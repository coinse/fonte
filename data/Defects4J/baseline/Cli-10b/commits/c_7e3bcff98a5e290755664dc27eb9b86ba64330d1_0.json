{"sha": "7e3bcff98a5e290755664dc27eb9b86ba64330d1", "log": "javadoc and checkstyle fixes   ", "commit": "\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n         return options.containsKey( opt );\n     }\n \n+    /**\n+     * @param opt the name of the option\n+     * @return the type of opt\n+     */\n     public Object getOptionObject(String opt) {\n-        String[] result = (String[])options.get( opt );\n+        String res = getOptionValue( opt );\n         Object type = types.get( opt );\n-        String res = result == null ? null : result[0];\n-        if(res == null) {\n-            return null;\n-        }\n-        return TypeHandler.createValue(res, type);\n+        return res == null ? null : TypeHandler.createValue(res, type);\n     }\n \n     /** <p>Retrieve the argument, if any,  of an option.</p>\n      *\n-     * @param opt Short single-character name of the option\n+     * @param opt the name of the option\n      * @return Value of the argument if option is set, and has an argument, else null.\n      */\n     public String getOptionValue(String opt) {\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n /*\n- * Copyright (C) The Apache Software Foundation. All rights reserved.\n- *\n- * This software is published under the terms of the Apache Software License\n- * version 1.1, a copy of which has been included with this distribution in\n- * the LICENSE file.\n- * \n- * $Id: HelpFormatter.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/CommandLine.java,v 1.4 2002/06/06 22:32:37 bayard Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/06 22:32:37 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n  */\n+\n package org.apache.commons.cli;\n \n import java.io.PrintWriter;\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n         this.type         = type;\n     }\n     \n-    /** <p>Retrieve the single-character name of this Option</p>\n+    /** <p>Retrieve the name of this Option</p>\n      *\n      * <p>It is this character which can be used with\n      * {@link CommandLine#hasOption(String opt)} and\n      * {@link CommandLine#getOptionValue(String opt)} to check\n      * for existence and argument.<p>\n      *\n-     * @return Single character name of this option\n+     * @return The name of this option\n      */\n     public String getOpt() {\n         return this.opt;\n     }\n \n+    /**\n+     * <p>Retrieve the type of this Option</p>\n+     * \n+     * @return The type of this option\n+     */\n     public Object getType() {\n         return this.type;\n     }\n--- a/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n \n     /// TODO: These need to break out to OptionType and also to be pluggable.\n \n-    static public final Class STRING_VALUE        = java.lang.String.class;\n-    static public final Class OBJECT_VALUE        = java.lang.Object.class;\n-    static public final Class NUMBER_VALUE        = java.lang.Number.class;\n-    static public final Class DATE_VALUE          = java.util.Date.class;\n-    static public final Class CLASS_VALUE         = java.lang.Class.class;\n+    /** String class */\n+    public static final Class STRING_VALUE        = java.lang.String.class;\n+    /** Object class */\n+    public static final Class OBJECT_VALUE        = java.lang.Object.class;\n+    /** Number class */\n+    public static final Class NUMBER_VALUE        = java.lang.Number.class;\n+    /** Date class */\n+    public static final Class DATE_VALUE          = java.util.Date.class;\n+    /** Class class */\n+    public static final Class CLASS_VALUE         = java.lang.Class.class;\n \n /// can we do this one?? \n // is meant to check that the file exists, else it errors.\n // ie) it's for reading not writing.\n-    static public final Class EXISTING_FILE_VALUE = java.io.FileInputStream.class;\n-    static public final Class FILE_VALUE          = java.io.File.class;\n-    static public final Class FILES_VALUE         = java.io.File[].class;\n-    static public final Class URL_VALUE           = java.net.URL.class;\n+    /** FileInputStream class */\n+    public static final Class EXISTING_FILE_VALUE = java.io.FileInputStream.class;\n+    /** File class */\n+    public static final Class FILE_VALUE          = java.io.File.class;\n+    /** File array class */\n+    public static final Class FILES_VALUE         = java.io.File[].class;\n+    /** URL class */\n+    public static final Class URL_VALUE           = java.net.URL.class;\n \n-    static public Object getValueClass(char ch) {\n+    /**\n+     * <p>Retrieve the class that <code>ch</code> represents.</p>\n+     *\n+     * @param ch the specified character\n+     * @return The class that <code>ch</code> represents\n+     */\n+    public static Object getValueClass(char ch) {\n         if (ch == '@') {\n             return PatternOptionBuilder.OBJECT_VALUE;\n         } else if (ch == ':') {\n         return null;\n     }\n  \n-    static public boolean isValueCode(char ch) {\n+    /**\n+     * <p>Returns whether <code>ch</code> is a value code, i.e.\n+     * whether it represents a class in a pattern.</p>\n+     * \n+     * @param ch the specified character\n+     * @return true if <code>ch</code> is a value code, otherwise false.\n+     */\n+    public static boolean isValueCode(char ch) {\n         if( (ch != '@') &&\n             (ch != ':') &&\n             (ch != '%') &&\n         return true;\n     }       \n  \n-    static public Options parsePattern(String pattern) {\n+    /**\n+     * <p>Returns the {@link Options} instance represented by \n+     * <code>pattern</code>.</p>\n+     *\n+     * @param pattern the pattern string\n+     * @return The {@link Options} instance\n+     */\n+    public static Options parsePattern(String pattern) {\n         int sz = pattern.length();\n \n         char opt = ' ';\n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n   */    \n public class TypeHandler {\n \n-    static public Object createValue(String str, Object obj) {\n+    /**\n+     * <p>Returns the <code>Object</code> of type <code>obj</code>\n+     * with the value of <code>str</code>.</p>\n+     *\n+     * @param str the command line value\n+     * @param obj the type of argument\n+     * @return The instance of <code>obj</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Object obj) {\n         return createValue(str, (Class)obj);\n     }\n-    static public Object createValue(String str, Class clazz) {\n+\n+    /**\n+     * <p>Returns the <code>Object</code> of type <code>clazz</code>\n+     * with the value of <code>str</code>.</p>\n+     *\n+     * @param str the command line value\n+     * @param clazz the type of argument\n+     * @return The instance of <code>clazz</code> initialised with\n+     * the value of <code>str</code>.\n+     */\n+    public static Object createValue(String str, Class clazz) {\n         if( PatternOptionBuilder.STRING_VALUE == clazz) {\n             return str;\n         } else\n     }\n \n     /**\n-      * Create an Object from the classname and empty constructor.\n-      * Returns null if it couldn't create the Object.\n+      * <p>Create an Object from the classname and empty constructor.</p>\n+      *\n+      * @param str the argument value\n+      * @return the initialised object, or null if it couldn't create the Object.\n       */\n-    static public Object createObject(String str) {\n+    public static Object createObject(String str) {\n         Class cl = null;\n         try {\n             cl = Class.forName(str);\n         try {\n             instance = cl.newInstance();\n         } catch (InstantiationException cnfe) {\n-            System.err.println(\"InstantiationException; Unable to create: \"+str);\n+            System.err.println(\"InstantiationException; Unable to create: \"+str);\n             return null;\n         }\n         catch (IllegalAccessException cnfe) {\n     }\n \n     /**\n-      * Create a number from a String.\n-      */\n-    static public Number createNumber(String str) {\n+     * <p>Create a number from a String.</p>\n+     *\n+     * @param str the value\n+     * @return the number represented by <code>str</code>, if <code>str</code>\n+     * is not a number, null is returned.\n+     */\n+    public static Number createNumber(String str) {\n         // Needs to be able to create\n         try {\n             // do searching for decimal point etc, but atm just make an Integer\n         }\n     }\n \n-    static public Class createClass(String str) {\n+    /**\n+     * <p>Returns the class whose name is <code>str</code>.</p>\n+     *\n+     * @param str the class name\n+     * @return The class if it is found, otherwise return null\n+     */\n+    public static Class createClass(String str) {\n         try {\n             return Class.forName(str);\n         } catch (ClassNotFoundException cnfe) {\n         }\n     }\n \n-    static public Date createDate(String str) {\n+    /**\n+     * <p>Returns the date represented by <code>str</code>.</p>\n+     *\n+     * @param str the date string\n+     * @return The date if <code>str</code> is a valid date string,\n+     * otherwise return null.\n+     */\n+    public static Date createDate(String str) {\n         Date date = null;\n         if(date == null) {\n             System.err.println(\"Unable to parse: \"+str);\n         return date;\n     }\n \n-    static public URL createURL(String str) {\n+    /**\n+     * <p>Returns the URL represented by <code>str</code>.</p>\n+     *\n+     * @param str the URL string\n+     * @return The URL is <code>str</code> is well-formed, otherwise\n+     * return null.\n+     */\n+    public static URL createURL(String str) {\n         try {\n             return new URL(str);\n         } catch (MalformedURLException mue) {\n         }\n     }\n \n-    static public File createFile(String str) {\n+    /**\n+     * <p>Returns the File represented by <code>str</code>.</p>\n+     *\n+     * @param str the File location\n+     * @return The file represented by <code>str</code>.\n+     */\n+    public static File createFile(String str) {\n         return new File(str);\n     }\n \n-    static public File[] createFiles(String str) {\n+    /**\n+     * <p>Returns the File[] represented by <code>str</code>.</p>\n+     *\n+     * @param str the paths to the files\n+     * @return The File[] represented by <code>str</code>.\n+     */\n+    public static File[] createFiles(String str) {\n // to implement/port:\n //        return FileW.findFiles(str);\n         return null;", "timestamp": 1026256335, "metainfo": ""}