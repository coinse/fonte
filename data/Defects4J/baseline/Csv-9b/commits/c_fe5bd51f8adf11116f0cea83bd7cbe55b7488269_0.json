{"sha": "fe5bd51f8adf11116f0cea83bd7cbe55b7488269", "log": "Applied patch contributed by Henri Yandell in SANDBOX-219: \"ExtendedBufferedReader does too much\"  ", "commit": "\n--- a/src/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/java/org/apache/commons/csv/ExtendedBufferedReader.java\n  * In particular the reader supports a look-ahead option,\n  * which allows you to see the next char returned by\n  * next().\n- * Furthermore the skip-method supports skipping until\n- * (but excluding) a given char. Similar functionality\n- * is supported by the reader as well.\n  * \n  */\n class ExtendedBufferedReader extends BufferedReader  {\n   }\n  \n  /**\n-  * Reads all characters up to (but not including) the given character.\n-  * \n-  * @param c the character to read up to\n-  * @return the string up to the character <code>c</code>\n-  * @throws IOException\n-  */\n- public String readUntil(char c) throws IOException {\n-   if (lookaheadChar == UNDEFINED) {\n-     lookaheadChar = super.read();\n-   }\n-   line.clear(); // reuse\n-   while (lookaheadChar != c && lookaheadChar != END_OF_STREAM) {\n-     line.append((char) lookaheadChar);\n-     if (lookaheadChar == '\\n') {\n-       lineCounter++;\n-     } \n-     lastChar = lookaheadChar;\n-     lookaheadChar = super.read();\n-   }\n-   return line.toString();    \n- }\n- \n- /**\n   * @return A String containing the contents of the line, not \n   *         including any line-termination characters, or null \n   *         if the end of the stream has been reached\n   }\n   \n   /**\n-   * Skips char in the stream\n-   * \n-   * ATTENTION: invalidates the line-counter !!!!!\n-   * \n-   * @return nof skiped chars\n+   * Unsupported\n    */\n   public long skip(long n) throws IllegalArgumentException, IOException  {\n-    \n-    if (lookaheadChar == UNDEFINED) {\n-      lookaheadChar = super.read();   \n-    }\n-    \n-    // illegal argument\n-    if (n < 0) {\n-      throw new IllegalArgumentException(\"negative argument not supported\");  \n-    }\n-    \n-    // no skipping\n-    if (n == 0 || lookaheadChar == END_OF_STREAM) {\n-      return 0;\n-    } \n-    \n-    // skip and reread the lookahead-char\n-    long skiped = 0;\n-    if (n > 1) {\n-      skiped = super.skip(n - 1);\n-    }\n-    lookaheadChar = super.read();\n-    // fixme uh: we should check the skiped sequence for line-terminations...\n-    lineCounter = Integer.MIN_VALUE;\n-    return skiped + 1;\n-  }\n-  \n-  /**\n-   * Skips all chars in the input until (but excluding) the given char\n-   * \n-   * @param c\n-   * @return\n-   * @throws IllegalArgumentException\n-   * @throws IOException\n-   */\n-  public long skipUntil(char c) throws IllegalArgumentException, IOException {\n-    if (lookaheadChar == UNDEFINED) {\n-      lookaheadChar = super.read();   \n-    }\n-    long counter = 0;\n-    while (lookaheadChar != c && lookaheadChar != END_OF_STREAM) {\n-      if (lookaheadChar == '\\n') {\n-        lineCounter++;\n-      } \n-      lookaheadChar = super.read();\n-      counter++;\n-    }\n-    return counter;\n+    throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n   }\n   \n   /**\n   \n   /**\n    * Returns the nof line read\n-   * ATTENTION: the skip-method does invalidate the line-number counter\n    * \n    * @return the current-line-number (or -1)\n    */ \n       return -1;\n     }\n   }\n+\n+  /**\n+   * Unsupported\n+   */\n   public boolean markSupported() {\n-    /* note uh: marking is not supported, cause we cannot\n-     *          see into the future...\n-     */\n-    return false;\n+    throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n   }\n   \n }\n--- a/src/test/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n  \n   }\n   \n-  public void testMarkSupported() {\n-    assertFalse(getEBR(\"foo\").markSupported());\n-  }\n-  \n   public void testReadLine() throws Exception {\n     ExtendedBufferedReader br = getEBR(\"\");\n     assertTrue(br.readLine() == null);\n     assertTrue(br.readLine() == null);\n   }\n   \n-  public void testSkip0() throws Exception {\n-    \n-    ExtendedBufferedReader br = getEBR(\"\");\n-    assertEquals(0, br.skip(0));\n-    assertEquals(0, br.skip(1));\n-    \n-    br = getEBR(\"\");\n-    assertEquals(0, br.skip(1));\n-    \n-    br = getEBR(\"abcdefg\");\n-    assertEquals(0, br.skip(0));\n-    assertEquals('a', br.lookAhead());\n-    assertEquals(0, br.skip(0));\n-    assertEquals('a', br.lookAhead());\n-    assertEquals(1, br.skip(1));\n-    assertEquals('b', br.lookAhead());\n-    assertEquals('b', br.read());\n-    assertEquals(3, br.skip(3));\n-    assertEquals('f', br.lookAhead());\n-    assertEquals(2, br.skip(5));\n-    assertTrue(br.readLine() == null);\n-    \n-    br = getEBR(\"12345\");\n-    assertEquals(5, br.skip(5));\n-    assertTrue (br.lookAhead() == ExtendedBufferedReader.END_OF_STREAM);\n-  }\n-  \n-  public void testSkipUntil() throws Exception {   \n-    ExtendedBufferedReader br = getEBR(\"\");\n-    assertEquals(0, br.skipUntil(';'));\n-    br = getEBR(\"ABCDEF,GHL,,MN\");\n-    assertEquals(6, br.skipUntil(','));\n-    assertEquals(0, br.skipUntil(','));\n-    br.skip(1);\n-    assertEquals(3, br.skipUntil(','));\n-    br.skip(1);\n-    assertEquals(0, br.skipUntil(','));\n-    br.skip(1);\n-    assertEquals(2, br.skipUntil(','));\n-  }\n-  \n-  public void testReadUntil() throws Exception {\n-    ExtendedBufferedReader br = getEBR(\"\");\n-    assertTrue(br.readUntil(';').equals(\"\"));\n-    br = getEBR(\"ABCDEF;GHL;;MN\");\n-    assertTrue(br.readUntil(';').equals(\"ABCDEF\"));\n-    assertTrue(br.readUntil(';').length() == 0);\n-    br.skip(1);\n-    assertTrue(br.readUntil(';').equals(\"GHL\"));\n-    br.skip(1);\n-    assertTrue(br.readUntil(';').equals(\"\"));\n-    br.skip(1);\n-    assertTrue(br.readUntil(',').equals(\"MN\"));\n-  }\n-  \n   private ExtendedBufferedReader getEBR(String s) {\n     return new ExtendedBufferedReader(new StringReader(s));\n   }", "timestamp": 1296548339, "metainfo": ""}