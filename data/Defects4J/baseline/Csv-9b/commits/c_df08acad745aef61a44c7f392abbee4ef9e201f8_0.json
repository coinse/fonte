{"sha": "df08acad745aef61a44c7f392abbee4ef9e201f8", "log": "Add org.apache.commons.csv.CSVFormat.CSVFormatBuilder.parse(Reader).  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n import java.util.Arrays;\n \n /**\n- * The format specification of a CSV file.\n+ * Specifies the format of a CSV file and parses input.\n  * <p>\n  * This class is immutable.\n  * </p>\n- * <p>\n  * You can extend a format through a builder. For example, to extend the Excel format with columns header, you write:\n  * </p>\n  * <pre>CSVFormat.EXCEL.toBuilder().withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).build();</pre>\n+ * <p>\n+ * You can parse through a format. For example, to parse an Excel file with columns header, you write:\n+ * </p>\n+ * <pre>Reader in = ...;\n+ *CSVFormat.EXCEL.toBuilder().withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);</pre>\n+ * <p>\n  * \n  * @version $Id$\n  */\n      *\n      * @param in\n      *            the input stream\n+     * @return a stream of CSVRecord\n      * @throws IOException\n      */\n     public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n         }\n \n         /**\n+         * Parses the specified content. Short-hand for:\n+         * <pre>format.build().parse(in);</pre>\n+         *\n+         * @param in\n+         *            the input stream\n+         * @return a CSVRecord stream\n+         * @throws IOException\n+         */\n+        public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n+            return this.build().parse(in);\n+        }\n+\n+        /**\n          * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n          *\n          * @throws IllegalStateException\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n         final CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n-        CSVFormat fmt = builder.build(); \n+        CSVFormat format = builder.build(); \n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n             final String[] option_parts = option.split(\"=\",2);\n             if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n-                fmt = builder.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1])).build();\n+                format = builder.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1])).build();\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n-                fmt = builder.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1])).build();\n+                format = builder.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1])).build();\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n-                fmt = builder.withCommentStart(option_parts[1].charAt(0)).build();\n+                format = builder.withCommentStart(option_parts[1].charAt(0)).build();\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n             }\n         }\n         line = readTestData(); // get string version of format\n-        assertEquals(testName+\" Expected format \", line, fmt.toString());\n+        assertEquals(testName+\" Expected format \", line, format.toString());\n \n         // Now parse the file and compare against the expected results\n-        for(final CSVRecord rec : fmt.parse(csvFile)) {\n-            String parsed = rec.toString();\n+        for(final CSVRecord record : format.parse(csvFile)) {\n+            String parsed = record.toString();\n             if (checkComments) {\n-                final String comment = rec.getComment().replace(\"\\n\", \"\\\\n\");\n+                final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n                 if (comment != null) {\n                     parsed += \"#\" + comment;\n                 }\n             }\n-            final int count = rec.size();\n+            final int count = record.size();\n             assertEquals(testName, readTestData(), count+\":\"+parsed);\n         }\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     public void testHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader().build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withCommentStart('#').withHeader().build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withCommentStart('#').withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testProvidedHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n         // header record\n         assertTrue(records.hasNext());", "timestamp": 1364314788, "metainfo": ""}