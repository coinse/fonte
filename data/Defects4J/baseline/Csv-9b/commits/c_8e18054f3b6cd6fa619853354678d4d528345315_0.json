{"sha": "8e18054f3b6cd6fa619853354678d4d528345315", "log": "Better ivar name.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     private final boolean ignoreEmptyLines;\n \n     /** The input stream */\n-    private final ExtendedBufferedReader in;\n+    private final ExtendedBufferedReader reader;\n \n     /** INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class */\n-    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n-        this.in = in;\n+    Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n+        this.reader = reader;\n         this.delimiter = format.getDelimiter();\n         this.escape = mapNullToDisabled(format.getEscape());\n         this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n     Token nextToken(final Token token) throws IOException {\n \n         // get the last read char (required for empty line detection)\n-        int lastChar = in.getLastChar();\n+        int lastChar = reader.getLastChar();\n \n         // read the next char and set eol\n-        int c = in.read();\n+        int c = reader.read();\n         /*\n          * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n          * - they are equivalent here.\n             while (eol && isStartOfLine(lastChar)) {\n                 // go on char ahead ...\n                 lastChar = c;\n-                c = in.read();\n+                c = reader.read();\n                 eol = readEndOfLine(c);\n                 // reached end of file without any content (empty line at the end)\n                 if (isEndOfFile(c)) {\n         }\n \n         if (isStartOfLine(lastChar) && isCommentStart(c)) {\n-            final String line = in.readLine();\n+            final String line = reader.readLine();\n             if (line == null) {\n                 token.type = EOF;\n                 // don't set token.isReady here because no content\n             // ignore whitespaces at beginning of a token\n             if (ignoreSurroundingSpaces) {\n                 while (isWhitespace(c) && !eol) {\n-                    c = in.read();\n+                    c = reader.read();\n                     eol = readEndOfLine(c);\n                 }\n             }\n             } else if (isEscape(ch)) {\n                 final int unescaped = readEscape();\n                 if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n-                    token.content.append((char) ch).append((char) in.getLastChar());\n+                    token.content.append((char) ch).append((char) reader.getLastChar());\n                 } else {\n                     token.content.append((char) unescaped);\n                 }\n-                ch = in.read(); // continue\n+                ch = reader.read(); // continue\n             } else {\n                 token.content.append((char) ch);\n-                ch = in.read(); // continue\n+                ch = reader.read(); // continue\n             }\n         }\n \n         final long startLineNumber = getCurrentLineNumber();\n         int c;\n         while (true) {\n-            c = in.read();\n+            c = reader.read();\n \n             if (isEscape(c)) {\n                 final int unescaped = readEscape();\n                 if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n-                    token.content.append((char) c).append((char) in.getLastChar());\n+                    token.content.append((char) c).append((char) reader.getLastChar());\n                 } else {\n                     token.content.append((char) unescaped);\n                 }\n             } else if (isQuoteChar(c)) {\n-                if (isQuoteChar(in.lookAhead())) {\n+                if (isQuoteChar(reader.lookAhead())) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n-                    c = in.read();\n+                    c = reader.read();\n                     token.content.append((char) c);\n                 } else {\n                     // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                     while (true) {\n-                        c = in.read();\n+                        c = reader.read();\n                         if (isDelimiter(c)) {\n                             token.type = TOKEN;\n                             return token;\n      * @return the current line number\n      */\n     long getCurrentLineNumber() {\n-        return in.getCurrentLineNumber();\n+        return reader.getCurrentLineNumber();\n     }\n \n     // TODO escape handling needs more work\n      */\n     int readEscape() throws IOException {\n         // the escape char has just been read (normally a backslash)\n-        final int ch = in.read();\n+        final int ch = reader.read();\n         switch (ch) {\n         case 'r':\n             return CR;\n      */\n     boolean readEndOfLine(int ch) throws IOException {\n         // check if we have \\r\\n...\n-        if (ch == CR && in.lookAhead() == LF) {\n+        if (ch == CR && reader.lookAhead() == LF) {\n             // note: does not change ch outside of this method!\n-            ch = in.read();\n+            ch = reader.read();\n         }\n         return ch == LF || ch == CR;\n     }\n \n     boolean isClosed() {\n-        return in.isClosed();\n+        return reader.isClosed();\n     }\n \n     /**\n      *             If an I/O error occurs\n      */\n     void close() throws IOException {\n-        in.close();\n+        reader.close();\n     }\n }", "timestamp": 1396706803, "metainfo": ""}