{"sha": "a0d975933d6fe9eb5f359088de43508c1d3109bf", "log": "[CSV-96] CSVRecord does not verify that the length of the header mapping matches the number of values - convert ArrayIndexOutOfBoundsException to IllegalArgumentException to give users a better feedback about what went wrong  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n \n     /**\n      * Returns a value by index.\n-     * \n+     *\n      * @param i\n      *            a column index (0-based)\n      * @return the String at the given index\n      * @return the column value, or {@code null} if the column name is not found\n      * @throws IllegalStateException\n      *             if no header mapping was provided\n+     * @throws IllegalArgumentException\n+     *             if the record is inconsistent\n+     * @see #isConsistent()\n      */\n     public String get(final String name) {\n         if (mapping == null) {\n                     \"No header mapping was specified, the record values can't be accessed by name\");\n         }\n         final Integer index = mapping.get(name);\n-        return index != null ? values[index.intValue()] : null;\n+        try {\n+            return index != null ? values[index.intValue()] : null;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(\n+                    String.format(\n+                            \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n+                            name, index.intValue(), values.length));\n+        }\n     }\n \n     /**\n      * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n      * the header size. Some programs can export files that fails this test but still produce parsable files.\n-     * \n+     *\n      * @return true of this record is valid, false if not\n      * @see CSVParserTest#org.apache.commons.csv.CSVParserTest.testMappedButNotSetAsOutlook2007ContactExport()\n      */\n     public boolean isConsistent() {\n         return mapping == null ? true : mapping.size() == values.length;\n     }\n-    \n+\n     /**\n      * Checks whether a given column is mapped.\n      *\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CSVRecordTest {\n+\n+    private String[] values;\n+    private CSVRecord record, recordWithHeader;\n+    private Map<String, Integer> header;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        values = new String[] { \"first\", \"second\", \"third\" };\n+        record = new CSVRecord(values, null, null, 0);\n+        header = new HashMap<String, Integer>();\n+        header.put(\"first\", Integer.valueOf(0));\n+        header.put(\"second\", Integer.valueOf(1));\n+        header.put(\"third\", Integer.valueOf(2));\n+        recordWithHeader = new CSVRecord(values, header, null, 0);\n+    }\n+\n+    @Test\n+    public void testGetInt() {\n+        assertEquals(values[0], record.get(0));\n+        assertEquals(values[1], record.get(1));\n+        assertEquals(values[2], record.get(2));\n+    }\n+\n+    @Test\n+    public void testGetString() {\n+        assertEquals(values[0], recordWithHeader.get(\"first\"));\n+        assertEquals(values[1], recordWithHeader.get(\"second\"));\n+        assertEquals(values[2], recordWithHeader.get(\"third\"));\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testGetStringNoHeader() {\n+        record.get(\"first\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testGetStringInconsistentRecord() {\n+        header.put(\"fourth\", Integer.valueOf(4));\n+        recordWithHeader.get(\"fourth\");\n+    }\n+\n+    @Test\n+    public void testIsConsistent() {\n+        assertTrue(record.isConsistent());\n+        assertTrue(recordWithHeader.isConsistent());\n+\n+        header.put(\"fourth\", Integer.valueOf(4));\n+        assertFalse(recordWithHeader.isConsistent());\n+    }\n+\n+    @Test\n+    public void testIsMapped() {\n+        assertFalse(record.isMapped(\"first\"));\n+        assertTrue(recordWithHeader.isMapped(\"first\"));\n+        assertFalse(recordWithHeader.isMapped(\"fourth\"));\n+    }\n+\n+    @Test\n+    public void testIsSet() {\n+        assertFalse(record.isSet(\"first\"));\n+        assertTrue(recordWithHeader.isSet(\"first\"));\n+        assertFalse(recordWithHeader.isSet(\"fourth\"));\n+    }\n+\n+    @Test\n+    public void testIterator() {\n+        int i = 0;\n+        for (Iterator<String> itr = record.iterator(); itr.hasNext();) {\n+            String value = itr.next();\n+            assertEquals(values[i], value);\n+            i++;\n+        }\n+    }\n+\n+}", "timestamp": 1365449678, "metainfo": ""}