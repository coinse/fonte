{"sha": "43a39b308abfbe39ea06729277d0630786b9956d", "log": "Added javadocs for Evaluators. Updated tests. Updated parser", "commit": "\n--- a/src/main/java/org/jsoup/select/ng/AndSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/AndSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Sequencing 'and' evaluator.\n+ * Matches only if all underlying evaluators have matched\n+ * @author ant\n+ *\n+ */\n public class AndSelector extends Evaluator {\n \tList<Evaluator> selectors;\n \n--- a/src/main/java/org/jsoup/select/ng/ElementSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ElementSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Evaluator for matching elements\n+ * Designed to be faster than separated chained Tag/Class/Id evaluators\n+ * @author ant\n+ *\n+ */\n public class ElementSelector extends Evaluator {\n \tString tag;\n \tString cls;\n--- a/src/main/java/org/jsoup/select/ng/HasSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/HasSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Evaluator for :has() construction\n+ * Matches if element's descendents matches underlying evaluator\n+ * @author ant\n+ *\n+ */\n public class HasSelector extends Evaluator {\n \tEvaluator sel;\n \t\n--- a/src/main/java/org/jsoup/select/ng/ImmediateParentSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ImmediateParentSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Tree-based evaluator for matching Element's immediate parent.\n+ * For evaluating 'E > F' construction\n+ * @author ant\n+ *\n+ */\n public class ImmediateParentSelector extends Evaluator {\n \tEvaluator sel;\n \t\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/ng/ImmediatePreviousSiblingSelector.java\n+package org.jsoup.select.ng;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching Element's immediate previous sibling.\n+ * For evaluating 'E + F' construction\n+ * @author ant\n+ *\n+ */\n+public class ImmediatePreviousSiblingSelector extends Evaluator {\n+\tEvaluator sel;\n+\t\n+\tpublic ImmediatePreviousSiblingSelector(Evaluator sel) {\n+\t\tthis.sel = sel;\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(Element root, Element element) {\n+\t\tif(root == element)\n+\t\t\treturn false;\n+\n+\t\t\n+\t\tElement prev = element.previousElementSibling();\n+\t\t\n+\t\tif(prev != null && sel.matches(root, prev))\n+\t\t\treturn true;\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\":prev%s\", sel);\n+\t}\n+\n+\n+}\n--- a/src/main/java/org/jsoup/select/ng/NotSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/NotSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Logical 'not' evaluator. Matches only if underlying evaluator didn't match.\n+ * @author ant\n+ *\n+ */\n public class NotSelector extends Evaluator {\n \tEvaluator sel;\n \t\n--- a/src/main/java/org/jsoup/select/ng/OrSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/OrSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Sequencing 'or' evaluator.\n+ * Matches only if any underlying evaluators have matched\n+ * @author ant\n+ *\n+ */\n public class OrSelector extends Evaluator {\n \tList<Evaluator> selectors;\n \n--- a/src/main/java/org/jsoup/select/ng/ParentSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/ParentSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Tree-based evaluator for matching any of Element's parents.\n+ * For evaluating 'E F' construction\n+ * @author ant\n+ *\n+ */\n public class ParentSelector extends Evaluator {\n \tEvaluator sel;\n \t\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/ng/PrevioustSiblingSelector.java\n+package org.jsoup.select.ng;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching Element's parent.\n+ * For evaluating 'E ~ F' construction\n+ * @author ant\n+ *\n+ */\n+public class PrevioustSiblingSelector extends Evaluator {\n+\tEvaluator sel;\n+\t\n+\t\n+\n+\tpublic PrevioustSiblingSelector(Evaluator sel) {\n+\t\tthis.sel = sel;\n+\t}\n+\n+\n+\n+\t@Override\n+\tpublic boolean matches(Element root, Element element) {\n+\t\tif(root == element)\n+\t\t\treturn false;\n+\t\t\n+\t\tElement prev = element.previousElementSibling();\n+\t\t\n+\t\twhile(prev != null) {\n+\t\t\tif(sel.matches(root, prev))\n+\t\t\t\treturn true;\n+\t\t\t\n+\t\t\tprev = prev.previousElementSibling();\n+\t\t}\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\":prev*%s\", sel);\n+\t}\n+\n+\n+}\n--- a/src/main/java/org/jsoup/select/ng/RootSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/RootSelector.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n \n+/**\n+ * Root matcher matches only on root node\n+ * @author ant\n+ *\n+ */\n public class RootSelector extends Evaluator {\n \n \t@Override\n--- a/src/main/java/org/jsoup/select/ng/parser/Parser.java\n+++ b/src/main/java/org/jsoup/select/ng/parser/Parser.java\n import org.jsoup.select.ng.NotSelector;\n import org.jsoup.select.ng.OrSelector;\n import org.jsoup.select.ng.ParentSelector;\n-import org.jsoup.select.ng.PrevSiblingSelector;\n-import org.jsoup.select.ng.PreviousSequentSiblingSelector;\n+import org.jsoup.select.ng.ImmediatePreviousSiblingSelector;\n+import org.jsoup.select.ng.PrevioustSiblingSelector;\n import org.jsoup.select.ng.RootSelector;\n import org.jsoup.select.ng.SelectMatch;\n \n         tq.consumeWhitespace();\n         \n         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n-            //elements.add(root);\n         \ts.add(new RootSelector());\n             combinator(tq.consume());\n         } else if (tq.matches(\":has(\")) {\n-            //elements.addAll(root.getAllElements());\n         } else {\n-            //addElements(findElements()); // chomp first element matcher off queue \n         \tfindElements();\n         }            \n                \n             if (tq.matchChomp(\",\")) { // group or\n             \tOrSelector or = new OrSelector(s);\n             \ts.clear();\n-            \t//s.push(or);\n             \ts.add(or);\n             \twhile (!tq.isEmpty()) {\n                     String subQuery = tq.chompTo(\",\");\n         } else if (combinator == ' ') {\n         \ts.add(BasicSelector.and(f, new ParentSelector(e)));\n         } else if (combinator == '+') {\n-        \ts.add(BasicSelector.and(f, new PrevSiblingSelector(e)));\n+        \ts.add(BasicSelector.and(f, new ImmediatePreviousSiblingSelector(e)));\n         } else if (combinator == '~') {\n-        \ts.add(BasicSelector.and(f, new PreviousSequentSiblingSelector(e)));\n+        \ts.add(BasicSelector.and(f, new PrevioustSiblingSelector(e)));\n         } else\n             throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n         \n     private void byId() {\n         String id = tq.consumeCssIdentifier();\n         Validate.notEmpty(id);\n-        ecPush(new Evaluator.Id(id));\n+        s.add(new Evaluator.Id(id));\n     }\n \n     private void byClass() {\n         String className = tq.consumeCssIdentifier();\n         Validate.notEmpty(className);\n-        ecPush(new Evaluator.Class(className.trim().toLowerCase()));\n+        s.add(new Evaluator.Class(className.trim().toLowerCase()));\n     }\n \n     private void byTag() {\n         if (tagName.contains(\"|\"))\n             tagName = tagName.replace(\"|\", \":\");\n         \n-        ecPush(new Evaluator.Tag(tagName.trim().toLowerCase()));\n+        s.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n     }\n \n     private void byAttribute() {\n \n         if (cq.isEmpty()) {\n             if(key.startsWith(\"^\"))\n-            \tecPush(new Evaluator.AttributeStarting(key.substring(1)));\n+            \ts.add(new Evaluator.AttributeStarting(key.substring(1)));\n             else\n-            \tecPush(new Evaluator.Attribute(key));\n+            \ts.add(new Evaluator.Attribute(key));\n         } else {\n             if (cq.matchChomp(\"=\"))\n-            \tecPush(new Evaluator.AttributeWithValue(key, cq.remainder()));\n+            \ts.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"!=\"))\n-                ecPush(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n+                s.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"^=\"))\n-            \tecPush(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n+            \ts.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"$=\"))\n-            \tecPush(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n+            \ts.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"*=\"))\n-            \tecPush(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n+            \ts.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n             \n             else if (cq.matchChomp(\"~=\"))\n-            \tecPush(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n+            \ts.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n             else\n                 throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n         }\n     // pseudo selectors :lt, :gt, :eq\n     private void indexLessThan() {\n     \t\n-        ecPush(new Evaluator.IndexLessThan(consumeIndex()));\n+        s.add(new Evaluator.IndexLessThan(consumeIndex()));\n     }\n     \n     private void indexGreaterThan() {\n-    \tecPush(new Evaluator.IndexGreaterThan(consumeIndex()));\n+    \ts.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n     }\n     \n     private void indexEquals() {\n-    \tecPush(new Evaluator.IndexEquals(consumeIndex()));\n+    \ts.add(new Evaluator.IndexEquals(consumeIndex()));\n     }\n \n     private int consumeIndex() {\n     }\n \n \n-    public static class SelectorParseException extends IllegalStateException {\n+\tpublic static class SelectorParseException extends IllegalStateException {\n         public SelectorParseException(String msg, Object... params) {\n             super(String.format(msg, params));\n         }\n     }\n-    \n-    void ecPush(Evaluator e) {\n-    \t/*Evaluator p = s.peek();\n-\n-    \tif(p == null || !(p instanceof ElementContainerSelector)) {\n-    \t\ts.push(new ElementContainerSelector().add(e));\n-    \t\treturn;\n-    \t}\n-    \t\n-    \tElementContainerSelector ec = (ElementContainerSelector) p;*/\n-    \t//ec.add(e);\n-    \ts.add(e);\n-    }\n-\n     \n     public static void main(String[] args) {\n         // make sure doesn't get nested\n--- a/src/test/java/org/jsoup/select/SelectorNGTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorNGTest.java\n import org.jsoup.select.ng.BasicSelector;\n import org.jsoup.select.ng.ElementSelector;\n import org.jsoup.select.ng.ImmediateParentSelector;\n-import org.jsoup.select.ng.PrevSiblingSelector;\n+import org.jsoup.select.ng.ImmediatePreviousSiblingSelector;\n import org.jsoup.select.ng.ParentSelector;\n import org.jsoup.select.ng.SelectMatch;\n-import org.jsoup.select.ng.PreviousSequentSiblingSelector;\n+import org.jsoup.select.ng.PrevioustSiblingSelector;\n import org.junit.Test;\n \n public class SelectorNGTest extends TestCase {\n         String h = \"<ol><li>One<li>Two<li>Three</ol>\";\n         Document doc = Jsoup.parse(h);\n         Elements sibs = SelectMatch.match(doc, new Evaluator.Tag(\"li\"), \n-        \t\tnew PrevSiblingSelector(new Evaluator.Tag(\"li\"))); //\"li + li\");\n+        \t\tnew ImmediatePreviousSiblingSelector(new Evaluator.Tag(\"li\"))); //\"li + li\");\n         assertEquals(2, sibs.size());\n         assertEquals(\"Two\", sibs.get(0).text());\n         assertEquals(\"Three\", sibs.get(1).text());\n         String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n         Document doc = Jsoup.parse(h);\n         Elements sibs = SelectMatch.match(doc, new ElementSelector(\"li\", null, \"2\"),\n-        \t\tnew PrevSiblingSelector(new ElementSelector(\"li\", null, \"1\")));//doc.select(\"li#1 + li#2\");\n+        \t\tnew ImmediatePreviousSiblingSelector(new ElementSelector(\"li\", null, \"1\")));//doc.select(\"li#1 + li#2\");\n         assertEquals(1, sibs.size());\n         assertEquals(\"Two\", sibs.get(0).text());\n     }\n         String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n         Document doc = Jsoup.parse(h);\n         Elements sibs = SelectMatch.match(doc, new ElementSelector(\"li\", null, \"3\"),\n-        \t\tnew PrevSiblingSelector(new ElementSelector(\"li\", null, \"1\")));//doc.select(\"li#1 + li#2\");//doc.select(\"li#1 + li#3\");\n+        \t\tnew ImmediatePreviousSiblingSelector(new ElementSelector(\"li\", null, \"1\")));//doc.select(\"li#1 + li#2\");//doc.select(\"li#1 + li#3\");\n         assertEquals(0, sibs.size());\n     }\n     \n     public void testGeneralSiblings() {\n         String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n         Document doc = Jsoup.parse(h);\n-        Elements els = SelectMatch.match(doc, new Evaluator.Id(\"3\"), new PreviousSequentSiblingSelector(new Evaluator.Id(\"1\")));//doc.select(\"#1 ~ #3\");\n+        Elements els = SelectMatch.match(doc, new Evaluator.Id(\"3\"), new PrevioustSiblingSelector(new Evaluator.Id(\"1\")));//doc.select(\"#1 ~ #3\");\n         assertEquals(1, els.size());\n         assertEquals(\"Three\", els.first().text());\n     }", "timestamp": 1309605125, "metainfo": ""}