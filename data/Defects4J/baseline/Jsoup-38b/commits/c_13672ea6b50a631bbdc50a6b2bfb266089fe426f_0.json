{"sha": "13672ea6b50a631bbdc50a6b2bfb266089fe426f", "log": "JavaDoc update", "commit": "\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n public class DocumentType extends Node {\n     // todo: quirk mode from publicId and systemId\n \n-    private DocumentType() {}\n-\n+    /**\n+     * Create a new doctype element.\n+     * @param name the doctype's name\n+     * @param publicId the doctype's public ID\n+     * @param systemId the doctype's system ID\n+     * @param baseUri the doctype's base URI\n+     */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n--- a/src/main/java/org/jsoup/parser/ParseError.java\n+++ b/src/main/java/org/jsoup/parser/ParseError.java\n package org.jsoup.parser;\n \n /**\n+ * A Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.\n  */\n-public class ParseError {\n+// todo: currently not ready for public consumption. revisit api, and exposure methods\n+class ParseError {\n     private String errorMsg;\n     private int pos;\n     private char c;\n     private TreeBuilderState treeBuilderState;\n     private Token token;\n \n-    public ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {\n+    ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {\n         this.errorMsg = errorMsg;\n         this.c = c;\n         this.tokeniserState = tokeniserState;\n         this.pos = pos;\n     }\n \n-    public ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {\n+    ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {\n         this.errorMsg = errorMsg;\n         this.tokeniserState = tokeniserState;\n         this.pos = pos;\n     }\n \n-    public ParseError(String errorMsg, int pos) {\n+    ParseError(String errorMsg, int pos) {\n         this.errorMsg = errorMsg;\n         this.pos = pos;\n     }\n \n-    public ParseError(String errorMsg, TreeBuilderState treeBuilderState, Token token, int pos) {\n+    ParseError(String errorMsg, TreeBuilderState treeBuilderState, Token token, int pos) {\n         this.errorMsg = errorMsg;\n         this.treeBuilderState = treeBuilderState;\n         this.token = token;\n         this.pos = pos;\n     }\n \n-    public String getErrorMsg() {\n+    String getErrorMsg() {\n         return errorMsg;\n     }\n \n-    public int getPos() {\n+    int getPos() {\n         return pos;\n     }\n }\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n \n     /**\n      * Case sensitive match test.\n-     * @param seq\n-     * @return\n+     * @param seq string to case sensitively check for\n+     * @return true if matched, false if not\n      */\n     public boolean matchesCS(String seq) {\n         return queue.startsWith(seq, pos);\n \n     /**\n      Tests if the next characters match any of the sequences. Case insensitive.\n-     @param seq\n-     @return\n+     @param seq list of strings to case insensitively check for\n+     @return true of any matched, false if none did\n      */\n     public boolean matchesAny(String... seq) {\n         for (String s : seq) {\n--- a/src/main/java/org/jsoup/parser/TreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.StringUtil;\n-import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.Arrays;\n import java.util.Iterator;\n import java.util.LinkedList;\n \n /**\n+ * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n  */\n-public enum TreeBuilderState {\n+enum TreeBuilderState {\n     Initial {\n         boolean process(Token t, TreeBuilder tb) {\n             if (isWhitespace(t)) {\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n \n     /**\n      * Get all of the parents and ancestor elements of the matched elements.\n-     * @return\n+     * @return all of the parents and ancestor elements of the matched elements\n      */\n     public Elements parents() {\n         HashSet<Element> combo = new LinkedHashSet<Element>();", "timestamp": 1309605129, "metainfo": ""}