{"sha": "c95216aa6e1f0dc5d39aea88624b05b953953d3d", "log": "Implemented comment handling.  Not very happy with token and parser. Would like to reimplement with some kind of expect / consumeTo behavior. Getting a bit too hacky.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Comment extends Node {\n-    private String data;\n+    private static final String COMMENT_KEY = \"comment\";\n \n-    protected Comment(Node parentNode) {\n-        super(parentNode, null);\n+    public Comment(Node parentNode, String data) {\n+        super(parentNode);\n+        attributes.put(COMMENT_KEY, data);\n     }\n \n     public String getNodeName() {\n     }\n \n     public String getData() {\n-        return data;\n+        return attributes.get(COMMENT_KEY);\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n /**\n         this.attributes = attributes;\n     }\n \n+    protected Node(Node parentNode) {\n+        this(parentNode, new Attributes());\n+    }\n+\n     public abstract String getNodeName();\n+\n+    public List<Node> getChildNodes() {\n+        return Collections.unmodifiableList(childNodes);\n+    }\n \n     public Node getParentNode() {\n         return parentNode;\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TextNode extends Node {\n-    private String text;\n-\n+    private static final String TEXT_KEY = \"text\";\n     public TextNode(Node parentNode, String text) {\n-        super(parentNode, null);\n-        this.text = text;\n+        super(parentNode);\n+        attributes.put(TEXT_KEY, text);\n     }\n \n     public String getNodeName() {\n     }\n \n     public String getWholeText() {\n-        return text;\n+        return attributes.get(TEXT_KEY);\n     }\n }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n         Document doc = new Document();\n         stack.add(doc);\n \n+        StringBuilder commentAccum = null;\n+\n         while (tokenStream.hasNext()) {\n             Token token = tokenStream.next();\n \n-            if (token.isStartTag()) {\n+            if (token.isFullComment()) { // <!-- comment -->\n+                Comment comment = new Comment(stack.peek(), token.getCommentData());\n+                stack.getLast().addChild(comment);\n+            } else if (token.isStartComment()) { // <!-- comment\n+                commentAccum = new StringBuilder(token.getCommentData());\n+            } else if (token.isEndComment() && commentAccum != null) { // comment -->\n+                commentAccum.append(token.getCommentData());\n+                Comment comment = new Comment(stack.peek(), commentAccum.toString());\n+                stack.getLast().addChild(comment);\n+                commentAccum = null;\n+            } else if (commentAccum != null) { // within a comment\n+                commentAccum.append(token.getData());\n+            }\n+\n+            else if (token.isStartTag()) {\n                 Attributes attributes = attributeParser.parse(token.getAttributeString());\n                 Tag tag = Tag.valueOf(token.getTagName());\n                 StartTag startTag = new StartTag(tag, attributes);\n                 stack.add(node);\n             }\n \n-            if (token.isEndTag()) { // empty tags are both start and end tags\n+            if (token.isEndTag() && commentAccum == null) { // empty tags are both start and end tags\n                 stack.removeLast();\n             }\n+\n+\n \n             // TODO[must] handle comments\n \n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n class Token {\n+    // match tags: <, opt space, opt closer, tagname, opt attribs, opt empty closer, >\n     private static final Pattern tagPattern = Pattern.compile(\"^<\\\\s*(/?)\\\\s*(\\\\w+)\\\\b\\\\s*(.*?)\\\\s*(/?)\\\\s*>$\");\n-    // pattern: <, opt space, opt closer, tagname, opt attribs, opt empty closer, >\n+    // match comments\n+    private static final Pattern commentFullPattern = Pattern.compile(\"^<!--\\\\s*(.*?)\\\\s*-?->$\");\n+    private static final Pattern commentStartPattern = Pattern.compile(\"^<!--\\\\s*(.*?)\\\\s*(-?->)?$\");\n+    private static final Pattern commentEndPattern = Pattern.compile(\"^(<!--)?\\\\s*(.*?)\\\\s*-?->$\");\n+\n \n     private String data;\n     private Position pos;\n \n     private boolean startTag;\n     private boolean endTag;\n+\n+    private boolean startComment;\n+    private boolean endComment;\n+    private String commentData;\n+\n     private boolean textNode;\n     private String tagName;\n     private String attributes;\n         this.pos = pos;\n \n         Matcher tagMatch = tagPattern.matcher(data);\n-        if (tagMatch.matches()) {\n+        Matcher commentFullMatch = commentFullPattern.matcher(data);\n+        Matcher commentStartMatch = commentStartPattern.matcher(data);\n+        Matcher commentEndMatch = commentEndPattern.matcher(data);\n+\n+        if (commentFullMatch.matches()) {\n+            startComment = true;\n+            endComment = true;\n+            commentData = commentFullMatch.group(1);\n+        }\n+        else if (commentStartMatch.matches()) {\n+            startComment = true;\n+            commentData = commentStartMatch.group(1);\n+        }\n+        else if (commentEndMatch.matches()) {\n+            endComment = true;\n+            commentData = commentEndMatch.group(2);\n+        } else if (!startComment && tagMatch.matches()) {\n             startTag = (tagMatch.group(1).isEmpty()); // 1: closer\n             endTag = (!tagMatch.group(1).isEmpty()) || (!tagMatch.group(4).isEmpty()); // 4: empty tag\n             tagName = tagMatch.group(2);\n             attributes = (tagMatch.group(3).isEmpty() ? null : tagMatch.group(3));\n         } else {\n-            // TODO: comments\n+            // TODO: xml decls, cdata\n             textNode = true;\n         }\n     }\n \n     public boolean isEndTag() {\n         return endTag;\n+    }\n+\n+    public boolean isStartComment() {\n+        return startComment;\n+    }\n+\n+    public boolean isEndComment() {\n+        return endComment;\n+    }\n+\n+    public boolean isFullComment() {\n+        return startComment && endComment;\n+    }\n+\n+    public String getCommentData() {\n+        return commentData;\n     }\n \n     public boolean isTextNode() {\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n package org.jsoup.parser;\n \n+import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.TextNode;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n         assertEquals(\"foo > bar\", p.getAttributes().get(\"class\"));\n         assertEquals(\"foo.png\", p.getChildren().get(0).getAttributes().get(\"src\"));\n     }\n+\n+    @Test public void testParsesComments() {\n+        TokenStream ts = TokenStream.create(\"<html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html>\");\n+        Document doc = new Parser(ts).parse();\n+        Element body = doc.getChildren().get(1);\n+        Comment comment = (Comment) body.getChildNodes().get(0);\n+        assertEquals(\"<table><tr><td></table>\", comment.getData());\n+        Element p = body.getChildren().get(0);\n+        TextNode text = (TextNode) p.getChildNodes().get(0);\n+        assertEquals(\"Hello\", text.getWholeText());\n+    }\n }", "timestamp": 1309605100, "metainfo": ""}