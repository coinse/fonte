{"sha": "8749726a79c22451b1f01b14fb2137f734e926b4", "log": "Reimplementation of parser and tokeniser, to make jsoup a HTML5 conformat parser, against the http://whatwg.org/html spec.", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n \n import java.io.*;\n import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n import java.nio.charset.Charset;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n      * @throws IOException on IO error\n      */\n     public static Document load(File in, String charsetName, String baseUri) throws IOException {\n-        InputStream inStream = null;\n+        FileInputStream inStream = null;\n         try {\n             inStream = new FileInputStream(in);\n-            return load(inStream, charsetName, baseUri);\n+            MappedByteBuffer byteData = inStream.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, in.length());\n+            return parseByteData(byteData, charsetName, baseUri);\n         } finally {\n             if (inStream != null)\n                 inStream.close();\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n         }\n         return modified ? sb.toString() : string;\n     }\n+\n+    public static boolean in(String needle, String... haystack) {\n+        for (String hay : haystack) {\n+            if (hay.equals(needle))\n+            return true;\n+        }\n+        return false;\n+    }\n }\n--- a/src/main/java/org/jsoup/helper/Validate.java\n+++ b/src/main/java/org/jsoup/helper/Validate.java\n     }\n \n     /**\n+     * Validates that the value is false\n+     * @param val object to test\n+     */\n+    public static void isFalse(boolean val) {\n+        if (val)\n+            throw new IllegalArgumentException(\"Must be false\");\n+    }\n+\n+    /**\n+     * Validates that the value is false\n+     * @param val object to test\n+     * @param msg message to output if validation fails\n+     */\n+    public static void isFalse(boolean val, String msg) {\n+        if (val)\n+            throw new IllegalArgumentException(msg);\n+    }\n+\n+    /**\n      * Validates that the array contains no null elements\n      * @param objects the array to test\n      */\n         if (string == null || string.length() == 0)\n             throw new IllegalArgumentException(msg);\n     }\n+\n+    /**\n+     Cause a failure.\n+     @param msg message to output.\n+     */\n+    public static void fail(String msg) {\n+        throw new IllegalArgumentException(msg);\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n     \n-    private LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>(2);\n+    private LinkedHashMap<String, Attribute> attributes = null;\n     // linked hash map to preserve insertion order.\n+    // null be default as so many elements have no attributes -- saves a good chunk of memory\n \n     /**\n      Get an attribute value by key.\n      */\n     public String get(String key) {\n         Validate.notEmpty(key);\n-        \n+\n+        if (attributes == null)\n+            return \"\";\n+\n         Attribute attr = attributes.get(key.toLowerCase());\n         return attr != null ? attr.getValue() : \"\";\n     }\n      */\n     public void put(Attribute attribute) {\n         Validate.notNull(attribute);\n+        if (attributes == null)\n+             attributes = new LinkedHashMap<String, Attribute>(2);\n         attributes.put(attribute.getKey(), attribute);\n     }\n \n      */\n     public void remove(String key) {\n         Validate.notEmpty(key);\n+        if (attributes == null)\n+            return;\n         attributes.remove(key.toLowerCase());\n     }\n \n      @return true if key exists, false otherwise\n      */\n     public boolean hasKey(String key) {\n-        return attributes.containsKey(key.toLowerCase());\n+        return attributes != null && attributes.containsKey(key.toLowerCase());\n     }\n \n     /**\n      @return size\n      */\n     public int size() {\n+        if (attributes == null)\n+            return 0;\n         return attributes.size();\n     }\n \n      @param incoming attributes to add to these attributes.\n      */\n     public void addAll(Attributes incoming) {\n+        if (incoming.size() == 0)\n+            return;\n+        if (attributes == null)\n+            attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n         attributes.putAll(incoming.attributes);\n     }\n     \n      @return an view of the attributes as a List.\n      */\n     public List<Attribute> asList() {\n+        if (attributes == null)\n+            return Collections.emptyList();\n+\n         List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             list.add(entry.getValue());\n     }\n     \n     void html(StringBuilder accum, Document.OutputSettings out) {\n+        if (attributes == null)\n+            return;\n+        \n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             Attribute attribute = entry.getValue();\n             accum.append(\" \");\n \n     @Override\n     public Attributes clone() {\n+        if (attributes == null)\n+            return new Attributes();\n+\n         Attributes clone;\n         try {\n             clone = (Attributes) super.clone();\n     }\n \n     private class Dataset extends AbstractMap<String, String> {\n+\n+        private Dataset() {\n+            if (attributes == null)\n+                attributes = new LinkedHashMap<String, Attribute>(2);\n+        }\n \n         public Set<Entry<String, String>> entrySet() {\n             return new EntrySet();\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Document extends Element {\n     private OutputSettings outputSettings = new OutputSettings();\n+    private QuirksMode quirksMode = QuirksMode.noQuirks;\n \n     /**\n      Create a new, empty Document.\n     public OutputSettings outputSettings() {\n         return outputSettings;\n     }\n+\n+    public enum QuirksMode {\n+        noQuirks, quirks, limitedQuirks;\n+    }\n+\n+    public QuirksMode quirksMode() {\n+        return quirksMode;\n+    }\n+\n+    public Document quirksMode(QuirksMode quirksMode) {\n+        this.quirksMode = quirksMode;\n+        return this;\n+    }\n }\n \n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n+package org.jsoup.nodes;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+/**\n+ * A {@code <!DOCTPYE>} node.\n+ */\n+public class DocumentType extends Node {\n+    // todo: quirk mode from publicId and systemId\n+\n+    private DocumentType() {}\n+\n+    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n+        super(baseUri);\n+\n+        attr(\"name\", name);\n+        attr(\"publicId\", publicId);\n+        attr(\"systemId\", systemId);\n+    }\n+\n+    @Override\n+    public String nodeName() {\n+        return \"#doctype\";\n+    }\n+\n+    @Override\n+    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+        accum.append(\"<!DOCTYPE html\");\n+        if (!StringUtil.isBlank(attr(\"publicId\")))\n+            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n+        if (!StringUtil.isBlank(attr(\"systemId\")))\n+            accum.append(' ').append(attr(\"systemId\")).append(\"\\\"\");\n+        accum.append('>');\n+    }\n+\n+    @Override\n+    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n     \n     /**\n-     * Add a node to the last child of this element.\n+     * Add a node child node to this element.\n      * \n      * @param child node to add. Must not already have a parent.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element append(String html) {\n         Validate.notNull(html);\n-        \n-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n-        addChildren(fragment.childNodesAsArray());\n+\n+        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n+        addChildren(nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n     \n     public Element prepend(String html) {\n         Validate.notNull(html);\n         \n-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n-        addChildren(0, fragment.childNodesAsArray());\n+        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n+        addChildren(0, nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n \n     }\n \n     /**\n+     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).\n+     * @param node to add before this element\n+     * @return this Element, for chaining\n+     * @see #after(Node)\n+     */\n+    @Override\n+    public Element before(Node node) {\n+        return (Element) super.before(node);\n+    }\n+\n+    /**\n      * Insert the specified HTML into the DOM after this element (i.e. as a following sibling).\n      *\n      * @param html HTML to add after this element\n     @Override\n     public Element after(String html) {\n         return (Element) super.after(html);\n+    }\n+\n+    /**\n+     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n+     * @param node to add after this element\n+     * @return this element, for chaining\n+     * @see #before(Node)\n+     */\n+    @Override\n+    public Element after(Node node) {\n+        return (Element) super.after(node);\n     }\n \n     /**\n      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n      */\n     public String className() {\n-        return attributes.hasKey(\"class\") ? attributes.get(\"class\") : \"\";\n+        return attr(\"class\");\n     }\n \n     /**\n \n     @Override\n     public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (!(o instanceof Element)) return false;\n-        if (!super.equals(o)) return false;\n-\n-        Element element = (Element) o;\n-\n-        if (tag != null ? !tag.equals(element.tag) : element.tag != null) return false;\n-\n-        return true;\n+        return this == o;\n     }\n \n     @Override\n     public int hashCode() {\n+        // todo: fixup, not very useful\n         int result = super.hashCode();\n         result = 31 * result + (tag != null ? tag.hashCode() : 0);\n         return result;\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n     private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\n     private static final Pattern strictUnescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);\");\n \n+    private Entities() {}\n+\n+    /**\n+     * Check if the input is a known named entity\n+     * @param name the possible entity name (e.g. \"lt\" or \"amp\"\n+     * @return true if a known named entity\n+     */\n+    public static boolean isNamedEntity(String name) {\n+        return full.containsKey(name);\n+    }\n+\n+    /**\n+     * Get the Character value of the named entity\n+     * @param name named entity (e.g. \"lt\" or \"amp\")\n+     * @return the Character value of the named entity (e.g. '<' or '&')\n+     */\n+    public static Character getCharacterByName(String name) {\n+        return full.get(name);\n+    }\n+    \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n      * @return\n      */\n     static String unescape(String string, boolean strict) {\n+        // todo: change this method to use Tokeniser.consumeCharacterReference\n         if (!string.contains(\"&\"))\n             return string;\n \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n-import org.jsoup.select.Elements;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n \n     /**\n      * Insert the specified HTML into the DOM before this node (i.e. as a preceeding sibling).\n-     * @param html HTML to add before this element\n+     * @param html HTML to add before this node\n      * @return this node, for chaining\n      * @see #after(String)\n      */\n     }\n \n     /**\n+     * Insert the specified node into the DOM before this node (i.e. as a preceeding sibling).\n+     * @param node to add before this node\n+     * @return this node, for chaining\n+     * @see #after(Node)\n+     */\n+    public Node before(Node node) {\n+        Validate.notNull(node);\n+        Validate.notNull(parentNode);\n+\n+        parentNode.addChildren(siblingIndex(), node);\n+        return this;\n+    }\n+\n+    /**\n      * Insert the specified HTML into the DOM after this node (i.e. as a following sibling).\n-     * @param html HTML to add after this element\n+     * @param html HTML to add after this node\n      * @return this node, for chaining\n      * @see #before(String)\n      */\n     public Node after(String html) {\n         addSiblingHtml(siblingIndex()+1, html);\n+        return this;\n+    }\n+\n+    /**\n+     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n+     * @param node to add after this node\n+     * @return this node, for chaining\n+     * @see #before(Node)\n+     */\n+    public Node after(Node node) {\n+        Validate.notNull(node);\n+        Validate.notNull(parentNode);\n+\n+        parentNode.addChildren(siblingIndex()+1, node);\n         return this;\n     }\n \n         Validate.notNull(html);\n         Validate.notNull(parentNode);\n \n-        Element fragment = Parser.parseBodyFragmentRelaxed(html, baseUri()).body();\n-        parentNode.addChildren(index, fragment.childNodesAsArray());\n+        Element context = parent() instanceof Element ? (Element) parent() : null;        \n+        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n+        parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n     }\n \n     /**\n     public Node wrap(String html) {\n         Validate.notEmpty(html);\n \n-        Element wrapBody = Parser.parseBodyFragmentRelaxed(html, baseUri).body();\n-        Elements wrapChildren = wrapBody.children();\n-        Element wrap = wrapChildren.first();\n-        if (wrap == null) // nothing to wrap with; noop\n+        Element context = parent() instanceof Element ? (Element) parent() : null;\n+        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n+        Node wrapNode = wrapChildren.get(0);\n+        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n             return null;\n \n+        Element wrap = (Element) wrapNode;\n         Element deepest = getDeepChild(wrap);\n         parentNode.replaceChild(this, wrap);\n         deepest.addChildren(this);\n \n         // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n-        if (wrapChildren.size() > 1) {\n-            for (int i = 1; i < wrapChildren.size(); i++) { // skip first\n-                Element remainder = wrapChildren.get(i);\n+        if (wrapChildren.size() > 0) {\n+            for (int i = 0; i < wrapChildren.size(); i++) {\n+                Node remainder = wrapChildren.get(i);\n                 remainder.parentNode.removeChild(remainder);\n                 wrap.appendChild(remainder);\n             }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n+package org.jsoup.parser;\n+\n+/**\n+ CharacterReader cosumes tokens off a string. To replace the old TokenQueue.\n+ */\n+class CharacterReader {\n+    static final char EOF = (char) -1;\n+\n+    private final String input;\n+    private final int length;\n+    private int pos = 0;\n+    private int mark = 0;\n+\n+    CharacterReader(String input) {\n+        this.input = input;\n+        this.length = input.length();\n+    }\n+\n+    int pos() {\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return pos >= length;\n+    }\n+\n+    char current() {\n+        return isEmpty() ? EOF : input.charAt(pos);\n+    }\n+\n+    char consume() {\n+        return isEmpty() ? EOF : input.charAt(pos++);\n+    }\n+\n+    void unconsume() {\n+        pos--;\n+    }\n+\n+    void advance() {\n+        pos++;\n+    }\n+\n+    void mark() {\n+        mark = pos;\n+    }\n+\n+    void rewindToMark() {\n+        pos = mark;\n+    }\n+\n+    String consumeAsString() {\n+        return input.substring(pos, pos++);\n+    }\n+\n+    String consumeTo(char c) {\n+        int offset = input.indexOf(c, pos);\n+        if (offset != -1) {\n+            String consumed = input.substring(pos, offset);\n+            pos += consumed.length();\n+            return consumed;\n+        } else {\n+            return consumeToEnd();\n+        }\n+    }\n+\n+    String consumeTo(String seq) {\n+        int offset = input.indexOf(seq, pos);\n+        if (offset != -1) {\n+            String consumed = input.substring(pos, offset);\n+            pos += consumed.length();\n+            return consumed;\n+        } else {\n+            return consumeToEnd();\n+        }\n+    }\n+\n+    String consumeToAny(char... seq) {\n+        int start = pos;\n+\n+        OUTER: while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            for (char seek : seq) {\n+                if (seek == c)\n+                    break OUTER;\n+            }\n+            pos++;\n+        }\n+\n+        return pos > start ? input.substring(start, pos) : \"\";\n+    }\n+\n+    String consumeToEnd() {\n+        String data = input.substring(pos, input.length() - 1);\n+        pos = input.length();\n+        return data;\n+    }\n+\n+    String consumeLetterSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n+                pos++;\n+            else\n+                break;\n+        }\n+\n+        return input.substring(start, pos);\n+    }\n+\n+    String consumeHexSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n+                pos++;\n+            else\n+                break;\n+        }\n+        return input.substring(start, pos);\n+    }\n+\n+    String consumeDigitSequence() {\n+        int start = pos;\n+        while (!isEmpty()) {\n+            char c = input.charAt(pos);\n+            if (c >= '0' && c <= '9')\n+                pos++;\n+            else\n+                break;\n+        }\n+        return input.substring(start, pos);\n+    }\n+\n+    boolean matches(char c) {\n+        return !isEmpty() && input.charAt(pos) == c;\n+\n+    }\n+\n+    boolean matches(String seq) {\n+        return input.startsWith(seq, pos);\n+    }\n+\n+    boolean matchesIgnoreCase(String seq) {\n+        return input.regionMatches(true, pos, seq, 0, seq.length());\n+    }\n+\n+    boolean matchesAny(char... seq) {\n+        if (isEmpty())\n+            return false;\n+\n+        char c = input.charAt(pos);\n+        for (char seek : seq) {\n+            if (seek == c)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean matchesLetter() {\n+        if (isEmpty())\n+            return false;\n+        char c = input.charAt(pos);\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n+    }\n+\n+    boolean matchesDigit() {\n+        if (isEmpty())\n+            return false;\n+        char c = input.charAt(pos);\n+        return (c >= '0' && c <= '9');\n+    }\n+\n+    boolean matchConsume(String seq) {\n+        if (matches(seq)) {\n+            pos += seq.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    boolean matchConsumeIgnoreCase(String seq) {\n+        if (matchesIgnoreCase(seq)) {\n+            pos += seq.length();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return input.substring(pos);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/ParseError.java\n+package org.jsoup.parser;\n+\n+/**\n+ */\n+public class ParseError {\n+    private String errorMsg;\n+    private int pos;\n+    private char c;\n+    private TokeniserState tokeniserState;\n+    private TreeBuilderState treeBuilderState;\n+    private Token token;\n+\n+    public ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {\n+        this.errorMsg = errorMsg;\n+        this.c = c;\n+        this.tokeniserState = tokeniserState;\n+        this.pos = pos;\n+    }\n+\n+    public ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {\n+        this.errorMsg = errorMsg;\n+        this.tokeniserState = tokeniserState;\n+        this.pos = pos;\n+    }\n+\n+    public ParseError(String errorMsg, int pos) {\n+        this.errorMsg = errorMsg;\n+        this.pos = pos;\n+    }\n+\n+    public ParseError(String errorMsg, TreeBuilderState treeBuilderState, Token token, int pos) {\n+        this.errorMsg = errorMsg;\n+        this.treeBuilderState = treeBuilderState;\n+        this.token = token;\n+        this.pos = pos;\n+    }\n+\n+    public String getErrorMsg() {\n+        return errorMsg;\n+    }\n+\n+    public int getPos() {\n+        return pos;\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n package org.jsoup.parser;\n \n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n \n-import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n-\n-import java.util.LinkedList;\n+import java.util.List;\n \n /**\n- Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the  more convenient parse methods\n+ * in {@link org.jsoup.Jsoup}.\n+ */\n public class Parser {\n-    private static final String SQ = \"'\";\n-    private static final String DQ = \"\\\"\";\n-\n-    private static final Tag htmlTag = Tag.valueOf(\"html\");\n-    private static final Tag headTag = Tag.valueOf(\"head\");\n-    private static final Tag bodyTag = Tag.valueOf(\"body\");\n-    private static final Tag titleTag = Tag.valueOf(\"title\");\n-    private static final Tag textareaTag = Tag.valueOf(\"textarea\");\n-\n-    private final LinkedList<Element> stack;\n-    private final TokenQueue tq;\n-    private final Document doc;\n-    private String baseUri;\n-    private boolean relaxed = false;\n-\n-    private Parser(String html, String baseUri, boolean isBodyFragment) {\n-        Validate.notNull(html);\n-        Validate.notNull(baseUri);\n-\n-        stack = new LinkedList<Element>();\n-        tq = new TokenQueue(html);\n-        this.baseUri = baseUri;\n-\n-        if (isBodyFragment) {\n-            doc = Document.createShell(baseUri);\n-            stack.add(doc.body());\n-        } else {\n-            doc = new Document(baseUri);\n-            stack.add(doc);\n-        }\n+    /**\n+     * Parse HTML into a Document.\n+     *\n+     * @param html HTML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return parsed Document\n+     */\n+    public static Document parse(String html, String baseUri) {\n+        TreeBuilder treeBuilder = new TreeBuilder();\n+        return treeBuilder.parse(html, baseUri);\n     }\n \n     /**\n-     Parse HTML into a Document.\n-     @param html HTML to parse\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return parsed Document\n+     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n+     *\n+     * @param fragmentHtml the fragment of HTML to parse\n+     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n+     * provides stack context (for implicit element creation).\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modifed.\n      */\n-    public static Document parse(String html, String baseUri) {\n-        Parser parser = new Parser(html, baseUri, false);\n-        return parser.parse();\n+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n+        TreeBuilder treeBuilder = new TreeBuilder();\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri);\n     }\n \n     /**\n-     Parse a fragment of HTML into the {@code body} of a Document.\n-     @param bodyHtml fragment of HTML\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return Document, with empty head, and HTML parsed into body\n+     * Parse a fragment of HTML into the {@code body} of a Document.\n+     *\n+     * @param bodyHtml fragment of HTML\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return Document, with empty head, and HTML parsed into body\n      */\n     public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n-        Parser parser = new Parser(bodyHtml, baseUri, true);\n-        return parser.parse();\n+        Document doc = Document.createShell(baseUri);\n+        Element body = doc.body();\n+        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n+        Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n+        for (Node node : nodes) {\n+            body.appendChild(node);\n+        }\n+        return doc;\n     }\n \n     /**\n-     Parse a fragment of HTML into the {@code body} of a Document, with relaxed parsing enabled. Relaxed, in this\n-     context, means that implicit tags are not automatically created when missing.\n-     @param bodyHtml fragment of HTML\n-     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n-     @return Document, with empty head, and HTML parsed into body\n+     * @param bodyHtml HTML to parse\n+     * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     *\n+     * @return parsed Document\n+     * @deprecated Use {@link #parseBodyFragment} or {@link #parseFragment} instead.\n      */\n     public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n-        Parser parser = new Parser(bodyHtml, baseUri, true);\n-        parser.relaxed = true;\n-        return parser.parse();\n-    }\n-\n-    private Document parse() {\n-        while (!tq.isEmpty()) {\n-            if (tq.matchesStartTag()) {\n-                parseStartTag();\n-            } else if (tq.matchesCS(\"</\")) {\n-                parseEndTag();\n-            } else if (tq.matchesCS(\"<!--\")) {\n-                parseComment();\n-            } else if (tq.matches(\"<![CDATA[\")) {\n-                parseCdata();\n-            } else if (tq.matchesCS(\"<?\") || tq.matchesCS(\"<!\")) {\n-                parseXmlDecl();\n-            } else {\n-                parseTextNode();\n-            }\n-        }\n-        return doc.normalise();\n-    }\n-\n-    private void parseComment() {\n-        tq.consume(\"<!--\");\n-        String data = tq.chompTo(\"->\");\n-\n-        if (data.endsWith(\"-\")) // i.e. was -->\n-            data = data.substring(0, data.length()-1);\n-        Comment comment = new Comment(data, baseUri);\n-        last().appendChild(comment);\n-    }\n-\n-    private void parseXmlDecl() {\n-        tq.consume(\"<\");\n-        Character firstChar = tq.consume(); // <? or <!, from initial match.\n-        boolean procInstr = firstChar.toString().equals(\"!\");\n-        String data = tq.chompTo(\">\");\n-\n-        XmlDeclaration decl = new XmlDeclaration(data, baseUri, procInstr);\n-        last().appendChild(decl);\n-    }\n-\n-    private void parseEndTag() {\n-        tq.consume(\"</\");\n-        String tagName = tq.consumeTagName();\n-        tq.chompTo(\">\");\n-\n-        if (tagName.length() != 0) {\n-            Tag tag = Tag.valueOf(tagName);\n-            if (!last().tag().isIgnorableEndTag(tag)) // skips </tr> if in <table>\n-                popStackToClose(tag);\n-        }\n-    }\n-\n-    private void parseStartTag() {\n-        tq.consume(\"<\");\n-        String tagName = tq.consumeTagName();\n-        Validate.notEmpty(tagName, \"Unexpectedly empty tagname. (This should not occur, please report!)\");\n-        \n-        tq.consumeWhitespace();\n-        Attributes attributes = new Attributes();\n-        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n-            Attribute attribute = parseAttribute();\n-            if (attribute != null)\n-                attributes.put(attribute);\n-        }\n-\n-        Tag tag = Tag.valueOf(tagName);\n-        Element child = new Element(tag, baseUri, attributes);\n-\n-        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n-        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n-            isEmptyElement = true;\n-            if (!tag.isKnownTag()) // if unknown and a self closed, allow it to be self closed on output. this doesn't force all instances to be empty\n-                tag.setSelfClosing();\n-        } else {\n-            tq.matchChomp(\">\");\n-        }\n-        addChildToParent(child, isEmptyElement);\n-\n-        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n-        if (tag.isData()) {\n-            String data = tq.chompToIgnoreCase(\"</\" + tagName);\n-            tq.chompTo(\">\");\n-            popStackToClose(tag);\n-            \n-            Node dataNode;\n-            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n-                dataNode = TextNode.createFromEncoded(data, baseUri);\n-            else\n-                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n-            child.appendChild(dataNode);   \n-        }\n-\n-        // <base href>: update the base uri\n-        if (child.tagName().equals(\"base\")) {\n-            String href = child.absUrl(\"href\");\n-            if (href.length() != 0) { // ignore <base target> etc\n-                baseUri = href;\n-                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n-            }\n-        }\n-    }\n-\n-    private Attribute parseAttribute() {\n-        tq.consumeWhitespace();\n-        String key = tq.consumeAttributeKey();\n-        String value = \"\";\n-        tq.consumeWhitespace();\n-        if (tq.matchChomp(\"=\")) {\n-            tq.consumeWhitespace();\n-\n-            if (tq.matchChomp(SQ)) {\n-                value = tq.chompTo(SQ);\n-            } else if (tq.matchChomp(DQ)) {\n-                value = tq.chompTo(DQ);\n-            } else {\n-                StringBuilder valueAccum = new StringBuilder();\n-                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n-                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n-                    valueAccum.append(tq.consume());\n-                }\n-                value = valueAccum.toString();\n-            }\n-            tq.consumeWhitespace();\n-        }\n-        if (key.length() != 0)\n-            return Attribute.createFromEncoded(key, value);\n-        else {\n-            if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck\n-                tq.advance();\n-                \n-            return null;\n-        }\n-    }\n-\n-    private void parseTextNode() {\n-        TextNode textNode;\n-        // special case: handle string like \"hello < there\". first char will be \"<\", because of matchStartTag\n-        if (tq.peek() == '<') {\n-            tq.advance();\n-            textNode = new TextNode(\"<\", baseUri);\n-        } else {\n-            String text = tq.consumeTo(\"<\");\n-            textNode = TextNode.createFromEncoded(text, baseUri);\n-        }\n-        last().appendChild(textNode);\n-    }\n-\n-    private void parseCdata() {\n-        tq.consume(\"<![CDATA[\");\n-        String rawText = tq.chompTo(\"]]>\");\n-        TextNode textNode = new TextNode(rawText, baseUri); // constructor does not escape\n-        last().appendChild(textNode);\n-    }\n-\n-    private Element addChildToParent(Element child, boolean isEmptyElement) {\n-        Element parent = popStackToSuitableContainer(child.tag());\n-        Tag childTag = child.tag();\n-        boolean validAncestor = stackHasValidParent(childTag);\n-\n-        if (!validAncestor && !relaxed) {\n-            // create implicit parent around this child\n-            Tag parentTag = childTag.getImplicitParent();\n-            Element implicit = new Element(parentTag, baseUri);\n-            // special case: make sure there's a head before putting in body\n-            if (child.tag().equals(bodyTag)) {\n-                Element head = new Element(headTag, baseUri);\n-                implicit.appendChild(head);\n-            }\n-            implicit.appendChild(child);\n-\n-            // recurse to ensure somewhere to put parent\n-            Element root = addChildToParent(implicit, false);\n-            if (!isEmptyElement)\n-                stack.addLast(child);\n-            return root;\n-        }\n-\n-        parent.appendChild(child);\n-\n-        if (!isEmptyElement)\n-            stack.addLast(child);\n-        return parent;\n-    }\n-\n-    private boolean stackHasValidParent(Tag childTag) {\n-        if (stack.size() == 1 && childTag.equals(htmlTag))\n-            return true; // root is valid for html node\n-\n-        if (childTag.requiresSpecificParent())\n-            return stack.getLast().tag().isValidParent(childTag);\n-\n-        // otherwise, look up the stack for valid ancestors\n-        for (int i = stack.size() -1; i >= 0; i--) {\n-            Element el = stack.get(i);\n-            Tag parent2 = el.tag();\n-            if (parent2.isValidAncestor(childTag)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private Element popStackToSuitableContainer(Tag tag) {\n-        while (!stack.isEmpty()) {\n-            if (last().tag().canContain(tag))\n-                return last();\n-            else\n-                stack.removeLast();\n-        }\n-        return null;\n-    }\n-\n-    private Element popStackToClose(Tag tag) {\n-        // first check to see if stack contains this tag; if so pop to there, otherwise ignore\n-        int counter = 0;\n-        Element elToClose = null;\n-        for (int i = stack.size() -1; i > 0; i--) {\n-            counter++;\n-            Element el = stack.get(i);\n-            Tag elTag = el.tag();\n-            if (elTag.equals(bodyTag) || elTag.equals(htmlTag)) { // once in body, don't close past body\n-                break;\n-            } else if (elTag.equals(tag)) {\n-                elToClose = el;\n-                break;\n-            }\n-        }\n-        if (elToClose != null) {\n-            for (int i = 0; i < counter; i++) {\n-                stack.removeLast();\n-            }\n-        }\n-        return elToClose;\n-    }\n-\n-    private Element last() {\n-        return stack.getLast();\n+        return parse(bodyHtml, baseUri);\n     }\n }\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n import org.jsoup.helper.Validate;\n \n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n- HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,\n- but it should capture most of what we need to know to intelligently parse a doc.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * HTML Tag capabilities.\n+ *\n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ */\n public class Tag {\n-    private static final Map<String, Tag> tags = new HashMap<String, Tag>();\n-    private static final Tag defaultAncestor;\n-    static {\n-        defaultAncestor = new Tag(\"BODY\");\n-        tags.put(defaultAncestor.tagName, defaultAncestor);\n-    }\n+    private static final Map<String, Tag> tags = new HashMap<String, Tag>(); // map of known tags\n \n     private String tagName;\n-    private boolean knownTag = false; // if pre-defined or auto-created\n     private boolean isBlock = true; // block or inline\n-    private boolean formatAsBlock = true;\n+    private boolean formatAsBlock = true; // should be formatted as a block\n     private boolean canContainBlock = true; // Can this tag hold block level tags?\n     private boolean canContainInline = true; // only pcdata if not\n-    private boolean optionalClosing = false; // If tag is open, and another seen, close previous tag\n     private boolean empty = false; // can hold nothing; e.g. img\n     private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\n     private boolean preserveWhitespace = false; // for pre, textarea, script etc\n-    private List<Tag> ancestors; // elements must be a descendant of one of these ancestors\n-    private List<Tag> excludes = Collections.emptyList(); // cannot contain these tags\n-    private List<Tag> ignoreEndTags = Collections.emptyList(); // ignore these end tags\n-    private boolean directDescendant; // if true, must directly descend from one of the ancestors\n-    private boolean limitChildren; // if true, only contain children that've registered parents\n \n     private Tag(String tagName) {\n         this.tagName = tagName.toLowerCase();\n     }\n \n+    /**\n+     * Get this tag's name.\n+     *\n+     * @return the tag's name\n+     */\n     public String getName() {\n         return tagName;\n     }\n \n     /**\n-     Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n-     <p>\n-     Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n-     @param tagName Name of tag, e.g. \"p\". Case insensitive.\n-     @return The tag, either defined or new generic.\n+     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n+     * <p/>\n+     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n+     *\n+     * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n+     * @return The tag, either defined or new generic.\n      */\n     public static Tag valueOf(String tagName) {\n         Validate.notNull(tagName);\n             if (tag == null) {\n                 // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n                 tag = new Tag(tagName);\n-                tag.setAncestor(defaultAncestor.tagName);\n-                tag.setExcludes();\n                 tag.isBlock = false;\n                 tag.canContainBlock = true;\n             }\n     }\n \n     /**\n-     Test if this tag, the prospective parent, can accept the proposed child.\n-     @param child potential child tag.\n-     @return true if this can contain child.\n-     */\n-    boolean canContain(Tag child) {\n-        Validate.notNull(child);\n-\n-        if (child.isBlock && !this.canContainBlock)\n-            return false;\n-\n-        if (!child.isBlock && !this.canContainInline) // not block == inline\n-            return false;\n-\n-        if (this.optionalClosing && this.equals(child))\n-            return false;\n-\n-        if (this.empty || this.isData())\n-            return false;\n-        \n-        // don't allow children to contain their parent (directly)\n-        if (this.requiresSpecificParent() && this.getImplicitParent().equals(child))\n-            return false;\n-\n-        // confirm limited children\n-        if (limitChildren) {\n-            for (Tag childParent : child.ancestors) {\n-                if (childParent.equals(this))\n-                    return true;\n-            }\n-            return false;\n-        }\n-        \n-        // exclude children\n-        if (!excludes.isEmpty()) {\n-            for (Tag excluded: excludes) {\n-                if (child.equals(excluded))\n-                    return false;\n-            }\n-        }\n-        \n-        return true;\n-    }\n-\n-    /**\n-     Gets if this is a block tag.\n-     @return if block tag\n+     * Gets if this is a block tag.\n+     *\n+     * @return if block tag\n      */\n     public boolean isBlock() {\n         return isBlock;\n \n     /**\n      * Gets if this tag should be formatted as a block (or as inline)\n+     *\n      * @return if should be formatted as block or inline\n      */\n     public boolean formatAsBlock() {\n     }\n \n     /**\n-     Gets if this tag can contain block tags.\n-     @return if tag can contain block tags\n+     * Gets if this tag can contain block tags.\n+     *\n+     * @return if tag can contain block tags\n      */\n     public boolean canContainBlock() {\n         return canContainBlock;\n     }\n \n     /**\n-     Gets if this tag is an inline tag.\n-     @return if this tag is an inline tag.\n+     * Gets if this tag is an inline tag.\n+     *\n+     * @return if this tag is an inline tag.\n      */\n     public boolean isInline() {\n         return !isBlock;\n     }\n \n     /**\n-     Gets if this tag is a data only tag.\n-     @return if this tag is a data only tag\n+     * Gets if this tag is a data only tag.\n+     *\n+     * @return if this tag is a data only tag\n      */\n     public boolean isData() {\n         return !canContainInline && !isEmpty();\n     }\n \n     /**\n-     Get if this is an empty tag\n-     @return if this is an emtpy tag\n+     * Get if this is an empty tag\n+     *\n+     * @return if this is an emtpy tag\n      */\n     public boolean isEmpty() {\n         return empty;\n     }\n-    \n+\n     /**\n      * Get if this tag is self closing.\n+     *\n      * @return if this tag should be output as self closing.\n      */\n     public boolean isSelfClosing() {\n         return empty || selfClosing;\n     }\n-    \n+\n     /**\n      * Get if this is a pre-defined tag, or was auto created on parsing.\n+     *\n      * @return if a known tag\n      */\n     public boolean isKnownTag() {\n-        return knownTag;\n-    }\n-\n-    /**\n-     Get if this tag should preserve whitespace within child text nodes.\n-     @return if preserve whitepace\n+        return tags.containsKey(tagName);\n+    }\n+\n+    /**\n+     * Check if this tagname is a known tag.\n+     *\n+     * @param tagName name of tag\n+     * @return if known HTML tag\n+     */\n+    public static boolean isKnownTag(String tagName) {\n+        return tags.containsKey(tagName);\n+    }\n+\n+    /**\n+     * Get if this tag should preserve whitespace within child text nodes.\n+     *\n+     * @return if preserve whitepace\n      */\n     public boolean preserveWhitespace() {\n         return preserveWhitespace;\n     }\n \n-    Tag getImplicitParent() {\n-        return (!ancestors.isEmpty()) ? ancestors.get(0) : null;\n-    }\n-\n-    boolean requiresSpecificParent() {\n-        return directDescendant;\n-    }\n-\n-    boolean isValidParent(Tag child) {\n-        return isValidAncestor(child);\n-    }\n-\n-    boolean isValidAncestor(Tag child) {\n-        if (child.ancestors.isEmpty())\n-            return true; // HTML tag\n-\n-        for (int i = 0; i < child.ancestors.size(); i++)\n-            if (this.equals(child.ancestors.get(i)))\n-                return true;\n-        \n-        return false;\n-    }\n-\n-    boolean isIgnorableEndTag(Tag child) {\n-        for (Tag endTag : ignoreEndTags) {\n-            if (child.equals(endTag))\n-                return true;\n-        }\n-        return false;        \n+    Tag setSelfClosing() {\n+        selfClosing = true;\n+        return this;\n     }\n \n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n+        if (!(o instanceof Tag)) return false;\n \n         Tag tag = (Tag) o;\n \n-        if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false;\n+        if (canContainBlock != tag.canContainBlock) return false;\n+        if (canContainInline != tag.canContainInline) return false;\n+        if (empty != tag.empty) return false;\n+        if (formatAsBlock != tag.formatAsBlock) return false;\n+        if (isBlock != tag.isBlock) return false;\n+        if (preserveWhitespace != tag.preserveWhitespace) return false;\n+        if (selfClosing != tag.selfClosing) return false;\n+        if (!tagName.equals(tag.tagName)) return false;\n \n         return true;\n     }\n \n     @Override\n     public int hashCode() {\n-        int result = tagName != null ? tagName.hashCode() : 0;\n+        int result = tagName.hashCode();\n         result = 31 * result + (isBlock ? 1 : 0);\n+        result = 31 * result + (formatAsBlock ? 1 : 0);\n         result = 31 * result + (canContainBlock ? 1 : 0);\n         result = 31 * result + (canContainInline ? 1 : 0);\n-        result = 31 * result + (optionalClosing ? 1 : 0);\n         result = 31 * result + (empty ? 1 : 0);\n+        result = 31 * result + (selfClosing ? 1 : 0);\n+        result = 31 * result + (preserveWhitespace ? 1 : 0);\n         return result;\n     }\n \n     }\n \n     // internal static initialisers:\n+    // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html and other sources\n+    private static final String[] blockTags = {\n+            \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n+            \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n+            \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n+            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n+    };\n+    private static final String[] inlineTags = {\n+            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n+            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n+            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n+            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n+            \"summary\", \"command\", \"device\"\n+    };\n+    private static final String[] emptyTags = {\n+            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n+            \"device\"\n+    };\n+    private static final String[] formatAsInlineTags = {\n+            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\"\n+    };\n+    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n \n     static {\n-        // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline\n-        // tags are set here in uppercase for legibility, but internally held as lowercase.\n-        // TODO[must]: incorporate html 5 as appropriate\n-\n-        // document\n-        createBlock(\"HTML\").setAncestor(); // specific includes not impl\n-        createBlock(\"HEAD\").setParent(\"HTML\").setLimitChildren();\n-        createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl\n-        createBlock(\"FRAMESET\").setAncestor(\"HTML\");\n-\n-        // head\n-        // all ancestors set to (head, body): so implicitly create head, but allow in body\n-        createBlock(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n-        createBlock(\"NOSCRIPT\").setAncestor(\"HEAD\", \"BODY\");\n-        createBlock(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n-        createBlock(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n-        createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head\n-        createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param\n-        createBlock(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly().setFormatAsInline();\n-        createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n-\n-        createBlock(\"FRAME\").setParent(\"FRAMESET\").setEmpty();\n-        createBlock(\"NOFRAMES\").setParent(\"FRAMESET\").setContainDataOnly();\n-\n-        // html5 sections\n-        createBlock(\"SECTION\");\n-        createBlock(\"NAV\");\n-        createBlock(\"ASIDE\");\n-        createBlock(\"HGROUP\").setLimitChildren(); // limited to h1 - h6\n-        createBlock(\"HEADER\").setExcludes(\"HEADER\", \"FOOTER\");\n-        createBlock(\"FOOTER\").setExcludes(\"HEADER\", \"FOOTER\");\n-\n-        // fontstyle\n-        createInline(\"FONT\").setOptionalClosing().setCanContainBlock().setFormatAsInline();\n-        createInline(\"TT\");\n-        createInline(\"I\");\n-        createInline(\"B\");\n-        createInline(\"U\");\n-        createInline(\"BIG\");\n-        createInline(\"SMALL\");\n-\n-        // phrase\n-        createInline(\"EM\");\n-        createInline(\"STRONG\");\n-        createInline(\"DFN\").setOptionalClosing();\n-        createInline(\"CODE\");\n-        createInline(\"SAMP\");\n-        createInline(\"KBD\");\n-        createInline(\"VAR\");\n-        createInline(\"CITE\");\n-        createInline(\"ABBR\");\n-        createInline(\"TIME\").setOptionalClosing();\n-        createInline(\"ACRONYM\");\n-        createInline(\"MARK\");\n-        \n-        // ruby\n-        createInline(\"RUBY\");\n-        createInline(\"RT\").setParent(\"RUBY\").setExcludes(\"RT\", \"RP\");\n-        createInline(\"RP\").setParent(\"RUBY\").setExcludes(\"RT\", \"RP\");\n-\n-        // special\n-        createInline(\"A\").setOptionalClosing().setCanContainBlock().setFormatAsInline(); // cannot contain self\n-        createInline(\"IMG\").setEmpty().setAncestor(\"BODY\", \"NOSCRIPT\"); // noscript so an image can be in html->head->noscript\n-        createInline(\"BR\").setEmpty();\n-        createInline(\"WBR\").setEmpty();\n-        createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.\n-        createInline(\"Q\");\n-        createInline(\"SUB\");\n-        createInline(\"SUP\");\n-        createInline(\"BDO\");\n-        createInline(\"IFRAME\").setOptionalClosing();\n-        createInline(\"EMBED\").setEmpty();\n-\n-        // things past this point aren't really blocks or inline. I'm using them because they can hold block or inline,\n-        // but per the spec, only specific elements can hold this. if this becomes a real-world parsing problem,\n-        // will need to have another non block/inline type, and explicit include & exclude rules. should be right though\n-\n-        // block\n-        createInline(\"SPAN\").setCanContainBlock().setFormatAsInline(); // spec is phrasing only, practise is block\n-        createBlock(\"P\").setContainInlineOnly(); // emasculated block?\n-        createBlock(\"H1\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"H2\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"H3\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"H4\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"H5\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"H6\").setAncestor(\"BODY\", \"HGROUP\").setExcludes(\"HGROUP\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\").setFormatAsInline();\n-        createBlock(\"UL\");\n-        createBlock(\"OL\");\n-        createBlock(\"PRE\").setContainInlineOnly().setPreserveWhitespace();\n-        createBlock(\"DIV\");\n-        createBlock(\"BLOCKQUOTE\");\n-        createBlock(\"HR\").setEmpty();\n-        createBlock(\"ADDRESS\").setContainInlineOnly();\n-        createBlock(\"FIGURE\");\n-        createBlock(\"FIGCAPTION\").setAncestor(\"FIGURE\");\n-\n-        // formctrl\n-        createBlock(\"FORM\").setOptionalClosing(); // can't contain self\n-        createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty();\n-        createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option\n-        createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();\n-        createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n-        createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n-        createInline(\"OPTGROUP\").setParent(\"SELECT\"); //  only contain option\n-        createInline(\"OPTION\").setParent(\"SELECT\", \"OPTGROUP\", \"DATALIST\").setOptionalClosing();\n-        createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n-        createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n-        \n-        // html5 form ctrl, not specced to have to be in forms\n-        createInline(\"DATALIST\");\n-        createInline(\"KEYGEN\").setEmpty();\n-        createInline(\"OUTPUT\");\n-        createInline(\"PROGRESS\").setOptionalClosing();\n-        createInline(\"METER\").setOptionalClosing();\n-\n-        // other\n-        createInline(\"AREA\").setAncestor(\"MAP\").setEmpty(); // not an inline per-se\n-        createInline(\"PARAM\").setParent(\"OBJECT\").setEmpty();\n-        createBlock(\"INS\"); // only within body\n-        createBlock(\"DEL\"); // only within body\n-\n-        // definition lists. per spec, dt and dd are inline and must directly descend from dl. However in practise\n-        // these are all used as blocks and dl need only be an ancestor\n-        createBlock(\"DL\").setOptionalClosing(); // can't nest\n-        createBlock(\"DT\").setAncestor(\"DL\").setExcludes(\"DL\", \"DD\").setOptionalClosing(); // only within DL.\n-        createBlock(\"DD\").setAncestor(\"DL\").setExcludes(\"DL\", \"DT\").setOptionalClosing(); // only within DL.\n-\n-        createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing().setFormatAsInline(); // only within OL or UL.\n-\n-        // tables\n-        createBlock(\"TABLE\").setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\", \"TBODY\", \"TD\", \"TFOO\", \"TH\", \"THEAD\", \"TR\"); // specific list of only includes (tr, td, thead etc) not implemented\n-        createBlock(\"CAPTION\").setParent(\"TABLE\").setExcludes(\"THEAD\", \"TFOOT\", \"TBODY\", \"COLGROUP\", \"COL\", \"TR\", \"TH\", \"TD\").setOptionalClosing().setIgnoreEnd(\"BODY\", \"COL\", \"COLGROUP\", \"HTML\", \"TBODY\", \"TD\", \"TFOOT\", \"TH\", \"THEAD\", \"TR\");\n-        createBlock(\"THEAD\").setParent(\"TABLE\").setLimitChildren().setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\", \"TD\", \"TH\", \"TR\"); // just TR\n-        createBlock(\"TFOOT\").setParent(\"TABLE\").setLimitChildren().setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\", \"TD\", \"TH\", \"TR\"); // just TR\n-        createBlock(\"TBODY\").setParent(\"TABLE\").setLimitChildren().setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\", \"TD\", \"TH\", \"TR\"); // optional / implicit open too. just TR\n-        createBlock(\"COLGROUP\").setParent(\"TABLE\").setLimitChildren().setOptionalClosing().setIgnoreEnd(\"COL\"); // just COL\n-        createBlock(\"COL\").setParent(\"COLGROUP\").setEmpty();\n-        createBlock(\"TR\").setParent(\"TBODY\", \"THEAD\", \"TFOOT\", \"TABLE\").setLimitChildren().setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\", \"TD\", \"TH\"); // just TH, TD\n-        createBlock(\"TH\").setParent(\"TR\").setExcludes(\"THEAD\", \"TFOOT\", \"TBODY\", \"COLGROUP\", \"COL\", \"TR\", \"TH\", \"TD\").setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\").setFormatAsInline();\n-        createBlock(\"TD\").setParent(\"TR\").setExcludes(\"THEAD\", \"TFOOT\", \"TBODY\", \"COLGROUP\", \"COL\", \"TR\", \"TH\", \"TD\").setOptionalClosing().setIgnoreEnd(\"BODY\", \"CAPTION\", \"COL\", \"COLGROUP\", \"HTML\").setFormatAsInline();\n-        \n-        // html5 media\n-        createBlock(\"VIDEO\").setExcludes(\"VIDEO\", \"AUDIO\");\n-        createBlock(\"AUDIO\").setExcludes(\"VIDEO\", \"AUDIO\");\n-        createInline(\"SOURCE\").setParent(\"VIDEO\", \"AUDIO\").setEmpty();\n-        createInline(\"TRACK\").setParent(\"VIDEO\", \"AUDIO\").setEmpty();\n-        createBlock(\"CANVAS\");\n-        \n-        // html5 interactive\n-        createBlock(\"DETAILS\");\n-        createInline(\"SUMMARY\").setParent(\"DETAILS\");\n-        createInline(\"COMMAND\").setEmpty();\n-        createBlock(\"MENU\");\n-        createInline(\"DEVICE\").setEmpty();\n-    }\n-\n-    private static Tag createBlock(String tagName) {\n-        return register(new Tag(tagName));\n-    }\n-\n-    private static Tag createInline(String tagName) {\n-        Tag inline = new Tag(tagName);\n-        inline.isBlock = false;\n-        inline.canContainBlock = false;\n-        inline.formatAsBlock = false;\n-        return register(inline);\n+        // creates\n+        for (String tagName : blockTags) {\n+            Tag tag = new Tag(tagName);\n+            register(tag);\n+        }\n+        for (String tagName : inlineTags) {\n+            Tag tag = new Tag(tagName);\n+            tag.isBlock = false;\n+            tag.canContainBlock = false;\n+            tag.formatAsBlock = false;\n+            register(tag);\n+        }\n+\n+        // mods:\n+        for (String tagName : emptyTags) {\n+            Tag tag = tags.get(tagName);\n+            Validate.notNull(tag);\n+            tag.canContainBlock = false;\n+            tag.canContainInline = false;\n+            tag.empty = true;\n+        }\n+\n+        for (String tagName : formatAsInlineTags) {\n+            Tag tag = tags.get(tagName);\n+            Validate.notNull(tag);\n+            tag.formatAsBlock = false;\n+        }\n+\n+        for (String tagName : preserveWhitespaceTags) {\n+            Tag tag = tags.get(tagName);\n+            Validate.notNull(tag);\n+            tag.preserveWhitespace = true;\n+        }\n     }\n \n     private static Tag register(Tag tag) {\n-        tag.setAncestor(defaultAncestor.tagName);\n-        tag.setKnownTag();\n         synchronized (tags) {\n             tags.put(tag.tagName, tag);\n         }\n         return tag;\n     }\n-\n-    private Tag setCanContainBlock() {\n-        canContainBlock = true;\n-        return this;\n-    }\n-\n-    private Tag setContainInlineOnly() {\n-        canContainBlock = false;\n-        canContainInline = true;\n-        formatAsBlock = false;\n-        return this;\n-    }\n-\n-    private Tag setFormatAsInline() {\n-        formatAsBlock = false;\n-        return this;\n-    }\n-\n-    private Tag setContainDataOnly() {\n-        canContainBlock = false;\n-        canContainInline = false;\n-        preserveWhitespace = true;\n-        return this;\n-    }\n-\n-    private Tag setEmpty() {\n-        canContainBlock = false;\n-        canContainInline = false;\n-        empty = true;\n-        return this;\n-    }\n-\n-    private Tag setOptionalClosing() {\n-        optionalClosing = true;\n-        return this;\n-    }\n-\n-    private Tag setPreserveWhitespace() {\n-        preserveWhitespace = true;\n-        return this;\n-    }\n-\n-    private Tag setAncestor(String... tagNames) {\n-        if (tagNames == null || tagNames.length == 0) {\n-            ancestors = Collections.emptyList();\n-        } else {\n-            ancestors = new ArrayList<Tag>(tagNames.length);\n-            for (String name : tagNames) {\n-                ancestors.add(Tag.valueOf(name));\n-            }\n-        }\n-        return this;\n-    }\n-    \n-    private Tag setExcludes(String... tagNames) {\n-        if (tagNames == null || tagNames.length == 0) {\n-            excludes = Collections.emptyList();\n-        } else {\n-            excludes = new ArrayList<Tag>(tagNames.length);\n-            for (String name : tagNames) {\n-                excludes.add(Tag.valueOf(name));\n-            }\n-        }\n-        return this;\n-    }\n-\n-    private Tag setIgnoreEnd(String... tagNames) {\n-        if (tagNames == null || tagNames.length == 0) {\n-            ignoreEndTags = Collections.emptyList();\n-        } else {\n-            ignoreEndTags = new ArrayList<Tag>(tagNames.length);\n-            for (String name : tagNames) {\n-                ignoreEndTags.add(Tag.valueOf(name));\n-            }\n-        }\n-        return this;\n-    }\n-\n-    private Tag setParent(String... tagNames) {\n-        directDescendant = true;\n-        setAncestor(tagNames);\n-        return this;\n-    }\n-    \n-    private Tag setLimitChildren() {\n-        limitChildren = true;\n-        return this;\n-    }\n-    \n-    Tag setSelfClosing() {\n-        selfClosing = true;\n-        return this;\n-    }\n-    \n-    private Tag setKnownTag() {\n-        knownTag = true;\n-        return this;\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/Token.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+\n+/**\n+ * Parse tokens for the Tokeniser.\n+ */\n+abstract class Token {\n+    TokenType type;\n+\n+    private Token() {\n+    }\n+\n+    static class Doctype extends Token {\n+        final StringBuilder name = new StringBuilder();\n+        final StringBuilder publicIdentifier = new StringBuilder();\n+        final StringBuilder systemIdentifier = new StringBuilder();\n+        boolean forceQuirks = false;\n+\n+        Doctype() {\n+            type = TokenType.Doctype;\n+        }\n+\n+        String getName() {\n+            return name.toString();\n+        }\n+\n+        String getPublicIdentifier() {\n+            return publicIdentifier.toString();\n+        }\n+\n+        public String getSystemIdentifier() {\n+            return systemIdentifier.toString();\n+        }\n+\n+        public boolean isForceQuirks() {\n+            return forceQuirks;\n+        }\n+    }\n+\n+    static abstract class Tag extends Token {\n+        protected String tagName;\n+        private String pendingAttributeName;\n+        private String pendingAttributeValue;\n+\n+        boolean selfClosing = false;\n+        Attributes attributes = new Attributes(); // todo: allow nodes to not have attributes\n+\n+        void newAttribute() {\n+            if (pendingAttributeName != null) {\n+                if (pendingAttributeValue == null)\n+                    pendingAttributeValue = \"\";\n+                Attribute attribute = new Attribute(pendingAttributeName, pendingAttributeValue);\n+                attributes.put(attribute);\n+            }\n+            pendingAttributeName = null;\n+            pendingAttributeValue = null;\n+        }\n+\n+        void finaliseTag() {\n+            // finalises for emit\n+            if (pendingAttributeName != null) {\n+                // todo: check if attribute name exists; if so, drop and error\n+                newAttribute();\n+            }\n+        }\n+\n+        String name() {\n+            Validate.isFalse(tagName.isEmpty());\n+            return tagName;\n+        }\n+\n+        Tag name(String name) {\n+            tagName = name;\n+            return this;\n+        }\n+\n+        boolean isSelfClosing() {\n+            return selfClosing;\n+        }\n+\n+        @SuppressWarnings({\"TypeMayBeWeakened\"})\n+        Attributes getAttributes() {\n+            return attributes;\n+        }\n+\n+        // these appenders are rarely hit in not null state-- caused by null chars.\n+        void appendTagName(String append) {\n+            tagName = tagName == null ? append : tagName.concat(append);\n+        }\n+\n+        void appendTagName(char append) {\n+            appendTagName(String.valueOf(append));\n+        }\n+\n+        void appendAttributeName(String append) {\n+            pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n+        }\n+\n+        void appendAttributeName(char append) {\n+            appendAttributeName(String.valueOf(append));\n+        }\n+\n+        void appendAttributeValue(String append) {\n+            pendingAttributeValue = pendingAttributeValue == null ? append : pendingAttributeValue.concat(append);\n+        }\n+\n+        void appendAttributeValue(char append) {\n+            appendAttributeValue(String.valueOf(append));\n+        }\n+    }\n+\n+    static class StartTag extends Tag {\n+        StartTag() {\n+            super();\n+            type = TokenType.StartTag;\n+        }\n+\n+        StartTag(String name) {\n+            this();\n+            this.tagName = name;\n+        }\n+\n+        StartTag(String name, Attributes attributes) {\n+            this();\n+            this.tagName = name;\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<\" + name() + \" \" + attributes.toString() + \">\";\n+        }\n+    }\n+\n+    static class EndTag extends Tag{\n+        EndTag() {\n+            super();\n+            type = TokenType.EndTag;\n+        }\n+\n+        EndTag(String name) {\n+            this();\n+            this.tagName = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"</\" + name() + \" \" + attributes.toString() + \">\";\n+        }\n+    }\n+\n+    static class Comment extends Token {\n+        final StringBuilder data = new StringBuilder();\n+\n+        Comment() {\n+            type = TokenType.Comment;\n+        }\n+\n+        String getData() {\n+            return data.toString();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<!--\" + getData() + \"-->\";\n+        }\n+    }\n+\n+    static class Character extends Token {\n+        private final String data;\n+\n+        Character(String data) {\n+            type = TokenType.Character;\n+            this.data = data;\n+        }\n+\n+        String getData() {\n+            return data;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getData();\n+        }\n+    }\n+\n+    static class EOF extends Token {\n+        EOF() {\n+            type = Token.TokenType.EOF;\n+        }\n+    }\n+\n+    boolean isDoctype() {\n+        return type == TokenType.Doctype;\n+    }\n+\n+    Doctype asDoctype() {\n+        return (Doctype) this;\n+    }\n+\n+    boolean isStartTag() {\n+        return type == TokenType.StartTag;\n+    }\n+\n+    StartTag asStartTag() {\n+        return (StartTag) this;\n+    }\n+\n+    boolean isEndTag() {\n+        return type == TokenType.EndTag;\n+    }\n+\n+    EndTag asEndTag() {\n+        return (EndTag) this;\n+    }\n+\n+    boolean isComment() {\n+        return type == TokenType.Comment;\n+    }\n+\n+    Comment asComment() {\n+        return (Comment) this;\n+    }\n+\n+    boolean isCharacter() {\n+        return type == TokenType.Character;\n+    }\n+\n+    Character asCharacter() {\n+        return (Character) this;\n+    }\n+\n+    boolean isEOF() {\n+        return type == TokenType.EOF;\n+    }\n+\n+    enum TokenType {\n+        Doctype,\n+        StartTag,\n+        EndTag,\n+        Comment,\n+        Character,\n+        EOF\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Entities;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Readers the input stream into tokens.\n+ */\n+class Tokeniser {\n+    static final char replacementChar = '\\uFFFD'; // replaces null character\n+\n+    private CharacterReader reader; // html input\n+    private boolean trackErrors = true;\n+    private List<ParseError> errors = new ArrayList<ParseError>(); // errors found while tokenising\n+\n+    private TokeniserState state = TokeniserState.Data; // current tokenisation state\n+    private Token emitPending; // the token we are about to emit on next read\n+    private boolean isEmitPending = false;\n+    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n+    StringBuilder dataBuffer; // buffers data looking for </script>\n+\n+    Token.Tag tagPending; // tag we are building up\n+    Token.Doctype doctypePending; // doctype building up\n+    Token.Comment commentPending; // comment building up\n+    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n+    private boolean selfClosingFlagAcknowledged = true;\n+\n+    Tokeniser(CharacterReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    Token read() {\n+        if (!selfClosingFlagAcknowledged) {\n+            error(\"Self closing flag not acknowledged\");\n+            selfClosingFlagAcknowledged = true;\n+        }\n+\n+        while (!isEmitPending)\n+            state.read(this, reader);\n+\n+        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n+        if (charBuffer.length() > 0) {\n+            String str = charBuffer.toString();\n+            charBuffer.delete(0, charBuffer.length());\n+            return new Token.Character(str);\n+        } else {\n+            isEmitPending = false;\n+            return emitPending;\n+        }\n+    }\n+\n+    void emit(Token token) {\n+        Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n+\n+        emitPending = token;\n+        isEmitPending = true;\n+\n+        if (token.type == Token.TokenType.StartTag) {\n+            Token.StartTag startTag = (Token.StartTag) token;\n+            lastStartTag = startTag;\n+            if (startTag.selfClosing)\n+                selfClosingFlagAcknowledged = false;\n+        } else if (token.type == Token.TokenType.EndTag) {\n+            Token.EndTag endTag = (Token.EndTag) token;\n+            if (endTag.attributes.size() > 0)\n+                error(\"Attributes incorrectly present on end tag\");\n+        }\n+    }\n+\n+    void emit(String str) {\n+        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n+        // does not set isEmitPending; read checks that\n+        charBuffer.append(str);\n+    }\n+\n+    void emit(char c) {\n+        charBuffer.append(c);\n+    }\n+\n+    TokeniserState getState() {\n+        return state;\n+    }\n+\n+    void transition(TokeniserState state) {\n+        this.state = state;\n+    }\n+\n+    void advanceTransition(TokeniserState state) {\n+        reader.advance();\n+        this.state = state;\n+    }\n+\n+    void acknowledgeSelfClosingFlag() {\n+        selfClosingFlagAcknowledged = true;\n+    }\n+\n+    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+        if (reader.isEmpty())\n+            return null;\n+        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n+            return null;\n+        if (reader.matchesAny('\\t', '\\n', '\\f', '<', '&'))\n+            return null;\n+\n+        reader.mark();\n+        if (reader.matchConsume(\"#\")) { // numbered\n+            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n+            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n+            if (numRef.length() == 0) { // didn't match anything\n+                characterReferenceError();\n+                reader.rewindToMark();\n+                return null;\n+            }\n+            if (!reader.matchConsume(\";\"))\n+                characterReferenceError(); // missing semi\n+            int charval = -1;\n+            try {\n+                int base = isHexMode ? 16 : 10;\n+                charval = Integer.valueOf(numRef, base);\n+            } catch (NumberFormatException e) {\n+            } // skip\n+            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+                characterReferenceError();\n+                return replacementChar;\n+            } else {\n+                // todo: implement number replacement table\n+                // todo: check for extra illegal unicode points as parse errors\n+                return (char) charval;\n+            }\n+        } else { // named\n+            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n+            String nameRef = reader.consumeLetterSequence();\n+            boolean looksLegit = reader.matches(';');\n+            boolean found = false;\n+            while (nameRef.length() > 0 && !found) {\n+                if (Entities.isNamedEntity(nameRef))\n+                    found = true;\n+                else {\n+                    nameRef = nameRef.substring(0, nameRef.length()-1);\n+                    reader.unconsume();\n+                }\n+            }\n+            if (!found) {\n+                if (looksLegit) // named with semicolon\n+                    characterReferenceError();\n+                reader.rewindToMark();\n+                return null;\n+            }\n+            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matches('='))) {\n+                // don't want that to match\n+                reader.rewindToMark();\n+                return null;\n+            }\n+            if (!reader.matchConsume(\";\"))\n+                characterReferenceError(); // missing semi\n+            return Entities.getCharacterByName(nameRef);\n+        }\n+    }\n+\n+    Token.Tag createTagPending(boolean start) {\n+        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n+        return tagPending;\n+    }\n+\n+    void emitTagPending() {\n+        tagPending.finaliseTag();\n+        emit(tagPending);\n+    }\n+\n+    void createCommentPending() {\n+        commentPending = new Token.Comment();\n+    }\n+\n+    void emitCommentPending() {\n+        emit(commentPending);\n+    }\n+\n+    void createDoctypePending() {\n+        doctypePending = new Token.Doctype();\n+    }\n+\n+    void emitDoctypePending() {\n+        emit(doctypePending);\n+    }\n+\n+    void createTempBuffer() {\n+        dataBuffer = new StringBuilder();\n+    }\n+\n+    boolean isAppropriateEndTagToken() {\n+        return tagPending.tagName.equals(lastStartTag.tagName);\n+    }\n+\n+    boolean isTrackErrors() {\n+        return trackErrors;\n+    }\n+\n+    void setTrackErrors(boolean trackErrors) {\n+        this.trackErrors = trackErrors;\n+    }\n+\n+    void error(TokeniserState state) {\n+        if (trackErrors)\n+            errors.add(new ParseError(\"Unexpected character in input\", reader.current(), state, reader.pos()));\n+    }\n+\n+    void eofError(TokeniserState state) {\n+        if (trackErrors)\n+            errors.add(new ParseError(\"Unexpectedly reached end of file (EOF)\", state, reader.pos()));\n+    }\n+\n+    private void characterReferenceError() {\n+        if (trackErrors)\n+            errors.add(new ParseError(\"Invalid character reference\", reader.pos()));\n+    }\n+\n+    private void error(String errorMsg) {\n+        if (trackErrors)\n+            errors.add(new ParseError(errorMsg, reader.pos()));\n+    }\n+\n+    boolean currentNodeInHtmlNS() {\n+        // todo: implememnt namespaces correctly\n+        return true;\n+        // Element currentNode = currentNode();\n+        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n+package org.jsoup.parser;\n+\n+/**\n+ * States and transition activations for the Tokeniser.\n+ */\n+enum TokeniserState {\n+    Data {\n+        // in data state, gather characters until a character reference or tag is found\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case '&':\n+                    t.advanceTransition(CharacterReferenceInData);\n+                    break;\n+                case '<':\n+                    t.advanceTransition(TagOpen);\n+                    break;\n+                case nullChar:\n+                    t.error(this); // NOT replacement character (oddly?)\n+                    t.emit(r.consume());\n+                    break;\n+                case eof:\n+                    t.emit(new Token.EOF());\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('&', '<', nullChar);\n+                    t.emit(data);\n+                    break;\n+            }\n+        }\n+    },\n+    CharacterReferenceInData {\n+        // from & in data\n+        void read(Tokeniser t, CharacterReader r) {\n+            Character c = t.consumeCharacterReference(null, false);\n+            if (c == null)\n+                t.emit('&');\n+            else\n+                t.emit(c);\n+            t.transition(Data);\n+        }\n+    },\n+    Rcdata {\n+        /// handles data in title, textarea etc\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case '&':\n+                    t.advanceTransition(CharacterReferenceInRcdata);\n+                    break;\n+                case '<':\n+                    t.advanceTransition(RcdataLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                case eof:\n+                    t.emit(new Token.EOF());\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('&', '<', nullChar);\n+                    t.emit(data);\n+                    break;\n+            }\n+        }\n+    },\n+    CharacterReferenceInRcdata {\n+        void read(Tokeniser t, CharacterReader r) {\n+            Character c = t.consumeCharacterReference(null, false);\n+            if (c == null)\n+                t.emit('&');\n+            else\n+                t.emit(c);\n+            t.transition(Rcdata);\n+        }\n+    },\n+    Rawtext {\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case '<':\n+                    t.advanceTransition(RawtextLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                case eof:\n+                    t.emit(new Token.EOF());\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('<', nullChar);\n+                    t.emit(data);\n+                    break;\n+            }\n+        }\n+    },\n+    ScriptData {\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case '<':\n+                    t.advanceTransition(ScriptDataLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                case eof:\n+                    t.emit(new Token.EOF());\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('<', nullChar);\n+                    t.emit(data);\n+                    break;\n+            }\n+        }\n+    },\n+    PLAINTEXT {\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                case eof:\n+                    t.emit(new Token.EOF());\n+                    break;\n+                default:\n+                    String data = r.consumeTo(nullChar);\n+                    t.emit(data);\n+                    break;\n+            }\n+        }\n+    },\n+    TagOpen {\n+        // from < in data\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.current()) {\n+                case '!':\n+                    t.advanceTransition(MarkupDeclarationOpen);\n+                    break;\n+                case '/':\n+                    t.advanceTransition(EndTagOpen);\n+                    break;\n+                case '?':\n+                    t.advanceTransition(BogusComment);\n+                    break;\n+                default:\n+                    if (r.matchesLetter()) {\n+                        t.createTagPending(true);\n+                        t.transition(TagName);\n+                    } else {\n+                        t.error(this);\n+                        t.emit('<'); // char that got us here\n+                        t.transition(Data);\n+                    }\n+                    break;\n+            }\n+        }\n+    },\n+    EndTagOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.isEmpty()) {\n+                t.eofError(this);\n+                t.emit(\"</\");\n+                t.transition(Data);\n+            } else if (r.matchesLetter()) {\n+                t.createTagPending(false);\n+                t.transition(TagName);\n+            } else if (r.matches('>')) {\n+                t.error(this);\n+                t.advanceTransition(Data);\n+            } else {\n+                t.error(this);\n+                t.advanceTransition(BogusComment);\n+            }\n+        }\n+    },\n+    TagName {\n+        // from < or </ in data, will have start or end tag pending\n+        void read(Tokeniser t, CharacterReader r) {\n+            // previous TagOpen state did NOT consume, will have a letter char in current\n+            String tagName = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n+            t.tagPending.appendTagName(tagName);\n+\n+            switch (r.consume()) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeAttributeName);\n+                    break;\n+                case '/':\n+                    t.transition(SelfClosingStartTag);\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar: // replacement\n+                    t.tagPending.appendTagName(replacementStr);\n+                    break;\n+                case eof: // should emit pending tag?\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                // no default, as covered with above consumeToAny\n+            }\n+        }\n+    },\n+    RcdataLessthanSign {\n+        // from < in rcdata\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matches('/')) {\n+                t.createTempBuffer();\n+                t.advanceTransition(RCDATAEndTagOpen);\n+            } else {\n+                t.emit(\"<\");\n+                t.transition(Rcdata);\n+            }\n+        }\n+    },\n+    RCDATAEndTagOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createTagPending(false);\n+                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n+                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.advanceTransition(RCDATAEndTagName);\n+            } else {\n+                t.emit(\"</\");\n+                t.transition(Rcdata);\n+            }\n+        }\n+    },\n+    RCDATAEndTagName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.tagPending.appendTagName(name.toLowerCase());\n+                t.dataBuffer.append(name);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            boolean handled = true;\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(BeforeAttributeName);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '/':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(SelfClosingStartTag);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '>':\n+                    if (t.isAppropriateEndTagToken()) {\n+                        t.emitTagPending();\n+                        t.transition(Data);\n+                    }\n+                    else\n+                        handled = false;\n+                    break;\n+            }\n+            if (!handled) {\n+                t.emit(\"</\" + t.dataBuffer.toString());\n+                r.unconsume();\n+                t.transition(Rcdata);\n+            }\n+        }\n+    },\n+    RawtextLessthanSign {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matches('/')) {\n+                t.createTempBuffer();\n+                t.advanceTransition(RawtextEndTagOpen);\n+            } else {\n+                t.emit('<');\n+                t.transition(Rawtext);\n+            }\n+        }\n+    },\n+    RawtextEndTagOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createTagPending(false);\n+                t.transition(RawtextEndTagName);\n+            } else {\n+                t.emit(\"</\");\n+                t.transition(Rawtext);\n+            }\n+        }\n+    },\n+    RawtextEndTagName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.tagPending.appendTagName(name.toLowerCase());\n+                t.dataBuffer.append(name);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            boolean handled = true;\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(BeforeAttributeName);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '/':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(SelfClosingStartTag);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '>':\n+                    if (t.isAppropriateEndTagToken()) {\n+                        t.emitTagPending();\n+                        t.transition(Data);\n+                    }\n+                    else\n+                        handled = false;\n+                    break;\n+            }\n+            if (!handled) {\n+                t.emit(\"</\" + t.dataBuffer.toString());\n+                r.unconsume();\n+                t.transition(Rawtext);\n+            }\n+        }\n+    },\n+    ScriptDataLessthanSign {\n+        void read(Tokeniser t, CharacterReader r) {\n+            switch (r.consume()) {\n+                case '/':\n+                    t.createTempBuffer();\n+                    t.transition(ScriptDataEndTagOpen);\n+                    break;\n+                case '!':\n+                    t.emit(\"<!\");\n+                    t.transition(ScriptDataEscapeStart);\n+                    break;\n+                default:\n+                    t.emit(\"<\");\n+                    r.unconsume();\n+                    t.transition(ScriptData);\n+            }\n+        }\n+    },\n+    ScriptDataEndTagOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createTagPending(false);\n+                t.transition(ScriptDataEndTagName);\n+            } else {\n+                t.emit(\"</\");\n+                t.transition(ScriptData);\n+            }\n+\n+        }\n+    },\n+    ScriptDataEndTagName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.tagPending.appendTagName(name.toLowerCase());\n+                t.dataBuffer.append(name);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            boolean handled = true;\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(BeforeAttributeName);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '/':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(SelfClosingStartTag);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '>':\n+                    if (t.isAppropriateEndTagToken()) {\n+                        t.emitTagPending();\n+                        t.transition(Data);\n+                    }\n+                    else\n+                        handled = false;\n+                    break;\n+            }\n+            if (!handled) {\n+                t.emit(\"</\" + t.dataBuffer.toString());\n+                r.unconsume();\n+                t.transition(ScriptData);\n+            }\n+        }\n+    },\n+    ScriptDataEscapeStart {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matches('-')) {\n+                t.emit('-');\n+                t.advanceTransition(ScriptDataEscapeStartDash);\n+            } else {\n+                t.transition(ScriptData);\n+            }\n+        }\n+    },\n+    ScriptDataEscapeStartDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matches('-')) {\n+                t.emit('-');\n+                t.advanceTransition(ScriptDataEscapedDashDash);\n+            } else {\n+                t.transition(ScriptData);\n+            }\n+        }\n+    },\n+    ScriptDataEscaped {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.isEmpty()) {\n+                t.eofError(this);\n+                t.transition(Data);\n+                return;\n+            }\n+\n+            switch (r.current()) {\n+                case '-':\n+                    t.emit('-');\n+                    t.advanceTransition(ScriptDataEscapedDash);\n+                    break;\n+                case '<':\n+                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('-', '<', nullChar);\n+                    t.emit(data);\n+            }\n+        }\n+    },\n+    ScriptDataEscapedDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.isEmpty()) {\n+                t.eofError(this);\n+                t.transition(Data);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.emit(c);\n+                    t.transition(ScriptDataEscapedDashDash);\n+                    break;\n+                case '<':\n+                    t.transition(ScriptDataEscapedLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.emit(replacementChar);\n+                    t.transition(ScriptDataEscaped);\n+                    break;\n+                default:\n+                    t.emit(c);\n+                    t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataEscapedDashDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.isEmpty()) {\n+                t.eofError(this);\n+                t.transition(Data);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.emit(c);\n+                    break;\n+                case '<':\n+                    t.transition(ScriptDataEscapedLessthanSign);\n+                    break;\n+                case '>':\n+                    t.emit(c);\n+                    t.transition(ScriptData);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.emit(replacementChar);\n+                    t.transition(ScriptDataEscaped);\n+                    break;\n+                default:\n+                    t.emit(c);\n+                    t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataEscapedLessthanSign {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createTempBuffer();\n+                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.emit(\"<\" + r.current());\n+                t.advanceTransition(ScriptDataDoubleEscapeStart);\n+            } else if (r.matches('/')) {\n+                t.createTempBuffer();\n+                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n+            } else {\n+                t.emit('<');\n+                t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataEscapedEndTagOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createTagPending(false);\n+                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n+                t.dataBuffer.append(r.current());\n+                t.advanceTransition(ScriptDataEscapedEndTagName);\n+            } else {\n+                t.emit(\"</\");\n+                t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataEscapedEndTagName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.tagPending.appendTagName(name.toLowerCase());\n+                t.dataBuffer.append(name);\n+                r.advance();\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            boolean handled = true;\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(BeforeAttributeName);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '/':\n+                    if (t.isAppropriateEndTagToken())\n+                        t.transition(SelfClosingStartTag);\n+                    else\n+                        handled = false;\n+                    break;\n+                case '>':\n+                    if (t.isAppropriateEndTagToken()) {\n+                        t.emitTagPending();\n+                        t.transition(Data);\n+                    }\n+                    else\n+                        handled = false;\n+                    break;\n+            }\n+            if (!handled) {\n+                t.emit(\"</\" + t.dataBuffer.toString());\n+                r.unconsume();\n+                t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscapeStart {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.dataBuffer.append(name.toLowerCase());\n+                t.emit(name);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                case '/':\n+                case '>':\n+                    if (t.dataBuffer.toString().equals(\"script\"))\n+                        t.transition(ScriptDataDoubleEscaped);\n+                    else\n+                        t.transition(ScriptDataEscaped);\n+                    t.emit(c);\n+                    break;\n+                default:\n+                    r.unconsume();\n+                    t.transition(ScriptDataEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscaped {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.current();\n+            switch (c) {\n+                case '-':\n+                    t.emit(c);\n+                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n+                    break;\n+                case '<':\n+                    t.emit(c);\n+                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    r.advance();\n+                    t.emit(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    String data = r.consumeToAny('-', '<', nullChar);\n+                    t.emit(data);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscapedDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.emit(c);\n+                    t.transition(ScriptDataDoubleEscapedDashDash);\n+                    break;\n+                case '<':\n+                    t.emit(c);\n+                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.emit(replacementChar);\n+                    t.transition(ScriptDataDoubleEscaped);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.emit(c);\n+                    t.transition(ScriptDataDoubleEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscapedDashDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.emit(c);\n+                    break;\n+                case '<':\n+                    t.emit(c);\n+                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n+                    break;\n+                case '>':\n+                    t.emit(c);\n+                    t.transition(ScriptData);\n+                case nullChar:\n+                    t.error(this);\n+                    t.emit(replacementChar);\n+                    t.transition(ScriptDataDoubleEscaped);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.emit(c);\n+                    t.transition(ScriptDataDoubleEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscapedLessthanSign {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matches('/')) {\n+                t.emit('/');\n+                t.createTempBuffer();\n+                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n+            } else {\n+                t.transition(ScriptDataDoubleEscaped);\n+            }\n+        }\n+    },\n+    ScriptDataDoubleEscapeEnd {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.dataBuffer.append(name.toLowerCase());\n+                t.emit(name);\n+                return;\n+            }\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                case '/':\n+                case '>':\n+                    if (t.dataBuffer.toString().equals(\"script\"))\n+                        t.transition(ScriptDataEscaped);\n+                    else\n+                        t.transition(ScriptDataDoubleEscaped);\n+                    t.emit(c);\n+                    break;\n+                default:\n+                    r.unconsume();\n+                    t.transition(ScriptDataDoubleEscaped);\n+            }\n+        }\n+    },\n+    BeforeAttributeName {\n+        // from tagname <xxx\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break; // ignore whitespace\n+                case '/':\n+                    t.transition(SelfClosingStartTag);\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.newAttribute();\n+                    r.unconsume();\n+                    t.transition(AttributeName);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                case '\\'':\n+                case '<':\n+                case '=':\n+                    t.error(this);\n+                    t.tagPending.newAttribute();\n+                    t.tagPending.appendAttributeName(c);\n+                    t.transition(AttributeName);\n+                    break;\n+                default: // A-Z, anything else\n+                    t.tagPending.newAttribute();\n+                    r.unconsume();\n+                    t.transition(AttributeName);\n+            }\n+        }\n+    },\n+    AttributeName {\n+        // from before attribute name\n+        void read(Tokeniser t, CharacterReader r) {\n+            String name = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<');\n+            t.tagPending.appendAttributeName(name.toLowerCase());\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(AfterAttributeName);\n+                    break;\n+                case '/':\n+                    t.transition(SelfClosingStartTag);\n+                    break;\n+                case '=':\n+                    t.transition(BeforeAttributeValue);\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeName(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                case '\\'':\n+                case '<':\n+                    t.error(this);\n+                    t.tagPending.appendAttributeName(c);\n+                // no default, as covered in consumeToAny\n+            }\n+        }\n+    },\n+    AfterAttributeName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    // ignore\n+                    break;\n+                case '/':\n+                    t.transition(SelfClosingStartTag);\n+                    break;\n+                case '=':\n+                    t.transition(BeforeAttributeValue);\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeName(replacementChar);\n+                    t.transition(AttributeName);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                case '\\'':\n+                case '<':\n+                    t.error(this);\n+                    t.tagPending.newAttribute();\n+                    t.tagPending.appendAttributeName(c);\n+                    t.transition(AttributeName);\n+                    break;\n+                default: // A-Z, anything else\n+                    t.tagPending.newAttribute();\n+                    r.unconsume();\n+                    t.transition(AttributeName);\n+            }\n+        }\n+    },\n+    BeforeAttributeValue {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    // ignore\n+                    break;\n+                case '\"':\n+                    t.transition(AttributeValue_doubleQuoted);\n+                    break;\n+                case '&':\n+                    r.unconsume();\n+                    t.transition(AttributeValue_unquoted);\n+                    break;\n+                case '\\'':\n+                    t.transition(AttributeValue_singleQuoted);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(replacementChar);\n+                    t.transition(AttributeValue_unquoted);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case '<':\n+                case '=':\n+                case '`':\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(c);\n+                    t.transition(AttributeValue_unquoted);\n+                    break;\n+                default:\n+                    r.unconsume();\n+                    t.transition(AttributeValue_unquoted);\n+            }\n+        }\n+    },\n+    AttributeValue_doubleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            String value = r.consumeToAny('\"', '&', nullChar);\n+            if (value.length() > 0)\n+                t.tagPending.appendAttributeValue(value);\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\"':\n+                    t.transition(AfterAttributeValue_quoted);\n+                    break;\n+                case '&':\n+                    Character ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null)\n+                        t.tagPending.appendAttributeValue(ref);\n+                    else\n+                        t.tagPending.appendAttributeValue('&');\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                // no default, handled in consume to any above\n+            }\n+        }\n+    },\n+    AttributeValue_singleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            String value = r.consumeToAny('\\'', '&', nullChar);\n+            if (value.length() > 0)\n+                t.tagPending.appendAttributeValue(value);\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\'':\n+                    t.transition(AfterAttributeValue_quoted);\n+                    break;\n+                case '&':\n+                    Character ref = t.consumeCharacterReference('\\'', true);\n+                    if (ref != null)\n+                        t.tagPending.appendAttributeValue(ref);\n+                    else\n+                        t.tagPending.appendAttributeValue('&');\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                // no default, handled in consume to any above\n+            }\n+        }\n+    },\n+    AttributeValue_unquoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            String value = r.consumeToAny('\\t', '\\n', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n+            if (value.length() > 0)\n+                t.tagPending.appendAttributeValue(value);\n+\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeAttributeName);\n+                    break;\n+                case '&':\n+                    Character ref = t.consumeCharacterReference('>', true);\n+                    if (ref != null)\n+                        t.tagPending.appendAttributeValue(ref);\n+                    else\n+                        t.tagPending.appendAttributeValue('&');\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                case '\\'':\n+                case '<':\n+                case '=':\n+                case '`':\n+                    t.error(this);\n+                    t.tagPending.appendAttributeValue(c);\n+                    break;\n+                // no default, handled in consume to any above\n+            }\n+\n+        }\n+    },\n+    // CharacterReferenceInAttributeValue state handled inline\n+    AfterAttributeValue_quoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeAttributeName);\n+                    break;\n+                case '/':\n+                    t.transition(SelfClosingStartTag);\n+                    break;\n+                case '>':\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    r.unconsume();\n+                    t.transition(BeforeAttributeName);\n+            }\n+\n+        }\n+    },\n+    SelfClosingStartTag {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '>':\n+                    t.tagPending.selfClosing = true;\n+                    t.emitTagPending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.transition(BeforeAttributeName);\n+            }\n+        }\n+    },\n+    BogusComment {\n+        void read(Tokeniser t, CharacterReader r) {\n+            // todo: handle bogus comment starting from eof. when does that trigger?\n+            // rewind to capture character that lead us here\n+            r.unconsume();\n+            Token.Comment comment = new Token.Comment();\n+            comment.data.append(r.consumeTo('>'));\n+            // todo: replace nullChar with replaceChar\n+            t.emit(comment);\n+            t.advanceTransition(Data);\n+        }\n+    },\n+    MarkupDeclarationOpen {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchConsume(\"--\")) {\n+                t.createCommentPending();\n+                t.transition(CommentStart);\n+            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n+                t.transition(Doctype);\n+            } else if (r.matchConsume(\"[CDATA[\")) {\n+                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n+                // is implemented properly, keep handling as cdata\n+                //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(\"[CDATA[\")) {\n+                t.transition(CdataSection);\n+            } else {\n+                t.error(this);\n+                t.advanceTransition(BogusComment); // advance so this character gets in bogus comment data's rewind\n+            }\n+        }\n+    },\n+    CommentStart {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.transition(CommentStartDash);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append(replacementChar);\n+                    t.transition(Comment);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.commentPending.data.append(c);\n+                    t.transition(Comment);\n+            }\n+        }\n+    },\n+    CommentStartDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.transition(CommentStartDash);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append(replacementChar);\n+                    t.transition(Comment);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.commentPending.data.append(c);\n+                    t.transition(Comment);\n+            }\n+        }\n+    },\n+    Comment {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.current();\n+            switch (c) {\n+                case '-':\n+                    t.advanceTransition(CommentEndDash);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n+            }\n+        }\n+    },\n+    CommentEndDash {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.transition(CommentEnd);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append('-').append(replacementChar);\n+                    t.transition(Comment);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.commentPending.data.append('-').append(c);\n+                    t.transition(Comment);\n+            }\n+        }\n+    },\n+    CommentEnd {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '>':\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append(\"--\").append(replacementChar);\n+                    t.transition(Comment);\n+                    break;\n+                case '!':\n+                    t.error(this);\n+                    t.transition(CommentEndBang);\n+                    break;\n+                case '-':\n+                    t.error(this);\n+                    t.commentPending.data.append('-');\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.commentPending.data.append(\"--\").append(c);\n+                    t.transition(Comment);\n+            }\n+        }\n+    },\n+    CommentEndBang {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '-':\n+                    t.commentPending.data.append(\"--!\");\n+                    t.transition(CommentEndDash);\n+                    break;\n+                case '>':\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.commentPending.data.append(\"--!\").append(replacementChar);\n+                    t.transition(Comment);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.emitCommentPending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.commentPending.data.append(\"--!\").append(c);\n+                    t.transition(Comment);\n+            }\n+        }\n+    },\n+    Doctype {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeDoctypeName);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.createDoctypePending();\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.transition(BeforeDoctypeName);\n+            }\n+        }\n+    },\n+    BeforeDoctypeName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                t.createDoctypePending();\n+                t.transition(DoctypeName);\n+                return;\n+            }\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break; // ignore whitespace\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.name.append(replacementChar);\n+                    t.transition(DoctypeName);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.createDoctypePending();\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.createDoctypePending();\n+                    t.doctypePending.name.append(c);\n+                    t.transition(DoctypeName);\n+            }\n+        }\n+    },\n+    DoctypeName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.matchesLetter()) {\n+                String name = r.consumeLetterSequence();\n+                t.doctypePending.name.append(name.toLowerCase());\n+                return;\n+            }\n+            char c = r.consume();\n+            switch (c) {\n+                case '>':\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(AfterDoctypeName);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.name.append(replacementChar);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.doctypePending.name.append(c);\n+            }\n+        }\n+    },\n+    AfterDoctypeName {\n+        void read(Tokeniser t, CharacterReader r) {\n+            if (r.isEmpty()) {\n+                t.eofError(this);\n+                t.doctypePending.forceQuirks = true;\n+                t.emitDoctypePending();\n+                t.transition(Data);\n+                return;\n+            }\n+            if (r.matches('>')) {\n+                t.emitDoctypePending();\n+                t.advanceTransition(Data);\n+            } else if (r.matchConsumeIgnoreCase(\"PUBLIC\")) {\n+                t.transition(AfterDoctypePublicKeyword);\n+            } else if (r.matchConsumeIgnoreCase(\"SYSTEM\")) {\n+                t.transition(AfterDoctypeSystemKeyword);\n+            } else {\n+                t.error(this);\n+                t.doctypePending.forceQuirks = true;\n+                t.advanceTransition(BogusDoctype);\n+            }\n+\n+        }\n+    },\n+    AfterDoctypePublicKeyword {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeDoctypePublicIdentifier);\n+                    break;\n+                case '\"':\n+                    t.error(this);\n+                    // set public id to empty string\n+                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    t.error(this);\n+                    // set public id to empty string\n+                    t.transition(DoctypePublicIdentifier_singleQuoted);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.transition(BogusDoctype);\n+            }\n+        }\n+    },\n+    BeforeDoctypePublicIdentifier {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break;\n+                case '\"':\n+                    // set public id to empty string\n+                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    // set public id to empty string\n+                    t.transition(DoctypePublicIdentifier_singleQuoted);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.transition(BogusDoctype);\n+            }\n+        }\n+    },\n+    DoctypePublicIdentifier_doubleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\"':\n+                    t.transition(AfterDoctypePublicIdentifier);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.publicIdentifier.append(replacementChar);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.doctypePending.publicIdentifier.append(c);\n+            }\n+        }\n+    },\n+    DoctypePublicIdentifier_singleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\'':\n+                    t.transition(AfterDoctypePublicIdentifier);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.publicIdentifier.append(replacementChar);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.doctypePending.publicIdentifier.append(c);\n+            }\n+        }\n+    },\n+    AfterDoctypePublicIdentifier {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n+                    break;\n+                case '>':\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.transition(BogusDoctype);\n+            }\n+        }\n+    },\n+    BetweenDoctypePublicAndSystemIdentifiers {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break;\n+                case '>':\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.transition(BogusDoctype);\n+            }\n+        }\n+    },\n+    AfterDoctypeSystemKeyword {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    t.transition(BeforeDoctypeSystemIdentifier);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case '\"':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    t.error(this);\n+                    // system id empty\n+                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+            }\n+        }\n+    },\n+    BeforeDoctypeSystemIdentifier {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break;\n+                case '\"':\n+                    // set system id to empty string\n+                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n+                    break;\n+                case '\\'':\n+                    // set public id to empty string\n+                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.transition(BogusDoctype);\n+            }\n+        }\n+    },\n+    DoctypeSystemIdentifier_doubleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\"':\n+                    t.transition(AfterDoctypeSystemIdentifier);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.systemIdentifier.append(replacementChar);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.doctypePending.systemIdentifier.append(c);\n+            }\n+        }\n+    },\n+    DoctypeSystemIdentifier_singleQuoted {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\'':\n+                    t.transition(AfterDoctypeSystemIdentifier);\n+                    break;\n+                case nullChar:\n+                    t.error(this);\n+                    t.doctypePending.systemIdentifier.append(replacementChar);\n+                    break;\n+                case '>':\n+                    t.error(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.doctypePending.systemIdentifier.append(c);\n+            }\n+        }\n+    },\n+    AfterDoctypeSystemIdentifier {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\f':\n+                case ' ':\n+                    break;\n+                case '>':\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.eofError(this);\n+                    t.doctypePending.forceQuirks = true;\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    t.error(this);\n+                    t.transition(BogusDoctype);\n+                    // NOT force quirks\n+            }\n+        }\n+    },\n+    BogusDoctype {\n+        void read(Tokeniser t, CharacterReader r) {\n+            char c = r.consume();\n+            switch (c) {\n+                case '>':\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                case eof:\n+                    t.emitDoctypePending();\n+                    t.transition(Data);\n+                    break;\n+                default:\n+                    // ignore char\n+                    break;\n+            }\n+        }\n+    },\n+    CdataSection {\n+        void read(Tokeniser t, CharacterReader r) {\n+            String data = r.consumeTo(\"]]>\");\n+            t.emit(data);\n+            r.matchConsume(\"]]>\");\n+            t.transition(Data);\n+        }\n+    };\n+\n+\n+    abstract void read(Tokeniser t, CharacterReader r);\n+\n+    private static final char nullChar = '\\u0000';\n+    private static final char replacementChar = Tokeniser.replacementChar;\n+    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n+    private static final char eof = CharacterReader.EOF;\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * HTML Tree Builder; creates a DOM from Tokens.\n+ */\n+class TreeBuilder {\n+    CharacterReader reader;\n+    Tokeniser tokeniser;\n+\n+    private TreeBuilderState state; // the current state\n+    private TreeBuilderState originalState; // original / marked state\n+    private Document doc; // current doc we are building into\n+    private LinkedList<Element> stack; // the stack of open elements\n+\n+    private String baseUri; // current base uri, for creating new elements\n+    private Token currentToken; // currentToken is used only for error tracking.\n+    private Element headElement; // the current head element\n+    private Element formElement; // the current form element\n+    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n+    private LinkedList<Element> formattingElements = new LinkedList<Element>(); // active (open) formatting elements\n+    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+\n+    private boolean framesetOk = true; // if ok to go into frameset\n+    private boolean fosterInserts = false; // if next inserts should be fostered\n+    private boolean fragmentParsing = false; // if parsing a fragment of html\n+\n+    private boolean trackErrors = false;\n+    private List<ParseError> errors = new ArrayList<ParseError>();\n+\n+    TreeBuilder() {}\n+\n+    private void initialiseParse(String input, String baseUri) {\n+        doc = new Document(baseUri);\n+        reader = new CharacterReader(input);\n+        tokeniser = new Tokeniser(reader);\n+        stack = new LinkedList<Element>();\n+        this.baseUri = baseUri;\n+    }\n+\n+    Document parse(String input, String baseUri) {\n+        state = TreeBuilderState.Initial;\n+        initialiseParse(input, baseUri);\n+        runParser();\n+        return doc;\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri) {\n+        // context may be null\n+        initialiseParse(inputFragment, baseUri);\n+        contextElement = context;\n+        fragmentParsing = true;\n+        Element root = null;\n+\n+        if (context != null) {\n+            if (context.ownerDocument() != null) // quirks setup:\n+                doc.quirksMode(context.ownerDocument().quirksMode());\n+\n+            // initialise the tokeniser state:\n+            String contextTag = context.tagName();\n+            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n+                tokeniser.transition(TokeniserState.Rcdata);\n+            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n+                tokeniser.transition(TokeniserState.Rawtext);\n+            else if (contextTag.equals(\"script\"))\n+                tokeniser.transition(TokeniserState.ScriptData);\n+            else if (contextTag.equals((\"noscript\")))\n+                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n+            else if (contextTag.equals(\"plaintext\"))\n+                tokeniser.transition(TokeniserState.Data);\n+            else\n+                tokeniser.transition(TokeniserState.Data); // default\n+\n+            root = new Element(Tag.valueOf(\"html\"), baseUri);\n+            doc.appendChild(root);\n+            stack.push(root);\n+            resetInsertionMode();\n+            // todo: setup form element to nearest form on context (up ancestor chain)\n+        }\n+\n+        runParser();\n+        if (context != null)\n+            return root.childNodes();\n+        else\n+            return doc.childNodes();\n+    }\n+\n+    private void runParser() {\n+        while (true) {\n+            // todo: handle foreign content checks\n+\n+            Token token = tokeniser.read();\n+            process(token);\n+\n+            if (token.type == Token.TokenType.EOF)\n+                break;\n+        }\n+    }\n+\n+    boolean process(Token token) {\n+        currentToken = token;\n+        return this.state.process(token, this);\n+    }\n+\n+    boolean process(Token token, TreeBuilderState state) {\n+        currentToken = token;\n+        return state.process(token, this);\n+    }\n+\n+    void transition(TreeBuilderState state) {\n+        this.state = state;\n+    }\n+\n+    TreeBuilderState state() {\n+        return state;\n+    }\n+\n+    void markInsertionMode() {\n+        originalState = state;\n+    }\n+\n+    TreeBuilderState originalState() {\n+        return originalState;\n+    }\n+\n+    void framesetOk(boolean framesetOk) {\n+        this.framesetOk = framesetOk;\n+    }\n+\n+    boolean framesetOk() {\n+        return framesetOk;\n+    }\n+\n+    Element currentElement() {\n+        return stack.getLast();\n+    }\n+\n+    Document getDocument() {\n+        return doc;\n+    }\n+\n+    String getBaseUri() {\n+        return baseUri;\n+    }\n+\n+    void setBaseUri(Element base) {\n+        String href = base.absUrl(\"href\");\n+        if (href.length() != 0) { // ignore <base target> etc\n+            baseUri = href;\n+            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n+        }\n+    }\n+\n+    boolean isFragmentParsing() {\n+        return fragmentParsing;\n+    }\n+\n+    void error(TreeBuilderState state) {\n+        if (trackErrors)\n+            errors.add(new ParseError(\"Unexpected token\", state, currentToken, reader.pos()));\n+    }\n+\n+    Element insert(Token.StartTag startTag) {\n+        // handle empty unknown tags\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n+        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+            Element el =  insertEmpty(startTag);\n+            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            return el;\n+        }\n+        \n+        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n+        insert(el);\n+        return el;\n+    }\n+\n+    Element insert(String startTagName) {\n+        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n+        insert(el);\n+        return el;\n+    }\n+\n+    void insert(Element el) {\n+        insertNode(el);\n+        stack.add(el);\n+    }\n+\n+    Element insertEmpty(Token.StartTag startTag) {\n+        Tag tag = Tag.valueOf(startTag.name());\n+        Element el = new Element(tag, baseUri, startTag.attributes);\n+        insertNode(el);\n+        if (startTag.isSelfClosing()) {\n+            tokeniser.acknowledgeSelfClosingFlag();\n+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+                tag.setSelfClosing();\n+        }\n+        return el;\n+    }\n+\n+    void insert(Token.Comment commentToken) {\n+        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        insertNode(comment);\n+    }\n+\n+    void insert(Token.Character characterToken) {\n+        Node node;\n+        // characters in script and style go in as datanodes, not text nodes\n+        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n+            node = new DataNode(characterToken.getData(), baseUri);\n+        else\n+            node = new TextNode(characterToken.getData(), baseUri);\n+        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n+    }\n+\n+    private void insertNode(Node node) {\n+        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n+        if (stack.size() == 0)\n+            doc.appendChild(node);\n+        else if (isFosterInserts())\n+            insertInFosterParent(node);\n+        else\n+            currentElement().appendChild(node);\n+    }\n+\n+    Element pop() {\n+        // todo - dev, remove validation check\n+        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n+            Validate.isFalse(true, \"pop td not in cell\");\n+        if (stack.peekLast().nodeName().equals(\"html\"))\n+            Validate.isFalse(true, \"popping html!\");\n+        return stack.pollLast();\n+    }\n+\n+    void push(Element element) {\n+        stack.add(element);\n+    }\n+\n+    LinkedList<Element> getStack() {\n+        return stack;\n+    }\n+\n+    boolean onStack(Element el) {\n+        return isElementInQueue(stack, el);\n+    }\n+\n+    private boolean isElementInQueue(LinkedList<Element> queue, Element element) {\n+        Iterator<Element> it = queue.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == element) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    Element getFromStack(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                return next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    boolean removeFromStack(Element el) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void popStackToClose(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), elNames)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void clearStackToTableContext() {\n+        clearStackToContext(\"table\");\n+    }\n+\n+    void clearStackToTableBodyContext() {\n+        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n+    }\n+\n+    void clearStackToTableRowContext() {\n+        clearStackToContext(\"tr\");\n+    }\n+\n+    private void clearStackToContext(String... nodeNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n+                break;\n+            else\n+                it.remove();\n+        }\n+    }\n+\n+    Element aboveOnStack(Element el) {\n+        assert onStack(el);\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                return it.next();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    void insertOnStackAfter(Element after, Element in) {\n+        int i = stack.lastIndexOf(after);\n+        Validate.isTrue(i != -1);\n+        stack.add(i+1, in);\n+    }\n+\n+    void replaceOnStack(Element out, Element in) {\n+        replaceInQueue(stack, out, in);\n+    }\n+\n+    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+        int i = queue.lastIndexOf(out);\n+        Validate.isTrue(i != -1);\n+        queue.remove(i);\n+        queue.add(i, in);\n+    }\n+\n+    void resetInsertionMode() {\n+        boolean last = false;\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element node = it.next();\n+            if (!it.hasNext()) {\n+                last = true;\n+                node = contextElement;\n+            }\n+            String name = node.nodeName();\n+            if (\"select\".equals(name)) {\n+                transition(TreeBuilderState.InSelect);\n+                break; // frag\n+            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+                transition(TreeBuilderState.InCell);\n+                break;\n+            } else if (\"tr\".equals(name)) {\n+                transition(TreeBuilderState.InRow);\n+                break;\n+            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n+                transition(TreeBuilderState.InTableBody);\n+                break;\n+            } else if (\"caption\".equals(name)) {\n+                transition(TreeBuilderState.InCaption);\n+                break;\n+            } else if (\"colgroup\".equals(name)) {\n+                transition(TreeBuilderState.InColumnGroup);\n+                break; // frag\n+            } else if (\"table\".equals(name)) {\n+                transition(TreeBuilderState.InTable);\n+                break;\n+            } else if (\"head\".equals(name)) {\n+                transition(TreeBuilderState.InBody);\n+                break; // frag\n+            } else if (\"body\".equals(name)) {\n+                transition(TreeBuilderState.InBody);\n+                break;\n+            } else if (\"frameset\".equals(name)) {\n+                transition(TreeBuilderState.InFrameset);\n+                break; // frag\n+            } else if (\"html\".equals(name)) {\n+                transition(TreeBuilderState.BeforeHead);\n+                break; // frag\n+            } else if (last) {\n+                transition(TreeBuilderState.InBody);\n+                break; // frag\n+            }\n+        }\n+    }\n+\n+    // todo: tidy up in specific scope methods\n+    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n+        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n+    }\n+\n+    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (StringUtil.in(elName, targetNames))\n+                return true;\n+            if (StringUtil.in(elName, baseTypes))\n+                return false;\n+            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    boolean inScope(String[] targetNames) {\n+        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n+    }\n+\n+    boolean inScope(String targetName) {\n+        return inScope(targetName, null);\n+    }\n+\n+    boolean inScope(String targetName, String[] extras) {\n+        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n+        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n+        // todo: in svg namespace: forignOjbect, desc, title\n+    }\n+\n+    boolean inListItemScope(String targetName) {\n+        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n+    }\n+\n+    boolean inButtonScope(String targetName) {\n+        return inScope(targetName, new String[]{\"button\"});\n+    }\n+\n+    boolean inTableScope(String targetName) {\n+        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n+    }\n+\n+    boolean inSelectScope(String targetName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (elName.equals(targetName))\n+                return true;\n+            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    void setHeadElement(Element headElement) {\n+        this.headElement = headElement;\n+    }\n+\n+    Element getHeadElement() {\n+        return headElement;\n+    }\n+\n+    boolean isFosterInserts() {\n+        return fosterInserts;\n+    }\n+\n+    void setFosterInserts(boolean fosterInserts) {\n+        this.fosterInserts = fosterInserts;\n+    }\n+\n+    Element getFormElement() {\n+        return formElement;\n+    }\n+\n+    void setFormElement(Element formElement) {\n+        this.formElement = formElement;\n+    }\n+\n+    void newPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<Token.Character>();\n+    }\n+\n+    List<Token.Character> getPendingTableCharacters() {\n+        return pendingTableCharacters;\n+    }\n+\n+    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+        this.pendingTableCharacters = pendingTableCharacters;\n+    }\n+\n+    /**\n+     11.2.5.2 Closing elements that have implied end tags<p/>\n+     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n+     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n+     the UA must pop the current node off the stack of open elements.\n+\n+     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n+     process, then the UA must perform the above steps as if that element was not in the above list.\n+     */\n+    void generateImpliedEndTags(String excludeTag) {\n+        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n+                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n+            pop();\n+    }\n+\n+    void generateImpliedEndTags() {\n+        generateImpliedEndTags(null);\n+    }\n+\n+    boolean isSpecial(Element el) {\n+        // todo: mathml's mi, mo, mn\n+        // todo: svg's foreigObject, desc, title\n+        String name = el.nodeName();\n+        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n+                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n+                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n+                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n+                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n+                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n+                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n+                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n+    }\n+\n+    // active formatting elements\n+    void pushActiveFormattingElements(Element in) {\n+        int numSeen = 0;\n+        Iterator<Element> iter = formattingElements.descendingIterator();\n+        while (iter.hasNext()) {\n+            Element el =  iter.next();\n+            if (el == null) // marker\n+                break;\n+\n+            if (isSameFormattingElement(in, el))\n+                numSeen++;\n+\n+            if (numSeen == 3) {\n+                iter.remove();\n+                break;\n+            }\n+        }\n+        formattingElements.add(in);\n+    }\n+\n+    private boolean isSameFormattingElement(Element a, Element b) {\n+        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n+        return a.nodeName().equals(b.nodeName()) &&\n+                // a.namespace().equals(b.namespace()) &&\n+                a.attributes().equals(b.attributes());\n+        // todo: namespaces\n+    }\n+\n+    void reconstructFormattingElements() {\n+        int size = formattingElements.size();\n+        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n+            return;\n+\n+        Element entry = formattingElements.getLast();\n+        int pos = size - 1;\n+        boolean skip = false;\n+        while (true) {\n+            if (pos == 0) { // step 4. if none before, skip to 8\n+                skip = true;\n+                break;\n+            }\n+            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n+            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n+                break; // jump to 8, else continue back to 4\n+        }\n+        while(true) {\n+            if (!skip) // step 7: on later than entry\n+                entry = formattingElements.get(++pos);\n+\n+            // 8. create new element from element, 9 insert into current node, onto stack\n+            skip = false; // can only skip increment from 4.\n+            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n+            // newEl.namespace(entry.namespace()); // todo: namespaces\n+            newEl.attributes().addAll(entry.attributes());\n+\n+            // 10. replace entry with new entry\n+            formattingElements.add(pos, newEl);\n+            formattingElements.remove(pos + 1);\n+\n+            // 11\n+            if (pos == size-1) // if not last entry in list, jump to 7\n+                break;\n+        }\n+    }\n+\n+    void clearFormattingElementsToLastMarker() {\n+        while (!formattingElements.isEmpty()) {\n+            Element el = formattingElements.peekLast();\n+            formattingElements.removeLast();\n+            if (el == null)\n+                break;\n+        }\n+    }\n+\n+    void removeFromActiveFormattingElements(Element el) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    boolean isInActiveFormattingElements(Element el) {\n+        return isElementInQueue(formattingElements, el);\n+    }\n+\n+    Element getActiveFormattingElement(String nodeName) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == null) // scope marker\n+                break;\n+            else if (next.nodeName().equals(nodeName))\n+                return next;\n+        }\n+        return null;\n+    }\n+\n+    void replaceActiveFormattingElement(Element out, Element in) {\n+        replaceInQueue(formattingElements, out, in);\n+    }\n+\n+    void insertMarkerToFormattingElements() {\n+        formattingElements.add(null);\n+    }\n+\n+    void insertInFosterParent(Node in) {\n+        Element fosterParent = null;\n+        Element lastTable = getFromStack(\"table\");\n+        boolean isLastTableParent = false;\n+        if (lastTable != null) {\n+            if (lastTable.parent() != null) {\n+                fosterParent = lastTable.parent();\n+                isLastTableParent = true;\n+            } else\n+                fosterParent = aboveOnStack(lastTable);\n+        } else { // no table == frag\n+            fosterParent = stack.get(0);\n+        }\n+\n+        if (isLastTableParent)\n+            lastTable.before(in);\n+        else\n+            fosterParent.appendChild(in);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TreeBuilder{\" +\n+                \"currentToken=\" + currentToken +\n+                \", state=\" + state +\n+                \", currentElement=\" + currentElement() +\n+                '}';\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+/**\n+ */\n+public enum TreeBuilderState {\n+    Initial {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return true; // ignore whitespace\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                // todo: parse error check on expected doctypes\n+                // todo: quirk state check on doctype ids\n+                Token.Doctype d = t.asDoctype();\n+                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                tb.getDocument().appendChild(doctype);\n+                if (d.isForceQuirks())\n+                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n+                tb.transition(BeforeHtml);\n+            } else {\n+                // todo: check not iframe srcdoc\n+                tb.transition(BeforeHtml);\n+                return tb.process(t); // re-process token\n+            }\n+            return true;\n+        }\n+    },\n+    BeforeHtml {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (isWhitespace(t)) {\n+                return true; // ignore whitespace\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                tb.insert(t.asStartTag());\n+                tb.transition(BeforeHead);\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+                return anythingElse(t, tb);\n+            } else if (t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.insert(\"html\");\n+            tb.transition(BeforeHead);\n+            return tb.process(t);\n+        }\n+    },\n+    BeforeHead {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return true;\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return InBody.process(t, tb); // does not transition\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\n+                Element head = tb.insert(t.asStartTag());\n+                tb.setHeadElement(head);\n+                tb.transition(InHead);\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+                tb.process(new Token.StartTag(\"head\"));\n+                return tb.process(t);\n+            } else if (t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                tb.process(new Token.StartTag(\"head\"));\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InHead {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+                return true;\n+            }\n+            switch (t.type) {\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    return false;\n+                case StartTag:\n+                    Token.StartTag start = t.asStartTag();\n+                    String name = start.name();\n+                    if (name.equals(\"html\")) {\n+                        return InBody.process(t, tb);\n+                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n+                        Element el = tb.insertEmpty(start);\n+                        // jsoup special: update base as it is seen. todo: flip to current browser behaviour of one shot\n+                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n+                            tb.setBaseUri(el);\n+                    } else if (name.equals(\"meta\")) {\n+                        Element meta = tb.insertEmpty(start);\n+                        // todo: charset switches\n+                    } else if (name.equals(\"title\")) {\n+                        handleRcData(start, tb);\n+                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n+                        handleRawtext(start, tb);\n+                    } else if (name.equals(\"noscript\")) {\n+                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\n+                        tb.insert(start);\n+                        tb.transition(InHeadNoscript);\n+                    } else if (name.equals(\"script\")) {\n+                        // skips some script rules as won't execute them\n+                        tb.insert(start);\n+                        tb.tokeniser.transition(TokeniserState.ScriptData);\n+                        tb.markInsertionMode();\n+                        tb.transition(Text);\n+                    } else if (name.equals(\"head\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        return anythingElse(t, tb);\n+                    }\n+                    break;\n+                case EndTag:\n+                    Token.EndTag end = t.asEndTag();\n+                    name = end.name();\n+                    if (name.equals(\"head\")) {\n+                        tb.pop();\n+                        tb.transition(AfterHead);\n+                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n+                        return anythingElse(t, tb);\n+                    } else {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.process(new Token.EndTag(\"head\"));\n+            return tb.process(t);\n+        }\n+    },\n+    InHeadNoscript {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isDoctype()) {\n+                tb.error(this);\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"noscript\")) {\n+                tb.pop();\n+                tb.transition(InHead);\n+            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n+                return tb.process(t, InHead);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"br\")) {\n+                return anythingElse(t, tb);\n+            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"head\", \"noscript\")) || t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.error(this);\n+            tb.process(new Token.EndTag(\"noscript\"));\n+            return tb.process(t);\n+        }\n+    },\n+    AfterHead {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+            } else if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+                if (name.equals(\"html\")) {\n+                    return tb.process(t, InBody);\n+                } else if (name.equals(\"body\")) {\n+                    tb.insert(startTag);\n+                    tb.framesetOk(false);\n+                    tb.transition(InBody);\n+                } else if (name.equals(\"frameset\")) {\n+                    tb.insert(startTag);\n+                    tb.transition(InFrameset);\n+                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n+                    tb.error(this);\n+                    Element head = tb.getHeadElement();\n+                    tb.push(head);\n+                    tb.process(t, InHead);\n+                    tb.removeFromStack(head);\n+                } else if (name.equals(\"head\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                if (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\n+                    anythingElse(t, tb);\n+                } else {\n+                    tb.error(this);\n+                    return false;\n+                }\n+            } else {\n+                anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.process(new Token.StartTag(\"body\"));\n+            tb.framesetOk(true);\n+            return tb.process(t);\n+        }\n+    },\n+    InBody {\n+        boolean process(Token t, TreeBuilder tb) {\n+            switch (t.type) {\n+                case Character: {\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        // todo confirm that check\n+                        tb.error(this);\n+                        return false;\n+                    } else if (isWhitespace(c)) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(c);\n+                    } else {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(c);\n+                        tb.framesetOk(false);\n+                    }\n+                    break;\n+                }\n+                case Comment: {\n+                    tb.insert(t.asComment());\n+                    break;\n+                }\n+                case Doctype: {\n+                    tb.error(this);\n+                    return false;\n+                }\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"html\")) {\n+                        tb.error(this);\n+                        // merge attributes onto real html\n+                        Element html = tb.getStack().getFirst();\n+                        for (Attribute attribute : startTag.getAttributes()) {\n+                            if (!html.hasAttr(attribute.getKey()))\n+                                html.attributes().put(attribute);\n+                        }\n+                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+                        return tb.process(t, InHead);\n+                    } else if (name.equals(\"body\")) {\n+                        tb.error(this);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n+                            // only in fragment case\n+                            return false; // ignore\n+                        } else {\n+                            tb.framesetOk(false);\n+                            Element body = stack.get(1);\n+                            for (Attribute attribute : startTag.getAttributes()) {\n+                                if (!body.hasAttr(attribute.getKey()))\n+                                    body.attributes().put(attribute);\n+                            }\n+                        }\n+                    } else if (name.equals(\"frameset\")) {\n+                        tb.error(this);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n+                            // only in fragment case\n+                            return false; // ignore\n+                        } else if (!tb.framesetOk()) {\n+                            return false; // ignore frameset\n+                        } else {\n+                            Element second = stack.get(1);\n+                            if (second.parent() != null)\n+                                second.remove();\n+                            // pop up to html element\n+                            while (stack.size() > 1)\n+                                stack.removeLast();\n+                            tb.insert(startTag);\n+                            tb.transition(InFrameset);\n+                        }\n+                    } else if (StringUtil.in(name,\n+                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n+                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n+                            \"p\", \"section\", \"summary\", \"ul\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                            tb.error(this);\n+                            tb.pop();\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        // todo: ignore LF if next token\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"form\")) {\n+                        if (tb.getFormElement() != null) {\n+                            tb.error(this);\n+                            return false;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        Element form = tb.insert(startTag);\n+                        tb.setFormElement(form);\n+                    } else if (name.equals(\"li\")) {\n+                        tb.framesetOk(false);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (el.nodeName().equals(\"li\")) {\n+                                tb.process(new Token.EndTag(\"li\"));\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n+                        tb.framesetOk(false);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n+                                tb.process(new Token.EndTag(el.nodeName()));\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"plaintext\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n+                    } else if (name.equals(\"button\")) {\n+                        if (tb.inButtonScope(\"button\")) {\n+                            // close and reprocess\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"button\"));\n+                            tb.process(startTag);\n+                        } else {\n+                            tb.reconstructFormattingElements();\n+                            tb.insert(startTag);\n+                            tb.framesetOk(false);\n+                        }\n+                    } else if (name.equals(\"a\")) {\n+                        if (tb.getActiveFormattingElement(\"a\") != null) {\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"a\"));\n+\n+                            // still on stack?\n+                            Element remainingA = tb.getFromStack(\"a\");\n+                            if (remainingA != null) {\n+                                tb.removeFromActiveFormattingElements(remainingA);\n+                                tb.removeFromStack(remainingA);\n+                            }\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        Element a = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(a);\n+                    } else if (StringUtil.in(name,\n+                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n+                        tb.reconstructFormattingElements();\n+                        Element el = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(el);\n+                    } else if (name.equals(\"nobr\")) {\n+                        tb.reconstructFormattingElements();\n+                        if (tb.inScope(\"nobr\")) {\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"nobr\"));\n+                            tb.reconstructFormattingElements();\n+                        }\n+                        Element el = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(el);\n+                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                        tb.insertMarkerToFormattingElements();\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"table\")) {\n+                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        tb.framesetOk(false);\n+                        tb.transition(InTable);\n+                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"input\")) {\n+                        tb.reconstructFormattingElements();\n+                        Element el = tb.insertEmpty(startTag);\n+                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n+                            tb.framesetOk(false);\n+                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n+                        tb.insertEmpty(startTag);\n+                    } else if (name.equals(\"hr\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"image\")) {\n+                        // we're not supposed to ask.\n+                        startTag.name(\"img\");\n+                        return tb.process(startTag);\n+                    } else if (name.equals(\"isindex\")) {\n+                        // how much do we care about the early 90s?\n+                        tb.error(this);\n+                        if (tb.getFormElement() != null)\n+                            return false;\n+\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                        tb.process(new Token.StartTag(\"form\"));\n+                        if (startTag.attributes.hasKey(\"action\")) {\n+                            Element form = tb.getFormElement();\n+                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n+                        }\n+                        tb.process(new Token.StartTag(\"hr\"));\n+                        tb.process(new Token.StartTag(\"label\"));\n+                        // hope you like english.\n+                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n+                                startTag.attributes.get(\"prompt\") :\n+                                \"This is a searchable index. Enter search keywords: \";\n+\n+                        tb.process(new Token.Character(prompt));\n+\n+                        // input\n+                        Attributes inputAttribs = new Attributes();\n+                        for (Attribute attr : startTag.attributes) {\n+                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n+                                inputAttribs.put(attr);\n+                        }\n+                        inputAttribs.put(\"name\", \"isindex\");\n+                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n+                        tb.process(new Token.EndTag(\"label\"));\n+                        tb.process(new Token.StartTag(\"hr\"));\n+                        tb.process(new Token.EndTag(\"form\"));\n+                    } else if (name.equals(\"textarea\")) {\n+                        tb.insert(startTag);\n+                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n+                        tb.tokeniser.transition(TokeniserState.Rcdata);\n+                        tb.markInsertionMode();\n+                        tb.framesetOk(false);\n+                        tb.transition(Text);\n+                    } else if (name.equals(\"xmp\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        tb.framesetOk(false);\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"iframe\")) {\n+                        tb.framesetOk(false);\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"noembed\")) {\n+                        // also handle noscript if script enabled\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"select\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                        tb.framesetOk(false);\n+\n+                        TreeBuilderState state = tb.state();\n+                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n+                            tb.transition(InSelectInTable);\n+                        else\n+                            tb.transition(InSelect);\n+                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n+                        if (tb.inScope(\"ruby\")) {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n+                                tb.error(this);\n+                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n+                            }\n+                            tb.insert(startTag);\n+                        }\n+                    } else if (name.equals(\"math\")) {\n+                        tb.reconstructFormattingElements();\n+                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n+                        tb.insert(startTag);\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                    } else if (name.equals(\"svg\")) {\n+                        tb.reconstructFormattingElements();\n+                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n+                        tb.insert(startTag);\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                    } else if (StringUtil.in(name,\n+                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    }\n+                    break;\n+\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (name.equals(\"body\")) {\n+                        if (!tb.inScope(\"body\")) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n+                            tb.transition(AfterBody);\n+                        }\n+                    } else if (name.equals(\"html\")) {\n+                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n+                        if (notIgnored)\n+                            return tb.process(endTag);\n+                    } else if (StringUtil.in(name,\n+                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n+                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n+                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n+                        // todo: refactor these lookups\n+                        if (!tb.inScope(name)) {\n+                            // nothing to close\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"form\")) {\n+                        Element currentForm = tb.getFormElement();\n+                        tb.setFormElement(null);\n+                        if (currentForm == null || !tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            // remove currentForm from stack. will shift anything under up.\n+                            tb.removeFromStack(currentForm);\n+                        }\n+                    } else if (name.equals(\"p\")) {\n+                        if (!tb.inButtonScope(name)) {\n+                            tb.error(this);\n+                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n+                            return tb.process(endTag);\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"li\")) {\n+                        if (!tb.inListItemScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n+                        if (!tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n+                        }\n+                    } else if (name.equals(\"sarcasm\")) {\n+                        // *sigh*\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (StringUtil.in(name,\n+                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n+                        // Adoption Agency Algorithm.\n+                        OUTER:\n+                        for (int i = 0; i < 8; i++) {\n+                            Element formatEl = tb.getActiveFormattingElement(name);\n+                            if (formatEl == null)\n+                                return anyOtherEndTag(t, tb);\n+                            else if (!tb.onStack(formatEl)) {\n+                                tb.error(this);\n+                                tb.removeFromActiveFormattingElements(formatEl);\n+                                return true;\n+                            } else if (!tb.inScope(formatEl.nodeName())) {\n+                                tb.error(this);\n+                                return false;\n+                            } else if (tb.currentElement() != formatEl)\n+                                tb.error(this);\n+\n+                            Element furthestBlock = null;\n+                            Element commonAncestor = null;\n+                            boolean seenFormattingElement = false;\n+                            LinkedList<Element> stack = tb.getStack();\n+                            for (int si = 0; si < stack.size(); si++) {\n+                                Element el = stack.get(si);\n+                                if (el == formatEl) {\n+                                    commonAncestor = stack.get(si - 1);\n+                                    seenFormattingElement = true;\n+                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n+                                    furthestBlock = el;\n+                                    break;\n+                                }\n+                            }\n+                            if (furthestBlock == null) {\n+                                tb.popStackToClose(formatEl.nodeName());\n+                                tb.removeFromActiveFormattingElements(formatEl);\n+                                return true;\n+                            }\n+\n+                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n+                            // does that mean: int pos of format el in list?\n+                            Element node = furthestBlock;\n+                            Element lastNode = furthestBlock;\n+                            INNER:\n+                            for (int j = 0; j < 3; j++) {\n+                                if (tb.onStack(node))\n+                                    node = tb.aboveOnStack(node);\n+                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n+                                    tb.removeFromStack(node);\n+                                    continue INNER;\n+                                } else if (node == formatEl)\n+                                    break INNER;\n+\n+                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n+                                tb.replaceActiveFormattingElement(node, replacement);\n+                                tb.replaceOnStack(node, replacement);\n+                                node = replacement;\n+\n+                                if (lastNode == furthestBlock) {\n+                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n+                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n+                                }\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                node.appendChild(lastNode);\n+\n+                                lastNode = node;\n+                            }\n+\n+                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                tb.insertInFosterParent(lastNode);\n+                            } else {\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                commonAncestor.appendChild(lastNode);\n+                            }\n+\n+                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n+                            for (Node childNode : childNodes) {\n+                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n+                            }\n+                            furthestBlock.appendChild(adopter);\n+                            tb.removeFromActiveFormattingElements(formatEl);\n+                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n+                            tb.removeFromStack(formatEl);\n+                            tb.insertOnStackAfter(furthestBlock, adopter);\n+                        }\n+                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n+                        if (!tb.inScope(\"name\")) {\n+                            if (!tb.inScope(name)) {\n+                                tb.error(this);\n+                                return false;\n+                            }\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                            tb.clearFormattingElementsToLastMarker();\n+                        }\n+                    } else if (name.equals(\"br\")) {\n+                        tb.error(this);\n+                        tb.process(new Token.StartTag(\"br\"));\n+                        return false;\n+                    } else {\n+                        return anyOtherEndTag(t, tb);\n+                    }\n+\n+                    break;\n+                case EOF:\n+                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n+                    // stop parsing\n+                    break;\n+            }\n+            return true;\n+        }\n+\n+        boolean anyOtherEndTag(Token t, TreeBuilder tb) {\n+            String name = t.asEndTag().name();\n+            LinkedList<Element> stack = tb.getStack();\n+            Iterator<Element> it = stack.descendingIterator();\n+            while (it.hasNext()) {\n+                Element node = it.next();\n+                if (node.nodeName().equals(name)) {\n+                    tb.generateImpliedEndTags(name);\n+                    if (!name.equals(tb.currentElement().nodeName()))\n+                        tb.error(this);\n+                    tb.popStackToClose(name);\n+                    break;\n+                } else {\n+                    if (tb.isSpecial(node)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+    },\n+    Text {\n+        // in script, style etc. normally treated as data tags\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isCharacter()) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isEOF()) {\n+                tb.error(this);\n+                // if current node is script: already started\n+                tb.pop();\n+                tb.transition(tb.originalState());\n+                return tb.process(t);\n+            } else if (t.isEndTag()) {\n+                // if: An end tag whose tag name is \"script\" -- scripting nesting level, if evaluating scripts\n+                tb.pop();\n+                tb.transition(tb.originalState());\n+            }\n+            return true;\n+        }\n+    },\n+    InTable {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isCharacter()) {\n+                tb.newPendingTableCharacters();\n+                tb.markInsertionMode();\n+                tb.transition(InTableText);\n+                return tb.process(t);\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+                if (name.equals(\"caption\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insertMarkerToFormattingElements();\n+                    tb.insert(startTag);\n+                    tb.transition(InCaption);\n+                } else if (name.equals(\"colgroup\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InColumnGroup);\n+                } else if (name.equals(\"col\")) {\n+                    tb.process(new Token.StartTag(\"colgroup\"));\n+                    return tb.process(t);\n+                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InTableBody);\n+                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n+                    tb.process(new Token.StartTag(\"tbody\"));\n+                    return tb.process(t);\n+                } else if (name.equals(\"table\")) {\n+                    tb.error(this);\n+                    boolean processed = tb.process(new Token.EndTag(\"table\"));\n+                    if (processed) // only ignored if in fragment\n+                        return tb.process(t);\n+                } else if (StringUtil.in(name, \"style\", \"script\")) {\n+                    return tb.process(t, InHead);\n+                } else if (name.equals(\"input\")) {\n+                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n+                        return anythingElse(t, tb);\n+                    } else {\n+                        tb.insertEmpty(startTag);\n+                    }\n+                } else if (name.equals(\"form\")) {\n+                    tb.error(this);\n+                    if (tb.getFormElement() != null)\n+                        return false;\n+                    else {\n+                        Element form = tb.insertEmpty(startTag);\n+                        tb.setFormElement(form);\n+                    }\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (name.equals(\"table\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.popStackToClose(\"table\");\n+                    }\n+                    tb.resetInsertionMode();\n+                } else if (StringUtil.in(name,\n+                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEOF()) {\n+                if (tb.currentElement().nodeName().equals(\"html\"))\n+                    tb.error(this);\n+                return true; // stops parsing\n+            }\n+            return anythingElse(t, tb);\n+        }\n+\n+        boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.error(this);\n+            boolean processed = true;\n+            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                tb.setFosterInserts(true);\n+                processed = tb.process(t, InBody);\n+                tb.setFosterInserts(false);\n+            } else {\n+                processed = tb.process(t, InBody);\n+            }\n+            return processed;\n+        }\n+    },\n+    InTableText {\n+        boolean process(Token t, TreeBuilder tb) {\n+            switch (t.type) {\n+                case Character:\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.getPendingTableCharacters().add(c);\n+                    }\n+                    break;\n+                default:\n+                    if (tb.getPendingTableCharacters().size() > 0) {\n+                        for (Token.Character character : tb.getPendingTableCharacters()) {\n+                            if (!isWhitespace(character)) {\n+                                // InTable anything else section:\n+                                tb.error(this);\n+                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                                    tb.setFosterInserts(true);\n+                                    tb.process(character, InBody);\n+                                    tb.setFosterInserts(false);\n+                                } else {\n+                                    tb.process(character, InBody);\n+                                }\n+                            } else\n+                                tb.insert(character);\n+                        }\n+                        tb.newPendingTableCharacters();\n+                    }\n+                    tb.transition(tb.originalState());\n+                    return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InCaption {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isEndTag() && t.asEndTag().name().equals(\"caption\")) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+                if (!tb.inTableScope(name)) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.generateImpliedEndTags();\n+                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n+                        tb.error(this);\n+                    tb.popStackToClose(\"caption\");\n+                    tb.clearFormattingElementsToLastMarker();\n+                    tb.transition(InTable);\n+                }\n+            } else if ((\n+                    t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n+                            t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n+                    ) {\n+                tb.error(this);\n+                boolean processed = tb.process(new Token.EndTag(\"caption\"));\n+                if (processed)\n+                    return tb.process(t);\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n+                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return tb.process(t, InBody);\n+            }\n+            return true;\n+        }\n+    },\n+    InColumnGroup {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+                return true;\n+            }\n+            switch (t.type) {\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    break;\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"html\"))\n+                        return tb.process(t, InBody);\n+                    else if (name.equals(\"col\"))\n+                        tb.insertEmpty(startTag);\n+                    else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (name.equals(\"colgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"html\")) { // frag case\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.pop();\n+                            tb.transition(InTable);\n+                        }\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EOF:\n+                    if (tb.currentElement().nodeName().equals(\"html\"))\n+                        return true; // stop parsing; frag case\n+                    else\n+                        return anythingElse(t, tb);\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            boolean processed = tb.process(new Token.EndTag(\"colgroup\"));\n+            if (processed) // only ignored in frag case\n+                return tb.process(t);\n+            return true;\n+        }\n+    },\n+    InTableBody {\n+        boolean process(Token t, TreeBuilder tb) {\n+            switch (t.type) {\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"tr\")) {\n+                        tb.clearStackToTableBodyContext();\n+                        tb.insert(startTag);\n+                        tb.transition(InRow);\n+                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n+                        tb.error(this);\n+                        tb.process(new Token.StartTag(\"tr\"));\n+                        return tb.process(startTag);\n+                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n+                        return exitTableBody(t, tb);\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                        if (!tb.inTableScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.clearStackToTableBodyContext();\n+                            tb.pop();\n+                            tb.transition(InTable);\n+                        }\n+                    } else if (name.equals(\"table\")) {\n+                        return exitTableBody(t, tb);\n+                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean exitTableBody(Token t, TreeBuilder tb) {\n+            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n+                // frag case\n+                tb.error(this);\n+                return false;\n+            }\n+            tb.clearStackToTableBodyContext();\n+            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead\n+            return tb.process(t);\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            return tb.process(t, InTable);\n+        }\n+    },\n+    InRow {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+\n+                if (StringUtil.in(name, \"th\", \"td\")) {\n+                    tb.clearStackToTableRowContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InCell);\n+                    tb.insertMarkerToFormattingElements();\n+                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                    return handleMissingTr(t, tb);\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (name.equals(\"tr\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this); // frag\n+                        return false;\n+                    }\n+                    tb.clearStackToTableRowContext();\n+                    tb.pop(); // tr\n+                    tb.transition(InTableBody);\n+                } else if (name.equals(\"table\")) {\n+                    return handleMissingTr(t, tb);\n+                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    tb.process(new Token.EndTag(\"tr\"));\n+                    return tb.process(t);\n+                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            return tb.process(t, InTable);\n+        }\n+\n+        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n+            boolean processed = tb.process(new Token.EndTag(\"tr\"));\n+            if (processed)\n+                return tb.process(t);\n+            else\n+                return false;\n+        }\n+    },\n+    InCell {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (StringUtil.in(name, \"td\", \"th\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\n+                        return false;\n+                    }\n+                    tb.generateImpliedEndTags();\n+                    if (!tb.currentElement().nodeName().equals(name))\n+                        tb.error(this);\n+                    tb.popStackToClose(name);\n+                    tb.clearFormattingElementsToLastMarker();\n+                    tb.transition(InRow);\n+                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    closeCell(tb);\n+                    return tb.process(t);\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isStartTag() &&\n+                    StringUtil.in(t.asStartTag().name(),\n+                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n+                    tb.error(this);\n+                    return false;\n+                }\n+                closeCell(tb);\n+                return tb.process(t);\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            return tb.process(t, InBody);\n+        }\n+\n+        private void closeCell(TreeBuilder tb) {\n+            if (tb.inTableScope(\"td\"))\n+                tb.process(new Token.EndTag(\"td\"));\n+            else\n+                tb.process(new Token.EndTag(\"th\")); // only here if th or td in scope\n+        }\n+    },\n+    InSelect {\n+        boolean process(Token t, TreeBuilder tb) {\n+            switch (t.type) {\n+                case Character:\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.insert(c);\n+                    }\n+                    break;\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    return false;\n+                case StartTag:\n+                    Token.StartTag start = t.asStartTag();\n+                    String name = start.name();\n+                    if (name.equals(\"html\"))\n+                        return tb.process(start, InBody);\n+                    else if (name.equals(\"option\")) {\n+                        tb.process(new Token.EndTag(\"option\"));\n+                        tb.insert(start);\n+                    } else if (name.equals(\"optgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                            tb.process(new Token.EndTag(\"optgroup\"));\n+                        tb.insert(start);\n+                    } else if (name.equals(\"select\")) {\n+                        tb.error(this);\n+                        return tb.process(new Token.EndTag(\"select\"));\n+                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n+                        tb.error(this);\n+                        if (!tb.inSelectScope(\"select\"))\n+                            return false; // frag\n+                        tb.process(new Token.EndTag(\"select\"));\n+                        return tb.process(start);\n+                    } else if (name.equals(\"script\")) {\n+                        return tb.process(t, InHead);\n+                    } else {\n+                        return anythingElse(t, tb);\n+                    }\n+                    break;\n+                case EndTag:\n+                    Token.EndTag end = t.asEndTag();\n+                    name = end.name();\n+                    if (name.equals(\"optgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                            tb.pop();\n+                        else\n+                            tb.error(this);\n+                    } else if (name.equals(\"option\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.pop();\n+                        else\n+                            tb.error(this);\n+                    } else if (name.equals(\"select\")) {\n+                        if (!tb.inSelectScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.popStackToClose(name);\n+                            tb.resetInsertionMode();\n+                        }\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EOF:\n+                    if (!tb.currentElement().nodeName().equals(\"html\"))\n+                        tb.error(this);\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.error(this);\n+            return false;\n+        }\n+    },\n+    InSelectInTable {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                tb.process(new Token.EndTag(\"select\"));\n+                return tb.process(t);\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                if (tb.inTableScope(t.asEndTag().name())) {\n+                    tb.process(new Token.EndTag(\"select\"));\n+                    return (tb.process(t));\n+                } else\n+                    return false;\n+            } else {\n+                return tb.process(t, InSelect);\n+            }\n+        }\n+    },\n+    AfterBody {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return tb.process(t, InBody);\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment()); // into html node\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+                if (tb.isFragmentParsing()) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.transition(AfterAfterBody);\n+                }\n+            } else if (t.isEOF()) {\n+                // chillax! we're done\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InFrameset {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag()) {\n+                Token.StartTag start = t.asStartTag();\n+                String name = start.name();\n+                if (name.equals(\"html\")) {\n+                    return tb.process(start, InBody);\n+                } else if (name.equals(\"frameset\")) {\n+                    tb.insert(start);\n+                } else if (name.equals(\"frame\")) {\n+                    tb.insertEmpty(start);\n+                } else if (name.equals(\"noframes\")) {\n+                    return tb.process(start, InHead);\n+                } else {\n+                    tb.error(this);\n+                    return false;\n+                }\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"frameset\")) {\n+                if (tb.currentElement().nodeName().equals(\"html\")) { // frag\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.pop();\n+                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n+                        tb.transition(AfterFrameset);\n+                    }\n+                }\n+            } else if (t.isEOF()) {\n+                if (!tb.currentElement().nodeName().equals(\"html\")) {\n+                    tb.error(this);\n+                    return true;\n+                }\n+            } else {\n+                tb.error(this);\n+                return false;\n+            }\n+            return true;\n+        }\n+    },\n+    AfterFrameset {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+                tb.transition(AfterAfterFrameset);\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+                return tb.process(t, InHead);\n+            } else if (t.isEOF()) {\n+                // cool your heels, we're complete\n+            } else {\n+                tb.error(this);\n+                return false;\n+            }\n+            return true;\n+        }\n+    },\n+    AfterAfterBody {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEOF()) {\n+                // nice work chuck\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    AfterAfterFrameset {\n+        boolean process(Token t, TreeBuilder tb) {\n+            if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEOF()) {\n+                // nice work chuck\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"nofrmes\")) {\n+                return tb.process(t, InHead);\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    ForeignContent {\n+        boolean process(Token t, TreeBuilder tb) {\n+            return true;\n+            // todo: implement. Also; how do we get here?\n+        }\n+    };\n+\n+    private static String nullString = String.valueOf(0x0000);\n+\n+    abstract boolean process(Token t, TreeBuilder tb);\n+\n+    private static boolean isWhitespace(Token t) {\n+        if (t.isCharacter()) {\n+            String data = t.asCharacter().getData();\n+            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n+            for (int i = 0; i < data.length(); i++) {\n+                char c = data.charAt(i);\n+                if (!Character.isWhitespace(c))\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {\n+        tb.insert(startTag);\n+        tb.tokeniser.transition(TokeniserState.Rcdata);\n+        tb.markInsertionMode();\n+        tb.transition(Text);\n+    }\n+\n+    private static void handleRawtext(Token.StartTag startTag, TreeBuilder tb) {\n+        tb.insert(startTag);\n+        tb.tokeniser.transition(TokeniserState.Rawtext);\n+        tb.markInsertionMode();\n+        tb.transition(Text);\n+    }\n+}\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n     }\n \n     @Test public void testNormalisesStructure() {\n-        Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body></html>\");\n-        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>\");\n+        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testClone() {\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n     @Test public void testAppendRowToTable() {\n         Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n-        Element table = doc.select(\"table\").first();\n+        Element table = doc.select(\"tbody\").first();\n         table.append(\"<tr><td>2</td></tr>\");\n \n-        assertEquals(\"<table><tr><td>1</td></tr><tr><td>2</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"<table><tbody><tr><td>1</td></tr><tr><td>2</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n         @Test public void testPrependRowToTable() {\n         Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n-        Element table = doc.select(\"table\").first();\n+        Element table = doc.select(\"tbody\").first();\n         table.prepend(\"<tr><td>2</td></tr>\");\n \n-        assertEquals(\"<table><tr><td>2</td></tr><tr><td>1</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"<table><tbody><tr><td>2</td></tr><tr><td>1</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n \n         // check sibling index (reindexChildren):\n         Elements ps = doc.select(\"tr\");\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n         assertTrue(doc.ownerDocument() == doc);\n         assertNull(doc.parent());\n     }\n+\n+    @Test public void before() {\n+        Document doc = Jsoup.parse(\"<p>One <b>two</b> three</p>\");\n+        Element newNode = new Element(Tag.valueOf(\"em\"), \"\");\n+        newNode.appendText(\"four\");\n+\n+        doc.select(\"b\").first().before(newNode);\n+        assertEquals(\"<p>One <em>four</em><b>two</b> three</p>\", doc.body().html());\n+\n+        doc.select(\"b\").first().before(\"<i>five</i>\");\n+        assertEquals(\"<p>One <em>four</em><i>five</i><b>two</b> three</p>\", doc.body().html());\n+    }\n+\n+    @Test public void after() {\n+        Document doc = Jsoup.parse(\"<p>One <b>two</b> three</p>\");\n+        Element newNode = new Element(Tag.valueOf(\"em\"), \"\");\n+        newNode.appendText(\"four\");\n+\n+        doc.select(\"b\").first().after(newNode);\n+        assertEquals(\"<p>One <b>two</b><em>four</em> three</p>\", doc.body().html());\n+\n+        doc.select(\"b\").first().after(\"<i>five</i>\");\n+        assertEquals(\"<p>One <b>two</b><i>five</i><em>four</em> three</p>\", doc.body().html());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n         assertEquals(0, attr.size());\n     }\n \n-    @Test public void emptyOnNoKey() {\n+    @Test public void canStartWithEq() {\n         String html = \"<a =empty />\";\n         Element el = Jsoup.parse(html).getElementsByTag(\"a\").get(0);\n         Attributes attr = el.attributes();\n-        assertEquals(0, attr.size());\n+        assertEquals(1, attr.size());\n+        assertTrue(attr.hasKey(\"=empty\"));\n+        assertEquals(\"\", attr.get(\"=empty\"));\n     }\n \n     @Test public void strictAttributeUnescapes() {\n         String html = \"<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>\";\n         Elements els = Jsoup.parse(html).select(\"a\");\n-        assertEquals(\"?foo=bar&mid&lt=true\", els.first().attr(\"href\"));\n+        assertEquals(\"?foo=bar\u2223&lt=true\", els.first().attr(\"href\")); // &mid gets to \u2223 because not tailed by =; lt is so not unescaped\n         assertEquals(\"?foo=bar<qux&lg=1\", els.last().attr(\"href\"));\n     }\n }\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n \n import java.util.List;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests for the Parser\n         assertEquals(\"p\", p.tagName());\n         assertEquals(\"foo > bar\", p.attr(\"class\"));\n     }\n-    \n+\n     @Test public void parsesQuiteRoughAttributes() {\n-        String html = \"<p =a>One<a =a\";\n-        Document doc = Jsoup.parse(html);\n-        assertEquals(\"<p>One<a></a></p>\", doc.body().html());\n-        \n-        doc = Jsoup.parse(\"<p .....\");\n-        assertEquals(\"<p></p>\", doc.body().html());\n-        \n-        doc = Jsoup.parse(\"<p .....<p!!\");\n-        assertEquals(\"<p></p>\\n<p></p>\", doc.body().html());\n+        String html = \"<p =a>One<a <p>Something</p>Else\";\n+        // this gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<p =a=\\\"\\\">One<a <p=\\\"\\\">Something</a></p>\\n\" +\n+                \"<a <p=\\\"\\\">Else</a>\", doc.body().html());\n+\n+        doc = Jsoup.parse(\"<p .....>\");\n+        assertEquals(\"<p .....=\\\"\\\"></p>\", doc.body().html());\n     }\n \n     @Test public void parsesComments() {\n         String html = \"<html><head></head><body><img src=foo><!-- <table><tr><td></table> --><p>Hello</p></body></html>\";\n         Document doc = Jsoup.parse(html);\n-        \n+\n         Element body = doc.body();\n         Comment comment = (Comment) body.childNode(1); // comment should not be sub of img, as it's an empty tag\n         assertEquals(\" <table><tr><td></table> \", comment.getData());\n         assertEquals(\" <tr><td>\", comment.getData());\n     }\n \n-    @Test public void parsesUnterminatedTag() {\n+    @Test public void dropsUnterminatedTag() {\n+        // jsoup used to parse this to <p>, but whatwg, webkit will drop.\n         String h1 = \"<p\";\n         Document doc = Jsoup.parse(h1);\n-        assertEquals(1, doc.getElementsByTag(\"p\").size());\n+        assertEquals(0, doc.getElementsByTag(\"p\").size());\n+        assertEquals(\"\", doc.text());\n \n         String h2 = \"<div id=1<p id='2'\";\n         doc = Jsoup.parse(h2);\n-        Element d = doc.getElementById(\"1\");\n-        assertEquals(1, d.children().size());\n-        Element p = doc.getElementById(\"2\");\n-        assertNotNull(p);\n-    }\n-\n-    @Test public void parsesUnterminatedAttribute() {\n+        assertEquals(\"\", doc.text());\n+    }\n+\n+    @Test public void dropsUnterminatedAttribute() {\n+        // jsoup used to parse this to <p id=\"foo\">, but whatwg, webkit will drop.\n         String h1 = \"<p id=\\\"foo\";\n         Document doc = Jsoup.parse(h1);\n-        Element p = doc.getElementById(\"foo\");\n-        assertNotNull(p);\n-        assertEquals(\"p\", p.tagName());\n-    }\n-    \n+        assertEquals(\"\", doc.text());\n+    }\n+\n     @Test public void parsesUnterminatedTextarea() {\n         Document doc = Jsoup.parse(\"<body><p><textarea>one<p>two\");\n         Element t = doc.select(\"textarea\").first();\n         assertEquals(\"one<p>two\", t.text());\n     }\n-    \n+\n     @Test public void parsesUnterminatedOption() {\n+        // bit weird this -- browsers and spec get stuck in select until there's a </select>\n         Document doc = Jsoup.parse(\"<body><p><select><option>One<option>Two</p><p>Three</p>\");\n         Elements options = doc.select(\"option\");\n         assertEquals(2, options.size());\n         assertEquals(\"One\", options.first().text());\n-        assertEquals(\"Two\", options.last().text());\n-    }\n-    \n+        assertEquals(\"TwoThree\", options.last().text());\n+    }\n+\n     @Test public void testSpaceAfterTag() {\n         Document doc = Jsoup.parse(\"<div > <a name=\\\"top\\\"></a ><p id=1 >Hello</p></div>\");\n         assertEquals(\"<div> <a name=\\\"top\\\"></a><p id=\\\"1\\\">Hello</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n         // needs to move into the start of the body\n         String html = \"foo <b>bar</b> baz\";\n         Document doc = Jsoup.parse(html);\n-        assertEquals (\"foo bar baz\", doc.text());\n+        assertEquals(\"foo bar baz\", doc.text());\n \n     }\n \n         Document doc = Jsoup.parse(h);\n         assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n-    \n+\n     @Test public void handlesTextArea() {\n         Document doc = Jsoup.parse(\"<textarea>Hello</textarea>\");\n         Elements els = doc.select(\"textarea\");\n         assertEquals(\"Hello\", els.val());\n     }\n \n-    @Test public void createsImplicitLists() {\n+    @Test public void doesNotCreateImplicitLists() {\n+        // old jsoup used to wrap this in <ul>, but that's not to spec\n         String h = \"<li>Point one<li>Point two\";\n         Document doc = Jsoup.parse(h);\n-        Elements ol = doc.select(\"ul\"); // should have created a default ul.\n-        assertEquals(1, ol.size());\n-        assertEquals(2, ol.get(0).children().size());\n+        Elements ol = doc.select(\"ul\"); // should NOT have created a default ul.\n+        assertEquals(0, ol.size());\n+        Elements lis = doc.select(\"li\");\n+        assertEquals(2, lis.size());\n+        assertEquals(\"body\", lis.first().parent().tagName());\n \n         // no fiddling with non-implicit lists\n         String h2 = \"<ol><li><p>Point the first<li><p>Point the second\";\n         assertEquals(1, doc2.select(\"ol li\").get(0).children().size()); // one p in first li\n     }\n \n-    @Test public void createsImplicitTable() {\n+    @Test public void discardsNakedTds() {\n+        // jsoup used to make this into an implicit table; but browsers make it into a text run\n         String h = \"<td>Hello<td><p>There<p>now\";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(\"<table><tbody><tr><td>Hello</td><td><p>There</p><p>now</p></td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"Hello<p>There</p><p>now</p>\", TextUtil.stripNewlines(doc.body().html()));\n         // <tbody> is introduced if no implicitly creating table, but allows tr to be directly under table\n     }\n \n-     @Test public void handlesNestedImplicitTable() {\n+    @Test public void handlesNestedImplicitTable() {\n         Document doc = Jsoup.parse(\"<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>\");\n-        assertEquals(\"<table><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tr><td>3</td> <td>4</td></tr></table> </td></tr><tr><td>5</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n-    }\n-    \n+        assertEquals(\"<table><tbody><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tbody><tr><td>3</td> <td>4</td></tr></tbody></table> </td></tr><tr><td>5</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n     @Test public void handlesWhatWgExpensesTableExample() {\n         // http://www.whatwg.org/specs/web-apps/current-work/multipage/tabular-data.html#examples-0\n         Document doc = Jsoup.parse(\"<table> <colgroup> <col> <colgroup> <col> <col> <col> <thead> <tr> <th> <th>2008 <th>2007 <th>2006 <tbody> <tr> <th scope=rowgroup> Research and development <td> $ 1,109 <td> $ 782 <td> $ 712 <tr> <th scope=row> Percentage of net sales <td> 3.4% <td> 3.3% <td> 3.7% <tbody> <tr> <th scope=rowgroup> Selling, general, and administrative <td> $ 3,761 <td> $ 2,963 <td> $ 2,433 <tr> <th scope=row> Percentage of net sales <td> 11.6% <td> 12.3% <td> 12.6% </table>\");\n         assertEquals(\"<table> <colgroup> <col /> </colgroup><colgroup> <col /> <col /> <col /> </colgroup><thead> <tr> <th> </th><th>2008 </th><th>2007 </th><th>2006 </th></tr></thead><tbody> <tr> <th scope=\\\"rowgroup\\\"> Research and development </th><td> $ 1,109 </td><td> $ 782 </td><td> $ 712 </td></tr><tr> <th scope=\\\"row\\\"> Percentage of net sales </th><td> 3.4% </td><td> 3.3% </td><td> 3.7% </td></tr></tbody><tbody> <tr> <th scope=\\\"rowgroup\\\"> Selling, general, and administrative </th><td> $ 3,761 </td><td> $ 2,963 </td><td> $ 2,433 </td></tr><tr> <th scope=\\\"row\\\"> Percentage of net sales </th><td> 11.6% </td><td> 12.3% </td><td> 12.6% </td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n-    \n+\n     @Test public void handlesTbodyTable() {\n         Document doc = Jsoup.parse(\"<html><head></head><body><table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table></body></html>\");\n         assertEquals(\"<table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n-    \n+\n     @Test public void handlesImplicitCaptionClose() {\n         Document doc = Jsoup.parse(\"<table><caption>A caption<td>One<td>Two\");\n-        assertEquals(\"<table><caption>A caption</caption><tr><td>One</td><td>Two</td></tr></table>\", TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"<table><caption>A caption</caption><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void noTableDirectInTable() {\n         Document doc = Jsoup.parse(\"<table> <td>One <td><table><td>Two</table> <table><td>Three\");\n-        assertEquals(\"<table> <tr><td>One </td><td><table><tr><td>Two</td></tr></table> <table><tr><td>Three</td></tr></table></td></tr></table>\", \n-            TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"<table> <tbody><tr><td>One </td><td><table><tbody><tr><td>Two</td></tr></tbody></table> <table><tbody><tr><td>Three</td></tr></tbody></table></td></tr></tbody></table>\",\n+                TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void ignoresDupeEndTrTag() {\n         Document doc = Jsoup.parse(\"<table><tr><td>One</td><td><table><tr><td>Two</td></tr></tr></table></td><td>Three</td></tr></table>\"); // two </tr></tr>, must ignore or will close table\n-        assertEquals(\"<table><tr><td>One</td><td><table><tr><td>Two</td></tr></table></td><td>Three</td></tr></table>\",\n-            TextUtil.stripNewlines(doc.body().html()));\n+        assertEquals(\"<table><tbody><tr><td>One</td><td><table><tbody><tr><td>Two</td></tr></tbody></table></td><td>Three</td></tr></tbody></table>\",\n+                TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void handlesBaseTags() {\n+        // todo -- don't handle base tags like this -- spec and browsers don't (any more -- v. old ones do).\n+        // instead, just maintain one baseUri in the doc\n         String h = \"<a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=4>#</a>\";\n         Document doc = Jsoup.parse(h, \"http://foo/\");\n         assertEquals(\"http://bar\", doc.baseUri()); // gets updated as base changes, so doc.createElement has latest.\n     }\n \n     @Test public void handlesCdata() {\n-        String h = \"<div id=1><![CData[<html>\\n<foo><&amp;]]></div>\"; // \"cdata\" insensitive. the &amp; in there should remain literal\n+        // todo: as this is html namespace, should actually treat as bogus comment, not cdata. keep as cdata for now\n+        String h = \"<div id=1><![CDATA[<html>\\n<foo><&amp;]]></div>\"; // the &amp; in there should remain literal\n         Document doc = Jsoup.parse(h);\n         Element div = doc.getElementById(\"1\");\n         assertEquals(\"<html> <foo><&amp;\", div.text());\n         Document doc = Jsoup.parse(h);\n         assertEquals(\"Hello < There <&>\", doc.select(\"div\").first().text());\n     }\n-    \n+\n     @Test public void handlesUnknownTags() {\n         String h = \"<div><foo title=bar>Hello<foo title=qux>there</foo></div>\";\n         Document doc = Jsoup.parse(h);\n         String out = doc.body().html();\n         assertEquals(h, TextUtil.stripNewlines(out));\n     }\n-    \n+\n+    @Test public void parsesBodyFragment() {\n+        String h = \"<!-- comment --><p><a href='foo'>One</a></p>\";\n+        Document doc = Jsoup.parseBodyFragment(h, \"http://example.com\");\n+        assertEquals(\"<body><!-- comment --><p><a href=\\\"foo\\\">One</a></p></body>\", TextUtil.stripNewlines(doc.body().outerHtml()));\n+        assertEquals(\"http://example.com/foo\", doc.select(\"a\").first().absUrl(\"href\"));\n+    }\n+\n     @Test public void handlesUnknownNamespaceTags() {\n-        String h = \"<foo:bar id=1/><abc:def id=2>Foo<p>Hello</abc:def><foo:bar>There</foo:bar>\";\n+        // note that the first foo:bar should not really be allowed to be self closing, if parsed in html mode.\n+        String h = \"<foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>\";\n         Document doc = Jsoup.parse(h);\n         assertEquals(\"<foo:bar id=\\\"1\\\" /><abc:def id=\\\"2\\\">Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n-    \n-    @Test public void handlesEmptyBlocks() {\n-        String h = \"<div id=1/><div id=2><img /></div> <hr /> hr text\";\n+\n+    @Test public void handlesKnownEmptyBlocks() {\n+        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.\n+        String h = \"<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two\";\n         Document doc = Jsoup.parse(h);\n         Element div1 = doc.getElementById(\"1\");\n-        assertTrue(div1.children().isEmpty());\n+        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...\n         assertTrue(doc.select(\"hr\").first().children().isEmpty());\n-    }\n-    \n+        assertTrue(doc.select(\"hr\").last().children().isEmpty());\n+        assertTrue(doc.select(\"img\").first().children().isEmpty());\n+        assertTrue(doc.select(\"img\").last().children().isEmpty());\n+    }\n+\n+    @Test public void handlesSolidusAtAttributeEnd() {\n+        // this test makes sure [<a href=/>link</a>] is parsed as [<a href=\"/\">link</a>], not [<a href=\"\" /><a>link</a>]\n+        String h = \"<a href=/>link</a>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<a href=\\\"/\\\">link</a>\", doc.body().html());\n+    }\n+\n     @Test public void handlesMultiClosingBody() {\n         String h = \"<body><p>Hello</body><p>there</p></body></body></html><p>now\";\n         Document doc = Jsoup.parse(h);\n         assertEquals(3, doc.select(\"p\").size());\n         assertEquals(3, doc.body().children().size());\n     }\n-    \n+\n     @Test public void handlesUnclosedDefinitionLists() {\n+        // jsoup used to create a <dl>, but that's not to spec\n         String h = \"<dt>Foo<dd>Bar<dt>Qux<dd>Zug\";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(4, doc.body().getElementsByTag(\"dl\").first().children().size());\n+        assertEquals(0, doc.select(\"dl\").size()); // no auto dl\n+        assertEquals(4, doc.select(\"dt, dd\").size());\n         Elements dts = doc.select(\"dt\");\n         assertEquals(2, dts.size());\n         assertEquals(\"Zug\", dts.get(1).nextElementSibling().text());\n     @Test public void handlesFrames() {\n         String h = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=foo></frame><frame src=foo></frameset></html>\";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(\"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset><body></body></html>\",\n+        assertEquals(\"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n+        // no body auto vivification\n     }\n \n     @Test public void handlesJavadocFont() {\n     @Test public void normalisesDocument() {\n         String h = \"<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven \";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(\"<!doctype html><html><head><link /></head><body>One Two Four Three Five Six Seven </body></html>\",\n-                TextUtil.stripNewlines(doc.html())); // is spaced OK if not newline & space stripped\n+        assertEquals(\"<!DOCTYPE html><html><head></head><body>OneTwoThree<link />FourFive Six Seven </body></html>\",\n+                TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void normalisesEmptyDocument() {\n         Document doc = Jsoup.parse(\"\");\n-        assertEquals(\"<html><head></head><body></body></html>\",TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head></head><body></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void normalisesHeadlessBody() {\n         assertEquals(\"<html><head></head><body><span class=\\\"foo\\\">bar</span></body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n-    \n+\n     @Test public void findsCharsetInMalformedMeta() {\n         String h = \"<meta http-equiv=Content-Type content=text/html; charset=gb2312>\";\n         // example cited for reason of html5's <meta charset> element\n         Document doc = Jsoup.parse(h);\n         assertEquals(\"gb2312\", doc.select(\"meta\").attr(\"charset\"));\n     }\n-    \n+\n     @Test public void testHgroup() {\n+        // jsoup used to not allow hroup in h{n}, but that's not in spec, and browsers are OK\n         Document doc = Jsoup.parse(\"<h1>Hello <h2>There <hgroup><h1>Another<h2>headline</hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup>\");\n-        assertEquals(\"<h1>Hello </h1><h2>There </h2><hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1></hgroup><p>stuff</p>\", TextUtil.stripNewlines(doc.body().html()));\n-    }\n-    \n+        assertEquals(\"<h1>Hello </h1><h2>There <hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup></h2>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n     @Test public void testRelaxedTags() {\n         Document doc = Jsoup.parse(\"<abc_def id=1>Hello</abc_def> <abc-def>There</abc-def>\");\n         assertEquals(\"<abc_def id=\\\"1\\\">Hello</abc_def> <abc-def>There</abc-def>\", TextUtil.stripNewlines(doc.body().html()));\n         assertEquals(\"<span>Hello <div>there</div> <span>now</span></span>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n-    @Test public void testAllowsImageInNoScriptInHead() {\n-        // some sites use this pattern as an analytics mechanism\n+    @Test public void testNoImagesInNoScriptInHead() {\n+        // jsoup used to allow, but against spec if parsing with noscript\n         Document doc = Jsoup.parse(\"<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>\");\n-        assertEquals(\"<html><head><noscript><img src=\\\"foo\\\" /></noscript></head><body><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><noscript></noscript></head><body><img src=\\\"foo\\\" /><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testAFlowContents() {\n         assertEquals(\"<a>Hello <div>there</div> <span>now</span></a>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n-     @Test public void testFontFlowContents() {\n+    @Test public void testFontFlowContents() {\n         // html5 has no definition of <font>; often used as flow\n         Document doc = Jsoup.parse(\"<font>Hello <div>there</div> <span>now</span></font>\");\n         assertEquals(\"<font>Hello <div>there</div> <span>now</span></font>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n+\n+    @Test public void handlesMisnestedTagsBI() {\n+        // whatwg: <b><i></b></i>\n+        String h = \"<p>1<b>2<i>3</b>4</i>5</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<p>1<b>2<i>3</i></b><i>4</i>5</p>\", doc.body().html());\n+        // adoption agency on </b>, reconstruction of formatters on 4.\n+    }\n+\n+    @Test public void handlesMisnestedTagsBP() {\n+        //  whatwg: <b><p></b></p>\n+        String h = \"<b>1<p>2</b>3</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<b>1</b>\\n<p><b>2</b>3</p>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesUnexpectedMarkupInTables() {\n+        // whatwg - tests markers in active formatting (if they didn't work, would get in in table)\n+        // also tests foster parenting\n+        String h = \"<table><b><tr><td>aaa</td></tr>bbb</table>ccc\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<b></b><b>bbb</b><table><tbody><tr><td>aaa</td></tr></tbody></table><b>ccc</b>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesUnclosedFormattingElements() {\n+        // whatwg: formatting elements get collected and applied, but excess elements are thrown away\n+        String h = \"<!DOCTYPE html>\\n\" +\n+                \"<p><b class=x><b class=x><b><b class=x><b class=x><b>X\\n\" +\n+                \"<p>X\\n\" +\n+                \"<p><b><b class=x><b>X\\n\" +\n+                \"<p></b></b></b></b></b></b>X\";\n+        Document doc = Jsoup.parse(h);\n+        doc.outputSettings().indentAmount(0);\n+        String want = \"<!DOCTYPE html>\\n\" +\n+                \"<html>\\n\" +\n+                \"<head></head>\\n\" +\n+                \"<body>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b>X </b></b></b></b></b></b></p>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b>X </b></b></b></b></b></p>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b><b><b class=\\\"x\\\"><b>X </b></b></b></b></b></b></b></b></p>\\n\" +\n+                \"<p>X</p>\\n\" +\n+                \"</body>\\n\" +\n+                \"</html>\";\n+        assertEquals(want, doc.html());\n+    }\n+\n+    @Test public void reconstructFormattingElements() {\n+        // tests attributes and multi b\n+        String h = \"<p><b class=one>One <i>Two <b>Three</p><p>Hello</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<p><b class=\\\"one\\\">One <i>Two <b>Three</b></i></b></p>\\n<p><b class=\\\"one\\\"><i><b>Hello</b></i></b></p>\", doc.body().html());\n+    }\n+\n+    @Test public void reconstructFormattingElementsInTable() {\n+        // tests that tables get formatting markers -- the <b> applies outside the table and does not leak in,\n+        // and the <i> inside the table and does not leak out.\n+        String h = \"<p><b>One</p> <table><tr><td><p><i>Three<p>Four</i></td></tr></table> <p>Five</p>\";\n+        Document doc = Jsoup.parse(h);\n+        String want = \"<p><b>One</b></p>\\n\" +\n+                \"<b> \\n\" +\n+                \" <table>\\n\" +\n+                \"  <tbody>\\n\" +\n+                \"   <tr>\\n\" +\n+                \"    <td><p><i>Three</i></p><p><i>Four</i></p></td>\\n\" +\n+                \"   </tr>\\n\" +\n+                \"  </tbody>\\n\" +\n+                \" </table> <p>Five</p></b>\";\n+        assertEquals(want, doc.body().html());\n+    }\n+\n+    @Test public void commentBeforeHtml() {\n+        String h = \"<!-- comment --><!-- comment 2 --><p>One</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<!-- comment --><!-- comment 2 --><html><head></head><body><p>One</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void emptyTdTag() {\n+        String h = \"<table><tr><td>One</td><td id='2' /></tr></table>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<td>One</td>\\n<td id=\\\"2\\\"></td>\", doc.select(\"tr\").first().html());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/TagTest.java\n+++ b/src/test/java/org/jsoup/parser/TagTest.java\n \n     @Test public void divSemantics() {\n         Tag div = Tag.valueOf(\"div\");\n-        Tag p = Tag.valueOf(\"p\");\n \n-        assertTrue(div.canContain(div));\n-        assertTrue(div.canContain(p));\n+        assertTrue(div.isBlock());\n+        assertTrue(div.formatAsBlock());\n     }\n \n     @Test public void pSemantics() {\n-        Tag div = Tag.valueOf(\"div\");\n         Tag p = Tag.valueOf(\"p\");\n-        Tag img = Tag.valueOf(\"img\");\n-        Tag span = Tag.valueOf(\"span\");\n \n-        assertTrue(p.canContain(img));\n-        assertTrue(p.canContain(span));\n-        assertFalse(p.canContain(div));\n-        assertFalse(p.canContain(p));\n-    }\n-\n-    @Test public void spanSemantics() {\n-        Tag span = Tag.valueOf(\"span\");\n-        Tag p = Tag.valueOf(\"p\");\n-        Tag div = Tag.valueOf(\"div\");\n-\n-        assertTrue(span.canContain(span));\n-        assertTrue(span.canContain(p));\n-        assertTrue(span.canContain(div));\n+        assertTrue(p.isBlock());\n+        assertFalse(p.formatAsBlock());\n     }\n \n     @Test public void imgSemantics() {\n         Tag img = Tag.valueOf(\"img\");\n-        Tag p = Tag.valueOf(\"p\");\n-\n-        assertFalse(img.canContain(img));\n-        assertFalse(img.canContain(p));\n+        assertTrue(img.isInline());\n+        assertTrue(img.isSelfClosing());\n+        assertFalse(img.isBlock());\n     }\n \n     @Test public void defaultSemantics() {\n         Tag foo = Tag.valueOf(\"foo\"); // not defined\n         Tag foo2 = Tag.valueOf(\"FOO\");\n-        Tag div = Tag.valueOf(\"div\");\n \n         assertEquals(foo, foo2);\n-        assertTrue(foo.canContain(foo));\n-        assertTrue(foo.canContain(div));\n-        assertTrue(div.canContain(foo));\n+        assertTrue(foo.isInline());\n+        assertTrue(foo.formatAsBlock());\n     }\n \n     @Test(expected = IllegalArgumentException.class) public void valueOfChecksNotNull() {\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n     }\n \n     @Test public void basicBehaviourTest() {\n-        String h = \"<div><p><a href='javascript:sendAllMoney()'>Dodgy</a> <A HREF='HTTP://nice.com'>Nice</p><blockquote>Hello</blockquote>\";\n+        String h = \"<div><p><a href='javascript:sendAllMoney()'>Dodgy</a> <A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>\";\n         String cleanHtml = Jsoup.clean(h, Whitelist.basic());\n \n         assertEquals(\"<p><a rel=\\\"nofollow\\\">Dodgy</a> <a href=\\\"http://nice.com\\\" rel=\\\"nofollow\\\">Nice</a></p><blockquote>Hello</blockquote>\",\n     }\n     \n     @Test public void testRelaxed() {\n-        String h = \"<h1>Head</h1><td>One<td>Two</td>\";\n+        String h = \"<h1>Head</h1><table><tr><td>One<td>Two</td></tr></table>\";\n         String cleanHtml = Jsoup.clean(h, Whitelist.relaxed());\n         assertEquals(\"<h1>Head</h1><table><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>\", TextUtil.stripNewlines(cleanHtml));\n     }\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n     \n     @Test public void val() {\n         Document doc = Jsoup.parse(\"<input value='one' /><textarea>two</textarea>\");\n-        Elements els = doc.select(\"form > *\");\n+        Elements els = doc.select(\"input, textarea\");\n         assertEquals(2, els.size());\n         assertEquals(\"one\", els.val());\n         assertEquals(\"two\", els.last().val());", "timestamp": 1309605128, "metainfo": ""}