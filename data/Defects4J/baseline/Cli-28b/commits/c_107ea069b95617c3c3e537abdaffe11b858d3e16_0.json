{"sha": "107ea069b95617c3c3e537abdaffe11b858d3e16", "log": "Added the old Avalon Excalibur CLI package  Submitted by: Sebb Issue: 34672   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/AbstractParserControl.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+/**\n+ * Class to inherit from so when in future when new controls are added\n+ * clients will no have to implement them.\n+ * @version $Revision: 1.2 $\n+ * @see ParserControl\n+ */\n+public abstract class AbstractParserControl\n+        implements ParserControl\n+{\n+    /**\n+     * By default always continue parsing by returning false.\n+     *\n+     * @param lastOptionCode the code of last option parsed\n+     * @return return true to halt, false to continue parsing\n+     * @see ParserControl#isFinished(int)\n+     */\n+    public boolean isFinished( int lastOptionCode )\n+    {\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/CLArgsParser.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+import java.text.ParseException;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+/**\n+ * Parser for command line arguments.\n+ *\n+ * This parses command lines according to the standard (?) of\n+ * GNU utilities.\n+ *\n+ * Note: This is still used in 1.1 libraries so do not add 1.2+ dependencies.\n+ *\n+ * Note that CLArgs uses a backing hashtable for the options index and so duplicate\n+ * arguments are only returned by getArguments().\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ * @see ParserControl\n+ * @see CLOption\n+ * @see CLOptionDescriptor\n+ */\n+public final class CLArgsParser\n+{\n+    //cached character == Integer.MAX_VALUE when invalid\n+    private static final int INVALID = Integer.MAX_VALUE;\n+\n+    private static final int STATE_NORMAL = 0;\n+    private static final int STATE_REQUIRE_2ARGS = 1;\n+    private static final int STATE_REQUIRE_ARG = 2;\n+    private static final int STATE_OPTIONAL_ARG = 3;\n+    private static final int STATE_NO_OPTIONS = 4;\n+    private static final int STATE_OPTION_MODE = 5;\n+\n+\t// Values for creating tokens\n+    private static final int TOKEN_SEPARATOR = 0;\n+    private static final int TOKEN_STRING = 1;\n+\n+    private static final char[] ARG_SEPARATORS =\n+            new char[]{(char)0, '='};\n+\n+    private static final char[] NULL_SEPARATORS =\n+            new char[]{(char)0};\n+\n+    private final CLOptionDescriptor[] m_optionDescriptors;\n+    private final Vector m_options;\n+    private Hashtable m_optionIndex;\n+    private final ParserControl m_control;\n+\n+    private String m_errorMessage;\n+    private String[] m_unparsedArgs = new String[]{};\n+\n+    //variables used while parsing options.\n+    private char m_ch;\n+    private String[] m_args;\n+    private boolean m_isLong;\n+    private int m_argIndex;\n+    private int m_stringIndex;\n+    private int m_stringLength;\n+\n+    private int m_lastChar = INVALID;\n+\n+    private int m_lastOptionId;\n+    private CLOption m_option;\n+    private int m_state = STATE_NORMAL;\n+\n+    /**\n+     * Retrieve an array of arguments that have not been parsed\n+     * due to the parser halting.\n+     *\n+     * @return an array of unparsed args\n+     */\n+    public final String[] getUnparsedArgs()\n+    {\n+        return m_unparsedArgs;\n+    }\n+\n+    /**\n+     * Retrieve a list of options that were parsed from command list.\n+     *\n+     * @return the list of options\n+     */\n+    public final Vector getArguments()\n+    {\n+        //System.out.println( \"Arguments: \" + m_options );\n+        return m_options;\n+    }\n+\n+    /**\n+     * Retrieve the {@link CLOption} with specified id, or\n+     * <code>null</code> if no command line option is found.\n+     *\n+     * @param id the command line option id\n+     * @return the {@link CLOption} with the specified id, or\n+     *    <code>null</code> if no CLOption is found.\n+     * @see CLOption\n+     */\n+    public final CLOption getArgumentById( final int id )\n+    {\n+        return (CLOption)m_optionIndex.get( new Integer( id ) );\n+    }\n+\n+    /**\n+     * Retrieve the {@link CLOption} with specified name, or\n+     * <code>null</code> if no command line option is found.\n+     *\n+     * @param name the command line option name\n+     * @return the {@link CLOption} with the specified name, or\n+     *    <code>null</code> if no CLOption is found.\n+     * @see CLOption\n+     */\n+    public final CLOption getArgumentByName( final String name )\n+    {\n+        return (CLOption)m_optionIndex.get( name );\n+    }\n+\n+    /**\n+     * Get Descriptor for option id.\n+     *\n+     * @param id the id\n+     * @return the descriptor\n+     */\n+    private final CLOptionDescriptor getDescriptorFor( final int id )\n+    {\n+        for( int i = 0; i < m_optionDescriptors.length; i++ )\n+        {\n+            if( m_optionDescriptors[i].getId() == id )\n+            {\n+                return m_optionDescriptors[i];\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve a descriptor by name.\n+     *\n+     * @param name the name\n+     * @return the descriptor\n+     */\n+    private final CLOptionDescriptor getDescriptorFor( final String name )\n+    {\n+        for( int i = 0; i < m_optionDescriptors.length; i++ )\n+        {\n+            if( m_optionDescriptors[i].getName().equals( name ) )\n+            {\n+                return m_optionDescriptors[i];\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieve an error message that occured during parsing if one existed.\n+     *\n+     * @return the error string\n+     */\n+    public final String getErrorString()\n+    {\n+        //System.out.println( \"ErrorString: \" + m_errorMessage );\n+        return m_errorMessage;\n+    }\n+\n+    /**\n+     * Require state to be placed in for option.\n+     *\n+     * @param descriptor the Option Descriptor\n+     * @return the state\n+     */\n+    private final int getStateFor( final CLOptionDescriptor descriptor )\n+    {\n+        final int flags = descriptor.getFlags();\n+        if( (flags & CLOptionDescriptor.ARGUMENTS_REQUIRED_2) ==\n+                CLOptionDescriptor.ARGUMENTS_REQUIRED_2 )\n+        {\n+            return STATE_REQUIRE_2ARGS;\n+        }\n+        else if( (flags & CLOptionDescriptor.ARGUMENT_REQUIRED) ==\n+                CLOptionDescriptor.ARGUMENT_REQUIRED )\n+        {\n+            return STATE_REQUIRE_ARG;\n+        }\n+        else if( (flags & CLOptionDescriptor.ARGUMENT_OPTIONAL) ==\n+                CLOptionDescriptor.ARGUMENT_OPTIONAL )\n+        {\n+            return STATE_OPTIONAL_ARG;\n+        }\n+        else\n+        {\n+            return STATE_NORMAL;\n+        }\n+    }\n+\n+    /**\n+     * Create a parser that can deal with options and parses certain args.\n+     *\n+     * @param args the args, typically that passed to the\n+     * <code>public static void main(String[] args)</code> method.\n+     * @param optionDescriptors the option descriptors\n+     * @param control the parser control used determine behaviour of parser\n+     */\n+    public CLArgsParser( final String[] args,\n+            final CLOptionDescriptor[] optionDescriptors,\n+            final ParserControl control )\n+    {\n+        m_optionDescriptors = optionDescriptors;\n+        m_control = control;\n+        m_options = new Vector();\n+        m_args = args;\n+\n+        try\n+        {\n+            parse();\n+            checkIncompatibilities( m_options );\n+            buildOptionIndex();\n+        }\n+        catch( final ParseException pe )\n+        {\n+            m_errorMessage = pe.getMessage();\n+        }\n+\n+        //System.out.println( \"Built : \" + m_options );\n+        //System.out.println( \"From : \" + Arrays.asList( args ) );\n+    }\n+\n+    /**\n+     * Check for duplicates of an option.\n+     * It is an error to have duplicates unless appropriate flags is set in descriptor.\n+     *\n+     * @param arguments the arguments\n+     */\n+    private final void checkIncompatibilities( final Vector arguments )\n+            throws ParseException\n+    {\n+        final int size = arguments.size();\n+\n+        for( int i = 0; i < size; i++ )\n+        {\n+            final CLOption option = (CLOption)arguments.elementAt( i );\n+            final int id = option.getDescriptor().getId();\n+            final CLOptionDescriptor descriptor = getDescriptorFor( id );\n+\n+            //this occurs when id == 0 and user has not supplied a descriptor\n+            //for arguments\n+            if( null == descriptor )\n+            {\n+                continue;\n+            }\n+\n+            final int[] incompatible = descriptor.getIncompatible();\n+\n+            checkIncompatible( arguments, incompatible, i );\n+        }\n+    }\n+\n+    private final void checkIncompatible( final Vector arguments,\n+            final int[] incompatible,\n+            final int original )\n+            throws ParseException\n+    {\n+        final int size = arguments.size();\n+\n+        for( int i = 0; i < size; i++ )\n+        {\n+            if( original == i )\n+            {\n+                continue;\n+            }\n+\n+            final CLOption option = (CLOption)arguments.elementAt( i );\n+            final int id = option.getDescriptor().getId();\n+\n+            for( int j = 0; j < incompatible.length; j++ )\n+            {\n+                if( id == incompatible[j] )\n+                {\n+                    final CLOption originalOption = (CLOption)arguments.elementAt( original );\n+                    final int originalId = originalOption.getDescriptor().getId();\n+\n+                    String message = null;\n+\n+                    if( id == originalId )\n+                    {\n+                        message =\n+                                \"Duplicate options for \" + describeDualOption( originalId ) +\n+                                \" found.\";\n+                    }\n+                    else\n+                    {\n+                        message = \"Incompatible options -\" +\n+                                describeDualOption( id ) + \" and \" +\n+                                describeDualOption( originalId ) + \" found.\";\n+                    }\n+                    throw new ParseException( message, 0 );\n+                }\n+            }\n+        }\n+    }\n+\n+    private final String describeDualOption( final int id )\n+    {\n+        final CLOptionDescriptor descriptor = getDescriptorFor( id );\n+        if( null == descriptor )\n+        {\n+            return \"<parameter>\";\n+        }\n+        else\n+        {\n+            final StringBuffer sb = new StringBuffer();\n+            boolean hasCharOption = false;\n+\n+            if( Character.isLetter( (char)id ) )\n+            {\n+                sb.append( '-' );\n+                sb.append( (char)id );\n+                hasCharOption = true;\n+            }\n+\n+            final String longOption = descriptor.getName();\n+            if( null != longOption )\n+            {\n+                if( hasCharOption )\n+                {\n+                    sb.append( '/' );\n+                }\n+                sb.append( \"--\" );\n+                sb.append( longOption );\n+            }\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * Create a parser that deals with options and parses certain args.\n+     *\n+     * @param args the args\n+     * @param optionDescriptors the option descriptors\n+     */\n+    public CLArgsParser( final String[] args,\n+            final CLOptionDescriptor[] optionDescriptors )\n+    {\n+        this( args, optionDescriptors, null );\n+    }\n+\n+    /**\n+     * Create a string array that is subset of input array.\n+     * The sub-array should start at array entry indicated by index. That array element\n+     * should only include characters from charIndex onwards.\n+     *\n+     * @param array the original array\n+     * @param index the cut-point in array\n+     * @param charIndex the cut-point in element of array\n+     * @return the result array\n+     */\n+    private final String[] subArray( final String[] array,\n+            final int index,\n+            final int charIndex )\n+    {\n+        final int remaining = array.length - index;\n+        final String[] result = new String[remaining];\n+\n+        if( remaining > 1 )\n+        {\n+            System.arraycopy( array, index + 1, result, 1, remaining - 1 );\n+        }\n+\n+        result[0] = array[index].substring( charIndex - 1 );\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Actually parse arguments\n+     */\n+    private final void parse()\n+            throws ParseException\n+    {\n+        if( 0 == m_args.length )\n+        {\n+            return;\n+        }\n+\n+        m_stringLength = m_args[m_argIndex].length();\n+\n+        //ch = peekAtChar();\n+\n+        while( true )\n+        {\n+            m_ch = peekAtChar();\n+\n+            //System.out.println( \"Pre State=\" + m_state );\n+            //System.out.println( \"Pre Char=\" + (char)ch + \"/\" + (int)ch );\n+\n+            if( m_argIndex >= m_args.length )\n+            {\n+                break;\n+            }\n+\n+            if( null != m_control && m_control.isFinished( m_lastOptionId ) )\n+            {\n+                //this may need mangling due to peeks\n+                m_unparsedArgs = subArray( m_args, m_argIndex, m_stringIndex );\n+                return;\n+            }\n+\n+            //System.out.println( \"State=\" + m_state );\n+            //System.out.println( \"Char=\" + (char)ch + \"/\" + (int)ch );\n+\n+            if( STATE_OPTION_MODE == m_state )\n+            {\n+                //if get to an arg barrier then return to normal mode\n+                //else continue accumulating options\n+                if( 0 == m_ch )\n+                {\n+                    getChar(); //strip the null\n+                    m_state = STATE_NORMAL;\n+                }\n+                else\n+                {\n+                    parseShortOption();\n+                }\n+            }\n+            else if( STATE_NORMAL == m_state )\n+            {\n+                parseNormal();\n+            }\n+            else if( STATE_NO_OPTIONS == m_state )\n+            {\n+                //should never get to here when stringIndex != 0\n+                addOption( new CLOption( m_args[m_argIndex++] ) );\n+            }\n+            else if( STATE_OPTIONAL_ARG == m_state && m_isLong && m_ch != 0)\n+            {\n+                m_state = STATE_NORMAL;\n+                addOption( m_option );\n+            }\n+            else\n+            {\n+                parseArguments();\n+            }\n+        }\n+\n+        if( m_option != null )\n+        {\n+            if( STATE_OPTIONAL_ARG == m_state )\n+            {\n+                m_options.addElement( m_option );\n+            }\n+            else if( STATE_REQUIRE_ARG == m_state )\n+            {\n+                final CLOptionDescriptor descriptor = getDescriptorFor(\n+                        m_option.getDescriptor().getId() );\n+                final String message =\n+                        \"Missing argument to option \" + getOptionDescription( descriptor );\n+                throw new ParseException( message, 0 );\n+            }\n+            else if( STATE_REQUIRE_2ARGS == m_state )\n+            {\n+                if( 1 == m_option.getArgumentCount() )\n+                {\n+                    m_option.addArgument( \"\" );\n+                    m_options.addElement( m_option );\n+                }\n+                else\n+                {\n+                    final CLOptionDescriptor descriptor = getDescriptorFor(\n+                            m_option.getDescriptor().getId() );\n+                    final String message =\n+                            \"Missing argument to option \" + getOptionDescription( descriptor );\n+                    throw new ParseException( message, 0 );\n+                }\n+            }\n+            else\n+            {\n+                throw new ParseException( \"IllegalState \" + m_state + \": \" + m_option, 0 );\n+            }\n+        }\n+    }\n+\n+    private final String getOptionDescription( final CLOptionDescriptor descriptor )\n+    {\n+        if( m_isLong )\n+        {\n+            return \"--\" + descriptor.getName();\n+        }\n+        else\n+        {\n+            return \"-\" + (char)descriptor.getId();\n+        }\n+    }\n+\n+    private final char peekAtChar()\n+    {\n+        if( INVALID == m_lastChar )\n+        {\n+            m_lastChar = readChar();\n+        }\n+        return (char)m_lastChar;\n+    }\n+\n+    private final char getChar()\n+    {\n+        if( INVALID != m_lastChar )\n+        {\n+            final char result = (char)m_lastChar;\n+            m_lastChar = INVALID;\n+            return result;\n+        }\n+        else\n+        {\n+            return readChar();\n+        }\n+    }\n+\n+    private final char readChar()\n+    {\n+        if( m_stringIndex >= m_stringLength )\n+        {\n+            m_argIndex++;\n+            m_stringIndex = 0;\n+\n+            if( m_argIndex < m_args.length )\n+            {\n+                m_stringLength = m_args[m_argIndex].length();\n+            }\n+            else\n+            {\n+                m_stringLength = 0;\n+            }\n+\n+            return 0;\n+        }\n+\n+        if( m_argIndex >= m_args.length )\n+        {\n+            return 0;\n+        }\n+\n+        return m_args[m_argIndex].charAt( m_stringIndex++ );\n+    }\n+\n+    private final Token nextToken( final char[] separators )\n+    {\n+        m_ch = getChar();\n+\n+        if( isSeparator( m_ch, separators ) )\n+        {\n+            m_ch = getChar();\n+            return new Token( TOKEN_SEPARATOR, null );\n+        }\n+\n+        final StringBuffer sb = new StringBuffer();\n+\n+        do\n+        {\n+            sb.append( m_ch );\n+            m_ch = getChar();\n+        }\n+        while( !isSeparator( m_ch, separators ) );\n+\n+        return new Token( TOKEN_STRING, sb.toString() );\n+    }\n+\n+    private final boolean isSeparator( final char ch, final char[] separators )\n+    {\n+        for( int i = 0; i < separators.length; i++ )\n+        {\n+            if( ch == separators[i] )\n+            {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private final void addOption( final CLOption option )\n+    {\n+        m_options.addElement( option );\n+        m_lastOptionId = option.getDescriptor().getId();\n+        m_option = null;\n+    }\n+\n+    private final void parseOption( final CLOptionDescriptor descriptor,\n+            final String optionString )\n+            throws ParseException\n+    {\n+        if( null == descriptor )\n+        {\n+            throw new ParseException( \"Unknown option \" + optionString, 0 );\n+        }\n+\n+        m_state = getStateFor( descriptor );\n+        m_option = new CLOption( descriptor );\n+\n+        if( STATE_NORMAL == m_state )\n+        {\n+            addOption( m_option );\n+        }\n+    }\n+\n+    private final void parseShortOption()\n+            throws ParseException\n+    {\n+        m_ch = getChar();\n+        final CLOptionDescriptor descriptor = getDescriptorFor( m_ch );\n+        m_isLong = false;\n+        parseOption( descriptor, \"-\" + m_ch );\n+\n+        if( STATE_NORMAL == m_state )\n+        {\n+            m_state = STATE_OPTION_MODE;\n+        }\n+    }\n+\n+    private final void parseArguments()\n+            throws ParseException\n+    {\n+        if( STATE_REQUIRE_ARG == m_state )\n+        {\n+            if( '=' == m_ch || 0 == m_ch )\n+            {\n+                getChar();\n+            }\n+\n+            final Token token = nextToken( NULL_SEPARATORS );\n+            m_option.addArgument( token.getValue() );\n+\n+            addOption( m_option );\n+            m_state = STATE_NORMAL;\n+        }\n+        else if( STATE_OPTIONAL_ARG == m_state )\n+        {\n+            if( '-' == m_ch || 0 == m_ch )\n+            {\n+                getChar(); //consume stray character\n+                addOption( m_option );\n+                m_state = STATE_NORMAL;\n+                return;\n+            }\n+\n+            if( '=' == m_ch )\n+            {\n+                getChar();\n+            }\n+\n+            final Token token = nextToken( NULL_SEPARATORS );\n+            m_option.addArgument( token.getValue() );\n+\n+            addOption( m_option );\n+            m_state = STATE_NORMAL;\n+        }\n+        else if( STATE_REQUIRE_2ARGS == m_state )\n+        {\n+            if( 0 == m_option.getArgumentCount() )\n+            {\n+\t\t\t\t/*\n+\t\t\t\t * Fix bug: -D arg1=arg2 was causing parse error; however --define arg1=arg2 is OK\n+\t\t\t\t * This seems to be because the parser skips the terminator for the long options,\n+\t\t\t\t * but was not doing so for the short options. \n+\t\t\t\t */\n+\t\t\t\tif (!m_isLong){\n+\t\t\t\t\tif (0 == peekAtChar()){\n+\t\t\t\t\t\tgetChar();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+                final Token token = nextToken( ARG_SEPARATORS );\n+\n+                if( TOKEN_SEPARATOR == token.getType() )\n+                {\n+                    final CLOptionDescriptor descriptor = getDescriptorFor(\n+                            m_option.getDescriptor().getId() );\n+                    final String message =\n+                            \"Unable to parse first argument for option \" +\n+                            getOptionDescription( descriptor );\n+                    throw new ParseException( message, 0 );\n+                }\n+                else\n+                {\n+                    m_option.addArgument( token.getValue() );\n+                }\n+                // Are we about to start a new option?\n+                if (0 == m_ch && '-' == peekAtChar()){\n+                    // Yes, so the second argument is missing\n+                    m_option.addArgument( \"\" );\n+                    m_options.addElement( m_option );\n+                    m_state = STATE_NORMAL; \n+                }\n+            }\n+            else //2nd argument\n+            {\n+                final StringBuffer sb = new StringBuffer();\n+\n+                m_ch = getChar();\n+                while( !isSeparator( m_ch, NULL_SEPARATORS ) )\n+                {\n+                    sb.append( m_ch );\n+                    m_ch = getChar();\n+                }\n+\n+                final String argument = sb.toString();\n+\n+                //System.out.println( \"Arguement:\" + argument );\n+\n+                m_option.addArgument( argument );\n+                addOption( m_option );\n+                m_option = null;\n+                m_state = STATE_NORMAL;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse Options from Normal mode.\n+     */\n+    private final void parseNormal()\n+            throws ParseException\n+    {\n+        if( '-' != m_ch )\n+        {\n+            //Parse the arguments that are not options\n+            final String argument = nextToken( NULL_SEPARATORS ).getValue();\n+            addOption( new CLOption( argument ) );\n+            m_state = STATE_NORMAL;\n+        }\n+        else\n+        {\n+            getChar(); // strip the -\n+\n+            if( 0 == peekAtChar() )\n+            {\n+                throw new ParseException( \"Malformed option -\", 0 );\n+            }\n+            else\n+            {\n+                m_ch = peekAtChar();\n+\n+                //if it is a short option then parse it else ...\n+                if( '-' != m_ch )\n+                {\n+                    parseShortOption();\n+                }\n+                else\n+                {\n+                    getChar(); // strip the -\n+                    //-- sequence .. it can either mean a change of state\n+                    //to STATE_NO_OPTIONS or else a long option\n+\n+                    if( 0 == peekAtChar() )\n+                    {\n+                        getChar();\n+                        m_state = STATE_NO_OPTIONS;\n+                    }\n+                    else\n+                    {\n+                        //its a long option\n+                        final String optionName = nextToken( ARG_SEPARATORS ).getValue();\n+                        final CLOptionDescriptor descriptor = getDescriptorFor( optionName );\n+                        m_isLong = true;\n+                        parseOption( descriptor, \"--\" + optionName );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build the m_optionIndex lookup map for the parsed options.\n+     */\n+    private final void buildOptionIndex()\n+    {\n+        final int size = m_options.size();\n+        m_optionIndex = new Hashtable( size * 2 );\n+\n+        for( int i = 0; i < size; i++ )\n+        {\n+            final CLOption option = (CLOption)m_options.get( i );\n+            final CLOptionDescriptor optionDescriptor =\n+                    getDescriptorFor( option.getDescriptor().getId() );\n+\n+            m_optionIndex.put( new Integer( option.getDescriptor().getId() ), option );\n+\n+            if( null != optionDescriptor &&\n+                    null != optionDescriptor.getName() )\n+            {\n+                m_optionIndex.put( optionDescriptor.getName(), option );\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/CLOption.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+// Renamed from org.apache.avalon.excalibur.cli\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Basic class describing an instance of option.\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ */\n+public final class CLOption\n+{\n+    /**\n+     * Value of {@link #getId} when the option is a text argument.\n+     */\n+    public static final int TEXT_ARGUMENT = 0;\n+\n+    /**\n+     * Default descriptor. Required, since code assumes that getDescriptor will never return null.\n+     */\n+    private static final CLOptionDescriptor TEXT_ARGUMENT_DESCRIPTOR =\n+            new CLOptionDescriptor( null, CLOptionDescriptor.ARGUMENT_OPTIONAL, TEXT_ARGUMENT,\n+                    null );\n+\n+    private String[] m_arguments;\n+    private CLOptionDescriptor m_descriptor = TEXT_ARGUMENT_DESCRIPTOR;\n+\n+    /**\n+     * Retrieve argument to option if it takes arguments.\n+     *\n+     * @return the (first) argument\n+     */\n+    public final String getArgument()\n+    {\n+        return getArgument( 0 );\n+    }\n+\n+    /**\n+     * Retrieve indexed argument to option if it takes arguments.\n+     *\n+     * @param index The argument index, from 0 to\n+     * {@link #getArgumentCount()}-1.\n+     * @return the argument\n+     */\n+    public final String getArgument( final int index )\n+    {\n+        if( null == m_arguments || index < 0 || index >= m_arguments.length )\n+        {\n+            return null;\n+        }\n+        else\n+        {\n+            return m_arguments[index];\n+        }\n+    }\n+\n+    /**\n+     * Retrieve id of option.\n+     *\n+     * The id is eqivalent to character code if it can be a single letter option.\n+     *\n+     * @return the id\n+     * @deprecated use <code>getDescriptor().getId()</code> instead\n+     */\n+    public final int getId()\n+    {\n+        return m_descriptor == null ? TEXT_ARGUMENT : m_descriptor.getId();\n+    }\n+\n+    public final CLOptionDescriptor getDescriptor()\n+    {\n+        return m_descriptor;\n+    }\n+\n+    /**\n+     * Constructor taking an descriptor\n+     *\n+     * @param descriptor the descriptor iff null, will default to a \"text argument\" descriptor.\n+     */\n+    public CLOption( final CLOptionDescriptor descriptor )\n+    {\n+        if( descriptor != null )\n+        {\n+            m_descriptor = descriptor;\n+        }\n+    }\n+\n+    /**\n+     * Constructor taking argument for option.\n+     *\n+     * @param argument the argument\n+     */\n+    public CLOption( final String argument )\n+    {\n+        this( (CLOptionDescriptor)null );\n+        addArgument( argument );\n+    }\n+\n+    /**\n+     * Mutator of Argument property.\n+     *\n+     * @param argument the argument\n+     */\n+    public final void addArgument( final String argument )\n+    {\n+        if( null == m_arguments )\n+        {\n+            m_arguments = new String[]{argument};\n+        }\n+        else\n+        {\n+            final String[] arguments = new String[m_arguments.length + 1];\n+            System.arraycopy( m_arguments, 0, arguments, 0, m_arguments.length );\n+            arguments[m_arguments.length] = argument;\n+            m_arguments = arguments;\n+        }\n+    }\n+\n+    /**\n+     * Get number of arguments.\n+     *\n+     * @return the number of arguments\n+     */\n+    public final int getArgumentCount()\n+    {\n+        if( null == m_arguments )\n+        {\n+            return 0;\n+        }\n+        else\n+        {\n+            return m_arguments.length;\n+        }\n+    }\n+\n+    /**\n+     * Convert to String.\n+     *\n+     * @return the string value\n+     */\n+    public final String toString()\n+    {\n+        final StringBuffer sb = new StringBuffer();\n+        sb.append( \"[Option \" );\n+        sb.append( (char)m_descriptor.getId() );\n+\n+        if( null != m_arguments )\n+        {\n+            sb.append( \", \" );\n+            sb.append( Arrays.asList( m_arguments ) );\n+        }\n+\n+        sb.append( \" ]\" );\n+\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/CLOptionDescriptor.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+/**\n+ * Basic class describing an type of option.\n+ * Typically, one creates a static array of <code>CLOptionDescriptor</code>s,\n+ * and passes it to {@link CLArgsParser#CLArgsParser(String[], CLOptionDescriptor[])}.\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ * @see CLArgsParser\n+ * @see CLUtil\n+ */\n+public final class CLOptionDescriptor\n+{\n+    /** Flag to say that one argument is required */\n+    public static final int ARGUMENT_REQUIRED = 1 << 1;\n+    /** Flag to say that the argument is optional */\n+    public static final int ARGUMENT_OPTIONAL = 1 << 2;\n+    /** Flag to say this option does not take arguments */\n+    public static final int ARGUMENT_DISALLOWED = 1 << 3;\n+    /** Flag to say this option requires 2 arguments */\n+    public static final int ARGUMENTS_REQUIRED_2 = 1 << 4;\n+    /** Flag to say this option may be repeated on the command line */\n+    public static final int DUPLICATES_ALLOWED = 1 << 5;\n+\n+    private final int m_id;\n+    private final int m_flags;\n+    private final String m_name;\n+    private final String m_description;\n+    private final int[] m_incompatible;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name the name/long option\n+     * @param flags the flags\n+     * @param id the id/character option\n+     * @param description description of option usage\n+     */\n+    public CLOptionDescriptor( final String name,\n+            final int flags,\n+            final int id,\n+            final String description )\n+    {\n+        this( name, flags, id, description,\n+                ((flags & CLOptionDescriptor.DUPLICATES_ALLOWED) > 0)\n+                ? new int[0] : new int[]{id} );\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name the name/long option\n+     * @param flags the flags\n+     * @param id the id/character option\n+     * @param description description of option usage\n+     * @param incompatible an array listing the ids of all incompatible options\n+     * @deprecated use the version with the array of CLOptionDescriptor's\n+     */\n+    public CLOptionDescriptor( final String name,\n+            final int flags,\n+            final int id,\n+            final String description,\n+            final int[] incompatible )\n+    {\n+        m_id = id;\n+        m_name = name;\n+        m_flags = flags;\n+        m_description = description;\n+        m_incompatible = incompatible;\n+\n+        int modeCount = 0;\n+        if( (ARGUMENT_REQUIRED & flags) == ARGUMENT_REQUIRED )\n+        {\n+            modeCount++;\n+        }\n+        if( (ARGUMENT_OPTIONAL & flags) == ARGUMENT_OPTIONAL )\n+        {\n+            modeCount++;\n+        }\n+        if( (ARGUMENT_DISALLOWED & flags) == ARGUMENT_DISALLOWED )\n+        {\n+            modeCount++;\n+        }\n+        if( (ARGUMENTS_REQUIRED_2 & flags) == ARGUMENTS_REQUIRED_2 )\n+        {\n+            modeCount++;\n+        }\n+\n+        if( 0 == modeCount )\n+        {\n+            final String message = \"No mode specified for option \" + this;\n+            throw new IllegalStateException( message );\n+        }\n+        else if( 1 != modeCount )\n+        {\n+            final String message = \"Multiple modes specified for option \" + this;\n+            throw new IllegalStateException( message );\n+        }\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name the name/long option\n+     * @param flags the flags\n+     * @param id the id/character option\n+     * @param description description of option usage\n+     */\n+    public CLOptionDescriptor( final String name,\n+            final int flags,\n+            final int id,\n+            final String description,\n+            final CLOptionDescriptor[] incompatible )\n+    {\n+        m_id = id;\n+        m_name = name;\n+        m_flags = flags;\n+        m_description = description;\n+\n+        m_incompatible = new int[incompatible.length];\n+        for( int i = 0; i < incompatible.length; i++ )\n+        {\n+            m_incompatible[i] = incompatible[i].getId();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Use the correctly spelled {@link #getIncompatible} instead.\n+     * @return the array of incompatible option ids\n+     */\n+    protected final int[] getIncompatble()\n+    {\n+        return getIncompatible();\n+    }\n+\n+    /**\n+     * Get the array of incompatible option ids.\n+     *\n+     * @return the array of incompatible option ids\n+     */\n+    protected final int[] getIncompatible()\n+    {\n+        return m_incompatible;\n+    }\n+\n+    /**\n+     * Retrieve textual description.\n+     *\n+     * @return the description\n+     */\n+    public final String getDescription()\n+    {\n+        return m_description;\n+    }\n+\n+    /**\n+     * Retrieve flags about option.\n+     * Flags include details such as whether it allows parameters etc.\n+     *\n+     * @return the flags\n+     */\n+    public final int getFlags()\n+    {\n+        return m_flags;\n+    }\n+\n+    /**\n+     * Retrieve the id for option.\n+     * The id is also the character if using single character options.\n+     *\n+     * @return the id\n+     */\n+    public final int getId()\n+    {\n+        return m_id;\n+    }\n+\n+    /**\n+     * Retrieve name of option which is also text for long option.\n+     *\n+     * @return name/long option\n+     */\n+    public final String getName()\n+    {\n+        return m_name;\n+    }\n+\n+    /**\n+     * Convert to String.\n+     *\n+     * @return the converted value to string.\n+     */\n+    public final String toString()\n+    {\n+        final StringBuffer sb = new StringBuffer();\n+        sb.append( \"[OptionDescriptor \" );\n+        sb.append( m_name );\n+        sb.append( \"[OptionDescriptor \" );\n+        sb.append( m_name );\n+        sb.append( \", \" );\n+        sb.append( m_id );\n+        sb.append( \", \" );\n+        sb.append( m_flags );\n+        sb.append( \", \" );\n+        sb.append( m_description );\n+        sb.append( \" ]\" );\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/CLUtil.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+/**\n+ * CLUtil offers basic utility operations for use both internal and external to package.\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ * @see CLOptionDescriptor\n+ */\n+public final class CLUtil\n+{\n+    private static final int MAX_DESCRIPTION_COLUMN_LENGTH = 60;\n+\n+    /**\n+     * Format options into StringBuffer and return. This is typically used to\n+     * print \"Usage\" text in response to a \"--help\" or invalid option.\n+     *\n+     * @param options the option descriptors\n+     * @return the formatted description/help for options\n+     */\n+    public static final StringBuffer describeOptions( final CLOptionDescriptor[] options )\n+    {\n+        final String lSep = System.getProperty( \"line.separator\" );\n+        final StringBuffer sb = new StringBuffer();\n+\n+        for( int i = 0; i < options.length; i++ )\n+        {\n+            final char ch = (char)options[i].getId();\n+            final String name = options[i].getName();\n+            String description = options[i].getDescription();\n+            int flags = options[i].getFlags();\n+            boolean argumentRequired =\n+                    ((flags & CLOptionDescriptor.ARGUMENT_REQUIRED) ==\n+                    CLOptionDescriptor.ARGUMENT_REQUIRED);\n+            boolean twoArgumentsRequired =\n+                    ((flags & CLOptionDescriptor.ARGUMENTS_REQUIRED_2) ==\n+                    CLOptionDescriptor.ARGUMENTS_REQUIRED_2);\n+            boolean needComma = false;\n+            if( twoArgumentsRequired )\n+            {\n+                argumentRequired = true;\n+            }\n+\n+            sb.append( '\\t' );\n+\n+            if( Character.isLetter( ch ) )\n+            {\n+                sb.append( \"-\" );\n+                sb.append( ch );\n+                needComma = true;\n+            }\n+\n+            if( null != name )\n+            {\n+                if( needComma )\n+                {\n+                    sb.append( \", \" );\n+                }\n+\n+                sb.append( \"--\" );\n+                sb.append( name );\n+            }\n+\n+            if( argumentRequired )\n+            {\n+                sb.append( \" <argument>\" );\n+            }\n+            if( twoArgumentsRequired )\n+            {\n+                sb.append( \"=<value>\" );\n+            }\n+            sb.append( lSep );\n+\n+            if( null != description )\n+            {\n+                while( description.length() > MAX_DESCRIPTION_COLUMN_LENGTH )\n+                {\n+                    final String descriptionPart =\n+                            description.substring( 0, MAX_DESCRIPTION_COLUMN_LENGTH );\n+                    description =\n+                            description.substring( MAX_DESCRIPTION_COLUMN_LENGTH );\n+                    sb.append( \"\\t\\t\" );\n+                    sb.append( descriptionPart );\n+                    sb.append( lSep );\n+                }\n+\n+                sb.append( \"\\t\\t\" );\n+                sb.append( description );\n+                sb.append( lSep );\n+            }\n+        }\n+        return sb;\n+    }\n+\n+    /**\n+     * Private Constructor so that no instance can ever be created.\n+     *\n+     */\n+    private CLUtil()\n+    {\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/ParserControl.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+/**\n+ * ParserControl is used to control particular behaviour of the parser.\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ * @see AbstractParserControl\n+ */\n+public interface ParserControl\n+{\n+    /**\n+     * Called by the parser to determine whether it should stop\n+     * after last option parsed.\n+     *\n+     * @param lastOptionCode the code of last option parsed\n+     * @return return true to halt, false to continue parsing\n+     */\n+    boolean isFinished( int lastOptionCode );\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/avalon/Token.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+/**\n+ * Token handles tokenizing the CLI arguments\n+ *\n+ * @version $Revision: 1.2 $ $Date: 2005/03/18 15:26:55 $\n+ * @since 4.0\n+ */\n+class Token\n+{\n+    /** Type for a separator token */\n+    public static final int TOKEN_SEPARATOR = 0;\n+    /** Type for a text token */\n+    public static final int TOKEN_STRING = 1;\n+\n+    private final int m_type;\n+    private final String m_value;\n+\n+    /**\n+     * New Token object with a type and value\n+     */\n+    Token( final int type, final String value )\n+    {\n+        m_type = type;\n+        m_value = value;\n+    }\n+\n+    /**\n+     * Get the value of the token\n+     */\n+    final String getValue()\n+    {\n+        return m_value;\n+    }\n+\n+    /**\n+     * Get the type of the token\n+     */\n+    final int getType()\n+    {\n+        return m_type;\n+    }\n+\n+    /**\n+     * Convert to a string\n+     */\n+    public final String toString()\n+    {\n+        final StringBuffer sb = new StringBuffer();\n+        sb.append( m_type );\n+        sb.append( \":\" );\n+        sb.append( m_value );\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/avalon/ClutilTestCase.java\n+/* \n+ * Copyright 2002-2005 The Apache Software Foundation\n+ * Licensed  under the  Apache License,  Version 2.0  (the \"License\");\n+ * you may not use  this file  except in  compliance with the License.\n+ * You may obtain a copy of the License at \n+ * \n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed  under the  License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or\n+ * implied.\n+ * \n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli.avalon;\n+//Renamed from org.apache.avalon.excalibur.cli\n+\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ *\n+ */\n+public final class ClutilTestCase\n+        extends TestCase\n+{\n+    private static final String[] ARGLIST1 = new String[]\n+    {\n+        \"--you\", \"are\", \"--all\", \"-cler\", \"kid\"\n+    };\n+\n+    private static final String[] ARGLIST2 = new String[]\n+    {\n+        \"-Dstupid=idiot\", \"are\", \"--all\", \"here\", \"-d\"\n+    };\n+\n+    private static final String[] ARGLIST3 = new String[]\n+    {\n+        //duplicates\n+        \"-Dstupid=idiot\", \"are\", \"--all\", \"--all\", \"here\"\n+    };\n+\n+    private static final String[] ARGLIST4 = new String[]\n+    {\n+        //incompatable (blee/all)\n+        \"-Dstupid\",\"idiot\", \"are\", \"--all\", \"--blee\", \"here\"\n+    };\n+\n+    private static final String[] ARGLIST5 = new String[]\n+    {\n+        \"-f\", \"myfile.txt\"\n+    };\n+\n+    private static final int DEFINE_OPT = 'D';\n+    private static final int CASE_CHECK_OPT = 'd';\n+    private static final int YOU_OPT = 'y';\n+    private static final int ALL_OPT = 'a';\n+    private static final int CLEAR1_OPT = 'c';\n+    private static final int CLEAR2_OPT = 'l';\n+    private static final int CLEAR3_OPT = 'e';\n+    private static final int CLEAR5_OPT = 'r';\n+    private static final int BLEE_OPT = 'b';\n+    private static final int FILE_OPT = 'f';\n+    private static final int TAINT_OPT = 'T';\n+\n+    private static final CLOptionDescriptor DEFINE =\n+            new CLOptionDescriptor( \"define\",\n+                    CLOptionDescriptor.ARGUMENTS_REQUIRED_2,\n+                    DEFINE_OPT,\n+                    \"define\" );\n+    private static final CLOptionDescriptor DEFINE_MANY =\n+        new CLOptionDescriptor( \"define\",\n+             CLOptionDescriptor.ARGUMENTS_REQUIRED_2|CLOptionDescriptor.DUPLICATES_ALLOWED,\n+             DEFINE_OPT,\n+             \"define\" );\n+\n+    private static final CLOptionDescriptor CASE_CHECK =\n+            new CLOptionDescriptor( \"charCheck\",\n+                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n+                    CASE_CHECK_OPT,\n+                    \"check character case sensitivity\" );\n+    private static final CLOptionDescriptor YOU =\n+            new CLOptionDescriptor( \"you\", CLOptionDescriptor.ARGUMENT_DISALLOWED, YOU_OPT, \"you\" );\n+\n+    private static final CLOptionDescriptor CLEAR1 =\n+            new CLOptionDescriptor( \"c\", CLOptionDescriptor.ARGUMENT_DISALLOWED, CLEAR1_OPT, \"c\" );\n+    private static final CLOptionDescriptor CLEAR2 =\n+            new CLOptionDescriptor( \"l\", CLOptionDescriptor.ARGUMENT_DISALLOWED, CLEAR2_OPT, \"l\" );\n+    private static final CLOptionDescriptor CLEAR3 =\n+            new CLOptionDescriptor( \"e\", CLOptionDescriptor.ARGUMENT_DISALLOWED, CLEAR3_OPT, \"e\" );\n+    private static final CLOptionDescriptor CLEAR5 =\n+            new CLOptionDescriptor( \"r\", CLOptionDescriptor.ARGUMENT_DISALLOWED, CLEAR5_OPT, \"r\" );\n+    private static final CLOptionDescriptor BLEE =\n+            new CLOptionDescriptor( \"blee\",\n+                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n+                    BLEE_OPT,\n+                    \"blee\" );\n+\n+    private static final CLOptionDescriptor ALL =\n+            new CLOptionDescriptor( \"all\",\n+                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n+                    ALL_OPT,\n+                    \"all\",\n+                    new CLOptionDescriptor[]{BLEE} );\n+\n+    private static final CLOptionDescriptor FILE =\n+            new CLOptionDescriptor( \"file\",\n+                    CLOptionDescriptor.ARGUMENT_REQUIRED,\n+                    FILE_OPT,\n+                    \"the build file.\" );\n+    private static final CLOptionDescriptor TAINT =\n+            new CLOptionDescriptor( \"taint\",\n+                    CLOptionDescriptor.ARGUMENT_OPTIONAL,\n+                    TAINT_OPT,\n+                    \"turn on tainting checks (optional level).\" );\n+\n+\tpublic ClutilTestCase()\n+    {\n+        this( \"Command Line Interpreter Test Case\" );\n+    }\n+\n+    public ClutilTestCase( String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void testOptionalArgWithSpace()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            ALL, TAINT\n+        };\n+\n+        final String[] args = new String[]{\"-T\", \"param\", \"-a\"};\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( \"Option count\", 3, size );\n+\n+        final CLOption option0 = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"Option Code: \" + option0.getDescriptor().getId(), TAINT_OPT,\n+                option0.getDescriptor().getId() );\n+        assertEquals( \"Option Arg: \" + option0.getArgument( 0 ),\n+                null, option0.getArgument( 0 ) );\n+\n+        final CLOption option1 = (CLOption)clOptions.get( 1 );\n+        assertEquals( option1.getDescriptor().getId(), CLOption.TEXT_ARGUMENT );\n+        assertEquals( option1.getArgument( 0 ), \"param\" );\n+\n+        final CLOption option2 = (CLOption)clOptions.get( 2 );\n+        assertEquals( option2.getDescriptor().getId(), ALL_OPT );\n+        assertEquals( option2.getArgument( 0 ), null );\n+    }\n+\n+    public void testOptionalArgLong()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            ALL, TAINT\n+        };\n+\n+\t\t// Check that optional args work woth long options\n+        final String[] args = new String[]{\"--taint\", \"param\", \"-a\"};\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( \"Option count\", 3, size );\n+\n+        final CLOption option0 = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"Option Code: \" + option0.getDescriptor().getId(), TAINT_OPT,\n+                option0.getDescriptor().getId() );\n+        assertEquals( \"Option Arg: \" + option0.getArgument( 0 ),\n+                null, option0.getArgument( 0 ) );\n+\n+        final CLOption option1 = (CLOption)clOptions.get( 1 );\n+        assertEquals( CLOption.TEXT_ARGUMENT , option1.getDescriptor().getId());\n+        assertEquals( \"param\" , option1.getArgument( 0 ) );\n+\n+        final CLOption option2 = (CLOption)clOptions.get( 2 );\n+        assertEquals( option2.getDescriptor().getId(), ALL_OPT );\n+        assertEquals( option2.getArgument( 0 ), null );\n+    }\n+\n+    public void testShortOptArgUnenteredBeforeOtherOpt()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            ALL, TAINT\n+        };\n+\n+        final String[] args = new String[]{\"-T\", \"-a\"};\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( \"Option count\", 2, size );\n+\n+        final CLOption option0 = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"Option Code: \" + option0.getDescriptor().getId(), TAINT_OPT,\n+                option0.getDescriptor().getId() );\n+        assertEquals( \"Option Arg: \" + option0.getArgument( 0 ), null, option0.getArgument( 0 ) );\n+\n+        final CLOption option1 = (CLOption)clOptions.get( 1 );\n+        assertEquals( option1.getDescriptor().getId(), ALL_OPT );\n+        assertEquals( option1.getArgument( 0 ), null );\n+    }\n+\n+    public void testOptionalArgsWithArgShortBeforeOtherOpt()\n+    {\n+        //\"-T3\",\"-a\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            ALL, TAINT\n+        };\n+\n+        final String[] args = new String[]{\"-T3\", \"-a\"};\n+\n+        //System.out.println(\"[before parsing]\");\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        //System.out.println(\"[after parsing]\");\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 2 );\n+        final CLOption option0 = (CLOption)clOptions.get( 0 );\n+        assertEquals( option0.getDescriptor().getId(), TAINT_OPT );\n+        assertEquals( option0.getArgument( 0 ), \"3\" );\n+\n+        final CLOption option1 = (CLOption)clOptions.get( 1 );\n+        assertEquals( ALL_OPT, option1.getDescriptor().getId() );\n+        assertEquals( null, option1.getArgument( 0 ) );\n+    }\n+\n+    public void testOptionalArgsNoArgShortBeforeOtherOpt()\n+    {\n+        //\"-T\",\"-a\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            ALL, TAINT\n+        };\n+\n+        final String[] args = new String[]{\"-T\", \"-a\"};\n+\n+        //System.out.println(\"[before parsing]\");\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        //System.out.println(\"[after parsing]\");\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 2 );\n+        final CLOption option0 = (CLOption)clOptions.get( 0 );\n+        assertEquals( TAINT_OPT, option0.getDescriptor().getId() );\n+        assertEquals( null, option0.getArgument( 0 ) );\n+\n+        final CLOption option1 = (CLOption)clOptions.get( 1 );\n+        assertEquals( ALL_OPT, option1.getDescriptor().getId() );\n+        assertEquals( null, option1.getArgument( 0 ) );\n+    }\n+\n+    public void testFullParse()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            YOU, ALL, CLEAR1, CLEAR2, CLEAR3, CLEAR5\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST1, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 8 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), YOU_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions.get( 2 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 3 )).getDescriptor().getId(), CLEAR1_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 4 )).getDescriptor().getId(), CLEAR2_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 5 )).getDescriptor().getId(), CLEAR3_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 6 )).getDescriptor().getId(), CLEAR5_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 7 )).getDescriptor().getId(), 0 );\n+    }\n+\n+    public void testDuplicateOptions()\n+    {\n+        //\"-Dstupid=idiot\",\"are\",\"--all\",\"--all\",\"here\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE, ALL, CLEAR1\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST3, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 5 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions.get( 2 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 3 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 4 )).getDescriptor().getId(), 0 );\n+    }\n+\n+    public void testIncompatableOptions()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE, ALL, CLEAR1, BLEE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST4, options );\n+\n+        assertNotNull( parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 5 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions.get( 2 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 3 )).getDescriptor().getId(), BLEE_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 4 )).getDescriptor().getId(), 0 );\n+    }\n+\n+    public void testSingleArg()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST5, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 1 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), FILE_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getArgument(), \"myfile.txt\" );\n+    }\n+    public void testSingleArg2()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-f-=,=-\"} // Check delimiters are allowed\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT ,((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=,=-\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg3()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"--file=-=,-\"} // Check delimiters are allowed\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=,-\" , ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg4()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"--file\",\"myfile.txt\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"myfile.txt\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg5()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-f\",\"myfile.txt\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"myfile.txt\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg6()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-f\",\"-=-\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=-\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg7()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"--file=-=-\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=-\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg8()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"--file\",\"-=-\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=-\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testSingleArg9()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"--file\",\"-=-\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+        assertEquals( \"-=-\", ((CLOption)clOptions.get( 0 )).getArgument() );\n+    }\n+\n+    public void testCombinedArgs1()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            BLEE, TAINT\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-bT\",\"rest\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+        assertEquals( 3, size);\n+        assertEquals( BLEE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId());\n+        assertEquals( TAINT_OPT, ((CLOption)clOptions.get( 1 )).getDescriptor().getId());\n+        assertEquals( 0, ((CLOption)clOptions.get( 2 )).getDescriptor().getId());\n+        assertEquals( \"rest\", ((CLOption)clOptions.get( 2 )).getArgument());\n+    }\n+\n+    public void testCombinedArgs2()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            BLEE, TAINT, FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-bT\",\"-fa\"}\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+        assertEquals( 3, size);\n+        assertEquals( BLEE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId());\n+        assertEquals( TAINT_OPT, ((CLOption)clOptions.get( 1 )).getDescriptor().getId());\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 2 )).getDescriptor().getId());\n+        assertEquals( \"a\", ((CLOption)clOptions.get( 2 )).getArgument());\n+    }\n+\n+    public void testCombinedArgs3()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            BLEE, TAINT, FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-bT\",\"--\",\"-fa\"}// Should not detect trailing option\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+        assertEquals( 3, size);\n+        assertEquals( BLEE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId());\n+        assertEquals( TAINT_OPT, ((CLOption)clOptions.get( 1 )).getDescriptor().getId());\n+        assertEquals( 0, ((CLOption)clOptions.get( 2 )).getDescriptor().getId());\n+        assertEquals( \"-fa\", ((CLOption)clOptions.get( 2 )).getArgument());\n+    }\n+\n+    public void testCombinedArgs4()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            BLEE, TAINT, FILE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[]{\"-bT\",\"rest\",\"-fa\"} // should detect trailing option\n+\t\t\t\t, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+        assertEquals( 4, size);\n+        assertEquals( BLEE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId());\n+        assertEquals( TAINT_OPT, ((CLOption)clOptions.get( 1 )).getDescriptor().getId());\n+        assertEquals( 0, ((CLOption)clOptions.get( 2 )).getDescriptor().getId());\n+        assertEquals( \"rest\", ((CLOption)clOptions.get( 2 )).getArgument());\n+        assertEquals( FILE_OPT, ((CLOption)clOptions.get( 3 )).getDescriptor().getId());\n+        assertEquals( \"a\", ((CLOption)clOptions.get( 3 )).getArgument());\n+    }\n+\n+    public void test2ArgsParse()\n+    {\n+        //\"-Dstupid=idiot\",\"are\",\"--all\",\"here\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE, ALL, CLEAR1, CASE_CHECK\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST2, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 5 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions.get( 2 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions.get( 3 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions.get( 4 )).getDescriptor().getId(), CASE_CHECK_OPT );\n+\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"stupid\", option.getArgument( 0 ) );\n+        assertEquals( \"idiot\", option.getArgument( 1 ) );\n+    }\n+\n+    public void test2ArgsParse2()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[] {\"--define\",\"a-b,c=d-e,f\"}, // Check \"-\" is allowed in arg2 \n+\t\t\t\toptions );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( DEFINE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"a-b,c\", option.getArgument( 0 ) );\n+        assertEquals( \"d-e,f\", option.getArgument( 1 ) );\n+    }\n+\n+    public void test2ArgsParse3()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[] {\"-D\",\"A-b,c\",\"G-e,f\"}, \n+\t\t\t\toptions );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 1, size );\n+        assertEquals( DEFINE_OPT, ((CLOption)clOptions.get( 0 )).getDescriptor().getId() );\n+\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"A-b,c\", option.getArgument( 0 ) );\n+        assertEquals( \"G-e,f\", option.getArgument( 1 ) );\n+    }\n+\n+    public void test2ArgsParse4()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE_MANY\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( \n+\t\t\t\tnew String[] {\"-Dval1=-1\",\"-D\",\"val2=-2\",\n+\t\t\t\t\t\t\"--define=val-3=-3\",\"--define\",\"val4-=-4\"}, \n+\t\t\t\toptions );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( 4, size );\n+\t\tfor (int i=0;i<size;i++){\n+        assertEquals( DEFINE_OPT, ((CLOption)clOptions.get( i )).getDescriptor().getId() );\n+\t\t}\n+\n+        CLOption option; \n+        option = (CLOption)clOptions.get( 0 );\n+        assertEquals( \"val1\", option.getArgument( 0 ) );\n+        assertEquals( \"-1\", option.getArgument( 1 ) );\n+\n+\t\toption = (CLOption)clOptions.get( 1 );\n+        assertEquals( \"val2\", option.getArgument( 0 ) );\n+        assertEquals( \"-2\", option.getArgument( 1 ) );\n+\n+\t\toption = (CLOption)clOptions.get( 2 );\n+        assertEquals( \"val-3\", option.getArgument( 0 ) );\n+        assertEquals( \"-3\", option.getArgument( 1 ) );\n+\t\t\n+\t\toption = (CLOption)clOptions.get( 3 );\n+        assertEquals( \"val4-\", option.getArgument( 0 ) );\n+        assertEquals( \"-4\", option.getArgument( 1 ) );\n+    }\n+\n+    public void testPartParse()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            YOU\n+        };\n+\n+        final ParserControl control = new AbstractParserControl()\n+        {\n+            public boolean isFinished( int lastOptionCode )\n+            {\n+                return (lastOptionCode == YOU_OPT);\n+            }\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST1, options, control );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 1 );\n+        assertEquals( ((CLOption)clOptions.get( 0 )).getDescriptor().getId(), YOU_OPT );\n+    }\n+\n+    public void test2PartParse()\n+    {\n+        final CLOptionDescriptor[] options1 = new CLOptionDescriptor[]\n+        {\n+            YOU\n+        };\n+\n+        final CLOptionDescriptor[] options2 = new CLOptionDescriptor[]\n+        {\n+            ALL, CLEAR1, CLEAR2, CLEAR3, CLEAR5\n+        };\n+\n+        final ParserControl control1 = new AbstractParserControl()\n+        {\n+            public boolean isFinished( int lastOptionCode )\n+            {\n+                return (lastOptionCode == YOU_OPT);\n+            }\n+        };\n+\n+        final CLArgsParser parser1 = new CLArgsParser( ARGLIST1, options1, control1 );\n+\n+        assertNull( parser1.getErrorString(), parser1.getErrorString() );\n+\n+        final List clOptions1 = parser1.getArguments();\n+        final int size1 = clOptions1.size();\n+\n+        assertEquals( size1, 1 );\n+        assertEquals( ((CLOption)clOptions1.get( 0 )).getDescriptor().getId(), YOU_OPT );\n+\n+        final CLArgsParser parser2 =\n+                new CLArgsParser( parser1.getUnparsedArgs(), options2 );\n+\n+        assertNull( parser2.getErrorString(), parser2.getErrorString() );\n+\n+        final List clOptions2 = parser2.getArguments();\n+        final int size2 = clOptions2.size();\n+\n+        assertEquals( size2, 7 );\n+        assertEquals( ((CLOption)clOptions2.get( 0 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions2.get( 1 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions2.get( 2 )).getDescriptor().getId(), CLEAR1_OPT );\n+        assertEquals( ((CLOption)clOptions2.get( 3 )).getDescriptor().getId(), CLEAR2_OPT );\n+        assertEquals( ((CLOption)clOptions2.get( 4 )).getDescriptor().getId(), CLEAR3_OPT );\n+        assertEquals( ((CLOption)clOptions2.get( 5 )).getDescriptor().getId(), CLEAR5_OPT );\n+        assertEquals( ((CLOption)clOptions2.get( 6 )).getDescriptor().getId(), 0 );\n+    }\n+\n+    public void test2PartPartialParse()\n+    {\n+        final CLOptionDescriptor[] options1 = new CLOptionDescriptor[]\n+        {\n+            YOU, ALL, CLEAR1\n+        };\n+\n+        final CLOptionDescriptor[] options2 = new CLOptionDescriptor[]{};\n+\n+        final ParserControl control1 = new AbstractParserControl()\n+        {\n+            public boolean isFinished( final int lastOptionCode )\n+            {\n+                return (lastOptionCode == CLEAR1_OPT);\n+            }\n+        };\n+\n+        final CLArgsParser parser1 = new CLArgsParser( ARGLIST1, options1, control1 );\n+\n+        assertNull( parser1.getErrorString(), parser1.getErrorString() );\n+\n+        final List clOptions1 = parser1.getArguments();\n+        final int size1 = clOptions1.size();\n+\n+        assertEquals( size1, 4 );\n+        assertEquals( ((CLOption)clOptions1.get( 0 )).getDescriptor().getId(), YOU_OPT );\n+        assertEquals( ((CLOption)clOptions1.get( 1 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions1.get( 2 )).getDescriptor().getId(), ALL_OPT );\n+        assertEquals( ((CLOption)clOptions1.get( 3 )).getDescriptor().getId(), CLEAR1_OPT );\n+\n+        assertTrue( parser1.getUnparsedArgs()[0].equals( \"ler\" ) );\n+\n+        final CLArgsParser parser2 =\n+                new CLArgsParser( parser1.getUnparsedArgs(), options2 );\n+\n+        assertNull( parser2.getErrorString(), parser2.getErrorString() );\n+\n+        final List clOptions2 = parser2.getArguments();\n+        final int size2 = clOptions2.size();\n+\n+        assertEquals( size2, 2 );\n+        assertEquals( ((CLOption)clOptions2.get( 0 )).getDescriptor().getId(), 0 );\n+        assertEquals( ((CLOption)clOptions2.get( 1 )).getDescriptor().getId(), 0 );\n+    }\n+\n+    public void testDuplicatesFail()\n+    {\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            YOU, ALL, CLEAR1, CLEAR2, CLEAR3, CLEAR5\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( ARGLIST1, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+    }\n+\n+    public void testIncomplete2Args()\n+    {\n+        //\"-Dstupid=\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE\n+        };\n+\n+        final CLArgsParser parser = new CLArgsParser( new String[]{\"-Dstupid=\"}, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 1 );\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( option.getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( option.getArgument( 0 ), \"stupid\" );\n+        assertEquals( option.getArgument( 1 ), \"\" );\n+    }\n+\n+    public void testIncomplete2ArgsMixed()\n+    {\n+        //\"-Dstupid=\",\"-c\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE, CLEAR1\n+        };\n+\n+        final String[] args = new String[]{\"-Dstupid=\", \"-c\"};\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 2 );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), CLEAR1_OPT );\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( option.getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( option.getArgument( 0 ), \"stupid\" );\n+        assertEquals( option.getArgument( 1 ), \"\" );\n+    }\n+\n+    public void testIncomplete2ArgsMixedNoEq()\n+    {\n+        //\"-Dstupid\",\"-c\"\n+        final CLOptionDescriptor[] options = new CLOptionDescriptor[]\n+        {\n+            DEFINE, CLEAR1\n+        };\n+\n+        final String[] args = new String[]{\"-DStupid\", \"-c\"};\n+\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        assertNull( parser.getErrorString(), parser.getErrorString() );\n+\n+        final List clOptions = parser.getArguments();\n+        final int size = clOptions.size();\n+\n+        assertEquals( size, 2 );\n+        assertEquals( ((CLOption)clOptions.get( 1 )).getDescriptor().getId(), CLEAR1_OPT );\n+        final CLOption option = (CLOption)clOptions.get( 0 );\n+        assertEquals( option.getDescriptor().getId(), DEFINE_OPT );\n+        assertEquals( option.getArgument( 0 ), \"Stupid\" );\n+        assertEquals( option.getArgument( 1 ), \"\" );\n+    }\n+\n+    /**\n+     * Test the getArgumentById and getArgumentByName lookup methods.\n+     */\n+    public void testArgumentLookup()\n+    {\n+        final String[] args = {\"-f\", \"testarg\"};\n+        final CLOptionDescriptor[] options = {FILE};\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        CLOption optionById = parser.getArgumentById( FILE_OPT );\n+        assertNotNull( optionById );\n+        assertEquals( FILE_OPT, optionById.getDescriptor().getId() );\n+\n+        CLOption optionByName = parser.getArgumentByName( FILE.getName() );\n+        assertNotNull( optionByName );\n+        assertEquals( FILE_OPT, optionByName.getDescriptor().getId() );\n+    }\n+\n+    /**\n+     * Test that you can have null long forms.\n+     */\n+    public void testNullLongForm()\n+    {\n+        final CLOptionDescriptor test =\n+                new CLOptionDescriptor( null,\n+                        CLOptionDescriptor.ARGUMENT_DISALLOWED,\n+                        'n',\n+                        \"test null long form\" );\n+\n+        final String[] args = {\"-n\", \"testarg\"};\n+        final CLOptionDescriptor[] options = {test};\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        final CLOption optionByID = parser.getArgumentById( 'n' );\n+        assertNotNull( optionByID );\n+        assertEquals( 'n', optionByID.getDescriptor().getId() );\n+\n+        final CLOption optionByName = parser.getArgumentByName( FILE.getName() );\n+        assertNull( \"Looking for non-existent option by name\", optionByName );\n+    }\n+\n+    /**\n+     * Test that you can have null descriptions.\n+     */\n+    public void testNullDescription()\n+    {\n+        final CLOptionDescriptor test =\n+                new CLOptionDescriptor( \"nulltest\",\n+                        CLOptionDescriptor.ARGUMENT_DISALLOWED,\n+                        'n',\n+                        null );\n+\n+        final String[] args = {\"-n\", \"testarg\"};\n+        final CLOptionDescriptor[] options = {test};\n+        final CLArgsParser parser = new CLArgsParser( args, options );\n+\n+        final CLOption optionByID = parser.getArgumentById( 'n' );\n+        assertNotNull( optionByID );\n+        assertEquals( 'n', optionByID.getDescriptor().getId() );\n+\n+        final StringBuffer sb = CLUtil.describeOptions( options );\n+        final String lineSeparator = System.getProperty( \"line.separator\" );\n+        assertEquals( \"Testing display of null description\",\n+                \"\\t-n, --nulltest\" + lineSeparator,\n+                sb.toString() );\n+    }\n+\t/*\n+\t *  TODO add tests to check for:\n+\t *  - name clash\n+\t *  - long option abbreviations (match shortest unique abbreviation)\n+\t */\n+\t\n+}", "timestamp": 1117835848, "metainfo": ""}