{"sha": "d30f12f8fc30ddc2c30a08beea0c10d6d8f2029b", "log": "allowed characters are now isJavaIdentifierPart, added javadoc to Parser, minor refactoring for required options   ", "commit": "\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n      * @return true if <code>c</code> is a letter.\n      */\n     private boolean isValidChar( char c ) {\n-        return Character.isLetter( c );\n+        return Character.isJavaIdentifierPart( c );\n     }\n \n     /**\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n \n package org.apache.commons.cli;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Map;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n \n /** <p>Main entry-point into the library.</p>\n  *\n     private Map  longOpts     = new HashMap();\n \n     /** a map of the required options */\n-    private Map  requiredOpts = new HashMap();\n+    private List requiredOpts = new ArrayList();\n     \n     /** a map of the option groups */\n     private Map optionGroups  = new HashMap();\n         \n         // if the option is required add it to the required list\n         if ( opt.isRequired() ) {\n-            requiredOpts.put( shortOpt, opt );\n+            requiredOpts.add( shortOpt );\n         }\n \n         shortOpts.put( shortOpt, opt );\n      *\n      * @return Collection of required options\n      */\n-    public Map getRequiredOptions() {\n+    public List getRequiredOptions() {\n         return requiredOpts;\n     }\n     \n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Parser.java,v 1.4 2002/09/01 22:54:56 jkeyes Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/09/01 22:54:56 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n package org.apache.commons.cli;\n \n import java.util.Arrays;\n import java.util.ListIterator;\n import java.util.Map;\n \n+/**\n+ * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n+ *\n+ * @author John Keyes (jbjk at mac.com)\n+ * @see Parser\n+ * @version $Revision: 1.4 $\n+ */\n public abstract class Parser implements CommandLineParser {\n \n+    /** commandline instance */\n     private CommandLine cmd;\n+    /** current Options */\n     private Options options;\n-    private Map requiredOptions;\n-\n+    /** list of required options strings */\n+    private List requiredOptions;\n+\n+    /**\n+     * <p>Subclasses must implement this method to reduce\n+     * the <code>arguments</code> that have been passed to the parse \n+     * method.</p>\n+     *\n+     * @param opts The Options to parse the arguments by.\n+     * @param args The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop \n+     * flattening when a non option has been encountered\n+     * @return a String array of the flattened arguments\n+     */\n     abstract protected String[] flatten( Options opts, \n-                                         String[] args, \n+                                         String[] arguments, \n                                          boolean stopAtNonOption );\n \n-    public CommandLine parse( Options opts, String[] args ) \n+    /**\n+     * <p>Parses the specified <code>arguments</code> \n+     * based on the specifed {@link Options}.</p>\n+     *\n+     * @param options the <code>Options</code>\n+     * @param arguments the <code>arguments</code>\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the\n+     * arguments.\n+     */\n+    public CommandLine parse( Options options, String[] arguments ) \n     throws ParseException \n     {\n-        return parse( opts, args, false );\n-    }\n-\n+        return parse( options, arguments, false );\n+    }\n+\n+    /**\n+     * <p>Parses the specified <code>arguments</code> \n+     * based on the specifed {@link Options}.</p>\n+     *\n+     * @param options the <code>Options</code>\n+     * @param arguments the <code>arguments</code>\n+     * @param stopAtNonOption specifies whether to stop \n+     * interpreting the arguments when a non option has \n+     * been encountered and to add them to the CommandLines\n+     * args list.\n+     * @return the <code>CommandLine</code>\n+     * @throws ParseException if an error occurs when parsing the\n+     * arguments.\n+     */\n     public CommandLine parse( Options opts, \n-                              String[] args, \n+                              String[] arguments, \n                               boolean stopAtNonOption ) \n     throws ParseException \n     {\n+        // initialise members\n         options = opts;\n         requiredOptions = options.getRequiredOptions();\n-        String[] tokens = flatten( opts, args, stopAtNonOption );\n-        List tokenList = Arrays.asList( tokens );\n+        cmd = new CommandLine();\n+\n+        boolean eatTheRest = false;\n+\n+        List tokenList = Arrays.asList( flatten( opts, arguments, stopAtNonOption ) );\n         ListIterator iterator = tokenList.listIterator();\n-        cmd = new CommandLine();\n-        boolean eatTheRest = false;\n+\n+        // process each flattened token\n         while( iterator.hasNext() ) {\n             String t = (String)iterator.next();\n+\n+            // the value is the double-dash\n             if( \"--\".equals( t ) ) {\n                 eatTheRest = true;\n             }\n+            // the value is a single dash\n+            else if( \"-\".equals( t ) ) {\n+                if( stopAtNonOption ) {\n+                    eatTheRest = true;\n+                }\n+                else {\n+                    cmd.addArg(t );\n+                }\n+            }\n+            // the value is an option\n             else if( t.startsWith( \"-\" ) ) {\n-                if( t.length() == 1 ) {\n-                    // not an option, so just drop it on the argument list\n-                    if ( stopAtNonOption ) {\n-                        eatTheRest = true;\n-                    }\n-                    else {\n-                        cmd.addArg( t );\n-                    }\n-                }\n-                else if ( stopAtNonOption && !options.hasOption( t ) ) {\n+                if ( stopAtNonOption && !options.hasOption( t ) ) {\n                     eatTheRest = true;\n                     cmd.addArg( t );\n                 }\n                     processOption( t, iterator );\n                 }\n             }\n+            // the value is an argument\n             else {\n                 cmd.addArg( t );\n                 if( stopAtNonOption ) {\n                 }\n             }\n \n+            // eat the remaining tokens\n             if( eatTheRest ) {\n                 while( iterator.hasNext() ) {\n                     String str = (String)iterator.next();\n+                    // ensure only one double-dash is added\n                     if( !\"--\".equals( str ) ) {\n                         cmd.addArg( str );\n                     }\n         return cmd;\n     }\n \n-    private void checkRequiredOptions( ) \n-    throws ParseException {\n+    /**\n+     * <p>Throws a {@link MissingOptionException} if all of the\n+     * required options are no present.</p>\n+     */\n+    private void checkRequiredOptions()\n+    throws MissingOptionException \n+    {\n \n         // if there are required options that have not been\n         // processsed\n         if( requiredOptions.size() > 0 ) {\n-            Iterator iter = requiredOptions.values().iterator();\n+            Iterator iter = requiredOptions.iterator();\n             StringBuffer buff = new StringBuffer();\n \n             // loop through the required options\n             while( iter.hasNext() ) {\n-                Option missing = (Option)iter.next();\n-                buff.append( \"-\" );\n-                buff.append( missing.getOpt() );\n-                buff.append( \" \" );\n-                buff.append( missing.getDescription() );\n+                buff.append( iter.next() );\n             }\n \n             throw new MissingOptionException( buff.toString() );\n--- a/src/test/org/apache/commons/cli/BugsTest.java\n+++ b/src/test/org/apache/commons/cli/BugsTest.java\n  * version 1.1, a copy of which has been included with this distribution in\n  * the LICENSE file.\n  * \n- * $Id: BugsTest.java,v 1.5 2002/08/31 17:53:11 jkeyes Exp $\n+ * $Id: BugsTest.java,v 1.6 2002/09/01 22:54:56 jkeyes Exp $\n  */\n \n package org.apache.commons.cli;\n \n         // Therefore, place them in an option group\n \n-        String[] argv = new String[] { \"-exec\", \"-execopto\", \"-execoptt\" };\n+        String[] argv = new String[] { \"-exec\", \"-exec_opt1\", \"-exec_opt2\" };\n         OptionGroup grp = new OptionGroup();\n \n         grp.addOption(new Option(\"exec\",false,\"description for this option\"));\n \n         // for the exec option, there are 2 options...\n         Options execOptions = new Options();\n-        execOptions.addOption(\"execopto\",false,\" desc\");\n-        execOptions.addOption(\"execoptt\",false,\" desc\");\n+        execOptions.addOption(\"exec_opt1\",false,\" desc\");\n+        execOptions.addOption(\"exec_opt2\",false,\" desc\");\n \n         // similarly, for rep there are 2 options...\n         Options repOptions = new Options();\n             if(cmd.hasOption(\"exec\")){\n                 cmd = parser.parse(execOptions,argv,false);\n                 // process the exec_op1 and exec_opt2...\n-                assertTrue( cmd.hasOption(\"execopto\") );\n-                assertTrue( cmd.hasOption(\"execoptt\") );\n+                assertTrue( cmd.hasOption(\"exec_opt1\") );\n+                assertTrue( cmd.hasOption(\"exec_opt2\") );\n             }\n             else if(cmd.hasOption(\"rep\")){\n                 cmd = parser.parse(repOptions,argv,false);", "timestamp": 1030920896, "metainfo": ""}