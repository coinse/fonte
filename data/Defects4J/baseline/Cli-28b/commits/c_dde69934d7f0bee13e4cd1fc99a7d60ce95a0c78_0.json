{"sha": "dde69934d7f0bee13e4cd1fc99a7d60ce95a0c78", "log": "separated the argument flattening from the Option processing   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/BasicParser.java\n+package org.apache.commons.cli;\n+\n+/**\n+ * @author John Keyes (jbjk at mac.com)\n+ */\n+public class BasicParser extends Parser {\n+\n+    protected String[] flatten( Options options, \n+                                String[] arguments, \n+                                boolean stopAtNonOption )\n+    {\n+        return arguments;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/CommandLineParserFactory.java\n+++ b/src/java/org/apache/commons/cli/CommandLineParserFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Attic/CommandLineParserFactory.java,v 1.2 2002/07/25 21:40:08 jkeyes Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/07/25 21:40:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Attic/CommandLineParserFactory.java,v 1.3 2002/08/24 22:15:31 jkeyes Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/08/24 22:15:31 $\n  *\n  * ====================================================================\n  *\n         return newParser( DEFAULT_PARSER );\n     }\n \n+    /**\n+     * @return the CommandLineParser specified by <code>classname</code>.\n+     */\n     public static CommandLineParser newParser( String classname ) {\n         try {\n+            // return the new CommandLineParser\n             return (CommandLineParser)Class.forName( classname ).newInstance();\n         }\n         catch( Exception exp ) {\n                 // this will not happen ?\n             }\n         }\n+        // must return something\n         return null;\n     }\n }\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.6 2002/08/15 22:05:18 jkeyes Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/08/15 22:05:18 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n package org.apache.commons.cli;\n \n import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n-import java.util.ListIterator;\n import java.util.Map;\n+import java.util.Iterator;\n \n /**\n- * GnuParser parses the command line arguments using the GNU style.\n- * For example, -buildfile can only be interpreted as the option\n- * 'buildfile'.\n- *\n  * @author John Keyes (jbjk at mac.com)\n  */\n-public class GnuParser implements CommandLineParser {\n+public class GnuParser extends Parser {\n \n-    /** current options instance */\n-    private Options options;\n+    private ArrayList tokens = new ArrayList();\n \n-    /** convience member for the command line */\n-    private CommandLine cmd;\n-\n-    /** required options subset of options */\n-    private Map requiredOptions;\n-\n-    /**\n-     * Parse the arguments according to the specified options.\n-     *\n-     * @param options the specified Options\n-     * @param arguments the command line arguments\n-     * @return the list of atomic option and value tokens\n-     * @throws ParseException if there are any problems encountered\n-     * while parsing the command line tokens.\n-     */\n-    public CommandLine parse( Options options, String[] arguments ) \n-    throws ParseException\n-    {\n-        return parse( options, arguments, false );\n+    private void init() {\n+        tokens.clear();\n     }\n \n-    /**\n-     * Parse the arguments according to the specified options.\n-     *\n-     * @param opts the specified Options\n-     * @param arguments the command line arguments\n-     * @param stopAtNonOption specifies whether to continue parsing the\n-     * arguments if a non option is encountered.\n-     * @return the CommandLine\n-     * @throws ParseException if there are any problems encountered\n-     * while parsing the command line tokens.\n-     */\n-    public CommandLine parse( Options opts, String[] arguments, boolean stopAtNonOption ) \n-    throws ParseException\n+    protected String[] flatten( Options options, \n+                                String[] arguments, \n+                                boolean stopAtNonOption )\n     {\n-        // set the member instances\n-        options = opts;\n-        cmd = new CommandLine();\n-        requiredOptions = options.getRequiredOptions();\n-\n-        ListIterator iter = Arrays.asList( arguments ).listIterator();\n-        String token = null;\n-\n-        // flag to indicate whether the remainder of the tokens should\n-        // be added to the other arguments list\n-        boolean eatTheRest = false;\n-\n-        while ( iter.hasNext() ) {\n-            token = (String) iter.next();\n-            if ( token.equals(\"--\") ) {\n-                eatTheRest = true;\n-            }\n-            else if ( token.startsWith(\"--\") ) {\n-                //process the long-option\n-                processOption( token, iter );\n-            }\n-            else if ( token.startsWith(\"-\") ) {\n-                if ( token.length() == 1) {\n-                    // It's not really an option, so\n-                    // just drop it on the list\n-                    if ( stopAtNonOption ) {\n-                        eatTheRest = true;\n-                    }\n-                    else {\n-                        cmd.addArg( token );\n-                    }\n+        init();\n+        for( int i = 0; i < arguments.length; i++ ) {\n+            Option option = options.getOption( arguments[i] );\n+            try {\n+                Option specialOption = options.getOption( arguments[i].substring(0,2) );\n+                if( specialOption != null && option == null ) {\n+                    tokens.add( arguments[i].substring(0,2) );\n+                    tokens.add( arguments[i].substring(2) );\n                 }\n                 else {\n-                    processOption( token, iter );\n+                    tokens.add( arguments[i] );\n                 }\n             }\n-            else {\n-                // It's just a normal non-option arg,\n-                // so dump it into the list of returned\n-                // values.\n-\n-                cmd.addArg( token );\n-\n-                if ( stopAtNonOption ) {\n-                    eatTheRest = true;\n-                }\n-            }\n-\n-            if ( eatTheRest ) {\n-                while ( iter.hasNext() ) {\n-                    cmd.addArg( (String)iter.next() );\n-                }\n+            catch( IndexOutOfBoundsException exp ) {\n+                tokens.add( arguments[i] );\n             }\n         }\n-\n-        // see if all required options have been processed\n-        checkRequiredOptions( );\n-\n-        return cmd;\n+        return (String[])tokens.toArray( new String[] {} );\n     }\n-\n-    /**\n-     * It the option can accept multiple argument values then\n-     * keep adding values until the next option token is encountered.\n-     *\n-     * @param opt the specified option\n-     * @param iter the iterator over the command line tokens\n-     */\n-    public void processArgs( Option opt, ListIterator iter ) \n-    throws ParseException \n-    {\n-        if( !iter.hasNext() && !opt.hasOptionalArg() ) {\n-            throw new MissingArgumentException( \"no argument for:\" + opt.getOpt() );\n-        }\n-        // loop until an option is found\n-        while( iter.hasNext() ) {\n-            String var = (String)iter.next();\n-\n-            // its an option\n-            if( !var.equals( \"-\" ) && var.startsWith( \"-\" ) ) {\n-                // set the iterator pointer back a position\n-                iter.previous();\n-                break;\n-            }\n-            // its a value\n-            else if( !opt.addValue( var ) ) {\n-                iter.previous();\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Process the option represented by <code>arg</code>.\n-     * \n-     * @param arg the string representation of an option\n-     * @param iter the command line token iterator\n-     */\n-    private void processOption( String arg, ListIterator iter ) \n-    throws ParseException\n-    {\n-        String value = null;\n-\n-        // see if it is a single character special option\n-        Option opt = (Option) options.getOption( arg );\n-        Option specialOption = (Option) options.getOption( arg.substring(0,2 ) );\n-        if( specialOption != null && opt == null) {\n-            opt = specialOption;\n-            value = arg.substring( 2 );\n-            char sep = opt.getValueSeparator();\n-\n-            if( sep > 0 ) {\n-                int findex;\n-                while( ( findex = value.indexOf( sep ) ) != -1 ) {\n-                    String val = value.substring( 0, findex );\n-                    value = value.substring( findex + 1);\n-                    if( !opt.addValue( val ) ) {\n-                        cmd.addArg( val );\n-                    }\n-                }\n-                if( !opt.addValue( value ) ) {\n-                    cmd.addArg( value );\n-                }\n-            }\n-            else {\n-                // add the argument value\n-                opt.addValue( value );\n-            }\n-        }\n-\n-        // if there is no option throw an UnrecognisedOptionException\n-        if( opt == null ) {\n-            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n-        }\n-\n-        // if the option is a required option remove the option from\n-        // the requiredOptions list\n-        if ( opt.isRequired() ) {\n-            requiredOptions.remove( opt );\n-        }\n-\n-        // if the option is in an OptionGroup make that option the selected\n-        // option of the group\n-        if ( options.getOptionGroup( opt ) != null ) {\n-            ( (OptionGroup)( options.getOptionGroup( opt ) ) ).setSelected( opt );\n-        }\n-\n-        // if the option takes an argument value\n-        if ( opt.hasArg() ) {\n-            processArgs( opt, iter );\n-        }\n-\n-        // set the option on the command line\n-        cmd.setOpt( opt );\n-    }\n-\n-    /**\n-     * Ensures that all required options are present.\n-     *\n-     * @throws ParseException if all of the required options\n-     * are not present.\n-     */\n-    private void checkRequiredOptions( ) \n-    throws ParseException {\n-\n-        // if there are required options that have not been\n-        // processsed\n-        if( requiredOptions.size() > 0 ) {\n-            Iterator iter = requiredOptions.values().iterator();\n-            StringBuffer buff = new StringBuffer();\n-\n-            // loop through the required options\n-            while( iter.hasNext() ) {\n-                Option missing = (Option)iter.next();\n-                buff.append( \"-\" );\n-                buff.append( missing.getOpt() );\n-                buff.append( \" \" );\n-                buff.append( missing.getDescription() );\n-            }\n-\n-            // throw the MissingOptionException\n-            throw new MissingOptionException( buff.toString() );\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Parser.java\n+package org.apache.commons.cli;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+public abstract class Parser implements CommandLineParser {\n+\n+    private CommandLine cmd;\n+    private Options options;\n+    private Map requiredOptions;\n+\n+    abstract protected String[] flatten( Options opts, \n+                                         String[] args, \n+                                         boolean stopAtNonOption );\n+\n+    public CommandLine parse( Options opts, String[] args ) \n+    throws ParseException \n+    {\n+        return parse( opts, args, false );\n+    }\n+\n+    public CommandLine parse( Options opts, \n+                              String[] args, \n+                              boolean stopAtNonOption ) \n+    throws ParseException \n+    {\n+        options = opts;\n+        requiredOptions = options.getRequiredOptions();\n+        String[] tokens = flatten( opts, args, stopAtNonOption );\n+        List tokenList = Arrays.asList( tokens );\n+        ListIterator iterator = tokenList.listIterator();\n+        cmd = new CommandLine();\n+        boolean eatTheRest = false;\n+        while( iterator.hasNext() ) {\n+            String t = (String)iterator.next();\n+            if( \"--\".equals( t ) ) {\n+                eatTheRest = true;\n+            }\n+            else if( t.startsWith( \"-\" ) ) {\n+                if( t.length() == 1 ) {\n+                    // not an option, so just drop it on the argument list\n+                    if ( stopAtNonOption ) {\n+                        eatTheRest = true;\n+                    }\n+                    else {\n+                        cmd.addArg( t );\n+                    }\n+                }\n+                else {\n+                    processOption( t, iterator );\n+                }\n+            }\n+            else {\n+                cmd.addArg( t );\n+                if( stopAtNonOption ) {\n+                    eatTheRest = true;\n+                }\n+            }\n+\n+            if( eatTheRest ) {\n+                while( iterator.hasNext() ) {\n+                    cmd.addArg( (String)iterator.next() );\n+                }\n+            }\n+        }\n+        checkRequiredOptions();\n+        return cmd;\n+    }\n+\n+    private void checkRequiredOptions( ) \n+    throws ParseException {\n+\n+        // if there are required options that have not been\n+        // processsed\n+        if( requiredOptions.size() > 0 ) {\n+            Iterator iter = requiredOptions.values().iterator();\n+            StringBuffer buff = new StringBuffer();\n+\n+            // loop through the required options\n+            while( iter.hasNext() ) {\n+                Option missing = (Option)iter.next();\n+                buff.append( \"-\" );\n+                buff.append( missing.getOpt() );\n+                buff.append( \" \" );\n+                buff.append( missing.getDescription() );\n+            }\n+\n+            // throw the MissingOptionException\n+            throw new MissingOptionException( buff.toString() );\n+        }\n+    }\n+\n+    public void processArgs( Option opt, ListIterator iter ) \n+    throws ParseException \n+    {\n+        if( !iter.hasNext() && !opt.hasOptionalArg() ) {\n+            throw new MissingArgumentException( \"no argument for:\" + opt.getOpt() );\n+        }\n+        // loop until an option is found\n+        while( iter.hasNext() ) {\n+            String var = (String)iter.next();\n+            if( options.hasOption( var ) ) {\n+                iter.previous();\n+                break;\n+            }\n+\n+            // its a value\n+            else {\n+                if( !opt.addValue( var ) ) {\n+                    iter.previous();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void processOption( String arg, ListIterator iter ) \n+    throws ParseException\n+    {\n+        // get the option represented by arg\n+        Option opt = null;\n+\n+        boolean hasOption = options.hasOption( arg );\n+\n+        // if there is no option throw an UnrecognisedOptionException\n+        if( !hasOption ) {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n+        }\n+        else {\n+            opt = (Option) options.getOption( arg );\n+        }\n+\n+        // if the option is a required option remove the option from\n+        // the requiredOptions list\n+        if ( opt.isRequired() ) {\n+            requiredOptions.remove( \"-\" + opt.getOpt() );\n+        }\n+\n+        // if the option is in an OptionGroup make that option the selected\n+        // option of the group\n+        if ( options.getOptionGroup( opt ) != null ) {\n+            ( (OptionGroup)( options.getOptionGroup( opt ) ) ).setSelected( opt );\n+        }\n+\n+        // if the option takes an argument value\n+        if ( opt.hasArg() ) {\n+            processArgs( opt, iter );\n+        }\n+\n+        // set the option on the command line\n+        cmd.setOpt( opt );\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.7 2002/08/15 22:05:18 jkeyes Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/08/15 22:05:18 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n package org.apache.commons.cli;\n \n import java.util.Arrays;\n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.ListIterator;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.Iterator;\n \n /**\n- * PosixParser parses the command line arguments using the Posix style.\n- * For example, -buildfile can only be interpreted as the option\n- * 'b' with value 'uildfile' or it could be interpreted as the options\n- * 'b','u','i','l','d','f','i','l','e'.\n- *\n  * @author John Keyes (jbjk at mac.com)\n  */\n-public class PosixParser implements CommandLineParser {\n+public class PosixParser extends Parser {\n \n-    /** current options instance */\n+    private ArrayList tokens = new ArrayList();\n+    private boolean eatTheRest;\n+    private Option currentOption;\n     private Options options;\n \n-    /** convience member for the command line */\n-    private CommandLine cmd;\n-\n-    /** required options subset of options */\n-    private Map requiredOptions;\n-\n-    /**\n-     * Parse the arguments according to the specified options.\n-     *\n-     * @param options the specified Options\n-     * @param arguments the command line arguments\n-     * @return the list of atomic option and value tokens\n-     * @throws ParseException if there are any problems encountered\n-     * while parsing the command line tokens.\n-     */\n-    public CommandLine parse( Options options, String[] arguments ) \n-    throws ParseException\n-    {\n-        return parse( options, arguments, false );\n+    private void init() {\n+        eatTheRest = false;\n+        tokens.clear();\n+        currentOption = null;\n     }\n \n-    /**\n-     * Parse the arguments according to the specified options.\n-     *\n-     * @param opts the specified Options\n-     * @param arguments the command line arguments\n-     * @param stopAtNonOption specifies whether to continue parsing the\n-     * arguments if a non option is encountered.\n-     * @return the CommandLine\n-     * @throws ParseException if there are any problems encountered\n-     * while parsing the command line tokens.\n-     */\n-    public CommandLine parse( Options opts, String[] arguments, boolean stopAtNonOption ) \n-    throws ParseException\n+    protected String[] flatten( Options options, \n+                                String[] arguments, \n+                                boolean stopAtNonOption )\n     {\n-        // set the member instances\n-        options = opts;\n-        cmd = new CommandLine();\n-        requiredOptions = options.getRequiredOptions();\n+        init();\n+        this.options = options;\n \n         // an iterator for the command line tokens\n-        ListIterator iter = Arrays.asList( arguments ).listIterator();\n+        Iterator iter = Arrays.asList( arguments ).iterator();\n         String token = null;\n-        \n-        // flag to indicate whether the remainder of the tokens should\n-        // be added to the other arguments list\n-        boolean eatTheRest = false;\n         \n         // process each command line token\n         while ( iter.hasNext() ) {\n \n             // get the next command line token\n             token = (String) iter.next();\n-            \n-            // Look for -- to indicate end-of-options, and\n-            // just stuff it, along with everything past it\n-            // into the returned list.\n-            if ( token.equals(\"--\") ) {\n-                eatTheRest = true;\n+\n+            // handle SPECIAL TOKEN\n+            if( token.startsWith( \"--\" ) ) {\n+                tokens.add( token );\n             }\n-            else if ( token.startsWith(\"--\") ) {\n-                // process the long-option\n-                processOption( token, iter );\n+            // single hyphen\n+            else if( \"-\".equals( token ) ) {\n+                processSingleHyphen( token );\n             }\n-            else if ( token.startsWith(\"-\") ) {\n-                // it might be a short arg needing some bursting\n-                if ( token.length() == 1) {\n-                    // not an option, so just drop it on the argument list\n-                    if ( stopAtNonOption ) {\n-                        eatTheRest = true;\n-                    }\n-                    else {\n-                        cmd.addArg( token );\n-                    }\n+            else if( token.startsWith( \"-\" ) ) {\n+                int tokenLength = token.length();\n+                if( tokenLength == 2 ) {\n+                    processOptionToken( token, stopAtNonOption );\n                 }\n-                else if ( token.length() == 2 ) {\n-                    processOption( token, iter );\n-                }\n+                // requires bursting\n                 else {\n-                    // Needs bursting.  Figure out if we have multiple \n-                    // options, or maybe an option plus an arg, or some \n-                    // combination thereof.\n-                    \n-                    // iterate over each character in the token\n-                    for ( int i = 1 ; i < token.length() ; ++i ) {\n-\n-                        String argname = String.valueOf( token.charAt(i) );\n-                        // retrieve the associated option\n-                        boolean hasOption = options.hasOption( argname );\n-                        \n-                        Option opt = null;\n-\n-                        // if there is an associated option\n-                        if ( hasOption ) {\n-                            opt = options.getOption( argname );\n-\n-                            // if the option requires an argument value\n-                            if ( opt.hasArg() ) {\n-                                // consider the rest of the token\n-                                // to be the argument value\n-\n-                                // if there is no argument value\n-                                if( token.substring(i+1).length() == 0 && !opt.hasOptionalArg() ) {\n-                                    throw new MissingArgumentException( \"Missing argument value for \" + opt.getOpt() );\n-                                }\n-                                else {\n-                                    opt.addValue( token.substring(i+1) );\n-                                }\n-\n-                                // set the option \n-                                cmd.setOpt( opt );\n-\n-                                // don't process any more characters\n-                                break;\n-                            }\n-\n-                            // if the option does not require an argument\n-                            cmd.setOpt( opt );\n-                        }\n-                        // this is an unrecognized option\n-                        else {\n-                            throw new UnrecognizedOptionException( String.valueOf( token.charAt(i) ) );\n-                        }\n-                    }\n+                    burstToken( token, stopAtNonOption );\n                 }\n             }\n             else {\n-                // It's just a normal non-option arg, so dump it into the \n-                // list of returned values.\n-                cmd.addArg( token );\n-                \n-                if ( stopAtNonOption ) {\n-                    eatTheRest = true;\n+                if( stopAtNonOption ) {\n+                    process( token );\n+                }\n+                else {\n+                    tokens.add( token );\n                 }\n             }\n-            \n-            // add all unprocessed tokens to the arg list\n-            if ( eatTheRest ) {\n-                while ( iter.hasNext() ) {\n-                    cmd.addArg( (String)iter.next() );\n-                }\n-            }\n+\n+            gobble( iter );\n         }\n-        \n-        // see if all required options have been processed\n-        checkRequiredOptions( );\n \n-        // return the CommandLine instance\n-        return cmd;\n+        return (String[])tokens.toArray( new String[] {} );\n     }\n \n-    /**\n-     * Process the option represented by <code>arg</code>.\n-     * \n-     * @param arg the string representation of an option\n-     * @param iter the command line token iterator\n-     */\n-    private void processOption( String arg, ListIterator iter ) \n-    throws ParseException\n-    {\n-        // get the option represented by arg\n-        Option opt = null;\n-\n-        boolean hasOption = options.hasOption( arg );\n-\n-        // if there is no option throw an UnrecognisedOptionException\n-        if( !hasOption ) {\n-            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n-        }\n-        else {\n-            opt = (Option) options.getOption( arg );\n-        }\n-\n-        // if the option is a required option remove the option from\n-        // the requiredOptions list\n-        if ( opt.isRequired() ) {\n-            requiredOptions.remove( \"-\" + opt.getOpt() );\n-        }\n-\n-        // if the option is in an OptionGroup make that option the selected\n-        // option of the group\n-        if ( options.getOptionGroup( opt ) != null ) {\n-            ( (OptionGroup)( options.getOptionGroup( opt ) ) ).setSelected( opt );\n-        }\n-\n-        // if the option takes an argument value\n-        if ( opt.hasArg() ) {\n-            processArgs( opt, iter );\n-        }\n-\n-        // set the option on the command line\n-        cmd.setOpt( opt );\n-    }\n-\n-    /**\n-     * It the option can accept multiple argument values then\n-     * keep adding values until the next option token is encountered.\n-     *\n-     * @param opt the specified option\n-     * @param iter the iterator over the command line tokens\n-     */\n-    public void processArgs( Option opt, ListIterator iter ) \n-    throws ParseException \n-    {\n-        if( !iter.hasNext() && !opt.hasOptionalArg() ) {\n-            throw new MissingArgumentException( \"no argument for:\" + opt.getOpt() );\n-        }\n-        // loop until an option is found\n-        while( iter.hasNext() ) {\n-            String var = (String)iter.next();\n-\n-            // its an option\n-            if( !var.equals( \"-\" ) && var.startsWith( \"-\" ) ) {\n-                // set the iterator pointer back a position\n-                iter.previous();\n-                break;\n-            }\n-            // its a value\n-            else {\n-                if( !opt.addValue( var ) ) {\n-                    iter.previous();\n-                    break;\n-                }\n+    private void gobble( Iterator iter ) {\n+        if( eatTheRest ) {\n+            while( iter.hasNext() ) {\n+                tokens.add( iter.next() );\n             }\n         }\n     }\n \n-    /**\n-     * Ensures that all required options are present.\n-     *\n-     * @throws ParseException if all of the required options\n-     * are not present.\n-     */\n-    private void checkRequiredOptions( ) \n-    throws ParseException {\n+    private void process( String value ) {\n+        if( currentOption != null && currentOption.hasArg() ) {\n+            if( currentOption.hasArg() ) {\n+                tokens.add( value );\n+                currentOption = null;\n+            }\n+            else if (currentOption.hasArgs() ) {\n+                tokens.add( value );\n+            }\n+        }\n+        else {\n+            eatTheRest = true;\n+            tokens.add( \"--\" );\n+            tokens.add( value );\n+        }\n+    }\n \n-        // if there are required options that have not been\n-        // processsed\n-        if( requiredOptions.size() > 0 ) {\n-            Iterator iter = requiredOptions.values().iterator();\n-            StringBuffer buff = new StringBuffer();\n+    private void processSingleHyphen( String hyphen ) {\n+        tokens.add( hyphen );\n+    }\n \n-            // loop through the required options\n-            while( iter.hasNext() ) {\n-                Option missing = (Option)iter.next();\n-                buff.append( \"-\" );\n-                buff.append( missing.getOpt() );\n-                buff.append( \" \" );\n-                buff.append( missing.getDescription() );\n+    private void processOptionToken( String token, boolean stop ) {\n+        if( this.options.hasOption( token ) ) {\n+            currentOption = this.options.getOption( token );\n+            tokens.add( token );\n+        }\n+        else if( stop ) {\n+            eatTheRest = true;\n+        }\n+    }\n+\n+    private void burstToken( String token, boolean stop ) {\n+        int tokenLength = token.length();\n+\n+        for( int i = 1; i < tokenLength; i++) {\n+            String ch = String.valueOf( token.charAt( i ) );\n+            boolean hasOption = options.hasOption( ch );\n+\n+            if( hasOption ) {\n+                tokens.add( \"-\" + ch );\n+                currentOption = options.getOption( ch );\n+                if( currentOption.hasArg() && token.length()!=i+1 ) {\n+                    tokens.add( token.substring( i+1 ) );\n+                    break;\n+                }\n             }\n-\n-            // throw the MissingOptionException\n-            throw new MissingOptionException( buff.toString() );\n+            else if( stop ) {\n+                process( token.substring( i ) );\n+            }\n+            else {\n+                tokens.add( \"-\" + ch );\n+            }\n         }\n     }\n }", "timestamp": 1030227331, "metainfo": ""}