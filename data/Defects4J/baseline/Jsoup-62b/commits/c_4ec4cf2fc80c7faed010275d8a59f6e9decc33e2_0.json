{"sha": "4ec4cf2fc80c7faed010275d8a59f6e9decc33e2", "log": "Reduce GC by not forcing string builders", "commit": "\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n /**\n  * Readers the input stream into tokens.\n  */\n-class Tokeniser {\n+final class Tokeniser {\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n     private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private boolean isEmitPending = false;\n-    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n+    private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n+    private StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n     StringBuilder dataBuffer; // buffers data looking for </script>\n \n     Token.Tag tagPending; // tag we are building up\n             state.read(this, reader);\n \n         // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n-        if (charBuffer.length() > 0) {\n-            String str = charBuffer.toString();\n-            charBuffer.delete(0, charBuffer.length());\n+        if (charsBuilder.length() > 0) {\n+            String str = charsBuilder.toString();\n+            charsBuilder.delete(0, charsBuilder.length());\n+            charsString = null;\n             return new Token.Character(str);\n+        } else if (charsString != null) {\n+            Token token = new Token.Character(charsString);\n+            charsString = null;\n+            return token;\n         } else {\n             isEmitPending = false;\n             return emitPending;\n         }\n     }\n \n-    void emit(String str) {\n+    void emit(final String str) {\n         // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n         // does not set isEmitPending; read checks that\n-        charBuffer.append(str);\n+        if (charsString == null) {\n+            charsString = str;\n+        }\n+        else {\n+            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n+                charsBuilder.append(charsString);\n+            }\n+            charsBuilder.append(str);\n+        }\n     }\n \n     void emit(char[] chars) {\n-        charBuffer.append(chars);\n+        emit(String.valueOf(chars));\n     }\n \n     void emit(char c) {\n-        charBuffer.append(c);\n+        emit(String.valueOf(c));\n     }\n \n     TokeniserState getState() {", "timestamp": 1414366056, "metainfo": ""}