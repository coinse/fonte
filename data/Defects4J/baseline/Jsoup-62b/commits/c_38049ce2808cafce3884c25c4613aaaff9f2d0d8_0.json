{"sha": "38049ce2808cafce3884c25c4613aaaff9f2d0d8", "log": "Memoize the child element list, so that sibling index queries are much faster  Measurement was 24 ops/s prior, now 450 ops/s. (When matching ~ 12K elements in a loop)", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java\n+package org.jsoup.helper;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+/**\n+ * Implementation of ArrayList that watches out for changes to the contents.\n+ */\n+public abstract class ChangeNotifyingArrayList<E> extends ArrayList<E> {\n+    public ChangeNotifyingArrayList(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    public abstract void onContentsChanged();\n+\n+    @Override\n+    public E set(int index, E element) {\n+        onContentsChanged();\n+        return super.set(index, element);\n+    }\n+\n+    @Override\n+    public boolean add(E e) {\n+        onContentsChanged();\n+        return super.add(e);\n+    }\n+\n+    @Override\n+    public void add(int index, E element) {\n+        onContentsChanged();\n+        super.add(index, element);\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        onContentsChanged();\n+        return super.remove(index);\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        onContentsChanged();\n+        return super.remove(o);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        onContentsChanged();\n+        super.clear();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> c) {\n+        onContentsChanged();\n+        return super.addAll(c);\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> c) {\n+        onContentsChanged();\n+        return super.addAll(index, c);\n+    }\n+\n+    @Override\n+    protected void removeRange(int fromIndex, int toIndex) {\n+        onContentsChanged();\n+        super.removeRange(fromIndex, toIndex);\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        onContentsChanged();\n+        return super.removeAll(c);\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        onContentsChanged();\n+        return super.retainAll(c);\n+    }\n+\n+}\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.select.Selector;\n \n import java.io.IOException;\n+import java.lang.ref.SoftReference;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n  */\n public class Element extends Node {\n     private Tag tag;\n+    private SoftReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n \n     private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n \n      * @see #childNode(int)\n      */\n     public Element child(int index) {\n-        return children().get(index);\n+        return childElementsList().get(index);\n     }\n \n     /**\n      * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n      * </p>\n-     * @return child elements. If this element has no children, returns an\n-     * empty list.\n+     * @return child elements. If this element has no children, returns an empty list.\n      * @see #childNodes()\n      */\n     public Elements children() {\n-        // create on the fly rather than maintaining two lists. if gets slow, memoize, and mark dirty on change\n-        List<Element> elements = new ArrayList<Element>(childNodes.size());\n-        for (Node node : childNodes) {\n-            if (node instanceof Element)\n-                elements.add((Element) node);\n-        }\n-        return new Elements(elements);\n+        return new Elements(childElementsList());\n+    }\n+\n+    /**\n+     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n+     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n+     * @return a list of child elements\n+     */\n+    private List<Element> childElementsList() {\n+        List<Element> children;\n+        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n+            children = new ArrayList<Element>(childNodes.size());\n+            for (Node node : childNodes) {\n+                if (node instanceof Element)\n+                    children.add((Element) node);\n+            }\n+            shadowChildrenRef = new SoftReference<List<Element>>(children);\n+        }\n+        return children;\n+    }\n+\n+    /**\n+     * Clears the cached shadow child elements.\n+     */\n+    @Override\n+    void nodelistChanged() {\n+        super.nodelistChanged();\n+        shadowChildrenRef = null;\n     }\n \n     /**\n         addChildren(index, nodeArray);\n         return this;\n     }\n+\n+    /**\n+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n+     *\n+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n+     * end\n+     * @param children child nodes to insert\n+     * @return this element, for chaining.\n+     */\n+    public Element insertChildren(int index, Node... children) {\n+        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n+        int currentSize = childNodeSize();\n+        if (index < 0) index += currentSize +1; // roll around\n+        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n+\n+        addChildren(index, children);\n+        return this;\n+    }\n     \n     /**\n      * Create a new element by tag name, and add it as the last child.\n         if (parentNode == null)\n             return new Elements(0);\n \n-        List<Element> elements = parent().children();\n+        List<Element> elements = parent().childElementsList();\n         Elements siblings = new Elements(elements.size() - 1);\n         for (Element el: elements)\n             if (el != this)\n      */\n     public Element nextElementSibling() {\n         if (parentNode == null) return null;\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n         if (siblings.size() > index+1)\n      */\n     public Element previousElementSibling() {\n         if (parentNode == null) return null;\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n         if (index > 0)\n      */\n     public Element firstElementSibling() {\n         // todo: should firstSibling() exclude this?\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         return siblings.size() > 1 ? siblings.get(0) : null;\n     }\n     \n      */\n     public Integer elementSiblingIndex() {\n        if (parent() == null) return 0;\n-       return indexInList(this, parent().children()); \n+       return indexInList(this, parent().childElementsList());\n     }\n \n     /**\n      * @return the last sibling that is an element (aka the parent's last element child) \n      */\n     public Element lastElementSibling() {\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n     }\n     \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n+import org.jsoup.helper.ChangeNotifyingArrayList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n         else\n             return el;\n     }\n+\n+    void nodelistChanged() {\n+        // Element overrides this to clear its shadow children elements\n+    }\n     \n     /**\n      * Replace this node in the DOM with the supplied node.\n     }\n \n     protected void setParentNode(Node parentNode) {\n+        Validate.notNull(parentNode);\n         if (this.parentNode != null)\n             this.parentNode.removeChild(this);\n         this.parentNode = parentNode;\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n-            childNodes = new ArrayList<Node>(4);\n+            childNodes = new NodeList(4);\n         }\n     }\n \n         clone.siblingIndex = parent == null ? 0 : siblingIndex;\n         clone.attributes = attributes != null ? attributes.clone() : null;\n         clone.baseUri = baseUri;\n-        clone.childNodes = new ArrayList<Node>(childNodes.size());\n+        clone.childNodes = new NodeList(childNodes.size());\n \n         for (Node child: childNodes)\n             clone.childNodes.add(child);\n             }\n         }\n     }\n+\n+    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n+        NodeList(int initialCapacity) {\n+            super(initialCapacity);\n+        }\n+\n+        public void onContentsChanged() {\n+            nodelistChanged();\n+        }\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         }\n \n         try {\n-            div2.insertChildren(0, null);\n+            div2.insertChildren(0, (Collection<? extends Node>) null);\n             fail();\n         } catch (IllegalArgumentException e) {\n         }\n         assertTrue(a.tagName().equals(\"P\"));\n     }\n \n-    public void testChildrenElements() {\n+    @Test public void testChildrenElements() {\n         String html = \"<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>\";\n         Document doc = Jsoup.parse(html);\n         Element div = doc.select(\"div\").first();\n         assertEquals(0, img.children().size());\n         assertEquals(0, img.childNodes().size());\n     }\n+\n+    @Test public void testShadowElementsAreUpdated() {\n+        String html = \"<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>\";\n+        Document doc = Jsoup.parse(html);\n+        Element div = doc.select(\"div\").first();\n+        Elements els = div.children();\n+        List<Node> nodes = div.childNodes();\n+\n+        assertEquals(2, els.size()); // the two Ps\n+        assertEquals(3, nodes.size()); // the \"Three\" textnode\n+\n+        Element p3 = new Element(\"p\").text(\"P3\");\n+        Element p4 = new Element(\"p\").text(\"P4\");\n+        div.insertChildren(1, p3);\n+        div.insertChildren(3, p4);\n+        Elements els2 = div.children();\n+\n+        // first els should not have changed\n+        assertEquals(2, els.size());\n+        assertEquals(4, els2.size());\n+\n+        assertEquals(\"<p><a>One</a></p>\\n\" +\n+            \"<p>P3</p>\\n\" +\n+            \"<p><a>Two</a></p>\\n\" +\n+            \"<p>P4</p>Three\", div.html());\n+        assertEquals(\"P3\", els2.get(1).text());\n+        assertEquals(\"P4\", els2.get(3).text());\n+\n+        p3.after(\"<span>Another</span\");\n+\n+        Elements els3 = div.children();\n+        assertEquals(5, els3.size());\n+        assertEquals(\"span\", els3.get(2).tagName());\n+        assertEquals(\"Another\", els3.get(2).text());\n+\n+        assertEquals(\"<p><a>One</a></p>\\n\" +\n+            \"<p>P3</p>\\n\" +\n+            \"<span>Another</span>\\n\" +\n+            \"<p><a>Two</a></p>\\n\" +\n+            \"<p>P4</p>Three\", div.html());\n+    }\n }", "timestamp": 1497122730, "metainfo": ""}