{"sha": "548ce13435a00bb447fbffdbca8c5ce3be752ee4", "log": "Initial implementation of Tag.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n+package org.jsoup.parser;\n+\n+import org.apache.commons.lang.Validate;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,\n+ but it should capture most of what we need to know to intelligently parse a doc.\n+\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+class Tag {\n+    private static final Map<String, Tag> tags = new HashMap<String, Tag>();\n+\n+    private String tagName;\n+    private boolean isBlock; // block or inline\n+    private boolean canContainBlock; // Can this tag hold block level tags?\n+    private boolean canContainInline; // only pcdata if not\n+    private boolean optionalClosing; // If tag is open, and another seen, close previous tag\n+    private boolean empty; // can hold nothing; e.g. img\n+\n+    private Tag(String tagName, boolean block, boolean canContainBlock, boolean canContainInline, boolean optionalClosing, boolean empty) {\n+        this.tagName = tagName.toLowerCase();\n+        isBlock = block;\n+        this.canContainBlock = canContainBlock;\n+        this.canContainInline = canContainInline;\n+        this.optionalClosing = optionalClosing;\n+        this.empty = empty;\n+    }\n+\n+    /**\n+     Get a Tag by name. If not previously defined (unknown), registers and returns a new generic tag, that can do anything.\n+     <p>\n+     Two unknown tags with the same name will compare ==.\n+     @param tagName Name of tag, e.g. \"p\". Case insensitive.\n+     @return The tag, either defined or new generic.\n+     */\n+    public static Tag valueOf(String tagName) {\n+        Validate.notNull(tagName);\n+        tagName = tagName.trim().toLowerCase();\n+        Validate.notEmpty(tagName);\n+\n+        synchronized (tags) {\n+            Tag tag = tags.get(tagName);\n+            if (tag == null) {\n+                // not defined: create default\n+                // TODO: log, generate warning?\n+                tag = new Tag(tagName, true, true, true, false, false);\n+                register(tag);\n+            }\n+            return tag;\n+        }\n+    }\n+\n+    /**\n+     Test if this tag, the prospective parent, can accept the proposed child.\n+     @param child potential child tag.\n+     @return true if this can contain child.\n+     */\n+    public boolean canContain(Tag child) {\n+        Validate.notNull(child);\n+\n+        if (child.isBlock && !this.canContainBlock)\n+            return false;\n+\n+        if (!child.isBlock && !this.canContainInline) // not block == inline\n+            return false;\n+\n+        if (this.optionalClosing && this.equals(child))\n+            return false;\n+        // TODO: the optional closing may need more context to decide?\n+\n+        if (this.empty)\n+            return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Tag tag = (Tag) o;\n+\n+        if (canContainBlock != tag.canContainBlock) return false;\n+        if (canContainInline != tag.canContainInline) return false;\n+        if (empty != tag.empty) return false;\n+        if (isBlock != tag.isBlock) return false;\n+        if (optionalClosing != tag.optionalClosing) return false;\n+        if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = tagName != null ? tagName.hashCode() : 0;\n+        result = 31 * result + (isBlock ? 1 : 0);\n+        result = 31 * result + (canContainBlock ? 1 : 0);\n+        result = 31 * result + (canContainInline ? 1 : 0);\n+        result = 31 * result + (optionalClosing ? 1 : 0);\n+        result = 31 * result + (empty ? 1 : 0);\n+        return result;\n+    }\n+\n+    public String toString() {\n+        return tagName;\n+    }\n+\n+    // internal static initialisers:\n+\n+    static {\n+        // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline\n+        // tags are set here in uppercase for legibility, but internally held as lowercase.\n+        // TODO[must]: incorporate html 5 as appropriate\n+\n+        // fontstyle\n+        createInline(\"TT\");\n+        createInline(\"I\");\n+        createInline(\"B\");\n+        createInline(\"BIG\");\n+        createInline(\"SMALL\");\n+\n+        // phrase\n+        createInline(\"EM\");\n+        createInline(\"STRONG\");\n+        createInline(\"DFN\");\n+        createInline(\"CODE\");\n+        createInline(\"SAMP\");\n+        createInline(\"KBD\");\n+        createInline(\"VAR\");\n+        createInline(\"CITE\");\n+        createInline(\"ABBR\");\n+        createInline(\"ACRONYM\");\n+\n+        // special\n+        createInline(\"A\").setOptionalClosing(); // cannot contain self\n+        createInline(\"IMG\").setEmpty();\n+        createInline(\"OBJECT\"); // flow (block/inline) or param\n+        createInline(\"BR\").setEmpty();\n+        createInline(\"SCRIPT\").setContainDataOnly();\n+        createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.\n+        createInline(\"Q\");\n+        createInline(\"SUB\");\n+        createInline(\"SUP\");\n+        createInline(\"SPAN\");\n+        createInline(\"BDO\");\n+\n+        // things past this point aren't really blocks or inline. I'm using them because they can hold block or inline,\n+        // but per the spec, only specific elements can hold this. if this becomes a real-world parsing problem,\n+        // will need to have another non block/inline type, and explicit include & exclude rules. should be right though\n+\n+        // block\n+        createBlock(\"P\").setContainInlineOnly(); // emasculated block?\n+        createBlock(\"H1\").setContainInlineOnly();\n+        createBlock(\"H2\").setContainInlineOnly();\n+        createBlock(\"H3\").setContainInlineOnly();\n+        createBlock(\"H4\").setContainInlineOnly();\n+        createBlock(\"H5\").setContainInlineOnly();\n+        createBlock(\"H6\").setContainInlineOnly();\n+        createBlock(\"UL\");\n+        createBlock(\"OL\");\n+        createBlock(\"PRE\").setContainInlineOnly();\n+        createBlock(\"DL\");\n+        createBlock(\"DIV\");\n+        createBlock(\"NOSCRIPT\");\n+        createBlock(\"BLOCKQUOTE\");\n+        createBlock(\"FORM\").setOptionalClosing(); // can't contian self\n+        createBlock(\"HR\").setEmpty();\n+        createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n+        createBlock(\"FIELDSET\");\n+        createBlock(\"ADDRESS\").setContainInlineOnly();\n+\n+\n+        // formctrl\n+        createInline(\"INPUT\").setEmpty();\n+        createInline(\"SELECT\"); // just optgroup or option\n+        createInline(\"TEXTAREA\");\n+        createInline(\"LABEL\").setOptionalClosing(); // not self\n+        createInline(\"BUTTON\"); // bunch of excludes not defined\n+\n+        // document\n+        createBlock(\"HTML\"); // specific includes not impl\n+        createBlock(\"HEAD\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT\n+        createBlock(\"BODY\"); // specific includes not impl\n+\n+        // other\n+        createInline(\"AREA\").setEmpty(); // not an inline per-se\n+        createBlock(\"LINK\").setEmpty(); // only within head\n+        createInline(\"PARAM\").setEmpty(); // only within object\n+        createBlock(\"INS\"); // only within body\n+        createBlock(\"DEL\"); // only within body\n+\n+        createInline(\"DT\").setOptionalClosing(); // only within DL. Prolly should create implicit DL?\n+        createInline(\"DD\").setOptionalClosing(); // only within DL. Prolly should create implicit DL?\n+\n+        createBlock(\"LI\").setOptionalClosing(); // only within OL or UL. Implicit?\n+\n+        createInline(\"OPTGROUP\"); // only in select, only contain option\n+        createInline(\"OPTION\").setContainDataOnly();\n+        createInline(\"TEXTAREA\").setContainDataOnly();\n+        createInline(\"LEGEND\"); // only within fieldset (implicit?)\n+\n+        // tables\n+        createInline(\"CAPTION\");\n+        createInline(\"THEAD\").setOptionalClosing(); // just TR\n+        createInline(\"TFOOT\").setOptionalClosing(); // just TR\n+        createInline(\"TBODY\").setOptionalClosing(); // optional / implicit open too. just TR\n+        createInline(\"COLGROUP\").setOptionalClosing(); // just COL\n+        createInline(\"COL\").setEmpty();\n+        createInline(\"TR\").setOptionalClosing(); // just TH, TD\n+        createBlock(\"TD\").setOptionalClosing();\n+        \n+        // head\n+        createInline(\"TITLE\").setContainDataOnly();\n+        createInline(\"BASE\").setEmpty();\n+        createInline(\"META\").setEmpty();\n+        createInline(\"STYLE\").setContainDataOnly();\n+    }\n+\n+    private static Tag createBlock(String tagName) {\n+        return register(new Tag(tagName, true, true, true, false, false));\n+    }\n+\n+    private static Tag createInline(String tagName) {\n+        return register(new Tag(tagName, false, false, true, false, false));\n+    }\n+\n+    private static Tag register(Tag tag) {\n+        synchronized (tags) {\n+            tags.put(tag.tagName, tag);\n+        }\n+        return tag;\n+    }\n+\n+    private Tag setContainInlineOnly() {\n+        canContainBlock = false;\n+        canContainInline = true;\n+        return this;\n+    }\n+\n+    private Tag setContainDataOnly() {\n+        canContainBlock = false;\n+        canContainInline = false;\n+        return this;\n+    }\n+\n+    private Tag setEmpty() {\n+        canContainBlock = false;\n+        canContainInline = false;\n+        empty = true;\n+        return this;\n+    }\n+\n+    private Tag setOptionalClosing() {\n+        optionalClosing = true;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/TagTest.java\n+package org.jsoup.parser;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+/**\n+ Tag tests.\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+public class TagTest {\n+\n+    @Test public void isCaseInsensitive() {\n+        Tag p1 = Tag.valueOf(\"P\");\n+        Tag p2 = Tag.valueOf(\"p\");\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test public void trims() {\n+        Tag p1 = Tag.valueOf(\"p\");\n+        Tag p2 = Tag.valueOf(\" p \");\n+        assertEquals(p1, p2);\n+    }\n+\n+    @Test public void equality() {\n+        Tag p1 = Tag.valueOf(\"p\");\n+        Tag p2 = Tag.valueOf(\"p\");\n+        assertTrue(p1.equals(p2));\n+        assertTrue(p1 == p2);\n+    }\n+\n+    @Test public void divSemantics() {\n+        Tag div = Tag.valueOf(\"div\");\n+        Tag p = Tag.valueOf(\"p\");\n+\n+        assertTrue(div.canContain(div));\n+        assertTrue(div.canContain(p));\n+    }\n+\n+    @Test public void pSemantics() {\n+        Tag div = Tag.valueOf(\"div\");\n+        Tag p = Tag.valueOf(\"p\");\n+        Tag img = Tag.valueOf(\"img\");\n+        Tag span = Tag.valueOf(\"span\");\n+\n+        assertTrue(p.canContain(img));\n+        assertTrue(p.canContain(span));\n+        assertFalse(p.canContain(div));\n+        assertFalse(p.canContain(p));\n+    }\n+\n+    @Test public void spanSemantics() {\n+        Tag span = Tag.valueOf(\"span\");\n+        Tag p = Tag.valueOf(\"p\");\n+        Tag div = Tag.valueOf(\"div\");\n+\n+        assertTrue(span.canContain(span));\n+        assertFalse(span.canContain(p));\n+        assertFalse(span.canContain(div));\n+    }\n+\n+    @Test public void imgSemantics() {\n+        Tag img = Tag.valueOf(\"img\");\n+        Tag p = Tag.valueOf(\"p\");\n+\n+        assertFalse(img.canContain(img));\n+        assertFalse(img.canContain(p));\n+    }\n+\n+    @Test public void defaultSemantics() {\n+        Tag foo = Tag.valueOf(\"foo\"); // not defined\n+        Tag foo2 = Tag.valueOf(\"FOO\");\n+        Tag div = Tag.valueOf(\"div\");\n+\n+        assertEquals(foo, foo2);\n+        assertTrue(foo.canContain(foo));\n+        assertTrue(foo.canContain(div));\n+        assertTrue(div.canContain(foo));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class) public void valueOfChecksNotNull() {\n+        Tag.valueOf(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class) public void valueOfChecksNotEmpty() {\n+        Tag.valueOf(\" \");\n+    }\n+}", "timestamp": 1309605099, "metainfo": ""}