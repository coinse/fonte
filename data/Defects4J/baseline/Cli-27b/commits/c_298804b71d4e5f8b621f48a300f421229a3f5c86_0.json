{"sha": "298804b71d4e5f8b621f48a300f421229a3f5c86", "log": "Applying Henning's patch to make the Parser more extendable - CLI-142  ", "commit": "\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n public abstract class Parser implements CommandLineParser {\n \n     /** commandline instance */\n-    private CommandLine cmd;\n+    protected CommandLine cmd;\n \n     /** current Options */\n     private Options options;\n \n     /** list of required options strings */\n     private List requiredOptions;\n+\n+    protected void setOptions(final Options options) {\n+        this.options = options;\n+        this.requiredOptions = options.getRequiredOptions();\n+    }\n+\n+    protected Options getOptions() {\n+        return options;\n+    }\n+\n+    protected List getRequiredOptions() {\n+        return requiredOptions;\n+    }\n+\n \n     /**\n      * <p>Subclasses must implement this method to reduce\n                              Properties properties, boolean stopAtNonOption)\n         throws ParseException\n     {\n-        // initialise members\n-        this.options = options;\n-\n         // clear out the data in options in case it's been used before (CLI-71)\n         for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n             Option opt = (Option) it.next();\n             opt.clearValues();\n         }\n \n-        requiredOptions = options.getRequiredOptions();\n+        // initialise members\n+        setOptions(options);\n+\n         cmd = new CommandLine();\n \n         boolean eatTheRest = false;\n             arguments = new String[0];\n         }\n \n-        List tokenList = Arrays.asList(flatten(this.options, \n+        List tokenList = Arrays.asList(flatten(getOptions(), \n                                                arguments, \n                                                stopAtNonOption));\n \n             // the value is an option\n             else if (t.startsWith(\"-\"))\n             {\n-                if (stopAtNonOption && !options.hasOption(t))\n+                if (stopAtNonOption && !getOptions().hasOption(t))\n                 {\n                     eatTheRest = true;\n                     cmd.addArg(t);\n      *\n      * @param properties The value properties to be processed.\n      */\n-    private void processProperties(Properties properties)\n+    protected void processProperties(Properties properties)\n     {\n         if (properties == null)\n         {\n \n             if (!cmd.hasOption(option))\n             {\n-                Option opt = options.getOption(option);\n+                Option opt = getOptions().getOption(option);\n \n                 // get the value from the properties instance\n                 String value = properties.getProperty(option);\n      * @throws MissingOptionException if any of the required Options\n      * are not present.\n      */\n-    private void checkRequiredOptions()\n+    protected void checkRequiredOptions()\n         throws MissingOptionException\n     {\n         // if there are required options that have not been\n         // processsed\n-        if (requiredOptions.size() > 0)\n-        {\n-            Iterator iter = requiredOptions.iterator();\n+        if (getRequiredOptions().size() > 0)\n+        {\n+            Iterator iter = getRequiredOptions().iterator();\n             StringBuffer buff = new StringBuffer(\"Missing required option\");\n-            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n+            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n             buff.append(\": \");\n \n \n             String str = (String) iter.next();\n \n             // found an Option, not an argument\n-            if (options.hasOption(str) && str.startsWith(\"-\"))\n+            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n             {\n                 iter.previous();\n                 break;\n      * @throws ParseException if <code>arg</code> does not\n      * represent an Option\n      */\n-    private void processOption(String arg, ListIterator iter)\n+    protected void processOption(String arg, ListIterator iter)\n         throws ParseException\n     {\n-        boolean hasOption = options.hasOption(arg);\n+        boolean hasOption = getOptions().hasOption(arg);\n \n         // if there is no option throw an UnrecognisedOptionException\n         if (!hasOption)\n         }\n         \n         // get the option represented by arg\n-        final Option opt = options.getOption(arg);\n+        final Option opt = getOptions().getOption(arg);\n \n         // if the option is a required option remove the option from\n         // the requiredOptions list\n         if (opt.isRequired())\n         {\n-            requiredOptions.remove(opt.getKey());\n+            getRequiredOptions().remove(opt.getKey());\n         }\n \n         // if the option is in an OptionGroup make that option the selected\n         // option of the group\n-        if (options.getOptionGroup(opt) != null)\n-        {\n-            OptionGroup group = options.getOptionGroup(opt);\n+        if (getOptions().getOptionGroup(opt) != null)\n+        {\n+            OptionGroup group = getOptions().getOptionGroup(opt);\n \n             if (group.isRequired())\n             {\n-                requiredOptions.remove(group);\n+                getRequiredOptions().remove(group);\n             }\n \n             group.setSelected(opt);", "timestamp": 1210228994, "metainfo": ""}