{"sha": "d5c05da1d75d6926e56269a5bfefb8e763f1a9e4", "log": "Moved the CLI2 converters to the top of the cli-1 branch - probably dead code in the long term as the plan is to have a CLI-1 compliant facade onto CLI-2.   ", "commit": "\n--- /dev/null\n+++ b/CLI2Converter.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.validation.InvalidArgumentException;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * A utility class for converting data structures version 1 to \n+ * version 2 Option instances.\n+ */\n+public class CLI2Converter {\n+\t\n+\tprivate CLI2Converter(){\n+\t\t// prevent creation of static utility class \n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Option instance from a version 1 Option instance.\n+\t * \n+\t * @param option1 the version 1 Option to convert\n+\t * @return a version 2 Option  \n+\t */\n+\tpublic static Option option(final org.apache.commons.cli.Option option1){\n+\t\t\n+\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+\t\tobuilder.withRequired(option1.isRequired());\n+\t\t\n+\t\tfinal String shortName = option1.getOpt();\n+\t\tif(shortName!=null && !\" \".equals(shortName)){\n+\t\t\tobuilder.withShortName(shortName);\n+\t\t}\n+\t\t\n+\t\tfinal String longName = option1.getLongOpt();\n+\t\tif(longName!=null){\n+\t\t\tobuilder.withLongName(longName);\n+\t\t}\n+\t\tobuilder.withId(option1.getId());\n+\t\t\n+\t\tfinal String description = option1.getDescription();\n+\t\tif(description!=null){\n+\t\t\tobuilder.withDescription(description);\n+\t\t}\n+\t\t\n+\t\tif(option1.hasArg()){\n+\t\t\tfinal ArgumentBuilder abuilder = new ArgumentBuilder();\n+\t\t\tfinal String argName = option1.getArgName();\n+\t\t\tabuilder.withName(argName);\n+\t\t\tabuilder.withMaximum(option1.getArgs());\n+\t\t\tif(option1.hasValueSeparator()){\n+\t\t\t\tabuilder.withSubsequentSeparator(option1.getValueSeparator());\n+\t\t\t}\n+\t\t\tif(option1.hasOptionalArg()){\n+\t\t\t\tabuilder.withMinimum(0);\n+\t\t\t}\n+\t\t\telse{\n+\t\t\t\t//TODO check what non-optional arg means\n+\t\t\t\tabuilder.withMinimum(option1.getArgs());\n+\t\t\t}\n+\t\t\t\n+\t\t\tfinal Object type = option1.getType();\n+\t\t\tif(type!=null){\n+\t\t\t\tabuilder.withValidator(new TypeHandlerValidator(type));\n+\t\t\t}\n+\t\t\t\n+\t\t\tobuilder.withArgument(abuilder.create());\n+\t\t}\n+\t\t\n+\t\treturn obuilder.create();\n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Group instance from a version 1 OptionGroup instance.\n+\t * \n+\t * @param optionGroup1 the version 1 OptionGroup to convert\n+\t * @return a version 2 Group\n+\t */\n+\tpublic static Group group(final OptionGroup optionGroup1){\n+\t\t\n+\t\tfinal GroupBuilder gbuilder = new GroupBuilder();\n+\t\t\n+\t\tfor(final Iterator i = optionGroup1.getOptions().iterator();i.hasNext();){\n+\t\t\tfinal org.apache.commons.cli.Option option1 = (org.apache.commons.cli.Option)i.next();\n+\t\t\tfinal Option option2 = option(option1);\n+\t\t\tgbuilder.withOption(option2);\n+\t\t}\n+\t\t\n+\t\tgbuilder.withMaximum(1);\n+\t\t\n+\t\tif(optionGroup1.isRequired()){\n+\t\t\tgbuilder.withMinimum(1);\n+\t\t}\n+\t\t\n+\t\treturn gbuilder.create();\n+\t}\n+\t\n+\t/**\n+\t * Creates a version 2 Group instance from a version 1 Options instance.\n+\t * \n+\t * @param options1 the version 1 Options to convert\n+\t * @return a version 2 Group\n+\t */\n+\tpublic static Group group(final Options options1){\n+\t\t\n+\t\tfinal GroupBuilder gbuilder = new GroupBuilder();\n+\t\t\n+\t\tfinal Set optionGroups = new HashSet();\n+\t\t\n+\t\tfor(final Iterator i = options1.getOptionGroups().iterator();i.hasNext();){\n+\t\t\tfinal OptionGroup optionGroup1 = (OptionGroup)i.next();\n+\t\t\tGroup group = group(optionGroup1);\n+\t\t\tgbuilder.withOption(group);\n+\t\t\toptionGroups.add(optionGroup1);\n+\t\t}\n+\t\t\n+\t\tfor(final Iterator i = options1.getOptions().iterator();i.hasNext();){\n+\t\t\tfinal org.apache.commons.cli.Option option1 = (org.apache.commons.cli.Option)i.next();\n+\t\t\tif(!optionInAGroup(option1,optionGroups)){\n+\t\t\t\tfinal Option option2 = option(option1);\n+\t\t\t\tgbuilder.withOption(option2);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn gbuilder.create();\n+\t}\n+\n+\tprivate static boolean optionInAGroup(final org.apache.commons.cli.Option option1, final Set optionGroups) {\n+\t\tfor (Iterator i = optionGroups.iterator(); i.hasNext();) {\n+\t\t\tOptionGroup group = (OptionGroup) i.next();\n+\t\t\tif(group.getOptions().contains(option1)){\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+}\n+\n+class TypeHandlerValidator implements Validator{\n+\t\n+\tprivate final Object type;\n+\t\n+\t/**\n+     * Creates a new Validator using the TypeHandler class.\n+     * \n+     * @see TypeHandler\n+\t * @param type The required type for valid elements\n+\t */\n+\tpublic TypeHandlerValidator(final Object type){\n+\t\tthis.type = type;\n+\t}\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+\t */\n+\tpublic void validate(final List values) throws InvalidArgumentException {\n+\t\tfinal ListIterator i = values.listIterator();\n+\t\twhile(i.hasNext()){\n+\t\t\tfinal String value = (String)i.next();\n+\t\t\tfinal Object converted = TypeHandler.createValue(value,type);\n+\t\t\tif(converted==null){\n+\t\t\t\tthrow new InvalidArgumentException(\"Unable to understand value: \" + value);\n+\t\t\t}\n+\t\t\ti.set(converted);\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/CLI2ConverterTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.builder.PatternBuilder;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+import junit.framework.TestCase;\n+\n+public class CLI2ConverterTest extends TestCase {\n+\t\n+\tprivate Options aceOptions;\n+\tprivate OptionGroup aceOptionGroup;\n+\tprivate Options abcdeOptions;\n+\tprivate Options pattern;\n+\t\n+\tprivate Option a;\n+\tprivate Option bbb;\n+\tprivate Option c;\n+\tprivate Option ddd;\n+\tprivate Option e;\n+\tprivate Option f;\n+\tprivate Option g;\n+\tprivate Option h;\n+\tprivate Option i;\n+\t\n+\tpublic void setUp(){\n+\t\ta = OptionBuilder.withDescription(\"A description\").create('a');\n+\t\tbbb = OptionBuilder.create(\"bbb\");\n+\t\tc = OptionBuilder.withLongOpt(\"ccc\").create('c');\n+\t\tddd = OptionBuilder.withLongOpt(\"ddd\").create();\n+\t\te = OptionBuilder.isRequired(true).create(\"e\");\n+\t\tf = OptionBuilder.hasArg().withArgName(\"argument\").create('f');\n+\t\tg = OptionBuilder.hasArgs(5).create('g');\n+\t\th = OptionBuilder.hasOptionalArg().create('h');\n+\t\ti = OptionBuilder.hasOptionalArgs(5).create('i');\n+\n+\t\taceOptions = new Options();\n+\t\taceOptions.addOption(OptionBuilder.create('a'));\n+\t\taceOptions.addOption(OptionBuilder.create('c'));\n+\t\taceOptions.addOption(OptionBuilder.create('e'));\n+\t\t\n+\t\taceOptionGroup = new OptionGroup();\n+\t\taceOptionGroup.addOption(OptionBuilder.create('a'));\n+\t\taceOptionGroup.addOption(OptionBuilder.create('c'));\n+\t\taceOptionGroup.addOption(OptionBuilder.create('e'));\n+\t\t\n+\t\tabcdeOptions = new Options();\n+\t\tabcdeOptions.addOption(OptionBuilder.create('d'));\n+\t\tOptionGroup og = new OptionGroup();\n+\t\tog.addOption(OptionBuilder.create('a'));\n+\t\tog.addOption(OptionBuilder.create('c'));\n+\t\tog.addOption(OptionBuilder.create('e'));\n+\t\tabcdeOptions.addOptionGroup(og);\n+\t\tabcdeOptions.addOption(OptionBuilder.create('b'));\n+\t\t\n+\t\tpattern = PatternOptionBuilder.parsePattern(\"a%ce:\");\n+\t}\n+\t\n+\t/*\n+\t * Class to test for Option option(Option)\n+\t */\n+\tpublic void testOption() {\n+\t\tassertTrue(e.isRequired());\n+\t\t\n+\t\tassertEquals(\"A description\",a.getDescription());\n+\t\tassertEquals('a',a.getId());\n+\t\tassertEquals(\"[-a]\",CLI2Converter.option(a).toString());\n+\t\tassertEquals(\"[-bbb]\",CLI2Converter.option(bbb).toString());\n+\t\tassertEquals(\"[-c (--ccc)]\",CLI2Converter.option(c).toString());\n+\t\tassertEquals(\"[--ddd]\",CLI2Converter.option(ddd).toString());\n+\t\tassertEquals(\"-e\",CLI2Converter.option(e).toString());\n+\t\tassertEquals(\"[-f <argument>]\",CLI2Converter.option(f).toString());\n+\t\tassertEquals(\"[-g <arg1> <arg2> <arg3> <arg4> <arg5>]\",CLI2Converter.option(g).toString());\n+\t\tassertEquals(\"[-h [<arg>]]\",CLI2Converter.option(h).toString());\n+\t\tassertEquals(\"[-i [<arg1> [<arg2> [<arg3> [<arg4> [<arg5>]]]]]]\",CLI2Converter.option(i).toString());\n+\t}\n+\t/*\n+\t * Class to test for Group group(OptionGroup)\n+\t */\n+\tpublic void testGroupOptionGroup() {\n+\t\tGroupImpl group;\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptionGroup);\n+\t\tassertEquals(\"[-a|-c|-e]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(1,group.getMaximum());\n+\t\t\n+\t\taceOptionGroup.setRequired(true);\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptionGroup);\n+\t\tassertEquals(\"-a|-c|-e\",group.toString());\n+\t\tassertEquals(1,group.getMinimum());\n+\t\tassertEquals(1,group.getMaximum());\n+\t}\n+\t/*\n+\t * Class to test for Group group(Options)\n+\t */\n+\tpublic void testGroupOptions() {\n+\t\t\n+\t\tGroupImpl group;\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(aceOptions);\n+\t\tassertEquals(\"[-a|-c|-e]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(abcdeOptions);\n+\t\t\n+\t\tassertEquals(\"[-a|-c|-e|-d|-b]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t\t\n+\t\tgroup = (GroupImpl)CLI2Converter.group(pattern);\n+\t\tassertEquals(\"[-a <arg>|-c|-e <arg>]\",group.toString());\n+\t\tassertEquals(0,group.getMinimum());\n+\t\tassertEquals(Integer.MAX_VALUE,group.getMaximum());\n+\t}\n+}", "timestamp": 1151268549, "metainfo": ""}