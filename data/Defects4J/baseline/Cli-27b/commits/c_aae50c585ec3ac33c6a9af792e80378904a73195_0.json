{"sha": "aae50c585ec3ac33c6a9af792e80378904a73195", "log": "moved cli over from the sandbox to commons proper   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/AlreadySelectedException.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/AlreadySelectedException.java,v 1.4 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** <p>Exception thrown when more than one option in an option group\n+ * has been provided.</p>\n+ *\n+ * @author John Keyes (john @ integralsource.com)\n+ * @version $Revision: 1.4 $\n+ */\n+class AlreadySelectedException extends ParseException {\n+\n+    /** Construct a new Exception with a message\n+     *\n+     * @param message Explanation of the exception\n+     */\n+    public AlreadySelectedException( String message ) {\n+        super( message );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/CommandLine.java,v 1.4 2002/06/06 22:32:37 bayard Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/06 22:32:37 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.List;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.HashMap;\n+\n+/** <p>Represents list of arguments parsed against\n+ * a {@link Options} descriptor.<p>\n+ *\n+ * <p>It allows querying of a boolean {@link #hasOption(char opt)},\n+ * in addition to retrieving the {@link #getOptionValue(char opt)}\n+ * for options requiring arguments.</p>\n+ *\n+ * <p>Additionally, any left-over or unrecognized arguments,\n+ * are available for further processing.</p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision: 1.4 $\n+ */\n+public class CommandLine {\n+    \n+    /** the unrecognised options/arguments */\n+    private List args    = new LinkedList();\n+\n+    /** the recognised options/arguments */\n+    private Map  options = new HashMap();\n+\n+    /** the option types */\n+    private Map  types   = new HashMap();\n+\n+    /**\n+     * <p>Creates a command line.</p>\n+     */\n+    CommandLine() {\n+    }\n+    \n+    /** <p>Query to see if an option has been set.</p>\n+     *\n+     * @param opt Short single-character name of the option\n+     * @return true if set, false if not\n+     */\n+    public boolean hasOption(char opt) {\n+        return options.containsKey( new Character(opt) );\n+    }\n+\n+    public Object getOptionObject(char opt) {\n+        String[] result = (String[])options.get( new Character(opt) );\n+        Object type = types.get( new Character(opt) );\n+        String res = result == null ? null : result[0];\n+        if(res == null) {\n+            return null;\n+        }\n+        return TypeHandler.createValue(res, type);\n+    }\n+\n+    /** <p>Retrieve the argument, if any,  of an option.</p>\n+     *\n+     * @param opt Short single-character name of the option\n+     * @return Value of the argument if option is set, and has an argument, else null.\n+     */\n+    public String getOptionValue(char opt) {\n+        String[] result = (String[])options.get( new Character(opt) );\n+        return result == null ? null : result[0];\n+    }\n+\n+    /** <p>Retrieves the array of values, if any, of an option.</p>\n+     *\n+     * @param opt Single-character name of the option\n+     * @return An array of values if the option is set, and has an argument, else null.\n+     */\n+    public String[] getOptionValues(char opt) {\n+        String[] result = (String[])options.get( new Character(opt) );\n+        return result == null ? null : result;\n+    }\n+    \n+    /** <p>Retrieve the argument, if any,  of an option.</p>\n+     *\n+     * @param opt Short single-character name of the option\n+     * @param defaultValue is the default value to be returned if the option is not specified\n+     * @return Value of the argument if option is set, and has an argument, else null.\n+     */\n+    public String getOptionValue(char opt, String defaultValue) {\n+        String answer = getOptionValue(opt);\n+        return (answer != null) ? answer : defaultValue;\n+    }\n+    \n+    /** <p>Retrieve any left-over non-recognized options and arguments</p>\n+     *\n+     * @return an array of remaining items passed in but not parsed\n+     */\n+    public String[] getArgs() {\n+        String[] answer = new String[ args.size() ];\n+        args.toArray( answer );\n+        return answer;\n+    }\n+    \n+    /** <p>Retrieve any left-over non-recognized options and arguments</p>\n+     *\n+     * @return List of remaining items passed in but not parsed\n+     */\n+    public List getArgList() {\n+        return args;\n+    }\n+    \n+    /** <p>Dump state, suitable for debugging.</p>\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        \n+        buf.append( \"[ CommandLine: [ options: \" );\n+        buf.append( options.toString() );\n+        buf.append( \" ] [ args: \");\n+        buf.append( args.toString() );\n+        buf.append( \" ] ]\" );\n+        \n+        return buf.toString();\n+    }\n+    \n+    /**\n+     * <p>Add left-over unrecognized option/argument.</p>\n+     *\n+     * @param arg the unrecognised option/argument.\n+     */\n+    void addArg(String arg) {\n+        args.add( arg );\n+    }\n+    \n+    /**\n+     * <p>Add an option that does not have any value to the \n+     * command line.</p>\n+     *\n+     * @param opt the processed option\n+     */\n+    void setOpt(char opt) {\n+        options.put( new Character(opt), null );\n+    }\n+    \n+    /**\n+     * <p>Add an option with the specified value to the \n+     * command line.</p>\n+     *\n+     * @param opt the processed option\n+     * @param value the value of the option\n+     */\n+    void setOpt(char opt, String value) {\n+        options.put( new Character(opt), value );\n+    }\n+    \n+    /**\n+     * <p>Add an option to the command line.  The values of \n+     * the option are stored.</p>\n+     *\n+     * @param opt the processed option\n+     */\n+    void setOpt(Option opt) {\n+        Character chr = new Character( opt.getOpt() );\n+        options.put( chr, opt.getValues() );\n+        types.put( chr, opt.getType() );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: HelpFormatter.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ */\n+package org.apache.commons.cli;\n+\n+import java.io.PrintWriter;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+\n+/** \n+ * A formatter of help messages for the current command line options\n+ *\n+ * @author Slawek Zachcial\n+ **/\n+public class HelpFormatter\n+{\n+   // --------------------------------------------------------------- Constants\n+\n+   public static final int DEFAULT_WIDTH              = 80;\n+   public static final int DEFAULT_LEFT_PAD           = 1;\n+   public static final int DEFAULT_DESC_PAD           = 3;\n+   public static final String DEFAULT_SYNTAX_PREFIX   = \"usage: \";\n+   public static final String DEFAULT_OPT_PREFIX      = \"-\";\n+   public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n+   public static final String DEFAULT_ARG_NAME        = \"arg\";\n+\n+   // ------------------------------------------------------------------ Static\n+\n+   // -------------------------------------------------------------- Attributes\n+\n+   public int defaultWidth;\n+   public int defaultLeftPad;\n+   public int defaultDescPad;\n+   public String defaultSyntaxPrefix;\n+   public String defaultNewLine;\n+   public String defaultOptPrefix;\n+   public String defaultLongOptPrefix;\n+   public String defaultArgName;\n+\n+   // ------------------------------------------------------------ Constructors\n+   public HelpFormatter()\n+   {\n+      defaultWidth = DEFAULT_WIDTH;\n+      defaultLeftPad = DEFAULT_LEFT_PAD;\n+      defaultDescPad = DEFAULT_DESC_PAD;\n+      defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n+      defaultNewLine = System.getProperty(\"line.separator\");\n+      defaultOptPrefix = DEFAULT_OPT_PREFIX;\n+      defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n+      defaultArgName = DEFAULT_ARG_NAME;\n+   }\n+\n+   // ------------------------------------------------------------------ Public\n+\n+   public void printHelp( String cmdLineSyntax,\n+                          Options options )\n+   {\n+      printHelp( defaultWidth, cmdLineSyntax, null, options, null );\n+   }\n+\n+   public void printHelp( String cmdLineSyntax,\n+                          String header,\n+                          Options options,\n+                          String footer )\n+   {\n+      printHelp(defaultWidth, cmdLineSyntax, header, options, footer);\n+   }\n+\n+   public void printHelp( int width,\n+                          String cmdLineSyntax,\n+                          String header,\n+                          Options options,\n+                          String footer )\n+   {\n+      PrintWriter pw = new PrintWriter(System.out);\n+      printHelp( pw, width, cmdLineSyntax, header,\n+                 options, defaultLeftPad, defaultDescPad, footer );\n+      pw.flush();\n+   }\n+\n+   public void printHelp( PrintWriter pw,\n+                          int width,\n+                          String cmdLineSyntax,\n+                          String header,\n+                          Options options,\n+                          int leftPad,\n+                          int descPad,\n+                          String footer )\n+      throws IllegalArgumentException\n+   {\n+      if ( cmdLineSyntax == null || cmdLineSyntax.length() == 0 )\n+      {\n+         throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n+      }\n+\n+      printUsage( pw, width, cmdLineSyntax );\n+      if ( header != null && header.trim().length() > 0 )\n+      {\n+         printWrapped( pw, width, header );\n+      }\n+      printOptions( pw, width, options, leftPad, descPad );\n+      if ( footer != null && footer.trim().length() > 0 )\n+      {\n+         printWrapped( pw, width, footer );\n+      }\n+   }\n+\n+   public void printUsage( PrintWriter pw, int width, String cmdLineSyntax )\n+   {\n+      int argPos = cmdLineSyntax.indexOf(' ') + 1;\n+      printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos,\n+                   defaultSyntaxPrefix + cmdLineSyntax);\n+   }\n+\n+   public void printOptions( PrintWriter pw, int width, Options options, int leftPad, int descPad )\n+   {\n+      StringBuffer sb = new StringBuffer();\n+      renderOptions(sb, width, options, leftPad, descPad);\n+      pw.println(sb.toString());\n+   }\n+\n+   public void printWrapped( PrintWriter pw, int width, String text )\n+   {\n+      printWrapped(pw, width, 0, text);\n+   }\n+\n+   public void printWrapped( PrintWriter pw, int width, int nextLineTabStop, String text )\n+   {\n+      StringBuffer sb = new StringBuffer(text.length());\n+      renderWrappedText(sb, width, nextLineTabStop, text);\n+      pw.println(sb.toString());\n+   }\n+\n+   // --------------------------------------------------------------- Protected\n+\n+   protected StringBuffer renderOptions( StringBuffer sb,\n+                                         int width,\n+                                         Options options,\n+                                         int leftPad,\n+                                         int descPad )\n+   {\n+      final String lpad = createPadding(leftPad);\n+      final String dpad = createPadding(descPad);\n+\n+      //first create list containing only <lpad>-a,--aaa where -a is opt and --aaa is\n+      //long opt; in parallel look for the longest opt string\n+      //this list will be then used to sort options ascending\n+      int max = 0;\n+      StringBuffer optBuf;\n+      List prefixList = new ArrayList();\n+      Option option;\n+      for ( Iterator i = options.getOptions().iterator(); i.hasNext(); )\n+      {\n+         option = (Option) i.next();\n+         optBuf = new StringBuffer(8);\n+         optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n+         if ( option.hasLongOpt() )\n+         {\n+            optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n+         }\n+         if ( option.hasArg() )\n+         {\n+            //FIXME - should have a way to specify arg name per option\n+            optBuf.append(' ').append(defaultArgName);\n+         }\n+         prefixList.add(optBuf);\n+         max = optBuf.length() > max ? optBuf.length() : max;\n+      }\n+\n+      //right pad the prefixes\n+      for ( Iterator i = prefixList.iterator(); i.hasNext(); )\n+      {\n+         optBuf = (StringBuffer) i.next();\n+         if ( optBuf.length() < max )\n+         {\n+            optBuf.append(createPadding(max-optBuf.length()));\n+         }\n+         optBuf.append(dpad);\n+      }\n+\n+      //sort this list ascending\n+      Collections.sort(prefixList, new StringBufferComparator());\n+\n+      //finally render options\n+      int nextLineTabStop = max + descPad;\n+      char opt;\n+      int optOffset = leftPad + defaultOptPrefix.length();\n+\n+      for ( Iterator i = prefixList.iterator(); i.hasNext(); )\n+      {\n+         optBuf = (StringBuffer) i.next();\n+         opt = optBuf.charAt(optOffset);\n+         option = options.getOption(opt);\n+         renderWrappedText(sb, width, nextLineTabStop,\n+                           optBuf.append(option.getDescription()).toString());\n+         if ( i.hasNext() )\n+         {\n+            sb.append(defaultNewLine);\n+         }\n+      }\n+\n+      return sb;\n+   }\n+\n+   protected StringBuffer renderWrappedText( StringBuffer sb,\n+                                             int width,\n+                                             int nextLineTabStop,\n+                                             String text )\n+   {\n+      int pos = findWrapPos( text, width, 0);\n+      if ( pos == -1 )\n+      {\n+         sb.append(rtrim(text));\n+         return sb;\n+      }\n+      else\n+      {\n+         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+      }\n+\n+      //all following lines must be padded with nextLineTabStop space characters\n+      final String padding = createPadding(nextLineTabStop);\n+\n+      while ( true )\n+      {\n+         text = padding + text.substring(pos).trim();\n+         pos = findWrapPos( text, width, nextLineTabStop );\n+         if ( pos == -1 )\n+         {\n+            sb.append(text);\n+            return sb;\n+         }\n+\n+         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+      }\n+\n+   }\n+\n+   /**\n+    * Finds the next text wrap position after <code>startPos</code> for the text\n+    * in <code>sb</code> with the column width <code>width</code>.\n+    * The wrap point is the last postion before startPos+width having a whitespace\n+    * character (space, \\n, \\r).\n+    *\n+    * @param sb text to be analyzed\n+    * @param width width of the wrapped text\n+    * @param startPos position from which to start the lookup whitespace character\n+    * @return postion on which the text must be wrapped or -1 if the wrap position is at the end\n+    *         of the text\n+    */\n+   protected int findWrapPos( String text, int width, int startPos )\n+   {\n+      int pos = -1;\n+      // the line ends before the max wrap pos or a new line char found\n+      if ( ((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)  ||\n+           ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width) )\n+      {\n+         return pos;\n+      }\n+      else if ( (startPos + width) >= text.length() )\n+      {\n+         return -1;\n+      }\n+\n+      //look for the last whitespace character before startPos+width\n+      pos = startPos + width;\n+      char c;\n+      while ( pos >= startPos && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n+      {\n+         --pos;\n+      }\n+      //if we found it - just return\n+      if ( pos > startPos )\n+      {\n+         return pos;\n+      }\n+      else\n+      {\n+         //must look for the first whitespace chearacter after startPos + width\n+         pos = startPos + width;\n+         while ( pos <= text.length() && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n+         {\n+            ++pos;\n+         }\n+         return pos == text.length() ? -1 : pos;\n+      }\n+   }\n+\n+   protected String createPadding(int len)\n+   {\n+      StringBuffer sb = new StringBuffer(len);\n+      for ( int i = 0; i < len; ++i )\n+      {\n+         sb.append(' ');\n+      }\n+      return sb.toString();\n+   }\n+\n+   protected String rtrim( String s )\n+   {\n+      if ( s == null || s.length() == 0 )\n+      {\n+         return s;\n+      }\n+\n+      int pos = s.length();\n+      while ( pos >= 0 && Character.isWhitespace(s.charAt(pos-1)) )\n+      {\n+         --pos;\n+      }\n+      return s.substring(0, pos);\n+   }\n+\n+   // ------------------------------------------------------- Package protected\n+   \n+   // ----------------------------------------------------------------- Private\n+   \n+   // ----------------------------------------------------------- Inner classes\n+\n+   private static class StringBufferComparator\n+   implements Comparator\n+   {\n+      public int compare( Object o1, Object o2 )\n+      {\n+         return ((StringBuffer) o1).toString().compareTo(((StringBuffer) o2).toString());\n+      }\n+   }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/MissingArgumentException.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/MissingArgumentException.java,v 1.2 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** <p>Exception thrown when an option requiring an argument\n+ * is not provided with an argument.</p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @version $Revision: 1.2 $\n+ */\n+public class MissingArgumentException extends ParseException {\n+    \n+    /** Construct a new Exception with a message\n+     *\n+     * @param msg Explanation of the exception\n+     */\n+    public MissingArgumentException(String msg) {\n+        super(msg);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/MissingOptionException.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/MissingOptionException.java,v 1.2 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** <p>Exception thrown when an option requiring an argument\n+ * is not provided with an argument.</p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @version $Revision: 1.2 $\n+ */\n+public class MissingOptionException extends ParseException {\n+    \n+    /** Construct a new Exception with a message\n+     *\n+     * @param msg Explanation of the exception\n+     */\n+    public MissingOptionException(String msg) {\n+        super(msg);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Option.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/Option.java,v 1.6 2002/06/06 22:50:14 bayard Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/06/06 22:50:14 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: Option.java,v 1.6 2002/06/06 22:50:14 bayard Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.ArrayList;\n+\n+/** <p>Describes a single command-line option.  It maintains\n+ * information regarding the short-name of the option, the long-name,\n+ * if any exists, a flag indicating if an argument is required for\n+ * this option, and a self-documenting description of the option.</p>\n+ *\n+ * <p>An Option is not created independantly, but is create through\n+ * an instance of {@link Options}.<p>\n+ *\n+ * @see org.apache.commons.cli.Options\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision: 1.6 $\n+ */\n+\n+public class Option {\n+    \n+    /** opt the single character representation of the option */\n+    private Character  opt          = null;\n+\n+    /** longOpt is the long representation of the option */\n+    private String     longOpt      = null;\n+\n+    /** hasArg specifies whether this option has an associated argument */\n+    private boolean    hasArg       = false;\n+\n+    /** description of the option */\n+    private String     description  = null;\n+\n+    /** required specifies whether this option is required to be present */\n+    private boolean    required     = false;\n+\n+    /** multipleArgs specifies whether this option has multiple argument values */\n+    private boolean    multipleArgs = false;   \n+\n+    /** the type of this Option */\n+    private Object     type         = null;   \n+\n+    /** ?? **/\n+    private ArrayList  values       = new ArrayList();\n+    \n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt character representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     */\n+    public Option(char opt, boolean hasArg, String description) {\n+        this(opt, null, hasArg, description, false, false);\n+    }\n+    \n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt character representation of the option\n+     * @param longOpt the long representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     */\n+    public Option(char opt, String longOpt, boolean hasArg, String description) {\n+        this(opt, longOpt, hasArg, description, false, false );\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt character representation of the option\n+     * @param longOpt the long representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     * @param required specifies whether the option is required or not\n+     */\n+    public Option(char opt, String longOpt, boolean hasArg, String description,\n+                  boolean required ) {\n+        this(opt, longOpt, hasArg, description, required, false );\n+    }\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt character representation of the option\n+     * @param longOpt the long representation of the option\n+     * @param hasArg specifies whether the Option takes an argument or not\n+     * @param description describes the function of the option\n+     * @param required specifies whether the option is required or not\n+     * @param multipleArgs specifies whether the option has multiple argument \n+     * values\n+     */\n+    public Option(char opt, String longOpt, boolean hasArg, String description, \n+                  boolean required, boolean multipleArgs ) {\n+        this(opt, longOpt, hasArg, description, required, multipleArgs, null );\n+    }\n+    public Option(char opt, String longOpt, boolean hasArg, String description, \n+                  boolean required, boolean multipleArgs, Object type ) {\n+        this.opt          = new Character( opt );\n+        this.longOpt      = longOpt;\n+        this.hasArg       = hasArg;\n+        this.description  = description;\n+        this.required     = required;\n+        this.multipleArgs = multipleArgs;\n+        this.type         = type;\n+    }\n+    \n+    /** <p>Retrieve the single-character name of this Option</p>\n+     *\n+     * <p>It is this character which can be used with\n+     * {@link CommandLine#hasOption(char opt)} and\n+     * {@link CommandLine#getOptionValue(char opt)} to check\n+     * for existence and argument.<p>\n+     *\n+     * @return Single character name of this option\n+     */\n+    public char getOpt() {\n+        return this.opt.charValue();\n+    }\n+\n+    public Object getType() {\n+        return this.type;\n+    }\n+    \n+    /** <p>Retrieve the long name of this Option</p>\n+     *\n+     * @return Long name of this option, or null, if there is no long name\n+     */\n+    public String getLongOpt() {\n+        return this.longOpt;\n+    }\n+    \n+    /** <p>Query to see if this Option has a long name</p>\n+     *\n+     * @return boolean flag indicating existence of a long name\n+     */\n+    public boolean hasLongOpt() {\n+        return ( this.longOpt != null );\n+    }\n+    \n+    /** <p>Query to see if this Option requires an argument</p>\n+     *\n+     * @return boolean flag indicating if an argument is required\n+     */\n+    public boolean hasArg() {\n+        return this.hasArg;\n+    }\n+    \n+    /** <p>Retrieve the self-documenting description of this Option</p>\n+     *\n+     * @return The string description of this option\n+     */\n+    public String getDescription() {\n+        return this.description;\n+    }\n+\n+     /** <p>Query to see if this Option requires an argument</p>\n+      *\n+      * @return boolean flag indicating if an argument is required\n+      */\n+     public boolean isRequired() {\n+         return this.required;\n+     }\n+\n+     /** <p>Query to see if this Option can take multiple values</p>\n+      *\n+      * @return boolean flag indicating if multiple values are allowed\n+      */\n+     public boolean hasMultipleArgs() {\n+         return this.multipleArgs;\n+     }\n+\n+    /** <p>Dump state, suitable for debugging.</p>\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n+        \n+        buf.append( this.opt );\n+        \n+        if ( this.longOpt != null ) {\n+            buf.append(\" \")\n+            .append(this.longOpt);\n+        }\n+        \n+        buf.append(\" \");\n+        \n+        if ( hasArg ) {\n+            buf.append( \"+ARG\" );\n+        }\n+        \n+        buf.append(\" :: \")\n+        .append( this.description );\n+        \n+        if ( this.type != null ) {\n+            buf.append(\" :: \")\n+            .append( this.type );\n+        }\n+\n+        buf.append(\" ]\");\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Adds the specified value to this Option\n+     * \n+     * @param value is a/the value of this Option\n+     */\n+    public void addValue( String value ) {\n+        this.values.add( value );\n+    }\n+\n+    /**\n+     * @return the value/first value of this Option or null if there are no\n+     * values\n+     */\n+    public String getValue() {\n+        return this.values.size()==0 ? null : (String)this.values.get( 0 );\n+    }\n+\n+    /**\n+     * @return the values of this Option or null if there are no\n+     * values\n+     */\n+    public String[] getValues() {\n+        return this.values.size()==0 ? null : (String[])this.values.toArray(new String[]{});\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/OptionGroup.java,v 1.2 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * A group of mutually exclusive options.\n+ * @author John Keyes ( john at integralsource.com )\n+ * @version $Revision: 1.2 $\n+ */\n+public class OptionGroup {\n+    /** hold the options */\n+    private HashMap optionMap = new HashMap();\n+\n+    /** the name of the selected option */\n+    private Option selected;\n+\n+    /**\n+     * add <code>opt</code> to this group\n+     *\n+     * @param opt the option to add to this group\n+     * @return this option group with opt added\n+     */\n+    public OptionGroup addOption(Option opt) {\n+        // key   - option name\n+        // value - the option\n+        optionMap.put( \"-\" + opt.getOpt(), opt );\n+        return this;\n+    }\n+\n+    /**\n+     * @return the names of the options in this group as a \n+     * <code>Collection</code>\n+     */\n+    private Collection getNames() {\n+        // the key set is the collection of names\n+        return optionMap.keySet();\n+    }\n+\n+    /**\n+     * @return the options in this group as a <code>Collection</code>\n+     */\n+    public Collection getOptions() {\n+        // the values are the collection of options\n+        return optionMap.values();\n+    }\n+\n+    /**\n+     * set the selected option of this group to <code>name</code>.\n+     * @param opt the option that is selected\n+     * @throws AlreadySelectedException if an option from this group has \n+     * already been selected.\n+     */\n+    public void setSelected(Option opt) throws AlreadySelectedException {\n+        // if no option has already been selected or the \n+        // same option is being reselected then set the\n+        // selected member variable\n+        if ( this.selected == null || this.selected.equals( opt ) ) {\n+            this.selected = opt;\n+        }\n+        else {\n+            throw new AlreadySelectedException( \"an option from this group has \" + \n+                                                \"already been selected: '\" + \n+                                                selected + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * @return the selected option name\n+     */\n+    public Option getSelected() {\n+        return selected;\n+    }\n+\n+    /**\n+     * @return the usage string for this option group\n+     */\n+    /*\n+    public String usageString()\n+    {\n+        StringBuffer buff = new StringBuffer();\n+\n+        buff.append( \"<\\n\");\n+\n+        Iterator oiter = getOptions().iterator();\n+\n+        while( oiter.hasNext() )\n+        {\n+            Option option = (Option)oiter.next();\n+            Collection names = option.getNames();\n+\n+            Iterator iter = names.iterator();\n+\n+            while( iter.hasNext() )\n+            {\n+                buff.append( option.getPrefix() );\n+                buff.append( iter.next() );\n+                if( iter.hasNext() )\n+                {\n+                    buff.append( \" | \" );\n+                }\n+            }\n+            buff.append( \" \" );\n+            buff.append( option.getDescription( ) );\n+            if ( oiter.hasNext() )\n+            {\n+                buff.append( \"\\n  or\\n\" );\n+            }\n+        }\n+        buff.append( \"\\n>\");\n+        buff.append( \"\\n\" );\n+        return buff.toString();\n+    }\n+    */\n+\n+    /**\n+     * <p>Returns the stringified version of this OptionGroup.</p>\n+     * @return the stringified representation of this group\n+     */\n+    public String toString() {\n+        StringBuffer buff = new StringBuffer();\n+\n+        Iterator iter = getOptions().iterator();\n+\n+        buff.append( \"[\" );\n+        while( iter.hasNext() ) {\n+            Option option = (Option)iter.next();\n+\n+            buff.append( \"-\" );\n+            buff.append( option.getOpt() );\n+            buff.append( \" \" );\n+            buff.append( option.getDescription( ) );\n+\n+            if( iter.hasNext() ) {\n+                buff.append( \", \" );\n+            }\n+        }\n+        buff.append( \"]\" );\n+\n+        return buff.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/Options.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/Options.java,v 1.5 2002/06/06 22:32:37 bayard Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/06/06 22:32:37 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.Iterator;\n+import java.util.Collections;\n+\n+/** <p>Main entry-point into the <code>werken.opt</code> library.</p>\n+ *\n+ * <p>Options represents a collection of {@link Option} objects, which\n+ * describe the possible options for a command-line.<p>\n+ *\n+ * <p>It may flexibly parse long and short options, with or without\n+ * values.  Additionally, it may parse only a portion of a commandline,\n+ * allowing for flexible multi-stage parsing.<p>\n+ *\n+ * @see org.apache.commons.cli.CommandLine\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @version $Revision: 1.5 $\n+ */\n+public class Options {\n+    \n+    /** the list of options */\n+    private List options      = new ArrayList();\n+\n+    /** a map of the options with the character key */\n+    private Map  shortOpts    = new HashMap();\n+\n+    /** a map of the options with the long key */\n+    private Map  longOpts     = new HashMap();\n+\n+    /** a map of the required options */\n+    private Map  requiredOpts = new HashMap();\n+    \n+    /** a map of the option groups */\n+    private Map optionGroups  = new HashMap();\n+\n+    /** <p>Construct a new Options descriptor</p>\n+     */\n+    public Options() {        \n+    }\n+\n+    /**\n+     * <p>Add the specified option group.</p>\n+     *\n+     * @param group the OptionGroup that is to be added\n+     * @return the resulting Options instance\n+     */\n+    public Options addOptionGroup( OptionGroup group ) {\n+        Iterator options = group.getOptions().iterator();\n+\n+        while( options.hasNext() ) {\n+            Option option = (Option)options.next();\n+            addOption( option );\n+            optionGroups.put( option, group );\n+        }\n+\n+        return this;\n+    }\n+\n+    /** <p>Add an option that only contains a short-name</p>\n+     * <p>It may be specified as requiring an argument.</p>\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(char opt, boolean hasArg, String description) {\n+        addOption( opt, null, hasArg, description, false );\n+        return this;\n+    }\n+    \n+    /** <p>Add an option that contains a short-name and a long-name</p>\n+     * <p>It may be specified as requiring an argument.</p>\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param longOpt Long multi-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(char opt, String longOpt, boolean hasArg, String description) {\n+        addOption( opt, longOpt, hasArg, description, false );        \n+        return this;\n+    }\n+\n+    /** <p>Add an option that contains a short-name and a long-name</p>\n+     * <p>It may be specified as requiring an argument.</p>\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param longOpt Long multi-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @param required specifies if this option is required\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(char opt, String longOpt, boolean hasArg, String description,\n+                             boolean required) {\n+        addOption( new Option(opt, longOpt, hasArg, description, required) );        \n+        return this;\n+    }\n+\n+    /** <p>Add an option that contains a short-name and a long-name</p>\n+     * <p>It may be specified as requiring an argument.</p>\n+     *\n+     * @param opt Short single-character name of the option.\n+     * @param longOpt Long multi-character name of the option.\n+     * @param hasArg flag signally if an argument is required after this option\n+     * @param description Self-documenting description\n+     * @param required specifies if this option is required\n+     * @param multipleArgs specifies if this option can accept multiple argument values\n+     * @return the resulting Options instance\n+     */\n+    public Options addOption(char opt, String longOpt, boolean hasArg, String description,\n+                             boolean required, boolean multipleArgs) {\n+        addOption( new Option(opt, longOpt, hasArg, description, required, multipleArgs) );        \n+        return this;\n+    }\n+\n+    public Options addOption(char opt, String longOpt, boolean hasArg, String description,\n+                             boolean required, boolean multipleArgs, Object type) {\n+        addOption( new Option(opt, longOpt, hasArg, description, required, multipleArgs, type) );        \n+        return this;\n+    }\n+\n+    /** <p>Parse the given list of arguments against this descriptor<p>\n+     *\n+     * @param args Args to parse\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(String[] args) \n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        return parse( args, 0, args.length, false);\n+    }\n+    \n+    /** <p>Parse the given list of arguments against this descriptor</p>\n+     *\n+     * <p>This method will cease parsing upon the first non-option token,\n+     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n+     *\n+     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n+     *\n+     * <p><code>\n+     * <pre>\n+     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n+     * </pre>\n+     * </code></p>\n+     *\n+     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n+     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n+     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n+     * another different <code>Options</code> instance.<p>\n+     *\n+     * @param args Args to parse\n+     * @param stopAtNonOption stop parsing at the first non-option token\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(String[] args, boolean stopAtNonOption) \n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        return parse( args, 0, args.length, stopAtNonOption);\n+    }\n+    \n+    /** <p>Parse the given list of arguments against this descriptor</p>\n+     *\n+     * <p>This method allows parsing from <code>formIndex</code> inclusive\n+     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n+     * to allow parsing a specific portion of a command-line.<p>\n+     *\n+     * @param args Args to parse\n+     * @param fromIndex index of args to start parsing\n+     * @param toIndex index of args to stop parsing\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(String[] args, int fromIndex, int toIndex) \n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        return parse( args, fromIndex, toIndex, false );\n+    }\n+    \n+    /** <p>Parse the given list of arguments against this descriptor</p>\n+     *\n+     * <p>This method will cease parsing upon the first non-option token,\n+     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n+     *\n+     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n+     *\n+     * <p><code>\n+     * <pre>\n+     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n+     * </pre>\n+     * </code></p>\n+     *\n+     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n+     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n+     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n+     * another different <code>Options</code> instance.<p>\n+     *\n+     * <p>This method also allows parsing from <code>formIndex</code> inclusive\n+     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n+     * to allow parsing a specific portion of a command-line.<p>\n+     *\n+     * @param args Args to parse\n+     * @param fromIndex index of args to start parsing\n+     * @param toIndex index of args to stop parsing\n+     * @param stopAtNonOption stop parsing at the first non-option token\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(String[] args, int fromIndex, int toIndex, boolean stopAtNonOption)\n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        List argList = java.util.Arrays.asList( args );\n+        \n+        return parse( argList, stopAtNonOption);\n+    }\n+    \n+    /** <p>Parse the given list of arguments against this descriptor</p>\n+     *\n+     * @param args Args to parse\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(List args)\n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        return parse( args, false );\n+    }\n+    \n+    /** <p>Parse the given list of arguments against this descriptor</p>\n+     *\n+     * <p>This method will cease parsing upon the first non-option token,\n+     * storing the rest of the tokens for access through {@link CommandLine#getArgs()}.</p>\n+     *\n+     * <p>This is useful for parsing a command-line in pieces, such as:</p>\n+     *\n+     * <p><code>\n+     * <pre>\n+     * myApp -s &lt;server&gt; -p &lt;port&gt; command -p &lt;printer&gt; -s &lt;style&gt;\n+     * </pre>\n+     * </code></p>\n+     *\n+     * <p>Here, it'll parse up-to, but not including <code>command</code>. The\n+     * tokens <code>command -p &lt;printer&gt; -s &lt;style&gt;</code> are available\n+     * through {@link CommandLine#getArgs()}, which may subsequently be parsed by\n+     * another different <code>Options</code> instance.<p>\n+     *\n+     * <p>This method also allows parsing from <code>formIndex</code> inclusive\n+     * to <code>toIndex</code> exclusive, of the <code>args</code> parameter,\n+     * to allow parsing a specific portion of a command-line.<p>\n+     *\n+     * @param inArgs Arguments to parse\n+     * @param stopAtNonOption stop parsing at the first non-option token\n+     *\n+     * @return {@link CommandLine} containing information related to parse state\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws MissingOptionException if a required option is not present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    public CommandLine parse(List inArgs, boolean stopAtNonOption) \n+    throws MissingArgumentException, UnrecognizedOptionException, \n+        MissingOptionException, AlreadySelectedException {\n+        CommandLine cl = new CommandLine();\n+        \n+        List args = burst( inArgs, stopAtNonOption );\n+        \n+        ListIterator argIter = args.listIterator();\n+        String   eachArg = null;\n+        Option   eachOpt = null;\n+        boolean  eatTheRest = false;\n+\n+        while ( argIter.hasNext() ) {\n+\n+            eachArg = (String) argIter.next();\n+\n+            if ( eachArg.equals(\"--\") ) {\n+                // signalled end-of-opts.  Eat the rest\n+                \n+                eatTheRest = true;\n+            }\n+            else if ( eachArg.startsWith(\"--\") ) {\n+                eachOpt = (Option) longOpts.get( eachArg );\n+                processOption( eachArg, eachOpt, argIter, cl );\n+            }\n+            else if ( eachArg.equals(\"-\") ) {\n+                // Just-another-argument\n+                \n+                if ( stopAtNonOption ) {\n+                    eatTheRest = true;\n+                }\n+                else {\n+                    cl.addArg( eachArg );\n+                }\n+            }\n+            else if ( eachArg.startsWith(\"-\") ) {\n+                eachOpt = (Option) shortOpts.get( eachArg );\n+                processOption( eachArg, eachOpt, argIter, cl );\n+            }                \n+            else {\n+                cl.addArg( eachArg );\n+                if ( stopAtNonOption ) {\n+                    eatTheRest = true;\n+                }\n+            }\n+            \n+            if ( eatTheRest ) {\n+                while ( argIter.hasNext() ) {\n+                    eachArg = (String) argIter.next();\n+                    cl.addArg( eachArg );\n+                }\n+            }\n+        }\n+\n+        // this will throw a MissingOptionException\n+        checkRequiredOptions();\n+\n+        return cl;\n+    }\n+\n+    /**\n+     * @throws MissingOptionException if all of the required options are\n+     * not present.\n+     */\n+    private void checkRequiredOptions() throws MissingOptionException {\n+        if( requiredOpts.size() > 0 ) {\n+            Set optKeys = requiredOpts.keySet();\n+\n+            Iterator iter = optKeys.iterator();\n+\n+            StringBuffer buff = new StringBuffer();\n+\n+            while( iter.hasNext() ) {\n+                Option missing = (Option)requiredOpts.get( iter.next() );\n+                buff.append( \"-\" );\n+                buff.append( missing.getOpt() );\n+                buff.append( \" \" );\n+                buff.append( missing.getDescription() );\n+            }\n+\n+            throw new MissingOptionException( buff.toString() );\n+        }\n+    }\n+\n+    /**\n+     * <p>processOption rakes the current option and checks if it is\n+     * an unrecognised option, whether the argument value is missing or\n+     * whether the option has already been selected.</p>\n+     *\n+     * @param eachArg the current option read from command line\n+     * @param option the current option corresponding to eachArg\n+     * @param argIter the argument iterator\n+     * @param cl the current command line\n+     *\n+     * @throws MissingArgumentException if an argument value for an option is not present\n+     * @throws UnrecognizedOptionException if an unrecognised option is present\n+     * @throws AlreadySelectedException if the same option appears more than once\n+     */\n+    private void processOption( String eachArg, Option option, ListIterator argIter, \n+                                CommandLine cl)\n+    throws UnrecognizedOptionException, AlreadySelectedException, \n+        MissingArgumentException {\n+\n+        if ( option == null ) {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" + eachArg);\n+        }\n+        else {\n+\n+            if ( optionGroups.get( option ) != null ) {\n+                ( (OptionGroup)( optionGroups.get( option ) ) ).setSelected( option );\n+            }\n+\n+            // if required remove from list\n+            if ( option.isRequired() ) {\n+                requiredOpts.remove( \"-\" + option.getOpt() );\n+            }\n+\n+            if ( option.hasArg() ) {\n+                if ( argIter.hasNext() ) {\n+                    eachArg = (String) argIter.next();\n+                    option.addValue( eachArg );\n+                    \n+                    if( option.hasMultipleArgs() ) {\n+                        while( argIter.hasNext() ) {\n+                            eachArg = (String)argIter.next();\n+                            if( eachArg.startsWith(\"-\") ) {\n+                                argIter.previous();\n+                                cl.setOpt( option );\n+                                break;\n+                            }\n+                            else {\n+                                option.addValue( eachArg );\n+                            }\n+                        }\n+                    }\n+                    else {\n+                        cl.setOpt( option );\n+                        return;\n+                    }\n+                    if( !argIter.hasNext() ) {\n+                        cl.setOpt( option );\n+                    }\n+                }\n+                else {\n+                    throw new MissingArgumentException( eachArg + \" requires an argument.\");\n+                }\n+\n+            }\n+            else {\n+                //option.addValue( null );\n+                cl.setOpt( option );\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Processes the argument list according to POSIX command line\n+     * processing rules.</p>\n+     *\n+     * @param inArgs the argument list\n+     * @param stopAtNonOption stop processing when the first non option\n+     * is encountered.\n+     * @return the processed list of arguments.\n+     */\n+    private List burst(List inArgs, boolean stopAtNonOption) {\n+        List args = new LinkedList();\n+        \n+        Iterator argIter = inArgs.iterator();\n+        String   eachArg = null;\n+        \n+        boolean eatTheRest = false;\n+        \n+        while ( argIter.hasNext() ) {\n+            eachArg = (String) argIter.next();\n+            \n+            if ( eachArg.equals(\"--\") ) {\n+                // Look for -- to indicate end-of-options, and\n+                // just stuff it, along with everything past it\n+                // into the returned list.\n+                \n+                args.add( eachArg );\n+                eatTheRest = true;\n+            }\n+            else if ( eachArg.startsWith(\"--\") ) {\n+                // It's a long-option, so doesn't need any\n+                // bursting applied to it.\n+                \n+                args.add( eachArg );\n+            }\n+            else if ( eachArg.startsWith(\"-\") ) {\n+                // It might be a short arg needing\n+                // some bursting\n+                \n+                if ( eachArg.length() == 1) {\n+                    // It's not really an option, so\n+                    // just drop it on the list\n+                    \n+                    if ( stopAtNonOption ) {\n+                        eatTheRest = true;\n+                    }\n+                    else {\n+                        args.add( eachArg );\n+                    }\n+                }\n+                else if ( eachArg.length() == 2 ) {\n+                    // No bursting required\n+                    \n+                    args.add( eachArg );\n+                }\n+                else {\n+                    // Needs bursting.  Figure out\n+                    // if we have multiple options,\n+                    // or maybe an option plus an arg,\n+                    // or some combination thereof.\n+                    \n+                    for ( int i = 1 ; i < eachArg.length() ; ++i ) {\n+                        String optStr = \"-\" + eachArg.charAt(i);\n+                        Option opt    = (Option) shortOpts.get( optStr );\n+                        \n+                        if ( (opt != null) && (opt.hasArg()) ) {\n+                            // If the current option has an argument,\n+                            // then consider the rest of the eachArg\n+                            // to be that argument.\n+                            \n+                            args.add( optStr );\n+                            \n+                            if ( (i+1) < eachArg.length() ) {\n+                                String optArg = eachArg.substring(i+1);\n+                                args.add( optArg );\n+                            }                            \n+                            break;\n+                        }\n+                        else {\n+                            // No argument, so prepend the single dash,\n+                            // and then drop it into the arglist.\n+                            \n+                            args.add( optStr );\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                // It's just a normal non-option arg,\n+                // so dump it into the list of returned\n+                // values.\n+                \n+                args.add( eachArg );\n+                \n+                if ( stopAtNonOption ) {\n+                    eatTheRest = true;\n+                }\n+            }\n+            \n+            if ( eatTheRest ) {\n+                while ( argIter.hasNext() ) {\n+                    args.add( argIter.next() );\n+                }\n+            }\n+        }\n+        \n+        return args;\n+    }\n+    \n+    /**\n+     * <p>Adds the option to the necessary member lists</p>\n+     *\n+     * @param opt the option that is to be added \n+     */\n+    private void addOption(Option opt)  {\n+        String shortOptStr = \"-\" + opt.getOpt();\n+        \n+        if ( opt.hasLongOpt() ) {\n+            longOpts.put( \"--\" + opt.getLongOpt(), opt );\n+        }\n+        \n+        if ( opt.isRequired() ) {\n+            requiredOpts.put( \"-\" + opt.getOpt(), opt );\n+        }\n+\n+        shortOpts.put( \"-\" + opt.getOpt(), opt );\n+        \n+        options.add( opt );\n+    }\n+    \n+    /** <p>Retrieve a read-only list of options in this set</p>\n+     *\n+     * @return read-only List of {@link Option} objects in this descriptor\n+     */\n+    public List getOptions() {\n+        return Collections.unmodifiableList(options);\n+    }\n+    \n+    /** <p>Retrieve the named {@link Option}<p>\n+     *\n+     * @param opt short single-character name of the {@link Option}\n+     * @return the option represented by opt\n+     */\n+    public Option getOption(char opt) {\n+        return (Option) shortOpts.get( \"-\" + opt );\n+    }\n+    \n+    /** <p>Retrieve the named {@link Option}<p>\n+     *\n+     * @param longOpt long name of the {@link Option}\n+     * @return the option represented by longOpt\n+     */\n+    public Option getOption(String longOpt) {\n+        return (Option) longOpts.get( longOpt );\n+    }\n+    \n+    /** <p>Dump state, suitable for debugging.</p>\n+     *\n+     * @return Stringified form of this object\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        \n+        buf.append(\"[ Options: [ short \");\n+        buf.append( shortOpts.toString() );\n+        buf.append( \" ] [ long \" );\n+        buf.append( longOpts );\n+        buf.append( \" ]\");\n+        \n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/ParseException.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/ParseException.java,v 1.2 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** <p>Base for Exceptions thrown during parsing of a command-line<p>\n+ *\n+ * @author bob mcwhirter (bob @ werken.com)\n+ * @version $Revision: 1.2 $\n+ */\n+public class ParseException extends Exception \n+{\n+    \n+    /** Construct a new Exception with a message\n+     *\n+     * @param msg Explanation of the exception\n+     */\n+    public ParseException(String msg) {\n+        super(msg);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/PatternOptionBuilder.java,v 1.2 2002/06/06 22:49:36 bayard Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 22:49:36 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** \n+ * Allows Options to be created from a single String.\n+ *\n+ *\n+ * @author Henri Yandell (bayard @ generationjava.com)\n+ * @version $Revision: 1.2 $\n+ */\n+public class PatternOptionBuilder {\n+\n+    /// TODO: These need to break out to OptionType and also to be pluggable.\n+\n+    static public final Class STRING_VALUE        = java.lang.String.class;\n+    static public final Class OBJECT_VALUE        = java.lang.Object.class;\n+    static public final Class NUMBER_VALUE        = java.lang.Number.class;\n+    static public final Class DATE_VALUE          = java.util.Date.class;\n+    static public final Class CLASS_VALUE         = java.lang.Class.class;\n+\n+/// can we do this one?? \n+// is meant to check that the file exists, else it errors.\n+// ie) it's for reading not writing.\n+    static public final Class EXISTING_FILE_VALUE = java.io.FileInputStream.class;\n+    static public final Class FILE_VALUE          = java.io.File.class;\n+    static public final Class FILES_VALUE         = java.io.File[].class;\n+    static public final Class URL_VALUE           = java.net.URL.class;\n+\n+    static public Object getValueClass(char ch) {\n+        if (ch == '@') {\n+            return PatternOptionBuilder.OBJECT_VALUE;\n+        } else if (ch == ':') {\n+            return PatternOptionBuilder.STRING_VALUE;\n+        } else if (ch == '%') {\n+            return PatternOptionBuilder.NUMBER_VALUE;\n+        } else if (ch == '+') {\n+            return PatternOptionBuilder.CLASS_VALUE;\n+        } else if (ch == '#') {\n+            return PatternOptionBuilder.DATE_VALUE;\n+        } else if (ch == '<') {\n+            return PatternOptionBuilder.EXISTING_FILE_VALUE;\n+        } else if (ch == '>') {\n+            return PatternOptionBuilder.FILE_VALUE;\n+        } else if (ch == '*') {\n+            return PatternOptionBuilder.FILES_VALUE;\n+        } else if (ch == '/') {\n+            return PatternOptionBuilder.URL_VALUE;\n+        }\n+        return null;\n+    }\n+ \n+    static public boolean isValueCode(char ch) {\n+        if( (ch != '@') &&\n+            (ch != ':') &&\n+            (ch != '%') &&\n+            (ch != '+') &&\n+            (ch != '#') &&\n+            (ch != '<') &&\n+            (ch != '>') &&\n+            (ch != '*') &&\n+            (ch != '/')\n+          )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }       \n+ \n+    static public Options parsePattern(String pattern) {\n+        int sz = pattern.length();\n+\n+        char opt = ' ';\n+        char ch = ' ';\n+        boolean required = false;\n+        Object type = null;\n+\n+        Options options = new Options();\n+\n+        for(int i=0; i<sz; i++) {\n+            ch = pattern.charAt(i);\n+\n+            // a value code comes after an option and specifies \n+            // details about it\n+            if(!isValueCode(ch)) {\n+                if(opt != ' ') {\n+                    // we have a previous one to deal with\n+                    options.addOption(opt, null, (type != null), \"\", required, false, type);\n+                    required = false;\n+                    type = null;\n+                    opt = ' ';\n+                }\n+                opt = ch;\n+            } else\n+            if(ch == '!') {\n+                required = true;\n+            } else {\n+                type = getValueClass(ch);\n+            }\n+        }\n+\n+        if(opt != ' ') {\n+            // we have a final one to deal with\n+            options.addOption(opt, null, (type != null), \"\", required, false, type);\n+        }\n+\n+        return options;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/TypeHandler.java,v 1.2 2002/06/06 22:49:36 bayard Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 22:49:36 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import java.io.File;\n+import java.net.URL;\n+import java.net.MalformedURLException;\n+import java.util.Date;\n+\n+import org.apache.commons.lang.Numbers;\n+\n+/**\n+  * This is a temporary implementation. TypeHandler will handle the \n+  * pluggableness of OptionTypes and it will direct all of these types \n+  * of conversion functionalities to ConvertUtils component in Commons \n+  * alreayd. BeanUtils I think.\n+  *\n+  * @author Henri Yandell (bayard @ generationjava.com)\n+  * @version $Revision: 1.2 $\n+  */    \n+public class TypeHandler {\n+\n+    static public Object createValue(String str, Object obj) {\n+        return createValue(str, (Class)obj);\n+    }\n+    static public Object createValue(String str, Class clazz) {\n+        if( PatternOptionBuilder.STRING_VALUE == clazz) {\n+            return str;\n+        } else\n+        if( PatternOptionBuilder.OBJECT_VALUE == clazz) {\n+            return createObject(str);\n+        } else\n+        if( PatternOptionBuilder.NUMBER_VALUE == clazz) {\n+            return createNumber(str);\n+        } else\n+        if( PatternOptionBuilder.DATE_VALUE   == clazz) {\n+            return createDate(str);\n+        } else\n+        if( PatternOptionBuilder.CLASS_VALUE  == clazz) {\n+            return createClass(str);\n+        } else\n+        if( PatternOptionBuilder.FILE_VALUE   == clazz) {\n+            return createFile(str);\n+        } else\n+        if( PatternOptionBuilder.EXISTING_FILE_VALUE   == clazz) {\n+            return createFile(str);\n+        } else\n+        if( PatternOptionBuilder.FILES_VALUE  == clazz) {\n+            return createFiles(str);\n+        } else\n+        if( PatternOptionBuilder.URL_VALUE    == clazz) {\n+            return createURL(str);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+      * Create an Object from the classname and empty constructor.\n+      * Returns null if it couldn't create the Object.\n+      */\n+    static public Object createObject(String str) {\n+        Class cl = null;\n+        try {\n+            cl = Class.forName(str);\n+        } catch (ClassNotFoundException cnfe) {\n+            System.err.println(\"Unable to find: \"+str);\n+            return null;\n+        }\n+\n+        Object instance = null;\n+\n+        try {\n+            instance = cl.newInstance();\n+        } catch (InstantiationException cnfe) {\n+            System.err.println(\"InstantiationException; Unable to create: \"+str);\n+            return null;\n+        }\n+        catch (IllegalAccessException cnfe) {\n+            System.err.println(\"IllegalAccessException; Unable to create: \"+str);\n+            return null;\n+        }\n+\n+        return instance;\n+    }\n+\n+    /**\n+      * Create a number from a String.\n+      */\n+    static public Number createNumber(String str) {\n+        // Needs to be able to create\n+        try {\n+            // do searching for decimal point etc, but atm just make an Integer\n+            return Numbers.createNumber(str);\n+        } catch (NumberFormatException nfe) {\n+            System.err.println(nfe.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    static public Class createClass(String str) {\n+        try {\n+            return Class.forName(str);\n+        } catch (ClassNotFoundException cnfe) {\n+            System.err.println(\"Unable to find: \"+str);\n+            return null;\n+        }\n+    }\n+\n+    static public Date createDate(String str) {\n+        Date date = null;\n+        if(date == null) {\n+            System.err.println(\"Unable to parse: \"+str);\n+        }\n+        return date;\n+    }\n+\n+    static public URL createURL(String str) {\n+        try {\n+            return new URL(str);\n+        } catch (MalformedURLException mue) {\n+            System.err.println(\"Unable to parse: \"+str);\n+            return null;\n+        }\n+    }\n+\n+    static public File createFile(String str) {\n+        return new File(str);\n+    }\n+\n+    static public File[] createFiles(String str) {\n+// to implement/port:\n+//        return FileW.findFiles(str);\n+        return null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+/*\n+ * $Header: /home/cvs/jakarta-commons-sandbox/cli/src/java/org/apache/commons/cli/UnrecognizedOptionException.java,v 1.2 2002/06/06 09:37:26 jstrachan Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/06 09:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.cli;\n+\n+/** <p>Exception thrown during parsing signalling an unrecognized\n+ * option was seen.<p>\n+ *\n+ *\n+ * @author bob mcwhiter (bob @ werken.com)\n+ * @version $Revision: 1.2 $\n+ */\n+public class UnrecognizedOptionException extends ParseException {\n+    \n+    /** Construct a new Exception with a message\n+     *\n+     * @param msg Explanation of the exception\n+     */\n+    public UnrecognizedOptionException(String msg) {\n+        super(msg);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/BuildTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: BuildTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class BuildTest extends TestCase\n+{\n+\n+    public static Test suite() { \n+        return new TestSuite(BuildTest.class); \n+    }\n+\n+    public BuildTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public void setUp()\n+    {\n+\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testSimple()\n+    {\n+        Options opts = new Options();\n+        \n+        opts.addOption('a',\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('b',\n+                       true,\n+                       \"toggle -b\");\n+/*\n+        try\n+        {\n+            opts.addOption('a',\n+                           false,\n+                           \"toggle -a\");\n+            \n+            opts.addOption('b',\n+                           true,\n+                           \"toggle -b\");\n+        }\n+        catch (DuplicateOptionException e)\n+        {\n+            fail(e.toString());\n+        }\n+*/\n+    }\n+\n+    public void testDuplicateSimple()\n+    {\n+        Options opts = new Options();\n+        opts.addOption('a',\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('a',\n+                       true,\n+                       \"toggle -a*\");\n+        \n+        assertEquals( \"last one in wins\", \"toggle -a*\", opts.getOption('a').getDescription() );\n+/*\n+        try\n+        {\n+            opts.addOption('a',\n+                           false,\n+                           \"toggle -a\");\n+            \n+            opts.addOption('a',\n+                           true,\n+                           \"toggle -a\");\n+\n+            fail(\"Should've thrown DuplicateOptionException\");\n+        }\n+        catch (DuplicateOptionException e)\n+        {\n+        }\n+ */\n+    }\n+\n+    public void testLong()\n+    {\n+        Options opts = new Options();\n+        \n+        opts.addOption('a',\n+                       \"--a\",\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('b',\n+                       \"--b\",\n+                       true,\n+                       \"set -b\");\n+\n+/*        \n+        try\n+        {\n+            opts.addOption('a',\n+                           \"--a\",\n+                           false,\n+                           \"toggle -a\");\n+\n+            opts.addOption('b',\n+                           \"--b\",\n+                           true,\n+                           \"set -b\");\n+        }\n+        catch (DuplicateOptionException e)\n+        {\n+            fail(e.toString());\n+        }\n+*/\n+    }\n+\n+    public void testDuplicateLong()\n+    {\n+        Options opts = new Options();\n+        opts.addOption('a',\n+                       \"--a\",\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('a',\n+                       \"--a\",\n+                       false,\n+                       \"toggle -a*\");\n+        assertEquals( \"last one in wins\", \"toggle -a*\", opts.getOption('a').getDescription() );\n+/*\n+        try\n+        {\n+            opts.addOption('a',\n+                           \"--a\",\n+                           false,\n+                           \"toggle -a\");\n+\n+            opts.addOption('a',\n+                           \"--a\",\n+                           false,\n+                           \"toggle -a\");\n+\n+            fail(\"Should've thrown DuplicateOptionException\");\n+        }\n+        catch (DuplicateOptionException e)\n+        {\n+        }\n+*/\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/HelpFormatterExamples.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: HelpFormatterExamples.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ */\n+package org.apache.commons.cli;\n+\n+/** \n+ * A sample program shpwing the use of Options and the HelpFormatter class \n+ *\n+ * @author Slawek Zachcial\n+ **/\n+public class HelpFormatterExamples\n+{\n+   // --------------------------------------------------------------- Constants\n+\n+   // ------------------------------------------------------------------ Static\n+\n+   public static void main( String[] args )\n+   {\n+      System.out.println(\"\\n#\\n# 'man' example\\n#\");\n+      manExample();\n+/*\n+      System.out.println(\"\\n#\\n# 'bzip2' example\\n#\");\n+      bzip2Example();\n+      System.out.println(\"\\n#\\n# 'ls' example\\n#\");\n+      lsExample();\n+*/\n+   }\n+\n+   static void manExample()\n+   {\n+      String cmdLine =\n+         \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] \" +\n+         \"[-msystem] [-pstring] [-Llocale] [-eextension] [section] page ...\";\n+      Options opts =\n+         new Options().\n+         addOption('a', \"all\",            false, \"find all matching manual pages.\").\n+         addOption('d', \"debug\",          false, \"emit debugging messages.\").\n+         addOption('e', \"extension\",      false, \"limit search to extension type 'extension'.\").\n+         addOption('f', \"whatis\",         false, \"equivalent to whatis.\").\n+         addOption('k', \"apropos\",        false, \"equivalent to apropos.\").\n+         addOption('w', \"location\",       false, \"print physical location of man page(s).\").\n+         addOption('l', \"local-file\",     false, \"interpret 'page' argument(s) as local filename(s)\").\n+         addOption('u', \"update\",         false, \"force a cache consistency check.\").\n+         //FIXME - should generate -r,--prompt string\n+         addOption('r', \"prompt\",         true,  \"provide 'less' pager with prompt.\").\n+         addOption('c', \"catman\",         false, \"used by catman to reformat out of date cat pages.\").\n+         addOption('7', \"ascii\",          false, \"display ASCII translation or certain latin1 chars.\").\n+         addOption('t', \"troff\",          false, \"use troff format pages.\").\n+         //FIXME - should generate -T,--troff-device device\n+         addOption('T', \"troff-device\",   true,  \"use groff with selected device.\").\n+         addOption('Z', \"ditroff\",        false, \"use groff with selected device.\").\n+         addOption('D', \"default\",        false, \"reset all options to their default values.\").\n+         //FIXME - should generate -M,--manpath path\n+         addOption('M', \"manpath\",        true,  \"set search path for manual pages to 'path'.\").\n+         //FIXME - should generate -P,--pager pager\n+         addOption('P', \"pager\",          true,  \"use program 'pager' to display output.\").\n+         //FIXME - should generate -S,--sections list\n+         addOption('S', \"sections\",       true,  \"use colon separated section list.\").\n+         //FIXME - should generate -m,--systems system\n+         addOption('m', \"systems\",        true,  \"search for man pages from other unix system(s).\").\n+         //FIXME - should generate -L,--locale locale\n+         addOption('L', \"locale\",         true,  \"defaine the locale for this particular man search.\").\n+         //FIXME - should generate -p,--preprocessor string\n+         addOption('p', \"preprocessor\",   true,  \"string indicates which preprocessor to run.\\n\" +\n+                                                 \" e - [n]eqn  p - pic     t - tbl\\n\" +\n+                                                 \" g - grap    r - refer   v - vgrind\").\n+         addOption('V', \"version\",        false, \"show version.\").\n+         addOption('h', \"help\",           false, \"show this usage message.\");\n+\n+      HelpFormatter hf = new HelpFormatter();\n+      //hf.printHelp(cmdLine, opts);\n+      hf.printHelp(60, cmdLine, null, opts, null);\n+   }\n+\n+   static void bzip2Example()\n+   {\n+      System.out.println( \"Coming soon\" );\n+   }\n+\n+   static void lsExample()\n+   {\n+      System.out.println( \"Coming soon\" );\n+   }\n+\n+\n+   // -------------------------------------------------------------- Attributes\n+\n+   // ------------------------------------------------------------ Constructors\n+   \n+   // ------------------------------------------------------------------ Public\n+\n+   // --------------------------------------------------------------- Protected\n+\n+   // ------------------------------------------------------- Package protected   \n+   \n+   // ----------------------------------------------------------------- Private\n+   \n+   // ----------------------------------------------------------- Inner classes\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/OptionGroupTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: OptionGroupTest.java,v 1.1 2002/04/23 16:08:02 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision: 1.1 $\n+ */\n+public class OptionGroupTest extends TestCase\n+{\n+\n+    private Options _options = null;\n+\n+    public static Test suite() \n+    { \n+        return new TestSuite ( OptionGroupTest.class ); \n+    }\n+\n+    public OptionGroupTest( String name )\n+    {\n+        super( name );\n+    }\n+\n+    public void setUp()\n+    {\n+        Option file = new Option( 'f', \"file\", false, \"file to process\" );\n+        Option dir = new Option( 'd', \"directory\", false, \"directory to process\" );\n+        OptionGroup group = new OptionGroup();\n+        group.addOption( file );\n+        group.addOption( dir );\n+        _options = new Options().addOptionGroup( group );\n+\n+        Option section = new Option( 's', \"section\", false, \"section to process\" );\n+        Option chapter = new Option( 'c', \"chapter\", false, \"chapter to process\" );\n+        OptionGroup group2 = new OptionGroup();\n+        group2.addOption( section );\n+        group2.addOption( chapter );\n+\n+        _options.addOptionGroup( group2 );\n+        _options.addOption( 'r', \"revision\", false, \"revision number\" );\n+    }\n+\n+    public void tearDown()\n+    {\n+    }\n+\n+    public void testSingleOptionFromGroup()\n+    {\n+        String[] args = new String[] { \"-f\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is NOT set\", !cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is set\", cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSingleOption()\n+    {\n+        String[] args = new String[] { \"-r\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is set\", cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is NOT set\", !cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testTwoValidOptions()\n+    {\n+        String[] args = new String[] { \"-r\", \"-f\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is set\", cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is set\", cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSingleLongOption()\n+    {\n+        String[] args = new String[] { \"--file\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is NOT set\", !cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is set\", cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testTwoValidLongOptions()\n+    {\n+        String[] args = new String[] { \"--revision\", \"--file\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is set\", cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is set\", cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm no extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testNoOptionsExtraArgs()\n+    {\n+        String[] args = new String[] { \"arg1\", \"arg2\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -r is NOT set\", !cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is NOT set\", !cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is NOT set\", !cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm TWO extra args\", cl.getArgList().size() == 2);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testTwoOptionsFromGroup()\n+    {\n+        String[] args = new String[] { \"-f\", \"-d\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            fail( \"two arguments from group not allowed\" );\n+        }\n+        catch (ParseException e)\n+        {\n+            if( !( e instanceof AlreadySelectedException ) )\n+            {\n+                fail( \"incorrect exception caught:\" + e.getMessage() );\n+            }\n+        }\n+    }\n+\n+    public void testTwoLongOptionsFromGroup()\n+    {\n+        String[] args = new String[] { \"--file\", \"--directory\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            fail( \"two arguments from group not allowed\" );\n+        }\n+        catch (ParseException e)\n+        {\n+            if( !( e instanceof AlreadySelectedException ) )\n+            {\n+                fail( \"incorrect exception caught:\" + e.getMessage() );\n+            }\n+        }\n+    }\n+\n+    public void testTwoOptionsFromDifferentGroup()\n+    {\n+        String[] args = new String[] { \"-f\", \"-s\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            assertTrue( \"Confirm -r is NOT set\", !cl.hasOption('r') );\n+            assertTrue( \"Confirm -f is set\", cl.hasOption('f') );\n+            assertTrue( \"Confirm -d is NOT set\", !cl.hasOption('d') );\n+            assertTrue( \"Confirm -s is set\", cl.hasOption('s') );\n+            assertTrue( \"Confirm -c is NOT set\", !cl.hasOption('c') );\n+            assertTrue( \"Confirm NO extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ParseRequiredTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: ParseRequiredTest.java,v 1.1 2002/04/23 16:08:02 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * @author John Keyes (john at integralsource.com)\n+ * @version $Revision: 1.1 $\n+ */\n+public class ParseRequiredTest extends TestCase\n+{\n+\n+    private Options _options = null;\n+\n+    public static Test suite() { \n+        return new TestSuite(ParseRequiredTest.class); \n+    }\n+\n+    public ParseRequiredTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public void setUp()\n+    {\n+        _options = new Options()\n+            .addOption('a',\n+                       \"enable-a\",\n+                       false,\n+                       \"turn [a] on or off\")\n+            .addOption('b',\n+                       \"bfile\",\n+                       true,\n+                       \"set the value of [b]\",\n+                       true);\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testWithRequiredOption()\n+    {\n+        String[] args = new String[] {  \"-b\", \"file\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            \n+            assertTrue( \"Confirm -a is NOT set\", !cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"file\") );\n+            assertTrue( \"Confirm NO of extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testOptionAndRequiredOption()\n+    {\n+        String[] args = new String[] {  \"-a\", \"-b\", \"file\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"file\") );\n+            assertTrue( \"Confirm NO of extra args\", cl.getArgList().size() == 0);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testMissingRequiredOption()\n+    {\n+        String[] args = new String[] { \"-a\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            fail( \"exception should have been thrown\" );\n+        }\n+        catch (ParseException e)\n+        {\n+            if( !( e instanceof MissingOptionException ) )\n+            {\n+                fail( \"expected to catch MissingOptionException\" );\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ParseTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: ParseTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class ParseTest extends TestCase\n+{\n+\n+    private Options _options = null;\n+\n+    public static Test suite() { \n+        return new TestSuite(ParseTest.class); \n+    }\n+\n+    public ParseTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public void setUp()\n+    {\n+        _options = new Options()\n+            .addOption('a',\n+                       \"enable-a\",\n+                       false,\n+                       \"turn [a] on or off\")\n+            .addOption('b',\n+                       \"bfile\",\n+                       true,\n+                       \"set the value of [b]\")\n+            .addOption('c',\n+                       \"copt\",\n+                       false,\n+                       \"turn [c] on or off\");\n+/*        \n+        try\n+        {\n+            _options\n+                .addOption('a',\n+                           \"enable-a\",\n+                           false,\n+                           \"turn [a] on or off\")\n+                .addOption('b',\n+                           \"bfile\",\n+                           true,\n+                           \"set the value of [b]\")\n+                .addOption('c',\n+                           \"copt\",\n+                           false,\n+                           \"turn [c] on or off\");\n+            \n+        }\n+        catch (CLIException e)\n+        {\n+            e.printStackTrace();\n+        }\n+*/\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testSimpleShort()\n+    {\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSimpleLong()\n+    {\n+        String[] args = new String[] { \"--enable-a\",\n+                                       \"--bfile\", \"toast\",\n+                                       \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+        } \n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testComplexShort()\n+    {\n+        String[] args = new String[] { \"-acbtoast\",\n+                                       \"foo\", \"bar\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm -c is set\", cl.hasOption('c') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 2);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testExtraOption()\n+    {\n+        String[] args = new String[] { \"-adbtoast\",\n+                                       \"foo\", \"bar\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+            \n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm size of extra args\", cl.getArgList().size() == 3);\n+        }\n+        catch (UnrecognizedOptionException e)\n+        {\n+            caught = true;\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+        assertTrue( \"Confirm UnrecognizedOptionException caught\", caught );\n+    }\n+\n+    public void testMissingArg()\n+    {\n+\n+        String[] args = new String[] { \"-acb\" };\n+\n+        boolean caught = false;\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+        }\n+        catch (MissingArgumentException e)\n+        {\n+            caught = true;\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+\n+        assertTrue( \"Confirm MissingArgumentException caught\", caught );\n+    }\n+\n+    public void testStop()\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foober\",\n+                                       \"-btoast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args,\n+                                            true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption('c') );\n+            assertTrue( \"Confirm  2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testMultiple()\n+    {\n+        String[] args = new String[] { \"-c\",\n+                                       \"foobar\",\n+                                       \"-btoast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args,\n+                                            true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption('c') );\n+            assertTrue( \"Confirm  2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+\n+            cl = _options.parse( cl.getArgList() );\n+\n+            assertTrue( \"Confirm -c is not set\", ! cl.hasOption('c') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testMultipleWithLong()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"foobar\",\n+                                       \"--bfile\", \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args,\n+                                            true);\n+            assertTrue( \"Confirm -c is set\", cl.hasOption('c') );\n+            assertTrue( \"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n+\n+            cl = _options.parse( cl.getArgList() );\n+\n+            assertTrue( \"Confirm -c is not set\", ! cl.hasOption('c') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"toast\") );\n+            assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm  value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"foobar\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testDoubleDash()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"--\",\n+                                       \"-b\", \"toast\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -c is set\", cl.hasOption('c') );\n+            assertTrue( \"Confirm -b is not set\", ! cl.hasOption('b') );\n+            assertTrue( \"Confirm 2 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 2);\n+\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+    }\n+\n+    public void testSingleDash()\n+    {\n+        String[] args = new String[] { \"--copt\",\n+                                       \"-b\", \"-\",\n+                                       \"-a\",\n+                                       \"-\" };\n+\n+        try\n+        {\n+            CommandLine cl = _options.parse(args);\n+\n+            assertTrue( \"Confirm -a is set\", cl.hasOption('a') );\n+            assertTrue( \"Confirm -b is set\", cl.hasOption('b') );\n+            assertTrue( \"Confirm arg of -b\", cl.getOptionValue('b').equals(\"-\") );\n+            assertTrue( \"Confirm 1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\n+            assertTrue( \"Confirm value of extra arg: \" + cl.getArgList().get(0), cl.getArgList().get(0).equals(\"-\") );\n+        }\n+        catch (ParseException e)\n+        {\n+            fail( e.toString() );\n+        }\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/PatternOptionBuilderTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: PatternOptionBuilderTest.java,v 1.1 2002/06/06 22:09:25 bayard Exp $\n+ */\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n+\n+/** \n+ * Test case for the PatternOptionBuilder class \n+ *\n+ * @author Henri Yandell\n+ **/\n+public class PatternOptionBuilderTest\n+extends TestCase\n+{\n+   public static void main( String[] args )\n+   {\n+      String[] testName = { PatternOptionBuilderTest.class.getName() };\n+      junit.textui.TestRunner.main(testName);\n+   }\n+\n+   public static TestSuite suite()\n+   {\n+      return new TestSuite(PatternOptionBuilderTest.class);\n+   }\n+\n+   public PatternOptionBuilderTest( String s )\n+   {\n+      super( s );\n+   }\n+\n+   public void testSimplePattern()\n+      throws Exception\n+   {\n+      Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\n+      String[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\n+      \n+      CommandLine line = options.parse(args);\n+      assertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\n+      assertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\n+      assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject('b'));\n+      assertEquals(\"boolean true flag c\", true, line.hasOption('c'));\n+      assertEquals(\"boolean false flag d\", false, line.hasOption('d'));\n+      assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject('e'));\n+      assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f'));\n+      assertEquals(\"number flag n\", new Float(4.5), line.getOptionObject('n'));\n+      assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject('t'));\n+/// DATES NOT SUPPORTED YET.\n+//      assertEquals(\"number flag t\", new java.util.Date(1023400137276L), line.getOptionObject('z'));\n+//     input is:  \"Thu Jun 06 17:48:57 EDT 2002\"\n+   }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/TestHelpFormatter.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: TestHelpFormatter.java,v 1.2 2002/05/17 11:44:32 jstrachan Exp $\n+ */\n+package org.apache.commons.cli;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n+\n+/** \n+ * Test case for the HelpFormatter class \n+ *\n+ * @author Slawek Zachcial\n+ **/\n+public class TestHelpFormatter\n+extends TestCase\n+{\n+   // --------------------------------------------------------------- Constants\n+\n+   // ------------------------------------------------------------------ Static\n+\n+   public static void main( String[] args )\n+   {\n+      String[] testName = { TestHelpFormatter.class.getName() };\n+      junit.textui.TestRunner.main(testName);\n+   }\n+\n+   public static TestSuite suite()\n+   {\n+      return new TestSuite(TestHelpFormatter.class);\n+   }\n+\n+   // -------------------------------------------------------------- Attributes\n+\n+   // ------------------------------------------------------------ Constructors\n+   public TestHelpFormatter( String s )\n+   {\n+      super( s );\n+   }\n+   // ------------------------------------------------------------------ Public\n+\n+   public void testFindWrapPos()\n+      throws Exception\n+   {\n+      HelpFormatter hf = new HelpFormatter();\n+\n+      String text = \"This is a test.\";\n+      //text width should be max 8; the wrap postition is 7\n+      assertEquals(\"wrap position\", 7, hf.findWrapPos(text, 8, 0));\n+      //starting from 8 must give -1 - the wrap pos is after end\n+      assertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n+      //if there is no a good position before width to make a wrapping look for the next one\n+      text = \"aaaa aa\";\n+      assertEquals(\"wrap position 3\", 4, hf.findWrapPos(text, 3, 0));\n+   }\n+\n+   public void testPrintWrapped()\n+      throws Exception\n+   {\n+      StringBuffer sb = new StringBuffer();\n+      HelpFormatter hf = new HelpFormatter();\n+\n+      String text = \"This is a test.\";\n+      String expected;\n+\n+      expected = \"This is a\" + hf.defaultNewLine + \"test.\";\n+      hf.renderWrappedText(sb, 12, 0, text);\n+      assertEquals(\"single line text\", expected, sb.toString());\n+\n+      sb.setLength(0);\n+      expected = \"This is a\" + hf.defaultNewLine + \"    test.\";\n+      hf.renderWrappedText(sb, 12, 4, text);\n+      assertEquals(\"single line padded text\", expected, sb.toString());\n+\n+      text =\n+         \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n+         \"aaaaaa\" + hf.defaultNewLine +\n+         \"aaaaa\";\n+\n+      expected = text;\n+      sb.setLength(0);\n+      hf.renderWrappedText(sb, 16, 0, text);\n+      assertEquals(\"multi line text\", expected, sb.toString());\n+\n+      expected =\n+         \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n+         \"    aaaaaa\" + hf.defaultNewLine +\n+         \"    aaaaa\";\n+      sb.setLength(0);\n+      hf.renderWrappedText(sb, 16, 4, text);\n+      assertEquals(\"multi-line padded text\", expected, sb.toString());\n+   }\n+\n+   public void testPrintOptions()\n+      throws Exception\n+   {\n+      StringBuffer sb = new StringBuffer();\n+      HelpFormatter hf = new HelpFormatter();\n+      final int leftPad = 1;\n+      final int descPad = 3;\n+      final String lpad = hf.createPadding(leftPad);\n+      final String dpad = hf.createPadding(descPad);\n+      Options options = null;\n+      String expected = null;\n+\n+      options = new Options().addOption('a', false, \"aaaa aaaa aaaa aaaa aaaa\");\n+      expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n+      hf.renderOptions(sb, 60, options, leftPad, descPad);\n+      assertEquals(\"simple non-wrapped option\", expected, sb.toString());\n+\n+      int nextLineTabStop = leftPad+descPad+\"-a\".length();\n+      expected =\n+         lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n+         hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n+      sb.setLength(0);\n+      hf.renderOptions(sb, nextLineTabStop+17, options, leftPad, descPad);\n+      assertEquals(\"simple wrapped option\", expected, sb.toString());\n+\n+\n+      options = new Options().addOption('a', \"aaa\", false, \"dddd dddd dddd dddd\");\n+      expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n+      sb.setLength(0);\n+      hf.renderOptions(sb, 60, options, leftPad, descPad);\n+      assertEquals(\"long non-wrapped option\", expected, sb.toString());\n+\n+      nextLineTabStop = leftPad+descPad+\"-a,--aaa\".length();\n+      expected =\n+         lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.defaultNewLine +\n+         hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n+      sb.setLength(0);\n+      hf.renderOptions(sb, 25, options, leftPad, descPad);\n+      assertEquals(\"long wrapped option\", expected, sb.toString());\n+\n+      options = new Options().\n+         addOption('a', \"aaa\", false, \"dddd dddd dddd dddd\").\n+         addOption('b', false, \"feeee eeee eeee eeee\");\n+      expected =\n+         lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.defaultNewLine +\n+         hf.createPadding(nextLineTabStop) + \"dddd dddd\" + hf.defaultNewLine +\n+         lpad + \"-b      \" + dpad + \"feeee eeee\" + hf.defaultNewLine +\n+         hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n+      sb.setLength(0);\n+      hf.renderOptions(sb, 25, options, leftPad, descPad);\n+      assertEquals(\"multiple wrapped options\", expected, sb.toString());\n+   }\n+\n+   // --------------------------------------------------------------- Protected\n+\n+   // ------------------------------------------------------- Package protected   \n+   \n+   // ----------------------------------------------------------------- Private\n+   \n+   // ----------------------------------------------------------- Inner classes\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ValueTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: ValueTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class ValueTest extends TestCase\n+{\n+\n+    public static Test suite() { \n+        return new TestSuite(ValueTest.class); \n+        /*\n+        TestSuite suite = new TestSuite();\n+\n+        suite.addTest( new ValueTest(\"testLongNoArg\") );\n+\n+        return suite;\n+        */\n+    }\n+\n+    private CommandLine _cl = null;\n+\n+\n+    public ValueTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public void setUp()\n+    {\n+        Options opts = new Options();\n+        opts.addOption('a',\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('b',\n+                       true,\n+                       \"set -b\");\n+\n+        opts.addOption('c',\n+                       \"c\",\n+                       false,\n+                       \"toggle -c\");\n+\n+        opts.addOption('d',\n+                       \"d\",\n+                       true,\n+                       \"set -d\");\n+\n+/*            \n+        try\n+        {\n+            opts.addOption('a',\n+                           false,\n+                           \"toggle -a\");\n+            \n+            opts.addOption('b',\n+                           true,\n+                           \"set -b\");\n+            \n+            opts.addOption('c',\n+                           \"c\",\n+                           false,\n+                           \"toggle -c\");\n+            \n+            opts.addOption('d',\n+                           \"d\",\n+                           true,\n+                           \"set -d\");\n+        }\n+        catch (DuplicateOptionException e)\n+        {\n+            fail(\"Cannot setUp() Options: \" + e.toString());\n+        }\n+*/\n+\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"foo\",\n+                                       \"--c\",\n+                                       \"--d\", \"bar\" };\n+\n+        try\n+        {\n+            _cl = opts.parse(args);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail(\"Cannot setUp() CommandLine: \" + e.toString());\n+        }\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testShortNoArg()\n+    {\n+        assertTrue( _cl.hasOption('a') );\n+        assertNull( _cl.getOptionValue('a') );\n+    }\n+\n+    public void testShortWithArg()\n+    {\n+        assertTrue( _cl.hasOption('b') );\n+        assertNotNull( _cl.getOptionValue('b') );\n+        assertEquals( _cl.getOptionValue('b'), \"foo\");\n+    }\n+\n+    public void testLongNoArg()\n+    {\n+        assertTrue( _cl.hasOption('c') );\n+        assertNull( _cl.getOptionValue('c') );\n+    }\n+\n+    public void testLongWithArg()\n+    {\n+        assertTrue( _cl.hasOption('d') );\n+        assertNotNull( _cl.getOptionValue('d') );\n+        assertEquals( _cl.getOptionValue('d'), \"bar\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli/ValuesTest.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ * \n+ * $Id: ValueTest.java,v 1.1 2001/12/19 18:16:25 jstrachan Exp $\n+ */\n+\n+package org.apache.commons.cli;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class ValuesTest extends TestCase\n+{\n+\n+    public static Test suite() { \n+        return new TestSuite(ValuesTest.class); \n+        /*\n+        TestSuite suite = new TestSuite();\n+\n+        suite.addTest( new ValueTest(\"testLongNoArg\") );\n+\n+        return suite;\n+        */\n+    }\n+\n+    private CommandLine _cl = null;\n+\n+\n+    public ValuesTest(String name)\n+    {\n+        super(name);\n+    }\n+\n+    public void setUp()\n+    {\n+        Options opts = new Options();\n+        opts.addOption('a',\n+                       false,\n+                       \"toggle -a\");\n+\n+        opts.addOption('b',\n+                       true,\n+                       \"set -b\");\n+\n+        opts.addOption('c',\n+                       \"c\",\n+                       false,\n+                       \"toggle -c\");\n+\n+        opts.addOption('d',\n+                       \"d\",\n+                       true,\n+                       \"set -d\");\n+        \n+        opts.addOption('e',\n+                       \"e\",\n+                       true,\n+                       \"set -e\",\n+                       false,\n+                       true);\n+\n+        opts.addOption('f',\n+                       \"f\",\n+                       false,\n+                       \"jk\");\n+\n+        String[] args = new String[] { \"-a\",\n+                                       \"-b\", \"foo\",\n+                                       \"--c\",\n+                                       \"--d\", \"bar\",\n+                                       \"-e\", \"one\", \"two\",\n+                                       \"-f\",\n+                                       \"arg1\", \"arg2\" };\n+\n+        try\n+        {\n+            _cl = opts.parse(args);\n+        }\n+        catch (ParseException e)\n+        {\n+            fail(\"Cannot setUp() CommandLine: \" + e.toString());\n+        }\n+    }\n+\n+    public void tearDown()\n+    {\n+\n+    }\n+\n+    public void testShortArgs()\n+    {\n+        assertTrue( _cl.hasOption('a') );\n+        assertTrue( _cl.hasOption('c') );\n+\n+        assertNull( _cl.getOptionValues('a') );\n+        assertNull( _cl.getOptionValues('c') );\n+    }\n+\n+    public void testShortArgsWithValue()\n+    {\n+        assertTrue( _cl.hasOption('b') );\n+        assertTrue( _cl.getOptionValue('b').equals(\"foo\"));\n+        assertTrue( _cl.getOptionValues('b').length == 1);\n+\n+        assertTrue( _cl.hasOption('d') );\n+        assertTrue( _cl.getOptionValue('d').equals(\"bar\"));\n+        assertTrue( _cl.getOptionValues('d').length == 1);\n+    }\n+\n+    public void testMultipleArgValues()\n+    {\n+        String[] result = _cl.getOptionValues('e');\n+        String[] values = new String[] { \"one\", \"two\" };\n+        assertTrue( _cl.hasOption('e') );\n+        assertTrue( _cl.getOptionValues('e').length == 2);\n+        assertTrue( java.util.Arrays.equals( values, _cl.getOptionValues('e') ) );\n+    }\n+\n+    public void testExtraArgs()\n+    {\n+        String[] args = new String[] { \"arg1\", \"arg2\" };\n+        assertTrue( _cl.getArgs().length == 2);\n+        assertTrue( java.util.Arrays.equals( args, _cl.getArgs() ) );\n+    }\n+}", "timestamp": 1023732076, "metainfo": ""}