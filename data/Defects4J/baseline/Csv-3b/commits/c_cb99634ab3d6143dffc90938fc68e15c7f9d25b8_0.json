{"sha": "cb99634ab3d6143dffc90938fc68e15c7f9d25b8", "log": "Renamed CSVStrategy to CSVFormat  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * The format specification of a CSV file.\n+ *\n+ * This class is immutable.\n+ */\n+public class CSVFormat implements Cloneable, Serializable {\n+\n+    private char delimiter = ',';\n+    private char encapsulator = '\"';\n+    private char commentStart = COMMENTS_DISABLED;\n+    private char escape = ESCAPE_DISABLED;\n+    private boolean leadingSpacesIgnored = true;\n+    private boolean trailingSpacesIgnored = true;\n+    private boolean unicodeEscapesInterpreted = false;\n+    private boolean emptyLinesIgnored = true;\n+    private String lineSeparator = \"\\n\";\n+\n+    // -2 is used to signal disabled, because it won't be confused with\n+    // an EOF signal (-1), and because \\ufffe in UTF-16 would be\n+    // encoded as two chars (using surrogates) and thus there should never\n+    // be a collision with a real text char.\n+    public static final char COMMENTS_DISABLED = (char) -2;\n+    public static final char ESCAPE_DISABLED = (char) -2;\n+    public static final char ENCAPSULATOR_DISABLED = (char) -2;\n+\n+    /** Standard comma separated format. */\n+    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true, false, true);\n+    \n+    /** Excel file format (using a comma as the value delimiter). */\n+    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, false, false, false);\n+    \n+    /** Tabulation delimited format. */\n+    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true, false, true);\n+\n+\n+    /**\n+     * Creates a CSVFormat with the default parameters.\n+     */\n+    public CSVFormat() {\n+    }\n+\n+    public CSVFormat(char delimiter, char encapsulator, char commentStart) {\n+        this(delimiter, encapsulator, commentStart, ESCAPE_DISABLED, true, true, false, true);\n+    }\n+\n+    /**\n+     * Customized CSV format constructor.\n+     *\n+     * @param delimiter                 a char used for value separation\n+     * @param encapsulator              a char used as value encapsulation marker\n+     * @param commentStart              a char used for comment identification\n+     * @param escape                    a char used to escape special characters in values\n+     * @param leadingSpacesIgnored      TRUE when leading whitespaces should be ignored\n+     * @param trailingSpacesIgnored     TRUE when trailing whitespaces should be ignored\n+     * @param unicodeEscapesInterpreted TRUE when unicode escapes should be interpreted\n+     * @param emptyLinesIgnored         TRUE when the parser should skip emtpy lines\n+     */\n+    public CSVFormat(\n+            char delimiter,\n+            char encapsulator,\n+            char commentStart,\n+            char escape,\n+            boolean leadingSpacesIgnored,\n+            boolean trailingSpacesIgnored,\n+            boolean unicodeEscapesInterpreted,\n+            boolean emptyLinesIgnored) {\n+        this.delimiter = delimiter;\n+        this.encapsulator = encapsulator;\n+        this.commentStart = commentStart;\n+        this.escape = escape;\n+        this.leadingSpacesIgnored = leadingSpacesIgnored;\n+        this.trailingSpacesIgnored = trailingSpacesIgnored;\n+        this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n+        this.emptyLinesIgnored = emptyLinesIgnored;\n+    }\n+\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    public CSVFormat withDelimiter(char delimiter) {\n+        CSVFormat format = (CSVFormat) clone();\n+        this.delimiter = delimiter;\n+        return format;\n+    }\n+\n+    public char getEncapsulator() {\n+        return encapsulator;\n+    }\n+\n+    public CSVFormat withEncapsulator(char encapsulator) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.encapsulator = encapsulator;\n+        return format;\n+    }\n+\n+    public char getCommentStart() {\n+        return commentStart;\n+    }\n+\n+    public CSVFormat withCommentStart(char commentStart) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.commentStart = commentStart;\n+        return format;\n+    }\n+\n+    public boolean isCommentingDisabled() {\n+        return this.commentStart == COMMENTS_DISABLED;\n+    }\n+\n+    public char getEscape() {\n+        return escape;\n+    }\n+\n+    public CSVFormat withEscape(char escape) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.escape = escape;\n+        return format;\n+    }\n+\n+    public boolean isLeadingSpacesIgnored() {\n+        return leadingSpacesIgnored;\n+    }\n+\n+    public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.leadingSpacesIgnored = leadingSpacesIgnored;\n+        return format;\n+    }\n+\n+    public boolean isTrailingSpacesIgnored() {\n+        return trailingSpacesIgnored;\n+    }\n+\n+    public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.trailingSpacesIgnored = trailingSpacesIgnored;\n+        return format;\n+    }\n+\n+    public boolean isUnicodeEscapesInterpreted() {\n+        return unicodeEscapesInterpreted;\n+    }\n+\n+    public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n+        return format;\n+    }\n+\n+    public boolean isEmptyLinesIgnored() {\n+        return emptyLinesIgnored;\n+    }\n+\n+    public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.emptyLinesIgnored = emptyLinesIgnored;\n+        return format;\n+    }\n+\n+    public String getLineSeparator() {\n+        return lineSeparator;\n+    }\n+\n+    public CSVFormat withLineSeparator(String lineSeparator) {\n+        CSVFormat format = (CSVFormat) clone();\n+        format.lineSeparator = lineSeparator;\n+        return format;\n+    }\n+\n+    protected Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw (Error) new InternalError().initCause(e);\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  * Parses CSV files according to the specified configuration.\n  *\n  * Because CSV appears in many different dialects, the parser supports many\n- * configuration settings by allowing the specification of a {@link CSVStrategy}.\n+ * configuration settings by allowing the specification of a {@link CSVFormat}.\n  *\n  * <p>Parsing of a csv-string having tabs as separators,\n  * '\"' as an optional value encapsulator, and comments starting with '#':</p>\n  * <pre>\n  *  String[][] data =\n- *   (new CSVParser(new StringReader(\"a\\tb\\nc\\td\"), new CSVStrategy('\\t','\"','#'))).getAllValues();\n+ *   (new CSVParser(new StringReader(\"a\\tb\\nc\\td\"), new CSVFormat('\\t','\"','#'))).getAllValues();\n  * </pre>\n  *\n  * <p>Parsing of a csv-string in Excel CSV format</p>\n  * <pre>\n  *  String[][] data =\n- *   (new CSVParser(new StringReader(\"a;b\\nc;d\"), CSVStrategy.EXCEL_STRATEGY)).getAllValues();\n+ *   (new CSVParser(new StringReader(\"a;b\\nc;d\"), CSVFormat.EXCEL)).getAllValues();\n  * </pre>\n  *\n  * <p>\n- * Internal parser state is completely covered by the strategy\n+ * Internal parser state is completely covered by the format\n  * and the reader-state.</p>\n  *\n  * <p>see <a href=\"package-summary.html\">package documentation</a>\n     // the input stream\n     private final ExtendedBufferedReader in;\n \n-    private final CSVStrategy strategy;\n+    private final CSVFormat format;\n \n     // the following objects are shared to reduce garbage\n     /**\n     // ======================================================\n \n     /**\n-     * CSV parser using the default {@link CSVStrategy}.\n+     * CSV parser using the default {@link CSVFormat}.\n      *\n      * @param input a Reader containing \"csv-formatted\" input\n      */\n     public CSVParser(Reader input) {\n-        this(input, CSVStrategy.DEFAULT_STRATEGY);\n-    }\n-\n-    /**\n-     * Customized CSV parser using the given {@link CSVStrategy}\n+        this(input, CSVFormat.DEFAULT);\n+    }\n+\n+    /**\n+     * Customized CSV parser using the given {@link CSVFormat}\n      *\n      * @param input    a Reader containing \"csv-formatted\" input\n-     * @param strategy the CSVStrategy used for CSV parsing\n-     */\n-    public CSVParser(Reader input, CSVStrategy strategy) {\n+     * @param format the CSVFormat used for CSV parsing\n+     */\n+    public CSVParser(Reader input, CSVFormat format) {\n         this.in = new ExtendedBufferedReader(input);\n-        this.strategy = strategy;\n+        this.format = format;\n     }\n \n     // ======================================================\n     // ======================================================\n \n     /**\n-     * Parses the CSV according to the given strategy\n+     * Parses the CSV according to the given format\n      * and returns the content as an array of records\n      * (whereas records are arrays of single values).\n      * <p/>\n         c = in.readAgain();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n-        while (strategy.isEmptyLinesIgnored() && eol\n+        while (format.isEmptyLinesIgnored() && eol\n                 && (lastChar == '\\n'\n                 || lastChar == '\\r'\n                 || lastChar == ExtendedBufferedReader.UNDEFINED)\n         }\n \n         // did we reach eof during the last iteration already ? TT_EOF\n-        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {\n+        if (isEndOfFile(lastChar) || (lastChar != format.getDelimiter() && isEndOfFile(c))) {\n             tkn.type = TT_EOF;\n             return tkn;\n         }\n         //  important: make sure a new char gets consumed in each iteration\n         while (!tkn.isReady && tkn.type != TT_EOF) {\n             // ignore whitespaces at beginning of a token\n-            while (strategy.isLeadingSpacesIgnored() && isWhitespace(c) && !eol) {\n+            while (format.isLeadingSpacesIgnored() && isWhitespace(c) && !eol) {\n                 wsBuf.append((char) c);\n                 c = in.read();\n                 eol = isEndOfLine(c);\n             }\n             // ok, start of token reached: comment, encapsulated, or token\n-            if (c == strategy.getCommentStart()) {\n+            if (c == format.getCommentStart()) {\n                 // ignore everything till end of line and continue (incr linecount)\n                 in.readLine();\n                 tkn = nextToken(tkn.reset());\n-            } else if (c == strategy.getDelimiter()) {\n+            } else if (c == format.getDelimiter()) {\n                 // empty token return TT_TOKEN(\"\")\n                 tkn.type = TT_TOKEN;\n                 tkn.isReady = true;\n                 //noop: tkn.content.append(\"\");\n                 tkn.type = TT_EORECORD;\n                 tkn.isReady = true;\n-            } else if (c == strategy.getEncapsulator()) {\n+            } else if (c == format.getEncapsulator()) {\n                 // consume encapsulated token\n                 encapsulatedTokenLexer(tkn, c);\n             } else if (isEndOfFile(c)) {\n             } else {\n                 // next token must be a simple token\n                 // add removed blanks when not ignoring whitespace chars...\n-                if (!strategy.isLeadingSpacesIgnored()) {\n+                if (!format.isLeadingSpacesIgnored()) {\n                     tkn.content.append(wsBuf);\n                 }\n                 simpleTokenLexer(tkn, c);\n                 tkn.type = TT_EOF;\n                 tkn.isReady = true;\n                 break;\n-            } else if (c == strategy.getDelimiter()) {\n+            } else if (c == format.getDelimiter()) {\n                 // end of token\n                 tkn.type = TT_TOKEN;\n                 tkn.isReady = true;\n                 break;\n-            } else if (c == '\\\\' && strategy.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n+            } else if (c == '\\\\' && format.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n                 // interpret unicode escaped chars (like \\u0070 -> p)\n                 tkn.content.append((char) unicodeEscapeLexer(c));\n-            } else if (c == strategy.getEscape()) {\n+            } else if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape(c));\n             } else {\n                 tkn.content.append((char) c);\n             c = in.read();\n         }\n \n-        if (strategy.isTrailingSpacesIgnored()) {\n+        if (format.isTrailingSpacesIgnored()) {\n             tkn.content.trimTrailingWhitespace();\n         }\n \n         for (; ;) {\n             c = in.read();\n \n-            if (c == '\\\\' && strategy.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n+            if (c == '\\\\' && format.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n                 tkn.content.append((char) unicodeEscapeLexer(c));\n-            } else if (c == strategy.getEscape()) {\n+            } else if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape(c));\n-            } else if (c == strategy.getEncapsulator()) {\n-                if (in.lookAhead() == strategy.getEncapsulator()) {\n+            } else if (c == format.getEncapsulator()) {\n+                if (in.lookAhead() == format.getEncapsulator()) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n                     c = in.read();\n                     tkn.content.append((char) c);\n                     // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                     for (; ;) {\n                         c = in.read();\n-                        if (c == strategy.getDelimiter()) {\n+                        if (c == format.getDelimiter()) {\n                             tkn.type = TT_TOKEN;\n                             tkn.isReady = true;\n                             return tkn;\n     // ======================================================\n \n     /**\n-     * Obtain the specified CSV Strategy.  This should not be modified.\n-     *\n-     * @return strategy currently being used\n-     */\n-    public CSVStrategy getStrategy() {\n-        return this.strategy;\n+     * Obtain the specified CSV format.\n+     *\n+     * @return format currently being used\n+     */\n+    public CSVFormat getFormat() {\n+        return this.format;\n     }\n \n     // ======================================================\n      * @return true if the given char is a whitespace character\n      */\n     private boolean isWhitespace(int c) {\n-        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());\n+        return Character.isWhitespace((char) c) && (c != format.getDelimiter());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n     /** The place that the values get written. */\n     private final Writer out;\n-    private final CSVStrategy strategy;\n+    private final CSVFormat format;\n \n     /** True if we just began a new line. */\n     private boolean newLine = true;\n     private char[] buf = new char[0];  \n \n     /**\n-     * Create a printer that will print values to the given\n-     * stream following the CSVStrategy.\n+     * Create a printer that will print values to the given stream following the CSVFormat.\n      * <p/>\n-     * Currently, only a pure encapsulation strategy or a pure escaping strategy\n-     * is supported.  Hybrid strategies (encapsulation and escaping with a different character) are not supported.\n-     *\n-     * @param out      stream to which to print.\n-     * @param strategy describes the CSV variation.\n-     */\n-    public CSVPrinter(Writer out, CSVStrategy strategy) {\n+     * Currently, only a pure encapsulation format or a pure escaping format\n+     * is supported. Hybrid formats (encapsulation and escaping with a different character) are not supported.\n+     *\n+     * @param out    stream to which to print.\n+     * @param format describes the CSV variation.\n+     */\n+    public CSVPrinter(Writer out, CSVFormat format) {\n         this.out = out;\n-        this.strategy = strategy == null ? CSVStrategy.DEFAULT_STRATEGY : strategy;\n+        this.format = format == null ? CSVFormat.DEFAULT : format;\n     }\n \n     // ======================================================\n      * Output a blank line\n      */\n     public void println() throws IOException {\n-        out.write(strategy.getLineSeparator());\n+        out.write(format.getLineSeparator());\n         newLine = true;\n     }\n \n      * @param comment the comment to output\n      */\n     public void printlnComment(String comment) throws IOException {\n-        if (this.strategy.isCommentingDisabled()) {\n+        if (this.format.isCommentingDisabled()) {\n             return;\n         }\n         if (!newLine) {\n             println();\n         }\n-        out.write(this.strategy.getCommentStart());\n+        out.write(this.format.getCommentStart());\n         out.write(' ');\n         for (int i = 0; i < comment.length(); i++) {\n             char c = comment.charAt(i);\n                     // break intentionally excluded.\n                 case '\\n':\n                     println();\n-                    out.write(this.strategy.getCommentStart());\n+                    out.write(this.format.getCommentStart());\n                     out.write(' ');\n                     break;\n                 default:\n             return;\n         }\n \n-        if (strategy.getEncapsulator() != CSVStrategy.ENCAPSULATOR_DISABLED) {\n+        if (format.getEncapsulator() != CSVFormat.ENCAPSULATOR_DISABLED) {\n             printAndEncapsulate(value, offset, len);\n-        } else if (strategy.getEscape() != CSVStrategy.ESCAPE_DISABLED) {\n+        } else if (format.getEscape() != CSVFormat.ESCAPE_DISABLED) {\n             printAndEscape(value, offset, len);\n         } else {\n             printSep();\n         if (newLine) {\n             newLine = false;\n         } else {\n-            out.write(this.strategy.getDelimiter());\n+            out.write(this.format.getDelimiter());\n         }\n     }\n \n \n         printSep();\n \n-        char delim = this.strategy.getDelimiter();\n-        char escape = this.strategy.getEscape();\n+        char delim = this.format.getDelimiter();\n+        char escape = this.format.getEscape();\n \n         while (pos < end) {\n             char c = value[pos];\n \n         printSep();\n \n-        char delim = this.strategy.getDelimiter();\n-        char encapsulator = this.strategy.getEncapsulator();\n+        char delim = this.format.getDelimiter();\n+        char encapsulator = this.format.getEncapsulator();\n \n         if (len <= 0) {\n             // always quote an empty token that is the first\n--- a/src/main/java/org/apache/commons/csv/CSVUtils.java\n+++ b/src/main/java/org/apache/commons/csv/CSVUtils.java\n      * @return the CSV string, will be an empty string if the length of the\n      *         value array is 0\n      */\n-    public static String printLine(String[] values, CSVStrategy strategy) {\n+    public static String printLine(String[] values, CSVFormat format) {\n         // set up a CSVUtils\n         StringWriter stringWriter = new StringWriter();\n-        CSVPrinter csvPrinter = new CSVPrinter(stringWriter, strategy);\n+        CSVPrinter csvPrinter = new CSVPrinter(stringWriter, format);\n \n         // check for null values an \"null\" as strings and convert them\n         // into the strings \"null\" and \"\\\"null\\\"\"\n     // ======================================================\n \n     /**\n-     * Parses the given String according to the default {@link CSVStrategy}.\n+     * Parses the given String according to the default {@link CSVFormat}.\n      *\n      * @param s CSV String to be parsed.\n      * @return parsed String matrix (which is never null)\n         }\n         String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n         if (result == null) {\n-            // since CSVStrategy ignores empty lines an empty array is returned\n+            // since CSVFormat ignores empty lines an empty array is returned\n             // (i.e. not \"result = new String[][] {{\"\"}};\")\n             result = EMPTY_DOUBLE_STRING_ARRAY;\n         }\n     }\n \n     /**\n-     * Parses the first line only according to the default {@link CSVStrategy}.\n+     * Parses the first line only according to the default {@link CSVFormat}.\n      *\n      * Parsing empty string will be handled as valid records containing zero\n      * elements, so the following property holds: parseLine(\"\").length == 0.\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import junit.framework.TestCase;\n+\n+public class CSVFormatTest extends TestCase {\n+\n+    public void testImmutalibity() {\n+        CSVFormat format1 = new CSVFormat('!', '!', '!', '!', true, true, true, true);\n+        CSVFormat format2 = format1.withDelimiter('?')\n+                                         .withEncapsulator('?')\n+                                         .withCommentStart('?')\n+                                         .withLineSeparator(\"?\")\n+                                         .withEscape('?')\n+                                         .withLeadingSpacesIgnored(false)\n+                                         .withTrailingSpacesIgnored(false)\n+                                         .withEmptyLinesIgnored(false)\n+                                         .withUnicodeEscapesInterpreted(false);\n+\n+        assertNotSame(format1.getDelimiter(), format2.getDelimiter());\n+        assertNotSame(format1.getEncapsulator(), format2.getEncapsulator());\n+        assertNotSame(format1.getCommentStart(), format2.getCommentStart());\n+        assertNotSame(format1.getEscape(), format2.getEscape());\n+        assertNotSame(format1.getLineSeparator(), format2.getLineSeparator());\n+        \n+        assertNotSame(format1.isTrailingSpacesIgnored(), format2.isTrailingSpacesIgnored());\n+        assertNotSame(format1.isLeadingSpacesIgnored(), format2.isLeadingSpacesIgnored());\n+        assertNotSame(format1.isEmptyLinesIgnored(), format2.isEmptyLinesIgnored());\n+        assertNotSame(format1.isUnicodeEscapesInterpreted(), format2.isUnicodeEscapesInterpreted());\n+    }\n+\n+} \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n             super(in);\n         }\n \n-        TestCSVParser(Reader in, CSVStrategy strategy) {\n-            super(in, strategy);\n+        TestCSVParser(Reader in, CSVFormat format) {\n+            super(in, format);\n         }\n \n         /**\n         *\n         */\n         String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n-        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY.withCommentStart('#');\n+        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         \n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n \n \n         assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n         *       \\,,\n         */\n         String code = \"a,\\\\,,b\\n\\\\,,\";\n-        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY.withCommentStart('#');\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n \n         assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n         // an unquoted single backslash is not an escape char\n         *       ;;\n         */\n         String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVStrategy(';', '\\'', '!'));\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVFormat(';', '\\'', '!'));\n         assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n         assertEquals(\n                 CSVParser.TT_EORECORD + \";b and ' more\\n;\",\n         }\n     }\n \n-    public void testExcelStrategy1() throws IOException {\n+    public void testExcelFormat1() throws IOException {\n         String code =\n                 \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n                         + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n                 {\"\"},\n                 {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n         };\n-        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.EXCEL);\n         String[][] tmp = parser.getAllValues();\n         assertEquals(res.length, tmp.length);\n         assertTrue(tmp.length > 0);\n         }\n     }\n \n-    public void testExcelStrategy2() throws Exception {\n+    public void testExcelFormat2() throws Exception {\n         String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n         String[][] res = {\n                 {\"foo\", \"baar\"},\n                 {\"\"},\n                 {\"world\", \"\"}\n         };\n-        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.EXCEL);\n         String[][] tmp = parser.getAllValues();\n         assertEquals(res.length, tmp.length);\n         assertTrue(tmp.length > 0);\n         };\n         String[][] res = {\n                 {\"hello\", \"\"},\n-                {\"\"},  // ExcelStrategy does not ignore empty lines\n+                {\"\"},  // Excel format does not ignore empty lines\n                 {\"world\", \"\"}\n         };\n         String code;\n         for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n             code = codes[codeIndex];\n-            CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+            CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.EXCEL);\n             String[][] tmp = parser.getAllValues();\n             assertEquals(res.length, tmp.length);\n             assertTrue(tmp.length > 0);\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n         };\n         String[][] res = {\n-                {\"hello\", \"\"},  // CSV Strategy ignores empty lines\n+                {\"hello\", \"\"},  // CSV format ignores empty lines\n                 {\"world\", \"\"}\n         };\n         String code;\n         };\n         String[][] res = {\n                 {\"hello\", \"\"},\n-                {\"\"},  // ExcelStrategy does not ignore empty lines\n+                {\"\"},  // Excel format does not ignore empty lines\n                 {\"\"}\n         };\n         String code;\n         for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n             code = codes[codeIndex];\n-            CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+            CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.EXCEL);\n             String[][] tmp = parser.getAllValues();\n             assertEquals(res.length, tmp.length);\n             assertTrue(tmp.length > 0);\n                 \"hello,\\\"\\\"\\n\\n\\n\"\n         };\n         String[][] res = {\n-                {\"hello\", \"\"}  // CSV Strategy ignores empty lines\n+                {\"hello\", \"\"}  // CSV format ignores empty lines\n         };\n         String code;\n         for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n         };\n \n \n-        CSVStrategy strategy = new CSVStrategy(',', '\\'', CSVStrategy.COMMENTS_DISABLED, '/', false, false, true, true);\n-\n-        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.COMMENTS_DISABLED, '/', false, false, true, true);\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), format);\n         String[][] tmp = parser.getAllValues();\n         assertTrue(tmp.length > 0);\n         for (int i = 0; i < res.length; i++) {\n         };\n \n \n-        CSVStrategy strategy = new CSVStrategy(',', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED, '/', false, false, true, true);\n-\n-        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        CSVFormat format = new CSVFormat(',', CSVFormat.ENCAPSULATOR_DISABLED, CSVFormat.COMMENTS_DISABLED, '/', false, false, true, true);\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), format);\n         String[][] tmp = parser.getAllValues();\n         assertTrue(tmp.length > 0);\n \n     }\n \n \n-    public void testDefaultStrategy() throws IOException {\n+    public void testDefaultFormat() throws IOException {\n \n         String code = \"\"\n                 + \"a,b\\n\"            // 1)\n                 {\"\", \"#\"},\n         };\n \n-        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n-        assertEquals(CSVStrategy.COMMENTS_DISABLED, strategy.getCommentStart());\n-\n-        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        CSVFormat format = CSVFormat.DEFAULT;\n+        assertEquals(CSVFormat.COMMENTS_DISABLED, format.getCommentStart());\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), format);\n         String[][] tmp = parser.getAllValues();\n         assertTrue(tmp.length > 0);\n \n                 {\"\"},\n         };\n \n-        strategy = new CSVStrategy(',', '\"', '#');\n-        parser = new CSVParser(new StringReader(code), strategy);\n+        format = new CSVFormat(',', '\"', '#');\n+        parser = new CSVParser(new StringReader(code), format);\n         tmp = parser.getAllValues();\n \n         if (!CSVPrinterTest.equals(res_comments, tmp)) {\n \n     public void testUnicodeEscape() throws IOException {\n         String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.DEFAULT_STRATEGY.withUnicodeEscapesInterpreted(true));\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.DEFAULT.withUnicodeEscapesInterpreted(true));\n         String[] data = parser.getLine();\n         assertEquals(2, data.length);\n         assertEquals(\"abc\", data[0]);\n     // From SANDBOX-153\n     public void testDelimiterIsWhitespace() throws IOException {\n         String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVStrategy.TDF_STRATEGY);\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVFormat.TDF);\n         assertEquals(CSVParser.TT_TOKEN + \";one;\", parser.testNextToken());\n         assertEquals(CSVParser.TT_TOKEN + \";two;\", parser.testNextToken());\n         assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n \n     public void testPrinter1() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a\", \"b\"};\n         printer.println(line1);\n         assertEquals(\"a,b\" + lineSeparator, sw.toString());\n \n     public void testPrinter2() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a,b\", \"b\"};\n         printer.println(line1);\n         assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n \n     public void testPrinter3() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a, b\", \"b \"};\n         printer.println(line1);\n         assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n \n     public void testPrinter4() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a\", \"b\\\"c\"};\n         printer.println(line1);\n         assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + lineSeparator, sw.toString());\n \n     public void testPrinter5() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a\", \"b\\nc\"};\n         printer.println(line1);\n         assertEquals(\"a,\\\"b\\nc\\\"\" + lineSeparator, sw.toString());\n \n     public void testPrinter6() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a\", \"b\\r\\nc\"};\n         printer.println(line1);\n         assertEquals(\"a,\\\"b\\r\\nc\\\"\" + lineSeparator, sw.toString());\n \n     public void testPrinter7() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         String[] line1 = {\"a\", \"b\\\\c\"};\n         printer.println(line1);\n         assertEquals(\"a,b\\\\c\" + lineSeparator, sw.toString());\n \n     public void testExcelPrinter1() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n         String[] line1 = {\"a\", \"b\"};\n         printer.println(line1);\n         assertEquals(\"a,b\" + lineSeparator, sw.toString());\n \n     public void testExcelPrinter2() throws IOException {\n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n         String[] line1 = {\"a,b\", \"b\"};\n         printer.println(line1);\n         assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n \n     public void testRandom() throws Exception {\n         int iter = 10000;\n-        strategy = CSVStrategy.DEFAULT_STRATEGY;\n+        format = CSVFormat.DEFAULT;\n         doRandom(iter);\n-        strategy = CSVStrategy.EXCEL_STRATEGY;\n+        format = CSVFormat.EXCEL;\n         doRandom(iter);\n \n-        // Strategy for MySQL\n-        strategy = new CSVStrategy('\\t', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED, '\\\\', false, false, false, false);\n+        // Format for MySQL\n+        format = new CSVFormat('\\t', CSVFormat.ENCAPSULATOR_DISABLED, CSVFormat.COMMENTS_DISABLED, '\\\\', false, false, false, false);\n         doRandom(iter);\n     }\n \n     Random r = new Random();\n-    CSVStrategy strategy;\n+    CSVFormat format;\n \n     public void doRandom(int iter) throws Exception {\n         for (int i = 0; i < iter; i++) {\n         }\n \n         StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, strategy);\n+        CSVPrinter printer = new CSVPrinter(sw, format);\n \n         for (int i = 0; i < nLines; i++) {\n             // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n \n         StringReader reader = new StringReader(result);\n \n-        CSVParser parser = new CSVParser(reader, strategy);\n+        CSVParser parser = new CSVParser(reader, format);\n         String[][] parseResult = parser.getAllValues();\n \n         if (!equals(lines, parseResult)) {\n--- a/src/test/java/org/apache/commons/csv/CSVUtilsTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVUtilsTest.java\n \n     public void testParse6() throws IOException {\n         String[][] data = CSVUtils.parse(\"\");\n-        // default strategy is CSV, which ignores empty lines\n+        // default format is CSV, which ignores empty lines\n         assertEquals(0, data.length);\n     }\n ", "timestamp": 1320857649, "metainfo": ""}