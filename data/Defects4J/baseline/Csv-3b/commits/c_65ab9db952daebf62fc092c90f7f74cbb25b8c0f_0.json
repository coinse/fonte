{"sha": "65ab9db952daebf62fc092c90f7f74cbb25b8c0f", "log": "Make it easy to provide an alternative lexer if required  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n \n import static org.apache.commons.csv.Token.Type.*;\n \n-class CSVLexer {\n+class CSVLexer extends Lexer {\n \n     private final StringBuilder wsBuf = new StringBuilder();\n     \n-    private final CSVFormat format;\n+    CSVLexer(CSVFormat format, ExtendedBufferedReader in) {\n+        super(format, in);\n+    }\n     \n-    /** The input stream */\n-    private final ExtendedBufferedReader in;\n-\n-    CSVLexer(CSVFormat format, ExtendedBufferedReader in) {\n-        this.format = format;\n-        this.in = in;\n-    }\n-\n-    public int getLineNumber() {\n-        return in.getLineNumber();\n-    }\n-\n     /**\n      * Returns the next token.\n      * <p/>\n      * @return the next token found\n      * @throws java.io.IOException on stream access error\n      */\n+    @Override\n     Token nextToken(Token tkn) throws IOException {\n         wsBuf.setLength(0); // reuse\n \n         }\n \n         return tkn;\n-    }\n-\n-    private void trimTrailingSpaces(StringBuilder buffer) {\n-        int length = buffer.length();\n-        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n-            length = length - 1;\n-        }\n-        if (length != buffer.length()) {\n-            buffer.setLength(length);\n-        }\n     }\n \n     /**\n         }\n     }\n \n-    private int readEscape(int c) throws IOException {\n-        // assume c is the escape char (normally a backslash)\n-        c = in.read();\n-        switch (c) {\n-            case 'r':\n-                return '\\r';\n-            case 'n':\n-                return '\\n';\n-            case 't':\n-                return '\\t';\n-            case 'b':\n-                return '\\b';\n-            case 'f':\n-                return '\\f';\n-            default:\n-                return c;\n-        }\n-    }\n-\n-    /**\n-     * @return true if the given char is a whitespace character\n-     */\n-    private boolean isWhitespace(int c) {\n-        return (c != format.getDelimiter()) && Character.isWhitespace((char) c);\n-    }\n-\n-    /**\n-     * Greedy - accepts \\n, \\r and \\r\\n\n-     * This checker consumes silently the second control-character...\n-     *\n-     * @return true if the given character is a line-terminator\n-     */\n-    private boolean isEndOfLine(int c) throws IOException {\n-        // check if we have \\r\\n...\n-        if (c == '\\r' && in.lookAhead() == '\\n') {\n-            // note: does not change c outside of this method !!\n-            c = in.read();\n-        }\n-        return (c == '\\n' || c == '\\r');\n-    }\n-\n-    /**\n-     * @return true if the given character indicates end of file\n-     */\n-    private boolean isEndOfFile(int c) {\n-        return c == ExtendedBufferedReader.END_OF_STREAM;\n-    }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  */\n public class CSVParser implements Iterable<CSVRecord> {\n \n-    private final CSVLexer lexer;\n+    private final Lexer lexer;\n     private final Map<String, Integer> headerMapping;\n \n     // the following objects are shared to reduce garbage\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Abstract lexer class; contains common utility routines shared by lexers\n+ */\n+abstract class Lexer {\n+\n+    final CSVFormat format;\n+    \n+    /** The input stream */\n+    final ExtendedBufferedReader in;\n+\n+    Lexer(CSVFormat format, ExtendedBufferedReader in) {\n+        this.format = format;\n+        this.in = in;\n+    }\n+\n+    int getLineNumber() {\n+        return in.getLineNumber();\n+    }\n+\n+    int readEscape(int c) throws IOException {\n+        // assume c is the escape char (normally a backslash)\n+        c = in.read();\n+        switch (c) {\n+            case 'r':\n+                return '\\r';\n+            case 'n':\n+                return '\\n';\n+            case 't':\n+                return '\\t';\n+            case 'b':\n+                return '\\b';\n+            case 'f':\n+                return '\\f';\n+            default:\n+                return c;\n+        }\n+    }\n+\n+    void trimTrailingSpaces(StringBuilder buffer) {\n+        int length = buffer.length();\n+        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n+            length = length - 1;\n+        }\n+        if (length != buffer.length()) {\n+            buffer.setLength(length);\n+        }\n+    }\n+\n+    /**\n+     * @return true if the given char is a whitespace character\n+     */\n+    boolean isWhitespace(int c) {\n+        return (c != format.getDelimiter()) && Character.isWhitespace((char) c);\n+    }\n+\n+    /**\n+     * Greedy - accepts \\n, \\r and \\r\\n\n+     * This checker consumes silently the second control-character...\n+     *\n+     * @return true if the given character is a line-terminator\n+     */\n+    boolean isEndOfLine(int c) throws IOException {\n+        // check if we have \\r\\n...\n+        if (c == '\\r' && in.lookAhead() == '\\n') {\n+            // note: does not change c outside of this method !!\n+            c = in.read();\n+        }\n+        return (c == '\\n' || c == '\\r');\n+    }\n+\n+    /**\n+     * @return true if the given character indicates end of file\n+     */\n+    boolean isEndOfFile(int c) {\n+        return c == ExtendedBufferedReader.END_OF_STREAM;\n+    }\n+\n+    abstract Token nextToken(Token reusableToken) throws IOException;\n+}", "timestamp": 1332373604, "metainfo": ""}