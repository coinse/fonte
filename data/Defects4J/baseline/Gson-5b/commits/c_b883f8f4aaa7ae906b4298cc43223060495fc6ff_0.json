{"sha": "b883f8f4aaa7ae906b4298cc43223060495fc6ff", "log": "Add new \"Mode\" enum and carry mode through Gson so exclusion strategies know whether it is currently serializing or deserializing.  Deprecate old ExclusionStrategy code since this new approach is more powerful.", "commit": "\n--- a/gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java\n \n package com.google.gson;\n \n-\n /**\n  * Strategy for excluding anonymous and local classes.\n  *\n  * @author Joel Leitch\n  */\n-final class AnonymousAndLocalClassExclusionStrategy implements ExclusionStrategy {\n+final class AnonymousAndLocalClassExclusionStrategy implements ExclusionStrategy2 {\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     return isAnonymousOrLocal(f.getDeclaredClass());\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return isAnonymousOrLocal(clazz);\n   }\n \n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n import java.util.Collection;\n \n /**\n- * A wrapper class used to collect numerous {@link ExclusionStrategy} objects\n+ * A wrapper class used to collect numerous {@link ExclusionStrategy2} objects\n  * and perform a short-circuited OR operation.\n  *\n  * @author Joel Leitch\n  */\n-final class DisjunctionExclusionStrategy implements ExclusionStrategy {\n-  private final Collection<ExclusionStrategy> strategies;\n+final class DisjunctionExclusionStrategy implements ExclusionStrategy2 {\n+  private final Collection<ExclusionStrategy2> strategies;\n \n-  public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\n+  public DisjunctionExclusionStrategy(Collection<ExclusionStrategy2> strategies) {\n     Preconditions.checkNotNull(strategies);\n     this.strategies = strategies;\n   }\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n-    for (ExclusionStrategy strategy : strategies) {\n-      if (strategy.shouldSkipField(f)) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n+    for (ExclusionStrategy2 strategy : strategies) {\n+      if (strategy.shouldSkipField(f, mode)) {\n         return true;\n       }\n     }\n     return false;\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n-    for (ExclusionStrategy strategy : strategies) {\n-      if (strategy.shouldSkipClass(clazz)) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n+    for (ExclusionStrategy2 strategy : strategies) {\n+      if (strategy.shouldSkipClass(clazz, mode)) {\n         return true;\n       }\n     }\n--- a/gson/src/main/java/com/google/gson/ExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java\n  * @see GsonBuilder#setExclusionStrategies(ExclusionStrategy...)\n  *\n  * @since 1.4\n+ * @deprecated use the more powerful {@link ExclusionStrategy2} instead.\n  */\n+@Deprecated\n public interface ExclusionStrategy {\n \n   /**\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy2.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A strategy (or policy) definition that is used to decide whether or not a field or top-level\n+ * class should be serialized or deserialized as part of the JSON output/input. For serialization,\n+ * if the {@link #shouldSkipClass(Class, Mode)} method returns false then that class or field \n+ * type will not be part of the JSON output.  For deserialization, if\n+ * {@link #shouldSkipClass(Class, , Context)} returns false, then it will not be set as part of\n+ * the Java object structure.\n+ *\n+ * <p>The following are a few examples that shows how you can use this exclusion mechanism.\n+ *\n+ * <p><strong>Exclude fields and objects based on a particular class type for both serialization\n+ * and deserialization:</strong>\n+ * <pre class=\"code\">\n+ * public class SpecificClassExclusionStrategy implements ExclusionStrategy2 {\n+ *   private final Class&lt;?&gt; excludedThisClass;\n+ *\n+ *   public SpecificClassExclusionStrategy(Class&lt;?&gt; excludedThisClass) {\n+ *     this.excludedThisClass = excludedThisClass;\n+ *   }\n+ *\n+ *   public boolean shouldSkipClass(Class&lt;?&gt; clazz, Context context) {\n+ *     return excludedThisClass.equals(clazz);\n+ *   }\n+ *\n+ *   public boolean shouldSkipField(FieldAttributes f, Context context) {\n+ *     return excludedThisClass.equals(f.getDeclaredClass());\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p><strong>Excludes fields and objects based on a particular annotation for both serialization\n+ * and deserialization:</strong>\n+ * <pre class=\"code\">\n+ * public &#64interface FooAnnotation {\n+ *   // some implementation here\n+ * }\n+ *\n+ * // Excludes any field (or class) that is tagged with an \"&#64FooAnnotation\"\n+ * public class FooAnnotationExclusionStrategy implements ExclusionStrategy2 {\n+ *   public boolean shouldSkipClass(Class&lt;?&gt; clazz, Context context) {\n+ *     return clazz.getAnnotation(FooAnnotation.class) != null;\n+ *   }\n+ *\n+ *   public boolean shouldSkipField(FieldAttributes f, Context context) {\n+ *     return f.getAnnotation(FooAnnotation.class) != null;\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p><strong>Exclude fields and objects based on a particular class type for serialization\n+ * only:</strong>\n+ * <pre class=\"code\">\n+ * public class SpecificClassExclusionStrategy implements ExclusionStrategy2 {\n+ *   private final Class&lt;?&gt; excludedThisClass;\n+ *\n+ *   public SpecificClassExclusionStrategy(Class&lt;?&gt; excludedThisClass) {\n+ *     this.excludedThisClass = excludedThisClass;\n+ *   }\n+ *\n+ *   public boolean shouldSkipClass(Class&lt;?&gt; clazz, Context context) {\n+ *     if (context == Context.SERIALIZE) {\n+ *       return excludedThisClass.equals(clazz);\n+ *     } else {\n+ *       return false;\n+ *     }\n+ *   }\n+ *\n+ *   public boolean shouldSkipField(FieldAttributes f, Context context) {\n+ *   if (context == Context.SERIALIZE) {\n+ *       return excludedThisClass.equals(f.getDeclaredClass());\n+ *     } else {\n+ *       return false;\n+ *     }\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>Now if you want to configure {@code Gson} to use a user defined exclusion strategy, then\n+ * the {@code GsonBuilder} is required. The following is an example of how you can use the\n+ * {@code GsonBuilder} to configure Gson to use one of the above sample:\n+ * <pre class=\"code\">\n+ * ExclusionStrategy2 excludeStrings = new UserDefinedExclusionStrategy(String.class);\n+ * Gson gson = new GsonBuilder()\n+ *     .setExclusionStrategies(excludeStrings)\n+ *     .create();\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ * \n+ * @since 1.7\n+ */\n+public interface ExclusionStrategy2 {\n+\n+  /**\n+   * @param f the field object that is under test\n+   * @param mode the current mode the Gson is running in\n+   * @return true if the field should be ignored; otherwise false\n+   */\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode);\n+\n+  /**\n+   * @param clazz the class object that is under test\n+   * @param mode the current mode the Gson is running in\n+   * @return true if the class should be ignored; otherwise false\n+   */\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy2Adapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Adapts the old {@link ExclusionStrategy} into the newer {@link ExclusionStrategy2} type.\n+ *\n+ * @author Joel Leitch\n+ */\n+class ExclusionStrategy2Adapter implements ExclusionStrategy2 {\n+  private final ExclusionStrategy strategy;\n+  \n+  public ExclusionStrategy2Adapter(ExclusionStrategy strategy) {\n+    Preconditions.checkNotNull(strategy);\n+    this.strategy = strategy;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n+    return strategy.shouldSkipClass(clazz);\n+  }\n+\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n+    return strategy.shouldSkipField(f);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ExposeAnnotationExclusionStrategy.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Expose;\n+\n+/**\n+ * Excludes fields that do not have the {@link Expose} annotation\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ExposeAnnotationExclusionStrategy implements ExclusionStrategy2 {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n+    return false;\n+  }\n+\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n+    Expose annotation = f.getAnnotation(Expose.class);\n+    if (annotation == null) {\n+      return true;\n+    }\n+    \n+    if (mode == Mode.SERIALIZE) {\n+      return !annotation.serialize();\n+    } else if (mode == Mode.DESERIALIZE) {\n+      return !annotation.deserialize();\n+    }\n+\n+    return false;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   static final FieldNamingStrategy2 DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n \n-  private static final ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY =\n-      createExclusionStrategy(VersionConstants.IGNORE_VERSIONS);\n+  private static final ExclusionStrategy2 DEFAULT_EXCLUSION_STRATEGY = createExclusionStrategy();\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n-  private final ExclusionStrategy serializationStrategy;\n-\n-  private final ExclusionStrategy deserializationStrategy;\n-\n+  private final ExclusionStrategy2 exclusionStrategy;\n   private final FieldNamingStrategy2 fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n \n    * </ul>\n    */\n   public Gson() {\n-    this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n+    this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\n     new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n     false, DefaultTypeAdapters.getAllDefaultSerializers(),\n     DefaultTypeAdapters.getAllDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false);\n   }\n \n-  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\n-       FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor,\n-       boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n-       boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\n-    this.serializationStrategy = serializationStrategy;\n-    this.deserializationStrategy = deserializationStrategy;\n+  Gson(ExclusionStrategy2 exclusionStrategy, FieldNamingStrategy2 fieldNamingPolicy,\n+      MappedObjectConstructor objectConstructor, boolean serializeNulls,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\n+    this.exclusionStrategy = exclusionStrategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.serializeNulls = serializeNulls;\n     this.prettyPrinting = prettyPrinting;\n   }\n \n-  private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\n+  private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy2 strategy) {\n     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n   }\n \n-  private static ExclusionStrategy createExclusionStrategy(double version) {\n-    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+  private static ExclusionStrategy2 createExclusionStrategy() {\n+    List<ExclusionStrategy2> strategies = new LinkedList<ExclusionStrategy2>();\n     strategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\n     strategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\n     strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\n-    if (version != VersionConstants.IGNORE_VERSIONS) {\n-      strategies.add(new VersionExclusionStrategy(version));\n-    }\n     return new DisjunctionExclusionStrategy(strategies);\n   }\n \n       return JsonNull.createJsonNull();\n     }\n     JsonSerializationContextDefault context = new JsonSerializationContextDefault(\n-        createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\n+        createDefaultObjectNavigatorFactory(exclusionStrategy), serializeNulls, serializers);\n     return context.serialize(src, typeOfSrc, true);\n   }\n \n       return null;\n     }\n     JsonDeserializationContext context = new JsonDeserializationContextDefault(\n-        createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers,\n+        createDefaultObjectNavigatorFactory(exclusionStrategy), deserializers,\n         objectConstructor);\n     T target = (T) context.deserialize(json, typeOfT);\n     return target;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n public final class GsonBuilder {\n   private static final InnerClassExclusionStrategy innerClassExclusionStrategy =\n       new InnerClassExclusionStrategy();\n-  private static final ExposeAnnotationSerializationExclusionStrategy\n-    exposeAnnotationSerializationExclusionStrategy =\n-      new ExposeAnnotationSerializationExclusionStrategy();\n-  private static final ExposeAnnotationDeserializationExclusionStrategy\n-    exposeAnnotationDeserializationExclusionStrategy =\n-      new ExposeAnnotationDeserializationExclusionStrategy();\n-\n-  private final Collection<ExclusionStrategy> exclusionStrategies =\n-      new HashSet<ExclusionStrategy>();\n+  private static final ExposeAnnotationExclusionStrategy exposeAnnotationExclusionStrategy =\n+      new ExposeAnnotationExclusionStrategy();\n+\n+  private final Collection<ExclusionStrategy2> exclusionStrategies =\n+      new HashSet<ExclusionStrategy2>();\n \n   private double ignoreVersionsAfter;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n    * @param strategies the set of strategy object to apply during object (de)serialization.\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.4\n-   */\n+   * @deprecated convert your {@code strategies} to {@link ExclusionStrategy2} and use the\n+   *    {@link #setExclusionStrategies(ExclusionStrategy2...) method instead.\n+   */\n+  @Deprecated\n   public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\n     for (ExclusionStrategy strategy : strategies) {\n+      exclusionStrategies.add(new ExclusionStrategy2Adapter(strategy));\n+    }\n+    return this;\n+  }\n+  \n+  /**\n+   * Configures Gson to apply a set of exclusion strategies during both serialization and\n+   * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.\n+   * This means that if one of the {@code strategies} suggests that a field (or class) should be\n+   * skipped in the current mode then that field (or object) is skipped during the particular Gson\n+   * mode.\n+   *\n+   * @param strategies the set of strategy object to apply during object (de)serialization.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.7\n+   */\n+  public GsonBuilder setExclusionStrategies(ExclusionStrategy2... strategies) {\n+    for (ExclusionStrategy2 strategy : strategies) {\n       exclusionStrategies.add(strategy);\n     }\n     return this;\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<ExclusionStrategy> serializationStrategies =\n-        new LinkedList<ExclusionStrategy>(exclusionStrategies);\n-    List<ExclusionStrategy> deserializationStrategies =\n-        new LinkedList<ExclusionStrategy>(exclusionStrategies);\n-\n-    serializationStrategies.add(modifierBasedExclusionStrategy);\n-    deserializationStrategies.add(modifierBasedExclusionStrategy);\n+    List<ExclusionStrategy2> strategies =\n+        new LinkedList<ExclusionStrategy2>(exclusionStrategies);\n+    strategies.add(modifierBasedExclusionStrategy);\n \n     if (!serializeInnerClasses) {\n-      serializationStrategies.add(innerClassExclusionStrategy);\n-      deserializationStrategies.add(innerClassExclusionStrategy);\n+      strategies.add(innerClassExclusionStrategy);\n     }\n     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n-      serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n-      deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n+      strategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n     }\n     if (excludeFieldsWithoutExposeAnnotation) {\n-      serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy);\n-      deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy);\n-    }\n-    ExclusionStrategy serializationExclusionStrategy =\n-      new DisjunctionExclusionStrategy(serializationStrategies);\n-    ExclusionStrategy deserializationExclusionStrategy =\n-      new DisjunctionExclusionStrategy(deserializationStrategies);\n+      strategies.add(exposeAnnotationExclusionStrategy);\n+    }\n+    ExclusionStrategy2 exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n \n     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers =\n       DefaultTypeAdapters.DEFAULT_HIERARCHY_SERIALIZERS.copyOf();\n \n     MappedObjectConstructor objConstructor = new MappedObjectConstructor(customInstanceCreators);\n \n-    Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy,\n-        fieldNamingPolicy, objConstructor, serializeNulls, customSerializers,\n-        customDeserializers, generateNonExecutableJson, escapeHtmlChars, prettyPrinting);\n+    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor, serializeNulls,\n+        customSerializers, customDeserializers, generateNonExecutableJson, escapeHtmlChars,\n+        prettyPrinting);\n     return gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n  *\n  * @author Joel Leitch\n  */\n-class InnerClassExclusionStrategy implements ExclusionStrategy {\n+class InnerClassExclusionStrategy implements ExclusionStrategy2 {\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     return isInnerClass(f.getDeclaredClass());\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return isInnerClass(clazz);\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n     }\n     return target;\n   }\n+  \n+  public Mode getMode() {\n+    return Mode.DESERIALIZE;\n+  }\n \n   protected abstract T constructTarget();\n \n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n   public Object getTarget() {\n     return null;\n+  }\n+  \n+  public Mode getMode() {\n+    return Mode.SERIALIZE;\n   }\n \n   public void start(ObjectTypePair node) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Mode.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Defines the current context of Gson so that common code for serializing and deserializing can\n+ * distinguish between the two modes.\n+ *\n+ * @author Joel Leitch\n+ * \n+ * @since 1.7\n+ */\n+public enum Mode {\n+  SERIALIZE,\n+  DESERIALIZE;\n+}\n--- a/gson/src/main/java/com/google/gson/ModifierBasedExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ModifierBasedExclusionStrategy.java\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n-final class ModifierBasedExclusionStrategy implements ExclusionStrategy {\n+final class ModifierBasedExclusionStrategy implements ExclusionStrategy2 {\n   private final Collection<Integer> modifiers;\n \n   public ModifierBasedExclusionStrategy(int... modifiers) {\n     }\n   }\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     for (int modifier : modifiers) {\n       if (f.hasModifier(modifier)) {\n         return true;\n     return false;\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return false;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/NullExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/NullExclusionStrategy.java\n \n package com.google.gson;\n \n-\n /**\n- * This acts as a \"Null Object\" pattern for the {@link ExclusionStrategy}.\n+ * This acts as a \"Null Object\" pattern for the {@link ExclusionStrategy2}.\n  * Passing an instance of this class into the {@link ObjectNavigator} will\n  * make the {@link ObjectNavigator} parse/visit every field of the object\n  * being navigated.\n  *\n  * @author Joel Leitch\n  */\n-final class NullExclusionStrategy implements ExclusionStrategy {\n+final class NullExclusionStrategy implements ExclusionStrategy2 {\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     return false;\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return false;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n     public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField,\n         Object parent);\n \n+    void visitPrimitive(Object primitive);\n+    \n     /**\n      * Retrieve the current target\n      */\n     Object getTarget();\n-\n-    void visitPrimitive(Object primitive);\n+    \n+    Mode getMode();\n   }\n \n-  private final ExclusionStrategy exclusionStrategy;\n+  private final ExclusionStrategy2 exclusionStrategy;\n   private final ObjectTypePair objTypePair;\n \n   /**\n    *          the concrete strategy object to be used to filter out fields of an\n    *          object.\n    */\n-  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\n+  ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy2 exclusionStrategy) {\n     Preconditions.checkNotNull(exclusionStrategy);\n \n     this.objTypePair = objTypePair;\n    * does not get visited.\n    */\n   public void accept(Visitor visitor) {\n-    if (exclusionStrategy.shouldSkipClass(Types.getRawType(objTypePair.type))) {\n+    if (exclusionStrategy.shouldSkipClass(Types.getRawType(objTypePair.type), visitor.getMode())) {\n       return;\n     }\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n   }\n \n   private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\n+    Mode mode = visitor.getMode();\n     Field[] fields = clazz.getDeclaredFields();\n     AccessibleObject.setAccessible(fields, true);\n     for (Field f : fields) {\n       FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n-      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n-          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n+      if (exclusionStrategy.shouldSkipField(fieldAttributes, mode)\n+          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass(), mode)) {\n         continue; // skip\n       }\n       Type declaredTypeOfField = getTypeInfoForField(f, objTypePair.type);\n--- a/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n \n /**\n  * A factory class used to simplify {@link ObjectNavigator} creation.\n- * This object holds on to a reference of the {@link ExclusionStrategy}\n+ * This object holds on to a reference of the {@link ExclusionStrategy2}\n  * that you'd like to use with the {@link ObjectNavigator}.\n  *\n  * @author Joel Leitch\n  */\n final class ObjectNavigatorFactory {\n-  private final ExclusionStrategy strategy;\n+  private final ExclusionStrategy2 strategy;\n   private final FieldNamingStrategy2 fieldNamingPolicy;\n \n   /**\n    * @param fieldNamingPolicy the naming policy that should be applied to field\n    *        names\n    */\n-  public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) {\n+  public ObjectNavigatorFactory(ExclusionStrategy2 strategy, FieldNamingStrategy2 fieldNamingPolicy) {\n     Preconditions.checkNotNull(fieldNamingPolicy);\n     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\n     this.fieldNamingPolicy = fieldNamingPolicy;\n--- a/gson/src/main/java/com/google/gson/SyntheticFieldExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/SyntheticFieldExclusionStrategy.java\n  *\n  * @since 1.4\n  */\n-class SyntheticFieldExclusionStrategy implements ExclusionStrategy {\n+class SyntheticFieldExclusionStrategy implements ExclusionStrategy2 {\n   private final boolean skipSyntheticFields;\n \n   SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) {\n     this.skipSyntheticFields = skipSyntheticFields;\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return false;\n   }\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     return skipSyntheticFields && f.isSynthetic();\n   }\n \n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n  *\n  * @author Joel Leitch\n  */\n-final class VersionExclusionStrategy implements ExclusionStrategy {\n+final class VersionExclusionStrategy implements ExclusionStrategy2 {\n   private final double version;\n \n   public VersionExclusionStrategy(double version) {\n     this.version = version;\n   }\n \n-  public boolean shouldSkipField(FieldAttributes f) {\n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n     return !isValidVersion(f.getAnnotation(Since.class), f.getAnnotation(Until.class));\n   }\n \n-  public boolean shouldSkipClass(Class<?> clazz) {\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n     return !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class));\n   }\n \n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n  */\n public class DisjunctionExclusionStrategyTest extends TestCase {\n \n-  private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);\n-  private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);\n+  private static final ExclusionStrategy2 FALSE_STRATEGY = \n+      new MockExclusionStrategy2(false, false, null);\n+  private static final ExclusionStrategy2 TRUE_STRATEGY = \n+      new MockExclusionStrategy2(true, true, null);\n+  \n   private static final Class<?> CLAZZ = String.class;\n   private static final FieldAttributes FIELD = new FieldAttributes(CLAZZ, CLAZZ.getFields()[0]);\n \n   public void testBadInstantiation() throws Exception {\n     try {\n-      List<ExclusionStrategy> constructorParam = null;\n+      List<ExclusionStrategy2> constructorParam = null;\n       new DisjunctionExclusionStrategy(constructorParam);\n       fail(\"Should throw an exception\");\n     } catch (IllegalArgumentException expected) { }\n   }\n \n   public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {\n-    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    List<ExclusionStrategy2> strategies = new LinkedList<ExclusionStrategy2>();\n     strategies.add(FALSE_STRATEGY);\n     strategies.add(TRUE_STRATEGY);\n     DisjunctionExclusionStrategy strategy = new DisjunctionExclusionStrategy(strategies);\n \n-    assertTrue(strategy.shouldSkipClass(CLAZZ));\n-    assertTrue(strategy.shouldSkipField(FIELD));\n+    assertTrue(strategy.shouldSkipClass(CLAZZ, Mode.SERIALIZE));\n+    assertTrue(strategy.shouldSkipField(FIELD, Mode.SERIALIZE));\n   }\n \n   public void testSkipFieldsWithFalseOnly() throws Exception {\n-    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    List<ExclusionStrategy2> strategies = new LinkedList<ExclusionStrategy2>();\n     strategies.add(FALSE_STRATEGY);\n     DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(strategies);\n \n-    assertFalse(strategy.shouldSkipClass(CLAZZ));\n-    assertFalse(strategy.shouldSkipField(FIELD));\n+    assertFalse(strategy.shouldSkipClass(CLAZZ, Mode.SERIALIZE));\n+    assertFalse(strategy.shouldSkipField(FIELD, Mode.SERIALIZE));\n   }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ExclusionStrategy2AdapterTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link ExclusionStrategy2Adapter} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ExclusionStrategy2AdapterTest extends TestCase {\n+\n+  public void testConstruction() throws Exception {\n+    try {\n+      new ExclusionStrategy2Adapter(null);\n+      fail();\n+    } catch (IllegalArgumentException expected) {}\n+  }\n+\n+  public void testAdapterDoesSameForBothModes() throws Exception {\n+    ExclusionStrategy2Adapter adapter =\n+        new ExclusionStrategy2Adapter(new MockExclusionStrategy(true, false));\n+    assertTrue(adapter.shouldSkipClass(String.class, Mode.DESERIALIZE));\n+    assertTrue(adapter.shouldSkipClass(String.class, Mode.SERIALIZE));\n+\n+    Field f = String.class.getFields()[0];\n+    assertFalse(adapter.shouldSkipField(new FieldAttributes(String.class, f), Mode.DESERIALIZE));\n+    assertFalse(adapter.shouldSkipField(new FieldAttributes(String.class, f), Mode.SERIALIZE));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+import com.google.gson.annotations.Expose;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for the {@link ExposeAnnotationExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ExposeAnnotationExclusionStrategyTest extends TestCase {\n+  private ExposeAnnotationExclusionStrategy strategy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    strategy = new ExposeAnnotationExclusionStrategy();\n+  }\n+\n+  public void testNeverSkipClasses() throws Exception {\n+    assertFalse(strategy.shouldSkipClass(MockObject.class, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipClass(MockObject.class, Mode.SERIALIZE));\n+  }\n+\n+  public void testSkipNonAnnotatedFields() throws Exception {\n+    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n+    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n+    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n+  }\n+\n+  public void testSkipExplicitlySkippedFields() throws Exception {\n+    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n+    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n+    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n+  }\n+\n+  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n+    FieldAttributes f = createFieldAttributes(\"exposedField\");\n+    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n+  }\n+\n+  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n+    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n+    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n+  }\n+  \n+  public void testDifferentSerializeAndDeserializeField() throws Exception {\n+    FieldAttributes f = createFieldAttributes(\"explicitlyDifferentModeField\");\n+    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n+  }\n+  \n+  private static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n+    Field f = MockObject.class.getField(fieldName);\n+    return new FieldAttributes(MockObject.class, f);\n+  }\n+  \n+  @SuppressWarnings(\"unused\")\n+  private static class MockObject {\n+    @Expose\n+    public final int exposedField = 0;\n+\n+    @Expose(serialize=true, deserialize=true)\n+    public final int explicitlyExposedField = 0;\n+\n+    @Expose(serialize=false, deserialize=false)\n+    public final int explicitlyHiddenField = 0;\n+    \n+    @Expose(serialize=true, deserialize=false)\n+    public final int explicitlyDifferentModeField = 0;\n+\n+    public final int hiddenField = 0;\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n public class FunctionWithInternalDependenciesTest extends TestCase {\n \n   public void testAnonymousLocalClassesSerialization() throws Exception {\n-    LinkedList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    LinkedList<ExclusionStrategy2> strategies = new LinkedList<ExclusionStrategy2>();\n     strategies.add(new SyntheticFieldExclusionStrategy(true));\n     strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));\n-    ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n-    Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,\n+    ExclusionStrategy2 exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n+    Gson gson = new Gson(exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,\n         new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n         false, DefaultTypeAdapters.getDefaultSerializers(),\n         DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE, true,\n     assertEquals(\"{}\", json);\n   }\n \n-  private static class UserDefinedExclusionStrategy implements ExclusionStrategy {\n+  private static class UserDefinedExclusionStrategy implements ExclusionStrategy2 {\n     private final Class<?> excludedThisClass;\n \n     UserDefinedExclusionStrategy(Class<?> excludedThisClass) {\n       this.excludedThisClass = excludedThisClass;\n     }\n \n-    public boolean shouldSkipClass(Class<?> clazz) {\n+    public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n       return excludedThisClass.equals(clazz);\n     }\n \n-    public boolean shouldSkipField(FieldAttributes f) {\n+    public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n       return excludedThisClass.equals(f.getDeclaredClass());\n     }\n \n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n   public void testExcludeInnerClassObject() throws Exception {\n     Class<?> clazz = innerClass.getClass();\n-    assertTrue(strategy.shouldSkipClass(clazz));\n+    assertTrue(strategy.shouldSkipClass(clazz, Mode.SERIALIZE));\n+    assertTrue(strategy.shouldSkipClass(clazz, Mode.DESERIALIZE));\n   }\n \n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f), Mode.SERIALIZE));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f), Mode.DESERIALIZE));\n   }\n \n   public void testIncludeStaticNestedClassObject() throws Exception {\n     Class<?> clazz = staticNestedClass.getClass();\n-    assertFalse(strategy.shouldSkipClass(clazz));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.SERIALIZE));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.DESERIALIZE));\n   }\n \n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f), Mode.SERIALIZE));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f), Mode.DESERIALIZE));\n   }\n \n   class InnerClass {\n--- a/gson/src/test/java/com/google/gson/MockExclusionStrategy.java\n+++ b/gson/src/test/java/com/google/gson/MockExclusionStrategy.java\n  */\n \n package com.google.gson;\n-\n \n /**\n  * This is a configurable {@link ExclusionStrategy} that can be used for\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/MockExclusionStrategy2.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * This is a configurable {@link ExclusionStrategy2} that can be used for\n+ * unit testing.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class MockExclusionStrategy2 implements ExclusionStrategy2 {\n+  private final MockExclusionStrategy strategy;\n+  private final Mode mode;\n+\n+  public MockExclusionStrategy2(boolean skipClass, boolean skipField, Mode mode) {\n+    this.strategy = new MockExclusionStrategy(skipClass, skipField);\n+    this.mode = mode;\n+  }\n+  \n+  public boolean shouldSkipField(FieldAttributes f, Mode mode) {\n+    if (this.mode == null || this.mode == mode) {\n+      return strategy.shouldSkipField(f);\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz, Mode mode) {\n+    if (this.mode == null || this.mode == mode) {\n+      return strategy.shouldSkipClass(clazz);\n+    } else {\n+      return false;\n+    }\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n   }\n \n   public void testNeverSkipsClass() throws Exception {\n-    assertFalse(strategy.shouldSkipClass(String.class));\n+    assertFalse(strategy.shouldSkipClass(String.class, Mode.SERIALIZE));\n+    assertFalse(strategy.shouldSkipClass(String.class, Mode.DESERIALIZE));\n   }\n \n   public void testNeverSkipsField() throws Exception {\n     assertFalse(strategy.shouldSkipField(\n-        new FieldAttributes(String.class, String.class.getFields()[0])));\n+        new FieldAttributes(String.class, String.class.getFields()[0]),\n+        Mode.SERIALIZE));\n+    assertFalse(strategy.shouldSkipField(\n+        new FieldAttributes(String.class, String.class.getFields()[0]),\n+        Mode.DESERIALIZE));\n   }\n }\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n \n-    assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.SERIALIZE));\n+\n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+    assertFalse(strategy.shouldSkipField(fieldAttributes, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipField(fieldAttributes, Mode.SERIALIZE));\n   }\n \n   public void testClassAndFieldAreBehindInVersion() throws Exception {\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n \n-    assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipClass(clazz, Mode.SERIALIZE));\n+    \n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+    assertFalse(strategy.shouldSkipField(fieldAttributes, Mode.DESERIALIZE));\n+    assertFalse(strategy.shouldSkipField(fieldAttributes, Mode.SERIALIZE));\n   }\n \n   public void testClassAndFieldAreAheadInVersion() throws Exception {\n     Field f = clazz.getField(\"someField\");\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n \n-    assertTrue(strategy.shouldSkipClass(clazz));\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n+    assertTrue(strategy.shouldSkipClass(clazz, Mode.DESERIALIZE));\n+    assertTrue(strategy.shouldSkipClass(clazz, Mode.SERIALIZE));\n+    \n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n+    assertTrue(strategy.shouldSkipField(fieldAttributes, Mode.DESERIALIZE));\n+    assertTrue(strategy.shouldSkipField(fieldAttributes, Mode.SERIALIZE));\n   }\n \n   @Since(VERSION)\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n   // millisecond portion.\n   @SuppressWarnings(\"deprecation\")\n   private void assertEqualsDate(Date date, int year, int month, int day) {\n-      assertEquals(year-1900, date.getYear());\n-      assertEquals(month, date.getMonth());\n-      assertEquals(day, date.getDate());\n+    assertEquals(year-1900, date.getYear());\n+    assertEquals(month, date.getMonth());\n+    assertEquals(day, date.getDate());\n   }\n \n   @SuppressWarnings(\"deprecation\")\n--- a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n package com.google.gson.functional;\n \n import com.google.gson.ExclusionStrategy;\n+import com.google.gson.ExclusionStrategy2;\n import com.google.gson.FieldAttributes;\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonPrimitive;\n+import com.google.gson.MockExclusionStrategy;\n+import com.google.gson.MockExclusionStrategy2;\n+import com.google.gson.Mode;\n \n import junit.framework.TestCase;\n \n \n /**\n  * Performs some functional tests when Gson is instantiated with some common user defined\n- * {@link ExclusionStrategy} objects.\n+ * {@link ExclusionStrategy} and {@link ExclusionStrategy2} objects.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n   }\n \n   public void testExclusionStrategySerialization() throws Exception {\n+    Gson gson = createGson(new MyExclusionStrategy(String.class));\n     String json = gson.toJson(src);\n     assertFalse(json.contains(\"\\\"stringField\\\"\"));\n     assertFalse(json.contains(\"\\\"annotatedField\\\"\"));\n     assertTrue(json.contains(\"\\\"longField\\\"\"));\n+  }\n+  \n+  public void testExclusionStrategy2Serialization() throws Exception {\n+    Gson gson = createGson(new MockExclusionStrategy2(false, true, Mode.DESERIALIZE));\n+    String json = gson.toJson(src);\n+    assertTrue(json.contains(\"\\\"stringField\\\"\"));\n+    assertTrue(json.contains(\"\\\"annotatedField\\\"\"));\n+    assertTrue(json.contains(\"\\\"longField\\\"\"));\n+    \n+    gson = createGson(new MockExclusionStrategy2(false, true, Mode.SERIALIZE));\n+    json = gson.toJson(src);\n+    assertFalse(json.contains(\"\\\"stringField\\\"\"));\n+    assertFalse(json.contains(\"\\\"annotatedField\\\"\"));\n+    assertFalse(json.contains(\"\\\"longField\\\"\"));\n   }\n \n   public void testExclusionStrategyDeserialization() throws Exception {\n     assertEquals(src.stringField, target.stringField);\n   }\n \n+  private static Gson createGson(ExclusionStrategy exclusionStrategy) {\n+    return new GsonBuilder()\n+        .setExclusionStrategies(exclusionStrategy)\n+        .serializeNulls()\n+        .create();\n+  }\n+  \n+  private static Gson createGson(ExclusionStrategy2 exclusionStrategy) {\n+    return new GsonBuilder()\n+        .setExclusionStrategies(exclusionStrategy)\n+        .serializeNulls()\n+        .create();\n+  }\n+  \n   @Retention(RetentionPolicy.RUNTIME)\n   @Target({ElementType.FIELD})\n   private static @interface Foo {", "timestamp": 1295734506, "metainfo": ""}