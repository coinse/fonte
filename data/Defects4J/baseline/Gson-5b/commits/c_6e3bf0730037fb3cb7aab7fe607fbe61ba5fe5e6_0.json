{"sha": "6e3bf0730037fb3cb7aab7fe607fbe61ba5fe5e6", "log": "Added support for runtime type determination while serializing array elements. Created a utility class Reflection to hold methods to find Runtime type and creating new Instances.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n       TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));\n       @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n       TypeAdapter<T> result = new ArrayTypeAdapter(\n-          componentTypeAdapter, $Gson$Types.getRawType(componentType));\n+          context, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n       return result;\n     }\n   };\n \n+  private final MiniGson context;\n   private final Class<E> componentType;\n   private final TypeAdapter<E> componentTypeAdapter;\n \n-  public ArrayTypeAdapter(TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+  public ArrayTypeAdapter(MiniGson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+    this.context = context;\n     this.componentTypeAdapter = componentTypeAdapter;\n     this.componentType = componentType;\n   }\n     writer.beginArray();\n     for (int i = 0, length = Array.getLength(array); i < length; i++) {\n       final E value = (E) Array.get(array, i);\n-      componentTypeAdapter.write(writer, value);\n+      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(componentType, array, value);\n+      TypeAdapter t = runtimeType != componentType ?\n+          context.getAdapter(TypeToken.get(runtimeType)) : componentTypeAdapter;\n+      t.write(writer, value);\n     }\n     writer.endArray();\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n       return null;\n     }\n \n-    Collection<E> collection = MiniGson.newInstance(constructor);\n+    Collection<E> collection = Reflection.newInstance(constructor);\n     reader.beginArray();\n     while (reader.hasNext()) {\n       E instance = elementTypeAdapter.read(reader);\n--- a/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n \n /**\n  * A basic binding between JSON and Java objects.\n       factories.add(ReflectiveTypeAdapter.FACTORY);\n     }\n     this.factories = Collections.unmodifiableList(factories);\n-  }\n-\n-  // TODO: this should use Joel's unsafe constructor stuff\n-  static <T> T newInstance(Constructor<T> constructor) {\n-    try {\n-      Object[] args = null;\n-      return constructor.newInstance(args);\n-    } catch (InstantiationException e) {\n-      // TODO: JsonParseException ?\n-      throw new RuntimeException(e);\n-    } catch (InvocationTargetException e) {\n-      // TODO: don't wrap if cause is unchecked!\n-      // TODO: JsonParseException ?\n-      throw new RuntimeException(e.getTargetException());\n-    } catch (IllegalAccessException e) {\n-      throw new AssertionError(e);\n-    }\n   }\n \n   /**\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/Reflection.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.internal.bind;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n+final class Reflection {\n+  /**\n+   * Finds a compatible runtime type if it is more specific\n+   * In case of a field of an object, parent is the object instance, and child is the field value.\n+   * In case of an Array, parent is the array instance, and the child is the array element.\n+   */\n+  public static Type getRuntimeTypeIfMoreSpecific(Type type, Object parent, Object child) {\n+    if (parent == null || child == null) {\n+      return type;\n+    }\n+    if (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>) {\n+      type = (Class<?>) child.getClass();\n+    }\n+    return type;\n+  }\n+\n+  // TODO: this should use Joel's unsafe constructor stuff\n+  public static <T> T newInstance(Constructor<T> constructor) {\n+    try {\n+      Object[] args = null;\n+      return constructor.newInstance(args);\n+    } catch (InstantiationException e) {\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e);\n+    } catch (InvocationTargetException e) {\n+      // TODO: don't wrap if cause is unchecked!\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e.getTargetException());\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError(e);\n+    }\n+  }\n+\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n \n     T instance;\n     if (constructor != null) {\n-      instance = (T) MiniGson.newInstance(constructor);\n+      instance = (T) Reflection.newInstance(constructor);\n     } else {\n       try {\n         instance = (T) unsafeAllocator.newInstance(rawType);\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n         Type declaredTypeOfField = fieldType.getType();\n-        Type resolvedTypeOfField = getMoreSpecificType(declaredTypeOfField, value, fieldValue);\n+        Type resolvedTypeOfField = Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, value, fieldValue);\n         TypeAdapter t = resolvedTypeOfField != declaredTypeOfField ?\n             context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n         t.write(writer, fieldValue);\n         field.set(value, fieldValue);\n       }\n     };\n-  }\n-\n-  private static Type getMoreSpecificType(Type type, Object obj, Object fieldValue) {\n-    if (obj == null || fieldValue == null) {\n-      return type;\n-    }\n-    if (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>) {\n-      type = (Class<?>) fieldValue.getClass();\n-    }\n-    return type;\n   }\n \n   public static class FactoryImpl implements Factory {\n--- a/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java\n       return null;\n     }\n \n-    Map<String, V> map = MiniGson.newInstance(constructor);\n+    Map<String, V> map = Reflection.newInstance(constructor);\n     reader.beginObject();\n     while (reader.hasNext()) {\n       String key = reader.nextName();", "timestamp": 1312498926, "metainfo": ""}