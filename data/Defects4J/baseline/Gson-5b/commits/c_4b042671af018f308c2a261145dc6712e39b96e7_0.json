{"sha": "4b042671af018f308c2a261145dc6712e39b96e7", "log": "Cleanup after experimenting with specializing BoundField by type (ie. Field.setInt() to avoid autoboxing)", "commit": "\n--- a/extras/src/main/java/com/google/gson/mini/MiniGson.java\n+++ b/extras/src/main/java/com/google/gson/mini/MiniGson.java\n \n   private MiniGson(Builder builder) {\n     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n-    factories.addAll(builder.factories);\n     factories.add(TypeAdapters.BOOLEAN_FACTORY);\n     factories.add(TypeAdapters.INTEGER_FACTORY);\n     factories.add(TypeAdapters.DOUBLE_FACTORY);\n     factories.add(TypeAdapters.LONG_FACTORY);\n     factories.add(TypeAdapters.STRING_FACTORY);\n+    factories.addAll(builder.factories);\n     factories.add(CollectionTypeAdapter.FACTORY);\n     factories.add(StringToValueMapTypeAdapter.FACTORY);\n     factories.add(ArrayTypeAdapter.FACTORY);\n   // TODO: this should use Joel's unsafe constructor stuff\n   static <T> T newInstance(Constructor<T> constructor) {\n     try {\n-      return constructor.newInstance();\n+      Object[] args = null;\n+      return constructor.newInstance(args);\n     } catch (InstantiationException e) {\n       // TODO: JsonParseException ?\n       throw new RuntimeException(e);\n \n     Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n     @SuppressWarnings(\"unchecked\") // the key and value type parameters always agree\n-        FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n+    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n     if (ongoingCall != null) {\n       return ongoingCall;\n     }\n--- a/extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java\n       return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n     }\n \n-    private Map<String, BoundField<?>> getBoundFields(\n+    private Map<String, BoundField> getBoundFields(\n         MiniGson context, TypeToken<?> type, Class<?> raw) {\n-      Map<String, BoundField<?>> result = new LinkedHashMap<String, BoundField<?>>();\n+      Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n       while (raw != Object.class) {\n         for (Field field : raw.getDeclaredFields()) {\n           field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n           Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-          BoundField<?> boundField = BoundField.create(context, field, TypeToken.get(fieldType));\n+          BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType));\n           result.put(boundField.name, boundField);\n         }\n         type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n   };\n \n   private final Constructor<? super T> constructor;\n-  private final Map<String, BoundField<?>> map;\n-  private final BoundField<?>[] boundFields;\n+  private final Map<String, BoundField> map;\n+  private final BoundField[] boundFields;\n \n-  ReflectiveTypeAdapter(Constructor<? super T> constructor, Map<String, BoundField<?>> map) {\n+  ReflectiveTypeAdapter(Constructor<? super T> constructor, Map<String, BoundField> map) {\n     this.constructor = constructor;\n     this.map = map;\n-    this.boundFields = map.values().toArray(new BoundField<?>[map.size()]);\n+    this.boundFields = map.values().toArray(new BoundField[map.size()]);\n   }\n \n   public T read(JsonReader reader) throws IOException {\n     // TODO: null out the other fields?\n \n     reader.beginObject();\n-    while (reader.hasNext()) {\n-      String name = reader.nextName();\n-      BoundField<?> field = map.get(name);\n-      if (field == null) {\n-        // TODO: define a better policy\n-        reader.skipValue();\n-      } else {\n-        field.read(reader, instance);\n+    try {\n+      while (reader.hasNext()) {\n+        String name = reader.nextName();\n+        BoundField field = map.get(name);\n+        if (field == null) {\n+          // TODO: define a better policy\n+          reader.skipValue();\n+        } else {\n+          field.read(reader, instance);\n+        }\n       }\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError();\n     }\n     reader.endObject();\n     return instance;\n     }\n \n     writer.beginObject();\n-    for (BoundField<?> boundField : boundFields) {\n-      writer.name(boundField.name);\n-      boundField.write(writer, value);\n+    try {\n+      for (BoundField boundField : boundFields) {\n+        writer.name(boundField.name);\n+        boundField.write(writer, value);\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError();\n     }\n     writer.endObject();\n   }\n \n-  static class BoundField<T> {\n+  static BoundField createBoundField(\n+      final MiniGson context, final Field field, final TypeToken<?> fieldType) {\n+    // special casing primitives here saves ~5% on Android...\n+    return new BoundField(field.getName()) {\n+      final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n+      @SuppressWarnings(\"unchecked\") // the type adapter and field type always agree\n+      @Override void write(JsonWriter writer, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = field.get(value);\n+        ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n+      }\n+      @Override void read(JsonReader reader, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = typeAdapter.read(reader);\n+        field.set(value, fieldValue);\n+      }\n+    };\n+  }\n+\n+  static abstract class BoundField {\n     final String name;\n-    final Field field;\n-    final TypeAdapter<T> typeAdapter;\n \n-    BoundField(String name, Field field, TypeAdapter<T> typeAdapter) {\n+    protected BoundField(String name) {\n       this.name = name;\n-      this.field = field;\n-      this.typeAdapter = typeAdapter;\n     }\n \n-    static <T> BoundField<T> create(MiniGson context, Field field, TypeToken<T> fieldType) {\n-      return new BoundField<T>(field.getName(), field, context.getAdapter(fieldType));\n-    }\n-\n-    void write(JsonWriter writer, Object value) throws IOException {\n-      try {\n-        @SuppressWarnings(\"unchecked\") // we previously verified that field is of type T\n-        T fieldValue = (T) field.get(value);\n-        typeAdapter.write(writer, fieldValue);\n-      } catch (IllegalAccessException e) {\n-        throw new AssertionError();\n-      }\n-    }\n-\n-    void read(JsonReader reader, Object value) throws IOException {\n-      T fieldValue = typeAdapter.read(reader);\n-      try {\n-        field.set(value, fieldValue);\n-      } catch (IllegalAccessException e) {\n-        throw new AssertionError();\n-      }\n-    }\n+    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n+    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n   }\n }\n--- a/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n+++ b/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n import junit.framework.TestCase;\n \n public final class MiniGsonTest extends TestCase {\n-\n   private MiniGson miniGson = new MiniGson.Builder().build();\n   private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n   private TypeAdapter<Map<String, Double>> mapAdapter", "timestamp": 1310740625, "metainfo": ""}