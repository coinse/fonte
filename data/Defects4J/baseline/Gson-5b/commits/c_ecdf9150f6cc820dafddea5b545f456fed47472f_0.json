{"sha": "ecdf9150f6cc820dafddea5b545f456fed47472f", "log": "Hide Gson.getNextAdapter() for the current release.", "commit": "\n--- a/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n import com.google.gson.JsonElement;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n       return null;\n     }\n \n-    final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n+    final TypeAdapter<T> typeAdapter = GsonInternalAccess.INSTANCE.getNextAdapter(gson, this, type);\n     final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\n     return new TypeAdapter<T>() {\n       @Override public void write(JsonWriter out, T value) throws IOException {\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n import com.google.gson.JsonPrimitive;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.JsonTreeReader;\n     final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n         = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n     for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n-      TypeAdapter<?> delegate = gson.getNextAdapter(this, TypeToken.get(entry.getValue()));\n+      TypeAdapter<?> delegate = GsonInternalAccess.INSTANCE\n+          .getNextAdapter(gson, this, TypeToken.get(entry.getValue()));\n       labelToDelegate.put(entry.getKey(), delegate);\n       subtypeToDelegate.put(entry.getValue(), delegate);\n     }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n+import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n     }\n   }\n \n-  /**\n-   * Returns a type adapter for {@code} type that isn't {@code skipPast}. This\n-   * can be used for type adapters to compose other, simpler type adapters.\n-   *\n-   * @throws IllegalArgumentException if this GSON cannot serialize and\n-   *     deserialize {@code type}.\n-   * @since 2.1\n-   */\n-  public <T> TypeAdapter<T> getNextAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n-    boolean skipPastFound = false;\n-\n-    for (TypeAdapterFactory factory : factories) {\n-      if (!skipPastFound) {\n-        if (factory == skipPast) {\n-          skipPastFound = true;\n+  static {\n+    GsonInternalAccess.INSTANCE = new GsonInternalAccess() {\n+      @Override public <T> TypeAdapter<T> getNextAdapter(\n+          Gson gson, TypeAdapterFactory skipPast, TypeToken<T> type) {\n+        boolean skipPastFound = false;\n+\n+        for (TypeAdapterFactory factory : gson.factories) {\n+          if (!skipPastFound) {\n+            if (factory == skipPast) {\n+              skipPastFound = true;\n+            }\n+            continue;\n+          }\n+\n+          TypeAdapter<T> candidate = factory.create(gson, type);\n+          if (candidate != null) {\n+            return candidate;\n+          }\n         }\n-        continue;\n-      }\n-\n-      TypeAdapter<T> candidate = factory.create(this, type);\n-      if (candidate != null) {\n-        return candidate;\n-      }\n-    }\n-\n-    throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n+\n+        throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n+      }\n+    };\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Streams;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n     TypeAdapter<T> d = delegate;\n     return d != null\n         ? d\n-        : (delegate = gson.getNextAdapter(skipPast, typeToken));\n+        : (delegate = GsonInternalAccess.INSTANCE.getNextAdapter(gson, skipPast, typeToken));\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n  * nextLong()}, {@code nextString()} or {@code nextNull()}. Writers should make\n  * exactly one call to one of <code>value()</code> or <code>nullValue()</code>.\n  * For arrays, type adapters should start with a call to {@code beginArray()},\n- * convert all elements, and finish with a call to {@code endArray}. For\n+ * convert all elements, and finish with a call to {@code endArray()}. For\n  * objects, they should start with {@code beginObject()}, convert the object,\n  * and finish with {@code endObject()}. Failing to convert a value or converting\n  * too many values may cause the application to crash.\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n         TypeAdapter<T> d = delegate;\n         return d != null\n             ? d\n-            : (delegate = gson.getNextAdapter(Excluder.this, type));\n+            : (delegate = GsonInternalAccess.INSTANCE.getNextAdapter(gson, Excluder.this, type));\n       }\n     };\n   }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/GsonInternalAccess.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Internal-only APIs of Gson available only to other classes in Gson.\n+ */\n+public abstract class GsonInternalAccess {\n+  public static GsonInternalAccess INSTANCE;\n+\n+  /**\n+   * Returns a type adapter for {@code} type that isn't {@code skipPast}. This\n+   * can be used for type adapters to compose other, simpler type adapters.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public abstract <T> TypeAdapter<T> getNextAdapter(\n+      Gson gson, TypeAdapterFactory skipPast, TypeToken<T> type);\n+}", "timestamp": 1325309440, "metainfo": ""}