{"sha": "4057b98babf5ecb7ad1583d23a90abe7b7fede12", "log": "Implement all but the most difficult part of graph type adapter's deserialization. The catch is we want to return an instance that we don't have yet. It's on the stack, but we don't have a handle to it because it's inside the 'nextTypeAdapter' who is busy populating its fields.", "commit": "\n--- a/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n package com.google.gson.graph;\n \n import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.IdentityHashMap;\n import java.util.LinkedList;\n     }\n \n     final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n+    final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\n     return new TypeAdapter<T>() {\n       @Override public void write(JsonWriter out, T value) throws IOException {\n         if (value == null) {\n         }\n \n         Graph graph = graphThreadLocal.get();\n-\n-        // this is the top-level object in the graph; write the whole graph recursively\n+        boolean writeEntireGraph = false;\n+\n         if (graph == null) {\n-          graph = new Graph();\n+          writeEntireGraph = true;\n+          graph = new Graph(new IdentityHashMap<Object, Element<?>>());\n+        }\n+\n+        Element<T> element = (Element<T>) graph.map.get(value);\n+        if (element == null) {\n+          element = new Element<T>(value, graph.nextName(), typeAdapter, null);\n+          graph.map.put(value, element);\n+          graph.queue.add(element);\n+        }\n+\n+        if (writeEntireGraph) {\n           graphThreadLocal.set(graph);\n-          Element element = new Element<T>(value, graph.elements.size() + 1, typeAdapter);\n-          graph.elements.put(value, element);\n-          graph.queue.add(element);\n-\n-          out.beginObject();\n-          Element current;\n-          while ((current = graph.queue.poll()) != null) {\n-            out.name(current.getName());\n-            current.write(out);\n-          }\n-          out.endObject();\n-          graphThreadLocal.remove();\n-\n-        // this is an element nested in the graph; just reference it by ID\n+          try {\n+            out.beginObject();\n+            Element<?> current;\n+            while ((current = graph.queue.poll()) != null) {\n+              out.name(current.id);\n+              current.write(out);\n+            }\n+            out.endObject();\n+          } finally {\n+            graphThreadLocal.remove();\n+          }\n         } else {\n-          Element element = graph.elements.get(value);\n-          if (element == null) {\n-            element = new Element<T>(value, graph.elements.size() + 1, typeAdapter);\n-            graph.elements.put(value, element);\n-            graph.queue.add(element);\n-          }\n-          out.value(element.getName());\n+          out.value(element.id);\n         }\n       }\n \n       @Override public T read(JsonReader in) throws IOException {\n-        // TODO:\n-        return null;\n+        if (in.peek() == JsonToken.NULL) {\n+          in.nextNull();\n+          return null;\n+        }\n+\n+        String currentName = null;\n+        Graph graph = graphThreadLocal.get();\n+        boolean readEntireGraph = false;\n+\n+        if (graph == null) {\n+          graph = new Graph(new HashMap<Object, Element<?>>());\n+          readEntireGraph = true;\n+\n+          // read the entire tree into memory\n+          in.beginObject();\n+          while (in.hasNext()) {\n+            String name = in.nextName();\n+            if (currentName == null) {\n+              currentName = name;\n+            }\n+            JsonElement element = elementAdapter.read(in);\n+            graph.map.put(name, new Element<T>(null, name, typeAdapter, element));\n+          }\n+          in.endObject();\n+        } else {\n+          currentName = in.nextString();\n+        }\n+\n+        if (readEntireGraph) {\n+          graphThreadLocal.set(graph);\n+        }\n+        try {\n+          Element<T> element = (Element<T>) graph.map.get(currentName);\n+          if (element.value == null) {\n+            element.typeAdapter = typeAdapter;\n+            element.read();\n+          }\n+          return element.value;\n+        } finally {\n+          if (readEntireGraph) {\n+            graphThreadLocal.remove();\n+          }\n+        }\n       }\n     };\n   }\n \n   static class Graph {\n-    private final Map<Object, Element> elements = new IdentityHashMap<Object, Element>();\n+    /**\n+     * The graph elements. On serialization keys are objects (using an identity\n+     * hash map) and on deserialization keys are the string names (using a\n+     * standard hash map).\n+     */\n+    private final Map<Object, Element<?>> map;\n     private final Queue<Element> queue = new LinkedList<Element>();\n+\n+    private Graph(Map<Object, Element<?>> map) {\n+      this.map = map;\n+    }\n+\n+    /**\n+     * Returns a unique name for an element to be inserted into the graph.\n+     */\n+    public String nextName() {\n+      return \"0x\" + Integer.toHexString(map.size() + 1);\n+    }\n   }\n \n   static class Element<T> {\n-    private final T value;\n-    private final int id;\n-    private final TypeAdapter<T> typeAdapter;\n-    Element(T value, int id, TypeAdapter<T> typeAdapter) {\n+    private final String id;\n+    private T value;\n+    private TypeAdapter<T> typeAdapter;\n+    private final JsonElement element;\n+    private boolean reading = false;\n+\n+    Element(T value, String id, TypeAdapter<T> typeAdapter, JsonElement element) {\n       this.value = value;\n       this.id = id;\n       this.typeAdapter = typeAdapter;\n-    }\n-    private String getName() {\n-      return \"0x\" + Integer.toHexString(id);\n-    }\n+      this.element = element;\n+    }\n+\n     private void write(JsonWriter out) throws IOException {\n       typeAdapter.write(out, value);\n     }\n+\n+    private void read() throws IOException {\n+      if (reading) {\n+        // TODO: this currently fails because we don't have the instance we want yet\n+        System.out.println(\"ALREADY READING \" + id);\n+        return;\n+      }\n+      reading = true;\n+      try {\n+        // TODO: use TypeAdapter.fromJsonTree() when that's public\n+        value = typeAdapter.read(new JsonTreeReader(element));\n+        if (value == null) {\n+          throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\n+        }\n+      } finally {\n+        reading = false;\n+      }\n+    }\n   }\n }\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.bind.JsonElementWriter;\n+import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n       // TODO: remove this when TypeAdapter.toJsonTree() is public\n       private JsonElement toJsonTree(TypeAdapter<T> delegate, T value) {\n         try {\n-          JsonElementWriter jsonWriter = new JsonElementWriter();\n+          JsonTreeWriter jsonWriter = new JsonTreeWriter();\n           jsonWriter.setLenient(true);\n           delegate.write(jsonWriter, value);\n           return jsonWriter.get();\n--- a/extras/src/test/java/com/google/gson/graph/GraphTypeAdapterFactoryTest.java\n+++ b/extras/src/test/java/com/google/gson/graph/GraphTypeAdapterFactoryTest.java\n import junit.framework.TestCase;\n \n public final class GraphTypeAdapterFactoryTest extends TestCase {\n-  public void testBasicCycle() {\n+  public void testSerialization() {\n     Roshambo rock = new Roshambo(\"ROCK\");\n     Roshambo scissors = new Roshambo(\"SCISSORS\");\n     Roshambo paper = new Roshambo(\"PAPER\");\n         gson.toJson(rock).replace('\\\"', '\\''));\n   }\n \n+  public void testDeserialization() {\n+    String json = \"{'0x1':{'name':'ROCK','beats':'0x2'},\" +\n+        \"'0x2':{'name':'SCISSORS','beats':'0x3'},\" +\n+        \"'0x3':{'name':'PAPER','beats':'0x1'}}\";\n+\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapterFactory(GraphTypeAdapterFactory.of(Roshambo.class))\n+        .create();\n+\n+    Roshambo rock = gson.fromJson(json, Roshambo.class);\n+    assertEquals(\"ROCK\", rock.name);\n+    Roshambo scissors = rock.beats;\n+    assertEquals(\"SCISSORS\", scissors.name);\n+    Roshambo paper = scissors.beats;\n+    assertEquals(\"PAPER\", paper.name);\n+    assertSame(rock, paper.beats); // TODO: currently fails\n+  }\n+\n   static class Roshambo {\n     String name;\n     Roshambo beats;\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n import com.google.gson.internal.bind.JsonTreeReader;\n-import com.google.gson.internal.bind.JsonElementWriter;\n+import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n    * @since 1.4\n    */\n   public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n-    JsonElementWriter writer = new JsonElementWriter();\n+    JsonTreeWriter writer = new JsonTreeWriter();\n     toJson(src, typeOfSrc, writer);\n     return writer.get();\n   }\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.bind.JsonElementWriter;\n+import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.JsonTreeReader;\n-import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n    */\n   /*public*/ final JsonElement toJsonTree(T value) {\n     try {\n-      JsonElementWriter jsonWriter = new JsonElementWriter();\n+      JsonTreeWriter jsonWriter = new JsonTreeWriter();\n       jsonWriter.setLenient(true);\n       write(jsonWriter, value);\n       return jsonWriter.get();\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This writer creates a JsonElement.\n+ */\n+public final class JsonTreeWriter extends JsonWriter {\n+  private static final Writer UNWRITABLE_WRITER = new Writer() {\n+    @Override public void write(char[] buffer, int offset, int counter) {\n+      throw new AssertionError();\n+    }\n+    @Override public void flush() throws IOException {\n+      throw new AssertionError();\n+    }\n+    @Override public void close() throws IOException {\n+      throw new AssertionError();\n+    }\n+  };\n+  /** Added to the top of the stack when this writer is closed to cause following ops to fail. */\n+  private static final JsonPrimitive SENTINEL_CLOSED = new JsonPrimitive(\"closed\");\n+\n+  /** The JsonElements and JsonArrays under modification, outermost to innermost. */\n+  private final List<JsonElement> stack = new ArrayList<JsonElement>();\n+\n+  /** The name for the next JSON object value. If non-null, the top of the stack is a JsonObject. */\n+  private String pendingName;\n+\n+  /** the JSON element constructed by this writer. */\n+  private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;\n+\n+  public JsonTreeWriter() {\n+    super(UNWRITABLE_WRITER);\n+  }\n+\n+  /**\n+   * Returns the top level object produced by this writer.\n+   */\n+  public JsonElement get() {\n+    if (!stack.isEmpty()) {\n+      throw new IllegalStateException(\"Expected one JSON element but was \" + stack);\n+    }\n+    return product;\n+  }\n+\n+  private JsonElement peek() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  private void put(JsonElement value) {\n+    if (pendingName != null) {\n+      if (!value.isJsonNull() || getSerializeNulls()) {\n+        JsonObject object = (JsonObject) peek();\n+        object.add(pendingName, value);\n+      }\n+      pendingName = null;\n+    } else if (stack.isEmpty()) {\n+      product = value;\n+    } else {\n+      JsonElement element = peek();\n+      if (element instanceof JsonArray) {\n+        ((JsonArray) element).add(value);\n+      } else {\n+        throw new IllegalStateException();\n+      }\n+    }\n+  }\n+\n+  @Override public JsonWriter beginArray() throws IOException {\n+    JsonArray array = new JsonArray();\n+    put(array);\n+    stack.add(array);\n+    return this;\n+  }\n+\n+  @Override public JsonWriter endArray() throws IOException {\n+    if (stack.isEmpty() || pendingName != null) {\n+      throw new IllegalStateException();\n+    }\n+    JsonElement element = peek();\n+    if (element instanceof JsonArray) {\n+      stack.remove(stack.size() - 1);\n+      return this;\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  @Override public JsonWriter beginObject() throws IOException {\n+    JsonObject object = new JsonObject();\n+    put(object);\n+    stack.add(object);\n+    return this;\n+  }\n+\n+  @Override public JsonWriter endObject() throws IOException {\n+    if (stack.isEmpty() || pendingName != null) {\n+      throw new IllegalStateException();\n+    }\n+    JsonElement element = peek();\n+    if (element instanceof JsonObject) {\n+      stack.remove(stack.size() - 1);\n+      return this;\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  @Override public JsonWriter name(String name) throws IOException {\n+    if (stack.isEmpty() || pendingName != null) {\n+      throw new IllegalStateException();\n+    }\n+    JsonElement element = peek();\n+    if (element instanceof JsonObject) {\n+      pendingName = name;\n+      return this;\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  @Override public JsonWriter value(String value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+    put(new JsonPrimitive(value));\n+    return this;\n+  }\n+\n+  @Override public JsonWriter nullValue() throws IOException {\n+    put(JsonNull.INSTANCE);\n+    return this;\n+  }\n+\n+  @Override public JsonWriter value(boolean value) throws IOException {\n+    put(new JsonPrimitive(value));\n+    return this;\n+  }\n+\n+  @Override public JsonWriter value(double value) throws IOException {\n+    if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {\n+      throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n+    }\n+    put(new JsonPrimitive(value));\n+    return this;\n+  }\n+\n+  @Override public JsonWriter value(long value) throws IOException {\n+    put(new JsonPrimitive(value));\n+    return this;\n+  }\n+\n+  @Override public JsonWriter value(Number value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+\n+    if (!isLenient()) {\n+      double d = value.doubleValue();\n+      if (Double.isNaN(d) || Double.isInfinite(d)) {\n+        throw new IllegalArgumentException(\"JSON forbids NaN and infinities: \" + value);\n+      }\n+    }\n+\n+    put(new JsonPrimitive(value));\n+    return this;\n+  }\n+\n+  @Override public void flush() throws IOException {\n+  }\n+\n+  @Override public void close() throws IOException {\n+    if (!stack.isEmpty()) {\n+      throw new IOException(\"Incomplete document\");\n+    }\n+    stack.add(SENTINEL_CLOSED);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n   // TODO: remove this when TypeAdapter.toJsonTree() is public\n   private static <T> JsonElement toJsonTree(TypeAdapter<T> typeAdapter, T value) {\n     try {\n-      JsonElementWriter jsonWriter = new JsonElementWriter();\n+      JsonTreeWriter jsonWriter = new JsonTreeWriter();\n       jsonWriter.setLenient(true);\n       typeAdapter.write(jsonWriter, value);\n       return jsonWriter.get();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n-import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Type;\n import java.util.LinkedHashMap;\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonTreeWriterTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonNull;\n+import java.io.IOException;\n+import junit.framework.TestCase;\n+\n+public final class JsonTreeWriterTest extends TestCase {\n+  public void testArray() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.beginArray();\n+    writer.value(1);\n+    writer.value(2);\n+    writer.value(3);\n+    writer.endArray();\n+    assertEquals(\"[1,2,3]\", writer.get().toString());\n+  }\n+\n+  public void testNestedArray() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.beginArray();\n+    writer.beginArray();\n+    writer.endArray();\n+    writer.beginArray();\n+    writer.beginArray();\n+    writer.endArray();\n+    writer.endArray();\n+    writer.endArray();\n+    assertEquals(\"[[],[[]]]\", writer.get().toString());\n+  }\n+\n+  public void testObject() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.beginObject();\n+    writer.name(\"A\").value(1);\n+    writer.name(\"B\").value(2);\n+    writer.endObject();\n+    assertEquals(\"{\\\"A\\\":1,\\\"B\\\":2}\", writer.get().toString());\n+  }\n+\n+  public void testNestedObject() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.beginObject();\n+    writer.name(\"A\");\n+    writer.beginObject();\n+    writer.name(\"B\");\n+    writer.beginObject();\n+    writer.endObject();\n+    writer.endObject();\n+    writer.name(\"C\");\n+    writer.beginObject();\n+    writer.endObject();\n+    writer.endObject();\n+    assertEquals(\"{\\\"A\\\":{\\\"B\\\":{}},\\\"C\\\":{}}\", writer.get().toString());\n+  }\n+\n+  public void testWriteAfterClose() throws Exception {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setLenient(true);\n+    writer.beginArray();\n+    writer.value(\"A\");\n+    writer.endArray();\n+    writer.close();\n+    try {\n+      writer.beginArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testPrematureClose() throws Exception {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setLenient(true);\n+    writer.beginArray();\n+    try {\n+      writer.close();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testSerializeNullsFalse() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setSerializeNulls(false);\n+    writer.beginObject();\n+    writer.name(\"A\");\n+    writer.nullValue();\n+    writer.endObject();\n+    assertEquals(\"{}\", writer.get().toString());\n+  }\n+\n+  public void testSerializeNullsTrue() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setSerializeNulls(true);\n+    writer.beginObject();\n+    writer.name(\"A\");\n+    writer.nullValue();\n+    writer.endObject();\n+    assertEquals(\"{\\\"A\\\":null}\", writer.get().toString());\n+  }\n+\n+  public void testEmptyWriter() {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    assertEquals(JsonNull.INSTANCE, writer.get());\n+  }\n+\n+  public void testLenientNansAndInfinities() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setLenient(true);\n+    writer.beginArray();\n+    writer.value(Double.NaN);\n+    writer.value(Double.NEGATIVE_INFINITY);\n+    writer.value(Double.POSITIVE_INFINITY);\n+    writer.endArray();\n+    assertEquals(\"[NaN,-Infinity,Infinity]\", writer.get().toString());\n+  }\n+\n+  public void testStrictNansAndInfinities() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setLenient(false);\n+    writer.beginArray();\n+    try {\n+      writer.value(Double.NaN);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      writer.value(Double.NEGATIVE_INFINITY);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      writer.value(Double.POSITIVE_INFINITY);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testStrictBoxedNansAndInfinities() throws IOException {\n+    JsonTreeWriter writer = new JsonTreeWriter();\n+    writer.setLenient(false);\n+    writer.beginArray();\n+    try {\n+      writer.value(new Double(Double.NaN));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      writer.value(new Double(Double.NEGATIVE_INFINITY));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      writer.value(new Double(Double.POSITIVE_INFINITY));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+}", "timestamp": 1325233644, "metainfo": ""}