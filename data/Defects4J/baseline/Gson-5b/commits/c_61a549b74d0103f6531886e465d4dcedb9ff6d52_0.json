{"sha": "61a549b74d0103f6531886e465d4dcedb9ff6d52", "log": "Don't allocate exceptions in the common case. On one benchmark this improved performance by 20%.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.internal.JsonReaderInternalAccess;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import java.io.Closeable;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.Reader;\n import java.util.ArrayList;\n import java.util.List;\n-\n-import com.google.gson.internal.JsonReaderInternalAccess;\n-import com.google.gson.internal.bind.JsonTreeReader;\n \n /**\n  * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n     case NONEMPTY_OBJECT:\n       return nextInObject(false);\n     case NONEMPTY_DOCUMENT:\n-      try {\n-        JsonToken token = nextValue();\n-        if (lenient) {\n-          return token;\n-        }\n+      int c = nextNonWhitespace(false);\n+      if (c == -1) {\n+        return JsonToken.END_DOCUMENT;\n+      }\n+      pos--;\n+      if (!lenient) {\n         throw syntaxError(\"Expected EOF\");\n-      } catch (EOFException e) {\n-        return token = JsonToken.END_DOCUMENT; // TODO: avoid throwing here?\n-      }\n+      }\n+      return nextValue();\n     case CLOSED:\n       throw new IllegalStateException(\"JsonReader is closed\");\n     default:\n    */\n   private void consumeNonExecutePrefix() throws IOException {\n     // fast forward through the leading whitespace\n-    nextNonWhitespace();\n+    nextNonWhitespace(true);\n     pos--;\n \n     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n       replaceTop(JsonScope.NONEMPTY_ARRAY);\n     } else {\n       /* Look for a comma before each element after the first element. */\n-      switch (nextNonWhitespace()) {\n+      switch (nextNonWhitespace(true)) {\n       case ']':\n         pop();\n         return token = JsonToken.END_ARRAY;\n       }\n     }\n \n-    switch (nextNonWhitespace()) {\n+    switch (nextNonWhitespace(true)) {\n     case ']':\n       if (firstElement) {\n         pop();\n      */\n     if (firstElement) {\n       /* Peek to see if this is the empty object. */\n-      switch (nextNonWhitespace()) {\n+      switch (nextNonWhitespace(true)) {\n       case '}':\n         pop();\n         return token = JsonToken.END_OBJECT;\n         pos--;\n       }\n     } else {\n-      switch (nextNonWhitespace()) {\n+      switch (nextNonWhitespace(true)) {\n       case '}':\n         pop();\n         return token = JsonToken.END_OBJECT;\n     }\n \n     /* Read the name. */\n-    int quote = nextNonWhitespace();\n+    int quote = nextNonWhitespace(true);\n     switch (quote) {\n     case '\\'':\n       checkLenient(); // fall-through\n      * Read the name/value separator. Usually a colon ':'. In lenient mode\n      * we also accept an equals sign '=', or an arrow \"=>\".\n      */\n-    switch (nextNonWhitespace()) {\n+    switch (nextNonWhitespace(true)) {\n     case ':':\n       break;\n     case '=':\n \n   @SuppressWarnings(\"fallthrough\")\n   private JsonToken nextValue() throws IOException {\n-    int c = nextNonWhitespace();\n+    int c = nextNonWhitespace(true);\n     switch (c) {\n     case '{':\n       push(JsonScope.EMPTY_OBJECT);\n     return result;\n   }\n \n-  private int nextNonWhitespace() throws IOException {\n+  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n     while (pos < limit || fillBuffer(1)) {\n       int c = buffer[pos++];\n       switch (c) {\n         return c;\n       }\n     }\n-    throw new EOFException(\"End of input\");\n+    if (throwOnEof) {\n+      throw new EOFException(\"End of input\");\n+    } else {\n+      return -1;\n+    }\n   }\n \n   private void checkLenient() throws IOException {", "timestamp": 1323746675, "metainfo": ""}