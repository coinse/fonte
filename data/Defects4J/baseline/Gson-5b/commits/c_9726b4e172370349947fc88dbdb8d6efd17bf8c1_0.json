{"sha": "9726b4e172370349947fc88dbdb8d6efd17bf8c1", "log": "updated Gson version number to 1.2.1  Removed unused productions from Gson grammar. Also removed unused imports.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n /* Generated By:JavaCC: Do not edit this line. JsonParser.java */\n package com.google.gson;\n-\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import com.google.gson.JsonArray;\n-import com.google.gson.JsonElement;\n-import com.google.gson.JsonObject;\n-import com.google.gson.JsonPrimitive;\n \n @SuppressWarnings(\"all\")\n final class JsonParser implements JsonParserConstants {\n     }\n     Number n;\n     if (exppart != null) {\n-      n = new BigDecimal(intpart + fracpart + exppart);\n+      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n     } else if (fracpart != null) {\n       n = new Double(intpart + fracpart);\n     } else {\n       } else if (intpart.length() < 19) {\n         n = new Long(intpart);\n       } else {\n-        n = new BigInteger(intpart);\n+        n = new java.math.BigInteger(intpart);\n       }\n     }\n     {if (true) return new JsonPrimitive(n);}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n-  final private void Chars(StringBuffer strbuf) throws ParseException {\n-  char c;\n-    c = Char();\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case CHAR:\n-    case CNTRL_ESC:\n-    case HEX_ESC:\n-      Chars(strbuf);\n-      break;\n-    default:\n-      jj_la1[11] = jj_gen;\n-      ;\n-    }\n-    strbuf.insert(0, c);\n-  }\n-\n-  final private char Char() throws ParseException {\n-  Token t;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case CHAR:\n-      t = jj_consume_token(CHAR);\n-      break;\n-    case CNTRL_ESC:\n-      t = jj_consume_token(CNTRL_ESC);\n-      break;\n-    case HEX_ESC:\n-      t = jj_consume_token(HEX_ESC);\n-      break;\n-    default:\n-      jj_la1[12] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    if(t.image.length() < 2) {\n-      {if (true) return t.image.charAt(0);}\n-    }\n-    if(t.image.length() < 6) {\n-      char c = t.image.charAt(1);\n-      switch(t.image.charAt(1)) {\n-        //control characters\n-        case 'b'  : {if (true) return (char) 8;} break;\n-        case 'f'  : {if (true) return (char) 12;} break;\n-        case 'n'  : {if (true) return (char) 10;} break;\n-        case 'r'  : {if (true) return (char) 13;} break;\n-        case 't'  : {if (true) return (char) 9;} break;\n-        default   : {if (true) return c;}   //characters that represent themselves\n-      }\n-    }\n-    else {      //hex escape code\n-      //create an integer from our hex values\n-      //and then cast into a char\n-      int i = Integer.valueOf(t.image.substring(2,6), 16).intValue();\n-      {if (true) return (char) i;}\n-    }\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n   public JsonParserTokenManager token_source;\n   SimpleCharStream jj_input_stream;\n   public Token token, jj_nt;\n   private int jj_ntk;\n   private int jj_gen;\n-  final private int[] jj_la1 = new int[13];\n+  final private int[] jj_la1 = new int[11];\n   static private int[] jj_la1_0;\n   static {\n       jj_la1_0();\n    }\n    private static void jj_la1_0() {\n-      jj_la1_0 = new int[] {0x3a500c40,0xc00,0x800000,0x3a500c40,0x800000,0x3a500c40,0x38000c40,0x40000000,0x20,0x20000000,0xc00,0x98000,0x98000,};\n+      jj_la1_0 = new int[] {0x3a500c40,0xc00,0x800000,0x3a500c40,0x800000,0x3a500c40,0x38000c40,0x40000000,0x20,0x20000000,0xc00,};\n    }\n \n   public JsonParser(java.io.InputStream stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(java.io.InputStream stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   public JsonParser(java.io.Reader stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(java.io.Reader stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   public JsonParser(JsonParserTokenManager tm) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(JsonParserTokenManager tm) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 11; i++) jj_la1[i] = -1;\n   }\n \n   final private Token jj_consume_token(int kind) throws ParseException {\n       la1tokens[jj_kind] = true;\n       jj_kind = -1;\n     }\n-    for (int i = 0; i < 13; i++) {\n+    for (int i = 0; i < 11; i++) {\n       if (jj_la1[i] == jj_gen) {\n         for (int j = 0; j < 32; j++) {\n           if ((jj_la1_0[i] & (1<<j)) != 0) {\n--- a/gson/src/main/java/com/google/gson/JsonParserConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserConstants.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserConstants.java */\n package com.google.gson;\n \n-@SuppressWarnings(\"all\")\n interface JsonParserConstants {\n \n   int EOF = 0;\n--- a/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n /* Generated By:JavaCC: Do not edit this line. JsonParserTokenManager.java */\n package com.google.gson;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.List;\n-import com.google.gson.JsonArray;\n-import com.google.gson.JsonElement;\n-import com.google.gson.JsonObject;\n-import com.google.gson.JsonPrimitive;\n \n @SuppressWarnings(\"all\")\n final class JsonParserTokenManager implements JsonParserConstants\n--- a/gson/src/main/java/com/google/gson/TypeInfoArray.java\n+++ b/gson/src/main/java/com/google/gson/TypeInfoArray.java\n    * @return the raw type unwrapped of the second level of array.\n    * If the object is (single-dimensional or multi-dimensional) array, it is the class of the\n    * elements of the array. For example, this method returns Foo.class for Foo[].\n-   * It will return Foo[].class for Foo[][].  For Foo<String>[][] types, it will return the type\n-   * representing Foo<String>[] (i.e. {@code new TypeToken<Foo<String>[]>() {}.getType()}).\n+   * It will return Foo[].class for Foo[][].  For Foo&lt;String&gt;[][] types, it will return the \n+   * type representing Foo&lt;String&gt;[] \n+   * (i.e. <code>new TypeToken<Foo<String>[]>() {}.getType()</code>).\n    */\n   public Type getSecondLevelType() {\n     return secondLevel;", "timestamp": 1223935755, "metainfo": ""}