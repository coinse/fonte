{"sha": "883ce465d5514ee9fd28a73c0891869d0b744d4a", "log": "Second half of adopting Guice's types code.  This removes a bunch of unnecessary public APIs and looks more like the GSON code that existed before this whole exercise. We no longer use TypeToken.isAssignable. I wrote a test that demonstrates at least one problem with that method, so I've deprecated it. We should be able to remove it release-after-next; nobody should be using this method anyway.  There are still some things that are public that shouldn't be. In particular there's some APIs in Types that are needed by TypeToken, which is unfortunately in a different package. Traditionally the fix is to create an 'internal' package and make the shared code public in the internal package. I'm not sure what we want to do for GSON; we could also use reflection (yuck) or duplicate the code (yuck).", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n       JsonArray array = new JsonArray();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = TypeToken.get(typeOfSrc).getCollectionElementType();\n+        Class<?> rawTypeOfSrc = Types.getRawType(typeOfSrc);\n+        childGenericType = Types.getCollectionElementType(typeOfSrc, rawTypeOfSrc);\n       }\n       for (Object child : src) {\n         if (child == null) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Collection.\n       Collection collection = constructCollectionType(typeOfT, context);\n-      Type childType = TypeToken.get(typeOfT).getCollectionElementType();\n+      Type childType = Types.getCollectionElementType(typeOfT, Types.getRawType(typeOfT));\n       for (JsonElement childElement : json.getAsJsonArray()) {\n         if (childElement == null || childElement.isJsonNull()) {\n           collection.add(null);\n       JsonObject map = new JsonObject();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        childGenericType = TypeToken.get(typeOfSrc).getMapKeyAndValueTypes()[1];\n+        Class<?> rawTypeOfSrc = Types.getRawType(typeOfSrc);\n+        childGenericType = Types.getMapKeyAndValueTypes(typeOfSrc, rawTypeOfSrc)[1];\n       }\n \n       for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Map.\n       Map<Object, Object> map = constructMapType(typeOfT, context);\n-      Type[] keyAndValueTypes = TypeToken.get(typeOfT).getMapKeyAndValueTypes();\n+      Type[] keyAndValueTypes = Types.getMapKeyAndValueTypes(typeOfT, Types.getRawType(typeOfT));\n       for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n         Object key = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueTypes[0]);\n         Object value = context.deserialize(entry.getValue(), keyAndValueTypes[1]);\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n \n   @Override\n   @SuppressWarnings(\"unchecked\")\n   protected T constructTarget() {\n-\n-    TypeToken typeToken = TypeToken.get(targetType);\n-\n     if (!json.isJsonArray()) {\n       throw new JsonParseException(\"Expecting array found: \" + json); \n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    if (typeToken.isArray()) {\n+    if (Types.isArray(targetType)) {\n       // We know that we are getting back an array of the required type, so\n       // this typecasting is safe.\n-      return (T) objectConstructor.constructArray(typeToken.getArrayComponentType(),\n+      return (T) objectConstructor.constructArray(Types.getArrayComponentType(targetType),\n           jsonArray.size());\n     }\n     // is a collection\n-    return (T) objectConstructor.construct(typeToken.getRawType());\n+    return (T) objectConstructor.construct(Types.getRawType(targetType));\n   }\n \n   public void visitArray(Object array, Type arrayType) {\n       throw new JsonParseException(\"Expecting array found: \" + json); \n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    TypeToken typeToken = TypeToken.get(arrayType);\n     for (int i = 0; i < jsonArray.size(); i++) {\n       JsonElement jsonChild = jsonArray.get(i);\n       Object child;\n       if (jsonChild == null || jsonChild.isJsonNull()) {\n         child = null;\n       } else if (jsonChild instanceof JsonObject) {\n-        child = visitChildAsObject(typeToken.getArrayComponentType(), jsonChild);\n+        child = visitChildAsObject(Types.getArrayComponentType(arrayType), jsonChild);\n       } else if (jsonChild instanceof JsonArray) {\n-        child = visitChildAsArray(typeToken.getArrayComponentType(), jsonChild.getAsJsonArray());\n+        child = visitChildAsArray(Types.getArrayComponentType(arrayType),\n+            jsonChild.getAsJsonArray());\n       } else if (jsonChild instanceof JsonPrimitive) {\n-        child = visitChildAsObject(typeToken.getArrayComponentType(),\n+        child = visitChildAsObject(Types.getArrayComponentType(arrayType),\n             jsonChild.getAsJsonPrimitive());\n       } else {\n         throw new IllegalStateException();\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n \n /**\n         throw new JsonParseException(\"Expecting object found: \" + json); \n       }\n       JsonElement child = json.getAsJsonObject().get(fName);\n-      boolean isPrimitive = TypeToken.get(declaredTypeOfField).isPrimitive();\n+      boolean isPrimitive = Primitives.isPrimitive(declaredTypeOfField);\n       if (child == null) { // Child will be null if the field wasn't present in Json\n         return true;\n       } else if (child.isJsonNull()) {\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   public void visitArray(Object array, Type arrayType) {\n     assignToRoot(new JsonArray());\n     int length = Array.getLength(array);\n-    Type componentType = TypeToken.get(arrayType).getArrayComponentType();\n+    Type componentType = Types.getArrayComponentType(arrayType);\n     for (int i = 0; i < length; ++i) {\n       Object child = Array.get(array, i);\n       // we should not get more specific component type yet since it is possible\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n   }\n \n   public Object constructArray(Type type, int length) {\n-    return Array.newInstance(TypeToken.get(type).getRawType(), length);\n+    return Array.newInstance(Types.getRawType(type), length);\n   }\n \n   private <T> T constructWithNoArgConstructor(Type typeOfT) {\n \n   @SuppressWarnings({\"unchecked\", \"cast\"})\n   private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) {\n-    Class<?> clazz = TypeToken.get(typeOfT).getRawType();\n+    Class<?> clazz = Types.getRawType(typeOfT);\n     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors();\n     AccessibleObject.setAccessible(declaredConstructors, true);\n     for (Constructor<T> constructor : declaredConstructors) {\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n+import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Properties;\n \n /**\n  * Provides ability to apply a visitor to an object and all of its fields\n    * does not get visited.\n    */\n   public void accept(Visitor visitor) {\n-    TypeToken<?> objTypeInfo = TypeToken.get(objTypePair.type);\n-    if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawType())) {\n+    if (exclusionStrategy.shouldSkipClass(Types.getRawType(objTypePair.type))) {\n       return;\n     }\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n       objTypePair.setObject(objectToVisit);\n       visitor.start(objTypePair);\n       try {\n-        if (objTypeInfo.isArray()) {\n+        if (Types.isArray(objTypePair.type)) {\n           visitor.visitArray(objectToVisit, objTypePair.type);\n-        } else if (objTypeInfo.getType() == Object.class\n-            && isPrimitiveOrString(objectToVisit)) {\n+        } else if (objTypePair.type == Object.class && isPrimitiveOrString(objectToVisit)) {\n           // TODO(Joel): this is only used for deserialization of \"primitives\"\n           // we should rethink this!!!\n           visitor.visitPrimitive(objectToVisit);\n-          objectToVisit = visitor.getTarget();\n+          visitor.getTarget();\n         } else {\n           visitor.startVisitingObject(objectToVisit);\n           ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n-          Class<?> topLevelClass = TypeToken.get(currObjTypePair.type).getRawType();\n+          Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n           for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n               curr.getSuperclass()) {\n             if (!curr.isSynthetic()) {\n           || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n         continue; // skip\n       }\n-      TypeToken<?> fieldTypeToken = getTypeInfoForField(f, objTypePair.type);\n-      Type declaredTypeOfField = fieldTypeToken.getType();\n+      Type declaredTypeOfField = getTypeInfoForField(f, objTypePair.type);\n       boolean visitedWithCustomHandler =\n-        visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n+          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n       if (!visitedWithCustomHandler) {\n-        if (fieldTypeToken.isArray()) {\n+        if (Types.isArray(declaredTypeOfField)) {\n           visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n         } else {\n           visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n    * @param typeDefiningF the type that contains the field {@code f}\n    * @return the type information for the field\n    */\n-  public static TypeToken<?> getTypeInfoForField(Field f, Type typeDefiningF) {\n-    TypeToken<?> typeToken = TypeToken.get(typeDefiningF);\n-    if (!f.getDeclaringClass().isAssignableFrom(typeToken.getRawType())) {\n+  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n+    Class<?> rawType = Types.getRawType(typeDefiningF);\n+    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n       // this field is unrelated to the type; the user probably omitted type information\n-      return TypeToken.get(f.getGenericType());\n+      return f.getGenericType();\n     }\n-    return typeToken.getFieldType(f);\n+    return Types.resolve(typeDefiningF, rawType, f.getGenericType());\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n   public synchronized T getHandlerFor(Type type) {\n     T handler = map.get(type);\n     if (handler == null) {\n-      Class<?> rawClass = TypeToken.get(type).getRawType();\n+      Class<?> rawClass = Types.getRawType(type);\n       if (rawClass != type) {\n         handler = getHandlerFor(rawClass);\n       }\n   }\n \n   private String typeToString(Type type) {\n-    return TypeToken.get(type).getRawType().getSimpleName();\n+    return Types.getRawType(type).getSimpleName();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Primitives.java\n+++ b/gson/src/main/java/com/google/gson/Primitives.java\n \n package com.google.gson;\n \n+import java.lang.reflect.Type;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n       Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n     forward.put(key, value);\n     backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public static boolean isPrimitive(Type type) {\n+    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n   }\n \n   /**\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Types.java\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+\n+/**\n+ * Static methods for working with types.\n+ *\n+ * @author Bob Lee\n+ * @author Jesse Wilson\n+ */\n+public final class Types {\n+  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private Types() {}\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType} and enclosed by {@code ownerType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedTypeWithOwner(\n+      Type ownerType, Type rawType, Type... typeArguments) {\n+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns an array type whose elements are all instances of\n+   * {@code componentType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} generic array type.\n+   */\n+  public static GenericArrayType arrayOf(Type componentType) {\n+    return new GenericArrayTypeImpl(componentType);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}.\n+   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n+   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n+   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For\n+   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n+   * super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+  }\n+\n+  /**\n+   * Returns a type that is functionally equal but not necessarily equal\n+   * according to {@link Object#equals(Object) Object.equals()}. The returned\n+   * type is {@link java.io.Serializable}.\n+   */\n+  public static Type canonicalize(Type type) {\n+    if (type instanceof Class) {\n+      Class<?> c = (Class<?>) type;\n+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType p = (ParameterizedType) type;\n+      return new ParameterizedTypeImpl(p.getOwnerType(),\n+          p.getRawType(), p.getActualTypeArguments());\n+\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType g = (GenericArrayType) type;\n+      return new GenericArrayTypeImpl(g.getGenericComponentType());\n+\n+    } else if (type instanceof WildcardType) {\n+      WildcardType w = (WildcardType) type;\n+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+\n+    } else {\n+      // type is either serializable as-is or unsupported\n+      return type;\n+    }\n+  }\n+\n+  public static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      checkArgument(rawType instanceof Class);\n+      return (Class<?>) rawType;\n+\n+    } else if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n+      return Array.newInstance(getRawType(componentType), 0).getClass();\n+\n+    } else if (type instanceof TypeVariable) {\n+      // we could use the variable's bounds, but that won't work if there are multiple.\n+      // having a raw type that's more general than necessary is okay\n+      return Object.class;\n+\n+    } else if (type instanceof WildcardType) {\n+      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n+\n+    } else {\n+      String className = type == null ? \"null\" : type.getClass().getName();\n+      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n+    }\n+  }\n+\n+  static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Returns true if {@code a} and {@code b} are equal.\n+   */\n+  public static boolean equals(Type a, Type b) {\n+    if (a == b) {\n+      // also handles (a == null && b == null)\n+      return true;\n+\n+    } else if (a instanceof Class) {\n+      // Class already specifies equals().\n+      return a.equals(b);\n+\n+    } else if (a instanceof ParameterizedType) {\n+      if (!(b instanceof ParameterizedType)) {\n+        return false;\n+      }\n+\n+      // TODO: save a .clone() call\n+      ParameterizedType pa = (ParameterizedType) a;\n+      ParameterizedType pb = (ParameterizedType) b;\n+      return equal(pa.getOwnerType(), pb.getOwnerType())\n+          && pa.getRawType().equals(pb.getRawType())\n+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n+\n+    } else if (a instanceof GenericArrayType) {\n+      if (!(b instanceof GenericArrayType)) {\n+        return false;\n+      }\n+\n+      GenericArrayType ga = (GenericArrayType) a;\n+      GenericArrayType gb = (GenericArrayType) b;\n+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n+\n+    } else if (a instanceof WildcardType) {\n+      if (!(b instanceof WildcardType)) {\n+        return false;\n+      }\n+\n+      WildcardType wa = (WildcardType) a;\n+      WildcardType wb = (WildcardType) b;\n+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n+\n+    } else if (a instanceof TypeVariable) {\n+      if (!(b instanceof TypeVariable)) {\n+        return false;\n+      }\n+      TypeVariable<?> va = (TypeVariable) a;\n+      TypeVariable<?> vb = (TypeVariable) b;\n+      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n+          && va.getName().equals(vb.getName());\n+\n+    } else {\n+      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n+      return false;\n+    }\n+  }\n+\n+  private static int hashCodeOrZero(Object o) {\n+    return o != null ? o.hashCode() : 0;\n+  }\n+\n+  public static String typeToString(Type type) {\n+    return type instanceof Class ? ((Class) type).getName() : type.toString();\n+  }\n+\n+  /**\n+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n+   */\n+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n+    if (toResolve == rawType) {\n+      return context;\n+    }\n+\n+    // we skip searching through interfaces if unknown is an interface\n+    if (toResolve.isInterface()) {\n+      Class[] interfaces = rawType.getInterfaces();\n+      for (int i = 0, length = interfaces.length; i < length; i++) {\n+        if (interfaces[i] == toResolve) {\n+          return rawType.getGenericInterfaces()[i];\n+        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+        }\n+      }\n+    }\n+\n+    // check our supertypes\n+    if (!rawType.isInterface()) {\n+      while (rawType != Object.class) {\n+        Class<?> rawSupertype = rawType.getSuperclass();\n+        if (rawSupertype == toResolve) {\n+          return rawType.getGenericSuperclass();\n+        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+        }\n+        rawType = rawSupertype;\n+      }\n+    }\n+\n+    // we can't resolve this further\n+    return toResolve;\n+  }\n+\n+  /**\n+   * Returns the generic form of {@code supertype}. For example, if this is {@code\n+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n+   * Iterable.class}.\n+   *\n+   * @param supertype a superclass of, or interface implemented by, this.\n+   */\n+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n+    checkArgument(supertype.isAssignableFrom(contextRawType));\n+    return resolve(context, contextRawType,\n+        Types.getGenericSupertype(context, contextRawType, supertype));\n+  }\n+\n+  /**\n+   * Returns true if this type is an array.\n+   */\n+  static boolean isArray(Type type) {\n+    return type instanceof GenericArrayType\n+        || (type instanceof Class && ((Class<?>) type).isArray());\n+  }\n+\n+  /**\n+   * Returns the component type of this array type.\n+   * @throws ClassCastException if this type is not an array.\n+   */\n+  static Type getArrayComponentType(Type array) {\n+    return array instanceof GenericArrayType\n+        ? ((GenericArrayType) array).getGenericComponentType()\n+        : ((Class<?>) array).getComponentType();\n+  }\n+\n+  /**\n+   * Returns the element type of this collection type.\n+   * @throws IllegalArgumentException if this type is not a collection.\n+   */\n+  static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n+    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n+    return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Returns a two element array containing this map's key and value types in\n+   * positions 0 and 1 respectively.\n+   */\n+  static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n+    /*\n+     * Work around a problem with the declaration of java.util.Properties. That\n+     * class should extend Hashtable<String, String>, but it's declared to\n+     * extend Hashtable<Object, Object>.\n+     */\n+    if (context == Properties.class) {\n+      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n+    }\n+\n+    Type mapType = getSupertype(context, contextRawType, Map.class);\n+    ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n+    return mapParameterizedType.getActualTypeArguments();\n+  }\n+\n+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n+    // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    while (true) {\n+      if (toResolve instanceof TypeVariable) {\n+        TypeVariable typeVariable = (TypeVariable) toResolve;\n+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n+        if (toResolve == typeVariable) {\n+          return toResolve;\n+        }\n+\n+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n+        Class<?> original = (Class<?>) toResolve;\n+        Type componentType = original.getComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof GenericArrayType) {\n+        GenericArrayType original = (GenericArrayType) toResolve;\n+        Type componentType = original.getGenericComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof ParameterizedType) {\n+        ParameterizedType original = (ParameterizedType) toResolve;\n+        Type ownerType = original.getOwnerType();\n+        Type newOwnerType = resolve(context, contextRawType, ownerType);\n+        boolean changed = newOwnerType != ownerType;\n+\n+        Type[] args = original.getActualTypeArguments();\n+        for (int t = 0, length = args.length; t < length; t++) {\n+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n+          if (resolvedTypeArgument != args[t]) {\n+            if (!changed) {\n+              args = args.clone();\n+              changed = true;\n+            }\n+            args[t] = resolvedTypeArgument;\n+          }\n+        }\n+\n+        return changed\n+            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n+            : original;\n+\n+      } else if (toResolve instanceof WildcardType) {\n+        WildcardType original = (WildcardType) toResolve;\n+        Type[] originalLowerBound = original.getLowerBounds();\n+        Type[] originalUpperBound = original.getUpperBounds();\n+\n+        if (originalLowerBound.length == 1) {\n+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n+          if (lowerBound != originalLowerBound[0]) {\n+            return supertypeOf(lowerBound);\n+          }\n+        } else if (originalUpperBound.length == 1) {\n+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n+          if (upperBound != originalUpperBound[0]) {\n+            return subtypeOf(upperBound);\n+          }\n+        }\n+        return original;\n+\n+      } else {\n+        return toResolve;\n+      }\n+    }\n+  }\n+\n+  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n+    Class<?> declaredByRaw = declaringClassOf(unknown);\n+\n+    // we can't reduce this further\n+    if (declaredByRaw == null) {\n+      return unknown;\n+    }\n+\n+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n+    if (declaredBy instanceof ParameterizedType) {\n+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n+    }\n+\n+    return unknown;\n+  }\n+\n+  private static int indexOf(Object[] array, Object toFind) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (toFind.equals(array[i])) {\n+        return i;\n+      }\n+    }\n+    throw new NoSuchElementException();\n+  }\n+\n+  /**\n+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n+   * a class.\n+   */\n+  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n+    return genericDeclaration instanceof Class\n+        ? (Class<?>) genericDeclaration\n+        : null;\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkArgument(!(type instanceof Class<?>) || !((Class) type).isPrimitive());\n+  }\n+\n+  private static class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n+    private final Type ownerType;\n+    private final Type rawType;\n+    private final Type[] typeArguments;\n+\n+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n+      // require an owner type if the raw type needs it\n+      if (rawType instanceof Class<?>) {\n+        Class rawTypeAsClass = (Class) rawType;\n+        checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n+        checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n+      }\n+\n+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n+      this.rawType = canonicalize(rawType);\n+      this.typeArguments = typeArguments.clone();\n+      for (int t = 0; t < this.typeArguments.length; t++) {\n+        checkNotNull(this.typeArguments[t]);\n+        checkNotPrimitive(this.typeArguments[t]);\n+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n+      }\n+    }\n+\n+    public Type[] getActualTypeArguments() {\n+      return typeArguments.clone();\n+    }\n+\n+    public Type getRawType() {\n+      return rawType;\n+    }\n+\n+    public Type getOwnerType() {\n+      return ownerType;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof ParameterizedType\n+          && Types.equals(this, (ParameterizedType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      return Arrays.hashCode(typeArguments)\n+          ^ rawType.hashCode()\n+          ^ hashCodeOrZero(ownerType);\n+    }\n+\n+    @Override public String toString() {\n+      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));\n+      stringBuilder.append(typeToString(rawType));\n+\n+      if (typeArguments.length == 0) {\n+        return stringBuilder.toString();\n+      }\n+\n+      stringBuilder.append(\"<\").append(typeToString(typeArguments[0]));\n+      for (int i = 1; i < typeArguments.length; i++) {\n+        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n+      }\n+      return stringBuilder.append(\">\").toString();\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n+    private final Type componentType;\n+\n+    public GenericArrayTypeImpl(Type componentType) {\n+      this.componentType = canonicalize(componentType);\n+    }\n+\n+    public Type getGenericComponentType() {\n+      return componentType;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof GenericArrayType\n+          && Types.equals(this, (GenericArrayType) o);\n+    }\n+\n+    @Override public int hashCode() {\n+      return componentType.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return typeToString(componentType) + \"[]\";\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  /**\n+   * The WildcardType interface supports multiple upper bounds and multiple\n+   * lower bounds. We only support what the Java 6 language needs - at most one\n+   * bound. If a lower bound is set, the upper bound must be Object.class.\n+   */\n+  private static class WildcardTypeImpl implements WildcardType, Serializable {\n+    private final Type upperBound;\n+    private final Type lowerBound;\n+\n+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+      checkArgument(lowerBounds.length <= 1);\n+      checkArgument(upperBounds.length == 1);\n+\n+      if (lowerBounds.length == 1) {\n+        checkNotNull(lowerBounds[0]);\n+        checkNotPrimitive(lowerBounds[0]);\n+        checkArgument(upperBounds[0] == Object.class);\n+        this.lowerBound = canonicalize(lowerBounds[0]);\n+        this.upperBound = Object.class;\n+\n+      } else {\n+        checkNotNull(upperBounds[0]);\n+        checkNotPrimitive(upperBounds[0]);\n+        this.lowerBound = null;\n+        this.upperBound = canonicalize(upperBounds[0]);\n+      }\n+    }\n+\n+    public Type[] getUpperBounds() {\n+      return new Type[] { upperBound };\n+    }\n+\n+    public Type[] getLowerBounds() {\n+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof WildcardType\n+          && Types.equals(this, (WildcardType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n+          ^ (31 + upperBound.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      if (lowerBound != null) {\n+        return \"? super \" + typeToString(lowerBound);\n+      } else if (upperBound == Object.class) {\n+        return \"?\";\n+      } else {\n+        return \"? extends \" + typeToString(upperBound);\n+      }\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static void checkNotNull(Object obj) {\n+    checkArgument(obj != null);\n+  }\n+\n+  private static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException(\"condition failed: \" + condition);\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n package com.google.gson.reflect;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n+import com.google.gson.Types;\n import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.Member;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n-import java.lang.reflect.WildcardType;\n-import java.util.Arrays;\n-import java.util.Collection;\n import java.util.HashMap;\n-import java.util.Hashtable;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Properties;\n \n /**\n  * Represents a generic type {@code T}. Java doesn't yet provide a way to\n   }\n \n   /**\n-   * Gets type literal from super class's type parameter.\n-   */\n-  static TypeToken<?> fromSuperclassTypeParameter(Class<?> subclass) {\n-    return new TypeToken<Object>(getSuperclassTypeParameter(subclass));\n-  }\n-\n-  /**\n    * Returns the raw (non-generic) type for this type.\n    */\n   public final Class<? super T> getRawType() {\n \n   /**\n    * Check if this type is assignable from the given class object.\n-   */\n+   *\n+   * @deprecated this implementation may be inconsistent with javac for types\n+   *     with wildcards.\n+   */\n+  @Deprecated\n+  @SuppressWarnings(\"deprecation\")\n   public boolean isAssignableFrom(Class<?> cls) {\n     return isAssignableFrom((Type) cls);\n   }\n \n   /**\n    * Check if this type is assignable from the given Type.\n-   */\n+   *\n+   * @deprecated this implementation may be inconsistent with javac for types\n+   *     with wildcards.\n+   */\n+  @Deprecated\n   public boolean isAssignableFrom(Type from) {\n-    // TODO: resolve from first, then do something lightweight?\n-\n     if (from == null) {\n       return false;\n     }\n \n   /**\n    * Check if this type is assignable from the given type token.\n-   */\n+   *\n+   * @deprecated this implementation may be inconsistent with javac for types\n+   *     with wildcards.\n+   */\n+  @Deprecated\n+  @SuppressWarnings(\"deprecation\")\n   public boolean isAssignableFrom(TypeToken<?> token) {\n     return isAssignableFrom(token.getType());\n   }\n \n     // Interfaces didn't work, try the superclass.\n     Type sType = clazz.getGenericSuperclass();\n-    if (isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap))) {\n-      return true;\n-    }\n-\n-    return false;\n+    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n   }\n \n   /**\n    * Checks if two types are the same or are equivalent under a variable mapping\n    * given in the type map that was provided.\n    */\n-  private static boolean matches(Type from, Type to,\n-      Map<String, Type> typeMap) {\n-    if (to.equals(from)) return true;\n-\n-    if (from instanceof TypeVariable<?>) {\n-      return to.equals(typeMap.get(((TypeVariable<?>)from).getName()));\n-    }\n-\n-    return false;\n+  private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n+    return to.equals(from)\n+        || (from instanceof TypeVariable\n+        && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\n+\n   }\n \n   @Override public final int hashCode() {\n     return new TypeToken<T>(type);\n   }\n \n-\n-  /** Returns an immutable list of the resolved types. */\n-  private List<TypeToken<?>> resolveAll(Type[] types) {\n-    TypeToken<?>[] result = new TypeToken<?>[types.length];\n-    for (int t = 0; t < types.length; t++) {\n-      result[t] = resolve(types[t]);\n-    }\n-    return Arrays.asList(result);\n-  }\n-\n-  /**\n-   * Resolves known type parameters in {@code toResolve} and returns the result.\n-   */\n-  TypeToken<?> resolve(Type toResolve) {\n-    return TypeToken.get(resolveType(toResolve));\n-  }\n-\n-  Type resolveType(Type toResolve) {\n-    // this implementation is made a little more complicated in an attempt to avoid object-creation\n-    while (true) {\n-      if (toResolve instanceof TypeVariable) {\n-        TypeVariable original = (TypeVariable) toResolve;\n-        toResolve = Types.resolveTypeVariable(type, rawType, original);\n-        if (toResolve == original) {\n-          return toResolve;\n-        }\n-\n-      } else if (toResolve instanceof GenericArrayType) {\n-        GenericArrayType original = (GenericArrayType) toResolve;\n-        Type componentType = original.getGenericComponentType();\n-        Type newComponentType = resolveType(componentType);\n-        return componentType == newComponentType\n-            ? original\n-            : Types.arrayOf(newComponentType);\n-\n-      } else if (toResolve instanceof ParameterizedType) {\n-        ParameterizedType original = (ParameterizedType) toResolve;\n-        Type ownerType = original.getOwnerType();\n-        Type newOwnerType = resolveType(ownerType);\n-        boolean changed = newOwnerType != ownerType;\n-\n-        Type[] args = original.getActualTypeArguments();\n-        for (int t = 0, length = args.length; t < length; t++) {\n-          Type resolvedTypeArgument = resolveType(args[t]);\n-          if (resolvedTypeArgument != args[t]) {\n-            if (!changed) {\n-              args = args.clone();\n-              changed = true;\n-            }\n-            args[t] = resolvedTypeArgument;\n-          }\n-        }\n-\n-        return changed\n-            ? Types.newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n-            : original;\n-\n-      } else if (toResolve instanceof WildcardType) {\n-        WildcardType original = (WildcardType) toResolve;\n-        Type[] originalLowerBound = original.getLowerBounds();\n-        Type[] originalUpperBound = original.getUpperBounds();\n-\n-        if (originalLowerBound.length == 1) {\n-          Type lowerBound = resolveType(originalLowerBound[0]);\n-          if (lowerBound != originalLowerBound[0]) {\n-            return Types.supertypeOf(lowerBound);\n-          }\n-        } else if (originalUpperBound.length == 1) {\n-          Type upperBound = resolveType(originalUpperBound[0]);\n-          if (upperBound != originalUpperBound[0]) {\n-            return Types.subtypeOf(upperBound);\n-          }\n-        }\n-        return original;\n-\n-      } else {\n-        return toResolve;\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Returns the generic form of {@code supertype}. For example, if this is {@code\n-   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n-   * Iterable.class}.\n-   *\n-   * @param supertype a superclass of, or interface implemented by, this.\n-   */\n-  public TypeToken<?> getSupertype(Class<?> supertype) {\n-    checkArgument(supertype.isAssignableFrom(rawType));\n-    return resolve(Types.getGenericSupertype(type, rawType, supertype));\n-  }\n-\n-  /**\n-   * Returns the resolved generic type of {@code field}.\n-   *\n-   * @param field a field defined by this or any superclass.\n-   */\n-  public TypeToken<?> getFieldType(Field field) {\n-    if (!field.getDeclaringClass().isAssignableFrom(rawType)) {\n-      throw new IllegalArgumentException(rawType.getName() + \" does not declare field \" + field);\n-    }\n-    return resolve(field.getGenericType());\n-  }\n-\n-  /**\n-   * Returns the resolved generic parameter types of {@code methodOrConstructor}.\n-   *\n-   * @param methodOrConstructor a method or constructor defined by this or any supertype.\n-   */\n-  public List<TypeToken<?>> getParameterTypes(Member methodOrConstructor) {\n-    Type[] genericParameterTypes;\n-\n-    if (methodOrConstructor instanceof Method) {\n-      Method method = (Method) methodOrConstructor;\n-      checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n-      genericParameterTypes = method.getGenericParameterTypes();\n-\n-    } else if (methodOrConstructor instanceof Constructor) {\n-      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;\n-      checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType));\n-      genericParameterTypes = constructor.getGenericParameterTypes();\n-\n-    } else {\n-      throw new IllegalArgumentException(\"Not a method or a constructor: \" + methodOrConstructor);\n-    }\n-\n-    return resolveAll(genericParameterTypes);\n-  }\n-\n-  /**\n-   * Returns the resolved generic exception types thrown by {@code constructor}.\n-   *\n-   * @param methodOrConstructor a method or constructor defined by this or any supertype.\n-   */\n-  public List<TypeToken<?>> getExceptionTypes(Member methodOrConstructor) {\n-    Type[] genericExceptionTypes;\n-\n-    if (methodOrConstructor instanceof Method) {\n-      Method method = (Method) methodOrConstructor;\n-      checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n-      genericExceptionTypes = method.getGenericExceptionTypes();\n-\n-    } else if (methodOrConstructor instanceof Constructor) {\n-      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;\n-      checkArgument(constructor.getDeclaringClass().isAssignableFrom(rawType));\n-      genericExceptionTypes = constructor.getGenericExceptionTypes();\n-\n-    } else {\n-      throw new IllegalArgumentException(\"Not a method or a constructor: \" + methodOrConstructor);\n-    }\n-\n-    return resolveAll(genericExceptionTypes);\n-  }\n-\n-  /**\n-   * Returns the resolved generic return type of {@code method}.\n-   *\n-   * @param method a method defined by this or any supertype.\n-   */\n-  public TypeToken<?> getReturnType(Method method) {\n-    checkArgument(method.getDeclaringClass().isAssignableFrom(rawType));\n-    return resolve(method.getGenericReturnType());\n-  }\n-\n   static void checkNotNull(Object obj) {\n     checkArgument(obj != null);\n   }\n       throw new IllegalArgumentException(\"condition failed: \" + condition);\n     }\n   }\n-\n-  // TODO: these methods are required by GSON but don't need to be public. Remove?\n-\n-  /**\n-   * Returns true if this type is an array.\n-   */\n-  public boolean isArray() {\n-    return type instanceof GenericArrayType;\n-  }\n-\n-  /**\n-   * Returns true if this type is a primitive.\n-   */\n-  public boolean isPrimitive() {\n-    return type == boolean.class\n-        || type == byte.class\n-        || type == char.class\n-        || type == double.class\n-        || type == float.class\n-        || type == int.class\n-        || type == long.class\n-        || type == short.class\n-        || type == void.class;\n-  }\n-\n-  /**\n-   * Returns the component type of this array type.\n-   * @throws ClassCastException if this type is not an array.\n-   */\n-  public Type getArrayComponentType() {\n-    return ((GenericArrayType) type).getGenericComponentType();\n-  }\n-\n-  /**\n-   * Returns the element type of this collection type.\n-   * @throws IllegalArgumentException if this type is not a collection.\n-   */\n-  public Type getCollectionElementType() {\n-    TypeToken<?> collectionType = getSupertype(Collection.class);\n-    return ((ParameterizedType) collectionType.getType()).getActualTypeArguments()[0];\n-  }\n-\n-  /**\n-   * Returns a two element array containing this map's key and value types in\n-   * positions 0 and 1 respectively.\n-   */\n-  public Type[] getMapKeyAndValueTypes() {\n-    /*\n-     * Work around a problem with the declaration of java.util.Properties. That\n-     * class should extend Hashtable<String, String>, but it's declared to\n-     * extend Hashtable<Object, Object>.\n-     */\n-    if (type == Properties.class) {\n-      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n-    }\n-\n-    TypeToken<?> mapTypeToken = TypeToken.get(type).getSupertype(Map.class);\n-    ParameterizedType mapParameterizedType = (ParameterizedType) mapTypeToken.getType();\n-    return mapParameterizedType.getActualTypeArguments();\n-  }\n }\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n package com.google.gson;\n \n-import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n     public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n-      TypeToken<?> typeToken = TypeToken.get(genericClass);\n-      String className = typeToken.getRawType().getSimpleName();\n+      Class<?> rawType = Types.getRawType(genericClass);\n+      String className = rawType.getSimpleName();\n       T value = (T) json.getAsJsonObject().get(className).getAsObject();\n-      if (typeToken.isPrimitive()) {\n+      if (Primitives.isPrimitive(genericClass)) {\n         PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n-        value = (T) typeAdapter.adaptType(value, typeToken.getRawType());\n+        value = (T) typeAdapter.adaptType(value, rawType);\n       }\n       return new MyParameterizedType<T>(value);\n     }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.reflect;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Jesse Wilson\n+ */\n+@SuppressWarnings({\"UnusedDeclaration\", \"deprecation\"})\n+public final class TypeTokenTest extends TestCase {\n+\n+  List<Integer> listOfInteger = null;\n+  List<Number> listOfNumber = null;\n+  List<String> listOfString = null;\n+  List<?> listOfUnknown = null;\n+  List<Set<String>> listOfSetOfString = null;\n+  List<Set<?>> listOfSetOfUnknown = null;\n+\n+  public void testIsAssignableFromRawTypes() {\n+    assertTrue(TypeToken.get(Object.class).isAssignableFrom(String.class));\n+    assertFalse(TypeToken.get(String.class).isAssignableFrom(Object.class));\n+    assertTrue(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class));\n+    assertFalse(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class));\n+  }\n+\n+  public void testIsAssignableFromWithTypeParameters() throws Exception {\n+    Type a = getClass().getDeclaredField(\"listOfInteger\").getGenericType();\n+    Type b = getClass().getDeclaredField(\"listOfNumber\").getGenericType();\n+    assertTrue(TypeToken.get(a).isAssignableFrom(a));\n+    assertTrue(TypeToken.get(b).isAssignableFrom(b));\n+\n+    // listOfInteger = listOfNumber; // doesn't compile; must be false\n+    assertFalse(TypeToken.get(a).isAssignableFrom(b));\n+    // listOfNumber = listOfInteger; // doesn't compile; must be false\n+    assertFalse(TypeToken.get(b).isAssignableFrom(a));\n+  }\n+\n+  public void testIsAssignableFromWithBasicWildcards() throws Exception {\n+    Type a = getClass().getDeclaredField(\"listOfString\").getGenericType();\n+    Type b = getClass().getDeclaredField(\"listOfUnknown\").getGenericType();\n+    assertTrue(TypeToken.get(a).isAssignableFrom(a));\n+    assertTrue(TypeToken.get(b).isAssignableFrom(b));\n+\n+    // listOfString = listOfUnknown  // doesn't compile; must be false\n+    assertFalse(TypeToken.get(a).isAssignableFrom(b));\n+    listOfUnknown = listOfString; // compiles; must be true\n+    assertTrue(TypeToken.get(b).isAssignableFrom(a));\n+  }\n+\n+  public void testIsAssignableFromWithNestedWildcards() throws Exception {\n+    Type a = getClass().getDeclaredField(\"listOfSetOfString\").getGenericType();\n+    Type b = getClass().getDeclaredField(\"listOfSetOfUnknown\").getGenericType();\n+    assertTrue(TypeToken.get(a).isAssignableFrom(a));\n+    assertTrue(TypeToken.get(b).isAssignableFrom(b));\n+\n+    // listOfSetOfString = listOfSetOfUnknown; // doesn't compile; must be false\n+    assertFalse(TypeToken.get(a).isAssignableFrom(b));\n+    // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false\n+    assertFalse(TypeToken.get(b).isAssignableFrom(a));\n+  }\n+}", "timestamp": 1291399946, "metainfo": ""}