{"sha": "31964507c1caabc9a70e3270fa56aaee29eff6b2", "log": "Updated SuppressWarnings annotations to Eclipse 3.6/3.7 which is unfortunately incompatible with Eclipse 3.5 (rawtypes vs unchecked) This CL eliminates all eclipse warnings.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  * @author Joel Leitch\n  */\n public final class Gson {\n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   static final ParameterizedTypeHandlerMap EMPTY_MAP =\n     new ParameterizedTypeHandlerMap().makeUnmodifiable();\n \n    * @return Json representation of {@code src}\n    * @since 1.4\n    */\n-  @SuppressWarnings(\"unchecked\") // the caller is required to make src and typeOfSrc consistent\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the caller is required to make src and typeOfSrc consistent\n   public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n     // Serialize 'src' to JSON, then deserialize that to a JSON tree.\n     TypeAdapter adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n    * according to {@link Object#equals(Object) Object.equals()}. The returned\n    * type is {@link java.io.Serializable}.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   public static Type canonicalize(Type type) {\n     if (type instanceof Class) {\n       Class<?> c = (Class<?>) type;\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   public static Class<?> getRawType(Type type) {\n     if (type instanceof Class<?>) {\n       // type is a normal class.\n   /**\n    * Returns true if {@code a} and {@code b} are equal.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   public static boolean equals(Type a, Type b) {\n     if (a == b) {\n       // also handles (a == null && b == null)\n     return o != null ? o.hashCode() : 0;\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   public static String typeToString(Type type) {\n     return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n   }\n   /**\n    * Returns true if this type is an array.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   public static boolean isArray(Type type) {\n     return type instanceof GenericArrayType\n         || (type instanceof Class && ((Class<?>) type).isArray());\n     return new Type[] { Object.class, Object.class };\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n     // this implementation is made a little more complicated in an attempt to avoid object-creation\n     while (true) {\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n-  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n+  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n     Class<?> declaredByRaw = declaringClassOf(unknown);\n \n     // we can't reduce this further\n    * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n    * a class.\n    */\n-  @SuppressWarnings(\"unchecked\")\n-  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+  private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n     GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n     return genericDeclaration instanceof Class\n         ? (Class<?>) genericDeclaration\n     private final Type rawType;\n     private final Type[] typeArguments;\n \n-    @SuppressWarnings(\"unchecked\")\n     public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n       // require an owner type if the raw type needs it\n       if (rawType instanceof Class<?>) {\n-        Class rawTypeAsClass = (Class) rawType;\n+        Class<?> rawTypeAsClass = (Class<?>) rawType;\n         checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n         checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n       }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n  */\n public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n   public static final Factory FACTORY = new Factory() {\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n     TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));\n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n \n-    @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\n     TypeAdapter<T> result = new Adapter(context, elementType, elementTypeAdapter, constructor);\n     return result;\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java\n     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Override public JsonToken peek() throws IOException {\n     if (stack.isEmpty()) {\n       return JsonToken.END_DOCUMENT;\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Override public String nextName() throws IOException {\n     expect(JsonToken.NAME);\n-    Iterator<?> i = (Iterator) peekStack();\n+    Iterator<?> i = (Iterator<?>) peekStack();\n     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n     stack.add(entry.getValue());\n     return (String) entry.getKey();\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n     TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n \n-    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    // we don't define a type parameter for the key or value types\n     TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,\n         keyAndValueTypes[1], valueAdapter, constructor);\n     return result;\n--- a/gson/src/main/java/com/google/gson/internal/bind/Reflection.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/Reflection.java\n   /**\n    * Finds a compatible runtime type if it is more specific\n    */\n-  @SuppressWarnings(\"unchecked\")\n   public static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\n     if (value != null\n-        && (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>)) {\n+        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\n       type = value.getClass();\n     }\n     return type;\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n     // special casing primitives here saves ~5% on Android...\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n-      @SuppressWarnings(\"unchecked\") // the type adapter and field type always agree\n+      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n--- a/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java\n \n     ObjectConstructor<?> constructor = constructorConstructor.getConstructor(typeToken);\n \n-    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    // we don't define a type parameter for the key or value types\n     TypeAdapter<T> result = new Adapter(valueAdapter, constructor);\n     return result;\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n     return delegate.read(reader);\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   @Override\n   public void write(JsonWriter writer, T value) throws IOException {\n     // Order of preference for choosing type adapters\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n   public static <TT> TypeAdapter.Factory newEnumTypeHierarchyFactory(final Class<TT> clazz) {\n     return new TypeAdapter.Factory() {\n-      @SuppressWarnings(\"unchecked\")\n+      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n       public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n         return clazz.isAssignableFrom(rawType)\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n    * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n    * canonical form}.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   static Type getSuperclassTypeParameter(Class<?> subclass) {\n     Type superclass = subclass.getGenericSuperclass();\n     if (superclass instanceof Class) {\n    * Checks if two types are the same or are equivalent under a variable mapping\n    * given in the type map that was provided.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\n     return to.equals(from)\n         || (from instanceof TypeVariable\n--- a/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java\n   private final MiniGson gson = new MiniGson.Builder().build();\n   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);\n \n-  @SuppressWarnings(\"unchecked\")\n   public void testDeserialize() throws Exception {\n-    Map<?, ?> map = (Map) adapter.fromJson(\"{a: 5, b: [1, 2, null], c: {x: y}}\");\n+    Map<?, ?> map = (Map<?, ?>) adapter.fromJson(\"{a: 5, b: [1, 2, null], c: {x: y}}\");\n     assertEquals(5.0, map.get(\"a\"));\n     assertEquals(Arrays.asList(1.0, 2.0, null), map.get(\"b\"));\n     assertEquals(Collections.singletonMap(\"x\", \"y\"), map.get(\"c\"));\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n     public int hashCode() {\n       return value == null ? 0 : value.hashCode();\n     }\n+\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public boolean equals(Object obj) {\n       if (getClass() != obj.getClass()) {\n         return false;\n       }\n-      MyParameterizedType other = (MyParameterizedType) obj;\n+      MyParameterizedType<T> other = (MyParameterizedType<T>) obj;\n       if (value == null) {\n         if (other.value != null) {\n           return false;\n--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n     assertEquals(\"[1,2,3,4,5,6,7,8,9]\", gson.toJson(target));\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   public void testRawCollectionSerialization() {\n     BagOfPrimitives bag1 = new BagOfPrimitives();\n     Collection target = Arrays.asList(bag1, bag1);\n     assertTrue(json.contains(bag1.getExpectedJson()));\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   public void testRawCollectionDeserializationNotAlllowed() {\n     String json = \"[0,1,2,3,4,5,6,7,8,9]\";\n     Collection integers = gson.fromJson(json, Collection.class);\n     assertTrue(strings.contains(\"World\"));\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   public void testRawCollectionOfBagOfPrimitivesNotAllowed() {\n     BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, \"stringValue\");\n     String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';\n     ArrayList<Long> longs = new ArrayList<Long>();\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   private static int[] toIntArray(Collection collection) {\n     int[] ints = new int[collection.size()];\n     int i = 0;\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n     assertEquals(2, target.get(\"b\").intValue());\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public void testRawMapSerialization() {\n     Map map = new LinkedHashMap();\n     map.put(\"a\", 1);\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   static final class MapWithGeneralMapParameters {\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n     final Map<String, Object> map = new LinkedHashMap();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n     assertEquals(target.getExpectedJson(), gson.toJson(target));\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   public void testClassWithTransientFieldsDeserialization() throws Exception {\n     String json = \"{\\\"longValue\\\":[1]}\";\n     ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);\n     assertEquals(json, target.getExpectedJson());\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings(\"rawtypes\")\n   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()\n       throws Exception {\n     String json = \"{\\\"transientLongValue\\\":1,\\\"longValue\\\":[1]}\";\n--- a/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java\n     gson = new Gson();\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public void testCompactFormattingLeavesNoWhiteSpace() {\n     List list = new ArrayList();\n     list.add(new BagOfPrimitives());", "timestamp": 1319146366, "metainfo": ""}