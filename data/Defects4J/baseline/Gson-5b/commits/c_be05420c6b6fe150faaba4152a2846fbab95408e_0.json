{"sha": "be05420c6b6fe150faaba4152a2846fbab95408e", "log": "Renamed Id to ValueBasedId renamed RestClient to ResourceDepotClient. Added ability to simulate an HTTP PUT or GET with a POST. Added support for extracting resource Id in callpath. Added Id to RestRequest.", "commit": "\n--- /dev/null\n+++ b/wsclient/src/main/java/com/google/gson/rest/client/ResourceDepotClient.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.rest.client;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.rest.definition.ID;\n+import com.google.gson.rest.definition.ResourceDepot;\n+import com.google.gson.rest.definition.RestCallSpec;\n+import com.google.gson.rest.definition.RestRequest;\n+import com.google.gson.rest.definition.RestResource;\n+import com.google.gson.rest.definition.RestResponse;\n+import com.google.gson.webservice.definition.CallPath;\n+import com.google.gson.webservice.definition.HeaderMap;\n+import com.google.gson.webservice.definition.HttpMethod;\n+\n+/**\n+ * A client class to access a rest resource\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class ResourceDepotClient<I extends ID, R extends RestResource<I, R>> implements ResourceDepot<I, R> {\n+  private final RestClientStub stub;\n+  private final RestCallSpec callSpec;\n+  private final Type resourceType;\n+  private final Gson gson;\n+\n+  /**\n+   * @param stub stub containing server info to access the rest client\n+   * @param callPath relative path to the resource\n+   * @param resourceType Class for the resource. Such as Cart.class\n+   */\n+  public ResourceDepotClient(RestClientStub stub, CallPath callPath, Type resourceType, Gson gson) {\n+    this(stub, resourceType, generateRestCallSpec(callPath, resourceType), gson);\n+  }\n+\n+  protected ResourceDepotClient(RestClientStub stub, Type resourceType, RestCallSpec callSpec, Gson gson) {\n+    this.stub = stub;\n+    this.callSpec = callSpec;\n+    this.resourceType = resourceType;\n+    this.gson = gson;\n+  }\n+\n+  private static <T> RestCallSpec generateRestCallSpec(CallPath callPath, Type resourceType) {\n+    return new RestCallSpec.Builder(callPath, resourceType).build();\n+  }\n+\n+  public R get(I resourceId) {\n+    HeaderMap requestHeaders =\n+      new HeaderMap.Builder(callSpec.getRequestSpec().getHeadersSpec()).build();\n+    RestRequest<I, R> request =\n+      new RestRequest<I, R>(HttpMethod.GET, requestHeaders, resourceId, null, resourceType);\n+    RestResponse<I, R> response = stub.getResponse(callSpec, request, gson);\n+    return response.getBody();\n+  }\n+\n+  public R post(R resource) {\n+    HeaderMap requestHeaders =\n+      new HeaderMap.Builder(callSpec.getRequestSpec().getHeadersSpec()).build();\n+    RestRequest<I, R> request =\n+      new RestRequest<I, R>(HttpMethod.POST, requestHeaders, resource.getId(), resource, resourceType);\n+    RestResponse<I, R> response = stub.getResponse(callSpec, request, gson);\n+    return response.getBody();\n+  }\n+\n+  public R put(R resource) {\n+    HeaderMap requestHeaders =\n+      new HeaderMap.Builder(callSpec.getRequestSpec().getHeadersSpec()).build();\n+    RestRequest<I, R> request =\n+      new RestRequest<I, R>(HttpMethod.PUT, requestHeaders, resource.getId(), resource, resourceType);\n+    RestResponse<I, R> response = stub.getResponse(callSpec, request, gson);\n+    return response.getBody();\n+  }\n+\n+  public void delete(I resourceId) {\n+    HeaderMap requestHeaders =\n+      new HeaderMap.Builder(callSpec.getRequestSpec().getHeadersSpec()).build();\n+    RestRequest<I, R> request =\n+      new RestRequest<I, R>(HttpMethod.DELETE, requestHeaders, resourceId, null, resourceType);\n+    stub.getResponse(callSpec, request, gson);\n+  }\n+}\n--- a/wsclient/src/main/java/com/google/gson/rest/client/RestClientStub.java\n+++ b/wsclient/src/main/java/com/google/gson/rest/client/RestClientStub.java\n       RestCallSpec callSpec, RestRequest<I, R> request, Gson gson) {\n     HttpURLConnection conn = null;\n     try {\n-      URL webServiceUrl = getWebServiceUrl(callSpec, getId(request.getBody()));\n-      if (logger != null) {\n-        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n-      }\n+      URL webServiceUrl = getWebServiceUrl(callSpec, request.getId());\n       conn = (HttpURLConnection) webServiceUrl.openConnection();\n       return getResponse(callSpec, request, gson, conn);\n     } catch (IOException e) {\n    * want to use HTTP pipelining.\n    */\n   public <I extends ID, R extends RestResource<I, R>> RestResponse<I, R> getResponse(\n-      RestCallSpec callSpec, RestRequest<I, R> request, Gson gson, HttpURLConnection conn) {\n+      RestCallSpec callSpec, RestRequest<I, R> request, Gson gson,\n+      HttpURLConnection conn) {\n     try {\n       if (logger != null) {\n-        URL webServiceUrl = getWebServiceUrl(callSpec, getId(request.getBody()));\n+        URL webServiceUrl = getWebServiceUrl(callSpec, request.getId());\n         logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n       }\n       RestRequestSender requestSender = new RestRequestSender(gson, logLevel);\n     }\n   }\n \n-  private static <I extends ID, R extends RestResource<I, R>> I getId(R resource) {\n-    return (resource == null || !resource.hasId()) ? null : resource.getId(); \n-  }\n-\n   @Override\n   public String toString() {\n     return String.format(\"config:%s\", config);\n--- a/wsclient/src/main/java/com/google/gson/rest/client/RestRequestSender.java\n+++ b/wsclient/src/main/java/com/google/gson/rest/client/RestRequestSender.java\n import com.google.gson.rest.definition.RestResource;\n import com.google.gson.webservice.definition.HeaderMap;\n import com.google.gson.webservice.definition.HeaderMapSpec;\n+import com.google.gson.webservice.definition.HttpMethod;\n import com.google.gson.webservice.definition.WebServiceSystemException;\n import com.google.gson.wsclient.internal.utils.Streams;\n \n  * @author inder\n  */\n public final class RestRequestSender {\n+  private static final boolean SIMULATE_GET_WITH_POST = true;\n+  private static final boolean SIMULATE_PUT_WITH_POST = true;\n+\n   private final Gson gson;\n   private final Logger logger;\n   private final Level logLevel;\n     this.logLevel = logLevel;\n   }\n   \n-  public <I extends ID, R extends RestResource<I, R>> void send(HttpURLConnection conn, RestRequest<I, R> request) {    \n+  public <I extends ID, R extends RestResource<I, R>> void send(\n+      HttpURLConnection conn, RestRequest<I, R> request) {    \n     try {\n-      conn.setRequestMethod(request.getHttpMethod().toString());\n+      HttpMethod method = request.getHttpMethod();\n+      if (SIMULATE_PUT_WITH_POST && method == HttpMethod.PUT) {\n+        method = HttpMethod.POST;\n+        setHeader(conn, HttpMethod.SIMULATED_METHOD_HEADER, HttpMethod.PUT.toString(), true);\n+      } else  if (SIMULATE_GET_WITH_POST && method == HttpMethod.GET) {\n+        method = HttpMethod.POST;\n+        setHeader(conn, HttpMethod.SIMULATED_METHOD_HEADER, HttpMethod.GET.toString(), true);\n+      }\n+      conn.setRequestMethod(method.toString());\n       setHeader(conn, \"Content-Type\", request.getContentType(), true);\n       \n       // Assume conservatively that the response will need to be read.\n       \n       R requestBody = request.getBody();\n       String requestBodyContents = \"\";\n-      // Android Java VM ignore Content-Length if setDoOutput is not set\n-      conn.setDoOutput(true);\n+      if (method == HttpMethod.POST || method == HttpMethod.PUT) {\n+        // Android Java VM ignore Content-Length if setDoOutput is not set\n+        conn.setDoOutput(true);\n+      }\n       if (requestBody != null) {\n         requestBodyContents = gson.toJson(requestBody, request.getSpec().getResourceType());\n       }\n--- a/wsdef/src/main/java/com/google/gson/rest/definition/ID.java\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/ID.java\n package com.google.gson.rest.definition;\n \n public interface ID {\n-  public static final long INVALID_ID = 0L;\n+  public static final long INVALID_ID = -1L;\n \n   public long getValue();\n }\n--- a/wsdef/src/main/java/com/google/gson/rest/definition/IDFactory.java\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/IDFactory.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.google.gson.rest.definition;\n \n import java.lang.reflect.Type;\n \n+/**\n+ * A factory to create {@link ValueBasedId)s\n+ *\n+ * @author inder\n+ *\n+ * @param <I>\n+ */\n public class IDFactory<I extends ID> {\n   private final Class<? super I> classOfI;\n   private final Type typeOfId;\n     this.typeOfId = typeOfId;\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n   public I createId(long value) {\n-    if (classOfI.isAssignableFrom(Id.class)) {\n-      return (I)Id.get(value, typeOfId);\n+    if (classOfI.isAssignableFrom(ValueBasedId.class)) {\n+      return (I)ValueBasedId.get(value, typeOfId);\n     } \n     throw new UnsupportedOperationException();\n   }\n--- /dev/null\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/ResourceDepot.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.rest.definition;\n+\n+public interface ResourceDepot<I extends ID, R extends RestResource<I, R>> {\n+\n+  public R get(I resourceId);\n+\n+  public R post(R resource);\n+\n+  public R put(R resource);\n+\n+  public void delete(I resourceId);\n+}\n--- a/wsdef/src/main/java/com/google/gson/rest/definition/ResourceMap.java\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/ResourceMap.java\n     private final Map<CallPath, RestCallSpec> resources =\n       new HashMap<CallPath, RestCallSpec>();\n     \n-    public Builder set(CallPath callPath, RestCallSpec spec) {\n-      Preconditions.checkArgument(resources.get(callPath) == null);\n-      resources.put(callPath, spec);\n+    public Builder set(CallPath baseCallPath, RestCallSpec spec) {\n+      Preconditions.checkArgument(resources.get(baseCallPath) == null);\n+      resources.put(baseCallPath, spec);\n       return this;\n     }\n \n--- a/wsdef/src/main/java/com/google/gson/rest/definition/RestCallSpec.java\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/RestCallSpec.java\n       \"path: %s, version: %.2f, resourceType: %s, requestSpec: %s, responseSpec: %s\",\n       path, version, resourceType, requestSpec, responseSpec);\n   }\n+\n+  public RestCallSpec createCopy(CallPath callPath) {\n+    return new RestCallSpec(supportedHttpMethods, callPath, requestSpec,\n+        responseSpec, resourceType, version);\n+  }\n }\n--- a/wsdef/src/main/java/com/google/gson/rest/definition/RestRequest.java\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/RestRequest.java\n \n   private final HttpMethod method;\n   private final HeaderMap headers;\n+  private final I id;\n   private final R body;\n   private final RestRequestSpec spec;\n   \n   public RestRequest(HttpMethod method, HeaderMap requestHeaders,\n-      R requestBody, Type resourceType) {\n+      I resourceId, R requestBody, Type resourceType) {\n     this.method = method;\n+    this.id = resourceId;\n     this.body = requestBody;\n     this.headers = requestHeaders;\n     this.spec = new RestRequestSpec(requestHeaders.getSpec(), resourceType);\n   }\n \n   public I getId() {\n-    return body.getId();\n+    return id;\n   }\n \n   public HttpMethod getMethod() {\n--- /dev/null\n+++ b/wsdef/src/main/java/com/google/gson/rest/definition/ValueBasedId.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.rest.definition;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.webservice.definition.internal.utils.Preconditions;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+/**\n+ * An id for a rest resource\n+ *\n+ * @author inder\n+ *\n+ * @param <R> type variable for the rest resource\n+ */\n+public final class ValueBasedId<R> implements ID {\n+  private final long value;\n+  private final Type typeOfId;\n+\n+  private ValueBasedId(long value, Type typeOfId) {\n+    this.value = value;\n+    this.typeOfId = typeOfId;\n+  }\n+\n+  @Override\n+  public long getValue() {\n+    return value;\n+  }\n+\n+  public static long getValue(ValueBasedId<?> id) {\n+    return id == null ? INVALID_ID : id.getValue();\n+  }\n+\n+  public String getValueAsString() {\n+    return String.valueOf(value);\n+  }\n+\n+  public Type getTypeOfId() {\n+    return typeOfId;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) value;\n+  }\n+\n+  public static boolean isValid(ValueBasedId<?> id) {\n+    return id != null && id.value != INVALID_ID;\n+  }\n+\n+  /**\n+   * A more efficient comparison method for ids that take into account of ids being nullable.\n+   * Since the method is parameterized and both ids are of the same type, this method compares\n+   * only id values, not their types. Note that this shortcut doesn't work if you pass raw ids\n+   * to this method\n+   */\n+  public static <T> boolean equals(/* @Nullable */ ValueBasedId<T> id1,\n+      /* @Nullable */ ValueBasedId<T> id2) {\n+    if ((id1 == null && id2 != null) || (id1 != null && id2 == null)) {\n+      return false;\n+    }\n+    if (id1 == null && id2 == null) {\n+      return true;\n+    }\n+    return id1.value == id2.value;\n+  }\n+\n+  @Override  \n+  public boolean equals(Object obj) {\n+    if (this == obj) return true;\n+    if (obj == null) return false;\n+    if (getClass() != obj.getClass()) return false;\n+    @SuppressWarnings(\"unchecked\")\n+    ValueBasedId<R> other = (ValueBasedId<R>)obj;\n+    if (typeOfId == null) {\n+      if (other.typeOfId != null) return false;\n+    } else if (!equivalentTypes(typeOfId, other.typeOfId)) return false;\n+    if (value != other.value) return false;\n+    return true;\n+  }\n+\n+  /**\n+   * Returns true for equivalentTypes(Class<?>, Class)\n+   * Visible for testing only \n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  static boolean equivalentTypes(Type type1, Type type2) {\n+    if (type1 instanceof ParameterizedType && type2 instanceof Class) {\n+      return areEquivalentTypes((ParameterizedType)type1, (Class)type2);\n+    } else if (type2 instanceof ParameterizedType && type1 instanceof Class) {\n+      return areEquivalentTypes((ParameterizedType)type2, (Class)type1);\n+    }\n+    return type1.equals(type2);\n+  }\n+\n+  /**\n+   * Visible for testing only\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  static boolean areEquivalentTypes(ParameterizedType type, Class clazz) {\n+    Class rawClass = (Class) type.getRawType();\n+    if (!clazz.equals(rawClass)) {\n+      return false;\n+    }\n+    for (Type typeVariable : type.getActualTypeArguments()) {\n+      if (typeVariable instanceof WildcardType) {\n+        continue;\n+      }\n+      // This is a real parameterized type, not just ?\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  public static <RS> ValueBasedId<RS> get(long value, Type typeOfId) {\n+    return new ValueBasedId<RS>(value, typeOfId);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String typeAsString = getSimpleTypeName(typeOfId);\n+    return String.format(\"{value:%s,type:%s}\", value, typeAsString);\n+  }\n+\n+  @SuppressWarnings(\"rawtypes\")\n+  private static String getSimpleTypeName(Type type) {\n+    if (type == null) {\n+      return \"null\";\n+    }\n+    if (type instanceof Class) {\n+      return ((Class)type).getSimpleName();\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType pType = (ParameterizedType) type;\n+      StringBuilder sb = new StringBuilder(getSimpleTypeName(pType.getRawType()));\n+      sb.append('<');\n+      boolean first = true;\n+      for (Type argumentType : pType.getActualTypeArguments()) {\n+        if (first) {\n+          first = false;\n+        } else {\n+          sb.append(',');\n+        }\n+        sb.append(getSimpleTypeName(argumentType));\n+      }\n+      sb.append('>');\n+      return sb.toString();\n+    } else if (type instanceof WildcardType) {\n+      return \"?\";\n+    }\n+    return type.toString();\n+  }\n+\n+  /**\n+   * Type adapter for converting an Id to its serialized form\n+   *\n+   * @author inder\n+   *\n+   */\n+  public static final class GsonTypeAdapter implements JsonSerializer<ValueBasedId<?>>,\n+      JsonDeserializer<ValueBasedId<?>> {\n+\n+    @Override\n+    public JsonElement serialize(ValueBasedId<?> src, Type typeOfSrc,\n+        JsonSerializationContext context) {\n+      return new JsonPrimitive(src.getValue());\n+    }\n+\n+    @Override\n+    public ValueBasedId<?> deserialize(JsonElement json, Type typeOfT,\n+        JsonDeserializationContext context) throws JsonParseException {\n+      if (!(typeOfT instanceof ParameterizedType)) {\n+        throw new JsonParseException(\"Id of unknown type: \" + typeOfT);\n+      }\n+      ParameterizedType parameterizedType = (ParameterizedType) typeOfT;\n+      // Since Id takes only one TypeVariable, the actual type corresponding to the first\n+      // TypeVariable is the Type we are looking for\n+      Type typeOfId = parameterizedType.getActualTypeArguments()[0];\n+      return ValueBasedId.get(json.getAsLong(), typeOfId);\n+    }\n+  }\n+}\n--- a/wsdef/src/main/java/com/google/gson/webservice/definition/CallPath.java\n+++ b/wsdef/src/main/java/com/google/gson/webservice/definition/CallPath.java\n  */\n package com.google.gson.webservice.definition;\n \n+import com.google.gson.rest.definition.ID;\n+import com.google.gson.webservice.definition.internal.utils.Pair;\n+\n /**\n  * Encapsulation of a Web service path that is sent by the client.\n  * \n  */\n public final class CallPath {\n \n+  private static final double IGNORE_VERSION = -1D;\n   private final String path;\n   private final double version;\n+  private final long resourceId;\n \n   public CallPath(String path) {\n     if (path == null) {\n       this.path = null;\n-      version = -1D;\n+      version = IGNORE_VERSION;\n+      resourceId = ID.INVALID_ID;\n     } else {\n-      int index1 = path.indexOf('/');\n-      int index2 = path.substring(index1+1).indexOf('/');\n-      String versionStr = path.substring(index1+1, index2+1);\n-      String callPathStr = path;\n-      double givenVersion = -1D;\n-      try {\n-        // Skip over the version number from the URL\n-        givenVersion = Double.parseDouble(versionStr);\n-        callPathStr = path.substring(index2+1);\n-      } catch (NumberFormatException e) {\n-        // Assume that version number wasn't specified\n-      }\n-      this.path = callPathStr;\n-      this.version = givenVersion;\n+      Pair<Double, String> path2 = extractVersion(path);\n+      this.version = path2.first;\n+      Pair<Long, String> path3 = extractId(path2.second);\n+      this.resourceId = path3.first;\n+      this.path = path3.second;\n     }\n   }\n+\n+  /**\n+   * Returns path after consuming version number from the begining\n+   */\n+  private static Pair<Double, String> extractVersion(String path) {\n+    int index1 = path.indexOf('/');\n+    int index2 = path.substring(index1+1).indexOf('/');\n+    String versionStr = path.substring(index1+1, index2+1);\n+    double extractedVersion = -1.0D;\n+    String revisedPath = path;\n+    try {\n+      // Skip over the version number from the URL\n+      extractedVersion = Double.parseDouble(versionStr);\n+      revisedPath = path.substring(index2+1);\n+    } catch (NumberFormatException e) {\n+      // Assume that version number wasn't specified\n+    }\n+    return Pair.create(extractedVersion, revisedPath);\n+  }\n+\n+  private static Pair<Long, String> extractId(String path) {\n+    Pair<Long, String> originalPath = Pair.create(ID.INVALID_ID, path);\n+    int end = path.endsWith(\"/\") ? path.length() - 1 : path.length();\n+    int begin = path.substring(0, end-1).lastIndexOf('/') + 1;\n+    if (begin < 0 || end < 0 || begin >= end) {\n+      return originalPath;\n+    }\n+    try {\n+      String id = path.substring(begin, end);\n+      String pathWithoutId = path.substring(0, begin-1);\n+      return Pair.create(Long.parseLong(id), pathWithoutId);\n+    } catch (NumberFormatException e) {\n+      return originalPath;\n+    }\n+  }\n \n   public String get() {\n     return path;\n     return version;\n   }\n \n+  public long getResourceId() {\n+    return resourceId;\n+  }\n+\n   @Override\n   public int hashCode() {\n     return path.hashCode();\n+  }\n+\n+  public boolean matches(CallPath callPath) {\n+    return path.startsWith(callPath.get());\n   }\n \n   @Override\n \n   @Override\n   public String toString() {\n-    return path;\n+    return String.format(\"path:%s, version:%2.f, resourceId: %d\", path, version, resourceId);\n   }\n }\n--- a/wsdef/src/main/java/com/google/gson/webservice/definition/HttpMethod.java\n+++ b/wsdef/src/main/java/com/google/gson/webservice/definition/HttpMethod.java\n   \n   public static final List<HttpMethod> ALL_METHODS =\n     Collections.unmodifiableList(Arrays.asList(values()));\n-}\n+\n+  /**\n+   * This header is used to indicate the real method that is channeled through the current\n+   * request. For example, you can use it to send PUT requests under a POST.\n+   */\n+  public static final String SIMULATED_METHOD_HEADER = \"SimulatedMethod\";\n+}\n--- /dev/null\n+++ b/wsdef/src/main/java/com/google/gson/webservice/definition/internal/utils/Pair.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.webservice.definition.internal.utils;\n+\n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n+public final class Pair<FIRST, SECOND> {\n+\n+  public final FIRST first;\n+  public final SECOND second;\n+\n+  public Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  public static <F, S> Pair<F, S> create(F first, S second) {\n+    return new Pair<F, S>(first, second);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    Pair<?, ?> that = (Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n+}\n--- a/wsdef/src/test/java/com/google/gson/rest/definition/IdTest.java\n+++ b/wsdef/src/test/java/com/google/gson/rest/definition/IdTest.java\n import junit.framework.TestCase;\n \n import com.google.gson.reflect.TypeToken;\n-import com.google.gson.rest.definition.Id;\n+import com.google.gson.rest.definition.ValueBasedId;\n \n /**\n- * Unit test for {@link Id}\n+ * Unit test for {@link ValueBasedId}\n  *\n  * @author inder\n  */\n public class IdTest extends TestCase {\n \n   public void testRawTypeNotEqualToParameterizedOfConcreteType() {\n-    ParameterizedType type = (ParameterizedType) new TypeToken<Id<Foo>>(){}.getType(); \n-    assertFalse(Id.areEquivalentTypes(type, Id.class));\n+    ParameterizedType type = (ParameterizedType) new TypeToken<ValueBasedId<Foo>>(){}.getType(); \n+    assertFalse(ValueBasedId.areEquivalentTypes(type, ValueBasedId.class));\n   }\n \n   public void testRawTypeEqualToParameterizedOfWildcardType() {\n-    ParameterizedType fooType = (ParameterizedType) new TypeToken<Id<?>>(){}.getType(); \n-    assertTrue(Id.areEquivalentTypes(fooType, Id.class));\n+    ParameterizedType fooType = (ParameterizedType) new TypeToken<ValueBasedId<?>>(){}.getType(); \n+    assertTrue(ValueBasedId.areEquivalentTypes(fooType, ValueBasedId.class));\n   }\n \n   public void testStaticEquals() {\n-    Id<Foo> id1 = Id.get(3L, Foo.class);\n-    Id<Foo> id2 = Id.get(3L, Foo.class);\n-    Id<Foo> id3 = Id.get(4L, Foo.class);\n-    assertTrue(Id.equals(id1, id2));\n-    assertFalse(Id.equals(null, id2));\n-    assertFalse(Id.equals(id1, null));\n-    assertTrue(Id.equals(null, null));\n-    assertFalse(Id.equals(id1, id3));\n+    ValueBasedId<Foo> id1 = ValueBasedId.get(3L, Foo.class);\n+    ValueBasedId<Foo> id2 = ValueBasedId.get(3L, Foo.class);\n+    ValueBasedId<Foo> id3 = ValueBasedId.get(4L, Foo.class);\n+    assertTrue(ValueBasedId.equals(id1, id2));\n+    assertFalse(ValueBasedId.equals(null, id2));\n+    assertFalse(ValueBasedId.equals(id1, null));\n+    assertTrue(ValueBasedId.equals(null, null));\n+    assertFalse(ValueBasedId.equals(id1, id3));\n   }\n \n   private static class Foo {\n--- a/wsdef/src/test/java/com/google/gson/rest/definition/IdTypeAdapterTest.java\n+++ b/wsdef/src/test/java/com/google/gson/rest/definition/IdTypeAdapterTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.reflect.TypeToken;\n-import com.google.gson.rest.definition.Id;\n+import com.google.gson.rest.definition.ValueBasedId;\n \n /**\n- * Unit tests for {@link Id.GsonTypeAdapter}\n+ * Unit tests for {@link ValueBasedId.GsonTypeAdapter}\n  *\n  * @author inder\n  */\n public class IdTypeAdapterTest extends TestCase {\n-  private static final Id<Student> STUDENT1_ID = Id.get(5L, Student.class);\n-  private static final Id<Student> STUDENT2_ID = Id.get(6L, Student.class);\n+  private static final ValueBasedId<Student> STUDENT1_ID = ValueBasedId.get(5L, Student.class);\n+  private static final ValueBasedId<Student> STUDENT2_ID = ValueBasedId.get(6L, Student.class);\n   private static final Student STUDENT1 = new Student(STUDENT1_ID, \"first\");\n   private static final Student STUDENT2 = new Student(STUDENT2_ID, \"second\");\n   private static final Type TYPE_COURSE_HISTORY =\n     new TypeToken<Course<HistoryCourse>>(){}.getType(); \n-  private static final Id<Course<HistoryCourse>> COURSE_ID = Id.get(10L, TYPE_COURSE_HISTORY);\n+  private static final ValueBasedId<Course<HistoryCourse>> COURSE_ID = ValueBasedId.get(10L, TYPE_COURSE_HISTORY);\n \n   private Gson gson;\n   private Course<HistoryCourse> course;\n   @Override\n   protected void setUp() {\n     gson = new GsonBuilder()\n-        .registerTypeAdapter(Id.class, new Id.GsonTypeAdapter())\n+        .registerTypeAdapter(ValueBasedId.class, new ValueBasedId.GsonTypeAdapter())\n         .create();\n     course = new Course<HistoryCourse>(COURSE_ID, 4,\n         new Assignment<HistoryCourse>(null, null), createList(STUDENT1, STUDENT2));\n \n   @SuppressWarnings(\"unused\")\n   private static class Student {\n-    Id<Student> id;\n+    ValueBasedId<Student> id;\n     String name;\n \n     private Student() {\n       this(null, null);\n     }\n-    public Student(Id<Student> id, String name) {\n+    public Student(ValueBasedId<Student> id, String name) {\n       this.id = id;\n       this.name = name;\n     }\n   @SuppressWarnings(\"unused\")\n   private static class Course<T> {\n     final List<Student> students;\n-    private final Id<Course<T>> courseId;\n+    private final ValueBasedId<Course<T>> courseId;\n     private final int numAssignments;\n     private final Assignment<T> assignment;\n \n       this(null, 0, null, new ArrayList<Student>());\n     }\n \n-    public Course(Id<Course<T>> courseId, int numAssignments,\n+    public Course(ValueBasedId<Course<T>> courseId, int numAssignments,\n         Assignment<T> assignment, List<Student> players) {\n       this.courseId = courseId;\n       this.numAssignments = numAssignments;\n       this.assignment = assignment;\n       this.students = players;\n     }\n-    public Id<Course<T>> getId() {\n+    public ValueBasedId<Course<T>> getId() {\n       return courseId;\n     }\n     List<Student> getStudents() {\n \n   @SuppressWarnings(\"unused\")\n   private static class Assignment<T> {\n-    private final Id<Assignment<T>> id;\n+    private final ValueBasedId<Assignment<T>> id;\n     private final T data;\n \n     private Assignment() {\n       this(null, null);\n     }\n-    public Assignment(Id<Assignment<T>> id, T data) {\n+    public Assignment(ValueBasedId<Assignment<T>> id, T data) {\n       this.id = id;\n       this.data = data;\n     }\n--- a/wsdef/src/test/java/com/google/gson/webservice/definition/CallPathTest.java\n+++ b/wsdef/src/test/java/com/google/gson/webservice/definition/CallPathTest.java\n \n import junit.framework.TestCase;\n \n+/**\n+ * Unit test for {@link CallPath}\n+ *\n+ * @author inder\n+ */\n public class CallPathTest extends TestCase {\n \n   public void testVersionIsSkipped() {\n     CallPath path = new CallPath(\"/1.0/rest/service1\");\n     assertEquals(\"/rest/service1\", path.get());\n     assertEquals(1D, path.getVersion());\n+    assertEquals(-1L, path.getResourceId());\n   }\n \n   public void testVersionNotPresent() {\n     CallPath path = new CallPath(\"/rest/service1\");\n     assertEquals(\"/rest/service1\", path.get());\n     assertEquals(-1D, path.getVersion());\n+    assertEquals(-1L, path.getResourceId());\n+  }\n+  \n+  public void testResourceIdPresent() {\n+    CallPath path = new CallPath(\"/rest/service/3\");\n+    assertEquals(\"/rest/service\", path.get());\n+    assertEquals(3L, path.getResourceId());\n+  }\n+\n+  public void testResourceIdWithEndSlashPresent() {\n+    CallPath path = new CallPath(\"/rest/service/3/\");\n+    assertEquals(\"/rest/service\", path.get());\n+    assertEquals(3L, path.getResourceId());\n+  }\n+\n+  public void testVersionAndResourceIdPresent() {\n+    CallPath path = new CallPath(\"/3.1/rest/service53/323222\");\n+    assertEquals(3.1D, path.getVersion());\n+    assertEquals(\"/rest/service53\", path.get());\n+    assertEquals(323222L, path.getResourceId());\n   }\n }\n--- a/wsf/src/main/java/com/google/gson/rest/server/IdMap.java\n+++ b/wsf/src/main/java/com/google/gson/rest/server/IdMap.java\n  */\n public class IdMap<I extends ID, T extends HasId<I>> {\n   public static final Logger LOG = Logger.getLogger(IdMap.class.getName());\n+  public static final long ID_START_VALUE = 1L;\n   protected final Map<I, T> map;\n   private volatile long nextAvailableId;\n   private final IDFactory<I> idFactory;\n    */\n   protected IdMap(Class<? super I> classOfI, Type typeOfId) {\n     map = new ConcurrentHashMap<I, T>();\n-    nextAvailableId = 0;\n+    nextAvailableId = ID_START_VALUE;\n     this.idFactory = new IDFactory<I>(classOfI, typeOfId);\n   }\n \n--- a/wsf/src/main/java/com/google/gson/rest/server/RestRequestReceiver.java\n+++ b/wsf/src/main/java/com/google/gson/rest/server/RestRequestReceiver.java\n     this.spec = spec;\n   }\n   \n-  public RestRequest<I, R> receive(HttpServletRequest request) {\n+  public RestRequest<I, R> receive(HttpServletRequest request, I resourceId) {\n     try {\n       HeaderMap requestParams = buildRequestParams(request);\n       R requestBody = buildRequestBody(request);\n-      \n+\n       HttpMethod method = HttpMethod.getMethod(request.getMethod());\n-      return new RestRequest<I, R>(method, requestParams, requestBody, spec.getResourceType());\n+      String simulatedMethod = request.getHeader(HttpMethod.SIMULATED_METHOD_HEADER);\n+      if (simulatedMethod != null && !simulatedMethod.equals(\"\")) {\n+        method = HttpMethod.getMethod(simulatedMethod);\n+      }\n+      return new RestRequest<I, R>(method, requestParams, resourceId, requestBody, spec.getResourceType());\n     } catch (IOException e) {\n       throw new WebServiceSystemException(e);\n     } catch (JsonParseException e) {", "timestamp": 1289325608, "metainfo": ""}