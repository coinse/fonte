{"sha": "d391584d48ce87a36c88e804711a5f187e0b9086", "log": "Register Gson 1.x tree-style adapters in the TypeAdapter.Factory list rather than in the ParameterizedTypeHandlerMap.  The motivation for this change is to give tree-style adapters precedence order in registration. This fixes the test I committed earlier today, where registration order was not honored.  This renamed ParameterizedTypeHandlerMap to the shorter 'TypeMap'. For type adapters, this is now only used for type hierarchy. We still need non-hierarchy support in TypeMap for instance creators; I'll be looking for workarounds to see if further simplification is possible here.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n package com.google.gson;\n \n import com.google.gson.internal.ConstructorConstructor;\n-import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n+import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n  */\n public final class Gson {\n   @SuppressWarnings(\"rawtypes\")\n-  static final ParameterizedTypeHandlerMap EMPTY_MAP =\n-    new ParameterizedTypeHandlerMap().makeUnmodifiable();\n+  static final TypeMap EMPTY_MAP = new TypeMap().makeUnmodifiable();\n \n    static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n \n   private final ConstructorConstructor constructorConstructor;\n \n   /** Map containing Type or Class objects as keys */\n-  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final TypeMap<JsonSerializer<?>> serializers;\n \n   /** Map containing Type or Class objects as keys */\n-  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final TypeMap<JsonDeserializer<?>> deserializers;\n \n   private final boolean serializeNulls;\n   private final boolean htmlSafe;\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n+\n+  final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n+    public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n+      return (T) fromJson(json, typeOfT);\n+    }\n+  };\n+\n+  final JsonSerializationContext serializationContext = new JsonSerializationContext() {\n+    public JsonElement serialize(Object src) {\n+      return toJsonTree(src);\n+    }\n+    public JsonElement serialize(Object src, Type typeOfSrc) {\n+      return toJsonTree(src, typeOfSrc);\n+    }\n+  };\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n   Gson(final ExclusionStrategy deserializationExclusionStrategy,\n       final ExclusionStrategy serializationExclusionStrategy,\n       final FieldNamingStrategy2 fieldNamingPolicy,\n-      final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n-      final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      final TypeMap<InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n+      final TypeMap<JsonSerializer<?>> serializers,\n+      final TypeMap<JsonDeserializer<?>> deserializers,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n       factories.add(factory);\n     }\n \n-    factories.add(new GsonToMiniGsonTypeAdapterFactory(this, serializers, deserializers));\n+    factories.add(new TreeTypeAdapter.TypeHierarchyFactory(serializers, deserializers));\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(TypeAdapters.URL_FACTORY);\n     factories.add(TypeAdapters.URI_FACTORY);\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n import com.google.gson.internal.$Gson$Preconditions;\n-import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n   private boolean excludeFieldsWithoutExposeAnnotation;\n   private LongSerializationPolicy longSerializationPolicy;\n   private FieldNamingStrategy2 fieldNamingPolicy;\n-  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n-  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n-  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final TypeMap<InstanceCreator<?>> instanceCreators;\n+  private final TypeMap<JsonSerializer<?>> serializers;\n+  private final TypeMap<JsonDeserializer<?>> deserializers;\n   private final List<TypeAdapter.Factory> typeAdapterFactories\n       = new ArrayList<TypeAdapter.Factory>();\n   private boolean serializeNulls;\n     excludeFieldsWithoutExposeAnnotation = false;\n     longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n     fieldNamingPolicy = Gson.DEFAULT_NAMING_POLICY;\n-    instanceCreators = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n-    serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n-    deserializers = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n+    instanceCreators = new TypeMap<InstanceCreator<?>>();\n+    serializers = new TypeMap<JsonSerializer<?>>();\n+    deserializers = new TypeMap<JsonDeserializer<?>>();\n     serializeNulls = false;\n     dateStyle = DateFormat.DEFAULT;\n     timeStyle = DateFormat.DEFAULT;\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n     }\n-    if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializer(type, (JsonSerializer<?>) typeAdapter);\n-    }\n-    if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter);\n+    if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\n+      TypeToken<?> typeToken = TypeToken.get(type);\n+      typeAdapterFactories.add(new TreeTypeAdapter.SingleTypeFactory(typeToken, typeAdapter));\n     }\n     if (typeAdapter instanceof TypeAdapter.Factory) {\n       typeAdapterFactories.add((TypeAdapter.Factory) typeAdapter);\n   private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n       InstanceCreator<? extends T> instanceCreator) {\n     instanceCreators.register(typeOfT, instanceCreator);\n-    return this;\n-  }\n-\n-  /**\n-   * Configures Gson to use a custom JSON serializer for the specified type. You should use this\n-   * method if you want to register different serializers for different generic types corresponding\n-   * to a raw type.\n-   *\n-   *\n-   * @param typeOfT The type definition for T\n-   * @param serializer the custom serializer\n-   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n-   */\n-  private <T> GsonBuilder registerSerializer(Type typeOfT, JsonSerializer<T> serializer) {\n-    serializers.register(typeOfT, serializer);\n-    return this;\n-  }\n-\n-  /**\n-   * Configures Gson to use a custom JSON deserializer for the specified type. You should use this\n-   * method if you want to register different deserializers for different generic types\n-   * corresponding to a raw type.\n-   *\n-   *\n-   * @param typeOfT The type definition for T\n-   * @param deserializer the custom deserializer\n-   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n-   */\n-  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) {\n-    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer));\n     return this;\n   }\n \n   }\n \n   private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n-      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n+      TypeMap<JsonSerializer<?>> serializers, TypeMap<JsonDeserializer<?>> deserializers) {\n     DefaultDateTypeAdapter dateTypeAdapter = null;\n     if (datePattern != null && !\"\".equals(datePattern.trim())) {\n       dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n     }\n   }\n \n-  private static <T> void registerIfAbsent(Class<?> type,\n-      ParameterizedTypeHandlerMap<T> adapters, T adapter) {\n+  private static <T> void registerIfAbsent(Class<?> type, TypeMap<T> adapters, T adapter) {\n     if (!adapters.hasSpecificHandlerFor(type)) {\n       adapters.register(type, adapter);\n     }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.TypeMap;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the\n+ * tree adapter may be serialization-only or deserialization-only, this class\n+ * has a facility to lookup a delegate type adapter on demand.\n+ */\n+public final class TreeTypeAdapter<T> extends TypeAdapter<T> {\n+  private final JsonSerializer<T> serializer;\n+  private final JsonDeserializer<T> deserializer;\n+  private final Gson gson;\n+  private final TypeToken<T> typeToken;\n+  private final Factory skipPast;\n+\n+  /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n+  private TypeAdapter<T> delegate;\n+\n+  private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n+      Gson gson, TypeToken<T> typeToken, Factory skipPast) {\n+    this.serializer = serializer;\n+    this.deserializer = deserializer;\n+    this.gson = gson;\n+    this.typeToken = typeToken;\n+    this.skipPast = skipPast;\n+  }\n+\n+  @Override public T read(JsonReader reader) throws IOException {\n+    if (deserializer == null) {\n+      return delegate().read(reader);\n+    }\n+    JsonElement value = Streams.parse(reader);\n+    if (value.isJsonNull()) {\n+      return null;\n+    }\n+    return deserializer.deserialize(value, typeToken.getType(), gson.deserializationContext);\n+  }\n+\n+  @Override public void write(JsonWriter writer, T value) throws IOException {\n+    if (serializer == null) {\n+      delegate().write(writer, value);\n+      return;\n+    }\n+    if (value == null) {\n+      writer.nullValue();\n+      return;\n+    }\n+    JsonElement tree = serializer.serialize(value, typeToken.getType(), gson.serializationContext);\n+    Streams.write(tree,writer);\n+  }\n+\n+  private TypeAdapter<T> delegate() {\n+    TypeAdapter<T> d = delegate;\n+    return d != null\n+        ? d\n+        : (delegate = gson.getNextAdapter(skipPast, typeToken));\n+  }\n+\n+  public static class SingleTypeFactory implements TypeAdapter.Factory {\n+    private final TypeToken<?> typeToken;\n+    private final JsonSerializer<?> serializer;\n+    private final JsonDeserializer<?> deserializer;\n+\n+    public SingleTypeFactory(TypeToken<?> typeToken, Object typeAdapter) {\n+      this.typeToken = typeToken;\n+      serializer = typeAdapter instanceof JsonSerializer\n+          ? (JsonSerializer) typeAdapter\n+          : null;\n+      deserializer = typeAdapter instanceof JsonDeserializer\n+          ? (JsonDeserializer) typeAdapter\n+          : null;\n+      $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n+      return typeToken.equals(type)\n+          ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,\n+              (JsonDeserializer<T>) deserializer, context, type, this)\n+          : null;\n+    }\n+  }\n+\n+  public static class TypeHierarchyFactory implements TypeAdapter.Factory {\n+    private final TypeMap<JsonSerializer<?>> serializers;\n+    private final TypeMap<JsonDeserializer<?>> deserializers;\n+\n+    public TypeHierarchyFactory(TypeMap<JsonSerializer<?>> serializers,\n+        TypeMap<JsonDeserializer<?>> deserializers) {\n+      this.serializers = serializers;\n+      this.deserializers = deserializers;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // guaranteed by serializers lookup matching type\n+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      JsonSerializer<T> serializer = (JsonSerializer<T>) serializers.getHandlerFor(type);\n+      JsonDeserializer<T> deserializer = (JsonDeserializer<T>) deserializers.getHandlerFor(type);\n+      return (serializer != null || deserializer != null)\n+          ? new TreeTypeAdapter<T>(serializer, deserializer, context, typeToken, this)\n+          : null;\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n  * Returns a function that can construct an instance of a requested type.\n  */\n public final class ConstructorConstructor {\n-  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n+  private final TypeMap<InstanceCreator<?>> instanceCreators;\n \n-  public ConstructorConstructor(ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n+  public ConstructorConstructor(TypeMap<InstanceCreator<?>> instanceCreators) {\n     this.instanceCreators = instanceCreators;\n   }\n \n   public ConstructorConstructor() {\n-    this(new ParameterizedTypeHandlerMap<InstanceCreator<?>>());\n+    this(new TypeMap<InstanceCreator<?>>());\n   }\n \n   public <T> ObjectConstructor<T> getConstructor(TypeToken<T> typeToken) {\n \n     @SuppressWarnings(\"unchecked\") // types must agree\n     final InstanceCreator<T> creator\n-        = (InstanceCreator<T>) instanceCreators.getHandlerFor(type, false);\n+        = (InstanceCreator<T>) instanceCreators.getHandlerFor(type);\n     if (creator != null) {\n       return new ObjectConstructor<T>() {\n         public T construct() {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/TypeMap.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * A map that provides ability to associate handlers for a specific type or all\n+ * of its sub-types\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <T> The handler that will be looked up by type\n+ */\n+public final class TypeMap<T> {\n+  private static final Logger logger = Logger.getLogger(TypeMap.class.getName());\n+\n+  /** Map that is meant for storing default type adapters */\n+  private final Map<Type, T> typeMap = new HashMap<Type, T>();\n+\n+  /** List of default type hierarchy adapters */\n+  private final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  private boolean modifiable = true;\n+\n+  public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n+    Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n+    registerForTypeHierarchy(pair);\n+  }\n+\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first, typeHierarchyList);\n+    if (index != -1) {\n+      logger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\n+      typeHierarchyList.remove(index);\n+    }\n+    index = getIndexOfAnOverriddenHandler(pair.first, typeHierarchyList);\n+    if (index != -1) {\n+      throw new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n+          + \" hides the previously registered type hierarchy handler for \"\n+          + typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n+    }\n+    // We want stack behavior for adding to this list. A type adapter added subsequently should\n+    // override a previously registered one.\n+    typeHierarchyList.add(0, pair);\n+  }\n+\n+  private static <T> int getIndexOfAnOverriddenHandler(Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n+      if (type.isAssignableFrom(entry.first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public synchronized void register(Type typeOfT, T value) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    typeMap.put(typeOfT, value);\n+  }\n+\n+  public synchronized TypeMap<T> makeUnmodifiable() {\n+    modifiable = false;\n+    return this;\n+  }\n+\n+  public synchronized T getHandlerFor(Type type) {\n+    T handler = typeMap.get(type);\n+    if (handler != null) {\n+      return handler;\n+    }\n+    Class<?> rawClass = $Gson$Types.getRawType(type);\n+    if (rawClass != type) {\n+      handler = getHandlerFor(rawClass);\n+      if (handler != null) {\n+        return handler;\n+      }\n+    }\n+    // check if something registered for type hierarchy\n+    return getHandlerForTypeHierarchy(rawClass);\n+  }\n+\n+  private T getHandlerForTypeHierarchy(Class<?> type) {\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+      if (entry.first.isAssignableFrom(type)) {\n+        return entry.second;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  public synchronized boolean hasSpecificHandlerFor(Type type) {\n+    return typeMap.containsKey(type);\n+  }\n+\n+  private static <T> int getIndexOfSpecificHandlerForTypeHierarchy(\n+      Class<?> type, List<Pair<Class<?>, T>> typeHierarchyList) {\n+    for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n+      if (type.equals(typeHierarchyList.get(i).first)) {\n+        return i;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  public synchronized TypeMap<T> copyOf() {\n+    TypeMap<T> copy = new TypeMap<T>();\n+    // Instead of individually registering entries in the map, make an efficient copy\n+    // of the list and map\n+    copy.typeMap.putAll(typeMap);\n+    copy.typeHierarchyList.addAll(typeHierarchyList);\n+    return copy;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder(\"{typeHierarchyList:{\");\n+    appendList(sb, typeHierarchyList);\n+    sb.append(\"},typeMap:{\");\n+    appendMap(sb, typeMap);\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  private void appendList(StringBuilder sb, List<Pair<Class<?>,T>> list) {\n+    boolean first = true;\n+    for (Pair<Class<?>, T> entry : list) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append(typeToString(entry.first)).append(':');\n+      sb.append(entry.second);\n+    }\n+  }\n+\n+  private void appendMap(StringBuilder sb, Map<Type, T> map) {\n+    boolean first = true;\n+    for (Map.Entry<Type, T> entry : map.entrySet()) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append(typeToString(entry.getKey())).append(':');\n+      sb.append(entry.getValue());\n+    }\n+  }\n+\n+  private String typeToString(Type type) {\n+    return $Gson$Types.getRawType(type).getSimpleName();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/TypeMapTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.common.TestTypes.Base;\n+import com.google.gson.common.TestTypes.Sub;\n+import com.google.gson.reflect.TypeToken;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for the {@link TypeMap} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class TypeMapTest extends TestCase {\n+  private TypeMap<String> paramMap;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    paramMap = new TypeMap<String>();\n+  }\n+\n+  public void testNullMap() throws Exception {\n+    assertFalse(paramMap.hasSpecificHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class));\n+  }\n+\n+  public void testHasGenericButNotSpecific() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(List.class, handler);\n+\n+    assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n+    assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType));\n+    assertNotNull(paramMap.getHandlerFor(List.class));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+  }\n+\n+  public void testHasSpecificType() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(specificType, handler);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n+    assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n+    assertNotNull(paramMap.getHandlerFor(specificType));\n+    assertNull(paramMap.getHandlerFor(List.class));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+  }\n+\n+  public void testTypeOverridding() throws Exception {\n+    String handler1 = \"blah1\";\n+    String handler2 = \"blah2\";\n+    paramMap.register(String.class, handler1);\n+    paramMap.register(String.class, handler2);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n+    assertEquals(handler2, paramMap.getHandlerFor(String.class));\n+  }\n+\n+  public void testMakeUnmodifiable() throws Exception {\n+    paramMap.makeUnmodifiable();\n+    try {\n+     paramMap.register(String.class, \"blah\");\n+     fail(\"Can not register handlers when map is unmodifiable\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+\n+  public void testTypeHierarchy() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    String handler = paramMap.getHandlerFor(Sub.class);\n+    assertEquals(\"baseHandler\", handler);\n+  }\n+\n+  public void testTypeHierarchyMultipleHandlers() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    String handler = paramMap.getHandlerFor(SubOfSub.class);\n+    assertEquals(\"subHandler\", handler);\n+  }\n+\n+  public void testReplaceExistingTypeHierarchyHandler() {\n+    paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+    paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\");\n+    String handler = paramMap.getHandlerFor(Base.class);\n+    assertEquals(\"base2Handler\", handler);\n+  }\n+\n+  public void testHidingExistingTypeHierarchyHandlerIsDisallowed() {\n+    paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\");\n+    try {\n+      paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\");\n+      fail(\"A handler that hides an existing type hierarchy handler is not allowed\");\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+  private static class SubOfSub extends Sub {\n+  }\n+}", "timestamp": 1321818901, "metainfo": ""}