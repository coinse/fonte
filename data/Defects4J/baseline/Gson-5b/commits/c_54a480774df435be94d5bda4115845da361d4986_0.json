{"sha": "54a480774df435be94d5bda4115845da361d4986", "log": "Add the ability to configure Gson to exclude serializing and deserializing of all \"Inner Classes\".", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Strategy for excluding anonymous and local classes.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class AnonymousAndLocalClassExclusionStrategy implements ExclusionStrategy {\n+\n+  public boolean shouldSkipField(Field f) {\n+    return isAnonymousOrLocal(f.getType());\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return isAnonymousOrLocal(clazz);\n+  }\n+\n+  private boolean isAnonymousOrLocal(Class<?> clazz) {\n+    return clazz.isAnonymousClass() || clazz.isLocalClass();\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n   private static ExclusionStrategy createExclusionStrategy(double version) {\n     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(new InnerClassExclusionStrategy());\n+    strategies.add(new AnonymousAndLocalClassExclusionStrategy());\n     strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\n     if (version != VersionConstants.IGNORE_VERSIONS) {\n       strategies.add(new VersionExclusionStrategy(version));\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n   private double ignoreVersionsAfter;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n+  private boolean serializeInnerClasses;\n+  private final AnonymousAndLocalClassExclusionStrategy anonAndLocalClassExclusionStrategy;\n   private final InnerClassExclusionStrategy innerClassExclusionStrategy;\n   private boolean excludeFieldsWithoutExposeAnnotation;\n   private JsonFormatter formatter;\n   public GsonBuilder() {\n     // setup default values\n     ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS;\n+    serializeInnerClasses = true;\n+    anonAndLocalClassExclusionStrategy = new AnonymousAndLocalClassExclusionStrategy();\n     innerClassExclusionStrategy = new InnerClassExclusionStrategy();\n     modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY;\n     excludeFieldsWithoutExposeAnnotation = false;\n     this.serializeNulls = true;\n     return this;\n   }\n+  \n+  /**\n+   * Configures Gson to include or exclude inner classes\n+   *\n+   * @param modifiers the field modifiers. You must use the modifiers specified in the\n+   * {@link java.lang.reflect.Modifier} class. For example,\n+   * {@link java.lang.reflect.Modifier#TRANSIENT},\n+   * {@link java.lang.reflect.Modifier#STATIC}.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder serializeInnerClasses(boolean value) {\n+    serializeInnerClasses = value;\n+    return this;\n+  }\n+  \n   /**\n    * Configures Gson to apply a specific naming policy to an object's field during serialization\n    * and deserialization.\n    */\n   public Gson create() {\n     List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(innerClassExclusionStrategy);\n     strategies.add(modifierBasedExclusionStrategy);\n+    strategies.add(anonAndLocalClassExclusionStrategy);\n+\n+    if (!serializeInnerClasses) {\n+      strategies.add(innerClassExclusionStrategy);\n+    }\n     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n       strategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n     }\n--- a/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n package com.google.gson;\n \n import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n \n /**\n  * Strategy for excluding inner classes.\n  *\n  * @author Joel Leitch\n  */\n-final class InnerClassExclusionStrategy implements ExclusionStrategy {\n+public class InnerClassExclusionStrategy implements ExclusionStrategy {\n \n   public boolean shouldSkipField(Field f) {\n-    return isAnonymousOrLocal(f.getType());\n+    return isInnerClass(f.getType());\n   }\n \n   public boolean shouldSkipClass(Class<?> clazz) {\n-    return isAnonymousOrLocal(clazz);\n+    return isInnerClass(clazz);\n   }\n \n-  private boolean isAnonymousOrLocal(Class<?> clazz) {\n-    return clazz.isAnonymousClass() || clazz.isLocalClass();\n+  private boolean isInnerClass(Class<?> clazz) {\n+    return clazz.isMemberClass() && !isStatic(clazz);\n+  }\n+  \n+  private boolean isStatic(Class<?> clazz) {\n+    return (clazz.getModifiers() & Modifier.STATIC) != 0;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n   public JsonElement serialize(Object src, Type typeOfSrc) {\n     ObjectNavigator on = factory.create(src, typeOfSrc);\n     JsonSerializationVisitor visitor =\n-      new JsonSerializationVisitor(factory, serializeNulls, serializers, this);\n+        new JsonSerializationVisitor(factory, serializeNulls, serializers, this);\n     on.accept(visitor);\n     return visitor.getJsonElement();\n   }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link InnerClassExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class InnerClassExclusionStrategyTest extends TestCase {\n+  public InnerClass innerClass;\n+  public StaticNestedClass staticNestedClass;\n+\n+  private InnerClassExclusionStrategy strategy;\n+  \n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    innerClass = new InnerClass();\n+    staticNestedClass = new StaticNestedClass();\n+    strategy = new InnerClassExclusionStrategy();\n+  }\n+\n+  public void testExcludeInnerClassObject() throws Exception {\n+    Class<?> clazz = innerClass.getClass();\n+    assertTrue(strategy.shouldSkipClass(clazz));\n+  }\n+  \n+  public void testExcludeInnerClassField() throws Exception {\n+    Field f = getClass().getField(\"innerClass\");\n+    assertTrue(strategy.shouldSkipField(f));\n+  }\n+  \n+  public void testIncludeStaticNestedClassObject() throws Exception {\n+    Class<?> clazz = staticNestedClass.getClass();\n+    assertFalse(strategy.shouldSkipClass(clazz));\n+  }\n+  \n+  public void testIncludeStaticNestedClassField() throws Exception {\n+    Field f = getClass().getField(\"staticNestedClass\");\n+    assertFalse(strategy.shouldSkipField(f));\n+  }\n+  \n+  class InnerClass {\n+  }\n+  \n+  static class StaticNestedClass {\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Performs some functional testing to ensure GSON infrastructure properly serializes/deserializes\n+ * fields that either should or should not be included in the output based on the GSON\n+ * configuration.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class FieldExclusionTest extends TestCase {\n+  private static final String VALUE = \"blah_1234\";\n+  \n+  public void testDefaultInnerClassExclusion() throws Exception {\n+    Gson gson = new Gson();\n+    TestInnerClass target = new TestInnerClass(VALUE);\n+    String result = gson.toJson(target);\n+    assertEquals(target.toJson(), result);\n+    \n+    gson = new GsonBuilder().create();\n+    target = new TestInnerClass(VALUE);\n+    result = gson.toJson(target);\n+    assertEquals(target.toJson(), result);\n+  }\n+  \n+  public void testInnerClassExclusion() throws Exception {\n+    Gson gson = new GsonBuilder().serializeInnerClasses(false).create();\n+    TestInnerClass target = new TestInnerClass(VALUE);\n+    String result = gson.toJson(target);\n+    assertEquals(\"\", result);\n+  }\n+  \n+  public void testDefaultNestedStaticClassIncluded() throws Exception {\n+    Gson gson = new Gson();\n+    TestInnerClass target = new TestInnerClass(VALUE);\n+    String result = gson.toJson(target);\n+    assertEquals(target.toJson(), result);\n+    \n+    gson = new GsonBuilder().create();\n+    target = new TestInnerClass(VALUE);\n+    result = gson.toJson(target);\n+    assertEquals(target.toJson(), result);\n+  }\n+  \n+  private class TestInnerClass extends TestStaticNestedClass {\n+    public TestInnerClass(String value) {\n+      super(value);\n+    }\n+  }\n+  \n+  private static class TestStaticNestedClass {\n+    private final String value;\n+    public TestStaticNestedClass(String value) {\n+      this.value = value;\n+    }\n+    \n+    public String toJson() {\n+      return \"{\\\"value\\\":\\\"\" + value + \"\\\"}\";\n+    }\n+  }\n+}", "timestamp": 1230429631, "metainfo": ""}