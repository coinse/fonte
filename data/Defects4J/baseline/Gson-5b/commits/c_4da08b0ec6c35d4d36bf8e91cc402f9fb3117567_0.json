{"sha": "4da08b0ec6c35d4d36bf8e91cc402f9fb3117567", "log": "Remove two implementation classes that weren't generally useful:  - The cache interface has only one implementation. Drop the interface; we can add it back later if necessary.  - The DefaultTypeAdapters class contains one member class. Just make that a top-level class.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * This type adapter supports three subclasses of date: Date, Timestamp, and\n+ * java.sql.Date.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n+\n+  // TODO: migrate to streaming adapter\n+\n+  private final DateFormat enUsFormat;\n+  private final DateFormat localFormat;\n+  private final DateFormat iso8601Format;\n+\n+  DefaultDateTypeAdapter() {\n+    this(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n+        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n+  }\n+\n+  DefaultDateTypeAdapter(String datePattern) {\n+    this(new SimpleDateFormat(datePattern, Locale.US), new SimpleDateFormat(datePattern));\n+  }\n+\n+  DefaultDateTypeAdapter(int style) {\n+    this(DateFormat.getDateInstance(style, Locale.US), DateFormat.getDateInstance(style));\n+  }\n+\n+  public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n+    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n+        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n+  }\n+\n+  DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\n+    this.enUsFormat = enUsFormat;\n+    this.localFormat = localFormat;\n+    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n+    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+  }\n+\n+  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n+  // See issue 162\n+  public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n+    synchronized (localFormat) {\n+      String dateFormatAsString = enUsFormat.format(src);\n+      return new JsonPrimitive(dateFormatAsString);\n+    }\n+  }\n+\n+  public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+      throws JsonParseException {\n+    if (!(json instanceof JsonPrimitive)) {\n+      throw new JsonParseException(\"The date should be a string value\");\n+    }\n+    Date date = deserializeToDate(json);\n+    if (typeOfT == Date.class) {\n+      return date;\n+    } else if (typeOfT == Timestamp.class) {\n+      return new Timestamp(date.getTime());\n+    } else if (typeOfT == java.sql.Date.class) {\n+      return new java.sql.Date(date.getTime());\n+    } else {\n+      throw new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n+    }\n+  }\n+\n+  private Date deserializeToDate(JsonElement json) {\n+    synchronized (localFormat) {\n+      try {\n+        return localFormat.parse(json.getAsString());\n+      } catch (ParseException ignored) {\n+      }\n+      try {\n+        return enUsFormat.parse(json.getAsString());\n+      } catch (ParseException ignored) {\n+      }\n+      try {\n+        return iso8601Format.parse(json.getAsString());\n+      } catch (ParseException e) {\n+        throw new JsonSyntaxException(json.getAsString(), e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(DefaultDateTypeAdapter.class.getSimpleName());\n+    sb.append('(').append(localFormat.getClass().getSimpleName()).append(')');\n+    return sb.toString();\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Pair;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n   private static final String MAX_CACHE_PROPERTY_NAME =\n       \"com.google.gson.annotation_cache_size_hint\";\n \n-  private static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n-      new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n+  private static final LruCache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE\n+      = new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n \n   private final Class<?> declaringClazz;\n   private final Field field;\n   public Collection<Annotation> getAnnotations() {\n     if (annotations == null) {\n       Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name);\n-      Collection<Annotation> cachedValue = ANNOTATION_CACHE.getElement(key);\n+      Collection<Annotation> cachedValue = ANNOTATION_CACHE.get(key);\n       if (cachedValue == null) {\n         cachedValue = Collections.unmodifiableCollection(\n             Arrays.asList(field.getAnnotations()));\n-        ANNOTATION_CACHE.addElement(key, cachedValue);\n+        ANNOTATION_CACHE.put(key, cachedValue);\n       }\n       annotations = cachedValue;\n     }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n import com.google.gson.annotations.Expose;\n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Primitives;\n--- a/gson/src/main/java/com/google/gson/LruCache.java\n+++ b/gson/src/main/java/com/google/gson/LruCache.java\n import java.util.Map;\n \n /**\n- * An implementation of the {@link Cache} interface that evict objects from the cache using an\n- * LRU (least recently used) algorithm.  Object start getting evicted from the cache once the\n- * {@code maxCapacity} is reached.\n+ * A cache that evict objects from the cache using an LRU (least recently used)\n+ * policy.  Object start getting evicted from the cache once the {@code maxCapacity}\n+ * is reached.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n-final class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {\n-  private static final long serialVersionUID = 1L;\n-\n+final class LruCache<K, V> extends LinkedHashMap<K, V> {\n   private final int maxCapacity;\n \n   public LruCache(int maxCapacity) {\n     this.maxCapacity = maxCapacity;\n   }\n \n-  public synchronized void addElement(K key, V value) {\n-    put(key, value);\n-  }\n-\n-  public synchronized V getElement(K key) {\n-    return get(key);\n-  }\n-\n-  @Override\n-  protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n+  @Override protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n     return size() > maxCapacity;\n   }\n }\n--- a/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n \n package com.google.gson;\n \n-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.Date;\n--- a/gson/src/test/java/com/google/gson/JsonDeserializerExceptionWrapperTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonDeserializerExceptionWrapperTest.java\n  */\n \n package com.google.gson;\n-\n-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n \n import junit.framework.TestCase;\n ", "timestamp": 1321856622, "metainfo": ""}