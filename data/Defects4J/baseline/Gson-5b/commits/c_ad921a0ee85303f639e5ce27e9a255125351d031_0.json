{"sha": "ad921a0ee85303f639e5ce27e9a255125351d031", "log": "removed unused variable. eliminated unnecessary ObjTypePair creation.", "commit": "\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n     return new ObjectTypePair(obj, actualType, preserveType);\n   }\n \n+  Type getMoreSpecificType() {    \n+    if (preserveType || obj == null) {\n+      return type;\n+    }\n+    return getActualTypeIfMoreSpecific(type, obj.getClass());\n+  }\n+\n   // This takes care of situations where the field was declared as an Object, but the\n   // actual value contains something more specific. See Issue 54.\n   // TODO (inder): This solution will not work if the field is of a generic type, but \n--- a/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n    * @param visitor the visitor to visit each field with\n    */\n   void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {\n-    ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n-    Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n-    for (Class<?> curr : getInheritanceHierarchy(currObjTypePair.type)) {\n+    for (Class<?> curr : getInheritanceHierarchy(objTypePair.getMoreSpecificType())) {\n       navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);\n     }\n   }", "timestamp": 1301006223, "metainfo": ""}