{"sha": "15fa10943c6e9db6d5db147efdec9640e86838a9", "log": "Fixed serializers and deserializers for java.sql Date and Time to ensure that Date does't serialize time, and time does't serialize the date portion.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.net.URL;\n+import java.sql.Time;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.ParseException;\n final class DefaultTypeAdapters {\n \n   private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER = new DefaultDateTypeAdapter();\n-  private static final DefaultJavaSqlDateDeserializer JAVA_SQL_DATE_DESERIALIZER =\n-    new DefaultJavaSqlDateDeserializer();\n+  private static final DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER =\n+    new DefaultJavaSqlDateTypeAdapter();\n+  private static final DefaultTimeTypeAdapter TIME_TYPE_ADAPTER =\n+    new DefaultTimeTypeAdapter();\n   private static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =\n     new DefaultTimestampDeserializer();\n \n     map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n     map.register(Map.class, MAP_TYPE_ADAPTER);\n     map.register(Date.class, DATE_TYPE_ADAPTER);\n+    map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\n     map.register(Timestamp.class, DATE_TYPE_ADAPTER);\n-    map.register(java.sql.Date.class, DATE_TYPE_ADAPTER);\n+    map.register(Time.class, TIME_TYPE_ADAPTER);\n     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n     map.register(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\n     map.register(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n-    map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_DESERIALIZER));\n+    map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\n     map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\n+    map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER));\n     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\n     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\n     }\n   }\n \n-  static class DefaultJavaSqlDateDeserializer implements JsonDeserializer<java.sql.Date> {\n+  static class DefaultJavaSqlDateTypeAdapter implements JsonSerializer<java.sql.Date>,\n+      JsonDeserializer<java.sql.Date> {\n+    private final DateFormat format;\n+    DefaultJavaSqlDateTypeAdapter() {\n+      this.format = new SimpleDateFormat(\"MMM d, yyyy\");\n+    }\n+\n+    public JsonElement serialize(java.sql.Date src, Type typeOfSrc,\n+        JsonSerializationContext context) {\n+      synchronized (format) {\n+        String dateFormatAsString = format.format(src);\n+        return new JsonPrimitive(dateFormatAsString);\n+      }\n+    }    \n     public java.sql.Date deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n-      Date date = context.deserialize(json, Date.class);\n-      return new java.sql.Date(date.getTime());\n-    }    \n+      if (!(json instanceof JsonPrimitive)) {\n+        throw new JsonParseException(\"The date should be a string value\");\n+      }\n+      try {\n+        synchronized (format) {\n+          Date date = format.parse(json.getAsString());\n+          return new java.sql.Date(date.getTime());\n+        }\n+      } catch (ParseException e) {\n+        throw new JsonParseException(e);\n+      }\n+    }\n   }\n \n   static class DefaultTimestampDeserializer implements JsonDeserializer<Timestamp> {\n         JsonDeserializationContext context) throws JsonParseException {\n       Date date = context.deserialize(json, Date.class);\n       return new Timestamp(date.getTime());\n-    }    \n+    }\n+  }\n+\n+  static class DefaultTimeTypeAdapter implements JsonSerializer<Time>, JsonDeserializer<Time> {\n+    private final DateFormat format;\n+    DefaultTimeTypeAdapter() {\n+      this.format = new SimpleDateFormat(\"hh:mm:ss a\");\n+    }\n+    public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context) {\n+      synchronized (format) {\n+        String dateFormatAsString = format.format(src);\n+        return new JsonPrimitive(dateFormatAsString);\n+      }\n+    }\n+    public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      if (!(json instanceof JsonPrimitive)) {\n+        throw new JsonParseException(\"The date should be a string value\");\n+      }\n+      try {\n+        synchronized (format) {\n+          Date date = format.parse(json.getAsString());\n+          return new Time(date.getTime());\n+        }\n+      } catch (ParseException e) {\n+        throw new JsonParseException(e);\n+      }\n+    }\n   }\n \n   private static class GregorianCalendarTypeAdapter \n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n import java.math.BigInteger;\n import java.net.URI;\n import java.net.URL;\n+import java.sql.Time;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n   public void testDefaultDateDeserialization() {\n     String json = \"'Dec 13, 2009 07:18:02 AM'\";\n     Date extracted = gson.fromJson(json, Date.class);\n-    assertEquals(extracted, 2009, 11, 13, 7, 18, 02);\n+    assertEqualsDate(extracted, 2009, 11, 13);\n+    assertEqualsTime(extracted, 7, 18, 02);\n   }\n \n   // Date can not directly be compared with another instance since the deserialization loses the\n   // millisecond portion.\n   @SuppressWarnings(\"deprecation\")\n-  private void assertEquals(Date date, int year, int month, int day, int hours, int minutes,\n-      int seconds) {\n-    assertEquals(year-1900, date.getYear());    \n-    assertEquals(month, date.getMonth());    \n-    assertEquals(day, date.getDate());\n-    if (!(date instanceof java.sql.Date)) { \n-      assertEquals(hours, date.getHours());    \n-      assertEquals(minutes, date.getMinutes());        \n-      assertEquals(seconds, date.getSeconds());\n-    }\n+  private void assertEqualsDate(Date date, int year, int month, int day) {\n+      assertEquals(year-1900, date.getYear());    \n+      assertEquals(month, date.getMonth());    \n+      assertEquals(day, date.getDate());\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n+  private void assertEqualsTime(Date date, int hours, int minutes, int seconds) {\n+    assertEquals(hours, date.getHours());    \n+    assertEquals(minutes, date.getMinutes());        \n+    assertEquals(seconds, date.getSeconds());\n   }\n \n   public void testDefaultJavaSqlDateSerialization() {\n-    long currentTimeMillis = System.currentTimeMillis();\n-    java.sql.Date now = new java.sql.Date(currentTimeMillis);\n-    String json = gson.toJson(now);\n-    assertEquals(\"\\\"\" + DateFormat.getDateTimeInstance().format(now) + \"\\\"\", json);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n+    java.sql.Date instant = new java.sql.Date(1259875082000L);\n+    String json = gson.toJson(instant);\n+    assertEquals(\"\\\"Dec 3, 2009\\\"\", json);\n+  }\n+\n   public void testDefaultJavaSqlDateDeserialization() {\n-    String json = \"'Dec 3, 2009 1:18:02 PM'\";\n+    String json = \"'Dec 3, 2009'\";\n     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class);\n-    assertEquals(extracted, 2009, 11, 3, 13, 18, 02);\n+    assertEqualsDate(extracted, 2009, 11, 3);\n   }\n   \n   public void testDefaultJavaSqlTimestampSerialization() {\n-    long currentTimeMillis = System.currentTimeMillis();\n-    Timestamp now = new java.sql.Timestamp(currentTimeMillis);\n-    String json = gson.toJson(now);\n-    assertEquals(\"\\\"\" + DateFormat.getDateTimeInstance().format(now) + \"\\\"\", json);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n+    Timestamp now = new java.sql.Timestamp(1259875082000L);\n+    String json = gson.toJson(now);\n+    assertEquals(\"\\\"Dec 3, 2009 1:18:02 PM\\\"\", json);\n+  }\n+\n   public void testDefaultJavaSqlTimestampDeserialization() {\n     String json = \"'Dec 3, 2009 1:18:02 PM'\";\n     Timestamp extracted = gson.fromJson(json, Timestamp.class);\n-    assertEquals(extracted, 2009, 11, 3, 13, 18, 02);\n+    assertEqualsDate(extracted, 2009, 11, 3);\n+    assertEqualsTime(extracted, 13, 18, 02);\n+  }\n+  \n+  public void testDefaultJavaSqlTimeSerialization() {\n+    Time now = new Time(1259875082000L);\n+    String json = gson.toJson(now);\n+    assertEquals(\"\\\"01:18:02 PM\\\"\", json);\n+  }\n+\n+  public void testDefaultJavaSqlTimeDeserialization() {\n+    String json = \"'1:18:02 PM'\";\n+    Time extracted = gson.fromJson(json, Time.class);\n+    assertEqualsTime(extracted, 13, 18, 02);\n   }\n   \n   public void testDefaultDateSerializationUsingBuilder() throws Exception {", "timestamp": 1259950500, "metainfo": ""}