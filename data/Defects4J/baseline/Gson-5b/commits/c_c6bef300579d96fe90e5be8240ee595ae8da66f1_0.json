{"sha": "c6bef300579d96fe90e5be8240ee595ae8da66f1", "log": "Array support.", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/ArrayTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Adapt an array of objects.\n+ */\n+final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n+        return null;\n+      }\n+\n+      Type componentType = $Gson$Types.getArrayComponentType(type);\n+      TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));\n+      @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n+      TypeAdapter<T> result = new ArrayTypeAdapter(\n+          componentTypeAdapter, $Gson$Types.getRawType(componentType));\n+      return result;\n+    }\n+  };\n+\n+  private final Class<E> componentType;\n+  private final TypeAdapter<E> componentTypeAdapter;\n+\n+  public ArrayTypeAdapter(TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+    this.componentTypeAdapter = componentTypeAdapter;\n+    this.componentType = componentType;\n+  }\n+\n+  public Object read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    List<E> list = new ArrayList<E>();\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      E instance = componentTypeAdapter.read(reader);\n+      list.add(instance);\n+    }\n+    reader.endArray();\n+    Object array = Array.newInstance(componentType, list.size());\n+    for (int i = 0; i < list.size(); i++) {\n+      Array.set(array, i, list.get(i));\n+    }\n+    return array;\n+  }\n+\n+  @Override public void write(JsonWriter writer, Object array) throws IOException {\n+    if (array == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginArray();\n+    for (int i = 0, length = Array.getLength(array); i < length; i++) {\n+      final E value = (E) Array.get(array, i);\n+      componentTypeAdapter.write(writer, value);\n+    }\n+    writer.endArray();\n+  }\n+}\n--- a/extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java\n         return null;\n       }\n \n-      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the element type\n+      @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n       TypeAdapter<T> result = new CollectionTypeAdapter(elementTypeAdapter, constructor);\n       return result;\n     }\n--- a/extras/src/main/java/com/google/gson/mini/MiniGson.java\n+++ b/extras/src/main/java/com/google/gson/mini/MiniGson.java\n     factories.add(TypeAdapters.STRING_FACTORY);\n     factories.add(ReflectiveTypeAdapter.FACTORY);\n     factories.add(CollectionTypeAdapter.FACTORY);\n-    factories.add(MapTypeAdapter.FACTORY);\n+    factories.add(StringToValueMapTypeAdapter.FACTORY);\n+    factories.add(ArrayTypeAdapter.FACTORY);\n     this.factories = Collections.unmodifiableList(factories);\n   }\n \n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/StringToValueMapTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a map whose keys are strings.\n+ */\n+final class StringToValueMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof ParameterizedType)) {\n+        return null;\n+      }\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Map.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);\n+      if (keyAndValueTypes[0] != String.class) {\n+        return null;\n+      }\n+      TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+\n+      Constructor<?> constructor;\n+      try {\n+        Class<?> constructorType = (rawType == Map.class) ? LinkedHashMap.class : rawType;\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+      TypeAdapter<T> result = new StringToValueMapTypeAdapter(valueAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<V> valueTypeAdapter;\n+  private final Constructor<? extends Map<String, V>> constructor;\n+\n+  public StringToValueMapTypeAdapter(TypeAdapter<V> valueTypeAdapter,\n+      Constructor<? extends Map<String, V>> constructor) {\n+    this.valueTypeAdapter = valueTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Map<String, V> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    Map<String, V> map = MiniGson.newInstance(constructor);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String key = reader.nextName();\n+      V value = valueTypeAdapter.read(reader);\n+      map.put(key, value);\n+    }\n+    reader.endObject();\n+    return map;\n+  }\n+\n+  public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+    if (map == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginObject();\n+    for (Map.Entry<String, V> entry : map.entrySet()) {\n+      writer.name(entry.getKey());\n+      valueTypeAdapter.write(writer, entry.getValue());\n+    }\n+    writer.endObject();\n+  }\n+}\n--- a/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n+++ b/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n     assertEquals(map, mapAdapter.fromJson(\"{'a':5.0,'b':10.0}\"));\n   }\n \n+  public void testSerialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    assertEquals(\"[1.0,2.0,3.0]\", arrayAdapter.toJson(new double[]{1.0, 2.0, 3.0}));\n+  }\n+\n+  public void testDeserialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    double[] array = arrayAdapter.fromJson(\"[1.0,2.0,3.0]\");\n+    assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));\n+  }\n+\n+  public void testSerialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = { {1.0, 2.0 }, { 3.0 } };\n+    assertEquals(\"[[1.0,2.0],[3.0]]\", arrayAdapter.toJson(array));\n+  }\n+\n+  public void testDeserialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = arrayAdapter.fromJson(\"[[1.0,2.0],[3.0]]\");\n+    double[][] expected = { {1.0, 2.0 }, { 3.0 } };\n+    assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));\n+  }\n+\n   static class Truck {\n     double horsePower;\n     List<Person> passengers = Collections.emptyList();", "timestamp": 1310423213, "metainfo": ""}