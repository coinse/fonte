{"sha": "de727d8c4811209b2fdc6dbfa367f8bb7f78ba4e", "log": "Delete dead code found by coverage", "commit": "\n--- a/gson/src/main/java/com/google/gson/Cache.java\n+++ b/gson/src/main/java/com/google/gson/Cache.java\n    * @return the cached value for the given {@code key}\n    */\n   V getElement(K key);\n-\n-  /**\n-   * Removes the value from the cache for the given key.\n-   *\n-   * @param key the key identifying the value to remove\n-   * @return the value for the given {@code key}\n-   */\n-  V removeElement(K key);\n }\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n-import com.google.gson.internal.$Gson$Types;\n-\n import com.google.gson.internal.Pair;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n   private final boolean isSynthetic;\n   private final int modifiers;\n   private final String name;\n-  private final Type resolvedType;\n \n   // Fields used for lazy initialization\n   private Type genericType;\n    * Constructs a Field Attributes object from the {@code f}.\n    *\n    * @param f the field to pull attributes from\n-   * @param declaringType The type in which the field is declared\n-   */\n-  FieldAttributes(Class<?> declaringClazz, Field f, Type declaringType) {\n+   */\n+  FieldAttributes(Class<?> declaringClazz, Field f) {\n     this.declaringClazz = $Gson$Preconditions.checkNotNull(declaringClazz);\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n     this.modifiers = f.getModifiers();\n     this.field = f;\n-    this.resolvedType = getTypeInfoForField(f, declaringType);\n   }\n \n   private static int getMaxCacheSize() {\n   }\n \n   /**\n-   * Returns the {@code Class<?>} object that was declared for this field.\n+   * Returns the {@code Class} object that was declared for this field.\n    *\n    * <p>For example, assume the following class definition:\n    * <pre class=\"code\">\n   /**\n    * This is exposed internally only for the removing synthetic fields from the JSON output.\n    *\n-   * @throws IllegalAccessException\n-   * @throws IllegalArgumentException\n-   */\n-  void set(Object instance, Object value) throws IllegalAccessException {\n-    field.set(instance, value);\n-  }\n-\n-  /**\n-   * This is exposed internally only for the removing synthetic fields from the JSON output.\n-   *\n    * @return true if the field is synthetic; otherwise false\n    * @throws IllegalAccessException\n    * @throws IllegalArgumentException\n   @Deprecated\n   Field getFieldObject() {\n     return field;\n-  }\n-\n-  Type getResolvedType() {\n-    return resolvedType;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n     }\n     return null;\n   }\n-\n-  /**\n-   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n-   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n-   *\n-   * @param f the actual field object to retrieve the type from\n-   * @param typeDefiningF the type that contains the field {@code f}\n-   * @return the type information for the field\n-   */\n-  static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n-    Class<?> rawType = $Gson$Types.getRawType(typeDefiningF);\n-    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n-      // this field is unrelated to the type; the user probably omitted type information\n-      return f.getGenericType();\n-    }\n-    return $Gson$Types.resolve(typeDefiningF, rawType, f.getGenericType());\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   static final SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY =\n       new SyntheticFieldExclusionStrategy(true);\n   static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n-      new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n+      new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC);\n   static final FieldNamingStrategy2 DEFAULT_NAMING_POLICY =\n       new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n \n         = new ReflectiveTypeAdapterFactory(constructorConstructor) {\n       @Override\n       public String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n-        return fieldNamingPolicy.translateName(new FieldAttributes(declaringClazz, f, declaredType));\n+        return fieldNamingPolicy.translateName(new FieldAttributes(declaringClazz, f));\n       }\n       @Override\n       public boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n         ExclusionStrategy strategy = Gson.this.serializationExclusionStrategy;\n         return !strategy.shouldSkipClass(f.getType())\n-            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f, declaredType));\n+            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f));\n       }\n \n       @Override\n       public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n         ExclusionStrategy strategy = Gson.this.deserializationExclusionStrategy;\n         return !strategy.shouldSkipClass(f.getType())\n-            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f, declaredType));\n+            && !strategy.shouldSkipField(new FieldAttributes(declaringClazz, f));\n       }\n     };\n \n       builder.factory(factory);\n     }\n \n-    builder.factory(new GsonToMiniGsonTypeAdapterFactory(this, serializers, deserializers, serializeNulls))\n+    builder.factory(new GsonToMiniGsonTypeAdapterFactory(this, serializers, deserializers))\n         .factory(TypeAdapters.URL_FACTORY)\n         .factory(TypeAdapters.URI_FACTORY)\n         .factory(TypeAdapters.UUID_FACTORY)\n    */\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     JsonReader jsonReader = new JsonReader(json);\n-    T object = this.<T>fromJson(jsonReader, typeOfT);\n+    T object = fromJson(jsonReader, typeOfT);\n     assertFullConsumption(object, jsonReader);\n     return object;\n   }\n--- a/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java\n   private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n   private final JsonDeserializationContext deserializationContext;\n   private final JsonSerializationContext serializationContext;\n-  private final boolean serializeNulls;\n \n   public GsonToMiniGsonTypeAdapterFactory(final Gson gson,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n-      boolean serializeNulls) {\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n     this.serializers = serializers;\n     this.deserializers = deserializers;\n-    this.serializeNulls = serializeNulls;\n \n     this.deserializationContext = new JsonDeserializationContext() {\n       public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n--- a/gson/src/main/java/com/google/gson/JsonArray.java\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n \n   }\n \n   /**\n-   * Reverses the elements of the array.\n-   */\n-  void reverse() {\n-    Collections.reverse(elements);\n-  }\n-\n-  /**\n    * Returns the number of elements in the array.\n    *\n    * @return the number of elements in the array.\n     throw new IllegalStateException();\n   }\n \n-  /**\n-   * convenience method to get this array as an Object if it contains a single element.\n-   *\n-   * @return get this element as an Object if it is single element array.\n-   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n-   * is not a valid Object.\n-   * @throws IllegalStateException if the array has more than one element.\n-   */\n-  @Override\n-  Object getAsObject() {\n-    if (elements.size() == 1) {\n-      return elements.get(0).getAsObject();\n-    }\n-    throw new IllegalStateException();\n-  }\n-\n   @Override\n   public boolean equals(Object o) {\n     return (o == this) || (o instanceof JsonArray && ((JsonArray) o).elements.equals(elements));\n--- a/gson/src/main/java/com/google/gson/JsonElement.java\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n   }\n \n   /**\n-   * convenience method to get this element as an {@link Object} value.\n-   *\n-   * @return get this element as an Object value.\n-   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n-   * Object value.\n-   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n-   * more than a single element.\n-   */\n-  Object getAsObject() {\n-    throw new UnsupportedOperationException(getClass().getSimpleName());\n-  }\n-\n-  /**\n    * Returns a deep copy of this. Immutable values can return this.\n    */\n   abstract JsonElement deepCopy();\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n     return getAsString().charAt(0);\n   }\n \n-  /**\n-   * convenience method to get this element as an Object.\n-   *\n-   * @return get this element as an Object that can be converted to a suitable value.\n-   */\n-  @Override\n-  Object getAsObject() {\n-    if (value instanceof BigInteger) {\n-      BigInteger big = (BigInteger) value;\n-      if (big.compareTo(INTEGER_MAX) < 0) {\n-        return big.intValue();\n-      } else if (big.compareTo(LONG_MAX) < 0) {\n-        return big.longValue();\n-      }\n-    }\n-    // No need to convert to float or double since those lose precision\n-    return value;\n-  }\n-\n   private static boolean isPrimitiveOrString(Object target) {\n     if (target instanceof String) {\n       return true;\n--- a/gson/src/main/java/com/google/gson/LruCache.java\n+++ b/gson/src/main/java/com/google/gson/LruCache.java\n     return get(key);\n   }\n \n-  public synchronized V removeElement(K key) {\n-    return remove(key);\n-  }\n-\n   @Override\n   protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n     return size() > maxCapacity;\n--- a/gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java\n     }\n   }\n \n-  public synchronized void register(ParameterizedTypeHandlerMap<T> other) {\n-    if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n-    }\n-    for (Map.Entry<Type, T> entry : other.userMap.entrySet()) {\n-      register(entry.getKey(), entry.getValue(), false);\n-    }\n-    for (Map.Entry<Type, T> entry : other.systemMap.entrySet()) {\n-      register(entry.getKey(), entry.getValue(), true);\n-    }\n-    // Quite important to traverse the typeHierarchyList from stack bottom first since\n-    // we want to register the handlers in the same order to preserve priority order\n-    for (int i = other.userTypeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.userTypeHierarchyList.get(i);\n-      registerForTypeHierarchy(entry, false);\n-    }\n-    for (int i = other.systemTypeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.systemTypeHierarchyList.get(i);\n-      registerForTypeHierarchy(entry, true);\n-    }\n-  }\n-\n-  public synchronized void registerIfAbsent(Type typeOfT, T value) {\n-    if (!modifiable) {\n-      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n-    }\n-    if (!userMap.containsKey(typeOfT)) {\n-      register(typeOfT, value, false);\n-    }\n-  }\n-\n   public synchronized ParameterizedTypeHandlerMap<T> makeUnmodifiable() {\n     modifiable = false;\n     return this;\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n     } else if (element.isJsonArray()) {\n       writer.beginArray();\n       for (JsonElement e : element.getAsJsonArray()) {\n-        /* always print null when its parent element is an array! */\n-        if (e.isJsonNull()) {\n-          writer.nullValue();\n-          continue;\n-        }\n         write(e, writer);\n       }\n       writer.endArray();\n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n   \n   private static final Class<?> CLAZZ = String.class;\n   private static final FieldAttributes FIELD =\n-    new FieldAttributes(CLAZZ, CLAZZ.getFields()[0], CLAZZ);\n+    new FieldAttributes(CLAZZ, CLAZZ.getFields()[0]);\n \n   public void testBadInstantiation() throws Exception {\n     try {\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n   \n   private static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n     Field f = MockObject.class.getField(fieldName);\n-    return new FieldAttributes(MockObject.class, f, MockObject.class);\n+    return new FieldAttributes(MockObject.class, f);\n   }\n   \n   @SuppressWarnings(\"unused\")\n--- a/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n+++ b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    fieldAttributes = new FieldAttributes(Foo.class, Foo.class.getField(\"bar\"), Foo.class);\n+    fieldAttributes = new FieldAttributes(Foo.class, Foo.class.getField(\"bar\"));\n   }\n \n   public void testNullField() throws Exception {\n     try {\n-      new FieldAttributes(Foo.class, null, Foo.class);\n+      new FieldAttributes(Foo.class, null);\n       fail(\"Field parameter can not be null\");\n     } catch (NullPointerException expected) { }\n   }\n--- a/gson/src/test/java/com/google/gson/FieldNamingStrategy2AdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/FieldNamingStrategy2AdapterTest.java\n     FieldNamingStrategy2 adapter =\n         new FieldNamingStrategy2Adapter(new UpperCaseNamingStrategy());\n     assertEquals(expectedFieldName, adapter.translateName(\n-        new FieldAttributes(String.class, field, String.class)));\n+        new FieldAttributes(String.class, field)));\n   }\n   \n   private static class UpperCaseNamingStrategy implements FieldNamingStrategy {\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f, getClass())));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n   }\n \n   public void testIncludeStaticNestedClassObject() throws Exception {\n \n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f, getClass())));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n   }\n \n   class InnerClass {\n--- a/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n   }\n \n   public void testFieldNamingPolicy() throws Exception {\n-    FieldAttributes f = new FieldAttributes(String.class, String.class.getFields()[0], String.class);\n+    FieldAttributes f = new FieldAttributes(String.class, String.class.getFields()[0]);\n     assertEquals(f.getName(), namingPolicy.translateName(f));\n   }\n \n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n       Class<?> rawType = $Gson$Types.getRawType(genericClass);\n       String className = rawType.getSimpleName();\n-      T value = (T) json.getAsJsonObject().get(className).getAsObject();\n+      JsonElement jsonElement = json.getAsJsonObject().get(className);\n+\n+      T value;\n+      if (genericClass == Integer.class) {\n+        value = (T) Integer.valueOf(jsonElement.getAsInt());\n+      } else if (genericClass == String.class) {\n+        value = (T) jsonElement.getAsString();\n+      } else {\n+        value = (T) jsonElement;\n+      }\n+\n       if (Primitives.isPrimitive(genericClass)) {\n         PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n         value = (T) typeAdapter.adaptType(value, rawType);\n--- a/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n   public void testFieldWithAnnotation() throws Exception {\n     String fieldName = \"fieldWithAnnotation\";\n     FieldAttributes f = new FieldAttributes(\n-        SomeObject.class, SomeObject.class.getField(fieldName), SomeObject.class);\n+        SomeObject.class, SomeObject.class.getField(fieldName));\n \n     assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));\n     assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));\n   public void testFieldWithoutAnnotation() throws Exception {\n     String fieldName = \"fieldWithoutAnnotation\";\n     FieldAttributes f = new FieldAttributes(\n-        SomeObject.class, SomeObject.class.getField(fieldName), SomeObject.class);\n+        SomeObject.class, SomeObject.class.getField(fieldName));\n \n     assertEquals(fieldName, policy.translateName(f));\n   }\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n     assertFalse(strategy.shouldSkipClass(clazz));\n \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f, clazz);\n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n     assertFalse(strategy.shouldSkipField(fieldAttributes));\n   }\n \n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n     assertFalse(strategy.shouldSkipClass(clazz));\n     \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f, clazz);\n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n     assertFalse(strategy.shouldSkipField(fieldAttributes));\n   }\n \n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n     assertTrue(strategy.shouldSkipClass(clazz));\n     \n-    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f, clazz);\n+    FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n     assertTrue(strategy.shouldSkipField(fieldAttributes));\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n     MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);\n     String json = MyParameterizedTypeAdapter.<Integer>getExpectedJson(src);\n     MyParameterizedType<Integer> intTarget = gson.fromJson(json, ptIntegerType);\n-    assertEquals(10, ((Number)intTarget.value).intValue());\n+    assertEquals(10, intTarget.value.intValue());\n \n     MyParameterizedType<String> srcStr = new MyParameterizedType<String>(\"abc\");\n     json = MyParameterizedTypeAdapter.<String>getExpectedJson(srcStr);", "timestamp": 1317434688, "metainfo": ""}