{"sha": "57d1f32de5bf3a7dd54613384cc7e979fba2660b", "log": "moved gson as a project under trunk", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Converts the field name that uses camel-case define word separation into separate words that\n+ * are separated by the provided {@code separatorString}.\n+ *\n+ * <p>The following is an example:</p>\n+ * <pre>\n+ * class IntWrapper {\n+ *   public int integerField = 0;\n+ * }\n+ *\n+ * CamelCaseSeparatorNamingPolicy policy = new CamelCaseSeparatorNamingPolicy(\"_\");\n+ * String translatedFieldName =\n+ *     policy.translateName(IntWrapper.class.getField(\"integerField\"));\n+ *\n+ * assert(\"integer_Field\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ */\n+final class CamelCaseSeparatorNamingPolicy extends RecursiveFieldNamingPolicy {\n+  private final String separatorString;\n+\n+  /**\n+   * Constructs a new CamelCaseSeparatorNamingPolicy object that will add the\n+   * {@code separatorString} between each of the words separated by camel case.\n+   *\n+   * @param separatorString the string value to place between words\n+   * @throws IllegalArgumentException thrown if the {@code separatorString} parameter\n+   *         is null or purely whitespace.\n+   */\n+  public CamelCaseSeparatorNamingPolicy(String separatorString) {\n+    Preconditions.checkNotNull(separatorString);\n+    Preconditions.checkArgument(!\"\".equals(separatorString.trim()));\n+    this.separatorString = separatorString;\n+  }\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annnotations) {\n+    StringBuilder translation = new StringBuilder();\n+    for (int i = 0; i < target.length(); i++) {\n+      char character = target.charAt(i);\n+      if (Character.isUpperCase(character) && translation.length() != 0) {\n+        translation.append(separatorString);\n+      }\n+      translation.append(character);\n+    }\n+\n+    return translation.toString();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/CompositionFieldNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Performs numerous field naming translations wrapped up as one object.\n+ *\n+ * @author Joel Leitch\n+ */\n+abstract class CompositionFieldNamingPolicy extends RecursiveFieldNamingPolicy {\n+\n+  private final RecursiveFieldNamingPolicy[] fieldPolicies;\n+\n+  public CompositionFieldNamingPolicy(RecursiveFieldNamingPolicy... fieldNamingPolicies) {\n+    if (fieldNamingPolicies == null) {\n+      throw new NullPointerException(\"naming policies can not be null.\");\n+    }\n+    this.fieldPolicies = fieldNamingPolicies;\n+  }\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+    for (RecursiveFieldNamingPolicy policy : fieldPolicies) {\n+      target = policy.translateName(target, fieldType, annotations);\n+    }\n+    return target;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.StringTokenizer;\n+import java.util.TreeSet;\n+\n+/**\n+ * List of all the default type adapters ({@link JsonSerializer}s, {@link JsonDeserializer}s,\n+ * and {@link InstanceCreator}s.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class DefaultTypeAdapters {\n+\n+  private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER =\n+    new DefaultDateTypeAdapter(DateFormat.DEFAULT);\n+  @SuppressWarnings(\"unchecked\")\n+  private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();\n+  private static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();\n+  private static final UriTypeAdapter URI_TYPE_ADAPTER = new UriTypeAdapter();\n+  private static final LocaleTypeAdapter LOCALE_TYPE_ADAPTER = new LocaleTypeAdapter();\n+  private static final MapTypeAdapter MAP_TYPE_ADAPTER = new MapTypeAdapter();\n+  private static final BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER = new BigDecimalTypeAdapter();\n+  private static final BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER = new BigIntegerTypeAdapter();\n+\n+  private static final BooleanCreator BOOLEAN_CREATOR = new BooleanCreator();\n+  private static final ByteCreator BYTE_CREATOR = new ByteCreator();\n+  private static final CharacterCreator CHARACTER_CREATOR = new CharacterCreator();\n+  private static final DoubleCreator DOUBLE_CREATOR = new DoubleCreator();\n+  private static final FloatCreator FLOAT_CREATOR = new FloatCreator();\n+  private static final IntegerCreator INTEGER_CREATOR = new IntegerCreator();\n+  private static final LongCreator LONG_CREATOR = new LongCreator();\n+  private static final ShortCreator SHORT_CREATOR = new ShortCreator();\n+  private static final LinkedListCreator LINKED_LIST_CREATOR = new LinkedListCreator();\n+  private static final TreeSetCreator TREE_SET_CREATOR = new TreeSetCreator();\n+\n+  // The constants DEFAULT_SERIALIZERS, DEFAULT_DESERIALIZERS, and DEFAULT_INSTANCE_CREATORS\n+  // must be defined after the constants for the type adapters. Otherwise, the type adapter\n+  // constants will appear as nulls.\n+  static final ParameterizedTypeHandlerMap<JsonSerializer<?>> DEFAULT_SERIALIZERS =\n+    getDefaultSerializers();\n+  static final ParameterizedTypeHandlerMap<JsonDeserializer<?>> DEFAULT_DESERIALIZERS =\n+    getDefaultDeserializers();\n+  static final ParameterizedTypeHandlerMap<InstanceCreator<?>> DEFAULT_INSTANCE_CREATORS =\n+    getDefaultInstanceCreators();\n+\n+  private static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n+    ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n+      new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n+\n+    map.register(Enum.class, wrapSerializer(ENUM_TYPE_ADAPTER));\n+    map.register(URL.class, wrapSerializer(URL_TYPE_ADAPTER));\n+    map.register(URI.class, wrapSerializer(URI_TYPE_ADAPTER));\n+    map.register(Locale.class, wrapSerializer(LOCALE_TYPE_ADAPTER));\n+    map.register(Map.class, wrapSerializer(MAP_TYPE_ADAPTER));\n+    map.register(Date.class, wrapSerializer(DATE_TYPE_ADAPTER));\n+    map.register(BigDecimal.class, wrapSerializer(BIG_DECIMAL_TYPE_ADAPTER));\n+    map.register(BigInteger.class, wrapSerializer(BIG_INTEGER_TYPE_ADAPTER));\n+    map.makeUnmodifiable();\n+    return map;\n+  }\n+\n+  private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() {\n+    ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n+      new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n+    map.register(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\n+    map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\n+    map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\n+    map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\n+    map.register(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\n+    map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n+    map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\n+    map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\n+    map.makeUnmodifiable();\n+    return map;\n+  }\n+\n+  private static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() {\n+    ParameterizedTypeHandlerMap<InstanceCreator<?>> map =\n+      new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n+    map.register(Enum.class, ENUM_TYPE_ADAPTER);\n+    map.register(URL.class, URL_TYPE_ADAPTER);\n+    map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n+    map.register(Map.class, MAP_TYPE_ADAPTER);\n+    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n+    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n+\n+    // Add primitive instance creators\n+    map.register(Boolean.class, BOOLEAN_CREATOR);\n+    map.register(boolean.class, BOOLEAN_CREATOR);\n+    map.register(Byte.class, BYTE_CREATOR);\n+    map.register(byte.class, BYTE_CREATOR);\n+    map.register(Character.class, CHARACTER_CREATOR);\n+    map.register(char.class, CHARACTER_CREATOR);\n+    map.register(Double.class, DOUBLE_CREATOR);\n+    map.register(double.class, DOUBLE_CREATOR);\n+    map.register(Float.class, FLOAT_CREATOR);\n+    map.register(float.class, FLOAT_CREATOR);\n+    map.register(Integer.class, INTEGER_CREATOR);\n+    map.register(int.class, INTEGER_CREATOR);\n+    map.register(Long.class, LONG_CREATOR);\n+    map.register(long.class, LONG_CREATOR);\n+    map.register(Short.class, SHORT_CREATOR);\n+    map.register(short.class, SHORT_CREATOR);\n+\n+    map.register(Collection.class, LINKED_LIST_CREATOR);\n+    map.register(List.class, LINKED_LIST_CREATOR);\n+    map.register(Queue.class, LINKED_LIST_CREATOR);\n+\n+    map.register(Set.class, TREE_SET_CREATOR);\n+    map.register(SortedSet.class, TREE_SET_CREATOR);\n+    map.makeUnmodifiable();\n+    return map;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static JsonSerializer<?> wrapSerializer(JsonSerializer<?> serializer) {\n+    return new JsonSerializerExceptionWrapper(serializer);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\n+    return new JsonDeserializerExceptionWrapper(deserializer);\n+  }\n+\n+  static class DefaultDateTypeAdapter implements JsonSerializer<Date>, JsonDeserializer<Date> {\n+\n+    private final DateFormat format;\n+\n+    public DefaultDateTypeAdapter(String datePattern) {\n+      this.format = new SimpleDateFormat(datePattern);\n+    }\n+\n+    public DefaultDateTypeAdapter(int style) {\n+      this.format = DateFormat.getDateInstance(style);\n+    }\n+\n+    public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n+      String dateFormatAsString = format.format(src);\n+      return new JsonPrimitive(dateFormatAsString);\n+    }\n+\n+    public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      if (!(json instanceof JsonPrimitive)) {\n+        throw new JsonParseException(\"The date should be a string value\");\n+      }\n+\n+      try {\n+        return format.parse(json.getAsString());\n+      } catch (ParseException e) {\n+        throw new JsonParseException(e);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static class EnumTypeAdapter<T extends Enum<T>> implements JsonSerializer<T>,\n+      JsonDeserializer<T>, InstanceCreator<Enum<?>> {\n+    public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src.name());\n+    }\n+    @SuppressWarnings(\"cast\")\n+    public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return (T) Enum.valueOf((Class<T>)classOfT, json.getAsString());\n+    }\n+    public Enum<?> createInstance(Type type) {\n+      Class<Enum<?>> enumClass = (Class<Enum<?>>) type;\n+      try {\n+        Method valuesMethod = enumClass.getMethod(\"values\");\n+        Enum<?>[] enums = (Enum<?>[]) valuesMethod.invoke(null);\n+        return enums[0];\n+      } catch (NoSuchMethodException e) {\n+        throw new RuntimeException(e);\n+      } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+      } catch (InvocationTargetException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  private static class UrlTypeAdapter implements JsonSerializer<URL>, JsonDeserializer<URL>,\n+      InstanceCreator<URL> {\n+    public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src.toExternalForm());\n+    }\n+    public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      try {\n+        return new URL(json.getAsString());\n+      } catch (MalformedURLException e) {\n+        throw new JsonParseException(e);\n+      }\n+    }\n+    public URL createInstance(Type type) {\n+      try {\n+        return new URL(\"http://google.com/\");\n+      } catch (MalformedURLException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  private static class UriTypeAdapter implements JsonSerializer<URI>, JsonDeserializer<URI> {\n+    public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src.toASCIIString());\n+    }\n+    public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+    throws JsonParseException {\n+      try {\n+        return new URI(json.getAsString());\n+      } catch (URISyntaxException e) {\n+        throw new JsonParseException(e);\n+      }\n+    }\n+  }\n+\n+  private static class LocaleTypeAdapter implements JsonSerializer<Locale>,\n+      JsonDeserializer<Locale>, InstanceCreator<Locale> {\n+    public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src.toString());\n+    }\n+    public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      String locale = json.getAsString();\n+      StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\n+      String language = null;\n+      String country = null;\n+      String variant = null;\n+      if (tokenizer.hasMoreElements()) {\n+        language = tokenizer.nextToken();\n+      }\n+      if (tokenizer.hasMoreElements()) {\n+        country = tokenizer.nextToken();\n+      }\n+      if (tokenizer.hasMoreElements()) {\n+        variant = tokenizer.nextToken();\n+      }\n+      if (country == null && variant == null) {\n+        return new Locale(language);\n+      } else if (variant == null) {\n+        return new Locale(language, country);\n+      } else {\n+        return new Locale(language, country, variant);\n+      }\n+    }\n+    public Locale createInstance(Type type) {\n+      return new Locale(\"en_US\");\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static class MapTypeAdapter implements JsonSerializer<Map>, JsonDeserializer<Map>,\n+      InstanceCreator<Map> {\n+    public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) {\n+      JsonObject map = new JsonObject();\n+      Type childType = new TypeInfoMap(typeOfSrc).getValueType();\n+      for (Iterator iterator = src.entrySet().iterator(); iterator.hasNext(); ) {\n+        Map.Entry entry = (Map.Entry) iterator.next();\n+        JsonElement valueElement = context.serialize(entry.getValue(), childType);\n+        map.add(entry.getKey().toString(), valueElement);\n+      }\n+      return map;\n+    }\n+    public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      // Using linked hash map to preserve order in which elements are entered\n+      Map<String, Object> map = new LinkedHashMap<String, Object>();\n+      Type childType = new TypeInfoMap(typeOfT).getValueType();\n+      for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n+        Object value = context.deserialize(entry.getValue(), childType);\n+        map.put(entry.getKey(), value);\n+      }\n+      return map;\n+    }\n+    public Map createInstance(Type type) {\n+      return new LinkedHashMap();\n+    }\n+  }\n+\n+  private static class BigDecimalTypeAdapter implements JsonSerializer<BigDecimal>,\n+      JsonDeserializer<BigDecimal>, InstanceCreator<BigDecimal> {\n+\n+    public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public BigDecimal deserialize(JsonElement json, Type typeOfT,\n+        JsonDeserializationContext context) throws JsonParseException {\n+      return json.getAsBigDecimal();\n+    }\n+\n+    public BigDecimal createInstance(Type type) {\n+      return new BigDecimal(0);\n+    }\n+  }\n+\n+  private static class BigIntegerTypeAdapter implements JsonSerializer<BigInteger>,\n+      JsonDeserializer<BigInteger>, InstanceCreator<BigInteger> {\n+\n+    public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public BigInteger deserialize(JsonElement json, Type typeOfT,\n+        JsonDeserializationContext context) throws JsonParseException {\n+      return json.getAsBigInteger();\n+    }\n+\n+    public BigInteger createInstance(Type type) {\n+      return new BigInteger(\"0\");\n+    }\n+  }\n+\n+  private static class LongCreator implements InstanceCreator<Long> {\n+    public Long createInstance(Type type) {\n+      return new Long(0L);\n+    }\n+  }\n+\n+  private static class IntegerCreator implements InstanceCreator<Integer> {\n+    public Integer createInstance(Type type) {\n+      return new Integer(0);\n+    }\n+  }\n+\n+  private static class ShortCreator implements InstanceCreator<Short> {\n+    public Short createInstance(Type type) {\n+      return new Short((short) 0);\n+    }\n+  }\n+\n+  private static class ByteCreator implements InstanceCreator<Byte> {\n+    public Byte createInstance(Type type) {\n+      return new Byte((byte) 0);\n+    }\n+  }\n+\n+  private static class FloatCreator implements InstanceCreator<Float> {\n+    public Float createInstance(Type type) {\n+      return new Float(0F);\n+    }\n+  }\n+\n+  private static class DoubleCreator implements InstanceCreator<Double> {\n+    public Double createInstance(Type type) {\n+      return new Double(0D);\n+    }\n+  }\n+\n+  private static class CharacterCreator implements InstanceCreator<Character> {\n+    public Character createInstance(Type type) {\n+      return new Character((char) 0);\n+    }\n+  }\n+\n+  private static class BooleanCreator implements InstanceCreator<Boolean> {\n+    public Boolean createInstance(Type type) {\n+      return new Boolean(false);\n+    }\n+  }\n+\n+  private static class LinkedListCreator implements InstanceCreator<LinkedList<?>> {\n+    public LinkedList<?> createInstance(Type type) {\n+      return new LinkedList<Object>();\n+    }\n+  }\n+\n+  private static class TreeSetCreator implements InstanceCreator<TreeSet<?>> {\n+    public TreeSet<?> createInstance(Type type) {\n+      return new TreeSet<Object>();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A simple implementation of the {@link JsonElementVisitor} that simply delegates the method\n+ * invocation onto a {@code delegate} instance of the {@link JsonElementVisitor}.  This object\n+ * can be used to build a chain of visitors such that each Visitor instance can perform some\n+ * operation on the {@link JsonElement} and then pass on the input to the delegate.  This kind\n+ * of pattern is sometimes referred as a \"Chain of Responsibility\".\n+ *\n+ * <p>The following is an example use case:\n+ *\n+ * <pre>\n+ * class JsonEscapingVisitor extends DelegatingJsonElementVisitor {\n+ *   public JsonEscapingVisitor(JsonElementVisitor) {\n+ *     super(visitor);\n+ *   }\n+ *\n+ *   public void visitPrimitive(JsonPrimitive primitive) {\n+ *     JsonPrimitive escapedPrimitive = escapePrimitiveObject(primitive);\n+ *     super.visitPrimitive(escapedPrimitive);\n+ *   }\n+ * }\n+ *\n+ * JsonElementVisitor visitor = new JsonEscapingVisitor(new FormattingVisitor());\n+ * </pre></p>\n+ *\n+ * @author Joel Leitch\n+ */\n+class DelegatingJsonElementVisitor implements JsonElementVisitor {\n+  private final JsonElementVisitor delegate;\n+\n+  protected DelegatingJsonElementVisitor(JsonElementVisitor delegate) {\n+    Preconditions.checkNotNull(delegate);\n+    this.delegate = delegate;\n+  }\n+\n+  public void endArray(JsonArray array) {\n+    delegate.endArray(array);\n+  }\n+\n+  public void endObject(JsonObject object) {\n+    delegate.endObject(object);\n+  }\n+\n+  public void startArray(JsonArray array) {\n+    delegate.startArray(array);\n+  }\n+\n+  public void startObject(JsonObject object) {\n+    delegate.startObject(object);\n+  }\n+\n+  public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {\n+    delegate.visitArrayMember(parent, member, isFirst);\n+  }\n+\n+  public void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst) {\n+    delegate.visitArrayMember(parent, member, isFirst);\n+  }\n+\n+  public void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst) {\n+    delegate.visitArrayMember(parent, member, isFirst);\n+  }\n+\n+  public void visitObjectMember(\n+      JsonObject parent, String memberName, JsonPrimitive member, boolean isFirst) {\n+    delegate.visitObjectMember(parent, memberName, member, isFirst);\n+  }\n+\n+  public void visitObjectMember(\n+      JsonObject parent, String memberName, JsonArray member, boolean isFirst) {\n+    delegate.visitObjectMember(parent, memberName, member, isFirst);\n+  }\n+\n+  public void visitObjectMember(\n+      JsonObject parent, String memberName, JsonObject member, boolean isFirst) {\n+    delegate.visitObjectMember(parent, memberName, member, isFirst);\n+  }\n+\n+  public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {\n+    delegate.visitNullObjectMember(parent, memberName, isFirst);\n+  }\n+\n+  public void visitPrimitive(JsonPrimitive primitive) {\n+    delegate.visitPrimitive(primitive);\n+  }\n+\n+  public void visitNull() {\n+    delegate.visitNull();\n+  }\n+\n+  public void visitNullArrayMember(JsonArray parent, boolean isFirst) {\n+    delegate.visitNullArrayMember(parent, isFirst);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+/**\n+ * A wrapper class used to collect numerous {@link ExclusionStrategy} objects\n+ * and perform a short-circuited OR operation.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class DisjunctionExclusionStrategy implements ExclusionStrategy {\n+  private final Collection<ExclusionStrategy> strategies;\n+\n+  public DisjunctionExclusionStrategy(ExclusionStrategy... strategies) {\n+    Preconditions.checkNotNull(strategies);\n+    Preconditions.checkArgument(strategies.length > 0);\n+\n+    this.strategies = new LinkedList<ExclusionStrategy>();\n+    for (ExclusionStrategy strategy : strategies) {\n+      this.strategies.add(strategy);\n+    }\n+  }\n+\n+  public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\n+    Preconditions.checkNotNull(strategies);\n+    Preconditions.checkArgument(!strategies.isEmpty());\n+\n+    this.strategies = new LinkedList<ExclusionStrategy>();\n+    this.strategies.addAll(strategies);\n+  }\n+\n+  public boolean shouldSkipField(Field f) {\n+    for (ExclusionStrategy strategy : strategies) {\n+      if (strategy.shouldSkipField(f)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    for (ExclusionStrategy strategy : strategies) {\n+      if (strategy.shouldSkipClass(clazz)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Escaper.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * A utility class that is used to perform JSON escaping so that \", <, >, etc. characters are\n+ * properly encoded in the JSON string representation before returning to the client code.\n+ *\n+ * <p>This class contains a single method to escape a passed in string value:\n+ * <pre>\n+ *   String jsonStringValue = \"beforeQuote\\\"afterQuote\";\n+ *   String escapedValue = Escaper.escapeJsonString(jsonStringValue);\n+ * </pre></p>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class Escaper {\n+\n+  private static final char[] HEX_CHARS = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n+  };\n+\n+  private static final Set<Character> JS_ESCAPE_CHARS;\n+\n+  static {\n+    Set<Character> tmpSet = new HashSet<Character>();\n+    tmpSet.add('\\u0000');\n+    tmpSet.add('\\r');\n+    tmpSet.add('\\n');\n+    tmpSet.add('\\u2028');\n+    tmpSet.add('\\u2029');\n+    tmpSet.add('\\u0085');\n+    tmpSet.add('\\'');\n+    tmpSet.add('\"');\n+    tmpSet.add('<');\n+    tmpSet.add('>');\n+    tmpSet.add('&');\n+    tmpSet.add('=');\n+    tmpSet.add('\\\\');\n+    JS_ESCAPE_CHARS = Collections.unmodifiableSet(tmpSet);\n+  }\n+\n+  public static String escapeJsonString(CharSequence plainText) {\n+    StringBuffer escapedString = new StringBuffer(plainText.length() + 20);\n+    try {\n+      escapeJsonString(plainText, escapedString);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+    return escapedString.toString();\n+  }\n+\n+  private static void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException {\n+    int pos = 0;  // Index just past the last char in plainText written to out.\n+    int len = plainText.length();\n+     for (int charCount, i = 0; i < len; i += charCount) {\n+       int codePoint = Character.codePointAt(plainText, i);\n+       charCount = Character.charCount(codePoint);\n+\n+         if (!((codePoint < 0x20 || codePoint >= 0x7f)\n+               || mustEscapeCharInJsString(codePoint))) {\n+            continue;\n+         }\n+\n+         out.append(plainText, pos, i);\n+         pos = i + charCount;\n+         switch (codePoint) {\n+           case '\\b':\n+             out.append(\"\\\\b\");\n+             break;\n+           case '\\t':\n+             out.append(\"\\\\t\");\n+             break;\n+           case '\\n':\n+             out.append(\"\\\\n\");\n+             break;\n+           case '\\f':\n+             out.append(\"\\\\f\");\n+             break;\n+           case '\\r':\n+             out.append(\"\\\\r\");\n+             break;\n+           case '\\\\':\n+             out.append(\"\\\\\\\\\");\n+             break;\n+           case '\"':\n+             out.append('\\\\').append((char) codePoint);\n+             break;\n+           case '\\'':\n+             out.append((char) codePoint);\n+             break;\n+           default:\n+             appendHexJavaScriptRepresentation(codePoint, out);\n+             break;\n+         }\n+     }\n+     out.append(plainText, pos, len);\n+  }\n+\n+  private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out)\n+      throws IOException {\n+    if (Character.isSupplementaryCodePoint(codePoint)) {\n+      // Handle supplementary unicode values which are not representable in\n+      // javascript.  We deal with these by escaping them as two 4B sequences\n+      // so that they will round-trip properly when sent from java to javascript\n+      // and back.\n+      char[] surrogates = Character.toChars(codePoint);\n+      appendHexJavaScriptRepresentation(surrogates[0], out);\n+      appendHexJavaScriptRepresentation(surrogates[1], out);\n+      return;\n+    }\n+    out.append(\"\\\\u\")\n+        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n+        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n+        .append(HEX_CHARS[codePoint & 0xf]);\n+  }\n+\n+  private static boolean mustEscapeCharInJsString(int codepoint) {\n+    if (!Character.isSupplementaryCodePoint(codepoint)) {\n+      return JS_ESCAPE_CHARS.contains((char)codepoint);\n+    } else {\n+      return false;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * A strategy definition that is used by the {@link ObjectNavigator} to\n+ * determine whether or not the field of the object should be ignored during\n+ * navigation.\n+ *\n+ * As well, for now this class is also responsible for excluding entire\n+ * classes.  This is somewhat a mixing of concerns for this object, but\n+ * it will suffice for now.  We can always break it down into two\n+ * different strategies later.\n+ *\n+ * @author Joel Leitch\n+ */\n+interface ExclusionStrategy {\n+\n+  /**\n+   * @param f the field object that is under test\n+   * @return true if the field should be ignored otherwise false\n+   */\n+  public boolean shouldSkipField(Field f);\n+\n+  /**\n+   * @param clazz the class object that is under test\n+   * @return true if the class should be ignored otherwise false\n+   */\n+  public boolean shouldSkipClass(Class<?> clazz);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ExposeAnnotationBasedExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Expose;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Excludes fields that do not have the {@link Expose} annotation\n+ * \n+ * @author Inderjeet Singh\n+ */\n+class ExposeAnnotationBasedExclusionStrategy implements ExclusionStrategy {\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return false;\n+  }\n+\n+  public boolean shouldSkipField(Field f) {\n+    return f.getAnnotation(Expose.class) == null;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/FieldNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * An enumeration that defines a few standard naming conventions for JSON field names.\n+ * This enumeration should be used in conjunction with {@link com.google.gson.GsonBuilder}\n+ * to configure a {@link com.google.gson.Gson} instance to properly translate Java field\n+ * names into the desired JSON field names.\n+ *\n+ * @author Joel Leitch\n+ */\n+public enum FieldNamingPolicy {\n+  /**\n+   * Using this naming policy with Gson will ensure that the first \"letter\" of the Java\n+   * field name is capitalized when serialized to its JSON form.\n+   *\n+   * <p>Here's a few examples of the form \"Java Field Name\" ---> \"JSON Field Name\":</p>\n+   * <ul>\n+   *   <li>someFieldName ---> SomeFieldName</li>\n+   *   <li>_someFieldName ---> _SomeFieldName</li>\n+   * </ul>\n+   */\n+  UPPER_CAMEL_CASE(new ModifyFirstLetterNamingPolicy(\n+      ModifyFirstLetterNamingPolicy.LetterModifier.UPPER)),\n+\n+  /**\n+   * Using this naming policy with Gson will modify the Java Field name from its camel cased\n+   * form to a lower case field name where each word is separated by an underscore (_).\n+   *\n+   * <p>Here's a few examples of the form \"Java Field Name\" ---> \"JSON Field Name\":</p>\n+   * <ul>\n+   *   <li>someFieldName ---> some_field_name</li>\n+   *   <li>_someFieldName ---> _some_field_name</li>\n+   *   <li>aStringField ---> a_string_field</li>\n+   *   <li>aURL ---> a_u_r_l</li>\n+   * </ul>\n+   */\n+  LOWER_CASE_WITH_UNDERSCORES(new LowerCamelCaseSeparatorNamingPolicy(\"_\"));\n+\n+  private final FieldNamingStrategy namingPolicy;\n+\n+  private FieldNamingPolicy(FieldNamingStrategy namingPolicy) {\n+    this.namingPolicy = namingPolicy;\n+  }\n+\n+  FieldNamingStrategy getFieldNamingPolicy() {\n+    return namingPolicy;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * A mechanism for providing custom field naming in Gson.  This allows the client code to translate\n+ * field names into a particular convention that is not supported as a normal Java field\n+ * declaration rules.  For example, Java does not support \"-\" characters in a field name.\n+ *\n+ * @author Joel Leitch\n+ */\n+interface FieldNamingStrategy {\n+\n+  /**\n+   * Translates the field name into its JSON field name representation.\n+   *\n+   * @param f the field object that we are translating\n+   * @return the translated field name.\n+   */\n+  public String translateName(Field f);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/GenericArrayTypeImpl.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * An simple pojo-like immutable instance of the {@link GenericArrayType}.  This object provides\n+ * us the ability to create reflective types on demand.  This object is required for support\n+ * object similar to the one defined below:\n+ * <pre>\n+ * class Foo<T> {\n+ *   private final List<T>[] arrayOfListT;\n+ *\n+ *   Foo(List<T>[] arrayList) {\n+ *     this.arrayOfListT = arrayList;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>During parsing or serialization, we know the real variable type parameter {@code T},\n+ * so we can build a new {@code GenericTypeArray} with the \"real\" type parameters and\n+ * pass that object along instead.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class GenericArrayTypeImpl implements GenericArrayType {\n+\n+  private final Type genericComponentType;\n+\n+  public GenericArrayTypeImpl(Type genericComponentType) {\n+    this.genericComponentType = genericComponentType;\n+  }\n+\n+  public Type getGenericComponentType() {\n+    return genericComponentType;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof  GenericArrayType)) {\n+      return false;\n+    } else {\n+      GenericArrayType that = (GenericArrayType) o;\n+      Type thatComponentType = that.getGenericComponentType();\n+      return genericComponentType == null ?\n+          thatComponentType == null : genericComponentType.equals(thatComponentType);\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (genericComponentType == null) ? 0 : genericComponentType.hashCode();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+/**\n+ * This is the main class for using Gson. Gson is typically used by first constructing a\n+ * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}\n+ * methods on it.\n+ *\n+ * <p>You can create a Gson instance by invoking {@code new Gson()} if the default configuration\n+ * is all you need. You can also use {@link GsonBuilder} to build a Gson instance with various\n+ * configuration options such as versioning support, pretty printing, custom\n+ * {@link JsonSerializer}s, {@link JsonDeserializer}s, and {@link InstanceCreator}s.</p>\n+ *\n+ * <p>Here is an example of how Gson is used for a simple Class:\n+ *\n+ * <pre>\n+ * Gson gson = new Gson(); // Or use new GsonBuilder().create();\n+ * MyType target = new MyType();\n+ * String json = gson.toJson(target); // serializes target to Json\n+ * MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2\n+ * </pre></p>\n+ *\n+ * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}\n+ * (i.e. contains at least one type parameter and may be an array) then you must use the\n+ * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an\n+ * example for serializing and deserialing a {@code ParameterizedType}:\n+ *\n+ * <pre>\n+ * Type listType = new TypeToken<List<String>>() {}.getType();\n+ * List<String> target = new LinkedList<String>();\n+ * target.add(\"blah\");\n+ *\n+ * Gson gson = new Gson();\n+ * String json = gson.toJson(target, listType);\n+ * List<String> target2 = gson.fromJson(json, listType);\n+ * </pre></p>\n+ *\n+ * <p>See the <a href=\"https://sites.google.com/site/gson/gson-user-guide\">Gson User Guide</a>\n+ * for a more complete set of examples.</p>\n+ *\n+ * @see com.google.gson.reflect.TypeToken\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class Gson {\n+\n+  //TODO(inder): get rid of all the registerXXX methods and take all such parameters in the\n+  // constructor instead. At the minimum, mark those methods private.\n+\n+  private static final String NULL_STRING = \"null\";\n+  // Default instances of plug-ins\n+  static final TypeAdapter DEFAULT_TYPE_ADAPTER =\n+      new TypeAdapterNotRequired(new PrimitiveTypeAdapter());\n+  static final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\n+      new ModifierBasedExclusionStrategy(true, new int[] { Modifier.TRANSIENT, Modifier.STATIC });\n+  static final JsonFormatter DEFAULT_JSON_FORMATTER = new JsonCompactFormatter();\n+  static final FieldNamingStrategy DEFAULT_NAMING_POLICY =\n+      new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n+\n+  static final Logger logger = Logger.getLogger(Gson.class.getName());\n+\n+  private final ObjectNavigatorFactory navigatorFactory;\n+  private final MappedObjectConstructor objectConstructor;\n+  private final TypeAdapter typeAdapter;\n+\n+  /** Map containing Type or Class objects as keys */\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+\n+  /** Map containing Type or Class objects as keys */\n+  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+\n+  private final JsonFormatter formatter;\n+  private final boolean serializeNulls;\n+\n+  /**\n+   * Constructs a Gson object with default configuration. The default configuration has the\n+   * following settings:\n+   * <ul>\n+   *   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n+   *   means that all the unneeded white-space is removed. You can change this behavior with\n+   *   {@link GsonBuilder#setPrettyPrinting()}. </li>\n+   *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n+   *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n+   *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n+   *   by setting {@link GsonBuilder#serializeNulls()}.</li>\n+   *   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n+   *   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n+   *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n+   *   to change the default representation, you can do so by registering a type adapter through\n+   *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n+   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. You can change\n+   *   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n+   *   {@link GsonBuilder#setDateFormat(String)}. </li>\n+   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n+   *   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n+   *   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n+   *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n+   *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n+   *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n+   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber@quot;</code> in\n+   *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n+   *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n+   *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n+   *   consideration for serialization and deserialization. You can change this behavior through\n+   *   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n+   * </ul>\n+   */\n+  public Gson() {\n+    this(createDefaultObjectNavigatorFactory());\n+  }\n+\n+  /**\n+   * Constructs a Gson object with the specified version and the mode of operation while\n+   * encountering inner class references.\n+   *\n+   * @param factory the object navigator factory to use when creating a new {@link ObjectNavigator}\n+   * instance\n+   */\n+  Gson(ObjectNavigatorFactory factory) {\n+    this(factory, createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),\n+        DEFAULT_TYPE_ADAPTER, DEFAULT_JSON_FORMATTER, false,\n+        DefaultTypeAdapters.DEFAULT_SERIALIZERS, DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n+  }\n+\n+  Gson(ObjectNavigatorFactory factory, MappedObjectConstructor objectConstructor,\n+      TypeAdapter typeAdapter, JsonFormatter formatter, boolean serializeNulls,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n+    this.navigatorFactory = factory;\n+    this.objectConstructor = objectConstructor;\n+    this.typeAdapter = typeAdapter;\n+    this.formatter = formatter;\n+    this.serializeNulls = serializeNulls;\n+    this.serializers = serializers;\n+    this.deserializers = deserializers;\n+  }\n+\n+  static MappedObjectConstructor createObjectConstructor(\n+      ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n+    MappedObjectConstructor objectConstructor = new MappedObjectConstructor();\n+    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\n+      objectConstructor.register(entry.getKey(), entry.getValue());\n+    }\n+    return objectConstructor;\n+  }\n+\n+  private static ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n+    return new ObjectNavigatorFactory(\n+        createExclusionStrategy(VersionConstants.IGNORE_VERSIONS), DEFAULT_NAMING_POLICY);\n+  }\n+\n+  private static ExclusionStrategy createExclusionStrategy(double version) {\n+    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    strategies.add(new InnerClassExclusionStrategy());\n+    strategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\n+    if (version != VersionConstants.IGNORE_VERSIONS) {\n+      strategies.add(new VersionExclusionStrategy(version));\n+    }\n+    return new DisjunctionExclusionStrategy(strategies);\n+  }\n+\n+  /**\n+   * This method serializes the specified object into its equivalent Json representation.\n+   * This method should be used when the specified object is not a generic type. This method uses\n+   * {@link Class#getClass()} to get the type for the specified object, but the\n+   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n+   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n+   * just the object itself should not be of a generic type. If the object is of generic type, use\n+   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a\n+   * {@link Writer}, use {@link #toJson(Object, Writer)} instead.\n+   *\n+   * @param src the object for which Json representation is to be created setting for Gson\n+   * @return Json representation of {@code src}.\n+   */\n+  public String toJson(Object src) {\n+    if (src == null) {\n+      return serializeNulls ? NULL_STRING : \"\";\n+    }\n+    return toJson(src, src.getClass());\n+  }\n+\n+  /**\n+   * This method serializes the specified object, including those of generic types, into its\n+   * equivalent Json representation. This method must be used if the specified object is a generic\n+   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out\n+   * the object to a {@link Writer}, use {@link #toJson(Object, Type, Writer)} instead.\n+   *\n+   * @param src the object for which JSON representation is to be created\n+   * @param typeOfSrc The specific genericized type of src. You can obtain\n+   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n+   * to get the type for {@code Collection<Foo>}, you should use:\n+   * <pre>\n+   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+   * </pre>\n+   * @return Json representation of {@code src}\n+   */\n+  public String toJson(Object src, Type typeOfSrc) {\n+    StringWriter writer = new StringWriter();\n+    toJson(src, typeOfSrc, writer);\n+    return writer.toString();\n+  }\n+\n+  /**\n+   * This method serializes the specified object into its equivalent Json representation.\n+   * This method should be used when the specified object is not a generic type. This method uses\n+   * {@link Class#getClass()} to get the type for the specified object, but the\n+   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n+   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n+   * just the object itself should not be of a generic type. If the object is of generic type, use\n+   * {@link #toJson(Object, Type, Writer)} instead.\n+   *\n+   * @param src the object for which Json representation is to be created setting for Gson\n+   * @param writer Writer to which the Json representation needs to be written\n+   * @since 1.2\n+   */\n+  public void toJson(Object src, Writer writer) {\n+    if (src != null) {\n+      toJson(src, src.getClass(), writer);\n+    } else if (serializeNulls) {\n+      writeOutNullString(writer);\n+    }\n+  }\n+\n+  /**\n+   * This method serializes the specified object, including those of generic types, into its\n+   * equivalent Json representation. This method must be used if the specified object is a generic\n+   * type. For non-generic objects, use {@link #toJson(Object, Writer)} instead.\n+   *\n+   * @param src the object for which JSON representation is to be created\n+   * @param typeOfSrc The specific genericized type of src. You can obtain\n+   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n+   * to get the type for {@code Collection<Foo>}, you should use:\n+   * <pre>\n+   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+   * </pre>\n+   * @param writer Writer to which the Json representation of src needs to be written.\n+   * @since 1.2\n+   */\n+  public void toJson(Object src, Type typeOfSrc, Writer writer) {\n+    if (src != null) {\n+      JsonSerializationContext context =\n+          new JsonSerializationContextDefault(navigatorFactory, serializeNulls, serializers);\n+      JsonElement jsonElement = context.serialize(src, typeOfSrc);\n+\n+      //TODO(Joel): instead of navigating the \"JsonElement\" inside the formatter, do it here.\n+      formatter.format(jsonElement, new PrintWriter(writer), serializeNulls);\n+    } else {\n+      if (serializeNulls) {\n+        writeOutNullString(writer);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method deserializes the specified Json into an object of the specified class. It is not\n+   * suitable to use if the specified class is a generic type since it will not have the generic\n+   * type information because of the Type Erasure feature of Java. Therefore, this method should not\n+   * be used if the desired type is a generic type. Note that this method works fine if the any of\n+   * the fields of the specified object are generics, just the object itself should not be a\n+   * generic type. For the cases when the object is of generic type, invoke\n+   * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\n+   * a String, use {@link #fromJson(Reader, Class)} instead.\n+   *\n+   * @param <T> the type of the desired object\n+   * @param json the string from which the object is to be deserialized\n+   * @param classOfT the class of T\n+   * @return an object of type T from the string\n+   * @throws JsonParseException if json is not a valid representation for an object of type\n+   * classOfT\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException {\n+    T target = (T) fromJson(json, (Type) classOfT);\n+    return target;\n+  }\n+\n+  /**\n+   * This method deserializes the specified Json into an object of the specified type. This method\n+   * is useful if the specified object is a generic type. For non-generic objects, use\n+   * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of\n+   * a String, use {@link #fromJson(Reader, Type)} instead.\n+   *\n+   * @param <T> the type of the desired object\n+   * @param json the string from which the object is to be deserialized\n+   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n+   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n+   * {@code Collection<Foo>}, you should use:\n+   * <pre>\n+   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+   * </pre>\n+   * @return an object of type T from the string\n+   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T fromJson(String json, Type typeOfT) throws JsonParseException {\n+    StringReader reader = new StringReader(json);\n+    T target = (T) fromJson(reader, typeOfT);\n+    return target;\n+  }\n+\n+  /**\n+   * This method deserializes the Json read from the specified reader into an object of the\n+   * specified class. It is not suitable to use if the specified class is a generic type since it\n+   * will not have the generic type information because of the Type Erasure feature of Java.\n+   * Therefore, this method should not be used if the desired type is a generic type. Note that\n+   * this method works fine if the any of the fields of the specified object are generics, just the\n+   * object itself should not be a generic type. For the cases when the object is of generic type,\n+   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a\n+   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n+   *\n+   * @param <T> the type of the desired object\n+   * @param json the reader producing the Json from which the object is to be deserialized.\n+   * @param classOfT the class of T\n+   * @return an object of type T from the string\n+   * @throws JsonParseException if json is not a valid representation for an object of type\n+   * classOfT\n+   * @since 1.2\n+   */\n+  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException {\n+    T target = classOfT.cast(fromJson(json, (Type) classOfT));\n+    return target;\n+  }\n+\n+  /**\n+   * This method deserializes the Json read from the specified reader into an object of the\n+   * specified type. This method is useful if the specified object is a generic type. For\n+   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n+   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n+   *\n+   * @param <T> the type of the desired object\n+   * @param json the reader producing Json from which the object is to be deserialized\n+   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n+   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n+   * {@code Collection<Foo>}, you should use:\n+   * <pre>\n+   * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+   * </pre>\n+   * @return an object of type T from the json\n+   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   * @since 1.2\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n+    try {\n+      JsonParser parser = new JsonParser(json);\n+      JsonElement root = parser.parse();\n+      JsonDeserializationContext context = new JsonDeserializationContextDefault(navigatorFactory,\n+          deserializers, objectConstructor, typeAdapter);\n+      T target = (T) context.deserialize(root, typeOfT);\n+      return target;\n+    } catch (TokenMgrError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (ParseException e) {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (StackOverflowError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    } catch (OutOfMemoryError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\n+    }\n+  }\n+\n+  /**\n+   * Appends the {@link #NULL_STRING} to the {@code writer} object.\n+   *\n+   * @param writer the object to append the null value to\n+   */\n+  private void writeOutNullString(Writer writer) {\n+    try {\n+      writer.append(NULL_STRING);\n+    } catch (IOException e) {\n+      // Should this be a different exception???\n+      throw new JsonParseException(e);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+\n+import java.lang.reflect.Type;\n+import java.text.DateFormat;\n+import java.util.Date;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n+ * options other than the default. For {@link Gson} with default configuration, it is simpler to\n+ * use {@code new Gson()}. {@code GsonBuilder} is best used by creating it, and then invoking its\n+ * various configuration methods, and finally calling create.</p>\n+ *\n+ * <p>The following is an example shows how to use the {@code GsonBuilder} to construct a Gson\n+ * instance:\n+ *\n+ * <pre>\n+ * Gson gson = new GsonBuilder()\n+ *     .registerTypeAdapter(Id.class, new IdTypeAdapter())\n+ *     .serializeNulls()\n+ *     .setDateFormat(DateFormat.LONG)\n+ *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+ *     .setPrettyPrinting()\n+ *     .setVersion(1.0)\n+ *     .create();\n+ * </pre></p>\n+ *\n+ * <p>NOTE: the order of invocation of configuration methods does not matter.</p>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class GsonBuilder {\n+\n+  private double ignoreVersionsAfter;\n+  private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n+  private final InnerClassExclusionStrategy innerClassExclusionStrategy;\n+  private boolean excludeFieldsWithoutExposeAnnotation;\n+  private final TypeAdapter typeAdapter;\n+  private JsonFormatter formatter;\n+  private FieldNamingStrategy fieldNamingPolicy;\n+  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private boolean serializeNulls;\n+  private String datePattern;\n+  private int dateStyle;\n+\n+  /**\n+   * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n+   * settings. GsonBuilder follows the builder pattern, and it is typically used by first\n+   * invoking various configuration methods to set desired options, and finally calling\n+   * {@link #create()}.\n+   */\n+  public GsonBuilder() {\n+    // setup default values\n+    ignoreVersionsAfter = VersionConstants.IGNORE_VERSIONS;\n+    innerClassExclusionStrategy = new InnerClassExclusionStrategy();\n+    modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY;\n+    excludeFieldsWithoutExposeAnnotation = false;\n+    typeAdapter = Gson.DEFAULT_TYPE_ADAPTER;\n+    formatter = Gson.DEFAULT_JSON_FORMATTER;\n+    fieldNamingPolicy = Gson.DEFAULT_NAMING_POLICY;\n+    instanceCreators = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n+    serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n+    deserializers = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n+    serializeNulls = false;\n+    dateStyle = DateFormat.DEFAULT;\n+  }\n+\n+  /**\n+   * Configures Gson to enable versioning support.\n+   *\n+   * @param ignoreVersionsAfter any field or type marked with a version higher than this value\n+   * are ignored during serialization or deserialization.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder setVersion(double ignoreVersionsAfter) {\n+    this.ignoreVersionsAfter = ignoreVersionsAfter;\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to excludes all class fields that have the specified modifiers. By default,\n+   * Gson will exclude all fields marked transient or static. This method will override that\n+   * behavior.\n+   *\n+   * @param modifiers the field modifiers. You must use the modifiers specified in the\n+   * {@link java.lang.reflect.Modifier} class. For example,\n+   * {@link java.lang.reflect.Modifier#TRANSIENT},\n+   * {@link java.lang.reflect.Modifier#STATIC}.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\n+    boolean skipSynthetics = true;\n+    modifierBasedExclusionStrategy = new ModifierBasedExclusionStrategy(skipSynthetics, modifiers);\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to exclude all fields from consideration for serialization or deserialization\n+   * that do not have the {@link com.google.gson.annotations.Expose} annotation.\n+   *\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder excludeFieldsWithoutExposeAnnotation() {\n+    excludeFieldsWithoutExposeAnnotation = true;\n+    return this;\n+  }\n+\n+  /**\n+   * Configure Gson to serialize null fields. By default, Gson omits all fields that are null\n+   * during serialization.\n+   *\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.2\n+   */\n+  public GsonBuilder serializeNulls() {\n+    this.serializeNulls = true;\n+    return this;\n+  }\n+  /**\n+   * Configures Gson to apply a specific naming policy to an object's field during serialization\n+   * and deserialization.\n+   *\n+   * @param namingConvention the JSON field naming convention to use for serialization and\n+   * deserialization.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\n+    return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy());\n+  }\n+\n+  /**\n+   * Configures Gson to apply a specific naming policy strategy to an object's field during\n+   * serialization and deserialization.\n+   *\n+   * @param fieldNamingPolicy the actual naming strategy to apply to the fields\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  private GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingPolicy) {\n+    this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingPolicy);\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to output Json that fits in a page for pretty printing. This option only\n+   * affects Json serialization.\n+   *\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder setPrettyPrinting() {\n+    setFormatter(new JsonPrintFormatter());\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson with a new formatting strategy other than the default strategy. The default\n+   * strategy is to provide a compact representation that eliminates all unneeded white-space.\n+   *\n+   * @param formatter the new formatter to use.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @see JsonPrintFormatter\n+   */\n+  GsonBuilder setFormatter(JsonFormatter formatter) {\n+    this.formatter = formatter;\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can\n+   * call this method or {@link #setDateFormat(int)} multiple times, but only the last invocation\n+   * will be used to decide the serialization format.\n+   *\n+   * <p>Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}\n+   * class. See the documentation in {@link java.text.SimpleDateFormat} for more information on\n+   * valid date and time patterns.</p>\n+   *\n+   * @param pattern the pattern that dates will be serialized/deserialized to/from\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.2\n+   */\n+  public GsonBuilder setDateFormat(String pattern) {\n+    // TODO(Joel): Make this fail fast if it is an invalid date format\n+    this.datePattern = pattern;\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to to serialize {@code Date} objects according to the style value provided.\n+   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n+   * invocation will be used to decide the serialization format.\n+   *\n+   * <p>Note that this style value should be one of the predefined constants in the\n+   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\n+   * information on the valid style constants.</p>\n+   *\n+   * @param style the predefined date style that date objects will be serialized/deserialized\n+   * to/from\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @since 1.2\n+   */\n+  public GsonBuilder setDateFormat(int style) {\n+    this.dateStyle = style;\n+    this.datePattern = null;\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson for custom serialization or deserialization. This method combines the\n+   * registration of an {@link InstanceCreator}, {@link JsonSerializer}, and a\n+   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\n+   * all the required interfaces for custom serialization with Gson. If an instance creator,\n+   * serializer or deserializer was previously registered for the specified {@code type}, it is\n+   * overwritten.\n+   *\n+   * @param type the type definition for the type adapter being registered\n+   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n+   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n+    Preconditions.checkArgument(typeAdapter instanceof JsonSerializer\n+        || typeAdapter instanceof JsonDeserializer || typeAdapter instanceof InstanceCreator);\n+    if (typeAdapter instanceof InstanceCreator) {\n+      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n+    }\n+    if (typeAdapter instanceof JsonSerializer) {\n+      registerSerializer(type, (JsonSerializer<?>) typeAdapter);\n+    }\n+    if (typeAdapter instanceof JsonDeserializer) {\n+      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter);\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to use a custom {@link InstanceCreator} for the specified type. If an instance\n+   * creator was previously registered for the specified class, it is overwritten. Since this method\n+   * takes a type instead of a Class object, it can be used to register a specific handler for a\n+   * generic type corresponding to a raw type.\n+   *\n+   * @param <T> the type for which instance creator is being registered\n+   * @param typeOfT The Type definition for T\n+   * @param instanceCreator the instance creator for T\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n+      InstanceCreator<? extends T> instanceCreator) {\n+    instanceCreators.register(typeOfT, instanceCreator);\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to use a custom JSON serializer for the specified type. You should use this\n+   * method if you want to register different serializers for different generic types corresponding\n+   * to a raw type.\n+   *\n+   * @param <T> the type for which the serializer is being registered\n+   * @param typeOfT The type definition for T\n+   * @param serializer the custom serializer\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  private <T> GsonBuilder registerSerializer(Type typeOfT, final JsonSerializer<T> serializer) {\n+    serializers.register(typeOfT, new JsonSerializerExceptionWrapper<T>(serializer));\n+    return this;\n+  }\n+\n+  /**\n+   * Configures Gson to use a custom JSON deserializer for the specified type. You should use this\n+   * method if you want to register different deserializers for different generic types\n+   * corresponding to a raw type.\n+   *\n+   * @param <T> the type for which the deserializer is being registered\n+   * @param typeOfT The type definition for T\n+   * @param deserializer the custom deserializer\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   */\n+  private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> deserializer) {\n+    deserializers.register(typeOfT, new JsonDeserializerExceptionWrapper<T>(deserializer));\n+    return this;\n+  }\n+\n+  /**\n+   * Creates a {@link Gson} instance based on the current configuration. This method is free of\n+   * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n+   *\n+   * @return an instance of Gson configured with the options currently set in this builder\n+   */\n+  public Gson create() {\n+    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n+    strategies.add(innerClassExclusionStrategy);\n+    strategies.add(modifierBasedExclusionStrategy);\n+    if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n+      strategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n+    }\n+    if (excludeFieldsWithoutExposeAnnotation) {\n+      strategies.add(new ExposeAnnotationBasedExclusionStrategy());\n+    }\n+    ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n+    ObjectNavigatorFactory objectNavigatorFactory =\n+        new ObjectNavigatorFactory(exclusionStrategy, fieldNamingPolicy);\n+\n+    ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf();\n+    ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf();\n+\n+    addTypeAdaptersForDate(datePattern, dateStyle, customSerializers, customDeserializers);\n+    customSerializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_SERIALIZERS);\n+    customDeserializers.registerIfAbsent(DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n+\n+    ParameterizedTypeHandlerMap<InstanceCreator<?>> customInstanceCreators =\n+      instanceCreators.copyOf();\n+    customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS);\n+    MappedObjectConstructor objConstructor = Gson.createObjectConstructor(customInstanceCreators);\n+\n+    Gson gson = new Gson(objectNavigatorFactory, objConstructor, typeAdapter, formatter,\n+        serializeNulls, customSerializers, customDeserializers);\n+    return gson;\n+  }\n+\n+  private static void addTypeAdaptersForDate(String datePattern, int dateStyle,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n+    // NOTE: if a date pattern exists, then that style takes priority\n+    DefaultDateTypeAdapter dateTypeAdapter = null;\n+    if (datePattern != null && !\"\".equals(datePattern.trim())) {\n+      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n+    } else if (dateStyle != DateFormat.DEFAULT) {\n+      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);\n+    }\n+    if (dateTypeAdapter != null\n+        && !serializers.hasAnyHandlerFor(Date.class)\n+        && !deserializers.hasAnyHandlerFor(Date.class)) {\n+      serializers.register(Date.class, dateTypeAdapter);\n+      deserializers.register(Date.class, dateTypeAdapter);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/InnerClassExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Strategy for excluding inner classes.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class InnerClassExclusionStrategy implements ExclusionStrategy {\n+\n+  public boolean shouldSkipField(Field f) {\n+    return isAnonymousOrLocal(f.getType());\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return isAnonymousOrLocal(clazz);\n+  }\n+\n+  private boolean isAnonymousOrLocal(Class<?> clazz) {\n+    return clazz.isAnonymousClass() || clazz.isLocalClass();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/InstanceCreator.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * This interface is implemented to create instances of a class that does not define a no-args\n+ * constructor. If you can modify the class, you should instead add a private, or public\n+ * no-args constructor. However, that is not possible for library classes, such as JDK classes, or\n+ * a third-party library that you do not have source-code of. In such cases, you should define an\n+ * instance creator for the class. Implementations of this interface should be registered with\n+ * {@link GsonBuilder#registerTypeAdapter(Type, Object)} method before Gson will be able to use\n+ * them.\n+ * <p>Let us look at an example where defining an InstanceCreator might be useful. The\n+ * {@code Id} class defined below does not have a default no-args constructor.</p>\n+ *\n+ * <pre>\n+ * public class Id&lt;T&gt; {\n+ *   private final Class&lt;T&gt; clazz;\n+ *   private final long value;\n+ *   public Id(Class&lt;T&gt; clazz, long value) {\n+ *     this.clazz = clazz;\n+ *     this.value = value;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>If Gson encounters an object of type {@code Id} during deserialization, it will throw an\n+ * exception. The easiest way to solve this problem will be to add a (public or private) no-args\n+ * constructor as follows:</p>\n+ *\n+ * <pre>\n+ * private Id() {\n+ *   this(Object.class, 0L);\n+ * }\n+ * </pre>\n+ *\n+ * <p>However, let us assume that the developer does not have access to the source-code of the\n+ * {@code Id} class, or does not want to define a no-args constructor for it. The developer\n+ * can solve this problem by defining an {@code InstanceCreator} for {@code Id}:</p>\n+ *\n+ * <pre>\n+ * class IdInstanceCreator implements InstanceCreator&lt;Id&gt; {\n+ *   public Id createInstance(Type type) {\n+ *     return new Id(Object.class, 0L);\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>Note that it does not matter what the fields of the created instance contain since Gson will\n+ * overwrite them with the deserialized values specified in Json. You should also ensure that a\n+ * <i>new</i> object is returned, not a common object since its fields will be overwritten.\n+ * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>\n+ *\n+ * <pre>\n+ * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();\n+ * </pre>\n+ *\n+ * @param <T> the type of object that will be created by this implementation.\n+ *\n+ * @author Joel Leitch\n+ */\n+public interface InstanceCreator<T> {\n+\n+  /**\n+   * Gson invokes this call-back method during deserialization to create an instance of the\n+   * specified type. The fields of the returned instance are overwritten with the data present\n+   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not\n+   * return an instance that is useful elsewhere. In particular, do not return a common instance,\n+   * always use {@code new} to create a new instance.\n+   *\n+   * @param type the parameterized T represented as a {@link Type}.\n+   * @return a default object instance of type T.\n+   */\n+  public T createInstance(Type type);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JavaFieldNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A simple implementation of the {@link FieldNamingStrategy} interface such that it does not\n+ * perform any string translation of the incoming field name.\n+ *\n+ * <p>The following is an example:</p>\n+ *\n+ * <pre>\n+ * class IntWrapper {\n+ *   public int integerField = 0;\n+ * }\n+ *\n+ * JavaFieldNamingPolicy policy = new JavaFieldNamingPolicy();\n+ * String translatedFieldName =\n+ *     policy.translateName(IntWrapper.class.getField(\"integerField\"));\n+ *\n+ * assert(\"integerField\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * <p>This is the default {@link FieldNamingStrategy} used by Gson.</p>\n+ *\n+ * @author Joel Leitch\n+ */\n+class JavaFieldNamingPolicy extends RecursiveFieldNamingPolicy {\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+    return target;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * A class representing an array type in Json. An array is a list of {@link JsonElement}s each of\n+ * which can be of a different type. This is an ordered list, meaning that the order in which\n+ * elements are added is preserved.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public final class JsonArray extends JsonElement implements Iterable<JsonElement> {\n+  private final List<JsonElement> elements;\n+\n+  /**\n+   * Creates an empty JsonArray.\n+   */\n+  public JsonArray() {\n+    elements = new LinkedList<JsonElement>();\n+  }\n+\n+  /**\n+   * Adds the specified element to self.\n+   *\n+   * @param element the element that needs to be added to the array.\n+   */\n+  public void add(JsonElement element) {\n+    elements.add(element);\n+  }\n+\n+  /**\n+   * Adds all the elements of the specified array to self.\n+   *\n+   * @param array the array whose elements need to be added to the array.\n+   */\n+  public void addAll(JsonArray array) {\n+    elements.addAll(array.elements);\n+  }\n+\n+  /**\n+   * Reverses the elements of the array.\n+   */\n+  void reverse() {\n+    Collections.reverse(elements);\n+  }\n+\n+  /**\n+   * Returns the number of elements in the array.\n+   *\n+   * @return the number of elements in the array.\n+   */\n+  public int size() {\n+    return elements.size();\n+  }\n+\n+  /**\n+   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,\n+   * the iterator navigates the elements in the order they were inserted.\n+   *\n+   * @return an iterator to navigate the elements of the array.\n+   */\n+  public Iterator<JsonElement> iterator() {\n+    return elements.iterator();\n+  }\n+\n+  /**\n+   * Returns the ith element of the array.\n+   *\n+   * @param i the index of the element that is being sought.\n+   * @return the element present at the ith index.\n+   * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the\n+   * {@link #size()} of the array.\n+   */\n+  public JsonElement get(int i) {\n+    return elements.get(i);\n+  }\n+\n+  /**\n+   * convenience method to get this array as a {@link Number} if it contains a single element.\n+   *\n+   * @return get this element as a number if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid Number.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public Number getAsNumber() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsNumber();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a {@link String} if it contains a single element.\n+   *\n+   * @return get this element as a String if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid String.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public String getAsString() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsString();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a double if it contains a single element.\n+   *\n+   * @return get this element as a double if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid double.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public double getAsDouble() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsDouble();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a {@link BigDecimal} if it contains a single element.\n+   *\n+   * @return get this element as a {@link BigDecimal} if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n+   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.\n+   * @throws IllegalStateException if the array has more than one element.\n+   * @since 1.2\n+   */\n+  @Override\n+  public BigDecimal getAsBigDecimal() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsBigDecimal();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a {@link BigInteger} if it contains a single element.\n+   *\n+   * @return get this element as a {@link BigInteger} if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n+   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.\n+   * @throws IllegalStateException if the array has more than one element.\n+   * @since 1.2\n+   */\n+  @Override\n+  public BigInteger getAsBigInteger() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsBigInteger();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a float if it contains a single element.\n+   *\n+   * @return get this element as a float if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid float.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public float getAsFloat() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsFloat();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a long if it contains a single element.\n+   *\n+   * @return get this element as a long if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid long.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public long getAsLong() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsLong();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as an integer if it contains a single element.\n+   *\n+   * @return get this element as an integer if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid integer.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public int getAsInt() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsInt();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a primitive short if it contains a single element.\n+   *\n+   * @return get this element as a primitive short if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid short.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public short getAsShort() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsShort();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as a boolean if it contains a single element.\n+   *\n+   * @return get this element as a boolean if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid boolean.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  public boolean getAsBoolean() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsBoolean();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  /**\n+   * convenience method to get this array as an Object if it contains a single element.\n+   *\n+   * @return get this element as an Object if it is single element array.\n+   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n+   * is not a valid Object.\n+   * @throws IllegalStateException if the array has more than one element.\n+   */\n+  @Override\n+  Object getAsObject() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsObject();\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  @Override\n+  protected void toString(StringBuilder sb) {\n+    sb.append('[');\n+    boolean first = true;\n+    for (JsonElement element : elements) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      element.toString(sb);\n+    }\n+    sb.append(']');\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * A visitor that populates fields of an object with data from its equivalent\n+ * JSON representation\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class JsonArrayDeserializationVisitor<T> extends JsonDeserializationVisitor<T> {\n+  private final Class<?> componentType;\n+\n+  JsonArrayDeserializationVisitor(JsonArray jsonArray, Type arrayType,\n+      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n+      TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      JsonDeserializationContext context) {\n+    super(jsonArray, arrayType, factory, objectConstructor, typeAdapter, deserializers, context);\n+    this.componentType = TypeUtils.toRawClass(arrayType);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  protected T constructTarget() {\n+\n+    TypeInfo typeInfo = new TypeInfo(targetType);\n+\n+    JsonArray jsonArray = json.getAsJsonArray();\n+    if (typeInfo.isPrimitiveOrStringAndNotAnArray()) {\n+      if (jsonArray.size() != 1) {\n+        throw new IllegalArgumentException(\n+            \"Primitives should be an array of length 1, but was: \" + jsonArray);\n+      }\n+      return (T) objectConstructor.construct(typeInfo.getWrappedClass());\n+    } else if (typeInfo.isArray()) {\n+      TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType);\n+      // We know that we are getting back an array of the required type, so\n+      // this typecasting is safe.\n+      return (T) objectConstructor.constructArray(arrayTypeInfo.getSecondLevelType(),\n+          jsonArray.size());\n+    } else { // is a collection\n+      return (T) objectConstructor.construct(typeInfo.getRawClass());\n+    }\n+  }\n+\n+  public void visitArray(Object array, Type arrayType) {\n+    JsonArray jsonArray = json.getAsJsonArray();\n+    TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType);\n+    for (int i = 0; i < jsonArray.size(); i++) {\n+      JsonElement jsonChild = jsonArray.get(i);\n+      Object child;\n+\n+      if (jsonChild == null) {\n+        child = null;\n+      } else if (jsonChild instanceof JsonObject) {\n+        child = visitChildAsObject(arrayTypeInfo.getComponentRawType(), jsonChild);\n+      } else if (jsonChild instanceof JsonArray) {\n+        child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray());\n+      } else if (jsonChild instanceof JsonPrimitive) {\n+        child = visitChildAsPrimitive(arrayTypeInfo.getComponentRawType(),\n+            jsonChild.getAsJsonPrimitive());\n+      } else {\n+        throw new IllegalStateException();\n+      }\n+      Array.set(array, i, child);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitCollection(Collection collection, Type collectionType) {\n+    Type childType = TypeUtils.getActualTypeForFirstTypeVariable(collectionType);\n+    for (JsonElement jsonChild : json.getAsJsonArray()) {\n+      if (childType == Object.class) {\n+        throw new JsonParseException(collection +\n+            \" must not be a raw collection. Try making it genericized instead.\");\n+      }\n+      Object child = visitChild(childType, jsonChild);\n+      collection.add(child);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitPrimitiveValue(Object obj) {\n+    target = (T) typeAdapter.adaptType(json.getAsJsonArray().get(0).getAsObject(), componentType);\n+  }\n+\n+  // We should not implement any other method from Visitor interface since\n+  // all other methods should be invoked on JsonObjectDeserializationVisitor\n+  // instead.\n+\n+  public void endVisitingObject(Object node) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void startVisitingObject(Object node) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void visitCollectionField(Field f, Type typeOfF, Object obj) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {\n+    throw new UnsupportedOperationException();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonCompactFormatter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.PrintWriter;\n+\n+/**\n+ * Formats Json in a compact way eliminating all unnecessary whitespace.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class JsonCompactFormatter implements JsonFormatter {\n+\n+  private static class FormattingVisitor implements JsonElementVisitor {\n+    private final PrintWriter writer;\n+    private final boolean serializeNulls;\n+\n+    FormattingVisitor(PrintWriter writer, boolean serializeNulls) {\n+      this.writer = writer;\n+      this.serializeNulls = serializeNulls;\n+    }\n+\n+    public void visitPrimitive(JsonPrimitive primitive) {\n+      writer.append(primitive.toString());\n+    }\n+\n+    public void visitNull() {\n+      writer.append(\"null\");\n+    }\n+    \n+    public void startArray(JsonArray array) {\n+      writer.append('[');\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+      writer.append(member.toString());\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+    }\n+\n+    public void visitNullArrayMember(JsonArray parent, boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+    }\n+\n+    public void endArray(JsonArray array) {\n+      writer.append(']');\n+    }\n+\n+    public void startObject(JsonObject object) {\n+      writer.append('{');\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonPrimitive member,\n+        boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+      writer.append('\"');\n+      writer.append(memberName);\n+      writer.append(\"\\\":\");\n+      writer.append(member.toString());\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonArray member,\n+        boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+      writer.append('\"');\n+      writer.append(memberName);\n+      writer.append(\"\\\":\");\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonObject member,\n+        boolean isFirst) {\n+      if (!isFirst) {\n+        writer.append(',');\n+      }\n+      writer.append('\"');\n+      writer.append(memberName);\n+      writer.append(\"\\\":\");\n+    }\n+\n+    public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {\n+      if (serializeNulls) {\n+        visitObjectMember(parent, memberName, (JsonObject) null, isFirst);\n+      }      \n+    }\n+    \n+    public void endObject(JsonObject object) {\n+      writer.append('}');\n+    }\n+  }\n+\n+  public void format(JsonElement root, PrintWriter writer, boolean serializeNulls) {\n+    if (root == null) {\n+      return;\n+    }\n+    JsonElementVisitor visitor = \n+      new JsonEscapingVisitor(new FormattingVisitor(writer, serializeNulls));\n+    JsonTreeNavigator navigator = new JsonTreeNavigator(visitor, serializeNulls);\n+    navigator.navigate(root);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Context for deserialization that is passed to a custom deserializer during invocation of its \n+ * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)}\n+ * method. \n+ * \n+ * @author Inderjeet Singh\n+ */\n+public interface JsonDeserializationContext {\n+  \n+  /**\n+   * Invokes default deserialization on the specified object. It should never be invoked on \n+   * the element received as a parameter of the \n+   * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)} method. Doing\n+   * so will result in an infinite loop since Gson will in-turn call the custom deserializer again. \n+\n+   * @param json the parse tree.\n+   * @param typeOfT type of the expected return value.\n+   * @param <T> The type of the deserialized object.\n+   * @return An object of type typeOfT.\n+   * @throws JsonParseException if the parse tree does not contain expected data.\n+   */\n+  public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException;\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * implementation of a deserialization context for Gson\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class JsonDeserializationContextDefault implements JsonDeserializationContext {\n+\n+  private final ObjectNavigatorFactory navigatorFactory;\n+  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final MappedObjectConstructor objectConstructor;\n+  private final TypeAdapter typeAdapter;\n+\n+  JsonDeserializationContextDefault(ObjectNavigatorFactory navigatorFactory,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      MappedObjectConstructor objectConstructor, TypeAdapter typeAdapter) {\n+    this.navigatorFactory = navigatorFactory;\n+    this.deserializers = deserializers;\n+    this.objectConstructor = objectConstructor;\n+    this.typeAdapter = typeAdapter;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n+    if (json.isJsonArray()) {\n+      return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this);\n+    } else if (json.isJsonObject()) {\n+      return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this);\n+    } else if (json.isJsonPrimitive()) {\n+      return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this);\n+    } else if (json.isJsonNull()) {\n+      return null;\n+    } else {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\");\n+    }\n+  }\n+\n+  private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,\n+      JsonDeserializationContext context) throws JsonParseException {\n+    JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(\n+        jsonArray, arrayType, navigatorFactory, objectConstructor, typeAdapter, deserializers,\n+        context);\n+    Object target = visitor.getTarget();\n+    ObjectNavigator on = navigatorFactory.create(target, arrayType);\n+    on.accept(visitor);\n+    return visitor.getTarget();\n+  }\n+\n+  private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,\n+      JsonDeserializationContext context) throws JsonParseException {\n+    JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n+        jsonObject, typeOfT, navigatorFactory, objectConstructor, typeAdapter, deserializers,\n+        context);\n+    Object target = visitor.getTarget();\n+    ObjectNavigator on = navigatorFactory.create(target, typeOfT);\n+    on.accept(visitor);\n+    return visitor.getTarget();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,\n+      JsonDeserializationContext context) throws JsonParseException {\n+    JsonPrimitiveDeserializationVisitor<T> visitor = new JsonPrimitiveDeserializationVisitor<T>(\n+        json, typeOfT, navigatorFactory, objectConstructor, typeAdapter, deserializers, context);\n+    Object target = visitor.getTarget();\n+    ObjectNavigator on = navigatorFactory.create(target, typeOfT);\n+    on.accept(visitor);\n+    target = visitor.getTarget();\n+    if (typeOfT instanceof Class) {\n+      target = typeAdapter.adaptType(target, (Class) typeOfT);\n+    }\n+    return (T) target;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Abstract data value container for the {@link ObjectNavigator.Visitor}\n+ * implementations.  This class exposes the {@link #getTarget()} method\n+ * which returns the class that was visited by this object.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+abstract class JsonDeserializationVisitor<T> implements ObjectNavigator.Visitor {\n+\n+  protected static Logger logger = Logger.getLogger(JsonDeserializationVisitor.class.getName());\n+\n+  protected final ObjectNavigatorFactory factory;\n+  protected final ObjectConstructor objectConstructor;\n+  protected final TypeAdapter typeAdapter;\n+  protected final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  protected T target;\n+  protected final JsonElement json;\n+  protected final Type targetType;\n+  private final JsonDeserializationContext context;\n+\n+  public JsonDeserializationVisitor(JsonElement json, Type targetType,\n+      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, TypeAdapter typeAdapter,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      JsonDeserializationContext context) {\n+    Preconditions.checkNotNull(json);\n+    this.targetType = targetType;\n+    this.factory = factory;\n+    this.objectConstructor = objectConstructor;\n+    this.typeAdapter = typeAdapter;\n+    this.deserializers = deserializers;\n+    this.json = json;\n+    this.context = context;\n+  }\n+\n+  T getTarget() {\n+    if (target == null) {\n+      target = constructTarget();\n+    }\n+    return target;\n+  }\n+\n+  protected abstract T constructTarget();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public final void visitEnum(Object obj, Type objType) {\n+    JsonDeserializer<T> deserializer = (JsonDeserializer<T>) deserializers.getHandlerFor(objType);\n+    if (deserializer == null) {\n+      deserializer =  (JsonDeserializer<T>) deserializers.getHandlerFor(Enum.class);\n+    }\n+    if (deserializer == null) {\n+      throw new RuntimeException(\"Register a JsonDeserializer for Enum or \"\n+          + obj.getClass().getName());\n+    }\n+    target = deserializer.deserialize(json, objType, context);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public final boolean visitUsingCustomHandler(Object obj, Type objType) {\n+    JsonDeserializer<T> deserializer = (JsonDeserializer<T>) deserializers.getHandlerFor(objType);\n+    if (deserializer != null) {\n+      target = deserializer.deserialize(json, objType, context);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  final Object visitChildAsObject(Type childType, JsonElement jsonChild) {\n+    JsonDeserializationVisitor<?> childVisitor =\n+      new JsonObjectDeserializationVisitor<Object>(jsonChild, childType,\n+          factory, objectConstructor, typeAdapter, deserializers, context);\n+    return visitChild(childType, childVisitor);\n+  }\n+\n+  final Object visitChildAsArray(Type childType, JsonArray jsonChild) {\n+    JsonDeserializationVisitor<?> childVisitor =\n+      new JsonArrayDeserializationVisitor<Object>(jsonChild.getAsJsonArray(), childType,\n+          factory, objectConstructor, typeAdapter, deserializers, context);\n+    return visitChild(childType, childVisitor);\n+  }\n+\n+  final Object visitChildAsPrimitive(Type childType, JsonPrimitive jsonChild) {\n+    Preconditions.checkNotNull(jsonChild);\n+    Class<?> childClass;\n+    if (childType instanceof Class) {\n+      childClass = (Class<?>) childType;\n+    } else {\n+      childClass = TypeUtils.toRawClass(childType);\n+    }\n+    return typeAdapter.adaptType(jsonChild.getAsObject(), childClass);\n+  }\n+\n+  final Object visitChild(Type childType, JsonElement jsonChild) {\n+    if (jsonChild == null) {\n+      return null;\n+    } else if (jsonChild instanceof JsonArray) {\n+      return visitChildAsArray(childType, jsonChild.getAsJsonArray());\n+    } else if (jsonChild instanceof JsonObject) {\n+      return visitChildAsObject(childType, jsonChild);\n+    } else if (jsonChild instanceof JsonPrimitive) {\n+      return visitChildAsPrimitive(childType, jsonChild.getAsJsonPrimitive());\n+    } else {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) {\n+    Object child = childVisitor.getTarget();\n+    ObjectNavigator on = factory.create(child, type);\n+    on.accept(childVisitor);\n+    // the underlying object may have changed during the construction phase\n+    // This happens primarily because of custom deserializers\n+    return childVisitor.getTarget();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializer.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * <p>Interface representing a custom deserializer for Json. You should write a custom\n+ * deserializer, if you are not happy with the default deserialization done by Gson. You will\n+ * also need to register this deserializer through\n+ * {@link GsonBuilder#registerTypeAdapter(Type, Object)}.</p>\n+ *\n+ * <p>Let us look at example where defining a deserializer will be useful. The {@code Id} class\n+ * defined below has two fields: {@code clazz} and {@code value}.</p>\n+ *\n+ * <pre>\n+ * public class Id&lt;T&gt; {\n+ *   private final Class&lt;T&gt; clazz;\n+ *   private final long value;\n+ *   public Id(Class&lt;T&gt; clazz, long value) {\n+ *     this.clazz = clazz;\n+ *     this.value = value;\n+ *   }\n+ *   public long getValue() {\n+ *     return value;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>The default deserialization of {@code Id(com.foo.MyObject.class, 20L)} will require the\n+ * Json string to be <code>{\"clazz\":com.foo.MyObject,\"value\":20}</code>. Suppose, you already know\n+ * the type of the field that the {@code Id} will be deserialized into, and hence just want to\n+ * deserialize it from a Json string {@code 20}. You can achieve that by writing a custom\n+ * deserializer:</p>\n+ *\n+ * <pre>\n+ * class IdDeserializer implements JsonDeserializer&lt;Id&gt;() {\n+ *   public Id fromJson(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+ *       throws JsonParseException {\n+ *     return (Id) new Id((Class)typeOfT, id.getValue());\n+ *   }\n+ * </pre>\n+ *\n+ * <p>You will also need to register {@code IdDeserializer} with Gson as follows:</p>\n+ *\n+ * <pre>\n+ * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <T> type for which the deserializer is being registered. It is possible that a\n+ * deserializer may be asked to deserialize a specific generic type of the T.\n+ */\n+public interface JsonDeserializer<T> {\n+\n+  /**\n+   * Gson invokes this call-back method during deserialization when it encounters a field of the\n+   * specified type.\n+   * <p>In the implementation of this call-back method, you should consider invoking\n+   * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects\n+   * for any non-trivial field of the returned object. However, you should never invoke it on the\n+   * the same type passing {@code json} since that will cause an infinite loop (Gson will call your\n+   * call-back method again).\n+   *\n+   * @param json The Json data being deserialized\n+   * @param typeOfT The type of the Object to deserialize to\n+   * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}\n+   * @throws JsonParseException if json is not in the expected format of {@code typeofT}\n+   */\n+  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+      throws JsonParseException;\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Decorators a {@code JsonDeserializer} instance with exception handling.  This wrapper class\n+ * ensures that a {@code JsonDeserializer} will not propagate any exception other than a\n+ * {@link JsonParseException}.\n+ *\n+ * @param <T> type of the deserializer being wrapped.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class JsonDeserializerExceptionWrapper<T> implements JsonDeserializer<T> {\n+\n+  private final JsonDeserializer<T> delegate;\n+\n+  /**\n+   * Returns a wrapped {@link JsonDeserializer} object that has been decorated with\n+   * {@link JsonParseException} handling.\n+   *\n+   * @param delegate the {@code JsonDeserializer} instance to be wrapped.\n+   * @throws IllegalArgumentException if {@code delegate} is {@code null}.\n+   */\n+  JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\n+    Preconditions.checkNotNull(delegate);\n+    this.delegate = delegate;\n+  }\n+\n+  public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+      throws JsonParseException {\n+    try {\n+      return delegate.deserialize(json, typeOfT, context);\n+    } catch (JsonParseException e) {\n+      // just rethrow the exception\n+      throw e;\n+    } catch (Exception e) {\n+      // rethrow as a JsonParseException\n+      StringBuilder errorMsg = new StringBuilder()\n+          .append(\"The JsonDeserializer \")\n+          .append(delegate)\n+          .append(\" failed to deserialized json object \")\n+          .append(json)\n+          .append(\" given the type \")\n+          .append(typeOfT);\n+      throw new JsonParseException(errorMsg.toString(), e);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * A class representing an element of Json. It could either be a {@link JsonObject}, a\n+ * {@link JsonArray}, a {@link JsonPrimitive} or a {@link JsonNull}.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public abstract class JsonElement {\n+\n+  /**\n+   * provides check for verifying if this element is an array or not.\n+   *\n+   * @return true if this element is of type {@link JsonArray}, false otherwise.\n+   */\n+  public boolean isJsonArray() {\n+    return this instanceof JsonArray;\n+  }\n+\n+  /**\n+   * provides check for verifying if this element is a Json object or not.\n+   *\n+   * @return true if this element is of type {@link JsonObject}, false otherwise.\n+   */\n+  public boolean isJsonObject() {\n+    return this instanceof JsonObject;\n+  }\n+\n+  /**\n+   * provides check for verifying if this element is a primitive or not.\n+   *\n+   * @return true if this element is of type {@link JsonPrimitive}, false otherwise.\n+   */\n+  public boolean isJsonPrimitive() {\n+    return this instanceof JsonPrimitive;\n+  }\n+\n+  /**\n+   * provides check for verifying if this element represents a null value or not.\n+   *\n+   * @return true if this element is of type {@link JsonNull}, false otherwise.\n+   * @since 1.2\n+   */\n+  public boolean isJsonNull() {\n+    return this instanceof JsonNull;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link JsonObject}. If the element is of some\n+   * other type, a {@link ClassCastException} will result. Hence it is best to use this method\n+   * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}\n+   * first.\n+   *\n+   * @return get this element as a {@link JsonObject}.\n+   * @throws ClassCastException if the element is of another type.\n+   */\n+  public JsonObject getAsJsonObject() {\n+    return (JsonObject) this;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link JsonArray}. If the element is of some\n+   * other type, a {@link ClassCastException} will result. Hence it is best to use this method\n+   * after ensuring that this element is of the desired type by calling {@link #isJsonArray()}\n+   * first.\n+   *\n+   * @return get this element as a {@link JsonArray}.\n+   * @throws ClassCastException if the element is of another type.\n+   */\n+  public JsonArray getAsJsonArray() {\n+    return (JsonArray) this;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link JsonPrimitive}. If the element is of some\n+   * other type, a {@link ClassCastException} will result. Hence it is best to use this method\n+   * after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}\n+   * first.\n+   *\n+   * @return get this element as a {@link JsonPrimitive}.\n+   * @throws ClassCastException if the element is of another type.\n+   */\n+  public JsonPrimitive getAsJsonPrimitive() {\n+    return (JsonPrimitive) this;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link JsonNull}. If the element is of some\n+   * other type, a {@link ClassCastException} will result. Hence it is best to use this method\n+   * after ensuring that this element is of the desired type by calling {@link #isJsonNull()}\n+   * first.\n+   *\n+   * @return get this element as a {@link JsonNull}.\n+   * @throws ClassCastException if the element is of another type.\n+   * @since 1.2\n+   */\n+  public JsonNull getAsJsonNull() {\n+    return (JsonNull) this;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a boolean value.\n+   *\n+   * @return get this element as a primitive boolean value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * boolean value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public boolean getAsBoolean() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link Boolean} value.\n+   *\n+   * @return get this element as a {@link Boolean} value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * boolean value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  Boolean getAsBooleanWrapper() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link Number}.\n+   *\n+   * @return get this element as a {@link Number}.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * number.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public Number getAsNumber() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a string value.\n+   *\n+   * @return get this element as a string value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * string value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public String getAsString() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive double value.\n+   *\n+   * @return get this element as a primitive double value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * double value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public double getAsDouble() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive float value.\n+   *\n+   * @return get this element as a primitive float value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * float value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public float getAsFloat() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive long value.\n+   *\n+   * @return get this element as a primitive long value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * long value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public long getAsLong() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive integer value.\n+   *\n+   * @return get this element as a primitive integer value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * integer value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public int getAsInt() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link BigDecimal}.\n+   *\n+   * @return get this element as a {@link BigDecimal}.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.\n+   * * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   * @since 1.2\n+   */\n+  public BigDecimal getAsBigDecimal() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link BigInteger}.\n+   *\n+   * @return get this element as a {@link BigInteger}.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.\n+   * @throws NumberFormatException if the element is not a valid {@link BigInteger}.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   * @since 1.2\n+   */\n+  public BigInteger getAsBigInteger() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive short value.\n+   *\n+   * @return get this element as a primitive short value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * short value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public short getAsShort() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * convenience method to get this element as an {@link Object} value.\n+   *\n+   * @return get this element as an Object value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * Object value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  Object getAsObject() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Returns a String representation of this element.\n+   *\n+   * @return String the string representation of this element. The output is valid Json.\n+   */\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    toString(sb);\n+    return sb.toString();\n+  }\n+\n+  protected abstract void toString(StringBuilder sb);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonElementVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Definition of a visitor for a JsonElement tree.\n+ * \n+ * @author Inderjeet Singh\n+ */\n+interface JsonElementVisitor {\n+  void visitPrimitive(JsonPrimitive primitive);\n+  void visitNull();\n+\n+  void startArray(JsonArray array);\n+  void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst);\n+  void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst);\n+  void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst);\n+  void visitNullArrayMember(JsonArray parent, boolean isFirst);\n+  void endArray(JsonArray array);\n+  \n+  void startObject(JsonObject object);\n+  void visitObjectMember(JsonObject parent, String memberName, JsonPrimitive member, \n+      boolean isFirst);\n+  void visitObjectMember(JsonObject parent, String memberName, JsonArray member, boolean isFirst);\n+  void visitObjectMember(JsonObject parent, String memberName, JsonObject member, boolean isFirst);\n+  void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst);\n+  void endObject(JsonObject object);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonEscapingVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Performs JSON escaping and passes on the new escaped value to the delegate\n+ * {@link JsonElementVisitor}.\n+ *\n+ * @author Joel Leitch\n+ */\n+class JsonEscapingVisitor extends DelegatingJsonElementVisitor {\n+\n+  /**\n+   * Constructs a Visitor that will properly escape any JSON primitive values.\n+   *\n+   * @param delegate the JsonElementVisitor that this instance will use for delegation\n+   */\n+  protected JsonEscapingVisitor(JsonElementVisitor delegate) {\n+    super(delegate);\n+  }\n+\n+  @Override\n+  public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {\n+    super.visitArrayMember(parent, escapeJsonPrimitive(member), isFirst);\n+  }\n+\n+  @Override\n+  public void visitObjectMember(\n+      JsonObject parent, String memberName, JsonPrimitive member, boolean isFirst) {\n+    super.visitObjectMember(parent, memberName, escapeJsonPrimitive(member), isFirst);\n+  }\n+\n+  @Override\n+  public void visitPrimitive(JsonPrimitive primitive) {\n+    super.visitPrimitive(escapeJsonPrimitive(primitive));\n+  }\n+\n+  private JsonPrimitive escapeJsonPrimitive(JsonPrimitive member) {\n+    if (member.isString()) {\n+      String memberValue = member.getAsString();\n+      String escapedValue = Escaper.escapeJsonString(memberValue);\n+      if (!escapedValue.equals(memberValue)) {\n+        member.setValue(escapedValue);\n+      }\n+    }\n+    return member;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * This class can be used to check the validity of a JSON field name.\n+ *\n+ * <p>The primary use of this object is to ensure that any Java fields that use the\n+ * {@link com.google.gson.annotations.SerializedName} annotation is providing valid JSON\n+ * field names.  This will make the code fail-fast rather than letting the invalid\n+ * field name propagate to the client and it fails to parse.</p>\n+ *\n+ * @author Joel Leitch\n+ */\n+class JsonFieldNameValidator {\n+  private static final String[] JS_KEYWORDS = {\n+    \"break\", \"case\", \"catch\", \"class\", \"comment\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\", \"do\",\n+    \"else\", \"enum\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"label\", \"new\",\n+    \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\", \"with\"\n+  };\n+\n+  private static final Pattern JSON_FIELD_NAME_PATTERN =\n+      Pattern.compile(\"(^[a-zA-Z][a-zA-Z0-9\\\\$_]*$)|(^[\\\\$_][a-zA-Z][a-zA-Z0-9\\\\$_]*$)\");\n+\n+  private static final Set<String> KEYWORDS = Collections.unmodifiableSet(\n+      new HashSet<String>(Arrays.asList(JS_KEYWORDS)));\n+\n+  /**\n+   * Performs validation on the JSON field name to ensure it is a valid field name.\n+   *\n+   * @param fieldName the name of the field to validate\n+   * @return {@code fieldName} if it is a valid JSON field name\n+   * @throws IllegalArgumentException if the field name is an invalid JSON field name\n+   */\n+  public String validate(String fieldName) {\n+    Preconditions.checkNotNull(fieldName);\n+    Preconditions.checkArgument(!\"\".equals(fieldName.trim()));\n+    Preconditions.checkArgument(!KEYWORDS.contains(fieldName));\n+\n+    Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName);\n+    if (!matcher.matches()) {\n+      throw new IllegalArgumentException(fieldName + \" is not a valid JSON field name.\");\n+    } else {\n+      return fieldName;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonFormatter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.PrintWriter;\n+\n+/**\n+ * Common interface for a formatter for Json. \n+ * \n+ * @author Inderjeet Singh\n+ */\n+interface JsonFormatter {\n+\n+  /**\n+   * Writes a formatted version of the Json corresponding to \n+   * the specified Json.  \n+   * \n+   * @param root the root of the Json tree. \n+   * @param writer the writer to output the formatter JSON to.\n+   * @param serializeNulls serialize null values in the output.\n+   */\n+  public void format(JsonElement root, PrintWriter writer, boolean serializeNulls);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonNull.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A class representing a Json null value.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @since 1.2\n+ */\n+public final class JsonNull extends JsonElement {\n+\n+  @Override\n+  protected void toString(StringBuilder sb) {\n+    sb.append(\"null\");\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+/**\n+ * A class representing an object type in Json. An object consists of name-value pairs where names \n+ * are strings, and values are any other type of {@link JsonElement}. This allows for a creating a \n+ * tree of JsonElements. The member elements of this object are maintained in order they were added. \n+ * \n+ * @author Inderjeet Singh\n+ */\n+public final class JsonObject extends JsonElement {\n+  // We are using a linked hash map because it is important to preserve\n+  // the order in which elements are inserted. This is needed to ensure\n+  // that the fields of an object are inserted in the order they were \n+  // defined in the class. \n+  private final Map<String, JsonElement> members;\n+\n+  /**\n+   * Creates an empty JsonObject.\n+   */\n+  public JsonObject() {\n+    members = new LinkedHashMap<String, JsonElement>();\n+  }\n+  \n+  /**\n+   * Adds a member, which is a name-value pair, to self. The name must be a String, but the value\n+   * can be an arbitrary JsonElement, thereby allowing you to build a full tree of JsonElements\n+   * rooted at this node. \n+   *   \n+   * @param property name of the member.\n+   * @param value the member object.\n+   */\n+  public void add(String property, JsonElement value) {\n+    members.put(property, value);\n+  }\n+  \n+  /**\n+   * Convenience method to add a primitive member. The specified value is converted to a \n+   * JsonPrimitive of String. \n+   *  \n+   * @param property name of the member.\n+   * @param value the string value associated with the member.\n+   */\n+  public void addProperty(String property, String value) {\n+    members.put(property, new JsonPrimitive(value));\n+  }\n+  \n+  /**\n+   * Convenience method to add a primitive member. The specified value is converted to a \n+   * JsonPrimitive of Number. \n+   *  \n+   * @param property name of the member.\n+   * @param value the number value associated with the member.\n+   */\n+  public void addProperty(String property, Number value) {\n+    members.put(property, new JsonPrimitive(value));\n+  }\n+\n+  /**\n+   * Returns a set of members of this object. The set is ordered, and the order is in which the \n+   * elements were added. \n+   *  \n+   * @return a set of members of this object. \n+   */\n+  public Set<Entry<String, JsonElement>> entrySet() {\n+    return members.entrySet();\n+  }\n+  \n+  /**\n+   * Convenience method to check if a member with the specified name is present in this object. \n+   * \n+   * @param memberName name of the member that is being checked for presence.\n+   * @return true if there is a member with the specified name, false otherwise. \n+   */\n+  public boolean has(String memberName) {\n+    return members.containsKey(memberName);\n+  }\n+  \n+  /**\n+   * Returns the member with the specified name. \n+   * \n+   * @param memberName name of the member that is being requested.\n+   * @return the member matching the name. Null if no such member exists. \n+   */\n+  public JsonElement get(String memberName) {\n+    return members.get(memberName);\n+  }\n+  \n+  /**\n+   * Convenience method to get the specified member as a JsonPrimitive element. \n+   * \n+   * @param memberName name of the member being requested. \n+   * @return the JsonPrimitive corresponding to the specified member. \n+   */\n+  public JsonPrimitive getAsJsonPrimitive(String memberName) {\n+    return (JsonPrimitive) members.get(memberName);\n+  }\n+  \n+  /**\n+   * Convenience method to get the specified member as a JsonArray.\n+   * \n+   * @param memberName name of the member being requested. \n+   * @return the JsonArray corresponding to the specified member.\n+   */\n+  public JsonArray getAsJsonArray(String memberName) {\n+    return (JsonArray) members.get(memberName);\n+  }\n+\n+  /**\n+   * Convenience method to get the specified member as a JsonObject.\n+   * \n+   * @param memberName name of the member being requested. \n+   * @return the JsonObject corresponding to the specified member.\n+   */\n+  public JsonObject getAsJsonObject(String memberName) {\n+    return (JsonObject) members.get(memberName);\n+  }\n+\n+  @Override\n+  protected void toString(StringBuilder sb) {\n+    sb.append('{');\n+    boolean first = true;\n+    for (Map.Entry<String, JsonElement> entry : members.entrySet()) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        sb.append(',');\n+      }\n+      sb.append('\\\"');\n+      sb.append(entry.getKey());\n+      sb.append(\"\\\":\");\n+      entry.getValue().toString(sb);\n+    }\n+    sb.append('}');\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * A visitor that populates fields of an object with data from its equivalent\n+ * JSON representation\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class JsonObjectDeserializationVisitor<T> extends JsonDeserializationVisitor<T> {\n+\n+  JsonObjectDeserializationVisitor(JsonElement json, Type type,\n+      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n+      TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      JsonDeserializationContext context) {\n+    super(json, type, factory, objectConstructor, typeAdapter, deserializers, context);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  protected T constructTarget() {\n+    return (T) objectConstructor.construct(targetType);\n+  }\n+\n+  public void startVisitingObject(Object node) {\n+    // do nothing\n+  }\n+\n+  public void endVisitingObject(Object node) {\n+    // do nothing\n+  }\n+\n+  public void visitCollection(@SuppressWarnings(\"unchecked\")Collection collection,\n+      Type componentType) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitArray(Object array, Type componentType) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitPrimitiveValue(Object obj) {\n+    // should not be called since this case should invoke JsonPrimitiveDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+    try {\n+      JsonObject jsonObject = json.getAsJsonObject();\n+      String fName = getFieldName(f);\n+      JsonElement jsonChild = jsonObject.get(fName);\n+      if (jsonChild != null) {\n+        Object child = visitChildAsObject(typeOfF, jsonChild);\n+        f.set(obj, child);\n+      } else {\n+        f.set(obj, null);\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitCollectionField(Field f, Type typeOfF, Object obj) {\n+    try {\n+      JsonObject jsonObject = json.getAsJsonObject();\n+      String fName = getFieldName(f);\n+      JsonArray jsonArray = (JsonArray) jsonObject.get(fName);\n+      if (jsonArray != null) {\n+        Collection collection = (Collection) objectConstructor.construct(typeOfF);\n+        f.set(obj, collection);\n+        Type childType = TypeUtils.getActualTypeForFirstTypeVariable(typeOfF);\n+        for (JsonElement jsonChild : jsonArray) {\n+          Object child = visitChild(childType, jsonChild);\n+          if (childType == Object.class) {\n+            throw new JsonParseException(fName +\n+                \" can not be a raw collection. Try making it a genericized collection instead\");\n+          }\n+          collection.add(child);\n+        }\n+      } else {\n+        f.set(obj, null);\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+    try {\n+      JsonObject jsonObject = json.getAsJsonObject();\n+      String fName = getFieldName(f);\n+      JsonArray jsonChild = (JsonArray) jsonObject.get(fName);\n+      if (jsonChild != null) {\n+        Object array = visitChildAsArray(typeOfF, jsonChild);\n+        f.set(obj, array);\n+      } else {\n+        f.set(obj, null);\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {\n+    try {\n+      JsonObject jsonObject = json.getAsJsonObject();\n+      String fName = getFieldName(f);\n+      JsonPrimitive value = jsonObject.getAsJsonPrimitive(fName);\n+      if (value != null) {\n+        f.set(obj, typeAdapter.adaptType(value.getAsObject(), TypeUtils.toRawClass(typeOfF)));\n+      } else {\n+        // For Strings, we need to set the field to null\n+        // For other primitive types, any value created during default construction is fine\n+        if (f.getType() == String.class) {\n+          f.set(obj, null);\n+        }\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private String getFieldName(Field f) {\n+    FieldNamingStrategy namingPolicy = factory.getFieldNamingPolicy();\n+    return namingPolicy.translateName(f);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParseException.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * This exception is raised if there is a serious issue that occurs during parsing of a Json\n+ * string.  One of the main usages for this class is for the Gson infrastructure.  If the incoming\n+ * Json is bad/malicious, an instance of this exception is raised.\n+ *\n+ * <p>This exception is a {@link RuntimeException} because it is exposed to the client.  Using a\n+ * {@link RuntimeException} avoids bad coding practices on the client side where they catch the\n+ * exception and do nothing.  It is often the case that you want to blow up if there is a parsing\n+ * error (i.e. often clients do not know how to recover from a {@link JsonParseException}.</p>\n+ *\n+ * @author Joel Leitch\n+ */\n+public final class JsonParseException extends RuntimeException {\n+  static final long serialVersionUID = -4086729973971783390L;\n+\n+  /**\n+   * Creates exception with the specified message. If you are wrapping another exception, consider\n+   * using {@link #JsonParseException(String, Throwable)} instead.\n+   *\n+   * @param msg error message describing a possible cause of this exception.\n+   */\n+  public JsonParseException(String msg) {\n+    super(msg);\n+  }\n+\n+  /**\n+   * Creates exception with the specified message and cause.\n+   *\n+   * @param msg error message describing what happened.\n+   * @param cause root exception that caused this exception to be thrown.\n+   */\n+  public JsonParseException(String msg, Throwable cause) {\n+    super(msg, cause);\n+  }\n+\n+  /**\n+   * Creates exception with the specified cause. Consider using\n+   * {@link #JsonParseException(String, Throwable)} instead if you can describe what happened.\n+   *\n+   * @param cause root exception that caused this exception to be thrown.\n+   */\n+  public JsonParseException(Throwable cause) {\n+    super(cause);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParser.java */\n+package com.google.gson;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+\n+@SuppressWarnings(\"all\")\n+final class JsonParser implements JsonParserConstants {\n+\n+  final public JsonElement parse() throws ParseException {\n+  JsonElement json = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 15:\n+      json = JsonObject();\n+      break;\n+    case 20:\n+      json = JsonArray();\n+      break;\n+    case DIGITS:\n+    case QUOTE:\n+    case 22:\n+    case 23:\n+    case 24:\n+      json = JsonPrimitive();\n+      break;\n+    case 17:\n+      json = JsonNull();\n+      break;\n+    default:\n+      jj_la1[0] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return json;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonObject JsonObject() throws ParseException {\n+  JsonObject o = new JsonObject();\n+    jj_consume_token(15);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case QUOTE:\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[1] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(16);\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonNull JsonNull() throws ParseException {\n+  JsonNull json = new JsonNull();\n+    jj_consume_token(17);\n+    {if (true) return json;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Members(JsonObject o) throws ParseException {\n+    Pair(o);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 18:\n+      jj_consume_token(18);\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[2] = jj_gen;\n+      ;\n+    }\n+  }\n+\n+  final private void Pair(JsonObject o) throws ParseException {\n+  JsonPrimitive property;\n+  JsonElement value;\n+    property = JsonString();\n+    jj_consume_token(19);\n+    value = JsonValue();\n+    o.add(property.getAsString(), value);\n+  }\n+\n+  final private JsonArray JsonArray() throws ParseException {\n+  JsonArray array = new JsonArray();\n+    jj_consume_token(20);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case DIGITS:\n+    case QUOTE:\n+    case 15:\n+    case 17:\n+    case 20:\n+    case 22:\n+    case 23:\n+    case 24:\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[3] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(21);\n+    array.reverse();\n+    {if (true) return array;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Elements(JsonArray array) throws ParseException {\n+  JsonElement element;\n+    element = JsonValue();\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 18:\n+      jj_consume_token(18);\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[4] = jj_gen;\n+      ;\n+    }\n+    array.add(element);\n+  }\n+\n+  final private JsonElement JsonValue() throws ParseException {\n+  JsonElement o = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case QUOTE:\n+      o = JsonString();\n+      break;\n+    case DIGITS:\n+    case 24:\n+      o = JsonNumber();\n+      break;\n+    case 15:\n+      o = JsonObject();\n+      break;\n+    case 20:\n+      o = JsonArray();\n+      break;\n+    case 22:\n+      jj_consume_token(22);\n+             o = new JsonPrimitive(true);\n+      break;\n+    case 23:\n+      jj_consume_token(23);\n+              o = new JsonPrimitive(false);\n+      break;\n+    case 17:\n+      jj_consume_token(17);\n+      break;\n+    default:\n+      jj_la1[5] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonPrimitive() throws ParseException {\n+  JsonPrimitive value;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case QUOTE:\n+      value = JsonString();\n+                          {if (true) return value;}\n+      break;\n+    case DIGITS:\n+    case 24:\n+      value = JsonNumber();\n+                          {if (true) return value;}\n+      break;\n+    case 22:\n+      jj_consume_token(22);\n+             {if (true) return new JsonPrimitive(true);}\n+      break;\n+    case 23:\n+      jj_consume_token(23);\n+              {if (true) return new JsonPrimitive(false);}\n+      break;\n+    default:\n+      jj_la1[6] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonNumber() throws ParseException {\n+  String intpart = null,\n+         fracpart = null,\n+         exppart = null;\n+    intpart = JsonInt();\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 25:\n+      fracpart = JsonFrac();\n+      break;\n+    default:\n+      jj_la1[7] = jj_gen;\n+      ;\n+    }\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case E:\n+      exppart = JsonExp();\n+      break;\n+    default:\n+      jj_la1[8] = jj_gen;\n+      ;\n+    }\n+    Number n;\n+    if (exppart != null) {\n+      n = new BigDecimal(intpart + fracpart + exppart);\n+    } else if (fracpart != null) {\n+      n = new Double(intpart + fracpart);\n+    } else {\n+      // See if the number fits in an integer, or long\n+      // Use BigInteger only if it is big enough.\n+      if (intpart.length() < 10) {\n+        n = new Integer(intpart);\n+      } else if (intpart.length() < 19) {\n+        n = new Long(intpart);\n+      } else {\n+        n = new BigInteger(intpart);\n+      }\n+    }\n+    {if (true) return new JsonPrimitive(n);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonInt() throws ParseException {\n+  String digits;\n+  boolean negative = false;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 24:\n+      jj_consume_token(24);\n+         negative = true;\n+      break;\n+    default:\n+      jj_la1[9] = jj_gen;\n+      ;\n+    }\n+    digits = Digits();\n+    if(negative)\n+      {if (true) return \"-\" + digits;}\n+    {if (true) return digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonFrac() throws ParseException {\n+  String digits;\n+    jj_consume_token(25);\n+    digits = Digits();\n+    {if (true) return \".\" + digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonExp() throws ParseException {\n+  Token t;\n+  String digits;\n+    t = jj_consume_token(E);\n+    digits = Digits();\n+    {if (true) return t.image + digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String Digits() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(DIGITS);\n+    {if (true) return t.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonString() throws ParseException {\n+  StringBuffer strbuf = new StringBuffer();\n+    jj_consume_token(QUOTE);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case CHAR:\n+    case CNTRL_ESC:\n+    case HEX_ESC:\n+      Chars(strbuf);\n+      break;\n+    default:\n+      jj_la1[10] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(ENDQUOTE);\n+    {if (true) return new JsonPrimitive(strbuf.toString());}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Chars(StringBuffer strbuf) throws ParseException {\n+  char c;\n+    c = Char();\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case CHAR:\n+    case CNTRL_ESC:\n+    case HEX_ESC:\n+      Chars(strbuf);\n+      break;\n+    default:\n+      jj_la1[11] = jj_gen;\n+      ;\n+    }\n+    strbuf.insert(0, c);\n+  }\n+\n+  final private char Char() throws ParseException {\n+  Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case CHAR:\n+      t = jj_consume_token(CHAR);\n+      break;\n+    case CNTRL_ESC:\n+      t = jj_consume_token(CNTRL_ESC);\n+      break;\n+    case HEX_ESC:\n+      t = jj_consume_token(HEX_ESC);\n+      break;\n+    default:\n+      jj_la1[12] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    if(t.image.length() < 2) {\n+      {if (true) return t.image.charAt(0);}\n+    }\n+    if(t.image.length() < 6) {\n+      char c = t.image.charAt(1);\n+      switch(t.image.charAt(1)) {\n+        //control characters\n+        case 'b'  : {if (true) return (char) 8;} break;\n+        case 'f'  : {if (true) return (char) 12;} break;\n+        case 'n'  : {if (true) return (char) 10;} break;\n+        case 'r'  : {if (true) return (char) 13;} break;\n+        case 't'  : {if (true) return (char) 9;} break;\n+        default   : {if (true) return c;}   //characters that represent themselves\n+      }\n+    }\n+    else {      //hex escape code\n+      //create an integer from our hex values\n+      //and then cast into a char\n+      int i = Integer.valueOf(t.image.substring(2,6), 16).intValue();\n+      {if (true) return (char) i;}\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  public JsonParserTokenManager token_source;\n+  SimpleCharStream jj_input_stream;\n+  public Token token, jj_nt;\n+  private int jj_ntk;\n+  private int jj_gen;\n+  final private int[] jj_la1 = new int[13];\n+  static private int[] jj_la1_0;\n+  static {\n+      jj_la1_0();\n+   }\n+   private static void jj_la1_0() {\n+      jj_la1_0 = new int[] {0x1d280c0,0x80,0x40000,0x1d280c0,0x40000,0x1d280c0,0x1c000c0,0x2000000,0x20,0x1000000,0x4c00,0x4c00,0x4c00,};\n+   }\n+\n+  public JsonParser(java.io.InputStream stream) {\n+     this(stream, null);\n+  }\n+  public JsonParser(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source = new JsonParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  public void ReInit(java.io.InputStream stream) {\n+     ReInit(stream, null);\n+  }\n+  public void ReInit(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  public JsonParser(java.io.Reader stream) {\n+    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n+    token_source = new JsonParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  public void ReInit(java.io.Reader stream) {\n+    jj_input_stream.ReInit(stream, 1, 1);\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  public JsonParser(JsonParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  public void ReInit(JsonParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+  }\n+\n+  final private Token jj_consume_token(int kind) throws ParseException {\n+    Token oldToken;\n+    if ((oldToken = token).next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    if (token.kind == kind) {\n+      jj_gen++;\n+      return token;\n+    }\n+    token = oldToken;\n+    jj_kind = kind;\n+    throw generateParseException();\n+  }\n+\n+  final public Token getNextToken() {\n+    if (token.next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    jj_gen++;\n+    return token;\n+  }\n+\n+  final public Token getToken(int index) {\n+    Token t = token;\n+    for (int i = 0; i < index; i++) {\n+      if (t.next != null) t = t.next;\n+      else t = t.next = token_source.getNextToken();\n+    }\n+    return t;\n+  }\n+\n+  final private int jj_ntk() {\n+    if ((jj_nt=token.next) == null)\n+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n+    else\n+      return (jj_ntk = jj_nt.kind);\n+  }\n+\n+  private java.util.Vector jj_expentries = new java.util.Vector();\n+  private int[] jj_expentry;\n+  private int jj_kind = -1;\n+\n+  public ParseException generateParseException() {\n+    jj_expentries.removeAllElements();\n+    boolean[] la1tokens = new boolean[26];\n+    for (int i = 0; i < 26; i++) {\n+      la1tokens[i] = false;\n+    }\n+    if (jj_kind >= 0) {\n+      la1tokens[jj_kind] = true;\n+      jj_kind = -1;\n+    }\n+    for (int i = 0; i < 13; i++) {\n+      if (jj_la1[i] == jj_gen) {\n+        for (int j = 0; j < 32; j++) {\n+          if ((jj_la1_0[i] & (1<<j)) != 0) {\n+            la1tokens[j] = true;\n+          }\n+        }\n+      }\n+    }\n+    for (int i = 0; i < 26; i++) {\n+      if (la1tokens[i]) {\n+        jj_expentry = new int[1];\n+        jj_expentry[0] = i;\n+        jj_expentries.addElement(jj_expentry);\n+      }\n+    }\n+    int[][] exptokseq = new int[jj_expentries.size()][];\n+    for (int i = 0; i < jj_expentries.size(); i++) {\n+      exptokseq[i] = (int[])jj_expentries.elementAt(i);\n+    }\n+    return new ParseException(token, exptokseq, tokenImage);\n+  }\n+\n+  final public void enable_tracing() {\n+  }\n+\n+  final public void disable_tracing() {\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserConstants.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParserConstants.java */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+interface JsonParserConstants {\n+\n+  int EOF = 0;\n+  int E = 5;\n+  int DIGITS = 6;\n+  int QUOTE = 7;\n+  int ENDQUOTE = 9;\n+  int CHAR = 10;\n+  int CNTRL_ESC = 11;\n+  int HEX = 13;\n+  int HEX_ESC = 14;\n+\n+  int DEFAULT = 0;\n+  int STRING_STATE = 1;\n+  int ESC_STATE = 2;\n+  int HEX_STATE = 3;\n+\n+  String[] tokenImage = {\n+    \"<EOF>\",\n+    \"\\\" \\\"\",\n+    \"\\\"\\\\t\\\"\",\n+    \"\\\"\\\\n\\\"\",\n+    \"\\\"\\\\r\\\"\",\n+    \"<E>\",\n+    \"<DIGITS>\",\n+    \"\\\"\\\\\\\"\\\"\",\n+    \"\\\"\\\\\\\\\\\"\",\n+    \"<ENDQUOTE>\",\n+    \"<CHAR>\",\n+    \"<CNTRL_ESC>\",\n+    \"\\\"u\\\"\",\n+    \"<HEX>\",\n+    \"<HEX_ESC>\",\n+    \"\\\"{\\\"\",\n+    \"\\\"}\\\"\",\n+    \"\\\"null\\\"\",\n+    \"\\\",\\\"\",\n+    \"\\\":\\\"\",\n+    \"\\\"[\\\"\",\n+    \"\\\"]\\\"\",\n+    \"\\\"true\\\"\",\n+    \"\\\"false\\\"\",\n+    \"\\\"-\\\"\",\n+    \"\\\".\\\"\",\n+  };\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n+/* Generated By:JavaCC: Do not edit this line. JsonParserTokenManager.java */\n+package com.google.gson;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.List;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+\n+@SuppressWarnings(\"all\")\n+final class JsonParserTokenManager implements JsonParserConstants\n+{\n+  public  java.io.PrintStream debugStream = System.out;\n+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\n+private final int jjMoveStringLiteralDfa0_3()\n+{\n+   return jjMoveNfa_3(0, 0);\n+}\n+private final void jjCheckNAdd(int state)\n+{\n+   if (jjrounds[state] != jjround)\n+   {\n+      jjstateSet[jjnewStateCnt++] = state;\n+      jjrounds[state] = jjround;\n+   }\n+}\n+private final void jjAddStates(int start, int end)\n+{\n+   do {\n+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddTwoStates(int state1, int state2)\n+{\n+   jjCheckNAdd(state1);\n+   jjCheckNAdd(state2);\n+}\n+private final void jjCheckNAddStates(int start, int end)\n+{\n+   do {\n+      jjCheckNAdd(jjnextStates[start]);\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddStates(int start)\n+{\n+   jjCheckNAdd(jjnextStates[start]);\n+   jjCheckNAdd(jjnextStates[start + 1]);\n+}\n+private final int jjMoveNfa_3(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 4;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 14)\n+                     kind = 14;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x7e0000007eL & l) != 0L && kind > 14)\n+                     kind = 14;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_0(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_0(int pos, long active0)\n+{\n+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);\n+}\n+private final int jjStopAtPos(int pos, int kind)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   return pos + 1;\n+}\n+private final int jjStartNfaWithStates_0(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_0(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_0()\n+{\n+   switch(curChar)\n+   {\n+      case 34:\n+         return jjStopAtPos(0, 7);\n+      case 44:\n+         return jjStopAtPos(0, 18);\n+      case 45:\n+         return jjStopAtPos(0, 24);\n+      case 46:\n+         return jjStopAtPos(0, 25);\n+      case 58:\n+         return jjStopAtPos(0, 19);\n+      case 91:\n+         return jjStopAtPos(0, 20);\n+      case 93:\n+         return jjStopAtPos(0, 21);\n+      case 102:\n+         return jjMoveStringLiteralDfa1_0(0x800000L);\n+      case 110:\n+         return jjMoveStringLiteralDfa1_0(0x20000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa1_0(0x400000L);\n+      case 123:\n+         return jjStopAtPos(0, 15);\n+      case 125:\n+         return jjStopAtPos(0, 16);\n+      default :\n+         return jjMoveNfa_0(0, 0);\n+   }\n+}\n+private final int jjMoveStringLiteralDfa1_0(long active0)\n+{\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(0, active0);\n+      return 1;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x800000L);\n+      case 114:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x400000L);\n+      case 117:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x20000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(0, active0);\n+}\n+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(0, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(1, active0);\n+      return 2;\n+   }\n+   switch(curChar)\n+   {\n+      case 108:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x820000L);\n+      case 117:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x400000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(1, active0);\n+}\n+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(1, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(2, active0);\n+      return 3;\n+   }\n+   switch(curChar)\n+   {\n+      case 101:\n+         if ((active0 & 0x400000L) != 0L)\n+            return jjStopAtPos(3, 22);\n+         break;\n+      case 108:\n+         if ((active0 & 0x20000L) != 0L)\n+            return jjStopAtPos(3, 17);\n+         break;\n+      case 115:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x800000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(2, active0);\n+}\n+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(2, old0);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(3, active0);\n+      return 4;\n+   }\n+   switch(curChar)\n+   {\n+      case 101:\n+         if ((active0 & 0x800000L) != 0L)\n+            return jjStopAtPos(4, 23);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(3, active0);\n+}\n+private final int jjMoveNfa_0(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 3;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+               case 2:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  kind = 6;\n+                  jjCheckNAdd(2);\n+                  break;\n+               case 1:\n+                  if ((0x280000000000L & l) != 0L)\n+                     kind = 5;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x2000000020L & l) == 0L)\n+                     break;\n+                  kind = 5;\n+                  jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_2(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_2(int pos, long active0)\n+{\n+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);\n+}\n+private final int jjStartNfaWithStates_2(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_2(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_2()\n+{\n+   switch(curChar)\n+   {\n+      case 117:\n+         return jjStopAtPos(0, 12);\n+      default :\n+         return jjMoveNfa_2(0, 0);\n+   }\n+}\n+private final int jjMoveNfa_2(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 1;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x800400000000L & l) != 0L)\n+                     kind = 11;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     kind = 11;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+private final int jjStopStringLiteralDfa_1(int pos, long active0)\n+{\n+   switch (pos)\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_1(int pos, long active0)\n+{\n+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);\n+}\n+private final int jjStartNfaWithStates_1(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_1(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_1()\n+{\n+   switch(curChar)\n+   {\n+      case 92:\n+         return jjStopAtPos(0, 8);\n+      default :\n+         return jjMoveNfa_1(0, 0);\n+   }\n+}\n+static final long[] jjbitVec0 = {\n+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+static final long[] jjbitVec2 = {\n+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+private final int jjMoveNfa_1(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 2;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                  {\n+                     if (kind > 10)\n+                        kind = 10;\n+                  }\n+                  else if (curChar == 34)\n+                  {\n+                     if (kind > 9)\n+                        kind = 9;\n+                  }\n+                  break;\n+               case 1:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                     kind = 10;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     kind = 10;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 10)\n+                     kind = 10;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+static final int[] jjnextStates = {\n+};\n+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec2[i2] & l2) != 0L);\n+      default :\n+         if ((jjbitVec0[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+public static final String[] jjstrLiteralImages = {\n+\"\", null, null, null, null, null, null, \"\\42\", null, null, null, null, null,\n+null, null, \"\\173\", \"\\175\", \"\\156\\165\\154\\154\", \"\\54\", \"\\72\", \"\\133\", \"\\135\",\n+\"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\55\", \"\\56\", };\n+public static final String[] lexStateNames = {\n+   \"DEFAULT\",\n+   \"STRING_STATE\",\n+   \"ESC_STATE\",\n+   \"HEX_STATE\",\n+};\n+public static final int[] jjnewLexState = {\n+   -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+   -1,\n+};\n+static final long[] jjtoToken = {\n+   0x3ffcee1L,\n+};\n+static final long[] jjtoSkip = {\n+   0x1eL,\n+};\n+static final long[] jjtoMore = {\n+   0x1100L,\n+};\n+protected SimpleCharStream input_stream;\n+private final int[] jjrounds = new int[4];\n+private final int[] jjstateSet = new int[8];\n+protected char curChar;\n+public JsonParserTokenManager(SimpleCharStream stream){\n+   if (SimpleCharStream.staticFlag)\n+      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n+   input_stream = stream;\n+}\n+public JsonParserTokenManager(SimpleCharStream stream, int lexState){\n+   this(stream);\n+   SwitchTo(lexState);\n+}\n+public void ReInit(SimpleCharStream stream)\n+{\n+   jjmatchedPos = jjnewStateCnt = 0;\n+   curLexState = defaultLexState;\n+   input_stream = stream;\n+   ReInitRounds();\n+}\n+private final void ReInitRounds()\n+{\n+   int i;\n+   jjround = 0x80000001;\n+   for (i = 4; i-- > 0;)\n+      jjrounds[i] = 0x80000000;\n+}\n+public void ReInit(SimpleCharStream stream, int lexState)\n+{\n+   ReInit(stream);\n+   SwitchTo(lexState);\n+}\n+public void SwitchTo(int lexState)\n+{\n+   if (lexState >= 4 || lexState < 0)\n+      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n+   else\n+      curLexState = lexState;\n+}\n+\n+protected Token jjFillToken()\n+{\n+   Token t = Token.newToken(jjmatchedKind);\n+   t.kind = jjmatchedKind;\n+   String im = jjstrLiteralImages[jjmatchedKind];\n+   t.image = (im == null) ? input_stream.GetImage() : im;\n+   t.beginLine = input_stream.getBeginLine();\n+   t.beginColumn = input_stream.getBeginColumn();\n+   t.endLine = input_stream.getEndLine();\n+   t.endColumn = input_stream.getEndColumn();\n+   return t;\n+}\n+\n+int curLexState = 0;\n+int defaultLexState = 0;\n+int jjnewStateCnt;\n+int jjround;\n+int jjmatchedPos;\n+int jjmatchedKind;\n+\n+public Token getNextToken()\n+{\n+  int kind;\n+  Token specialToken = null;\n+  Token matchedToken;\n+  int curPos = 0;\n+\n+  EOFLoop :\n+  for (;;)\n+  {\n+   try\n+   {\n+      curChar = input_stream.BeginToken();\n+   }\n+   catch(java.io.IOException e)\n+   {\n+      jjmatchedKind = 0;\n+      matchedToken = jjFillToken();\n+      return matchedToken;\n+   }\n+\n+   for (;;)\n+   {\n+     switch(curLexState)\n+     {\n+       case 0:\n+         try { input_stream.backup(0);\n+            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)\n+               curChar = input_stream.BeginToken();\n+         }\n+         catch (java.io.IOException e1) { continue EOFLoop; }\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_0();\n+         break;\n+       case 1:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_1();\n+         break;\n+       case 2:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_2();\n+         break;\n+       case 3:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_3();\n+         break;\n+     }\n+     if (jjmatchedKind != 0x7fffffff)\n+     {\n+        if (jjmatchedPos + 1 < curPos)\n+           input_stream.backup(curPos - jjmatchedPos - 1);\n+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+           matchedToken = jjFillToken();\n+       if (jjnewLexState[jjmatchedKind] != -1)\n+         curLexState = jjnewLexState[jjmatchedKind];\n+           return matchedToken;\n+        }\n+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+         if (jjnewLexState[jjmatchedKind] != -1)\n+           curLexState = jjnewLexState[jjmatchedKind];\n+           continue EOFLoop;\n+        }\n+      if (jjnewLexState[jjmatchedKind] != -1)\n+        curLexState = jjnewLexState[jjmatchedKind];\n+        curPos = 0;\n+        jjmatchedKind = 0x7fffffff;\n+        try {\n+           curChar = input_stream.readChar();\n+           continue;\n+        }\n+        catch (java.io.IOException e1) { }\n+     }\n+     int error_line = input_stream.getEndLine();\n+     int error_column = input_stream.getEndColumn();\n+     String error_after = null;\n+     boolean EOFSeen = false;\n+     try { input_stream.readChar(); input_stream.backup(1); }\n+     catch (java.io.IOException e1) {\n+        EOFSeen = true;\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+        if (curChar == '\\n' || curChar == '\\r') {\n+           error_line++;\n+           error_column = 0;\n+        }\n+        else\n+           error_column++;\n+     }\n+     if (!EOFSeen) {\n+        input_stream.backup(1);\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+     }\n+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n+   }\n+  }\n+}\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * A class representing a Json primitive value. A primitive value\n+ * is either a String, a Java primitive, or a Java primitive\n+ * wrapper type.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public final class JsonPrimitive extends JsonElement {\n+\n+  private Object value;\n+\n+  /**\n+   * Create a primitive containing a boolean value.\n+   *\n+   * @param bool the value to create the primitive with.\n+   */\n+  public JsonPrimitive(Boolean bool) {\n+    this.value = bool;\n+  }\n+\n+  /**\n+   * Create a primitive containing a {@link Number}.\n+   *\n+   * @param number the value to create the primitive with.\n+   */\n+  public JsonPrimitive(Number number) {\n+    this.value = number;\n+  }\n+\n+  /**\n+   * Create a primitive containing a String value.\n+   *\n+   * @param string the value to create the primitive with.\n+   */\n+  public JsonPrimitive(String string) {\n+    this.value = string;\n+  }\n+\n+  /**\n+   * Create a primitive containing a character. The character is turned into a one character String\n+   * since Json only supports String.\n+   *\n+   * @param c the value to create the primitive with.\n+   */\n+  public JsonPrimitive(Character c) {\n+    this.value = String.valueOf(c);\n+  }\n+\n+  /**\n+   * Create a primitive containing a character. The character is turned into a one character String\n+   * since Json only supports String.\n+   *\n+   * @param c the value to create the primitive with.\n+   */\n+  public JsonPrimitive(char c) {\n+    this.value = String.valueOf(c);\n+  }\n+\n+  /**\n+   * Create a primitive using the specified Object. It must be an instance of {@link Number}, a\n+   * Java primitive type, or a String.\n+   *\n+   * @param primitive the value to create the primitive with.\n+   */\n+  JsonPrimitive(Object primitive) {\n+    setValue(primitive);\n+  }\n+\n+  void setValue(Object primitive) {\n+    if (primitive instanceof Character) {\n+      // convert characters to strings since in JSON, characters are represented as a single\n+      // character string\n+      char c = ((Character)primitive).charValue();\n+      this.value = String.valueOf(c);\n+    } else {\n+      Preconditions.checkArgument(primitive instanceof Number\n+          || ObjectNavigator.isPrimitiveOrString(primitive));\n+      this.value = primitive;\n+    }\n+  }\n+\n+  /**\n+   * Check whether this primitive contains a boolean value.\n+   *\n+   * @return true if this primitive contains a boolean value, false otherwise.\n+   */\n+  public boolean isBoolean() {\n+    return value instanceof Boolean;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link Boolean}.\n+   *\n+   * @return get this element as a {@link Boolean}.\n+   * @throws ClassCastException if the value contained is not a valid boolean value.\n+   */\n+  @Override\n+  Boolean getAsBooleanWrapper() {\n+    return (Boolean) value;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a boolean value.\n+   *\n+   * @return get this element as a primitive boolean value.\n+   * @throws ClassCastException if the value contained is not a valid boolean value.\n+   */\n+  @Override\n+  public boolean getAsBoolean() {\n+    return ((Boolean) value).booleanValue();\n+  }\n+\n+  /**\n+   * Check whether this primitive contains a Number.\n+   *\n+   * @return true if this primitive contains a Number, false otherwise.\n+   */\n+  public boolean isNumber() {\n+    return value instanceof Number;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a Number.\n+   *\n+   * @return get this element as a Number.\n+   * @throws ClassCastException if the value contained is not a valid Number.\n+   */\n+  @Override\n+  public Number getAsNumber() {\n+    return (Number) value;\n+  }\n+\n+  /**\n+   * Check whether this primitive contains a String value.\n+   *\n+   * @return true if this primitive contains a String value, false otherwise.\n+   */\n+  public boolean isString() {\n+    return value instanceof String;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a String.\n+   *\n+   * @return get this element as a String.\n+   * @throws ClassCastException if the value contained is not a valid String.\n+   */\n+  @Override\n+  public String getAsString() {\n+    return (String) value;\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive double.\n+   *\n+   * @return get this element as a primitive double.\n+   * @throws ClassCastException if the value contained is not a valid double.\n+   */\n+  @Override\n+  public double getAsDouble() {\n+    return ((Number) value).doubleValue();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link BigDecimal}.\n+   *\n+   * @return get this element as a {@link BigDecimal}.\n+   * @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.\n+   */\n+  @Override\n+  public BigDecimal getAsBigDecimal() {\n+    if (value instanceof BigDecimal) {\n+      return (BigDecimal) value;\n+    } else {\n+      return new BigDecimal(value.toString());\n+    }\n+  }\n+\n+  /**\n+   * convenience method to get this element as a {@link BigInteger}.\n+   *\n+   * @return get this element as a {@link BigInteger}.\n+   * @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.\n+   */\n+  @Override\n+  public BigInteger getAsBigInteger() {\n+    if (value instanceof BigInteger) {\n+      return (BigInteger) value;\n+    } else {\n+      return new BigInteger(value.toString());\n+    }\n+  }\n+\n+  /**\n+   * convenience method to get this element as a float.\n+   *\n+   * @return get this element as a float.\n+   * @throws ClassCastException if the value contained is not a valid float.\n+   */\n+  @Override\n+  public float getAsFloat() {\n+    return ((Number) value).floatValue();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive long.\n+   *\n+   * @return get this element as a primitive long.\n+   * @throws ClassCastException if the value contained is not a valid long.\n+   */\n+  @Override\n+  public long getAsLong() {\n+    return ((Number) value).longValue();\n+  }\n+\n+  /**\n+   * convenience method to get this element as a primitive short.\n+   *\n+   * @return get this element as a primitive short.\n+   * @throws ClassCastException if the value contained is not a valid short value.\n+   */\n+ @Override\n+  public short getAsShort() {\n+    return ((Number) value).shortValue();\n+  }\n+\n+ /**\n+  * convenience method to get this element as a primitive integer.\n+  *\n+  * @return get this element as a primitive integer.\n+  * @throws ClassCastException if the value contained is not a valid integer.\n+  */\n+  @Override\n+  public int getAsInt() {\n+    return ((Number) value).intValue();\n+  }\n+\n+  /**\n+   * convenience method to get this element as an Object.\n+   *\n+   * @return get this element as an Object that can be converted to a suitable value.\n+   */\n+  @Override\n+  Object getAsObject() {\n+    return value;\n+  }\n+\n+  @Override\n+  protected void toString(StringBuilder sb) {\n+    if (value != null) {\n+      if (value instanceof String) {\n+        sb.append('\"');\n+        sb.append(value);\n+        sb.append('\"');\n+\n+      } else {\n+        sb.append(value);\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitiveDeserializationVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * A visitor that populates a primitive value from its JSON representation\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class JsonPrimitiveDeserializationVisitor<T> extends JsonDeserializationVisitor<T> {\n+\n+  JsonPrimitiveDeserializationVisitor(JsonPrimitive json, Type type,\n+      ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n+      TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      JsonDeserializationContext context) {\n+    super(json, type, factory, objectConstructor, typeAdapter, deserializers, context);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"unchecked\")\n+  protected T constructTarget() {\n+    return (T) objectConstructor.construct(targetType);\n+  }\n+\n+  public void startVisitingObject(Object node) {\n+    // do nothing\n+  }\n+\n+  public void endVisitingObject(Object node) {\n+    // do nothing\n+  }\n+\n+  public void visitCollection(@SuppressWarnings(\"unchecked\")Collection collection,\n+      Type componentType) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitArray(Object array, Type componentType) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitPrimitiveValue(Object obj) {\n+    JsonPrimitive jsonPrimitive = json.getAsJsonPrimitive();\n+    if (jsonPrimitive.isBoolean()) {\n+      target = (T) jsonPrimitive.getAsBooleanWrapper();\n+    } else if (jsonPrimitive.isNumber()) {\n+      target = (T) jsonPrimitive.getAsNumber();\n+    } else if (jsonPrimitive.isString()) {\n+      target = (T) jsonPrimitive.getAsString();\n+    } else {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitCollectionField(Field f, Type typeOfF, Object obj) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+\n+  public void visitPrimitiveField(Field f, Type fType, Object obj) {\n+    // should not be called since this case should invoke JsonArrayDeserializationVisitor\n+    throw new IllegalStateException();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonPrintFormatter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.PrintWriter;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Formats Json in a nicely indented way with a specified print margin.\n+ * This printer tries to keep elements on the same line as much as possible\n+ * while respecting right margin.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class JsonPrintFormatter implements JsonFormatter {\n+\n+  private final int printMargin;\n+  private final int indentationSize;\n+  private final int rightMargin;\n+\n+  public static final int DEFAULT_PRINT_MARGIN = 80;\n+  public static final int DEFAULT_INDENTATION_SIZE = 2;\n+  public static final int DEFAULT_RIGHT_MARGIN = 4;\n+\n+  public JsonPrintFormatter() {\n+    this(DEFAULT_PRINT_MARGIN, DEFAULT_INDENTATION_SIZE, DEFAULT_RIGHT_MARGIN);\n+  }\n+\n+  public JsonPrintFormatter(int printMargin, int indentationSize, int rightMargin) {\n+    this.printMargin = printMargin;\n+    this.indentationSize = indentationSize;\n+    this.rightMargin = rightMargin;\n+  }\n+\n+  private class JsonWriter {\n+    private final PrintWriter writer;\n+    private StringBuilder line;\n+    private int level;\n+    JsonWriter(PrintWriter writer) {\n+      this.writer = writer;\n+      level = 0;\n+      line = new StringBuilder();\n+    }\n+\n+    void key(String key) {\n+      getLine().append('\"');\n+      getLine().append(key);\n+      getLine().append('\"');\n+    }\n+\n+    void value(String value) {\n+      getLine().append(value);\n+    }\n+\n+    void fieldSeparator() {\n+      getLine().append(':');\n+      breakLineIfNeeded();\n+    }\n+\n+    void elementSeparator() {\n+      getLine().append(',');\n+      breakLineIfNeeded();\n+    }\n+\n+    void beginObject() {\n+      ++level;\n+      breakLineIfNeeded();\n+      getLine().append('{');\n+    }\n+\n+    void endObject() {\n+      getLine().append('}');\n+      --level;\n+    }\n+\n+    void beginArray() {\n+      ++level;\n+      breakLineIfNeeded();\n+      getLine().append('[');\n+    }\n+\n+    void endArray() {\n+      getLine().append(']');\n+      --level;\n+    }\n+\n+    private void breakLineIfNeeded() {\n+      if (getLine().length() > printMargin - rightMargin) {\n+        finishLine();\n+      }\n+    }\n+\n+    private void finishLine() {\n+      if (line != null) {\n+        writer.append(line).append(\"\\n\");\n+      }\n+      line = null;\n+    }\n+\n+    private StringBuilder getLine() {\n+      if (line == null) {\n+        createNewLine();\n+      }\n+      return line;\n+    }\n+\n+    private void createNewLine() {\n+      line = new StringBuilder();\n+      for (int i = 0; i < level; ++i) {\n+        for (int j = 0; j < indentationSize; ++j) {\n+          line.append(' ');\n+        }\n+      }\n+    }\n+  }\n+\n+  private class PrintFormattingVisitor implements JsonElementVisitor {\n+    private final Map<Integer, Boolean> first;\n+    private final JsonWriter writer;\n+    private final boolean serializeNulls;\n+    private int level = 0;\n+\n+    PrintFormattingVisitor(JsonWriter writer, boolean serializeNulls) {\n+      this.writer = writer;\n+      this.serializeNulls = serializeNulls;\n+      this.first = new HashMap<Integer, Boolean>();\n+    }\n+\n+    private void addCommaCheckingFirst() {\n+      if (first.get(level) != Boolean.FALSE) {\n+        first.put(level, false);\n+      } else {\n+        writer.elementSeparator();\n+      }\n+    }\n+\n+    public void startArray(JsonArray array) {\n+      first.put(++level, true);\n+      writer.beginArray();\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {\n+      addCommaCheckingFirst();\n+      writer.value(member.toString());\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonArray member, boolean first) {\n+      addCommaCheckingFirst();\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonObject member, boolean first) {\n+      addCommaCheckingFirst();\n+    }\n+\n+    public void visitNullArrayMember(JsonArray parent, boolean isFirst) {\n+      addCommaCheckingFirst();\n+    }\n+\n+    public void endArray(JsonArray array) {\n+      level--;\n+      writer.endArray();\n+    }\n+\n+    public void startObject(JsonObject object) {\n+      writer.beginObject();\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonPrimitive member, \n+        boolean isFirst) {\n+      addCommaCheckingFirst();\n+      writer.key(memberName);\n+      writer.fieldSeparator();\n+      writer.value(member.toString());\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonArray member, \n+        boolean isFirst) {\n+      addCommaCheckingFirst();\n+      writer.key(memberName);\n+      writer.fieldSeparator();\n+    }\n+\n+    public void visitObjectMember(JsonObject parent, String memberName, JsonObject member, \n+        boolean isFirst) {\n+      addCommaCheckingFirst();\n+      writer.key(memberName);\n+      writer.fieldSeparator();\n+    }\n+\n+    public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {\n+      if (serializeNulls) {\n+        visitObjectMember(parent, memberName, (JsonObject) null, isFirst);\n+      }\n+    }\n+    \n+    public void endObject(JsonObject object) {\n+      writer.endObject();\n+    }\n+\n+    public void visitPrimitive(JsonPrimitive primitive) {\n+      writer.value(primitive.toString());\n+    }\n+\n+    public void visitNull() {\n+      writer.value(\"null\");\n+    }\n+  }\n+\n+  public void format(JsonElement root, PrintWriter writer, boolean serializeNulls) {\n+    if (root == null) {\n+      return;\n+    }\n+    JsonWriter jsonWriter = new JsonWriter(writer);\n+    JsonElementVisitor visitor = \n+      new JsonEscapingVisitor(new PrintFormattingVisitor(jsonWriter, serializeNulls));    \n+    JsonTreeNavigator navigator = new JsonTreeNavigator(visitor, serializeNulls);\n+    navigator.navigate(root);\n+    jsonWriter.finishLine();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Context for serialization that is passed to a custom serializer during invocation of its\n+ * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public interface JsonSerializationContext {\n+\n+  /**\n+   * Invokes default serialization on the specified object.\n+   *\n+   * @param src the object that needs to be serialized.\n+   * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n+   */\n+  public JsonElement serialize(Object src);\n+\n+  /**\n+   * Invokes default serialization on the specified object passing the specific type information.\n+   * It should never be invoked on the element received as a parameter of the\n+   * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method. Doing\n+   * so will result in an infinite loop since Gson will in-turn call the custom serializer again.\n+   *\n+   * @param src the object that needs to be serialized.\n+   * @param typeOfSrc the actual genericized type of src object.\n+   * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n+   */\n+  public JsonElement serialize(Object src, Type typeOfSrc);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * An implementation of serialization context for Gson.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+final class JsonSerializationContextDefault implements JsonSerializationContext {\n+\n+  private final ObjectNavigatorFactory factory;\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final boolean serializeNulls;\n+\n+  JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\n+    this.factory = factory;\n+    this.serializeNulls = serializeNulls;\n+    this.serializers = serializers;\n+  }\n+\n+  public JsonElement serialize(Object src) {\n+    return serialize(src, src.getClass());\n+  }\n+\n+  public JsonElement serialize(Object src, Type typeOfSrc) {\n+    ObjectNavigator on = factory.create(src, typeOfSrc);\n+    JsonSerializationVisitor visitor =\n+      new JsonSerializationVisitor(factory, serializeNulls, serializers, this);\n+    on.accept(visitor);\n+    return visitor.getJsonElement();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * A visitor that adds JSON elements corresponding to each field of an object\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class JsonSerializationVisitor implements ObjectNavigator.Visitor {\n+\n+  private final ObjectNavigatorFactory factory;\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final boolean serializeNulls;\n+\n+  private final JsonSerializationContext context;\n+\n+  private JsonElement root;\n+\n+  JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls,\n+      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      JsonSerializationContext context) {\n+    this.factory = factory;\n+    this.serializeNulls = serializeNulls;\n+    this.serializers = serializers;\n+    this.context = context;\n+  }\n+\n+  public void endVisitingObject(Object node) {\n+    // nothing to be done here\n+  }\n+\n+  public void startVisitingObject(Object node) {\n+    assignToRoot(new JsonObject());\n+  }\n+\n+  public void visitArray(Object array, Type arrayType) {\n+    assignToRoot(new JsonArray());\n+    int length = Array.getLength(array);\n+    TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType);\n+    Type componentType = fieldTypeInfo.getSecondLevelType();\n+    for (int i = 0; i < length; ++i) {\n+      Object child = Array.get(array, i);\n+      addAsArrayElement(componentType, child);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitCollection(Collection collection, Type collectionType) {\n+    assignToRoot(new JsonArray());\n+    for (Object child : collection) {\n+      Type childType = TypeUtils.getActualTypeForFirstTypeVariable(collectionType);\n+      if (childType == Object.class && child != null) {\n+        // Try our luck some other way\n+        childType = child.getClass();\n+      }\n+      addAsArrayElement(childType, child);\n+    }\n+  }\n+\n+  public void visitArrayField(Field f, Type typeOfF, Object obj) {\n+    if (!isFieldNull(f, obj)) {\n+      Object array = getFieldValue(f, obj);\n+      addAsChildOfObject(f, typeOfF, array);\n+    }\n+  }\n+\n+  public void visitCollectionField(Field f, Type typeOfF, Object obj) {\n+    if (!isFieldNull(f, obj)) {\n+      if (typeOfF == null) {\n+        throw new RuntimeException(\"Can not handle non-generic collections\");\n+      }\n+      Object collection = getFieldValue(f, obj);\n+      addAsChildOfObject(f, typeOfF, collection);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void visitEnum(Object obj, Type objType) {\n+    JsonSerializer serializer = serializers.getHandlerFor(objType);\n+    if (serializer == null) {\n+      serializer = serializers.getHandlerFor(Enum.class);\n+    }\n+    if (serializer == null) {\n+      throw new RuntimeException(\"Register a JsonSerializer for Enum or \"\n+          + obj.getClass().getName());\n+    }\n+    assignToRoot(serializer.serialize(obj, objType, context));\n+  }\n+\n+  public void visitObjectField(Field f, Type typeOfF, Object obj) {\n+    if (isFieldNull(f, obj)) {\n+      if (serializeNulls) {\n+        addChildAsElement(f, new JsonNull());\n+      }\n+    } else {\n+      Object fieldValue = getFieldValue(f, obj);\n+      addAsChildOfObject(f, typeOfF, fieldValue);\n+    }\n+  }\n+\n+  private void addAsChildOfObject(Field f, Type fieldType, Object fieldValue) {\n+    JsonElement childElement = getJsonElementForChild(fieldType, fieldValue);\n+    addChildAsElement(f, childElement);\n+  }\n+\n+  private void addChildAsElement(Field f, JsonElement childElement) {\n+    FieldNamingStrategy namingPolicy = factory.getFieldNamingPolicy();\n+    root.getAsJsonObject().add(namingPolicy.translateName(f), childElement);\n+  }\n+\n+  private void addAsArrayElement(Type elementType, Object elementValue) {\n+    if (elementValue == null) {\n+      addNullAsArrayElement();\n+    } else {\n+      JsonElement childElement = getJsonElementForChild(elementType, elementValue);\n+      root.getAsJsonArray().add(childElement);\n+    }\n+  }\n+\n+  private void addNullAsArrayElement() {\n+    root.getAsJsonArray().add(null);\n+  }\n+\n+  private JsonElement getJsonElementForChild(Type fieldType, Object fieldValue) {\n+    ObjectNavigator on = factory.create(fieldValue, fieldType);\n+    JsonSerializationVisitor childVisitor =\n+        new JsonSerializationVisitor(factory, serializeNulls, serializers, context);\n+    on.accept(childVisitor);\n+    return childVisitor.getJsonElement();\n+  }\n+\n+  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {\n+    if (!isFieldNull(f, obj)) {\n+      TypeInfo typeInfo = new TypeInfo(typeOfF);\n+      if (typeInfo.isPrimitiveOrStringAndNotAnArray()) {\n+        Object fieldValue = getFieldValue(f, obj);\n+        addAsChildOfObject(f, typeOfF, fieldValue);\n+      } else {\n+        throw new IllegalArgumentException(\"Not a primitive type\");\n+      }\n+    }\n+  }\n+\n+  public void visitPrimitiveValue(Object obj) {\n+    assignToRoot(new JsonPrimitive(obj));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public boolean visitUsingCustomHandler(Object obj, Type objType) {\n+    JsonSerializer serializer = serializers.getHandlerFor(objType);\n+    if (serializer == null && obj instanceof Map) {\n+      serializer = serializers.getHandlerFor(Map.class);\n+    }\n+    if (serializer != null) {\n+      assignToRoot(serializer.serialize(obj, objType, context));\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private void assignToRoot(JsonElement newRoot) {\n+    Preconditions.checkArgument(root == null);\n+    root = newRoot;\n+  }\n+\n+  private boolean isFieldNull(Field f, Object obj) {\n+    return getFieldValue(f, obj) == null;\n+  }\n+\n+  private Object getFieldValue(Field f, Object obj) {\n+    try {\n+      return f.get(obj);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public JsonElement getJsonElement() {\n+    return root;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonSerializer.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Interface representing a custom serializer for Json. You should write a custom serializer, if\n+ * you are not happy with the default serialization done by Gson. You will also need to register\n+ * this serializer through {@link com.google.gson.GsonBuilder#registerTypeAdapter(Type, Object)}.\n+ *\n+ * <p>Let us look at example where defining a serializer will be useful. The {@code Id} class\n+ * defined below has two fields: {@code clazz} and {@code value}.</p>\n+ *\n+ * <p><pre>\n+ * public class Id&lt;T&gt; {\n+ *   private final Class&lt;T&gt; clazz;\n+ *   private final long value;\n+ *\n+ *   public Id(Class&lt;T&gt; clazz, long value) {\n+ *     this.clazz = clazz;\n+ *     this.value = value;\n+ *   }\n+ *\n+ *   public long getValue() {\n+ *     return value;\n+ *   }\n+ * }\n+ * </pre></p>\n+ *\n+ * <p>The default serialization of {@code Id(com.foo.MyObject.class, 20L)} will be\n+ * <code>{\"clazz\":com.foo.MyObject,\"value\":20}</code>. Suppose, you just want the output to be\n+ * the value instead, which is {@code 20} in this case. You can achieve that by writing a custom\n+ * serializer:</p>\n+ *\n+ * <p><pre>\n+ * class IdSerializer implements JsonSerializer&lt;Id&gt;() {\n+ *   public JsonElement toJson(Id id, Type typeOfId, JsonSerializationContext context) {\n+ *     return new JsonPrimitive(id.getValue());\n+ *   }\n+ * }\n+ * </pre></p>\n+ *\n+ * <p>You will also need to register {@code IdSerializer} with Gson as follows:</p>\n+ * <pre>\n+ * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <T> type for which the serializer is being registered. It is possible that a serializer\n+ *        may be asked to serialize a specific generic type of the T.\n+ */\n+public interface JsonSerializer<T> {\n+\n+  /**\n+   * Gson invokes this call-back method during serialization when it encounters a field of the\n+   * specified type.\n+   *\n+   * <p>In the implementation of this call-back method, you should consider invoking\n+   * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any\n+   * non-trivial field of the {@code src} object. However, you should never invoke it on the\n+   * {@code src} object itself since that will cause an infinite loop (Gson will call your\n+   * call-back method again).</p>\n+   *\n+   * @param src the object that needs to be converted to Json.\n+   * @param typeOfSrc the actual type (fully genericized version) of the source object.\n+   * @return a JsonElement corresponding to the specified object.\n+   */\n+  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonSerializerExceptionWrapper.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Decorators a {@code JsonSerializer} instance with exception handling.  This wrapper class\n+ * ensures that a {@code JsonSerializer} will not propagate any exception other than a\n+ * {@link JsonParseException}.\n+ *\n+ * @param <T> type of the serializer being wrapped.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class JsonSerializerExceptionWrapper<T> implements JsonSerializer<T> {\n+  private final JsonSerializer<T> delegate;\n+\n+  /**\n+   * Returns a wrapped {@link JsonSerializer} object that has been decorated with\n+   * {@link JsonParseException} handling.\n+   *\n+   * @param delegate the {@code JsonSerializer} instance to be wrapped\n+   * @throws IllegalArgumentException if {@code delegate} is {@code null}.\n+   */\n+  JsonSerializerExceptionWrapper(JsonSerializer<T> delegate) {\n+    Preconditions.checkNotNull(delegate);\n+    this.delegate = delegate;\n+  }\n+\n+  public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) {\n+    try {\n+      return delegate.serialize(src, typeOfSrc, context);\n+    } catch (JsonParseException e) {\n+      // just rethrow the exception\n+      throw e;\n+    } catch (Exception e) {\n+      // throw as a JsonParseException\n+      StringBuilder errorMsg = new StringBuilder()\n+          .append(\"The JsonSerializer \")\n+          .append(delegate)\n+          .append(\" failed to serialized object \")\n+          .append(src)\n+          .append(\" given the type \")\n+          .append(typeOfSrc);\n+      throw new JsonParseException(errorMsg.toString(), e);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonTreeNavigator.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.Map;\n+\n+/**\n+ * A navigator to navigate a tree of JsonElement nodes in Depth-first order\n+ * \n+ * @author Inderjeet Singh\n+ */\n+final class JsonTreeNavigator {\n+  private final JsonElementVisitor visitor;\n+  private final boolean visitNulls;\n+\n+  JsonTreeNavigator(JsonElementVisitor visitor, boolean visitNulls) {\n+    this.visitor = visitor;\n+    this.visitNulls = visitNulls;\n+  }\n+  \n+  public void navigate(JsonElement element) {\n+    if (element == null || element.isJsonNull()) {\n+      visitor.visitNull();\n+    } else if (element.isJsonArray()) {\n+      JsonArray array = element.getAsJsonArray();\n+      visitor.startArray(array);\n+      boolean isFirst = true;\n+      for (JsonElement child : array) {\n+        visitChild(array, child, isFirst);\n+        if (isFirst) {\n+          isFirst = false;\n+        }\n+      }\n+      visitor.endArray(array);\n+    } else if (element.isJsonObject()){\n+      JsonObject object = element.getAsJsonObject();\n+      visitor.startObject(object);\n+      boolean isFirst = true;\n+      for (Map.Entry<String, JsonElement> member : object.entrySet()) {\n+        visitChild(object, member.getKey(), member.getValue(), isFirst);\n+        if (isFirst) {\n+          isFirst = false;\n+        }\n+      }\n+      visitor.endObject(object);\n+    } else { // must be JsonPrimitive\n+      visitor.visitPrimitive(element.getAsJsonPrimitive());\n+    }    \n+  }\n+\n+  private void visitChild(JsonObject parent, String childName, JsonElement child, boolean isFirst) {\n+    if (child != null) { \n+      if (child.isJsonNull()) {\n+        if (visitNulls) {\n+          visitor.visitNullObjectMember(parent, childName, isFirst);\n+          navigate(child.getAsJsonNull());\n+        }\n+      } else if (child.isJsonArray()) {\n+        JsonArray childAsArray = child.getAsJsonArray();\n+        visitor.visitObjectMember(parent, childName, childAsArray, isFirst);\n+        navigate(childAsArray);\n+      } else if (child.isJsonObject()) {\n+        JsonObject childAsObject = child.getAsJsonObject();\n+        visitor.visitObjectMember(parent, childName, childAsObject, isFirst);\n+        navigate(childAsObject);\n+      } else { // is a JsonPrimitive\n+        visitor.visitObjectMember(parent, childName, child.getAsJsonPrimitive(), isFirst);          \n+      }\n+    }\n+  }\n+\n+  private void visitChild(JsonArray parent, JsonElement child, boolean isFirst) {\n+    if (child == null || child.isJsonNull()) {\n+      visitor.visitNullArrayMember(parent, isFirst);\n+      navigate(null);\n+\t} else if (child.isJsonArray()) {\n+      JsonArray childAsArray = child.getAsJsonArray();\n+      visitor.visitArrayMember(parent, childAsArray, isFirst);\n+      navigate(childAsArray);\n+    } else if (child.isJsonObject()) {\n+      JsonObject childAsObject = child.getAsJsonObject();\n+      visitor.visitArrayMember(parent, childAsObject, isFirst);\n+      navigate(childAsObject);\n+    } else { // is a JsonPrimitive\n+      visitor.visitArrayMember(parent, child.getAsJsonPrimitive(), isFirst);          \n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/LowerCamelCaseSeparatorNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n+ * lower case letters and are separated by a particular {@code separatorString}.\n+ *\n+ *<p>The following is an example:</p>\n+ * <pre>\n+ * class StringWrapper {\n+ *   public String AStringField = \"abcd\";\n+ * }\n+ *\n+ * LowerCamelCaseSeparatorNamingPolicy policy = new LowerCamelCaseSeparatorNamingPolicy(\"_\");\n+ * String translatedFieldName =\n+ *     policy.translateName(StringWrapper.class.getField(\"AStringField\"));\n+ *\n+ * assert(\"a_string_field\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ */\n+class LowerCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {\n+\n+  public LowerCamelCaseSeparatorNamingPolicy(String separatorString) {\n+    super(new CamelCaseSeparatorNamingPolicy(separatorString), new LowerCaseNamingPolicy());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/LowerCaseNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n+ * lower case letters.\n+ *\n+ *<p>The following is an example:</p>\n+ * <pre>\n+ * class IntWrapper {\n+ *   public int integerField = 0;\n+ * }\n+ *\n+ * LowerCaseNamingPolicy policy = new LowerCaseNamingPolicy();\n+ * String translatedFieldName =\n+ *     policy.translateName(IntWrapper.class.getField(\"integerField\"));\n+ *\n+ * assert(\"integerfield\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ */\n+class LowerCaseNamingPolicy extends RecursiveFieldNamingPolicy {\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+    return target.toLowerCase();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * This class contains a mapping of all the application specific\n+ * {@link InstanceCreator} instances.  Registering an {@link InstanceCreator}\n+ * with this class will override the default object creation that is defined\n+ * by the ObjectConstructor that this class is wrapping.  Using this class\n+ * with the JSON framework provides the application with \"pluggable\" modules\n+ * to customize framework to suit the application's needs.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class MappedObjectConstructor implements ObjectConstructor {\n+  private final Logger log = Logger.getLogger(getClass().getName());\n+\n+  private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap =\n+    new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T construct(Type typeOfT) {\n+    if (instanceCreatorMap.hasAnyHandlerFor(typeOfT)) {\n+      InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT);\n+      return creator.createInstance(typeOfT);\n+    }\n+    TypeInfo typeInfo = new TypeInfo(typeOfT);\n+    if (typeInfo.isEnum()) {\n+      InstanceCreator<T> creator =\n+        (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(Enum.class);\n+      return creator.createInstance(typeOfT);\n+    }\n+    return (T) constructWithNoArgConstructor(typeOfT);\n+  }\n+\n+  public Object constructArray(Type type, int length) {\n+    return Array.newInstance(TypeUtils.toRawClass(type), length);\n+  }\n+\n+  private <T> T constructWithNoArgConstructor(Type typeOfT) {\n+    try {\n+      Constructor<T> constructor = getNoArgsConstructor(typeOfT);\n+      if (constructor == null) {\n+        throw new RuntimeException((\"No-args constructor for \" + typeOfT + \" does not exist. \"\n+            + \"Register an InstanceCreator with Gson for this type to fix this problem.\"));\n+      }\n+      return constructor.newInstance();\n+    } catch (InstantiationException e) {\n+      throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n+          + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n+          + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n+    } catch (InvocationTargetException e) {\n+      throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n+          + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n+    }\n+  }\n+\n+  @SuppressWarnings({\"unchecked\", \"cast\"})\n+  private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) {\n+    TypeInfo typeInfo = new TypeInfo(typeOfT);\n+    Class<T> clazz = (Class<T>) typeInfo.getRawClass();\n+    Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors();\n+    AccessibleObject.setAccessible(declaredConstructors, true);\n+    for (Constructor<T> constructor : declaredConstructors) {\n+      if (constructor.getParameterTypes().length == 0) {\n+        return constructor;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Use this methods to register an {@link InstanceCreator} for a new type.\n+   *\n+   * @param <T> the type of class to be mapped with its \"creator\"\n+   * @param typeOfT the instance type that will be created\n+   * @param creator the {@link InstanceCreator} instance to register\n+   */\n+  <T> void register(Type typeOfT, InstanceCreator<? extends T> creator) {\n+    if (instanceCreatorMap.hasSpecificHandlerFor(typeOfT)) {\n+      log.log(Level.WARNING, \"Overriding the existing InstanceCreator for \" + typeOfT);\n+    }\n+    instanceCreatorMap.register(typeOfT, creator);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/MemoryRefStack.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.Stack;\n+\n+/**\n+ * A stack data structure that only does a memory reference comparison\n+ * when looking for a particular item in the stack.  This stack does\n+ * not allow {@code null} values to be added.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class MemoryRefStack<T> {\n+  private final Stack<T> stack = new Stack<T>();\n+\n+  /**\n+   * Adds a new element to the top of the stack.\n+   *\n+   * @param obj the object to add to the stack\n+   * @return the object that was added\n+   */\n+  public T push(T obj) {\n+    Preconditions.checkNotNull(obj);\n+\n+    return stack.push(obj);\n+  }\n+\n+  /**\n+   * Removes the top element from the stack.\n+   *\n+   * @return the element being removed from the stack\n+   * @throws java.util.EmptyStackException thrown if the stack is empty\n+   */\n+  public T pop() {\n+    return stack.pop();\n+  }\n+\n+  /**\n+   * Retrieves the item from the top of the stack, but does not remove it.\n+   *\n+   * @return the item from the top of the stack\n+   * @throws java.util.EmptyStackException thrown if the stack is empty\n+   */\n+  public T peek() {\n+    return stack.peek();\n+  }\n+\n+  /**\n+   * Performs a memory reference check to see it the {@code obj} exists in\n+   * the stack.\n+   *\n+   * @param obj the object to search for in the stack\n+   * @return true if this object is already in the stack otherwise false\n+   */\n+  public boolean contains(T obj) {\n+    if (obj == null) {\n+      return false;\n+    }\n+\n+    for (T stackObject : stack) {\n+      if (obj == stackObject) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ModifierBasedExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+/**\n+ * Exclude fields based on particular field modifiers.  For a list of possible\n+ * modifiers, see {@link java.lang.reflect.Modifier}.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class ModifierBasedExclusionStrategy implements ExclusionStrategy {\n+  private final boolean skipSyntheticField;\n+  private final Collection<Integer> modifiers;\n+\n+  public ModifierBasedExclusionStrategy(boolean skipSyntheticFields, int... modifiers) {\n+    this.skipSyntheticField = skipSyntheticFields;\n+    this.modifiers = new HashSet<Integer>();\n+    if (modifiers != null) {\n+      for (int modifier : modifiers) {\n+        this.modifiers.add(modifier);\n+      }\n+    }\n+  }\n+\n+  public boolean shouldSkipField(Field f) {\n+    if (skipSyntheticField && f.isSynthetic()) {\n+      return true;\n+    }\n+    int objectModifiers = f.getModifiers();\n+    for (int modifier : modifiers) {\n+      if ((objectModifiers & modifier) != 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return false;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A {@link FieldNamingStrategy} that ensures the JSON field names begins with\n+ * an upper case letter.\n+ *\n+ *<p>The following is an example:</p>\n+ * <pre>\n+ * class StringWrapper {\n+ *   public String stringField = \"abcd\";\n+ *   public String _stringField = \"efg\";\n+ * }\n+ *\n+ * ModifyFirstLetterNamingPolicy policy =\n+ *     new ModifyFirstLetterNamingPolicy(LetterModifier.UPPER);\n+ * String translatedFieldName =\n+ *     policy.translateName(StringWrapper.class.getField(\"stringField\"));\n+ *\n+ * assert(\"StringField\".equals(translatedFieldName));\n+ *\n+ * String translatedFieldName =\n+ *     policy.translateName(StringWrapper.class.getField(\"_stringField\"));\n+ *\n+ * assert(\"_StringField\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ */\n+class ModifyFirstLetterNamingPolicy extends RecursiveFieldNamingPolicy {\n+\n+  public enum LetterModifier {\n+    UPPER,\n+    LOWER;\n+  }\n+\n+  private final LetterModifier letterModifier;\n+\n+  /**\n+   * Creates a new ModifyFirstLetterNamingPolicy that will either modify the first letter of the\n+   * target name to either UPPER case or LOWER case depending on the {@code modifier} parameter.\n+   *\n+   * @param modifier the type of modification that should be performed\n+   * @throws IllegalArgumentException if {@code modifier} is null\n+   */\n+  public ModifyFirstLetterNamingPolicy(LetterModifier modifier) {\n+    Preconditions.checkNotNull(modifier);\n+    this.letterModifier = modifier;\n+  }\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+    StringBuilder fieldNameBuilder = new StringBuilder();\n+    int index = 0;\n+    char firstCharacter = target.charAt(index);\n+\n+    while (index < target.length() - 1) {\n+      if (Character.isLetter(firstCharacter)) {\n+        break;\n+      }\n+\n+      fieldNameBuilder.append(firstCharacter);\n+      firstCharacter = target.charAt(++index);\n+    }\n+\n+    if (index == target.length()) {\n+      return fieldNameBuilder.toString();\n+    }\n+\n+    boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER);\n+    if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) {\n+      String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index);\n+      return fieldNameBuilder.append(modifiedTarget).toString();\n+    } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) {\n+      String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index);\n+      return fieldNameBuilder.append(modifiedTarget).toString();\n+    } else {\n+      return target;\n+    }\n+  }\n+\n+  private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {\n+    if (indexOfSubstring < srcString.length()) {\n+      return firstCharacter + srcString.substring(indexOfSubstring);\n+    } else {\n+      return String.valueOf(firstCharacter);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/NullExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * This acts as a \"Null Object\" pattern for the {@link ExclusionStrategy}.\n+ * Passing an instance of this class into the {@link ObjectNavigator} will\n+ * make the {@link ObjectNavigator} parse/visit every field of the object\n+ * being navigated.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class NullExclusionStrategy implements ExclusionStrategy {\n+\n+  public boolean shouldSkipField(Field f) {\n+    return false;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return false;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ObjectConstructor.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Defines a generic object construction factory.  The purpose of this class\n+ * is to construct a default instance of a class that can be used for object\n+ * navigation while deserialization from its JSON representation.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+interface ObjectConstructor {\n+\n+  /**\n+   * Creates a new instance of the given type.\n+   *\n+   * @param typeOfT the class type that should be instantiated\n+   * @return a default instance of the provided class.\n+   */\n+  public <T> T construct(Type typeOfT);\n+\n+  /**\n+   * Constructs an array type of the provided length.\n+   *\n+   * @param typeOfArrayElements type of objects in the array\n+   * @param length size of the array\n+   * @return new array of size length\n+   */\n+  public Object constructArray(Type typeOfArrayElements, int length);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * Provides ability to apply a visitor to an object and all of its fields recursively.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class ObjectNavigator {\n+\n+  public interface Visitor {\n+    /**\n+     * This is called before the object navigator starts visiting the current object\n+     */\n+    void startVisitingObject(Object node);\n+\n+    /**\n+     * This is called after the object navigator finishes visiting the current object\n+     */\n+    void endVisitingObject(Object node);\n+\n+    /**\n+     * This is called to visit the current object if it is an iterable\n+     *\n+     * @param componentType the type of each element of the component\n+     */\n+    void visitCollection(@SuppressWarnings(\"unchecked\") Collection collection, Type componentType);\n+\n+    /**\n+     * This is called to visit the current object if it is an array\n+     */\n+    void visitArray(Object array, Type componentType);\n+\n+    /**\n+     * This is called to visit the current object if it is a primitive\n+     */\n+    void visitPrimitiveValue(Object obj);\n+\n+    /**\n+     * This is called to visit an object field of the current object\n+     */\n+    void visitObjectField(Field f, Type typeOfF, Object obj);\n+\n+    /**\n+     * This is called to visit a field of type Collection of the current object\n+     */\n+    void visitCollectionField(Field f, Type typeOfF, Object obj);\n+\n+    /**\n+     * This is called to visit an array field of the current object\n+     */\n+    void visitArrayField(Field f, Type typeOfF, Object obj);\n+\n+    /**\n+     * This is called to visit a primitive field of the current object\n+     */\n+    void visitPrimitiveField(Field f, Type typeOfF, Object obj);\n+\n+    /**\n+     * This is called to visit an enum object\n+     */\n+    public void visitEnum(Object obj, Type objType);\n+\n+    /**\n+     * This is called to visit an object using a custom handler\n+     * @return true if a custom handler exists, false otherwise\n+     */\n+    public boolean visitUsingCustomHandler(Object obj, Type objType);\n+  }\n+\n+  private final ExclusionStrategy exclusionStrategy;\n+  private final MemoryRefStack<Object> ancestors;\n+  private final Object obj;\n+  private final Type objType;\n+\n+  /**\n+   * @param obj The object being navigated\n+   * @param objType The (fully genericized) type of the object being navigated\n+   * @param exclusionStrategy the concrete strategy object to be used to\n+   *        filter out fields of an object.\n+   */\n+  ObjectNavigator(Object obj, Type objType, ExclusionStrategy exclusionStrategy,\n+      MemoryRefStack<Object> ancestors) {\n+    Preconditions.checkNotNull(exclusionStrategy);\n+    Preconditions.checkNotNull(ancestors);\n+\n+    this.obj = obj;\n+    this.objType = objType;\n+    this.exclusionStrategy = exclusionStrategy;\n+    this.ancestors = ancestors;\n+  }\n+\n+  /**\n+   * Navigate all the fields of the specified object.\n+   * If a field is null, it does not get visited.\n+   */\n+  public void accept(Visitor visitor) {\n+    if (obj == null) {\n+      return;\n+    }\n+    TypeInfo objTypeInfo = new TypeInfo(objType);\n+    if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\n+      return;\n+    }\n+\n+    if (ancestors.contains(obj)) {\n+      throw new IllegalStateException(\"Circular reference found: \" + obj);\n+    }\n+    ancestors.push(obj);\n+\n+    try {\n+      if (objTypeInfo.isCollectionOrArray()) {\n+        if (objTypeInfo.isArray()) {\n+          visitor.visitArray(obj, objType);\n+        } else { // must be a collection\n+          visitor.visitCollection((Collection<?>) obj, objType);\n+        }\n+      } else if (objTypeInfo.isEnum()) {\n+        visitor.visitEnum(obj, objType);\n+      } else if (objTypeInfo.isPrimitiveOrStringAndNotAnArray()) {\n+        visitor.visitPrimitiveValue(obj);\n+      } else {\n+        if (!visitor.visitUsingCustomHandler(obj, objType)) {\n+          visitor.startVisitingObject(obj);\n+          // For all classes in the inheritance hierarchy (including the current class),\n+          // visit all fields\n+          for (Class<?> curr = objTypeInfo.getRawClass();\n+              curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) {\n+            if (!curr.isSynthetic()) {\n+              navigateClassFields(obj, curr, visitor);\n+            }\n+          }\n+          visitor.endVisitingObject(obj);\n+        }\n+      }\n+    } finally {\n+      ancestors.pop();\n+    }\n+  }\n+\n+  private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\n+    Field[] fields = clazz.getDeclaredFields();\n+    AccessibleObject.setAccessible(fields, true);\n+    for (Field f : fields) {\n+      TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objType);\n+      Type actualTypeOfField = fieldTypeInfo.getActualType();\n+      if (exclusionStrategy.shouldSkipField(f)) {\n+        continue; // skip\n+      } else if (fieldTypeInfo.isCollectionOrArray()) {\n+        if (fieldTypeInfo.isArray()) {\n+          visitor.visitArrayField(f, actualTypeOfField, obj);\n+        } else { // must be Collection\n+          visitor.visitCollectionField(f, actualTypeOfField, obj);\n+        }\n+      } else if (fieldTypeInfo.isPrimitiveOrStringAndNotAnArray()) {\n+        visitor.visitPrimitiveField(f, actualTypeOfField, obj);\n+      } else {\n+        visitor.visitObjectField(f, actualTypeOfField, obj);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static final Class[] PRIMITIVE_TYPES = { int.class, long.class, short.class, float.class,\n+      double.class, byte.class, boolean.class, Integer.class, Long.class, Short.class, Float.class,\n+      Double.class, Byte.class, Boolean.class };\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static boolean isPrimitiveOrString(Object target) {\n+    if (target instanceof String) {\n+      return true;\n+    }\n+    Class<?> classOfPrimitive = target.getClass();\n+    for (Class standardPrimitive : PRIMITIVE_TYPES) {\n+      if (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A factory class used to simplify {@link ObjectNavigator} creation.\n+ * This object holds on to a reference of the {@link ExclusionStrategy}\n+ * that you'd like to use with the {@link ObjectNavigator}.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class ObjectNavigatorFactory {\n+  private final ExclusionStrategy strategy;\n+  private final FieldNamingStrategy fieldNamingPolicy;\n+  private final MemoryRefStack<Object> stack;\n+\n+  /**\n+   * Creates a factory object that will be able to create new\n+   * {@link ObjectNavigator}s with the provided {@code strategy}\n+   *\n+   * @param strategy the exclusion strategy to use with every instance that\n+   *        is created by this factory instance.\n+   * @param fieldNamingPolicy the naming policy that should be applied to field\n+   *        names\n+   */\n+  public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n+    Preconditions.checkNotNull(fieldNamingPolicy);\n+    this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\n+    this.fieldNamingPolicy = fieldNamingPolicy;\n+    this.stack = new MemoryRefStack<Object>();\n+  }\n+\n+  /**\n+   * Creates a new {@link ObjectNavigator} for this {@code srcObject}.\n+   *\n+   * @see #create(Object, Type)\n+   * @param srcObject object to navigate\n+   * @return a new instance of a {@link ObjectNavigator} ready to navigate the\n+   *         {@code srcObject}.\n+   */\n+  public ObjectNavigator create(Object srcObject) {\n+    return create(srcObject, srcObject.getClass());\n+  }\n+\n+  /**\n+   * Creates a new {@link ObjectNavigator} for this {@code srcObject},\n+   * {@code type} pair.\n+   *\n+   * @param srcObject object to navigate\n+   * @param type the \"actual\" type of this {@code srcObject}.  NOTE: this can\n+   *        be a {@link java.lang.reflect.ParameterizedType} rather than a {@link Class}.\n+   * @return a new instance of a {@link ObjectNavigator} ready to navigate the\n+   *         {@code srcObject} while taking into consideration the\n+   *         {@code type}.\n+   */\n+  public ObjectNavigator create(Object srcObject, Type type) {\n+    return new ObjectNavigator(srcObject, type, strategy, stack);\n+  }\n+\n+  FieldNamingStrategy getFieldNamingPolicy() {\n+    return fieldNamingPolicy;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+\n+/**\n+ * A map that provides ability to associate handlers for a specific type or all of its sub-types\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <T> The handler that will be looked up by type\n+ */\n+final class ParameterizedTypeHandlerMap<T> {\n+\n+  private final Map<Type, T> map = new HashMap<Type, T>();\n+  private boolean modifiable = true;\n+\n+  public synchronized void register(Type typeOfT, T value) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    if (hasSpecificHandlerFor(typeOfT)) {\n+      Gson.logger.log(Level.WARNING, \"Overriding the existing type handler for \" + typeOfT);\n+    }\n+    map.put(typeOfT, value);\n+  }\n+\n+  public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\n+    if (!modifiable) {\n+      throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n+    }\n+    for (Map.Entry<Type, T> entry : other.entrySet()) {\n+      if (!map.containsKey(entry.getKey())) {\n+        register(entry.getKey(), entry.getValue());\n+      }\n+    }\n+  }\n+\n+  public synchronized void makeUnmodifiable() {\n+    modifiable = false;\n+  }\n+\n+  public synchronized T getHandlerFor(Type type) {\n+    T handler = map.get(type);\n+    if (handler == null && type instanceof ParameterizedType) {\n+      // a handler for a non-generic version is registered, so use that\n+      Type rawType = ((ParameterizedType)type).getRawType();\n+      handler = map.get(rawType);\n+    }\n+    return handler;\n+  }\n+\n+  public synchronized boolean hasAnyHandlerFor(Type type) {\n+    return getHandlerFor(type) != null;\n+  }\n+\n+  public synchronized boolean hasSpecificHandlerFor(Type type) {\n+    return map.containsKey(type);\n+  }\n+\n+  public synchronized ParameterizedTypeHandlerMap<T> copyOf() {\n+    ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>();\n+    for (Map.Entry<Type, T> entry : map.entrySet()) {\n+      copy.register(entry.getKey(), entry.getValue());\n+    }\n+    return copy;\n+  }\n+\n+  public synchronized Set<Map.Entry<Type, T>> entrySet() {\n+    return map.entrySet();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeImpl.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+\n+/**\n+ * An immutable implementation of the {@link ParameterizedType} interface.  This object allows\n+ * us to build a reflective {@link Type} objects on demand.  This object is used to support\n+ * serialization and deserialization of classes with an {@code ParameterizedType} field where\n+ * as least one of the actual type parameters is a {@code TypeVariable}.\n+ *\n+ * <p>Here's an example class:\n+ * <pre>\n+ * class Foo<T> {\n+ *   private List<T> someList;\n+ *\n+ *   Foo(List<T> list) {\n+ *     this.someList = list;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class ParameterizedTypeImpl implements ParameterizedType {\n+\n+  private final Type rawType;\n+  private final Type[] actualTypeArguments;\n+  private final Type owner;\n+\n+  public ParameterizedTypeImpl(Type rawType, Type[] actualTypeArguments, Type owner) {\n+    this.rawType = rawType;\n+    this.actualTypeArguments = actualTypeArguments;\n+    this.owner = owner;\n+  }\n+\n+  public Type getRawType() {\n+    return rawType;\n+  }\n+\n+  public Type[] getActualTypeArguments() {\n+    return actualTypeArguments;\n+  }\n+\n+  public Type getOwnerType() {\n+    return owner;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof  ParameterizedType)) {\n+      return false;\n+    } else {\n+      // Check that information is equivalent\n+      ParameterizedType that = (ParameterizedType) o;\n+      if (this  == that)\n+      return true;\n+\n+      Type thatOwner = that.getOwnerType();\n+      Type thatRawType = that.getRawType();\n+\n+      return (owner == null ? thatOwner == null : owner.equals(thatOwner))\n+          && (rawType == null ? thatRawType == null : rawType.equals(thatRawType))\n+          && Arrays.equals(actualTypeArguments, that.getActualTypeArguments());\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Arrays.hashCode(actualTypeArguments)\n+        ^ (owner == null ? 0 : owner.hashCode())\n+        ^ (rawType == null ? 0 : rawType.hashCode());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/ParseException.java\n+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */\n+package com.google.gson;\n+\n+/**\n+ * This exception is thrown when parse errors are encountered.\n+ * You can explicitly create objects of this exception type by\n+ * calling the method generateParseException in the generated\n+ * parser.\n+ *\n+ * You can modify this class to customize your error reporting\n+ * mechanisms so long as you retain the public fields.\n+ */\n+@SuppressWarnings(\"all\")\n+final class ParseException extends Exception {\n+\n+  /**\n+   * This constructor is used by the method \"generateParseException\"\n+   * in the generated parser.  Calling this constructor generates\n+   * a new object of this type with the fields \"currentToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" set.  The boolean\n+   * flag \"specialConstructor\" is also set to true to indicate that\n+   * this constructor was used to create this object.\n+   * This constructor calls its super class with the empty string\n+   * to force the \"toString\" method of parent class \"Throwable\" to\n+   * print the error message in the form:\n+   *     ParseException: <result of getMessage>\n+   */\n+  public ParseException(Token currentTokenVal,\n+                        int[][] expectedTokenSequencesVal,\n+                        String[] tokenImageVal\n+                       )\n+  {\n+    super(\"\");\n+    specialConstructor = true;\n+    currentToken = currentTokenVal;\n+    expectedTokenSequences = expectedTokenSequencesVal;\n+    tokenImage = tokenImageVal;\n+  }\n+\n+  /**\n+   * The following constructors are for use by you for whatever\n+   * purpose you can think of.  Constructing the exception in this\n+   * manner makes the exception behave in the normal way - i.e., as\n+   * documented in the class \"Throwable\".  The fields \"errorToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n+   * relevant information.  The JavaCC generated code does not use\n+   * these constructors.\n+   */\n+\n+  public ParseException() {\n+    super();\n+    specialConstructor = false;\n+  }\n+\n+  public ParseException(String message) {\n+    super(message);\n+    specialConstructor = false;\n+  }\n+\n+  /**\n+   * This variable determines which constructor was used to create\n+   * this object and thereby affects the semantics of the\n+   * \"getMessage\" method (see below).\n+   */\n+  protected boolean specialConstructor;\n+\n+  /**\n+   * This is the last token that has been consumed successfully.  If\n+   * this object has been created due to a parse error, the token\n+   * followng this token will (therefore) be the first error token.\n+   */\n+  public Token currentToken;\n+\n+  /**\n+   * Each entry in this array is an array of integers.  Each array\n+   * of integers represents a sequence of tokens (by their ordinal\n+   * values) that is expected at this point of the parse.\n+   */\n+  public int[][] expectedTokenSequences;\n+\n+  /**\n+   * This is a reference to the \"tokenImage\" array of the generated\n+   * parser within which the parse error occurred.  This array is\n+   * defined in the generated ...Constants interface.\n+   */\n+  public String[] tokenImage;\n+\n+  /**\n+   * This method has the standard behavior when this object has been\n+   * created using the standard constructors.  Otherwise, it uses\n+   * \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n+   * error message and returns it.  If this object has been created\n+   * due to a parse error, and you do not catch it (it gets thrown\n+   * from the parser), then this method is called during the printing\n+   * of the final stack trace, and hence the correct error message\n+   * gets displayed.\n+   */\n+  public String getMessage() {\n+    if (!specialConstructor) {\n+      return super.getMessage();\n+    }\n+    StringBuffer expected = new StringBuffer();\n+    int maxSize = 0;\n+    for (int i = 0; i < expectedTokenSequences.length; i++) {\n+      if (maxSize < expectedTokenSequences[i].length) {\n+        maxSize = expectedTokenSequences[i].length;\n+      }\n+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(\" \");\n+      }\n+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n+        expected.append(\"...\");\n+      }\n+      expected.append(eol).append(\"    \");\n+    }\n+    String retval = \"Encountered \\\"\";\n+    Token tok = currentToken.next;\n+    for (int i = 0; i < maxSize; i++) {\n+      if (i != 0) retval += \" \";\n+      if (tok.kind == 0) {\n+        retval += tokenImage[0];\n+        break;\n+      }\n+      retval += add_escapes(tok.image);\n+      tok = tok.next; \n+    }\n+    retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n+    retval += \".\" + eol;\n+    if (expectedTokenSequences.length == 1) {\n+      retval += \"Was expecting:\" + eol + \"    \";\n+    } else {\n+      retval += \"Was expecting one of:\" + eol + \"    \";\n+    }\n+    retval += expected.toString();\n+    return retval;\n+  }\n+\n+  /**\n+   * The end of line string for this machine.\n+   */\n+  protected String eol = System.getProperty(\"line.separator\", \"\\n\");\n+ \n+  /**\n+   * Used to convert raw characters to their escaped version\n+   * when these raw version cannot be used as part of an ASCII\n+   * string literal.\n+   */\n+  protected String add_escapes(String str) {\n+      StringBuffer retval = new StringBuffer();\n+      char ch;\n+      for (int i = 0; i < str.length(); i++) {\n+        switch (str.charAt(i))\n+        {\n+           case 0 :\n+              continue;\n+           case '\\b':\n+              retval.append(\"\\\\b\");\n+              continue;\n+           case '\\t':\n+              retval.append(\"\\\\t\");\n+              continue;\n+           case '\\n':\n+              retval.append(\"\\\\n\");\n+              continue;\n+           case '\\f':\n+              retval.append(\"\\\\f\");\n+              continue;\n+           case '\\r':\n+              retval.append(\"\\\\r\");\n+              continue;\n+           case '\\\"':\n+              retval.append(\"\\\\\\\"\");\n+              continue;\n+           case '\\'':\n+              retval.append(\"\\\\\\'\");\n+              continue;\n+           case '\\\\':\n+              retval.append(\"\\\\\\\\\");\n+              continue;\n+           default:\n+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                 String s = \"0000\" + Integer.toString(ch, 16);\n+                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+              } else {\n+                 retval.append(ch);\n+              }\n+              continue;\n+        }\n+      }\n+      return retval.toString();\n+   }\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Preconditions.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A simple utility class used to check method Preconditions.\n+ *\n+ * <pre>\n+ * public long divideBy(long value) {\n+ *   Preconditions.checkArgument(value != 0);\n+ *   return this.value / value;\n+ * }\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class Preconditions {\n+  public static void checkNotNull(Object obj) {\n+    checkArgument(obj != null);\n+  }\n+\n+  public static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException(\"condition failed: \" + condition);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/PrimitiveTypeAdapter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Handles type conversion from some object to some primitive (or primitive\n+ * wrapper instance).\n+ *\n+ * @author Joel Leitch\n+ */\n+final class PrimitiveTypeAdapter implements TypeAdapter {\n+\n+  @SuppressWarnings({\"unchecked\"})\n+  public <T> T adaptType(Object from, Class<T> to) {\n+    Class<?> aClass = Primitives.wrap(to);\n+    if (Primitives.isWrapperType(aClass)) {\n+      if (aClass == Character.class) {\n+        String value = from.toString();\n+        if (value.length() == 1) {\n+          return (T) (Character) from.toString().charAt(0);\n+        } else {\n+          throw new JsonParseException(\"The value: \" + value + \" contains more than a character.\");\n+        }\n+      }\n+\n+      try {\n+        Constructor<?> constructor = aClass.getConstructor(String.class);\n+        return (T) constructor.newInstance(from.toString());\n+      } catch (NoSuchMethodException e) {\n+        throw new JsonParseException(e);\n+      } catch (IllegalAccessException e) {\n+        throw new JsonParseException(e);\n+      } catch (InvocationTargetException e) {\n+        throw new JsonParseException(e);\n+      } catch (InstantiationException e) {\n+        throw new JsonParseException(e);\n+      }\n+    } else if (Enum.class.isAssignableFrom(to)) {\n+      // Case where the type being adapted to is an Enum\n+      // We will try to convert from.toString() to the enum\n+      try {\n+        Method valuesMethod = to.getMethod(\"valueOf\", String.class);\n+        return (T) valuesMethod.invoke(null, from.toString());\n+      } catch (NoSuchMethodException e) {\n+        throw new RuntimeException(e);\n+      } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+      } catch (InvocationTargetException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } else {\n+      throw new JsonParseException(\n+          \"Can not adapt type \" + from.getClass() + \" to \" + to);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Primitives.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains static utility methods pertaining to primitive types and their\n+ * corresponding wrapper types.\n+ *\n+ * @author Kevin Bourrillion\n+ */\n+final class Primitives {\n+  private Primitives() {}\n+\n+  /** A map from primitive types to their corresponding wrapper types. */\n+  public static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n+\n+  /** A map from wrapper types to their corresponding primitive types. */\n+  public static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n+\n+  // Sad that we can't use a BiMap. :(\n+  \n+  static {\n+    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\n+    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n+\n+    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);\n+    add(primToWrap, wrapToPrim, byte.class, Byte.class);\n+    add(primToWrap, wrapToPrim, char.class, Character.class);\n+    add(primToWrap, wrapToPrim, double.class, Double.class);\n+    add(primToWrap, wrapToPrim, float.class, Float.class);\n+    add(primToWrap, wrapToPrim, int.class, Integer.class);\n+    add(primToWrap, wrapToPrim, long.class, Long.class);\n+    add(primToWrap, wrapToPrim, short.class, Short.class);\n+    add(primToWrap, wrapToPrim, void.class, Void.class);\n+\n+    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\n+    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n+  }\n+\n+  private static void add(Map<Class<?>, Class<?>> forward,\n+      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n+    forward.put(key, value);\n+    backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns {@code true} if {@code type} is one of the nine\n+   * primitive-wrapper types, such as {@link Integer}.\n+   *\n+   * @see Class#isPrimitive\n+   */\n+  public static boolean isWrapperType(Class<?> type) {\n+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(checkNotNull(type));\n+  }\n+\n+  private static Class<?> checkNotNull(Class<?> type) {\n+    Preconditions.checkNotNull(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> wrap(Class<T> type) {\n+    checkNotNull(type);\n+\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type);\n+    return (wrapped == null) ? type : wrapped;\n+  }\n+\n+  /**\n+   * Returns the corresponding primitive type of {@code type} if it is a\n+   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     unwrap(Integer.class) == int.class\n+   *     unwrap(int.class) == int.class\n+   *     unwrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> unwrap(Class<T> type) {\n+    checkNotNull(type);\n+\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type);\n+    return (unwrapped == null) ? type : unwrapped;\n+  }  \n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/RecursiveFieldNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A mechanism for providing custom field naming in Gson.  This allows the client code to translate\n+ * field names into a particular convention that is not supported as a normal Java field\n+ * declaration rules.  For example, Java does not support \"-\" characters in a field name.\n+ *\n+ * @author Joel Leitch\n+ */\n+abstract class RecursiveFieldNamingPolicy implements FieldNamingStrategy {\n+\n+  public final String translateName(Field f) {\n+    Preconditions.checkNotNull(f);\n+    return translateName(f.getName(), f.getGenericType(), f.getAnnotations());\n+  }\n+\n+  /**\n+   * Performs the specific string translation.\n+   *\n+   * @param target the string object that will be manipulation/translated\n+   * @param fieldType the actual type value of the field\n+   * @param annotations the annotations set on the field\n+   * @return the translated field name\n+   */\n+  protected abstract String translateName(String target, Type fieldType, Annotation[] annotations);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * A {@link FieldNamingStrategy} that acts as a chain of responsibility.  If the\n+ * {@link com.google.gson.annotations.SerializedName} annotation is applied to a field then this\n+ * strategy will translate the name to the {@code serializedName.value()}; otherwise it delegates\n+ * to the wrapped {@link FieldNamingStrategy}.\n+ *\n+ * <p>NOTE: this class performs JSON field name validation for any of the fields marked with\n+ * an {@code @SerializedName} annotation.</p>\n+ *\n+ * @see SerializedName\n+ *\n+ * @author Joel Leitch\n+ */\n+class SerializedNameAnnotationInterceptingNamingPolicy implements FieldNamingStrategy {\n+  private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\n+  private final FieldNamingStrategy delegate;\n+\n+  public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  public String translateName(Field f) {\n+    Preconditions.checkNotNull(f);\n+    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n+    if (serializedName != null) {\n+      return fieldNameValidator.validate(serializedName.value());\n+    } else {\n+      return delegate.translateName(f);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/SimpleCharStream.java\n+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */\n+package com.google.gson;\n+\n+/**\n+ * An implementation of interface CharStream, where the stream is assumed to\n+ * contain only ASCII characters (without unicode processing).\n+ */\n+\n+@SuppressWarnings(\"all\")\n+final class SimpleCharStream\n+{\n+  public static final boolean staticFlag = false;\n+  int bufsize;\n+  int available;\n+  int tokenBegin;\n+  public int bufpos = -1;\n+  protected int bufline[];\n+  protected int bufcolumn[];\n+\n+  protected int column = 0;\n+  protected int line = 1;\n+\n+  protected boolean prevCharIsCR = false;\n+  protected boolean prevCharIsLF = false;\n+\n+  protected java.io.Reader inputStream;\n+\n+  protected char[] buffer;\n+  protected int maxNextCharInd = 0;\n+  protected int inBuf = 0;\n+  protected int tabSize = 8;\n+\n+  protected void setTabSize(int i) { tabSize = i; }\n+  protected int getTabSize(int i) { return tabSize; }\n+\n+\n+  protected void ExpandBuff(boolean wrapAround)\n+  {\n+     char[] newbuffer = new char[bufsize + 2048];\n+     int newbufline[] = new int[bufsize + 2048];\n+     int newbufcolumn[] = new int[bufsize + 2048];\n+\n+     try\n+     {\n+        if (wrapAround)\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           System.arraycopy(buffer, 0, newbuffer,\n+                                             bufsize - tokenBegin, bufpos);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n+           bufcolumn = newbufcolumn;\n+\n+           maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n+        }\n+        else\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           bufcolumn = newbufcolumn;\n+\n+           maxNextCharInd = (bufpos -= tokenBegin);\n+        }\n+     }\n+     catch (Throwable t)\n+     {\n+        throw new Error(t.getMessage());\n+     }\n+\n+\n+     bufsize += 2048;\n+     available = bufsize;\n+     tokenBegin = 0;\n+  }\n+\n+  protected void FillBuff() throws java.io.IOException\n+  {\n+     if (maxNextCharInd == available)\n+     {\n+        if (available == bufsize)\n+        {\n+           if (tokenBegin > 2048)\n+           {\n+              bufpos = maxNextCharInd = 0;\n+              available = tokenBegin;\n+           }\n+           else if (tokenBegin < 0)\n+              bufpos = maxNextCharInd = 0;\n+           else\n+              ExpandBuff(false);\n+        }\n+        else if (available > tokenBegin)\n+           available = bufsize;\n+        else if ((tokenBegin - available) < 2048)\n+           ExpandBuff(true);\n+        else\n+           available = tokenBegin;\n+     }\n+\n+     int i;\n+     try {\n+        if ((i = inputStream.read(buffer, maxNextCharInd,\n+                                    available - maxNextCharInd)) == -1)\n+        {\n+           inputStream.close();\n+           throw new java.io.IOException();\n+        }\n+        else\n+           maxNextCharInd += i;\n+        return;\n+     }\n+     catch(java.io.IOException e) {\n+        --bufpos;\n+        backup(0);\n+        if (tokenBegin == -1)\n+           tokenBegin = bufpos;\n+        throw e;\n+     }\n+  }\n+\n+  public char BeginToken() throws java.io.IOException\n+  {\n+     tokenBegin = -1;\n+     char c = readChar();\n+     tokenBegin = bufpos;\n+\n+     return c;\n+  }\n+\n+  protected void UpdateLineColumn(char c)\n+  {\n+     column++;\n+\n+     if (prevCharIsLF)\n+     {\n+        prevCharIsLF = false;\n+        line += (column = 1);\n+     }\n+     else if (prevCharIsCR)\n+     {\n+        prevCharIsCR = false;\n+        if (c == '\\n')\n+        {\n+           prevCharIsLF = true;\n+        }\n+        else\n+           line += (column = 1);\n+     }\n+\n+     switch (c)\n+     {\n+        case '\\r' :\n+           prevCharIsCR = true;\n+           break;\n+        case '\\n' :\n+           prevCharIsLF = true;\n+           break;\n+        case '\\t' :\n+           column--;\n+           column += (tabSize - (column % tabSize));\n+           break;\n+        default :\n+           break;\n+     }\n+\n+     bufline[bufpos] = line;\n+     bufcolumn[bufpos] = column;\n+  }\n+\n+  public char readChar() throws java.io.IOException\n+  {\n+     if (inBuf > 0)\n+     {\n+        --inBuf;\n+\n+        if (++bufpos == bufsize)\n+           bufpos = 0;\n+\n+        return buffer[bufpos];\n+     }\n+\n+     if (++bufpos >= maxNextCharInd)\n+        FillBuff();\n+\n+     char c = buffer[bufpos];\n+\n+     UpdateLineColumn(c);\n+     return (c);\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndColumn\n+   */\n+\n+  public int getColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndLine\n+   */\n+\n+  public int getLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public int getEndColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  public int getEndLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public int getBeginColumn() {\n+     return bufcolumn[tokenBegin];\n+  }\n+\n+  public int getBeginLine() {\n+     return bufline[tokenBegin];\n+  }\n+\n+  public void backup(int amount) {\n+\n+    inBuf += amount;\n+    if ((bufpos -= amount) < 0)\n+       bufpos += bufsize;\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    available = bufsize = buffersize;\n+    buffer = new char[buffersize];\n+    bufline = new int[buffersize];\n+    bufcolumn = new int[buffersize];\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+                          int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream)\n+  {\n+     this(dstream, 1, 1, 4096);\n+  }\n+  public void ReInit(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    if (buffer == null || buffersize != buffer.length)\n+    {\n+      available = bufsize = buffersize;\n+      buffer = new char[buffersize];\n+      bufline = new int[buffersize];\n+      bufcolumn = new int[buffersize];\n+    }\n+    prevCharIsLF = prevCharIsCR = false;\n+    tokenBegin = inBuf = maxNextCharInd = 0;\n+    bufpos = -1;\n+  }\n+\n+  public void ReInit(java.io.Reader dstream, int startline,\n+                     int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public void ReInit(java.io.Reader dstream)\n+  {\n+     ReInit(dstream, 1, 1, 4096);\n+  }\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n+  {\n+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n+                          int startcolumn) throws java.io.UnsupportedEncodingException\n+  {\n+     this(dstream, encoding, startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+                          int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n+  {\n+     this(dstream, encoding, 1, 1, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream)\n+  {\n+     this(dstream, 1, 1, 4096);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n+  {\n+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                          int startcolumn, int buffersize)\n+  {\n+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n+  {\n+     ReInit(dstream, encoding, 1, 1, 4096);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream)\n+  {\n+     ReInit(dstream, 1, 1, 4096);\n+  }\n+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n+                     int startcolumn) throws java.io.UnsupportedEncodingException\n+  {\n+     ReInit(dstream, encoding, startline, startcolumn, 4096);\n+  }\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                     int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+  public String GetImage()\n+  {\n+     if (bufpos >= tokenBegin)\n+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n+     else\n+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n+                              new String(buffer, 0, bufpos + 1);\n+  }\n+\n+  public char[] GetSuffix(int len)\n+  {\n+     char[] ret = new char[len];\n+\n+     if ((bufpos + 1) >= len)\n+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n+     else\n+     {\n+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n+                                                          len - bufpos - 1);\n+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n+     }\n+\n+     return ret;\n+  }\n+\n+  public void Done()\n+  {\n+     buffer = null;\n+     bufline = null;\n+     bufcolumn = null;\n+  }\n+\n+  /**\n+   * Method to adjust line and column numbers for the start of a token.\n+   */\n+  public void adjustBeginLineColumn(int newLine, int newCol)\n+  {\n+     int start = tokenBegin;\n+     int len;\n+\n+     if (bufpos >= tokenBegin)\n+     {\n+        len = bufpos - tokenBegin + inBuf + 1;\n+     }\n+     else\n+     {\n+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n+     }\n+\n+     int i = 0, j = 0, k = 0;\n+     int nextColDiff = 0, columnDiff = 0;\n+\n+     while (i < len &&\n+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n+     {\n+        bufline[j] = newLine;\n+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n+        bufcolumn[j] = newCol + columnDiff;\n+        columnDiff = nextColDiff;\n+        i++;\n+     } \n+\n+     if (i < len)\n+     {\n+        bufline[j] = newLine++;\n+        bufcolumn[j] = newCol + columnDiff;\n+\n+        while (i++ < len)\n+        {\n+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n+              bufline[j] = newLine++;\n+           else\n+              bufline[j] = newLine;\n+        }\n+     }\n+\n+     line = bufline[j];\n+     column = bufcolumn[j];\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Token.java\n+/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */\n+package com.google.gson;\n+\n+/**\n+ * Describes the input token stream.\n+ */\n+\n+@SuppressWarnings(\"all\")\n+final class Token {\n+\n+  /**\n+   * An integer that describes the kind of this token.  This numbering\n+   * system is determined by JavaCCParser, and a table of these numbers is\n+   * stored in the file ...Constants.java.\n+   */\n+  public int kind;\n+\n+  /**\n+   * beginLine and beginColumn describe the position of the first character\n+   * of this token; endLine and endColumn describe the position of the\n+   * last character of this token.\n+   */\n+  public int beginLine, beginColumn, endLine, endColumn;\n+\n+  /**\n+   * The string image of the token.\n+   */\n+  public String image;\n+\n+  /**\n+   * A reference to the next regular (non-special) token from the input\n+   * stream.  If this is the last token from the input stream, or if the\n+   * token manager has not read tokens beyond this one, this field is\n+   * set to null.  This is true only if this token is also a regular\n+   * token.  Otherwise, see below for a description of the contents of\n+   * this field.\n+   */\n+  public Token next;\n+\n+  /**\n+   * This field is used to access special tokens that occur prior to this\n+   * token, but after the immediately preceding regular (non-special) token.\n+   * If there are no such special tokens, this field is set to null.\n+   * When there are more than one such special token, this field refers\n+   * to the last of these special tokens, which in turn refers to the next\n+   * previous special token through its specialToken field, and so on\n+   * until the first special token (whose specialToken field is null).\n+   * The next fields of special tokens refer to other special tokens that\n+   * immediately follow it (without an intervening regular token).  If there\n+   * is no such token, this field is null.\n+   */\n+  public Token specialToken;\n+\n+  /**\n+   * Returns the image.\n+   */\n+  public String toString()\n+  {\n+     return image;\n+  }\n+\n+  /**\n+   * Returns a new Token object, by default. However, if you want, you\n+   * can create and return subclass objects based on the value of ofKind.\n+   * Simply add the cases to the switch for all those special cases.\n+   * For example, if you have a subclass of Token called IDToken that\n+   * you want to create if ofKind is ID, simlpy add something like :\n+   *\n+   *    case MyParserConstants.ID : return new IDToken();\n+   *\n+   * to the following switch statement. Then you can cast matchedToken\n+   * variable to the appropriate type and use it in your lexical actions.\n+   */\n+  public static final Token newToken(int ofKind)\n+  {\n+     switch(ofKind)\n+     {\n+       default : return new Token();\n+     }\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TokenMgrError.java\n+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+final class TokenMgrError extends Error\n+{\n+   /*\n+    * Ordinals for various reasons why an Error of this type can be thrown.\n+    */\n+\n+   /**\n+    * Lexical error occured.\n+    */\n+   static final int LEXICAL_ERROR = 0;\n+\n+   /**\n+    * An attempt wass made to create a second instance of a static token manager.\n+    */\n+   static final int STATIC_LEXER_ERROR = 1;\n+\n+   /**\n+    * Tried to change to an invalid lexical state.\n+    */\n+   static final int INVALID_LEXICAL_STATE = 2;\n+\n+   /**\n+    * Detected (and bailed out of) an infinite loop in the token manager.\n+    */\n+   static final int LOOP_DETECTED = 3;\n+\n+   /**\n+    * Indicates the reason why the exception is thrown. It will have\n+    * one of the above 4 values.\n+    */\n+   int errorCode;\n+\n+   /**\n+    * Replaces unprintable characters by their espaced (or unicode escaped)\n+    * equivalents in the given string\n+    */\n+   protected static final String addEscapes(String str) {\n+      StringBuffer retval = new StringBuffer();\n+      char ch;\n+      for (int i = 0; i < str.length(); i++) {\n+        switch (str.charAt(i))\n+        {\n+           case 0 :\n+              continue;\n+           case '\\b':\n+              retval.append(\"\\\\b\");\n+              continue;\n+           case '\\t':\n+              retval.append(\"\\\\t\");\n+              continue;\n+           case '\\n':\n+              retval.append(\"\\\\n\");\n+              continue;\n+           case '\\f':\n+              retval.append(\"\\\\f\");\n+              continue;\n+           case '\\r':\n+              retval.append(\"\\\\r\");\n+              continue;\n+           case '\\\"':\n+              retval.append(\"\\\\\\\"\");\n+              continue;\n+           case '\\'':\n+              retval.append(\"\\\\\\'\");\n+              continue;\n+           case '\\\\':\n+              retval.append(\"\\\\\\\\\");\n+              continue;\n+           default:\n+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                 String s = \"0000\" + Integer.toString(ch, 16);\n+                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+              } else {\n+                 retval.append(ch);\n+              }\n+              continue;\n+        }\n+      }\n+      return retval.toString();\n+   }\n+\n+   /**\n+    * Returns a detailed message for the Error when it is thrown by the\n+    * token manager to indicate a lexical error.\n+    * Parameters : \n+    *    EOFSeen     : indicates if EOF caused the lexicl error\n+    *    curLexState : lexical state in which this error occured\n+    *    errorLine   : line number when the error occured\n+    *    errorColumn : column number when the error occured\n+    *    errorAfter  : prefix that was seen before this error occured\n+    *    curchar     : the offending character\n+    * Note: You can customize the lexical error message by modifying this method.\n+    */\n+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n+      return(\"Lexical error at line \" +\n+           errorLine + \", column \" +\n+           errorColumn + \".  Encountered: \" +\n+           (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") +\n+           \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n+   }\n+\n+   /**\n+    * You can also modify the body of this method to customize your error messages.\n+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n+    * of end-users concern, so you can return something like : \n+    *\n+    *     \"Internal Error : Please file a bug report .... \"\n+    *\n+    * from this method for such cases in the release version of your parser.\n+    */\n+   public String getMessage() {\n+      return super.getMessage();\n+   }\n+\n+   /*\n+    * Constructors of various flavors follow.\n+    */\n+\n+   public TokenMgrError() {\n+   }\n+\n+   public TokenMgrError(String message, int reason) {\n+      super(message);\n+      errorCode = reason;\n+   }\n+\n+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {\n+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n+   }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * This class is responsible for adapting/converting an particular \"from\"\n+ * instance to an instance of type \"to\".\n+ *\n+ * @author Joel Leitch\n+ */\n+interface TypeAdapter {\n+\n+  /**\n+   * Adapts an object instance \"from\" to and instance of type \"to\".\n+   *\n+   * @param from the object to adapt\n+   * @param to the Type/Class which this will convert to\n+   * @return the converted \"from\" instance to type \"to\"\n+   */\n+  public <T> T adaptType(Object from, Class<T> to);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeAdapterNotRequired.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * This class implements the {@link TypeAdapter} interface; however, if the\n+ * from instance type is the same as the to type then this object will\n+ * terminate the chain early and return the \"from\" object to the calling\n+ * class.\n+ *\n+ * If the incoming object does need some kind of conversion then this object\n+ * will delegate to the {@link TypeAdapter} that it is wrapping.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class TypeAdapterNotRequired implements TypeAdapter {\n+\n+  private final TypeAdapter delegate;\n+\n+  /**\n+   * Constructs a TypeAdapterNotRequired that will wrap the delegate instance\n+   * that is passed in.\n+   *\n+   * @param delegate the TypeConverter to delegate to if this instance can\n+   *        not handle the type adapting (can not be null)\n+   */\n+  TypeAdapterNotRequired(TypeAdapter delegate) {\n+    Preconditions.checkNotNull(delegate);\n+    this.delegate = delegate;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T adaptType(Object from, Class<T> to) {\n+    if (to.isAssignableFrom(from.getClass())) {\n+      return (T) from;\n+    }\n+    return delegate.adaptType(from, to);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeInfo.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+\n+/**\n+ * Class that provides information relevant to different parts of a type.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class TypeInfo {\n+  protected final Type actualType;\n+  protected final Class<?> rawClass;\n+\n+  TypeInfo(Type actualType) {\n+    this.actualType = actualType;\n+    rawClass = TypeUtils.toRawClass(actualType);\n+  }\n+\n+  public final Type getActualType() {\n+    return actualType;\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public final Class<?> getWrappedClass() {\n+    return Primitives.wrap(rawClass);\n+  }\n+\n+  /**\n+   * @return the raw class associated with this type\n+   */\n+  public final Class<?> getRawClass() {\n+    return rawClass;\n+  }\n+\n+  public final boolean isCollectionOrArray() {\n+    return Collection.class.isAssignableFrom(rawClass) || isArray();\n+  }\n+\n+  public final boolean isArray() {\n+    return TypeUtils.isArray(rawClass);\n+  }\n+\n+  public final boolean isEnum() {\n+    return rawClass.isEnum();\n+  }\n+\n+  public final boolean isPrimitive() {\n+    return Primitives.isWrapperType(Primitives.wrap(rawClass));\n+  }\n+\n+  public final boolean isString() {\n+    return rawClass == String.class;\n+  }\n+\n+  public final boolean isPrimitiveOrStringAndNotAnArray() {\n+    return (isPrimitive() || isString()) && !isArray();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeInfoArray.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Class to extract information about types used to define a generic array.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class TypeInfoArray extends TypeInfo {\n+  private final Class<?> componentRawType;\n+  private final Type secondLevel;\n+\n+  TypeInfoArray(Type type) {\n+    super(type);\n+    Class<?> rootComponentType = rawClass;\n+    while (rootComponentType.isArray()) {\n+      rootComponentType = rootComponentType.getComponentType();\n+    }\n+    this.componentRawType = rootComponentType;\n+    this.secondLevel = extractSecondLevelType(actualType, rawClass);\n+  }\n+\n+  private static Type extractSecondLevelType(Type actualType, Class<?> rawClass) {\n+    if (actualType instanceof GenericArrayType) {\n+      GenericArrayType castedType = (GenericArrayType) actualType;\n+      return castedType.getGenericComponentType();\n+    } else {\n+      return rawClass.getComponentType();\n+    }\n+  }\n+\n+  /**\n+   * @return the raw type unwrapped of the second level of array.\n+   * If the object is (single-dimensional or multi-dimensional) array, it is the class of the\n+   * elements of the array. For example, this method returns Foo.class for Foo[].\n+   * It will return Foo[].class for Foo[][].  For Foo<String>[][] types, it will return the type\n+   * representing Foo<String>[] (i.e. {@code new TypeToken<Foo<String>[]>() {}.getType()}).\n+   */\n+  public Type getSecondLevelType() {\n+    return secondLevel;\n+  }\n+\n+  /**\n+   * @return the raw type of the root component.\n+   * If the object is a single-dimensional array then the component type is the class of an\n+   * element of the array.\n+   * If the object is a multi-dimensional array then the component type is the class of the\n+   * inner-most array element. For example, the This method will return Foo.class for Foo[][][].\n+   */\n+  public Class<?> getComponentRawType() {\n+    return componentRawType;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeInfoFactory.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+\n+/**\n+ * A static factory class used to construct the \"TypeInfo\" objects.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class TypeInfoFactory {\n+\n+  private TypeInfoFactory() {\n+    // Not instantiable since it provides factory methods only.\n+  }\n+\n+  public static TypeInfoArray getTypeInfoForArray(Type type) {\n+    Preconditions.checkArgument(TypeUtils.isArray(type));\n+    return new TypeInfoArray(type);\n+  }\n+\n+  /**\n+   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n+   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n+   *\n+   * @param f the actual field object to retrieve the type from\n+   * @param typeDefiningF the type that contains the field {@code f}\n+   * @return the type information for the field\n+   */\n+  public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\n+    Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\n+    Type type = f.getGenericType();\n+    Type actualType = getActualType(type, typeDefiningF, classDefiningF);\n+    return new TypeInfo(actualType);\n+  }\n+\n+  private static Type getActualType(\n+      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n+    if (typeToEvaluate instanceof Class) {\n+      return typeToEvaluate;\n+    } else if (typeToEvaluate instanceof ParameterizedType) {\n+      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n+      Type owner = castedType.getOwnerType();\n+      Type[] actualTypeParameters =\n+          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n+      Type rawType = castedType.getRawType();\n+      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n+    } else if (typeToEvaluate instanceof GenericArrayType) {\n+      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n+      Type componentType = castedType.getGenericComponentType();\n+      Type actualType = getActualType(componentType, parentType, rawParentClass);\n+      if (componentType.equals(actualType)) {\n+        return castedType;\n+      } else {\n+        if (actualType instanceof Class) {\n+          return TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType));\n+        } else {\n+          return new GenericArrayTypeImpl(actualType);\n+        }\n+      }\n+    } else if (typeToEvaluate instanceof TypeVariable) {\n+      // The class definition has the actual types used for the type variables.\n+      // Find the matching actual type for the Type Variable used for the field.\n+      // For example, class Foo<A> { A a; }\n+      // new Foo<Integer>(); defines the actual type of A to be Integer.\n+      // So, to find the type of the field a, we will have to look at the class'\n+      // actual type arguments.\n+      TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n+      TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n+      ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n+      int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n+      Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n+      return actualTypeArguments[indexOfActualTypeArgument];\n+    } else if (typeToEvaluate instanceof WildcardType) {\n+      WildcardType castedType = (WildcardType) typeToEvaluate;\n+      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n+    } else {\n+      throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n+          + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n+    }\n+  }\n+\n+  private static Type[] extractRealTypes(\n+      Type[] actualTypeArguments, Type parentType, Class<?> rawParentClass) {\n+    Preconditions.checkNotNull(actualTypeArguments);\n+\n+    Type[] retTypes = new Type[actualTypeArguments.length];\n+    for (int i = 0; i < actualTypeArguments.length; ++i) {\n+      retTypes[i] = getActualType(actualTypeArguments[i], parentType, rawParentClass);\n+    }\n+    return retTypes;\n+  }\n+\n+  private static int getIndex(TypeVariable<?>[] types, TypeVariable<?> type) {\n+    for (int i = 0; i < types.length; ++i) {\n+      if (type.equals(types[i])) {\n+        return i;\n+      }\n+    }\n+    throw new IllegalStateException(\n+        \"How can the type variable not be present in the class declaration!\");\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeInfoMap.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+\n+/**\n+ * A convenience object for retrieving the map type information.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class TypeInfoMap {\n+  private final ParameterizedType mapType;\n+\n+  public TypeInfoMap(Type mapType) {\n+    if (!(mapType instanceof ParameterizedType)) {\n+      throw new IllegalArgumentException(\n+          \"Map objects need to be parameterized unless you use a custom serializer. \"\n+              + \"Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType.\");\n+    }\n+    TypeInfo rawType = new TypeInfo(mapType);\n+    Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass()));\n+    this.mapType = (ParameterizedType) mapType;\n+  }\n+\n+  public Type getKeyType() {\n+    return mapType.getActualTypeArguments()[0];\n+  }\n+\n+  public Type getValueType() {\n+    return mapType.getActualTypeArguments()[1];\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeUtils.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Utility class containing some methods for obtaining information on types.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class TypeUtils {\n+\n+  /**\n+   * Returns the actual type matching up with the first type variable.\n+   * So, for a {@code typeInfo} instance defined as:\n+   * <pre>\n+   *   class Foo<A, B> {\n+   *   }\n+   *   Type fooType = new TypeToken<Foo<Integer, String>>() {}.getType();\n+   * </pre>\n+   * <code>TypeUtils.getActualTypeForFirstTypeVariable(fooType)</code> will return Integer.class.\n+   */\n+  static Type getActualTypeForFirstTypeVariable(Type type) {\n+    if (type instanceof Class) {\n+      return Object.class;\n+    } else if (type instanceof ParameterizedType) {\n+      return ((ParameterizedType)type).getActualTypeArguments()[0];\n+    } else if (type instanceof GenericArrayType) {\n+      return getActualTypeForFirstTypeVariable(((GenericArrayType)type).getGenericComponentType());\n+    } else {\n+      throw new IllegalArgumentException(\"Type \\'\" + type + \"\\' is not a Class, \"\n+          + \"ParameterizedType, or GenericArrayType. Can't extract class.\");\n+    }\n+  }\n+\n+  static boolean isArray(Type type) {\n+    if (type instanceof Class) {\n+      return ((Class<?>)type).isArray();\n+    } else if (type instanceof GenericArrayType) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * This method returns the actual raw class associated with the specified type.\n+   */\n+  static Class<?> toRawClass(Type type) {\n+    if (type instanceof Class) {\n+      return (Class<?>) type;\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType actualType = (ParameterizedType)type;\n+      return toRawClass(actualType.getRawType());\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType actualType = (GenericArrayType) type;\n+      Class<?> rawClass = toRawClass(actualType.getGenericComponentType());\n+      return wrapWithArray(rawClass);\n+    } else {\n+      throw new IllegalArgumentException(\"Type \\'\" + type + \"\\' is not a Class, \"\n+          + \"ParameterizedType, or GenericArrayType. Can't extract class.\");\n+    }\n+  }\n+\n+  static Class<?> wrapWithArray(Class<?> rawClass) {\n+    return Array.newInstance(rawClass, 0).getClass();\n+  }\n+\n+  private TypeUtils() {\n+    // Class with just some static utility methods, should not be instantiated\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/UpperCaseNamingPolicy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n+ * upper case letters.\n+ *\n+ * <p>The following is an example:</p>\n+ * <pre>\n+ * class IntWrapper {\n+ *   public int integerField = 0;\n+ * }\n+ *\n+ * UpperCaseNamingPolicy policy = new UpperCaseNamingPolicy();\n+ * String translatedFieldName =\n+ *     policy.translateName(IntWrapper.class.getField(\"integerField\"));\n+ *\n+ * assert(\"INTEGERFIELD\".equals(translatedFieldName));\n+ * </pre>\n+ *\n+ * @author Joel Leitch\n+ */\n+class UpperCaseNamingPolicy extends RecursiveFieldNamingPolicy {\n+\n+  @Override\n+  protected String translateName(String target, Type fieldType, Annotation[] annotations) {\n+    return target.toUpperCase();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/VersionConstants.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Class contain all constants for versioning support.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class VersionConstants {\n+  // Prevent instantiation\n+  private VersionConstants() { }\n+\n+  static final double IGNORE_VERSIONS = -1D;\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Since;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+ * This strategy will exclude any files and/or class that are passed the\n+ * {@link #version} value.\n+ *\n+ * @author Joel Leitch\n+ */\n+final class VersionExclusionStrategy implements ExclusionStrategy {\n+  private final double version;\n+\n+  public VersionExclusionStrategy(double version) {\n+    Preconditions.checkArgument(version >= 0.0D);\n+    this.version = version;\n+  }\n+\n+  public boolean shouldSkipField(Field f) {\n+    return !isValidVersion(f.getAnnotations());\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return !isValidVersion(clazz.getAnnotations());\n+  }\n+\n+  private boolean isValidVersion(Annotation[] annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation instanceof Since) {\n+        double annotationVersion = ((Since) annotation).value();\n+        if (annotationVersion > version) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * An annotation that indicates this member should be exposed for JSON\n+ * serialization or deserialization.\n+ *\n+ * <p>This annotation has no effect unless you build {@link com.google.gson.Gson}\n+ * with a {@link com.google.gson.GsonBuilder} and invoke\n+ * {@link com.google.gson.GsonBuilder#excludeFieldsWithoutExposeAnnotation()}\n+ * method.</p>\n+ *\n+ * <p>Here is an example of how this annotation is meant to be used:\n+ * <p><pre>\n+ * public class User {\n+ *   &#64Expose private String firstName;\n+ *   &#64Expose private String lastName;\n+ *   &#64Expose private String emailAddress;\n+ *   private String password;\n+ * }\n+ * </pre></p>\n+ * If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}\n+ * methods will use the {@code password} field along-with {@code firstName}, {@code lastName},\n+ * and {@code emailAddress} for serialization and deserialization. However, if you created Gson\n+ * with {@code Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()}\n+ * then the {@code toJson()} and {@code fromJson()} methods of Gson will exclude the\n+ * {@code password} field. This is because the {@code password} field is not marked with the\n+ * {@code @Expose} annotation.\n+ *\n+ * <p>Note that another way to achieve the same effect would have been to just mark the\n+ * {@code password} field as {@code transient}, and Gson would have excluded it even with default\n+ * settings. The {@code @Expose} annotation is useful in a style of programming where you want to\n+ * explicitly specify all fields that should get considered for serialization or deserialization.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface Expose {\n+  // This is a marker annotation with no additional properties\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/annotations/SerializedName.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * An annotation that indicates this member should be serialized to JSON with\n+ * the provided name value as its field name.\n+ *\n+ * <p>This annotation will override any {@link com.google.gson.FieldNamingPolicy}, including\n+ * the default field naming policy, that may have been set on the {@link com.google.gson.Gson}\n+ * instance.  A different naming policy can set using the {@code GsonBuilder} class.  See\n+ * {@link com.google.gson.GsonBuilder#setFieldNamingPolicy(com.google.gson.FieldNamingPolicy)}\n+ * for more information.</p>\n+ *\n+ * <p>Here is an example of how this annotation is meant to be used:</p>\n+ * <pre>\n+ * public class SomeClassWithFields {\n+ *   &#64SerializedName(\"name\") private final String someField;\n+ *   private final String someOtherField;\n+ *\n+ *   public SomeClassWithFields(String a, String b) {\n+ *     this.someField = a;\n+ *     this.someOtherField = b;\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>The following shows the output that is generated when serializing an instance of the\n+ * above example class:</p>\n+ * <pre>\n+ * SomeClassWithFields objectToSerialize = new SomeClassWithFields(\"a\", \"b\");\n+ * Gson gson = new Gson();\n+ * String jsonRepresentation = gson.toJson(objectToSerialize);\n+ * System.out.println(jsonRepresentation);\n+ *\n+ * ===== OUTPUT =====\n+ * {\"name\":\"a\",\"someOtherField\":\"b\"}\n+ * </pre>\n+ *\n+ * <p>NOTE: The value you specify in this annotation must be a valid JSON field name.</p>\n+ *\n+ * @see com.google.gson.FieldNamingPolicy\n+ *\n+ * @author Joel Leitch\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface SerializedName {\n+\n+  /**\n+   * @return the desired name of the field when it is serialized\n+   */\n+  String value();\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/annotations/Since.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * An annotation that indicates the version number since a member or a type has been present.\n+ * This annotation is useful to manage versioning of your Json classes for a web-service.\n+ *\n+ * <p>\n+ * This annotation has no effect unless you build {@link com.google.gson.Gson} with a\n+ * {@link com.google.gson.GsonBuilder} and invoke\n+ * {@link com.google.gson.GsonBuilder#setVersion(double)} method.\n+ *\n+ * <p>Here is an example of how this annotation is meant to be used:</p>\n+ * <pre>\n+ * public class User {\n+ *   private String firstName;\n+ *   private String lastName;\n+ *   &#64Since(1.0) private String emailAddress;\n+ *   &#64Since(1.0) private String password;\n+ *   &#64Since(1.1) private Address address;\n+ * }\n+ * </pre>\n+ *\n+ * <p>If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}\n+ * methods will use all the fields for serialization and deserialization. However, if you created\n+ * Gson with {@code Gson gson = new GsonBuilder().setVersion(1.0).create()} the the\n+ * {@code toJson()} and {@code fromJson()} methods of Gson will exclude the {@code address} field\n+ * since it's version number is set to {@code 1.1}.</p>\n+ *\n+ * @author Inderjeet Singh\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD, ElementType.TYPE})\n+public @interface Since {\n+  /**\n+   * the value indicating a version number since this member\n+   * or type has been present.\n+   */\n+  double value();\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/annotations/package-info.java\n+/**\n+ * This package provides annotations that can be used with {@link com.google.gson.Gson}.\n+ * \n+ * @author Inderjeet Singh, Joel Leitch\n+ */\n+package com.google.gson.annotations;\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/package-info.java\n+/**\n+ * This package provides the {@link com.google.gson.Gson} class to convert Json to Java and\n+ * vice-versa.\n+ *\n+ * <p>The primary class to use is {@link com.google.gson.Gson} which can be constructed with\n+ * {@code new Gson()} (using default settings) or by using {@link com.google.gson.GsonBuilder}\n+ * (to configure various options such as using versioning and so on).</p>\n+ *\n+ * @author Inderjeet Singh, Joel Leitch\n+ */\n+package com.google.gson;\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.reflect;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a generic type {@code T}.\n+ *\n+ * You can use this class to get the generic type for a class. For example,\n+ * to get the generic type for <code>Collection&lt;Foo&gt;</code>, you can use:\n+ * <p>\n+ * <code>Type typeOfCollectionOfFoo = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType()\n+ * </code>\n+ * \n+ * <p>Assumes {@code Type} implements {@code equals()} and {@code hashCode()}\n+ * as a value (as opposed to identity) comparison.\n+ *\n+ * Also implements {@link #isAssignableFrom(Type)} to check type-safe\n+ * assignability.\n+ *\n+ * @author Bob Lee\n+ * @author Sven Mawson\n+ */\n+public abstract class TypeToken<T> {\n+\n+  final Class<? super T> rawType;\n+  final Type type;\n+\n+  /**\n+   * Constructs a new type token. Derives represented class from type\n+   * parameter.\n+   *\n+   * <p>Clients create an empty anonymous subclass. Doing so embeds the type\n+   * parameter in the anonymous class's type hierarchy so we can reconstitute\n+   * it at runtime despite erasure.\n+   *\n+   * <p>For example:\n+   * <code>\n+   * {@literal TypeToken<List<String>> t = new TypeToken<List<String>>}(){}\n+   * </code>\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  protected TypeToken() {\n+    this.type = getSuperclassTypeParameter(getClass());\n+    this.rawType = (Class<? super T>) getRawType(type);\n+  }\n+\n+  /**\n+   * Unsafe. Constructs a type token manually.\n+   */\n+  @SuppressWarnings({\"unchecked\"})\n+  private TypeToken(Type type) {\n+    this.rawType = (Class<? super T>) getRawType(nonNull(type, \"type\"));\n+    this.type = type;\n+  }\n+\n+  private static <T> T nonNull(T o, String message) {\n+    if (o == null) {\n+      throw new NullPointerException(message);\n+    }\n+    return o;\n+  }\n+  \n+  /**\n+   * Gets type from super class's type parameter.\n+   */\n+  static Type getSuperclassTypeParameter(Class<?> subclass) {\n+    Type superclass = subclass.getGenericSuperclass();\n+    if (superclass instanceof Class) {\n+      throw new RuntimeException(\"Missing type parameter.\");\n+    }\n+    return ((ParameterizedType) superclass).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Gets type token from super class's type parameter.\n+   */\n+  static TypeToken<?> fromSuperclassTypeParameter(Class<?> subclass) {\n+    return new SimpleTypeToken<Object>(subclass);\n+  }\n+\n+  private static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      if (rawType instanceof Class<?>) {\n+        return (Class<?>) rawType;\n+      }\n+      throw buildUnexpectedTypeError(rawType, Class.class);\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType genericArrayType = (GenericArrayType) type;\n+\n+      // TODO(jleitch): This is not the most efficient way to handle generic\n+      // arrays, but is there another way to extract the array class in a\n+      // non-hacky way (i.e. using String value class names- \"[L...\")?\n+      Object rawArrayType = Array.newInstance(\n+          getRawType(genericArrayType.getGenericComponentType()), 0);\n+      return rawArrayType.getClass();\n+    } else {\n+      throw buildUnexpectedTypeError(\n+          type, ParameterizedType.class, GenericArrayType.class);\n+    }\n+  }\n+\n+  /**\n+   * Gets the raw type.\n+   */\n+  public Class<? super T> getRawType() {\n+    return rawType;\n+  }\n+\n+  /**\n+   * Gets underlying {@code Type} instance.\n+   */\n+  public Type getType() {\n+    return type;\n+  }\n+\n+  /**\n+   * Check if this type is assignable from the given class object.\n+   */\n+  public boolean isAssignableFrom(Class<?> cls) {\n+    return isAssignableFrom((Type) cls);\n+  }\n+\n+  /**\n+   * Check if this type is assignable from the given Type.\n+   */\n+  public boolean isAssignableFrom(Type from) {\n+    if (from == null) {\n+      return false;\n+    }\n+\n+    if (type.equals(from)) {\n+      return true;\n+    }\n+\n+    if (type instanceof Class) {\n+      return rawType.isAssignableFrom(getRawType(from));\n+    } else if (type instanceof ParameterizedType) {\n+      return isAssignableFrom(from, (ParameterizedType) type,\n+          new HashMap<String, Type>());\n+    } else if (type instanceof GenericArrayType) {\n+      return rawType.isAssignableFrom(getRawType(from))\n+          && isAssignableFrom(from, (GenericArrayType) type);\n+    } else {\n+      throw buildUnexpectedTypeError(\n+          type, Class.class, ParameterizedType.class, GenericArrayType.class);\n+    }\n+  }\n+\n+  /**\n+   * Check if this type is assignable from the given type token.\n+   */\n+  public boolean isAssignableFrom(TypeToken<?> token) {\n+    return isAssignableFrom(token.getType());\n+  }\n+\n+  /**\n+   * Private helper function that performs some assignability checks for\n+   * the provided GenericArrayType.\n+   */\n+  private static boolean isAssignableFrom(Type from, GenericArrayType to) {\n+    Type toGenericComponentType = to.getGenericComponentType();\n+    if (toGenericComponentType instanceof ParameterizedType) {\n+      Type t = from;\n+      if (from instanceof GenericArrayType) {\n+        t = ((GenericArrayType) from).getGenericComponentType();\n+      } else if (from instanceof Class) {\n+        Class<?> classType = (Class<?>) from;\n+        while (classType.isArray()) {\n+          classType = classType.getComponentType();\n+        }\n+        t = classType;\n+      }\n+      return isAssignableFrom(t, (ParameterizedType) toGenericComponentType,\n+          new HashMap<String, Type>());\n+    }\n+    // No generic defined on \"to\"; therefore, return true and let other\n+    // checks determine assignability\n+    return true;\n+  }\n+\n+  /**\n+   * Private recursive helper function to actually do the type-safe checking\n+   * of assignability.\n+   */\n+  private static boolean isAssignableFrom(Type from, ParameterizedType to,\n+      Map<String, Type> typeVarMap) {\n+\n+    if (from == null) {\n+      return false;\n+    }\n+\n+    if (to.equals(from)) {\n+      return true;\n+    }\n+\n+    // First figure out the class and any type information.\n+    Class<?> clazz = getRawType(from);\n+    ParameterizedType ptype = null;\n+    if (from instanceof ParameterizedType) {\n+      ptype = (ParameterizedType) from;\n+    }\n+\n+    // Load up parameterized variable info if it was parameterized.\n+    if (ptype != null) {\n+      Type[] tArgs = ptype.getActualTypeArguments();\n+      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n+      for (int i = 0; i < tArgs.length; i++) {\n+        Type arg = tArgs[i];\n+        TypeVariable<?> var = tParams[i];\n+        while (arg instanceof TypeVariable) {\n+          TypeVariable<?> v = (TypeVariable<?>) arg;\n+          arg = typeVarMap.get(v.getName());\n+        }\n+        typeVarMap.put(var.getName(), arg);\n+      }\n+\n+      // check if they are equivalent under our current mapping.\n+      if (typeEquals(ptype, to, typeVarMap)) {\n+        return true;\n+      }\n+    }\n+\n+    for (Type itype : clazz.getGenericInterfaces()) {\n+      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n+        return true;\n+      }\n+    }\n+\n+    // Interfaces didn't work, try the superclass.\n+    Type sType = clazz.getGenericSuperclass();\n+    if (isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap))) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if two parameterized types are exactly equal, under the variable\n+   * replacement described in the typeVarMap.\n+   */\n+  private static boolean typeEquals(ParameterizedType from,\n+      ParameterizedType to, Map<String, Type> typeVarMap) {\n+    if (from.getRawType().equals(to.getRawType())) {\n+      Type[] fromArgs = from.getActualTypeArguments();\n+      Type[] toArgs = to.getActualTypeArguments();\n+      for (int i = 0; i < fromArgs.length; i++) {\n+        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if two types are the same or are equivalent under a variable mapping\n+   * given in the type map that was provided.\n+   */\n+  private static boolean matches(Type from, Type to,\n+      Map<String, Type> typeMap) {\n+    if (to.equals(from)) return true;\n+\n+    if (from instanceof TypeVariable) {\n+      return to.equals(typeMap.get(((TypeVariable<?>)from).getName()));\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Hashcode for this object.\n+   * @return hashcode for this object.\n+   */\n+  @Override public int hashCode() {\n+    return type.hashCode();\n+  }\n+\n+  /**\n+   * Method to test equality. \n+   * \n+   * @return true if this object is logically equal to the specified object, false otherwise.\n+   */\n+  @Override public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    }\n+    if (!(o instanceof TypeToken<?>)) {\n+      return false;\n+    }\n+    TypeToken<?> t = (TypeToken<?>) o;\n+    return type.equals(t.type);\n+  }\n+\n+  /**\n+   * Returns a string representation of this object.\n+   * @return a string representation of this object.\n+   */\n+  @Override public String toString() {\n+    return type instanceof Class<?>\n+        ? ((Class<?>) type).getName()\n+        : type.toString();\n+  }\n+\n+  private static AssertionError buildUnexpectedTypeError(\n+      Type token, Class<?>... expected) {\n+\n+    // Build exception message\n+    StringBuilder exceptionMessage =\n+        new StringBuilder(\"Unexpected type. Expected one of: \");\n+    for (Class<?> clazz : expected) {\n+      exceptionMessage.append(clazz.getName()).append(\", \");\n+    }\n+    exceptionMessage.append(\"but got: \").append(token.getClass().getName())\n+        .append(\", for type token: \").append(token.toString()).append('.');\n+\n+    return new AssertionError(exceptionMessage.toString());\n+  }\n+\n+  /**\n+   * Gets type token for the given {@code Type} instance.\n+   */\n+  public static TypeToken<?> get(Type type) {\n+    return new SimpleTypeToken<Object>(type);\n+  }\n+\n+  /**\n+   * Gets type token for the given {@code Class} instance.\n+   */\n+  public static <T> TypeToken<T> get(Class<T> type) {\n+    return new SimpleTypeToken<T>(type);\n+  }\n+\n+  /**\n+   * Private static class to not create more anonymous classes than\n+   * necessary.\n+   */\n+  private static class SimpleTypeToken<T> extends TypeToken<T> {\n+    public SimpleTypeToken(Type type) {\n+      super(type);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/reflect/package-info.java\n+/**\n+ * This package provides utility classes for finding type information for generic types.\n+ *  \n+ * @author Inderjeet Singh, Joel Leitch\n+ */\n+package com.google.gson.reflect;\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/CamelCaseSeparatorNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for the {@link CamelCaseSeparatorNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class CamelCaseSeparatorNamingPolicyTest extends TestCase {\n+\n+  private static final Class<String> CLASS = String.class;\n+  private static final String UNDERSCORE = \"_\";\n+  private static final String MULTI_CHAR_SEPARATOR = \"_$_\";\n+\n+  public void testInvalidInstantiation() throws Exception {\n+    try {\n+      new CamelCaseSeparatorNamingPolicy(null);\n+      fail(\"Null separator string is not supported\");\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      new CamelCaseSeparatorNamingPolicy(\"\");\n+      fail(\"Empty separator string is not supported\");\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      new CamelCaseSeparatorNamingPolicy(\" \");\n+      fail(\"space separator string is not supported\");\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      new CamelCaseSeparatorNamingPolicy(\"\\n\");\n+      fail(\"new-line separator string is not supported\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testUnderscoreSeparator() throws Exception {\n+    CamelCaseSeparatorNamingPolicy namingPolicy =\n+        new CamelCaseSeparatorNamingPolicy(UNDERSCORE);\n+    String translatedName = namingPolicy.translateName(\"testUnderscoreBetweenWords\", CLASS, null);\n+    assertEquals(\"test_Underscore_Between_Words\", translatedName);\n+  }\n+\n+  public void testMultiCharSeparator() throws Exception {\n+    CamelCaseSeparatorNamingPolicy namingPolicy =\n+        new CamelCaseSeparatorNamingPolicy(MULTI_CHAR_SEPARATOR);\n+    String translatedName = namingPolicy.translateName(\"testMultCharBetweenWords\", CLASS, null);\n+    assertEquals(\"test_$_Mult_$_Char_$_Between_$_Words\", translatedName);\n+  }\n+\n+  public void testNameBeginsWithCapital() throws Exception {\n+    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);\n+    String translatedName = namingPolicy.translateName(\"TestNameBeginsWithCapital\", CLASS, null);\n+    assertEquals(\"Test_Name_Begins_With_Capital\", translatedName);\n+  }\n+\n+  public void testExceptionPossiblyIncorrectSeparation() throws Exception {\n+    CamelCaseSeparatorNamingPolicy namingPolicy = new CamelCaseSeparatorNamingPolicy(UNDERSCORE);\n+    String translatedName = namingPolicy.translateName(\"aURL\", CLASS, null);\n+    assertEquals(\"a_U_R_L\", translatedName);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+\n+import junit.framework.TestCase;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+/**\n+ * A simple unit test for the {@link DefaultDateTypeAdapter} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class DefaultDateTypeAdapterTest extends TestCase {\n+\n+  public void testDateSerialization() throws Exception {\n+    int dateStyle = DateFormat.LONG;\n+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);\n+    DateFormat formatter = DateFormat.getDateInstance(dateStyle);\n+    Date currentDate = new Date();\n+\n+    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();\n+    assertEquals(formatter.format(currentDate), dateString);\n+  }\n+\n+  public void testDatePattern() throws Exception {\n+    String pattern = \"yyyy-MM-dd\";\n+    DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(pattern);\n+    DateFormat formatter = new SimpleDateFormat(pattern);\n+    Date currentDate = new Date();\n+\n+    String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();\n+    assertEquals(formatter.format(currentDate), dateString);\n+  }\n+\n+  public void testInvalidDatePattern() throws Exception {\n+    try {\n+      new DefaultDateTypeAdapter(\"I am a bad Date pattern....\");\n+      fail(\"Invalid date pattern should fail.\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/DefaultMapJsonSerializerTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Unit test for the default JSON map serialization object located in the\n+ * {@link DefaultTypeAdapters} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class DefaultMapJsonSerializerTest extends TestCase {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private JsonSerializer<Map> mapSerializer;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    mapSerializer = new DefaultTypeAdapters.MapTypeAdapter();\n+  }\n+\n+  public void testEmptyMapNoTypeSerialization() {\n+    Map<String, String> emptyMap = new HashMap<String, String>();\n+    try {\n+      mapSerializer.serialize(emptyMap, emptyMap.getClass(), null);\n+      fail(\"Parameterized types need to have a ParameterizedType passed in, not a Class.\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testEmptyMapSerialization() {\n+    Type mapType = new TypeToken<Map<String, String>>() { }.getType();\n+    Map<String, String> emptyMap = new HashMap<String, String>();\n+    JsonElement element = mapSerializer.serialize(emptyMap, mapType, null);\n+\n+    assertTrue(element instanceof JsonObject);\n+    JsonObject emptyMapJsonObject = (JsonObject) element;\n+    assertTrue(emptyMapJsonObject.entrySet().isEmpty());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DisjunctionExclusionStrategy;\n+import com.google.gson.ExclusionStrategy;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Unit tests for the {@link DisjunctionExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class DisjunctionExclusionStrategyTest extends TestCase {\n+\n+  private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);\n+  private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);\n+  private static final Class<?> CLAZZ = String.class;\n+  private static final Field FIELD = CLAZZ.getFields()[0];\n+\n+  public void testBadInstantiation() throws Exception {\n+    try {\n+      new DisjunctionExclusionStrategy();\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      ExclusionStrategy[] constructorParam = null;\n+      new DisjunctionExclusionStrategy(constructorParam);\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      ExclusionStrategy[] constructorParam = new ExclusionStrategy[0];\n+      new DisjunctionExclusionStrategy(constructorParam);\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      List<ExclusionStrategy> constructorParam = null;\n+      new DisjunctionExclusionStrategy(constructorParam);\n+    } catch (IllegalArgumentException expected) { }\n+\n+    try {\n+      List<ExclusionStrategy> constructorParam = new LinkedList<ExclusionStrategy>();\n+      new DisjunctionExclusionStrategy(constructorParam);\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {\n+    DisjunctionExclusionStrategy strategy =\n+        new DisjunctionExclusionStrategy(FALSE_STRATEGY, TRUE_STRATEGY);\n+\n+    assertTrue(strategy.shouldSkipClass(CLAZZ));\n+    assertTrue(strategy.shouldSkipField(FIELD));\n+  }\n+\n+  public void testSkipFieldsWithFalseOnly() throws Exception {\n+    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(FALSE_STRATEGY);\n+\n+    assertFalse(strategy.shouldSkipClass(CLAZZ));\n+    assertFalse(strategy.shouldSkipField(FIELD));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/EscaperTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Performs some unit testing for the {@link Escaper} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class EscaperTest extends TestCase {\n+\n+  public void testNoSpecialCharacters() {\n+    String value = \"Testing123\";\n+    String escapedString = Escaper.escapeJsonString(value);\n+    assertEquals(value, escapedString);\n+  }\n+\n+  public void testNewlineEscaping() throws Exception {\n+    String containsNewline = \"123\\n456\";\n+    String escapedString = Escaper.escapeJsonString(containsNewline);\n+    assertEquals(\"123\\\\n456\", escapedString);\n+  }\n+\n+  public void testCarrageReturnEscaping() throws Exception {\n+    String containsCarrageReturn = \"123\\r456\";\n+    String escapedString = Escaper.escapeJsonString(containsCarrageReturn);\n+    assertEquals(\"123\\\\r456\", escapedString);\n+  }\n+\n+  public void testTabEscaping() throws Exception {\n+    String containsTab = \"123\\t456\";\n+    String escapedString = Escaper.escapeJsonString(containsTab);\n+    assertEquals(\"123\\\\t456\", escapedString);\n+  }\n+\n+  public void testQuoteEscaping() throws Exception {\n+    String containsQuote = \"123\\\"456\";\n+    String escapedString = Escaper.escapeJsonString(containsQuote);\n+    assertEquals(\"123\\\\\\\"456\", escapedString);\n+  }\n+\n+  public void testEqualsEscaping() throws Exception {\n+    String containsEquals = \"123=456\";\n+    int index = containsEquals.indexOf('=');\n+    String unicodeValue = convertToUnicodeString(Character.codePointAt(containsEquals, index));\n+    String escapedString = Escaper.escapeJsonString(containsEquals);\n+    assertEquals(\"123\" + unicodeValue + \"456\", escapedString);\n+  }\n+\n+  public void testGreaterThanAndLessThanEscaping() throws Exception {\n+    String containsLtGt = \"123>456<\";\n+    int gtIndex = containsLtGt.indexOf('>');\n+    int ltIndex = containsLtGt.indexOf('<');\n+    String gtAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, gtIndex));\n+    String ltAsUnicode = convertToUnicodeString(Character.codePointAt(containsLtGt, ltIndex));\n+\n+    String escapedString = Escaper.escapeJsonString(containsLtGt);\n+    assertEquals(\"123\" + gtAsUnicode + \"456\" + ltAsUnicode, escapedString);\n+  }\n+\n+  public void testAmpersandEscaping() throws Exception {\n+    String containsAmp = \"123&456\";\n+    int ampIndex = containsAmp.indexOf('&');\n+    String ampAsUnicode = convertToUnicodeString(Character.codePointAt(containsAmp, ampIndex));\n+\n+    String escapedString = Escaper.escapeJsonString(containsAmp);\n+    assertEquals(\"123\" + ampAsUnicode + \"456\", escapedString);\n+\n+    char ampCharAsUnicode = '\\u0026';\n+    String containsAmpUnicode = \"123\" + ampCharAsUnicode + \"456\";\n+    escapedString = Escaper.escapeJsonString(containsAmpUnicode);\n+    assertEquals(\"123\" + ampAsUnicode + \"456\", escapedString);\n+  }\n+\n+  public void testSlashEscaping() throws Exception {\n+    String containsSlash = \"123\\\\456\";\n+    String escapedString = Escaper.escapeJsonString(containsSlash);\n+    assertEquals(\"123\\\\\\\\456\", escapedString);\n+  }\n+\n+  public void testSingleQuoteNotEscaped() throws Exception {\n+    String containsSingleQuote = \"123'456\";\n+    String escapedString = Escaper.escapeJsonString(containsSingleQuote);\n+    assertEquals(containsSingleQuote, escapedString);\n+  }\n+\n+  public void testRequiredEscapingUnicodeCharacter() throws Exception {\n+    char unicodeChar = '\\u2028';\n+    String unicodeString = \"Testing\" + unicodeChar;\n+\n+    String escapedString = Escaper.escapeJsonString(unicodeString);\n+    assertFalse(unicodeString.equals(escapedString));\n+    assertEquals(\"Testing\\\\u2028\", escapedString);\n+  }\n+\n+  public void testUnicodeCharacterStringNoEscaping() throws Exception {\n+    String unicodeString = \"\\u0065\\u0066\";\n+\n+    String escapedString = Escaper.escapeJsonString(unicodeString);\n+    assertEquals(unicodeString, escapedString);\n+  }\n+\n+  /*\n+  public void testChineseCharacterEscaping() throws Exception {\n+    String unicodeString = \"\\u597d\\u597d\\u597d\";\n+    String chineseString = \"\u597d\u597d\u597d\";\n+    assertEquals(unicodeString, chineseString);\n+\n+    String expectedEscapedString = \"\\\\u597d\\\\u597d\\\\u597d\";\n+    String escapedString = Escaper.escapeJsonString(chineseString);\n+    assertEquals(expectedEscapedString, escapedString);\n+  }\n+   */\n+\n+  private String convertToUnicodeString(int codepoint) {\n+    String hexValue = Integer.toHexString(codepoint);\n+    StringBuilder sb = new StringBuilder(\"\\\\u\");\n+    for (int i = 0; i < 4 - hexValue.length(); i++) {\n+      sb.append(0);\n+    }\n+    sb.append(hexValue);\n+\n+    return sb.toString().toLowerCase();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Expose;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Unit tests for the {@link ExposeAnnotationBasedExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ExposeAnnotationBasedExclusionStrategyTest extends TestCase {\n+  private ExposeAnnotationBasedExclusionStrategy strategy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    strategy = new ExposeAnnotationBasedExclusionStrategy();\n+  }\n+\n+  public void testNeverSkipClasses() throws Exception {\n+    assertFalse(strategy.shouldSkipClass(MockObject.class));\n+  }\n+  \n+  public void testSkipNonAnnotatedFields() throws Exception {\n+    Field f = MockObject.class.getField(\"hiddenField\");\n+    assertTrue(strategy.shouldSkipField(f));\n+  }\n+  \n+  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n+    Field f = MockObject.class.getField(\"exposedField\");\n+    assertFalse(strategy.shouldSkipField(f));\n+  }\n+\n+  private static class MockObject {\n+    @Expose\n+    public final int exposedField = 0;\n+    public final int hiddenField = 0;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/FunctionalWithInternalDependenciesTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import com.google.gson.common.TestTypes.ArrayOfObjects;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassWithNoFields;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Functional tests for Gson that depend on some internal package-protected elements of\n+ * com.google.gson package and hence must be placed in the same package. We should make every\n+ * attempt to migrate tests out of this class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class FunctionalWithInternalDependenciesTest extends TestCase {\n+  private static int INDENTATION_SIZE = 2;\n+  private static int PRINT_MARGIN = 100;\n+  private static int RIGHT_MARGIN = 8;\n+\n+  private static boolean DEBUG = false;\n+\n+  private GsonBuilder builder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    builder = new GsonBuilder();\n+  }\n+\n+  public void testAnonymousLocalClassesSerialization() {\n+    Gson gson = new Gson(new ObjectNavigatorFactory(new ModifierBasedExclusionStrategy(\n+        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY));\n+    assertEquals(\"{}\", gson.toJson(new ClassWithNoFields() {\n+      // empty anonymous class\n+    }));\n+  }\n+\n+  public void testPrettyPrintList() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    BagOfPrimitives b = new BagOfPrimitives();\n+    List<BagOfPrimitives> listOfB = new LinkedList<BagOfPrimitives>();\n+    for (int i = 0; i < 15; ++i) {\n+      listOfB.add(b);\n+    }\n+    Type typeOfSrc = new TypeToken<List<BagOfPrimitives>>() {}.getType();\n+    String json = gson.toJson(listOfB, typeOfSrc);\n+    print(json);\n+    assertPrintMargin(json);\n+  }\n+\n+  public void testPrettyPrintArrayOfObjects() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    ArrayOfObjects target = new ArrayOfObjects();\n+    String json = gson.toJson(target);\n+    print(json);\n+    assertPrintMargin(json);\n+  }\n+\n+  public void testPrettyPrintArrayOfPrimitives() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    int[] ints = new int[] { 1, 2, 3, 4, 5 };\n+    String json = gson.toJson(ints);\n+    assertEquals(\"[1,2,3,4,5]\\n\", json);\n+  }\n+\n+  public void testPrettyPrintArrayOfPrimitiveArrays() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    int[][] ints = new int[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 }, { 9, 0 }, { 10 } };\n+    String json = gson.toJson(ints);\n+    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\\n\", json);\n+  }\n+\n+  public void testPrettyPrintListOfPrimitiveArrays() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    List<Integer[]> list = Arrays.asList(new Integer[][] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 },\n+        { 9, 0 }, { 10 } });\n+    String json = gson.toJson(list);\n+    assertEquals(\"[[1,2],[3,4],[5,6],[7,8],[9,0],[10]]\\n\", json);\n+  }\n+\n+  public void testMultipleArrays() {\n+    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);\n+    Gson gson = builder.setFormatter(formatter).create();\n+    int[][][] ints = new int[][][] { {  { 1 }, { 2 } } };\n+    String json = gson.toJson(ints);\n+    assertEquals(\"[[[1],[2]]]\\n\", json);\n+  }\n+\n+  private void print(String msg) {\n+    if (DEBUG) {\n+      System.out.println(msg);\n+    }\n+  }\n+\n+  private void assertPrintMargin(String str) {\n+    int position = 0;\n+    char[] chars = str.toCharArray();\n+    for (int i = 0; i < chars.length; ++i, ++position) {\n+      char c = chars[i];\n+      if (c == '\\n') {\n+        position = 0;\n+      }\n+      assertTrue(position < PRINT_MARGIN + RIGHT_MARGIN);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeImplTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Unit tests for the {@link GenericArrayTypeImpl} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class GenericArrayTypeImplTest extends TestCase {\n+\n+  private Type parameterizedType;\n+  private Type genericArrayType;\n+  private GenericArrayTypeImpl ourType;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    parameterizedType = new TypeToken<List<String>>() {}.getType();\n+    genericArrayType = new TypeToken<List<String>[]>() {}.getType();\n+    ourType = new GenericArrayTypeImpl(parameterizedType);\n+  }\n+\n+  public void testOurTypeFunctionality() throws Exception {\n+    assertEquals(parameterizedType, ourType.getGenericComponentType());\n+    assertEquals(genericArrayType, ourType);\n+    assertEquals(genericArrayType.hashCode(), ourType.hashCode());\n+  }\n+\n+  public void testNotEquals() throws Exception {\n+    Type differentGenericArrayType = new TypeToken<List<String>[][]>() {}.getType();\n+\n+    assertFalse(differentGenericArrayType.equals(ourType));\n+    assertFalse(ourType.equals(differentGenericArrayType));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link GsonBuilder}.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class GsonBuilderTest extends TestCase {\n+\n+  public void testCreatingMoreThanOnce() {\n+    GsonBuilder builder = new GsonBuilder();\n+    builder.create();\n+    builder.create();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Contains numerous tests involving registered type converters with a Gson instance.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class GsonTypeAdapterTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new GsonBuilder()\n+        .registerTypeAdapter(AtomicLong.class, new ExceptionTypeAdapter())\n+        .registerTypeAdapter(AtomicInteger.class, new AtomicIntegerTypeAdapter())\n+        .create();\n+  }\n+\n+  public void testDefaultTypeAdapterThrowsParseException() throws Exception {\n+    try {\n+      gson.fromJson(\"{\\\"abc\\\":123}\", BigInteger.class);\n+      fail(\"Should have thrown a JsonParseException\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testTypeAdapterThrowsException() throws Exception {\n+    try {\n+      gson.toJson(new AtomicLong(0));\n+      fail(\"Type Adapter should have thrown an exception\");\n+    } catch (JsonParseException expected) { }\n+\n+    try {\n+      gson.fromJson(\"123\", AtomicLong.class);\n+      fail(\"Type Adapter should have thrown an exception\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testTypeAdapterProperlyConvertsTypes() throws Exception {\n+    int intialValue = 1;\n+    AtomicInteger atomicInt = new AtomicInteger(intialValue);\n+    String json = gson.toJson(atomicInt);\n+    assertEquals(intialValue + 1, Integer.parseInt(json));\n+\n+    atomicInt = gson.fromJson(json, AtomicInteger.class);\n+    assertEquals(intialValue, atomicInt.get());\n+  }\n+\n+  public void testTypeAdapterDoesNotAffectNonAdaptedTypes() throws Exception {\n+    String expected = \"blah\";\n+    String actual = gson.toJson(expected);\n+    assertEquals(\"\\\"\" + expected + \"\\\"\", actual);\n+\n+    actual = gson.fromJson(actual, String.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  private static class ExceptionTypeAdapter\n+      implements JsonSerializer<AtomicLong>, JsonDeserializer<AtomicLong> {\n+    public JsonElement serialize(\n+        AtomicLong src, Type typeOfSrc, JsonSerializationContext context) {\n+      throw new IllegalStateException();\n+    }\n+\n+    public AtomicLong deserialize(\n+        JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private static class AtomicIntegerTypeAdapter\n+      implements JsonSerializer<AtomicInteger>, JsonDeserializer<AtomicInteger> {\n+    public JsonElement serialize(AtomicInteger src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src.incrementAndGet());\n+    }\n+\n+    public AtomicInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      int intValue = json.getAsInt();\n+      return new AtomicInteger(--intValue);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Tests for the {@link JavaFieldNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class JavaFieldNamingPolicyTest extends TestCase {\n+\n+  private JavaFieldNamingPolicy namingPolicy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    namingPolicy = new JavaFieldNamingPolicy();\n+  }\n+\n+  public void testFieldNamingPolicy() throws Exception {\n+    Field f = String.class.getFields()[0];\n+    assertEquals(f.getName(), namingPolicy.translateName(f));\n+  }\n+\n+  public void testNullField() throws Exception {\n+    try {\n+      namingPolicy.translateName((Field) null);\n+      fail(\"Should have thrown an exception\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonDeserializerExceptionWrapperTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.text.DateFormat;\n+import java.util.Date;\n+\n+/**\n+ * Simple unit tests for the {@link JsonDeserializerExceptionWrapper} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class JsonDeserializerExceptionWrapperTest extends TestCase {\n+\n+  private static final String DATE_STRING =\n+      DateFormat.getDateInstance(DateFormat.LONG).format(new Date());\n+  private static final JsonPrimitive PRIMITIVE_ELEMENT = new JsonPrimitive(DATE_STRING);\n+\n+  public void testRethrowJsonParseException() throws Exception {\n+    String errorMsg = \"please rethrow me\";\n+    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =\n+        new JsonDeserializerExceptionWrapper<String>(\n+            new ExceptionJsonDeserializer(new JsonParseException(errorMsg)));\n+\n+    try {\n+      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);\n+      fail(\"JsonParseException should have been thrown\");\n+    } catch (JsonParseException expected) {\n+      assertNull(expected.getCause());\n+      assertEquals(errorMsg, expected.getMessage());\n+    }\n+  }\n+\n+  public void testWrappedExceptionPropagation() throws Exception {\n+    IllegalArgumentException exceptionToThrow = new IllegalArgumentException();\n+    JsonDeserializerExceptionWrapper<String> wrappedJsonSerializer =\n+        new JsonDeserializerExceptionWrapper<String>(\n+            new ExceptionJsonDeserializer(exceptionToThrow));\n+\n+    try {\n+      wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, String.class, null);\n+      fail(\"JsonParseException should have been thrown\");\n+    } catch (JsonParseException expected) {\n+      assertEquals(exceptionToThrow, expected.getCause());\n+    }\n+  }\n+\n+  public void testProperSerialization() throws Exception {\n+    DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG);\n+    JsonDeserializerExceptionWrapper<Date> wrappedJsonSerializer =\n+        new JsonDeserializerExceptionWrapper<Date>(dateSerializer);\n+\n+    Date expected = dateSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);\n+    Date actual = wrappedJsonSerializer.deserialize(PRIMITIVE_ELEMENT, Date.class, null);\n+    assertEquals(expected, actual);\n+  }\n+\n+  private static class ExceptionJsonDeserializer implements JsonDeserializer<String> {\n+    private final RuntimeException exceptionToThrow;\n+\n+    public ExceptionJsonDeserializer(RuntimeException exceptionToThrow) {\n+      this.exceptionToThrow = exceptionToThrow;\n+    }\n+\n+    public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      throw exceptionToThrow;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonEscapingVisitorTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Performs some unit testing for the {@link JsonEscapingVisitor} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class JsonEscapingVisitorTest extends TestCase {\n+  private StubbedJsonElementVisitor stubVisitor;\n+  private JsonEscapingVisitor escapingVisitor;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    stubVisitor = new StubbedJsonElementVisitor();\n+    escapingVisitor = new JsonEscapingVisitor(stubVisitor);\n+  }\n+\n+  public void testNonStringPrimitiveVisitation() throws Exception {\n+    boolean value = true;\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    escapingVisitor.visitPrimitive(primitive);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsBoolean());\n+  }\n+\n+  public void testStringPrimitiveVisitationNoEscapingRequired() throws Exception {\n+    String value = \"Testing123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    escapingVisitor.visitPrimitive(primitive);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsObject());\n+  }\n+\n+  public void testStringPrimitiveVisitationEscapingRequired() throws Exception {\n+    String value = \"Testing\\\"123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    escapingVisitor.visitPrimitive(primitive);\n+    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());\n+  }\n+\n+  public void testNonStringArrayVisitation() throws Exception {\n+    int value = 123;\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonArray array = new JsonArray();\n+    array.add(primitive);\n+    escapingVisitor.visitArrayMember(array, primitive, true);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());\n+  }\n+\n+  public void testStringArrayVisitationNoEscaping() throws Exception {\n+    String value = \"Testing123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonArray array = new JsonArray();\n+    array.add(primitive);\n+    escapingVisitor.visitArrayMember(array, primitive, true);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsString());\n+  }\n+\n+  public void testStringArrayVisitationEscapingRequired() throws Exception {\n+    String value = \"Testing\\\"123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonArray array = new JsonArray();\n+    array.add(primitive);\n+    escapingVisitor.visitArrayMember(array, primitive, true);\n+    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());\n+  }\n+\n+  public void testNonStringFieldVisitation() throws Exception {\n+    String fieldName = \"fieldName\";\n+    int value = 123;\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonObject object = new JsonObject();\n+    object.addProperty(fieldName, value);\n+\n+    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsInt());\n+  }\n+\n+  public void testStringFieldVisitationNoEscaping() throws Exception {\n+    String fieldName = \"fieldName\";\n+    String value = \"Testing123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonObject object = new JsonObject();\n+    object.addProperty(fieldName, value);\n+\n+    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);\n+    assertEquals(value, stubVisitor.primitiveReceived.getAsString());\n+  }\n+\n+  public void testStringFieldVisitationEscapingRequired() throws Exception {\n+    String fieldName = \"fieldName\";\n+    String value = \"Testing\\\"123\";\n+    JsonPrimitive primitive = new JsonPrimitive(value);\n+    JsonObject object = new JsonObject();\n+    object.addProperty(fieldName, value);\n+\n+    escapingVisitor.visitObjectMember(object, fieldName, primitive, true);\n+    assertEquals(Escaper.escapeJsonString(value), stubVisitor.primitiveReceived.getAsString());\n+  }\n+\n+  private static class StubbedJsonElementVisitor implements JsonElementVisitor {\n+    public JsonPrimitive primitiveReceived;\n+\n+    public void endArray(JsonArray array) {\n+      // Do nothing\n+    }\n+\n+    public void endObject(JsonObject object) {\n+      // Do nothing\n+    }\n+\n+    public void startArray(JsonArray array) {\n+      // Do nothing\n+    }\n+\n+    public void startObject(JsonObject object) {\n+      // Do nothing\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonPrimitive member, boolean isFirst) {\n+      primitiveReceived = member;\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonArray member, boolean isFirst) {\n+      // Do nothing\n+    }\n+\n+    public void visitArrayMember(JsonArray parent, JsonObject member, boolean isFirst) {\n+      // Do nothing\n+    }\n+\n+    public void visitObjectMember(\n+        JsonObject parent, String memberName, JsonPrimitive member, boolean isFirst) {\n+      primitiveReceived = member;\n+    }\n+\n+    public void visitObjectMember(\n+        JsonObject parent, String memberName, JsonArray member, boolean isFirst) {\n+      // Do nothing\n+    }\n+\n+    public void visitObjectMember(\n+        JsonObject parent, String memberName, JsonObject member, boolean isFirst) {\n+      // Do nothing\n+    }\n+\n+    public void visitPrimitive(JsonPrimitive primitive) {\n+      primitiveReceived = primitive;\n+    }\n+\n+    public void visitNullArrayMember(JsonArray parent, boolean isFirst) {\n+      // Do nothing\n+    }\n+\n+    public void visitNull() {\n+      // Do nothing      \n+    }\n+\n+    public void visitNullObjectMember(JsonObject parent, String memberName, boolean isFirst) {\n+      // Do nothing      \n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonFieldNameValidatorTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for the {@link JsonFieldNameValidator} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class JsonFieldNameValidatorTest extends TestCase {\n+\n+  private JsonFieldNameValidator validator;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    validator = new JsonFieldNameValidator();\n+  }\n+\n+  public void testValidFieldBeginsWithDollarSign() throws Exception {\n+    String fieldName = \"$abc\";\n+    assertEquals(fieldName, validator.validate(fieldName));\n+  }\n+\n+  public void testValidFieldBeginsWithUnderscore() throws Exception {\n+    String fieldName = \"_abc\";\n+    assertEquals(fieldName, validator.validate(fieldName));\n+  }\n+\n+  public void testValidFieldBeginsWithLetter() throws Exception {\n+    String fieldName = \"abc\";\n+    assertEquals(fieldName, validator.validate(fieldName));\n+  }\n+\n+  public void testValidFieldMixingLetter() throws Exception {\n+    String fieldName = \"$abc_12v$34\";\n+    assertEquals(fieldName, validator.validate(fieldName));\n+  }\n+\n+  public void testInvalidFieldStartingWithNumbers() throws Exception {\n+    try {\n+      validator.validate(\"1abc\");\n+      fail(\"Json field name can not start with a number\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testInvalidFieldStartingTwoDollarSigns() throws Exception {\n+    try {\n+      validator.validate(\"$$abc\");\n+      fail(\"Json field name can not start with a double dollar sign\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testInvalidFieldStartingTwoUnderscores() throws Exception {\n+    try {\n+      validator.validate(\"__abc\");\n+      fail(\"Json field name can not start with a double underscore\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testInvalidFieldStartingDollarUnderscore() throws Exception {\n+    try {\n+      validator.validate(\"$_abc\");\n+      fail(\"Json field name can not start with two non-alphabet characters\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testKeywordAsFieldName() throws Exception {\n+    try {\n+      validator.validate(\"break\");\n+      fail(\"Json field name can not be a reserved word\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testInvalidCharacters() throws Exception {\n+    try {\n+      validator.validate(\"abc.123\");\n+      fail(\"Json field name can not contain a period character\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonSerializerExceptionWrapperTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.text.DateFormat;\n+import java.util.Date;\n+\n+/**\n+ * Simple unit tests for the {@link JsonSerializerExceptionWrapper} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class JsonSerializerExceptionWrapperTest extends TestCase {\n+\n+  public void testRethrowJsonParseException() throws Exception {\n+    String errorMsg = \"please rethrow me\";\n+    JsonSerializerExceptionWrapper<String> wrappedJsonSerializer =\n+        new JsonSerializerExceptionWrapper<String>(\n+            new ExceptionJsonSerializer(new JsonParseException(errorMsg)));\n+\n+    try {\n+      wrappedJsonSerializer.serialize(\"blah\", String.class, null);\n+      fail(\"JsonParseException should have been thrown\");\n+    } catch (JsonParseException expected) {\n+      assertNull(expected.getCause());\n+      assertEquals(errorMsg, expected.getMessage());\n+    }\n+  }\n+\n+  public void testWrappedExceptionPropagation() throws Exception {\n+    IllegalArgumentException exceptionToThrow = new IllegalArgumentException();\n+    JsonSerializerExceptionWrapper<String> wrappedJsonSerializer =\n+        new JsonSerializerExceptionWrapper<String>(\n+            new ExceptionJsonSerializer(exceptionToThrow));\n+\n+    try {\n+      wrappedJsonSerializer.serialize(\"blah\", String.class, null);\n+      fail(\"JsonParseException should have been thrown\");\n+    } catch (JsonParseException expected) {\n+      assertEquals(exceptionToThrow, expected.getCause());\n+    }\n+  }\n+\n+  public void testProperSerialization() throws Exception {\n+    Date now = new Date();\n+    DefaultDateTypeAdapter dateSerializer = new DefaultDateTypeAdapter(DateFormat.LONG);\n+    JsonSerializerExceptionWrapper<Date> wrappedJsonSerializer =\n+        new JsonSerializerExceptionWrapper<Date>(dateSerializer);\n+\n+    JsonElement expected = dateSerializer.serialize(now, Date.class, null);\n+    JsonElement actual = wrappedJsonSerializer.serialize(now, Date.class, null);\n+    assertEquals(expected.getAsString(), actual.getAsString());\n+  }\n+\n+  private static class ExceptionJsonSerializer implements JsonSerializer<String> {\n+    private final RuntimeException exceptionToThrow;\n+\n+    public ExceptionJsonSerializer(RuntimeException exceptionToThrow) {\n+      this.exceptionToThrow = exceptionToThrow;\n+    }\n+\n+    public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) {\n+      throw exceptionToThrow;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/LowerCamelCaseSeparatorNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for the {@link LowerCamelCaseSeparatorNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class LowerCamelCaseSeparatorNamingPolicyTest extends TestCase {\n+\n+  private static final Class<String> CLASS = String.class;\n+  private static final String UNDERSCORE = \"_\";\n+\n+  private LowerCamelCaseSeparatorNamingPolicy namingPolicy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    namingPolicy = new LowerCamelCaseSeparatorNamingPolicy(UNDERSCORE);\n+  }\n+\n+  public void testNameBeginsWithLowerCase() throws Exception {\n+    String translatedName = namingPolicy.translateName(\"testNameBeginsWithLower\", CLASS, null);\n+    assertEquals(\"test_name_begins_with_lower\", translatedName);\n+  }\n+\n+  public void testNameBeginsWithUpperCase() throws Exception {\n+    String translatedName = namingPolicy.translateName(\"TestNameBeginsWithUpper\", CLASS, null);\n+    assertEquals(\"test_name_begins_with_upper\", translatedName);\n+  }\n+\n+  public void testExceptionPossiblyIncorrectSeparation() throws Exception {\n+    String translatedName = namingPolicy.translateName(\"aURL\", CLASS, null);\n+    assertEquals(\"a_u_r_l\", translatedName);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/LowerCaseNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.LowerCaseNamingPolicy;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for the {@link LowerCaseNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class LowerCaseNamingPolicyTest extends TestCase {\n+  private static final String ALL_LOWER = \"abcdefg\";\n+  private static final String ALL_UPPER = \"ABCDEFG\";\n+  private static final String MIXED = \"aBcdeFg\";\n+\n+  private LowerCaseNamingPolicy namingPolicy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    namingPolicy = new LowerCaseNamingPolicy();\n+  }\n+\n+  public void testAllLowerCase() throws Exception {\n+    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_LOWER, String.class, null));\n+  }\n+\n+  public void testAllUpperCase() throws Exception {\n+    assertEquals(ALL_LOWER, namingPolicy.translateName(ALL_UPPER, String.class, null));\n+  }\n+\n+  public void testMixedCase() throws Exception {\n+    assertEquals(ALL_LOWER, namingPolicy.translateName(MIXED, String.class, null));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.MemoryRefStack;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.EmptyStackException;\n+\n+/**\n+ * Unit tests for the {@link MemoryRefStack} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class MemoryRefStackTest extends TestCase {\n+  private MemoryRefStack<MockObject> stack;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    stack = new MemoryRefStack<MockObject>();\n+  }\n+\n+  public void testPeekEmptyStack() throws Exception {\n+    try {\n+      stack.peek();\n+    } catch (EmptyStackException expected) { }\n+  }\n+\n+  public void testPushPeekAndPop() throws Exception {\n+    MockObject obj = new MockObject();\n+\n+    assertEquals(obj, stack.push(obj));\n+    assertEquals(obj, stack.peek());\n+    assertEquals(obj, stack.pop());\n+  }\n+\n+  public void testPopTooMany() throws Exception {\n+    MockObject obj = new MockObject();\n+    stack.push(obj);\n+    assertEquals(obj, stack.pop());\n+\n+    try {\n+      stack.pop();\n+    } catch (EmptyStackException expected) { }\n+  }\n+\n+  public void testContains() throws Exception {\n+    MockObject objA = new MockObject();\n+    MockObject objB = new MockObject();\n+    assertEquals(objA, objB);\n+\n+    stack.push(objA);\n+    assertFalse(stack.contains(objB));\n+    assertTrue(stack.contains(objA));\n+  }\n+\n+  private static class MockObject {\n+    private final int value = 1;\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      return obj instanceof MockObject && value == ((MockObject) obj).value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return value;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/MockExclusionStrategy.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.ExclusionStrategy;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * This is a configurable {@link ExclusionStrategy} that can be used for\n+ * unit testing. \n+ *\n+ * @author Joel Leitch\n+ */\n+public class MockExclusionStrategy implements ExclusionStrategy {\n+  private final boolean skipClass;\n+  private final boolean skipField;\n+\n+  public MockExclusionStrategy(boolean skipClass, boolean skipField) {\n+    this.skipClass = skipClass;\n+    this.skipField = skipField;\n+  }\n+\n+  public boolean shouldSkipField(Field f) {\n+    return skipField;\n+  }\n+\n+  public boolean shouldSkipClass(Class<?> clazz) {\n+    return skipClass;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ModifyFirstLetterNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link com.google.gson.ModifyFirstLetterNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ModifyFirstLetterNamingPolicyTest extends TestCase {\n+\n+  public void testInvalidConstruction() throws Exception {\n+    try {\n+      new ModifyFirstLetterNamingPolicy(null);\n+      fail(\"Null values are not allowed as a constructor parameters\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testLowerCaseFirstLetter() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);\n+    assertEquals(\"blah\", policy.translateName(\"Blah\", String.class, null));\n+    assertEquals(\"blah\", policy.translateName(\"blah\", String.class, null));\n+  }\n+\n+  public void testUpperCaseFirstLetter() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"Blah\", policy.translateName(\"blah\", String.class, null));\n+    assertEquals(\"Blah\", policy.translateName(\"Blah\", String.class, null));\n+  }\n+\n+  public void testSingleCharacterField() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"B\", policy.translateName(\"b\", String.class, null));\n+    assertEquals(\"B\", policy.translateName(\"B\", String.class, null));\n+  }\n+\n+  public void testFieldStartsWithUnderscore() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"_Blah\", policy.translateName(\"_blah\", String.class, null));\n+    assertEquals(\"_Blah\", policy.translateName(\"_Blah\", String.class, null));\n+  }\n+\n+  public void testFieldStartsWithUnderscoreFollowedBySingleLetter() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"_B\", policy.translateName(\"_b\", String.class, null));\n+    assertEquals(\"_B\", policy.translateName(\"_B\", String.class, null));\n+  }\n+\n+  public void testFieldHasSingleNonLetter() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);\n+    assertEquals(\"_\", policy.translateName(\"_\", String.class, null));\n+\n+    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"_\", policy.translateName(\"_\", String.class, null));\n+  }\n+\n+  public void testFieldHasNoLetters() throws Exception {\n+    ModifyFirstLetterNamingPolicy policy =\n+        new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.LOWER);\n+    assertEquals(\"$_$\", policy.translateName(\"$_$\", String.class, null));\n+\n+    policy = new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER);\n+    assertEquals(\"$_$\", policy.translateName(\"$_$\", String.class, null));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.NullExclusionStrategy;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link NullExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class NullExclusionStrategyTest extends TestCase {\n+  private NullExclusionStrategy strategy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    strategy = new NullExclusionStrategy();\n+  }\n+\n+  public void testNeverSkipsClass() throws Exception {\n+    assertFalse(strategy.shouldSkipClass(String.class));\n+  }\n+\n+  public void testNeverSkipsField() throws Exception {\n+    assertFalse(strategy.shouldSkipField(\"\".getClass().getFields()[0]));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Unit tests for the {@link ParameterizedTypeHandlerMap} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ParameterizedTypeHandlerMapTest extends TestCase {\n+  private ParameterizedTypeHandlerMap<String> paramMap;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    paramMap = new ParameterizedTypeHandlerMap<String>();\n+  }\n+\n+  public void testNullMap() throws Exception {\n+    assertFalse(paramMap.hasSpecificHandlerFor(String.class));\n+    assertFalse(paramMap.hasAnyHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class));\n+  }\n+\n+  public void testHasGenericButNotSpecific() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(List.class, handler);\n+\n+    assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n+    assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n+    assertTrue(paramMap.hasAnyHandlerFor(specificType));\n+    assertTrue(paramMap.hasAnyHandlerFor(List.class));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+  }\n+\n+  public void testHasSpecificType() throws Exception {\n+    Type specificType = new TypeToken<List<String>>() {}.getType();\n+    String handler = \"blah\";\n+    paramMap.register(specificType, handler);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n+    assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n+    assertTrue(paramMap.hasAnyHandlerFor(specificType));\n+    assertFalse(paramMap.hasAnyHandlerFor(List.class));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+  }\n+\n+  public void testTypeOverridding() throws Exception {\n+    String handler1 = \"blah1\";\n+    String handler2 = \"blah2\";\n+    paramMap.register(String.class, handler1);\n+    paramMap.register(String.class, handler2);\n+\n+    assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n+    assertEquals(handler2, paramMap.getHandlerFor(String.class));\n+  }\n+\n+  public void testMakeUnmodifiable() throws Exception {\n+    paramMap.makeUnmodifiable();\n+    try {\n+     paramMap.register(String.class, \"blah\");\n+     fail(\"Can not register handlers when map is unmodifiable\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeImplTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Unit tests for the {@link ParameterizedTypeImpl} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ParameterizedTypeImplTest extends TestCase {\n+\n+  private Type parameterizedType;\n+  private ParameterizedTypeImpl ourType;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    parameterizedType = new TypeToken<List<String>>() {}.getType();\n+    ourType = new ParameterizedTypeImpl(List.class, new Type[] { String.class }, null);\n+  }\n+\n+  public void testOurTypeFunctionality() throws Exception {\n+    assertNull(ourType.getOwnerType());\n+    assertEquals(String.class, ourType.getActualTypeArguments()[0]);\n+    assertEquals(List.class, ourType.getRawType());\n+    assertEquals(parameterizedType, ourType);\n+    assertEquals(parameterizedType.hashCode(), ourType.hashCode());\n+  }\n+\n+  public void testNotEquals() throws Exception {\n+    Type differentParameterizedType = new TypeToken<List<Integer>>() {}.getType();\n+    assertFalse(differentParameterizedType.equals(ourType));\n+    assertFalse(ourType.equals(differentParameterizedType));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * This class contains some test fixtures for Parameterized types. These classes should ideally\n+ * belong either in the common or functional package, but they are placed here because they need\n+ * access to package protected elements of com.google.gson.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ParamterizedTypeFixtures {\n+\n+  public static class MyParameterizedType<T> {\n+    public final T value;\n+    public MyParameterizedType(T value) {\n+      this.value = value;\n+    }\n+    public T getValue() {\n+      return value;\n+    }\n+\n+    public String getExpectedJson() {\n+      String valueAsJson = getExpectedJson(value);\n+      return String.format(\"{\\\"value\\\":%s}\", valueAsJson);\n+    }\n+\n+    private String getExpectedJson(Object obj) {\n+      Class<?> clazz = obj.getClass();\n+      if (Primitives.isWrapperType(Primitives.wrap(clazz))) {\n+        return obj.toString();\n+      } else if (obj.getClass().equals(String.class)) {\n+        return \"\\\"\" + obj.toString() + \"\\\"\";\n+      } else {\n+        // Try invoking a getExpectedJson() method if it exists\n+        try {\n+          Method method = clazz.getMethod(\"getExpectedJson\");\n+          Object results = method.invoke(obj);\n+          return (String) results;\n+        } catch (SecurityException e) {\n+          throw new RuntimeException(e);\n+        } catch (NoSuchMethodException e) {\n+          throw new RuntimeException(e);\n+        } catch (IllegalArgumentException e) {\n+          throw new RuntimeException(e);\n+        } catch (IllegalAccessException e) {\n+          throw new RuntimeException(e);\n+        } catch (InvocationTargetException e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return value == null ? 0 : value.hashCode();\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (this == obj) {\n+        return true;\n+      }\n+      if (obj == null) {\n+        return false;\n+      }\n+      if (getClass() != obj.getClass()) {\n+        return false;\n+      }\n+      MyParameterizedType other = (MyParameterizedType) obj;\n+      if (value == null) {\n+        if (other.value != null) {\n+          return false;\n+        }\n+      } else if (!value.equals(other.value)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+  }\n+\n+  public static class MyParameterizedTypeInstanceCreator<T>\n+      implements InstanceCreator<MyParameterizedType<T>>{\n+    private final T instanceOfT;\n+    /**\n+     * Caution the specified instance is reused by the instance creator for each call.\n+     * This means that the fields of the same objects will be overwritten by Gson.\n+     * This is usually fine in tests since there we deserialize just once, but quite\n+     * dangerous in practice.\n+     *\n+     * @param instanceOfT\n+     */\n+    public MyParameterizedTypeInstanceCreator(T instanceOfT) {\n+      this.instanceOfT = instanceOfT;\n+    }\n+    public MyParameterizedType<T> createInstance(Type type) {\n+      return new MyParameterizedType<T>(instanceOfT);\n+    }\n+  }\n+\n+  public static class MyParameterizedTypeAdapter<T>\n+  implements JsonSerializer<MyParameterizedType<T>>, JsonDeserializer<MyParameterizedType<T>> {\n+    @SuppressWarnings(\"unchecked\")\n+    public static<T> String getExpectedJson(MyParameterizedType<T> obj) {\n+      Class<T> clazz = (Class<T>) obj.value.getClass();\n+      boolean addQuotes = !clazz.isArray() && !Primitives.unwrap(clazz).isPrimitive();\n+      StringBuilder sb = new StringBuilder(\"{\\\"\");\n+      sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\n+      if (addQuotes) {\n+        sb.append(\"\\\"\");\n+      }\n+      sb.append(obj.value.toString());\n+      if (addQuotes) {\n+        sb.append(\"\\\"\");\n+      }\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+\n+    public JsonElement serialize(MyParameterizedType<T> src, Type classOfSrc,\n+        JsonSerializationContext context) {\n+      JsonObject json = new JsonObject();\n+      T value = src.getValue();\n+      json.add(value.getClass().getSimpleName(), context.serialize(value));\n+      return json;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n+        JsonDeserializationContext context) throws JsonParseException {\n+      Type genericClass = TypeUtils.getActualTypeForFirstTypeVariable(typeOfT);\n+      TypeInfo typeInfo = new TypeInfo(genericClass);\n+      String className = typeInfo.getRawClass().getSimpleName();\n+      T value = (T) json.getAsJsonObject().get(className).getAsObject();\n+      if (typeInfo.isPrimitive()) {\n+        PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n+        value = (T) typeAdapter.adaptType(value, typeInfo.getRawClass());\n+      }\n+      return new MyParameterizedType<T>(value);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/PrimitiveTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Performs some unit testing for the {@link PrimitiveTypeAdapter} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class PrimitiveTypeAdapterTest extends TestCase {\n+  private PrimitiveTypeAdapter typeAdapter;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    typeAdapter = new PrimitiveTypeAdapter();\n+  }\n+\n+  public void testImproperConversion() throws Exception {\n+    double someValue = 1.0;\n+    try {\n+      typeAdapter.adaptType(someValue, String.class);\n+      fail(\"Should not be able to convert incompatible types.\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testImproperCharacterConversion() throws Exception {\n+    String someValue = \"test123\";\n+    try {\n+      typeAdapter.adaptType(someValue, Character.class);\n+      fail(\"Should not be able to convert incompatible types.\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testProperPrimitiveConversions() throws Exception {\n+    String stringValue = \"1.0\";\n+    Double actualValue = typeAdapter.adaptType(stringValue, Double.class);\n+    assertEquals(1.0, actualValue.doubleValue(), 0.0001);\n+\n+    Double doubleValue = 1.0;\n+    actualValue = typeAdapter.adaptType(doubleValue, Double.class);\n+    assertEquals(1.0, actualValue.doubleValue(), 0.0001);\n+\n+    stringValue = \"A\";\n+    Character actualCharacter = typeAdapter.adaptType(stringValue, Character.class);\n+    assertEquals('A', actualCharacter.charValue());\n+  }\n+\n+  public void testProperEnumConversions() throws Exception {\n+    TestEnum expected = TestEnum.TEST1;\n+    TestEnum actual = typeAdapter.adaptType(expected, TestEnum.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  private static enum TestEnum {\n+    TEST1, TEST2, TEST3\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Unit tests for the {@link SerializedNameAnnotationInterceptingNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class SerializedNameAnnotationInterceptingNamingPolicyTest extends TestCase {\n+  private static final String ANNOTATED_FIELD_NAME = \"annotatedFieldName\";\n+\n+  private SerializedNameAnnotationInterceptingNamingPolicy policy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    policy = new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy());\n+  }\n+\n+  public void testFieldWithAnnotation() throws Exception {\n+    String fieldName = \"fieldWithAnnotation\";\n+    Field f = SomeObject.class.getField(fieldName);\n+\n+    assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));\n+    assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));\n+  }\n+\n+  public void testFieldWithoutAnnotation() throws Exception {\n+    String fieldName = \"fieldWithoutAnnotation\";\n+    Field f = SomeObject.class.getField(fieldName);\n+\n+    assertEquals(fieldName, policy.translateName(f));\n+  }\n+\n+  private static class SomeObject {\n+    @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;\n+    public final int fieldWithoutAnnotation = 1;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/TypeInfoArrayTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Small test for the {@link TypeInfoArray}.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class TypeInfoArrayTest extends TestCase {\n+\n+  public void testArray() {\n+    String[] a = {\"a\", \"b\", \"c\"};\n+    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());\n+    assertEquals(a.getClass(), typeInfo.getRawClass());\n+    assertEquals(String.class, typeInfo.getComponentRawType());\n+  }\n+\n+  public void testArrayOfArrays() {\n+    String[][] a = {\n+        new String[]{\"a1\", \"a2\", \"a3\"},\n+        new String[]{\"b1\", \"b2\", \"b3\"},\n+        new String[]{\"c1\", \"c2\", \"c3\"}};\n+    TypeInfoArray typeInfo = new TypeInfoArray(a.getClass());\n+    assertEquals(a.getClass(), typeInfo.getRawClass());\n+    assertEquals(String.class, typeInfo.getComponentRawType());\n+    assertEquals(String[].class, typeInfo.getSecondLevelType());\n+  }\n+\n+  public void testParameterizedArray() {\n+    Type type = new TypeToken<List<String>[]>() {}.getType();\n+    TypeInfoArray typeInfo = new TypeInfoArray(type);\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+    assertEquals(List.class, typeInfo.getComponentRawType());\n+  }\n+\n+  public void testParameterizedArrayOfArrays() {\n+    Type type = new TypeToken<List<String>[][]>() {}.getType();\n+    Type secondLevelType = new TypeToken<List<String>[]>() {}.getType();\n+\n+    TypeInfoArray typeInfo = new TypeInfoArray(type);\n+    assertEquals(List[][].class, typeInfo.getRawClass());\n+    assertEquals(secondLevelType, typeInfo.getSecondLevelType());\n+    assertEquals(List.class, typeInfo.getComponentRawType());\n+  }\n+\n+  public void testNestedParameterizedArray() {\n+    Type type = new TypeToken<List<List<String>>[]>() {}.getType();\n+    Type secondLevelType = new TypeToken<List<List<String>>>() {}.getType();\n+\n+    TypeInfoArray typeInfo = new TypeInfoArray(type);\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+    assertEquals(secondLevelType, typeInfo.getSecondLevelType());\n+    assertEquals(List.class, typeInfo.getComponentRawType());\n+  }\n+\n+  public void testPrimitiveArray() throws Exception {\n+    TypeInfoArray arrayTypeInfo = new TypeInfoArray(int[].class);\n+\n+    assertTrue(arrayTypeInfo.isArray());\n+    assertEquals(int.class, arrayTypeInfo.getSecondLevelType());\n+    assertFalse(arrayTypeInfo.isPrimitiveOrStringAndNotAnArray());\n+  }\n+\n+  public void testStringArray() throws Exception {\n+    TypeInfoArray arrayTypeInfo = new TypeInfoArray(String[].class);\n+\n+    assertTrue(arrayTypeInfo.isArray());\n+    assertEquals(String.class, arrayTypeInfo.getSecondLevelType());\n+    assertEquals(String[].class, arrayTypeInfo.getRawClass());\n+  }\n+\n+  public void testPrimitiveArrayType() throws Exception {\n+    TypeInfoArray typeInfo = new TypeInfoArray(long[].class);\n+    assertTrue(typeInfo.isArray());\n+    assertEquals(long.class, typeInfo.getSecondLevelType());\n+    assertEquals(long[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testStringArrayType() throws Exception {\n+    TypeInfoArray typeInfo = new TypeInfoArray(String[].class);\n+    assertTrue(typeInfo.isArray());\n+    assertEquals(String[].class, typeInfo.getRawClass());\n+    assertEquals(String.class, typeInfo.getSecondLevelType());\n+  }\n+\n+  public void testArrayAsParameterizedTypes() throws Exception {\n+    Type type = new TypeToken<List<String>[]>() {}.getType();\n+    Type secondLevelType = new TypeToken<List<String>>() {}.getType();\n+\n+    TypeInfoArray typeInfo = new TypeInfoArray(type);\n+    assertTrue(typeInfo.isArray());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+    assertEquals(secondLevelType, typeInfo.getSecondLevelType());\n+\n+    Type actualType = typeInfo.getActualType();\n+    assertEquals(type, actualType);\n+    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(actualType);\n+    assertEquals(String.class, actualTypeForFirstTypeVariable);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/TypeInfoFactoryTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Small test to ensure that the TypeInfoFactory is return the object that we expect.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class TypeInfoFactoryTest extends TestCase {\n+\n+  private static Type OBJ_TYPE = new TypeToken<ObjectWithDifferentFields<Integer>>() {}.getType();\n+  private ObjectWithDifferentFields<Integer> obj;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    obj = new ObjectWithDifferentFields<Integer>();\n+  }\n+\n+  public void testSimpleField() throws Exception {\n+    Field f = obj.getClass().getField(\"simpleField\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(String.class, typeInfo.getActualType());\n+    assertEquals(String.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testEnumField() throws Exception {\n+    Field f = obj.getClass().getField(\"enumField\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertTrue(typeInfo.isEnum());\n+    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getActualType());\n+    assertEquals(ObjectWithDifferentFields.TestEnum.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testParameterizedTypeField() throws Exception {\n+    Type listType = new TypeToken<List<String>>() {}.getType();\n+    Field f = obj.getClass().getField(\"simpleParameterizedType\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testNestedParameterizedTypeField() throws Exception {\n+    Type listType = new TypeToken<List<List<String>>>() {}.getType();\n+    Field f = obj.getClass().getField(\"simpleNestedParameterizedType\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testGenericArrayTypeField() throws Exception {\n+    Type listType = new TypeToken<List<String>[]>() {}.getType();\n+    Field f = obj.getClass().getField(\"simpleGenericArray\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testTypeVariableField() throws Exception {\n+    Field f = obj.getClass().getField(\"typeVariableObj\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(Integer.class, typeInfo.getActualType());\n+    assertEquals(Integer.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testTypeVariableArrayField() throws Exception {\n+    Field f = obj.getClass().getField(\"typeVariableArray\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(Integer[].class, typeInfo.getActualType());\n+    assertEquals(Integer[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testMutliDimensionalTypeVariableArrayField() throws Exception {\n+    Field f = obj.getClass().getField(\"mutliDimensionalTypeVariableArray\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(Integer[][][].class, typeInfo.getActualType());\n+    assertEquals(Integer[][][].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testParameterizedTypeVariableField() throws Exception {\n+    Type listType = new TypeToken<List<Integer>>() {}.getType();\n+    Field f = obj.getClass().getField(\"listOfTypeVariables\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testNestedParameterizedTypeVariableField() throws Exception {\n+    Type listType = new TypeToken<List<List<Integer>>>() {}.getType();\n+    Field f = obj.getClass().getField(\"listOfListsOfTypeVariables\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testParameterizedTypeVariableArrayField() throws Exception {\n+    Type listType = new TypeToken<List<Integer>[]>() {}.getType();\n+    Field f = obj.getClass().getField(\"listOfTypeVariablesArray\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<Object>>() {}.getType();\n+    Field f = obj.getClass().getField(\"listWithWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testArrayOfWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<Object>[]>() {}.getType();\n+    Field f = obj.getClass().getField(\"arrayOfListWithWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testListStringWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<String>>() {}.getType();\n+    Field f = obj.getClass().getField(\"listWithStringWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testArrayOfListStringWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<String>[]>() {}.getType();\n+    Field f = obj.getClass().getField(\"arrayOfListWithStringWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+  }\n+\n+  public void testListTypeVariableWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<Integer>>() {}.getType();\n+    Field f = obj.getClass().getField(\"listWithTypeVariableWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testArrayOfListTypeVariableWildcardField() throws Exception {\n+    Type listType = new TypeToken<List<Integer>[]>() {}.getType();\n+    Field f = obj.getClass().getField(\"arrayOfListWithTypeVariableWildcard\");\n+    TypeInfo typeInfo = TypeInfoFactory.getTypeInfoForField(f, OBJ_TYPE);\n+\n+    assertTrue(typeInfo.isArray());\n+    assertFalse(typeInfo.isEnum());\n+    assertEquals(listType, typeInfo.getActualType());\n+    assertEquals(List[].class, typeInfo.getRawClass());\n+  }\n+\n+  private static class ObjectWithDifferentFields<T> {\n+    public static enum TestEnum {\n+      TEST_1, TEST_2;\n+    }\n+\n+    public String simpleField;\n+    public TestEnum enumField;\n+    public List<String> simpleParameterizedType;\n+    public List<List<String>> simpleNestedParameterizedType;\n+    public List<String>[] simpleGenericArray;\n+\n+    public T typeVariableObj;\n+    public T[] typeVariableArray;\n+    public T[][][] mutliDimensionalTypeVariableArray;\n+    public List<T> listOfTypeVariables;\n+    public List<List<T>> listOfListsOfTypeVariables;\n+    public List<T>[] listOfTypeVariablesArray;\n+\n+    public List<?> listWithWildcard;\n+    public List<?>[] arrayOfListWithWildcard;\n+    public List<? extends String> listWithStringWildcard;\n+    public List<? extends String>[] arrayOfListWithStringWildcard;\n+\n+    public List<? extends T> listWithTypeVariableWildcard;\n+    public List<? extends T>[] arrayOfListWithTypeVariableWildcard;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/TypeInfoMapTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Unit test for the default JSON map serialization object located in the\n+ * {@link DefaultTypeAdapters} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class TypeInfoMapTest extends TestCase {\n+\n+  public void testInvalidConstruction() throws Exception {\n+    try {\n+      new TypeInfoMap(String.class);\n+      fail(\"Must be a ParameterizedType\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testNonMapConstruction() throws Exception {\n+    try {\n+      Type parameterizedMapType = new TypeToken<List<String>>() {}.getType();\n+      new TypeInfoMap(parameterizedMapType);\n+      fail(\"The raw type must be a Map\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testBasicGetters() throws Exception {\n+    Type parameterizedMapType = new TypeToken<Map<String, Integer>>() {}.getType();\n+    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);\n+\n+    assertEquals(String.class, mapTypeInfo.getKeyType());\n+    assertEquals(Integer.class, mapTypeInfo.getValueType());\n+  }\n+\n+  public void testMapImplementations() throws Exception {\n+    Type parameterizedMapType = new TypeToken<HashMap<String, Integer>>() {}.getType();\n+    TypeInfoMap mapTypeInfo = new TypeInfoMap(parameterizedMapType);\n+\n+    assertEquals(String.class, mapTypeInfo.getKeyType());\n+    assertEquals(Integer.class, mapTypeInfo.getValueType());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/TypeInfoTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+/**\n+ * Exercising the construction of the Parameter object and ensure the\n+ * proper types are returned.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class TypeInfoTest extends TestCase {\n+\n+  public void testPrimitive() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(boolean.class);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isString());\n+    assertTrue(typeInfo.isPrimitive());\n+    assertEquals(boolean.class, typeInfo.getRawClass());\n+    assertEquals(Boolean.class, typeInfo.getWrappedClass());\n+  }\n+\n+  public void testPrimitiveWrapper() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(Integer.class);\n+\n+    assertEquals(Integer.class, typeInfo.getRawClass());\n+    assertTrue(typeInfo.isPrimitive());\n+    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());\n+  }\n+\n+  public void testString() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(String.class);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isPrimitive());\n+    assertEquals(String.class, typeInfo.getRawClass());\n+    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());\n+  }\n+\n+  public void testObject() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(Object.class);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertFalse(typeInfo.isPrimitive());\n+    assertEquals(Object.class, typeInfo.getRawClass());\n+    assertFalse(typeInfo.isPrimitiveOrStringAndNotAnArray());\n+  }\n+\n+  public void testPrimitiveType() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(long.class);\n+    assertFalse(typeInfo.isArray());\n+    assertEquals(long.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testObjectType() throws Exception {\n+    TypeInfo typeInfo = new TypeInfo(String.class);\n+    assertFalse(typeInfo.isArray());\n+    assertTrue(typeInfo.isString());\n+    assertEquals(String.class, typeInfo.getRawClass());\n+  }\n+\n+  public void testParameterizedTypes() throws Exception {\n+    Type type = new TypeToken<List<String>>() {}.getType();\n+    TypeInfo typeInfo = new TypeInfo(type);\n+\n+    assertFalse(typeInfo.isArray());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+    assertEquals(type, typeInfo.getActualType());\n+  }\n+\n+  public void testGenericizedGenericType() throws Exception {\n+    Type type = new TypeToken<List<List<String>>>() {}.getType();\n+    Type genericType = new TypeToken<List<String>>() {}.getType();\n+\n+    TypeInfo typeInfo = new TypeInfo(type);\n+    assertFalse(typeInfo.isArray());\n+    assertEquals(List.class, typeInfo.getRawClass());\n+    Type actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(type);\n+    assertEquals(genericType, actualTypeForFirstTypeVariable);\n+\n+    typeInfo = new TypeInfo(genericType);\n+    actualTypeForFirstTypeVariable = TypeUtils.getActualTypeForFirstTypeVariable(genericType);\n+    assertEquals(String.class, actualTypeForFirstTypeVariable);\n+  }\n+\n+  public void testStrangeTypeParameters() throws Exception {\n+    try {\n+      new TypeInfo(new Type() {});\n+      fail(\"Should not be able to determine this unknown type\");\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/TypeUtilsTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Unit tests for {@link TypeUtils}.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class TypeUtilsTest extends TestCase {\n+  private static final Type MAP_TYPE = new TypeToken<Map<String, Integer>>() {}.getType();\n+\n+  public void testGetActualTypeForFirstTypeVariable() {\n+    assertEquals(String.class, TypeUtils.getActualTypeForFirstTypeVariable(MAP_TYPE));\n+  }\n+\n+  public void testIsArrayForNonArrayClasses() {\n+    assertFalse(TypeUtils.isArray(Boolean.class));\n+    assertFalse(TypeUtils.isArray(MAP_TYPE));\n+  }\n+\n+  public void testIsArrayForArrayClasses() {\n+    assertTrue(TypeUtils.isArray(String[].class));\n+    assertTrue(TypeUtils.isArray(Integer[][].class));\n+    assertTrue(TypeUtils.isArray(Collection[].class));\n+  }\n+\n+  public void testToRawClassForNonGenericClasses() {\n+    assertEquals(String.class, TypeUtils.toRawClass(String.class));\n+  }\n+\n+  public void testToRawClassForGenericClasses() {\n+    assertEquals(Map.class, TypeUtils.toRawClass(MAP_TYPE));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/UpperCaseNamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.LowerCaseNamingPolicy;\n+import com.google.gson.UpperCaseNamingPolicy;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for the {@link LowerCaseNamingPolicy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class UpperCaseNamingPolicyTest extends TestCase {\n+  private static final String ALL_LOWER = \"abcdefg\";\n+  private static final String ALL_UPPER = \"ABCDEFG\";\n+  private static final String MIXED = \"aBcdeFg\";\n+\n+  private UpperCaseNamingPolicy namingPolicy;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    namingPolicy = new UpperCaseNamingPolicy();\n+  }\n+\n+  public void testAllLowerCase() throws Exception {\n+    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_LOWER, String.class, null));\n+  }\n+\n+  public void testAllUpperCase() throws Exception {\n+    assertEquals(ALL_UPPER, namingPolicy.translateName(ALL_UPPER, String.class, null));\n+  }\n+\n+  public void testMixedCase() throws Exception {\n+    assertEquals(ALL_UPPER, namingPolicy.translateName(MIXED, String.class, null));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.annotations.Since;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Unit tests for the {@link VersionExclusionStrategy} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class VersionExclusionStrategyTest extends TestCase {\n+  private static final double VERSION = 5.0D;\n+\n+  public void testDisallowNegativeValuesAndFailFast() throws Exception {\n+    try {\n+      new VersionExclusionStrategy(-1.0D);\n+      fail(\"should have thrown an exception.\");\n+    } catch (IllegalArgumentException expected) { }\n+  }\n+\n+  public void testClassAndFieldAreAtSameVersion() throws Exception {\n+    Class<MockObject> clazz = MockObject.class;\n+    Field f = clazz.getField(\"someField\");\n+    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n+    \n+    assertFalse(strategy.shouldSkipClass(clazz));\n+    assertFalse(strategy.shouldSkipField(f));\n+  }\n+\n+  public void testClassAndFieldAreBehindInVersion() throws Exception {\n+    Class<MockObject> clazz = MockObject.class;\n+    Field f = clazz.getField(\"someField\");\n+    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n+    \n+    assertFalse(strategy.shouldSkipClass(clazz));\n+    assertFalse(strategy.shouldSkipField(f));\n+  }\n+\n+  public void testClassAndFieldAreAheadInVersion() throws Exception {\n+    Class<MockObject> clazz = MockObject.class;\n+    Field f = clazz.getField(\"someField\");\n+    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n+    \n+    assertTrue(strategy.shouldSkipClass(clazz));\n+    assertTrue(strategy.shouldSkipField(f));\n+  }\n+\n+  @Since(VERSION)\n+  private static class MockObject {\n+    @Since(VERSION)\n+    public final int someField = 0;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/common/MoreAsserts.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.common;\n+\n+import junit.framework.Assert;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Handy asserts that we wish were present in {@link Assert}\n+ * so that we didn't have to write them.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class MoreAsserts {\n+\n+  public static void assertEquals(int[] expected, int[] target) {\n+    if (expected == null) {\n+      Assert.assertNull(target);\n+    }\n+    Assert.assertEquals(expected.length, target.length);\n+    for (int i = 0; i < expected.length; ++i) {\n+      Assert.assertEquals(expected[i], target[i]);\n+    }\n+  }\n+\n+  public static void assertEquals(Integer[] expected, Integer[] target) {\n+    if (expected == null) {\n+      Assert.assertNull(target);\n+    }\n+    Assert.assertEquals(expected.length, target.length);\n+    for (int i = 0; i < expected.length; ++i) {\n+      Assert.assertEquals(expected[i], target[i]);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that the specified {@code value} is not present in {@code collection}\n+   * @param collection the collection to look into\n+   * @param value the value that needs to be checked for presence\n+   */\n+  public static <T> void assertContains(Collection<T> collection, T value) {\n+    for (T entry : collection) {\n+      if (entry.equals(value)) {\n+        return;\n+      }\n+    }\n+    Assert.fail(value + \" not present in \" + collection);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.common;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * Types used for testing JSON serialization and deserialization\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class TestTypes {\n+\n+  public static class StringWrapper {\n+    public final String someConstantStringInstanceField;\n+\n+    StringWrapper() {\n+      this(\"Blah\");\n+    }\n+\n+    public StringWrapper(String value) {\n+      someConstantStringInstanceField = value;\n+    }\n+  }\n+\n+  public static class BagOfPrimitives {\n+    public static final long DEFAULT_VALUE = 0;\n+    public final long longValue;\n+    public final int intValue;\n+    public final boolean booleanValue;\n+    public final String stringValue;\n+\n+    public BagOfPrimitives() {\n+      this(DEFAULT_VALUE, 0, false, \"\");\n+    }\n+\n+    public BagOfPrimitives(long longValue, int intValue, boolean booleanValue, String stringValue) {\n+      this.longValue = longValue;\n+      this.intValue = intValue;\n+      this.booleanValue = booleanValue;\n+      this.stringValue = stringValue;\n+    }\n+\n+    public int getIntValue() {\n+      return intValue;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+      sb.append(\"\\\"longValue\\\":\").append(longValue).append(\",\");\n+      sb.append(\"\\\"intValue\\\":\").append(intValue).append(\",\");\n+      sb.append(\"\\\"booleanValue\\\":\").append(booleanValue).append(\",\");\n+      sb.append(\"\\\"stringValue\\\":\\\"\").append(stringValue).append(\"\\\"\");\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      final int prime = 31;\n+      int result = 1;\n+      result = prime * result + (booleanValue ? 1231 : 1237);\n+      result = prime * result + intValue;\n+      result = prime * result + (int) (longValue ^ (longValue >>> 32));\n+      result = prime * result + ((stringValue == null) ? 0 : stringValue.hashCode());\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (this == obj)\n+        return true;\n+      if (obj == null)\n+        return false;\n+      if (getClass() != obj.getClass())\n+        return false;\n+      BagOfPrimitives other = (BagOfPrimitives) obj;\n+      if (booleanValue != other.booleanValue)\n+        return false;\n+      if (intValue != other.intValue)\n+        return false;\n+      if (longValue != other.longValue)\n+        return false;\n+      if (stringValue == null) {\n+        if (other.stringValue != null)\n+          return false;\n+      } else if (!stringValue.equals(other.stringValue))\n+        return false;\n+      return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"(longValue=%d,intValue=%d,booleanValue=%b,stringValue=%s)\",\n+          longValue, intValue, booleanValue, stringValue);\n+    }\n+  }\n+\n+  public static class BagOfPrimitiveWrappers {\n+    private final Long longValue;\n+    private final Integer intValue;\n+    private final Boolean booleanValue;\n+\n+    public BagOfPrimitiveWrappers() {\n+      this(0L, 0, false);\n+    }\n+\n+    public BagOfPrimitiveWrappers(Long longValue, Integer intValue, Boolean booleanValue) {\n+      this.longValue = longValue;\n+      this.intValue = intValue;\n+      this.booleanValue = booleanValue;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+      sb.append(\"\\\"longValue\\\":\").append(longValue).append(\",\");\n+      sb.append(\"\\\"intValue\\\":\").append(intValue).append(\",\");\n+      sb.append(\"\\\"booleanValue\\\":\").append(booleanValue);\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  public static class PrimitiveArray {\n+    private final long[] longArray;\n+\n+    public PrimitiveArray() {\n+      this(new long[0]);\n+    }\n+\n+    public PrimitiveArray(long[] longArray) {\n+      this.longArray = longArray;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\\\"longArray\\\":[\");\n+\n+      boolean first = true;\n+      for (long l : longArray) {\n+        if (!first) {\n+          sb.append(\",\");\n+        } else {\n+          first = false;\n+        }\n+        sb.append(l);\n+      }\n+\n+      sb.append(\"]}\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  public static class ClassWithNoFields {\n+    // Nothing here.. .\n+    @Override\n+    public boolean equals(Object other) {\n+      return other.getClass() == ClassWithNoFields.class;\n+    }\n+  }\n+\n+  public static class Nested {\n+    private final BagOfPrimitives primitive1;\n+    private final BagOfPrimitives primitive2;\n+\n+    public Nested() {\n+      this(null, null);\n+    }\n+\n+    public Nested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {\n+      this.primitive1 = primitive1;\n+      this.primitive2 = primitive2;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+      appendFields(sb);\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+\n+    public void appendFields(StringBuilder sb) {\n+      if (primitive1 != null) {\n+        sb.append(\"\\\"primitive1\\\":\").append(primitive1.getExpectedJson());\n+      }\n+      if (primitive1 != null && primitive2 != null) {\n+        sb.append(\",\");\n+      }\n+      if (primitive2 != null) {\n+        sb.append(\"\\\"primitive2\\\":\").append(primitive2.getExpectedJson());\n+      }\n+    }\n+  }\n+\n+  public static class ClassWithTransientFields {\n+    public final transient long transientLongValue;\n+    private final long[] longValue;\n+\n+    public ClassWithTransientFields() {\n+      this(0L);\n+    }\n+\n+    public ClassWithTransientFields(long value) {\n+      longValue = new long[] { value };\n+      transientLongValue = value + 1;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+      sb.append(\"\\\"longValue\\\":[\").append(longValue[0]).append(\"]\");\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  public static class ClassWithCustomTypeConverter {\n+    private final BagOfPrimitives bag;\n+    private final int value;\n+\n+    public ClassWithCustomTypeConverter() {\n+      this(new BagOfPrimitives(), 10);\n+    }\n+\n+    public ClassWithCustomTypeConverter(int value) {\n+      this(new BagOfPrimitives(value, value, false, \"\"), value);\n+    }\n+\n+    public ClassWithCustomTypeConverter(BagOfPrimitives bag, int value) {\n+      this.bag = bag;\n+      this.value = value;\n+    }\n+\n+    public BagOfPrimitives getBag() {\n+      return bag;\n+    }\n+\n+    public String getExpectedJson() {\n+      return \"{\\\"url\\\":\\\"\" + bag.getExpectedJson() + \"\\\",\\\"value\\\":\" + value + \"}\";\n+    }\n+\n+    public int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  public static class ArrayOfObjects {\n+    private final BagOfPrimitives[] elements;\n+    public ArrayOfObjects() {\n+      elements = new BagOfPrimitives[3];\n+      for (int i = 0; i < elements.length; ++i) {\n+        elements[i] = new BagOfPrimitives(i, i+2, false, \"i\"+i);\n+      }\n+    }\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder(\"{\\\"elements\\\":[\");\n+      boolean first = true;\n+      for (BagOfPrimitives element : elements) {\n+        if (first) {\n+          first = false;\n+        } else {\n+          sb.append(\",\");\n+        }\n+        sb.append(element.getExpectedJson());\n+      }\n+      sb.append(\"]}\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  public static enum MyEnum {\n+    VALUE1, VALUE2;\n+\n+    public String getExpectedJson() {\n+      return \"\\\"\" + toString() + \"\\\"\";\n+    }\n+  }\n+\n+  public static class ClassOverridingEquals {\n+    public ClassOverridingEquals ref;\n+\n+    public String getExpectedJson() {\n+      if (ref == null) {\n+        return \"{}\";\n+      }\n+      return \"{\\\"ref\\\":\" + ref.getExpectedJson() + \"}\";\n+    }\n+    @Override\n+    public boolean equals(Object obj) {\n+      return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return 1;\n+    }\n+  }\n+\n+  public static class ClassWithArray {\n+    public final Object[] array;\n+    public ClassWithArray() {\n+      array = null;\n+    }\n+\n+    public ClassWithArray(Object[] array) {\n+      this.array = array;\n+    }\n+  }\n+\n+  public static class ClassWithObjects {\n+    public final BagOfPrimitives bag;\n+    public ClassWithObjects() {\n+      this(new BagOfPrimitives());\n+    }\n+    public ClassWithObjects(BagOfPrimitives bag) {\n+      this.bag = bag;\n+    }\n+  }\n+\n+  public static class ClassWithSerializedNameFields {\n+    @SerializedName(\"fooBar\") public final int f;\n+\n+    public ClassWithSerializedNameFields() {\n+      this(1);\n+    }\n+    public ClassWithSerializedNameFields(int f) {\n+      this.f = f;\n+    }\n+\n+    public String getExpectedJson() {\n+      return '{' + \"\\\"fooBar\\\":\" + f + '}';\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.common.MoreAsserts;\n+import com.google.gson.common.TestTypes.MyEnum;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+/**\n+ * Functional tests for Json serialization and deserialization of arrays.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ArrayTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testTopLevelArrayOfIntsSerialization() {\n+    int[] target = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n+    assertEquals(\"[1,2,3,4,5,6,7,8,9]\", gson.toJson(target));\n+  }\n+\n+  public void testTopLevelArrayOfIntsDeserialization() {\n+    int[] expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+    int[] actual = gson.fromJson(\"[1,2,3,4,5,6,7,8,9]\", int[].class);\n+    MoreAsserts.assertEquals(expected, actual);\n+  }\n+\n+  public void testEmptyArraySerialization() {\n+    int[] target = {};\n+    assertEquals(\"[]\", gson.toJson(target));\n+  }\n+\n+  public void testEmptyArrayDeserialization() {\n+    int[] actualObject = gson.fromJson(\"[]\", int[].class);\n+    assertTrue(actualObject.length == 0);\n+\n+    Integer[] actualObject2 = gson.fromJson(\"[]\", Integer[].class);\n+    assertTrue(actualObject2.length == 0);\n+  }\n+\n+  public void testNullsInArraySerialization() {\n+    String[] array = {\"foo\", null, \"bar\"};\n+    String expected = \"[\\\"foo\\\",null,\\\"bar\\\"]\";\n+    String json = gson.toJson(array);\n+    assertEquals(expected, json);\n+  }\n+\n+  public void testNullsInArrayDeserialization() {\n+    String json = \"[\\\"foo\\\",null,\\\"bar\\\"]\";\n+    String[] expected = {\"foo\", null, \"bar\"};\n+    String[] target = gson.fromJson(json, expected.getClass());\n+    for (int i = 0; i < expected.length; ++i) {\n+      assertEquals(expected[i], target[i]);\n+    }\n+  }\n+\n+  public void testArrayOfStringsSerialization() {\n+    String[] target = {\"Hello\", \"World\"};\n+    assertEquals(\"[\\\"Hello\\\",\\\"World\\\"]\", gson.toJson(target));\n+  }\n+\n+  public void testArrayOfStringsDeserialization() {\n+    String json = \"[\\\"Hello\\\",\\\"World\\\"]\";\n+    String[] target = gson.fromJson(json, String[].class);\n+    assertEquals(\"Hello\", target[0]);\n+    assertEquals(\"World\", target[1]);\n+  }\n+\n+  public void testTopLevelEnumInASingleElementArrayDeserialization() {\n+    String json = \"[\" + MyEnum.VALUE1.getExpectedJson() + \"]\";\n+    MyEnum target = gson.fromJson(json, MyEnum.class);\n+    assertEquals(json, \"[\" + target.getExpectedJson() + \"]\");\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testArrayOfCollectionSerialization() throws Exception {\n+    StringBuilder sb = new StringBuilder(\"[\");\n+    int arraySize = 3;\n+\n+    Type typeToSerialize = new TypeToken<Collection<Integer>[]>() {}.getType();\n+    Collection<Integer>[] arrayOfCollection = new ArrayList[arraySize];\n+    for (int i = 0; i < arraySize; ++i) {\n+      int startValue = (3 * i) + 1;\n+      sb.append('[').append(startValue).append(',').append(startValue + 1).append(']');\n+      ArrayList<Integer> tmpList = new ArrayList<Integer>();\n+      tmpList.add(startValue);\n+      tmpList.add(startValue + 1);\n+      arrayOfCollection[i] = tmpList;\n+\n+      if (i < arraySize - 1) {\n+        sb.append(',');\n+      }\n+    }\n+    sb.append(']');\n+\n+    String json = gson.toJson(arrayOfCollection, typeToSerialize);\n+    assertEquals(sb.toString(), json);\n+  }\n+\n+  public void testArrayOfCollectionDeserialization() throws Exception {\n+    String json = \"[[1,2],[3,4]]\";\n+    Type type = new TypeToken<Collection<Integer>[]>() {}.getType();\n+    Collection<Integer>[] target = gson.fromJson(json, type);\n+\n+    assertEquals(2, target.length);\n+    MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));\n+    MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.common.MoreAsserts;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.MyEnum;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Functional tests for Json serialization and deserialization of collections.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class CollectionTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testTopLevelCollectionOfIntegersSerialization() {\n+    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    Type targetType = new TypeToken<Collection<Integer>>() {}.getType();\n+    String json = gson.toJson(target, targetType);\n+    assertEquals(\"[1,2,3,4,5,6,7,8,9]\", json);\n+  }\n+\n+  public void testTopLevelCollectionOfIntegersDeserialization() {\n+    String json = \"[0,1,2,3,4,5,6,7,8,9]\";\n+    Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();\n+    Collection<Integer> target = gson.fromJson(json, collectionType);\n+    int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+    MoreAsserts.assertEquals(expected, toIntArray(target));\n+  }\n+\n+  public void testTopLevelListOfIntegerCollectionsDeserialization() throws Exception {\n+    String json = \"[[1,2,3],[4,5,6],[7,8,9]]\";\n+    Type collectionType = new TypeToken<Collection<Collection<Integer>>>() {}.getType();\n+    List<Collection<Integer>> target = gson.fromJson(json, collectionType);\n+    int[][] expected = new int[3][3];\n+    for (int i = 0; i < 3; ++i) {\n+      int start = (3 * i) + 1;\n+      for (int j = 0; j < 3; ++j) {\n+        expected[i][j] = start + j;\n+      }\n+    }\n+\n+    for (int i = 0; i < 3; i++) {\n+      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));\n+    }\n+  }\n+\n+  public void testNullsInListSerialization() {\n+    List<String> list = new ArrayList<String>();\n+    list.add(\"foo\");\n+    list.add(null);\n+    list.add(\"bar\");\n+    String expected = \"[\\\"foo\\\",null,\\\"bar\\\"]\";\n+    Type typeOfList = new TypeToken<List<String>>() {}.getType();\n+    String json = gson.toJson(list, typeOfList);\n+    assertEquals(expected, json);\n+  }\n+\n+  public void testNullsInListDeserialization() {\n+    List<String> expected = new ArrayList<String>();\n+    expected.add(\"foo\");\n+    expected.add(null);\n+    expected.add(\"bar\");\n+    String json = \"[\\\"foo\\\",null,\\\"bar\\\"]\";\n+    Type expectedType = new TypeToken<List<String>>() {}.getType();\n+    List<String> target = gson.fromJson(json, expectedType);\n+    for (int i = 0; i < expected.size(); ++i) {\n+      assertEquals(expected.get(i), target.get(i));\n+    }\n+  }\n+\n+  public void testCollectionOfStringsSerialization() {\n+    List<String> target = new ArrayList<String>();\n+    target.add(\"Hello\");\n+    target.add(\"World\");\n+    assertEquals(\"[\\\"Hello\\\",\\\"World\\\"]\", gson.toJson(target));\n+  }\n+\n+  public void testCollectionOfBagOfPrimitivesSerialization() {\n+    List<BagOfPrimitives> target = new ArrayList<BagOfPrimitives>();\n+    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, \"blah\");\n+    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, \"blahB\");\n+    target.add(objA);\n+    target.add(objB);\n+\n+    String result = gson.toJson(target);\n+    assertTrue(result.startsWith(\"[\"));\n+    assertTrue(result.endsWith(\"]\"));\n+    for (BagOfPrimitives obj : target) {\n+      assertTrue(result.contains(obj.getExpectedJson()));\n+    }\n+  }\n+\n+  public void testCollectionOfEnumsSerialization() {\n+    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();\n+    Collection<MyEnum> target = new ArrayList<MyEnum>();\n+    target.add(MyEnum.VALUE1);\n+    target.add(MyEnum.VALUE2);\n+    String expectedJson = \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\n+    String actualJson = gson.toJson(target);\n+    assertEquals(expectedJson, actualJson);\n+    actualJson = gson.toJson(target, type);\n+    assertEquals(expectedJson, actualJson);\n+  }\n+\n+  public void testCollectionOfEnumsDeserialization() {\n+    Type type = new TypeToken<Collection<MyEnum>>() {}.getType();\n+    String json = \"[\\\"VALUE1\\\",\\\"VALUE2\\\"]\";\n+    Collection<MyEnum> target = gson.fromJson(json, type);\n+    MoreAsserts.assertContains(target, MyEnum.VALUE1);\n+    MoreAsserts.assertContains(target, MyEnum.VALUE2);\n+  }\n+\n+  public void testCollectionOfStringsDeserialization() {\n+    String json = \"[\\\"Hello\\\",\\\"World\\\"]\";\n+    Type collectionType = new TypeToken<Collection<String>>() { }.getType();\n+    Collection<String> target = gson.fromJson(json, collectionType);\n+\n+    assertTrue(target.contains(\"Hello\"));\n+    assertTrue(target.contains(\"World\"));\n+  }\n+\n+  public void testRawCollectionOfIntegersSerialization() {\n+    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    assertEquals(\"[1,2,3,4,5,6,7,8,9]\", gson.toJson(target));\n+  }\n+\n+  public void testRawCollectionDeserializationNotAlllowed() {\n+    String json = \"[0,1,2,3,4,5,6,7,8,9]\";\n+    try {\n+        gson.fromJson(json, Collection.class);\n+        fail(\"Can not deserialize a non-genericized collection.\");\n+    } catch (JsonParseException expected) { }\n+\n+    json = \"[\\\"Hello\\\", \\\"World\\\"]\";\n+    try {\n+      gson.fromJson(json, Collection.class);\n+      fail(\"Can not deserialize a non-genericized collection.\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testRawCollectionOfBagOfPrimitivesNotAllowed() {\n+    try {\n+      BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, \"stringValue\");\n+      String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';\n+      Collection target = gson.fromJson(json, Collection.class);\n+      assertEquals(2, target.size());\n+      for (BagOfPrimitives bag1 : (Collection<BagOfPrimitives>) target) {\n+        assertEquals(bag.getExpectedJson(), bag1.getExpectedJson());\n+      }\n+      fail(\"Raw collection of objects should not work\");\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static int[] toIntArray(Collection collection) {\n+    int[] ints = new int[collection.size()];\n+    int i = 0;\n+    for (Iterator iterator = collection.iterator(); iterator.hasNext(); ++i) {\n+      Object obj = iterator.next();\n+      if (obj instanceof Integer) {\n+        ints[i] = ((Integer)obj).intValue();\n+      } else if (obj instanceof Long) {\n+        ints[i] = ((Long)obj).intValue();\n+      }\n+    }\n+    return ints;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassWithCustomTypeConverter;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Functional tests for the support of custom serializer and deserializers.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class CustomTypeAdaptersTest extends TestCase {\n+  private GsonBuilder builder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    builder = new GsonBuilder();\n+  }\n+\n+  public void testCustomSerializers() {\n+    Gson gson = builder.registerTypeAdapter(\n+        ClassWithCustomTypeConverter.class, new JsonSerializer<ClassWithCustomTypeConverter>() {\n+      public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        JsonObject json = new JsonObject();\n+        json.addProperty(\"bag\", 5);\n+        json.addProperty(\"value\", 25);\n+        return json;\n+      }\n+    }).create();\n+    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();\n+    assertEquals(\"{\\\"bag\\\":5,\\\"value\\\":25}\", gson.toJson(target));\n+  }\n+\n+  public void testCustomDeserializers() {\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        ClassWithCustomTypeConverter.class, new JsonDeserializer<ClassWithCustomTypeConverter>() {\n+      public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,\n+          JsonDeserializationContext context) {\n+        JsonObject jsonObject = json.getAsJsonObject();\n+        int value = jsonObject.get(\"bag\").getAsInt();\n+        return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,\n+            value, false, \"\"), value);\n+      }\n+    }).create();\n+    String json = \"{\\\"bag\\\":5,\\\"value\\\":25}\";\n+    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);\n+    assertEquals(5, target.getBag().getIntValue());\n+  }\n+\n+  public void testCustomNestedSerializers() {\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {\n+      public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        return new JsonPrimitive(6);\n+      }\n+    }).create();\n+    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();\n+    assertEquals(\"{\\\"bag\\\":6,\\\"value\\\":10}\", gson.toJson(target));\n+  }\n+\n+  public void testCustomNestedDeserializers() {\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {\n+      public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,\n+          JsonDeserializationContext context) throws JsonParseException {\n+        int value = json.getAsInt();\n+        return new BagOfPrimitives(value, value, false, \"\");\n+      }\n+    }).create();\n+    String json = \"{\\\"bag\\\":7,\\\"value\\\":25}\";\n+    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);\n+    assertEquals(7, target.getBag().getIntValue());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.URI;\n+import java.net.URL;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Functional test for Json serialization and deserialization for common classes for which default\n+ * support is provided in Gson.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class DefaultTypeAdaptersTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testUrlSerialization() throws Exception {\n+    String urlValue = \"http://google.com/\";\n+    URL url = new URL(urlValue);\n+    assertEquals('\"' + urlValue + '\"', gson.toJson(url));\n+  }\n+\n+  public void testUrlDeserialization() {\n+    String urlValue = \"http://google.com/\";\n+    String json = '\"' + urlValue + '\"';\n+    URL target = gson.fromJson(json, URL.class);\n+    assertEquals(urlValue, target.toExternalForm());\n+  }\n+\n+  public void testUriSerialization() throws Exception {\n+    String uriValue = \"http://google.com/\";\n+    URI uri = new URI(uriValue);\n+    assertEquals('\"' + uriValue + '\"', gson.toJson(uri));\n+  }\n+\n+  public void testUriDeserialization() {\n+    String uriValue = \"http://google.com/\";\n+    String json = '\"' + uriValue + '\"';\n+    URI target = gson.fromJson(json, URI.class);\n+    assertEquals(uriValue, target.toASCIIString());\n+  }\n+\n+  public void testLocaleSerializationWithLanguage() {\n+    Locale target = new Locale(\"en\");\n+    assertEquals(\"\\\"en\\\"\", gson.toJson(target));\n+  }\n+\n+  public void testLocaleDeserializationWithLanguage() {\n+    String json = \"\\\"en\\\"\";\n+    Locale locale = gson.fromJson(json, Locale.class);\n+    assertEquals(\"en\", locale.getLanguage());\n+  }\n+\n+  public void testLocaleSerializationWithLanguageCountry() {\n+    Locale target = Locale.CANADA_FRENCH;\n+    assertEquals(\"\\\"fr_CA\\\"\", gson.toJson(target));\n+  }\n+\n+  public void testLocaleDeserializationWithLanguageCountry() {\n+    String json = \"\\\"fr_CA\\\"\";\n+    Locale locale = gson.fromJson(json, Locale.class);\n+    assertEquals(Locale.CANADA_FRENCH, locale);\n+  }\n+\n+  public void testLocaleSerializationWithLanguageCountryVariant() {\n+    Locale target = new Locale(\"de\", \"DE\", \"EURO\");\n+    String json = gson.toJson(target);\n+    assertEquals(\"\\\"de_DE_EURO\\\"\", json);\n+  }\n+\n+  public void testLocaleDeserializationWithLanguageCountryVariant() {\n+    String json = \"\\\"de_DE_EURO\\\"\";\n+    Locale locale = gson.fromJson(json, Locale.class);\n+    assertEquals(\"de\", locale.getLanguage());\n+    assertEquals(\"DE\", locale.getCountry());\n+    assertEquals(\"EURO\", locale.getVariant());\n+  }\n+\n+  public void testMapSerialization() {\n+    Map<String, Integer> map = new LinkedHashMap<String, Integer>();\n+    map.put(\"a\", 1);\n+    map.put(\"b\", 2);\n+    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();\n+    String json = gson.toJson(map, typeOfMap);\n+    assertTrue(json.contains(\"\\\"a\\\":1\"));\n+    assertTrue(json.contains(\"\\\"b\\\":2\"));\n+  }\n+\n+  public void testMapDeserialization() {\n+    String json = \"{\\\"a\\\":1,\\\"b\\\":2}\";\n+    Type typeOfMap = new TypeToken<Map<String,Integer>>(){}.getType();\n+    Map<String, Integer> target = gson.fromJson(json, typeOfMap);\n+    assertEquals(1, target.get(\"a\").intValue());\n+    assertEquals(2, target.get(\"b\").intValue());\n+  }\n+\n+  public void testMapSerializationEmpty() {\n+    Map<String, Integer> map = new LinkedHashMap<String, Integer>();\n+    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();\n+    String json = gson.toJson(map, typeOfMap);\n+    assertEquals(\"{}\", json);\n+  }\n+\n+  public void testBigDecimalFieldSerialization() {\n+    ClassWithBigDecimal target = new ClassWithBigDecimal(\"-122.01e-21\");\n+    String json = gson.toJson(target);\n+    String actual = json.substring(json.indexOf(':') + 1, json.indexOf('}'));\n+    assertEquals(target.value, new BigDecimal(actual));\n+  }\n+\n+  public void testBigDecimalFieldDeserialization() {\n+    ClassWithBigDecimal expected = new ClassWithBigDecimal(\"-122.01e-21\");\n+    String json = expected.getExpectedJson();\n+    ClassWithBigDecimal actual = gson.fromJson(json, ClassWithBigDecimal.class);\n+    assertEquals(expected.value, actual.value);\n+  }\n+\n+  public void testBadValueForBigDecimalDeserialization() {\n+    try {\n+      gson.fromJson(\"{\\\"value\\\"=1.5e-1.0031}\", ClassWithBigDecimal.class);\n+      fail(\"Exponent of a BigDecimal must be an integer value.\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testBigIntegerFieldSerialization() {\n+    ClassWithBigInteger target = new ClassWithBigInteger(\"23232323215323234234324324324324324324\");\n+    String json = gson.toJson(target);\n+    assertEquals(target.getExpectedJson(), json);\n+  }\n+\n+  public void testBigIntegerFieldDeserialization() {\n+    ClassWithBigInteger expected = new ClassWithBigInteger(\"879697697697697697697697697697697697\");\n+    String json = expected.getExpectedJson();\n+    ClassWithBigInteger actual = gson.fromJson(json, ClassWithBigInteger.class);\n+    assertEquals(expected.value, actual.value);\n+  }\n+\n+  public void testSetSerialization() throws Exception {\n+    Gson gson = new Gson();\n+    HashSet<String> s = new HashSet<String>();\n+    s.add(\"blah\");\n+    String json = gson.toJson(s);\n+    assertEquals(\"[\\\"blah\\\"]\", json);\n+\n+    json = gson.toJson(s, Set.class);\n+    assertEquals(\"[\\\"blah\\\"]\", json);\n+  }\n+\n+  public void testDefaultDateSerialization() {\n+    Date now = new Date();\n+    String json = gson.toJson(now);\n+    assertEquals(\"\\\"\" + DateFormat.getDateInstance().format(now) + \"\\\"\", json);\n+  }\n+\n+  public void testDefaultDateSerializationUsingBuilder() throws Exception {\n+    Gson gson = new GsonBuilder().create();\n+    Date now = new Date();\n+    String json = gson.toJson(now);\n+    assertEquals(\"\\\"\" + DateFormat.getDateInstance().format(now) + \"\\\"\", json);\n+  }\n+\n+  public void testDateSerializationWithPattern() throws Exception {\n+    String pattern = \"yyyy-MM-dd\";\n+    DateFormat formatter = new SimpleDateFormat(pattern);\n+    Gson gson = new GsonBuilder().setDateFormat(DateFormat.LONG).setDateFormat(pattern).create();\n+    Date now = new Date();\n+    String json = gson.toJson(now);\n+    assertEquals(\"\\\"\" + formatter.format(now) + \"\\\"\", json);\n+  }\n+\n+  private static class ClassWithBigDecimal {\n+    BigDecimal value;\n+    ClassWithBigDecimal() { }\n+    ClassWithBigDecimal(String value) {\n+      this.value = new BigDecimal(value);\n+    }\n+    String getExpectedJson() {\n+      return \"{\\\"value\\\":\" + value.toEngineeringString() + \"}\";\n+    }\n+  }\n+\n+  private static class ClassWithBigInteger {\n+    BigInteger value;\n+    ClassWithBigInteger() { }\n+    ClassWithBigInteger(String value) {\n+      this.value = new BigInteger(value);\n+    }\n+    String getExpectedJson() {\n+      return \"{\\\"value\\\":\" + value + \"}\";\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/EscapingTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+\n+import junit.framework.TestCase;\n+\n+public class EscapingTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testEscapingQuotesInStringArray() throws Exception {\n+    String[] valueWithQuotes = { \"beforeQuote\\\"afterQuote\" };\n+    String jsonRepresentation = gson.toJson(valueWithQuotes);\n+    String[] target = gson.fromJson(jsonRepresentation, String[].class);\n+    assertEquals(1, target.length);\n+    assertEquals(valueWithQuotes[0], target[0]);\n+  }\n+\n+  public void testEscapingObjectFields() throws Exception {\n+    BagOfPrimitives objWithPrimitives = new BagOfPrimitives(1L, 1, true, \"test with\\\" <script>\");\n+    String jsonRepresentation = gson.toJson(objWithPrimitives);\n+    assertFalse(jsonRepresentation.contains(\"<\"));\n+    assertFalse(jsonRepresentation.contains(\">\"));\n+    assertTrue(jsonRepresentation.contains(\"\\\\\\\"\"));\n+\n+    BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);\n+    assertEquals(objWithPrimitives.getExpectedJson(), expectedObject.getExpectedJson());\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.annotations.Expose;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for the regarding functional \"@Expose\" type tests.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class ExposeFieldsTest extends TestCase {\n+\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();\n+  }\n+\n+  public void testNullExposeFieldSerialization() throws Exception {\n+    ClassWithExposedFields object = new ClassWithExposedFields(null, 1);\n+    String json = gson.toJson(object);\n+\n+    assertEquals(object.getExpectedJson(), json);\n+  }\n+\n+  public void testArrayWithOneNullExposeFieldObjectSerialization() throws Exception {\n+    ClassWithExposedFields object1 = new ClassWithExposedFields(1, 1);\n+    ClassWithExposedFields object2 = new ClassWithExposedFields(null, 1);\n+    ClassWithExposedFields object3 = new ClassWithExposedFields(2, 2);\n+    ClassWithExposedFields[] objects = { object1, object2, object3 };\n+\n+    String json = gson.toJson(objects);\n+    String expected = new StringBuilder()\n+        .append('[').append(object1.getExpectedJson()).append(',')\n+        .append(object2.getExpectedJson()).append(',')\n+        .append(object3.getExpectedJson()).append(']')\n+        .toString();\n+\n+    assertEquals(expected, json);\n+  }\n+\n+  public void testExposeAnnotationSerialization() throws Exception {\n+    ClassWithExposedFields target = new ClassWithExposedFields(1, 2);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testExposeAnnotationDeserialization() throws Exception {\n+    String json = '{' + \"\\\"a\\\":\" + 3 + \",\\\"b\\\":\" + 4 + '}';\n+    ClassWithExposedFields target = gson.fromJson(json, ClassWithExposedFields.class);\n+\n+    assertEquals(3, (int) target.a);\n+    assertNull(target.b);\n+  }\n+\n+  public void testNoExposedFieldSerialization() throws Exception {\n+    ClassWithNoExposedFields obj = new ClassWithNoExposedFields();\n+    String json = gson.toJson(obj);\n+\n+    assertEquals(\"{}\", json);\n+  }\n+\n+  public void testNoExposedFieldDeserialization() throws Exception {\n+    String json = '{' + \"\\\"a\\\":\" + 4 + \",\\\"b\\\":\" + 5 + '}';\n+    ClassWithNoExposedFields obj = gson.fromJson(json, ClassWithNoExposedFields.class);\n+\n+    assertEquals(0, obj.a);\n+    assertEquals(1, obj.b);\n+  }\n+\n+  private static class ClassWithExposedFields {\n+    @Expose private final Integer a;\n+    private final Integer b;\n+\n+    ClassWithExposedFields() {\n+      this(null, null);\n+    }\n+\n+    public ClassWithExposedFields(Integer a, Integer b) {\n+      this.a = a;\n+      this.b = b;\n+    }\n+\n+    public String getExpectedJson() {\n+      if (a == null) {\n+        return \"{}\";\n+      }\n+      return '{' + \"\\\"a\\\":\" + a + '}';\n+    }\n+\n+    public String getExpectedJsonWithoutAnnotations() {\n+      StringBuilder stringBuilder = new StringBuilder();\n+      boolean requiresComma = false;\n+      stringBuilder.append('{');\n+      if (a != null) {\n+        stringBuilder.append(\"\\\"a\\\":\").append(a);\n+        requiresComma = true;\n+      }\n+      if (b != null) {\n+        if (requiresComma) {\n+          stringBuilder.append(',');\n+        }\n+        stringBuilder.append(\"\\\"b\\\":\").append(b);\n+      }\n+      stringBuilder.append('}');\n+      return stringBuilder.toString();\n+    }\n+  }\n+\n+  private static class  ClassWithNoExposedFields {\n+    private final int a = 0;\n+    private final int b = 1;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/InternationalizationTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for internationalized strings.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class InternationalizationTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  /*\n+  public void testStringsWithRawChineseCharactersSerialization() throws Exception {\n+    String target = \"\u597d\u597d\u597d\";\n+    String json = gson.toJson(target);\n+    String expected = \"\\\"\\\\u597d\\\\u597d\\\\u597d\\\"\";\n+    assertEquals(expected, json);\n+  }\n+  */\n+\n+  public void testStringsWithRawChineseCharactersDeserialization() throws Exception {\n+    String expected = \"\u597d\u597d\u597d\";\n+    String json = \"\\\"\" + expected + \"\\\"\";\n+    String actual = gson.fromJson(json, String.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testStringsWithUnicodeChineseCharactersSerialization() throws Exception {\n+    String target = \"\\u597d\\u597d\\u597d\";\n+    String json = gson.toJson(target);\n+    String expected = \"\\\"\\\\u597d\\\\u597d\\\\u597d\\\"\";\n+    assertEquals(expected, json);\n+  }\n+\n+  public void testStringsWithUnicodeChineseCharactersDeserialization() throws Exception {\n+    String expected = \"\\u597d\\u597d\\u597d\";\n+    String json = \"\\\"\" + expected + \"\\\"\";\n+    String actual = gson.fromJson(json, String.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testStringsWithUnicodeChineseCharactersEscapedDeserialization() throws Exception {\n+    String json = \"\\\"\" + \"\\\\u597d\\\\u597d\\\\u597d\" + \"\\\"\";\n+    String actual = gson.fromJson(json, String.class);\n+    String expected = \"\\u597d\\u597d\\u597d\";\n+    assertEquals(expected, actual);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.common.TestTypes.ClassWithSerializedNameFields;\n+import com.google.gson.common.TestTypes.StringWrapper;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for naming policies.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class NamingPolicyTest extends TestCase {\n+\n+  private GsonBuilder builder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    builder = new GsonBuilder();\n+  }\n+\n+  public void testGsonWithNonDefaultFieldNamingPolicySerialization() {\n+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\n+    StringWrapper target = new StringWrapper(\"blah\");\n+    assertEquals(\"{\\\"SomeConstantStringInstanceField\\\":\\\"\"\n+        + target.someConstantStringInstanceField + \"\\\"}\", gson.toJson(target));\n+  }\n+\n+  public void testGsonWithNonDefaultFieldNamingPolicyDeserialiation() {\n+    Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();\n+    StringWrapper target = new StringWrapper(\"SomeValue\");\n+    String jsonRepresentation = gson.toJson(target);\n+    StringWrapper deserializedObject = gson.fromJson(jsonRepresentation, StringWrapper.class);\n+    assertEquals(target.someConstantStringInstanceField,\n+        deserializedObject.someConstantStringInstanceField);\n+  }\n+\n+  public void testGsonWithSerializedNameFieldNamingPolicySerialization() {\n+    Gson gson = builder.create();\n+    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);\n+    String actual = gson.toJson(expected);\n+    assertEquals(expected.getExpectedJson(), actual);\n+  }\n+\n+  public void testGsonWithSerializedNameFieldNamingPolicyDeserialization() {\n+    Gson gson = builder.create();\n+    ClassWithSerializedNameFields expected = new ClassWithSerializedNameFields(5);\n+    ClassWithSerializedNameFields actual =\n+        gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);\n+    assertEquals(expected.f, actual.f);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassWithObjects;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Functional tests for the different cases for serializing (or ignoring) null fields and object.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class NullObjectAndFieldTest extends TestCase {\n+  private GsonBuilder gsonBuilder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gsonBuilder = new GsonBuilder().serializeNulls();\n+  }\n+\n+  public void testTopLevelNullObjectSerialization() {\n+    Gson gson = gsonBuilder.create();\n+    String actual = gson.toJson(null);\n+    assertEquals(\"null\", actual);\n+\n+    actual = gson.toJson(null, String.class);\n+    assertEquals(\"null\", actual);\n+  }\n+\n+  public void testTopLevelNullObjectDeserialization() throws Exception {\n+    Gson gson = gsonBuilder.create();\n+    String actual = gson.fromJson(\"null\", String.class);\n+    assertNull(actual);\n+  }\n+\n+  public void testExplicitSerializationOfNulls() {\n+    Gson gson = gsonBuilder.create();\n+    ClassWithObjects target = new ClassWithObjects(null);\n+    String actual = gson.toJson(target);\n+    String expected = \"{\\\"bag\\\":null}\";\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testExplicitDeserializationOfNulls() throws Exception {\n+    Gson gson = gsonBuilder.create();\n+    ClassWithObjects target = gson.fromJson(\"{\\\"bag\\\":null}\", ClassWithObjects.class);\n+    assertNull(target.bag);\n+  }\n+\n+  public void testCustomSerializationOfNulls() {\n+    gsonBuilder.registerTypeAdapter(ClassWithObjects.class, new ClassWithObjectsSerializer());\n+    Gson gson = gsonBuilder.create();\n+    ClassWithObjects target = new ClassWithObjects(new BagOfPrimitives());\n+    String actual = gson.toJson(target);\n+    String expected = \"{\\\"bag\\\":null}\";\n+    assertEquals(expected, actual);\n+  }\n+\n+  private static class ClassWithObjectsSerializer implements JsonSerializer<ClassWithObjects> {\n+    public JsonElement serialize(ClassWithObjects src, Type typeOfSrc,\n+        JsonSerializationContext context) {\n+      JsonObject obj = new JsonObject();\n+      obj.add(\"bag\", new JsonNull());\n+      return obj;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.common.TestTypes.ArrayOfObjects;\n+import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassOverridingEquals;\n+import com.google.gson.common.TestTypes.ClassWithArray;\n+import com.google.gson.common.TestTypes.ClassWithNoFields;\n+import com.google.gson.common.TestTypes.ClassWithObjects;\n+import com.google.gson.common.TestTypes.ClassWithTransientFields;\n+import com.google.gson.common.TestTypes.MyEnum;\n+import com.google.gson.common.TestTypes.Nested;\n+import com.google.gson.common.TestTypes.PrimitiveArray;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+/**\n+ * Functional tests for Json serialization and deserialization of regular classes.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ObjectTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testBagOfPrimitivesSerialization() throws Exception {\n+    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, \"stringValue\");\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testBagOfPrimitivesDeserialization() throws Exception {\n+    BagOfPrimitives src = new BagOfPrimitives(10, 20, false, \"stringValue\");\n+    String json = src.getExpectedJson();\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testBagOfPrimitiveWrappersSerialization() throws Exception {\n+    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testBagOfPrimitiveWrappersDeserialization() throws Exception {\n+    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);\n+    String jsonString = target.getExpectedJson();\n+    target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);\n+    assertEquals(jsonString, target.getExpectedJson());\n+  }\n+\n+  public void testDirectedAcyclicGraphSerialization() throws Exception {\n+    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();\n+    a.children.add(b);\n+    a.children.add(c);\n+    b.children.add(c);\n+    assertNotNull(gson.toJson(a));\n+  }\n+\n+  public void testDirectedAcyclicGraphDeserialization() throws Exception {\n+    String json = \"{\\\"children\\\":[{\\\"children\\\":[{\\\"children\\\":[]}]},{\\\"children\\\":[]}]}\";\n+    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);\n+    assertNotNull(target);\n+    assertEquals(2, target.children.size());\n+  }\n+\n+  public void testClassWithTransientFieldsSerialization() throws Exception {\n+    ClassWithTransientFields target = new ClassWithTransientFields(1L);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testClassWithTransientFieldsDeserialization() throws Exception {\n+    String json = \"{\\\"longValue\\\":[1]}\";\n+    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()\n+      throws Exception {\n+    String json = \"{\\\"transientLongValue\\\":1,\\\"longValue\\\":[1]}\";\n+    ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);\n+    assertFalse(target.transientLongValue != 1);\n+  }\n+\n+  public void testClassWithNoFieldsSerialization() throws Exception {\n+    assertEquals(\"{}\", gson.toJson(new ClassWithNoFields()));\n+  }\n+\n+  public void testClassWithNoFieldsDeserialization() throws Exception {\n+    String json = \"{}\";\n+    ClassWithNoFields target = gson.fromJson(json, ClassWithNoFields.class);\n+    ClassWithNoFields expected = new ClassWithNoFields();\n+    assertEquals(expected, target);\n+  }\n+\n+  public void testNestedSerialization() throws Exception {\n+    Nested target = new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"),\n+       new BagOfPrimitives(30, 40, true, \"stringValue\"));\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testNestedDeserialization() throws Exception {\n+    String json = \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false,\"\n+        + \"\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":{\\\"longValue\\\":30,\\\"intValue\\\":40,\"\n+        + \"\\\"booleanValue\\\":true,\\\"stringValue\\\":\\\"stringValue\\\"}}\";\n+    Nested target = gson.fromJson(json, Nested.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testInheritenceSerialization() throws Exception {\n+    SubTypeOfNested target = new SubTypeOfNested(new BagOfPrimitives(10, 20, false, \"stringValue\"),\n+        new BagOfPrimitives(30, 40, true, \"stringValue\"));\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testInheritenceDeserialization() throws Exception {\n+    String json = \"{\\\"value\\\":5,\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\"\n+        + \"\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"stringValue\\\"},\\\"primitive2\\\":\"\n+        + \"{\\\"longValue\\\":30,\\\"intValue\\\":40,\\\"booleanValue\\\":true,\"\n+        + \"\\\"stringValue\\\":\\\"stringValue\\\"}}\";\n+    SubTypeOfNested target = gson.fromJson(json, SubTypeOfNested.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testNullSerialization() throws Exception {\n+    assertEquals(\"\", gson.toJson(null));\n+  }\n+\n+  public void testNullDeserialization() throws Exception {\n+    try {\n+      gson.fromJson(\"\", Object.class);\n+      fail(\"Null strings should not be allowed\");\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testNullFieldsSerialization() throws Exception {\n+    Nested target = new Nested(new BagOfPrimitives(10, 20, false, \"stringValue\"), null);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testNullFieldsDeserialization() throws Exception {\n+    String json = \"{\\\"primitive1\\\":{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false\"\n+        + \",\\\"stringValue\\\":\\\"stringValue\\\"}}\";\n+    Nested target = gson.fromJson(json, Nested.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testArrayOfObjectsSerialization() throws Exception {\n+    ArrayOfObjects target = new ArrayOfObjects();\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testArrayOfObjectsDeserialization() throws Exception {\n+    String json = new ArrayOfObjects().getExpectedJson();\n+    ArrayOfObjects target = gson.fromJson(json, ArrayOfObjects.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testArrayOfArraysSerialization() throws Exception {\n+    ArrayOfArrays target = new ArrayOfArrays();\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testArrayOfArraysDeserialization() throws Exception {\n+    String json = new ArrayOfArrays().getExpectedJson();\n+    ArrayOfArrays target = gson.fromJson(json, ArrayOfArrays.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testClassWithEnumFieldSerialization() throws Exception {\n+    ClassWithEnumFields target = new ClassWithEnumFields();\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testClassWithEnumFieldDeserialization() throws Exception {\n+    String json = new ClassWithEnumFields().getExpectedJson();\n+    ClassWithEnumFields target = gson.fromJson(json, ClassWithEnumFields.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testTopLevelEnumSerialization() throws Exception {\n+    MyEnum target = MyEnum.VALUE1;\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testTopLevelEnumDeserialization() throws Exception {\n+    String json = MyEnum.VALUE1.getExpectedJson();\n+    MyEnum target = gson.fromJson(json, MyEnum.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  public void testSubInterfacesOfCollectionSerialization() throws Exception {\n+    List<Integer> list = new LinkedList<Integer>();\n+    list.add(0);\n+    list.add(1);\n+    list.add(2);\n+    list.add(3);\n+    Queue<Long> queue = new LinkedList<Long>();\n+    queue.add(0L);\n+    queue.add(1L);\n+    queue.add(2L);\n+    queue.add(3L);\n+    Set<Float> set = new TreeSet<Float>();\n+    set.add(0.1F);\n+    set.add(0.2F);\n+    set.add(0.3F);\n+    set.add(0.4F);\n+    SortedSet<Character> sortedSet = new TreeSet<Character>();\n+    sortedSet.add('a');\n+    sortedSet.add('b');\n+    sortedSet.add('c');\n+    sortedSet.add('d');\n+    ClassWithSubInterfacesOfCollection target =\n+        new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testSubInterfacesOfCollectionDeserialization() throws Exception {\n+    String json = \"{\\\"list\\\":[0,1,2,3],\\\"queue\\\":[0,1,2,3],\\\"set\\\":[0.1,0.2,0.3,0.4],\"\n+        + \"\\\"sortedSet\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"]\"\n+//        + \",\\\"navigableSet\\\":[\\\"abc\\\",\\\"def\\\",\\\"ghi\\\",\\\"jkl\\\"]\"\n+        + \"}\";\n+    ClassWithSubInterfacesOfCollection target = gson.fromJson(\n+        json, ClassWithSubInterfacesOfCollection.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  /**\n+   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14\n+   */\n+  public void testNullArraysDeserialization() throws Exception {\n+    String json = \"{\\\"array\\\": null}\";\n+    ClassWithArray target = gson.fromJson(json, ClassWithArray.class);\n+    assertNull(target.array);\n+  }\n+\n+  /**\n+   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14\n+   */\n+  public void testNullObjectFieldsDeserialization() throws Exception {\n+    String json = \"{\\\"bag\\\": null}\";\n+    ClassWithObjects target = gson.fromJson(json, ClassWithObjects.class);\n+    assertNull(target.bag);\n+  }\n+\n+  public void testEmptyCollectionInAnObjectDeserialization() throws Exception {\n+    String json = \"{\\\"children\\\":[]}\";\n+    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);\n+    assertNotNull(target);\n+    assertTrue(target.children.isEmpty());\n+  }\n+\n+  public void testPrimitiveArrayInAnObjectDeserialization() throws Exception {\n+    String json = \"{\\\"longArray\\\":[0,1,2,3,4,5,6,7,8,9]}\";\n+    PrimitiveArray target = gson.fromJson(json, PrimitiveArray.class);\n+    assertEquals(json, target.getExpectedJson());\n+  }\n+\n+  /**\n+   * Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14\n+   */\n+  public void testNullPrimitiveFieldsDeserialization() throws Exception {\n+    String json = \"{\\\"longValue\\\":null}\";\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(BagOfPrimitives.DEFAULT_VALUE, target.longValue);\n+  }\n+\n+  public void testReallyLongStringsDeserialization() throws Exception {\n+    StringBuilder sb = new StringBuilder(8096);\n+    sb.append(\"Once upon a time there was a really long string that caused a StackOverFlowError\\n\");\n+    sb.append(\"and now it is fixed and instead throws a JsonParserException.....Yippie!!!\\n\");\n+    sb.append(\"Wow....that is a really long string that is meant to be an exception stack trace, \");\n+    sb.append(\"but is not :( \\n\\n\\n\\n\\n\\n.\");\n+    sb.append(\"lalalalala \\n\\n\\n.\");\n+    sb.append(\"C'est la vie!!! \\n\\n\\n\\n\\n\");\n+\n+    for (int i = 0; i < 10; i++) {\n+      sb.append(sb.toString());\n+    }\n+\n+    while (true) {\n+      try {\n+        String stackTrace = sb.toString();\n+        sb.append(stackTrace);\n+        String json = \"{\\\"message\\\":\\\"Error message.\\\",\"\n+          + \"\\\"stackTrace\\\":\\\"\" + stackTrace + \"\\\"}\";\n+        parseLongJson(json);\n+      } catch (JsonParseException expected) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  public void testEmptyCollectionInAnObjectSerialization() throws Exception {\n+    ContainsReferenceToSelfType target = new ContainsReferenceToSelfType();\n+    assertEquals(\"{\\\"children\\\":[]}\", gson.toJson(target));\n+  }\n+\n+  private void parseLongJson(String json) throws JsonParseException {\n+    ExceptionHolder target = gson.fromJson(json, ExceptionHolder.class);\n+    assertTrue(target.message.contains(\"Error\"));\n+    assertTrue(target.stackTrace.contains(\"Yippie\"));\n+  }\n+\n+  public void testCircularSerialization() throws Exception {\n+    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();\n+    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();\n+    a.children.add(b);\n+    b.children.add(a);\n+    try {\n+      gson.toJson(a);\n+      fail(\"Circular types should not get printed!\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+\n+  public void testSelfReferenceSerialization() throws Exception {\n+    ClassOverridingEquals objA = new ClassOverridingEquals();\n+    objA.ref = objA;\n+\n+    try {\n+      gson.toJson(objA);\n+      fail(\"Circular reference to self can not be serialized!\");\n+    } catch (IllegalStateException expected) { }\n+  }\n+\n+  public void testPrivateNoArgConstructorDeserialization() throws Exception {\n+    ClassWithPrivateNoArgsConstructor target =\n+      gson.fromJson(\"{\\\"a\\\":20}\", ClassWithPrivateNoArgsConstructor.class);\n+    assertEquals(20, target.a);\n+  }\n+\n+  public void testAnonymousLocalClassesSerialization() throws Exception {\n+    assertEquals(\"\", gson.toJson(new ClassWithNoFields() {\n+      // empty anonymous class\n+    }));\n+  }\n+\n+  public void testPrimitiveArrayFieldSerialization() {\n+    PrimitiveArray target = new PrimitiveArray(new long[] { 1L, 2L, 3L });\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public static class ClassWithSubInterfacesOfCollection {\n+    private List<Integer> list;\n+    private Queue<Long> queue;\n+    private Set<Float> set;\n+    private SortedSet<Character> sortedSet;\n+\n+    ClassWithSubInterfacesOfCollection() {\n+    }\n+\n+    public ClassWithSubInterfacesOfCollection(List<Integer> list, Queue<Long> queue, Set<Float> set,\n+        SortedSet<Character> sortedSet) {\n+      this.list = list;\n+      this.queue = queue;\n+      this.set = set;\n+      this.sortedSet = sortedSet;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(\"{\");\n+      sb.append(\"\\\"list\\\":\");\n+      append(sb, list).append(\",\");\n+      sb.append(\"\\\"queue\\\":\");\n+      append(sb, queue).append(\",\");\n+      sb.append(\"\\\"set\\\":\");\n+      append(sb, set).append(\",\");\n+      sb.append(\"\\\"sortedSet\\\":\");\n+      append(sb, sortedSet);\n+      sb.append(\"}\");\n+      return sb.toString();\n+    }\n+\n+    private StringBuilder append(StringBuilder sb, Collection<?> c) {\n+      sb.append(\"[\");\n+      boolean first = true;\n+      for (Object o : c) {\n+        if (!first) {\n+          sb.append(\",\");\n+        } else {\n+          first = false;\n+        }\n+        if (o instanceof String || o instanceof Character) {\n+          sb.append('\\\"');\n+        }\n+        sb.append(o.toString());\n+        if (o instanceof String || o instanceof Character) {\n+          sb.append('\\\"');\n+        }\n+      }\n+      sb.append(\"]\");\n+      return sb;\n+    }\n+  }\n+\n+  private static class ContainsReferenceToSelfType {\n+    public Collection<ContainsReferenceToSelfType> children =\n+        new ArrayList<ContainsReferenceToSelfType>();\n+  }\n+\n+  private static class SubTypeOfNested extends Nested {\n+    private final long value = 5;\n+\n+    public SubTypeOfNested() {\n+      this(null, null);\n+    }\n+\n+    public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {\n+      super(primitive1, primitive2);\n+    }\n+\n+    @Override\n+    public void appendFields(StringBuilder sb) {\n+      sb.append(\"\\\"value\\\":\").append(value).append(\",\");\n+      super.appendFields(sb);\n+    }\n+  }\n+\n+  private static class ArrayOfArrays {\n+    private final BagOfPrimitives[][] elements;\n+    public ArrayOfArrays() {\n+      elements = new BagOfPrimitives[3][2];\n+      for (int i = 0; i < elements.length; ++i) {\n+        BagOfPrimitives[] row = elements[i];\n+        for (int j = 0; j < row.length; ++j) {\n+          row[j] = new BagOfPrimitives(i+j, i*j, false, i+\"_\"+j);\n+        }\n+      }\n+    }\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder(\"{\\\"elements\\\":[\");\n+      boolean first = true;\n+      for (BagOfPrimitives[] row : elements) {\n+        if (first) {\n+          first = false;\n+        } else {\n+          sb.append(\",\");\n+        }\n+        boolean firstOfRow = true;\n+        sb.append(\"[\");\n+        for (BagOfPrimitives element : row) {\n+          if (firstOfRow) {\n+            firstOfRow = false;\n+          } else {\n+            sb.append(\",\");\n+          }\n+          sb.append(element.getExpectedJson());\n+        }\n+        sb.append(\"]\");\n+      }\n+      sb.append(\"]}\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  private static class ClassWithEnumFields {\n+    private final MyEnum value1 = MyEnum.VALUE1;\n+    private final MyEnum value2 = MyEnum.VALUE2;\n+    public String getExpectedJson() {\n+      return \"{\\\"value1\\\":\\\"\" + value1 + \"\\\",\\\"value2\\\":\\\"\" + value2 + \"\\\"}\";\n+    }\n+  }\n+\n+  private static class ClassWithPrivateNoArgsConstructor {\n+    public int a;\n+    private ClassWithPrivateNoArgsConstructor() {\n+      a = 10;\n+    }\n+  }\n+\n+  private static class ExceptionHolder {\n+    public final String message;\n+    public final String stackTrace;\n+    public ExceptionHolder() {\n+      this(\"\", \"\");\n+    }\n+    public ExceptionHolder(String message, String stackTrace) {\n+      this.message = message;\n+      this.stackTrace = stackTrace;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.ParamterizedTypeFixtures.MyParameterizedType;\n+import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeAdapter;\n+import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeInstanceCreator;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Functional tests for the serialization and deserialization of parameterized types in Gson.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ParameterizedTypesTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testParameterizedTypesSerialization() throws Exception {\n+    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);\n+    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();\n+    String json = gson.toJson(src, typeOfSrc);\n+    assertEquals(src.getExpectedJson(), json);\n+  }\n+\n+  public void testParameterizedTypeDeserialization() throws Exception {\n+    BagOfPrimitives bag = new BagOfPrimitives();\n+    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);\n+    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();\n+    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))\n+        .create();\n+\n+    String json = expected.getExpectedJson();\n+    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testTypesWithMultipleParametersSerialization() throws Exception {\n+    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> src =\n+      new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,\n+          \"abc\", new BagOfPrimitives());\n+    Type typeOfSrc = new TypeToken<MultiParameters<Integer, Float, Double, String,\n+        BagOfPrimitives>>() {}.getType();\n+    String json = gson.toJson(src, typeOfSrc);\n+    String expected = \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\"\n+      + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\n+    assertEquals(expected, json);\n+  }\n+\n+  public void testTypesWithMultipleParametersDeserialization() throws Exception {\n+    Type typeOfTarget = new TypeToken<MultiParameters<Integer, Float, Double, String,\n+        BagOfPrimitives>>() {}.getType();\n+    String json = \"{\\\"a\\\":10,\\\"b\\\":1.0,\\\"c\\\":2.1,\\\"d\\\":\\\"abc\\\",\"\n+      + \"\\\"e\\\":{\\\"longValue\\\":0,\\\"intValue\\\":0,\\\"booleanValue\\\":false,\\\"stringValue\\\":\\\"\\\"}}\";\n+    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> target =\n+      gson.fromJson(json, typeOfTarget);\n+    MultiParameters<Integer, Float, Double, String, BagOfPrimitives> expected =\n+      new MultiParameters<Integer, Float, Double, String, BagOfPrimitives>(10, 1.0F, 2.1D,\n+          \"abc\", new BagOfPrimitives());\n+    assertEquals(expected, target);\n+  }\n+\n+  public void testParameterizedTypeWithCustomSerializer() {\n+    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();\n+    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(ptIntegerType, new MyParameterizedTypeAdapter<Integer>())\n+        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())\n+        .create();\n+    MyParameterizedType<Integer> intTarget = new MyParameterizedType<Integer>(10);\n+    String json = gson.toJson(intTarget, ptIntegerType);\n+    assertEquals(MyParameterizedTypeAdapter.<Integer>getExpectedJson(intTarget), json);\n+\n+    MyParameterizedType<String> stringTarget = new MyParameterizedType<String>(\"abc\");\n+    json = gson.toJson(stringTarget, ptStringType);\n+    assertEquals(MyParameterizedTypeAdapter.<String>getExpectedJson(stringTarget), json);\n+  }\n+\n+  public void testParameterizedTypesWithCustomDeserializer() {\n+    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();\n+    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        ptIntegerType, new MyParameterizedTypeAdapter<Integer>())\n+        .registerTypeAdapter(ptStringType, new MyParameterizedTypeAdapter<String>())\n+        .registerTypeAdapter(ptStringType, new MyParameterizedTypeInstanceCreator<String>(\"\"))\n+        .registerTypeAdapter(ptIntegerType,\n+            new MyParameterizedTypeInstanceCreator<Integer>(new Integer(0)))\n+        .create();\n+\n+    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);\n+    String json = MyParameterizedTypeAdapter.<Integer>getExpectedJson(src);\n+    MyParameterizedType<Integer> intTarget = gson.fromJson(json, ptIntegerType);\n+    assertEquals(10, (int) intTarget.value);\n+\n+    MyParameterizedType<String> srcStr = new MyParameterizedType<String>(\"abc\");\n+    json = MyParameterizedTypeAdapter.<String>getExpectedJson(srcStr);\n+    MyParameterizedType<String> stringTarget = gson.fromJson(json, ptStringType);\n+    assertEquals(\"abc\", stringTarget.value);\n+  }\n+\n+  public void testParameterizedTypesWithWriterSerialization() throws Exception {\n+    Writer writer = new StringWriter();\n+    MyParameterizedType<Integer> src = new MyParameterizedType<Integer>(10);\n+    Type typeOfSrc = new TypeToken<MyParameterizedType<Integer>>() {}.getType();\n+    gson.toJson(src, typeOfSrc, writer);\n+    assertEquals(src.getExpectedJson(), writer.toString());\n+  }\n+\n+  public void testParameterizedTypeWithReaderDeserialization() throws Exception {\n+    BagOfPrimitives bag = new BagOfPrimitives();\n+    MyParameterizedType<BagOfPrimitives> expected = new MyParameterizedType<BagOfPrimitives>(bag);\n+    Type expectedType = new TypeToken<MyParameterizedType<BagOfPrimitives>>() {}.getType();\n+    BagOfPrimitives bagDefaultInstance = new BagOfPrimitives();\n+    Gson gson = new GsonBuilder().registerTypeAdapter(\n+        expectedType, new MyParameterizedTypeInstanceCreator<BagOfPrimitives>(bagDefaultInstance))\n+        .create();\n+\n+    Reader json = new StringReader(expected.getExpectedJson());\n+    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);\n+    assertEquals(expected, actual);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testVariableTypeFieldsAndGenericArraysSerialization() throws Exception {\n+    Integer obj = 0;\n+    Integer[] array = { 1, 2, 3 };\n+    List<Integer> list = new ArrayList<Integer>();\n+    list.add(4);\n+    list.add(5);\n+    List<Integer>[] arrayOfLists = new List[] { list, list };\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+\n+    assertEquals(objToSerialize.getExpectedJson(), json);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testVariableTypeFieldsAndGenericArraysDeserialization() throws Exception {\n+    Integer obj = 0;\n+    Integer[] array = { 1, 2, 3 };\n+    List<Integer> list = new ArrayList<Integer>();\n+    list.add(4);\n+    list.add(5);\n+    List<Integer>[] arrayOfLists = new List[] { list, list };\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(obj, array, list, arrayOfLists, list, arrayOfLists);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);\n+\n+    assertEquals(objAfterDeserialization.getExpectedJson(), json);\n+  }\n+\n+  public void testVariableTypeDeserialization() throws Exception {\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(0, null, null, null, null, null);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);\n+\n+    assertEquals(objAfterDeserialization.getExpectedJson(), json);\n+  }\n+\n+  public void testVariableTypeArrayDeserialization() throws Exception {\n+    Integer[] array = { 1, 2, 3 };\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(null, array, null, null, null, null);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);\n+\n+    assertEquals(objAfterDeserialization.getExpectedJson(), json);\n+  }\n+\n+  public void testParameterizedTypeWithVariableTypeDeserialization() throws Exception {\n+    List<Integer> list = new ArrayList<Integer>();\n+    list.add(4);\n+    list.add(5);\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(null, null, list, null, null, null);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);\n+\n+    assertEquals(objAfterDeserialization.getExpectedJson(), json);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testParameterizedTypeGenericArraysDeserialization() throws Exception {\n+    List<Integer> list = new ArrayList<Integer>();\n+    list.add(1);\n+    list.add(2);\n+    List<Integer>[] arrayOfLists = new List[] { list, list };\n+\n+    Type typeOfSrc = new TypeToken<ObjectWithTypeVariables<Integer>>() {}.getType();\n+    ObjectWithTypeVariables<Integer> objToSerialize =\n+        new ObjectWithTypeVariables<Integer>(null, null, null, arrayOfLists, null, null);\n+    String json = gson.toJson(objToSerialize, typeOfSrc);\n+    ObjectWithTypeVariables<Integer> objAfterDeserialization = gson.fromJson(json, typeOfSrc);\n+\n+    assertEquals(objAfterDeserialization.getExpectedJson(), json);\n+  }\n+\n+  /**\n+   * An test object that has fields that are type variables.\n+   *\n+   * @param <T> Enforce T to be a string to make writing the \"toExpectedJson\" method easier.\n+   */\n+  private static class ObjectWithTypeVariables<T extends Number> {\n+    private final T typeParameterObj;\n+    private final T[] typeParameterArray;\n+    private final List<T> listOfTypeParameters;\n+    private final List<T>[] arrayOfListOfTypeParameters;\n+    private final List<? extends T> listOfWildcardTypeParameters;\n+    private final List<? extends T>[] arrayOfListOfWildcardTypeParameters;\n+\n+    public ObjectWithTypeVariables() {\n+      this(null, null, null, null, null, null);\n+    }\n+\n+    public ObjectWithTypeVariables(T obj, T[] array, List<T> list, List<T>[] arrayOfList,\n+        List<? extends T> wildcardList, List<? extends T>[] arrayOfWildcardList) {\n+      this.typeParameterObj = obj;\n+      this.typeParameterArray = array;\n+      this.listOfTypeParameters = list;\n+      this.arrayOfListOfTypeParameters = arrayOfList;\n+      this.listOfWildcardTypeParameters = wildcardList;\n+      this.arrayOfListOfWildcardTypeParameters = arrayOfWildcardList;\n+    }\n+\n+    public String getExpectedJson() {\n+      StringBuilder sb = new StringBuilder().append(\"{\");\n+\n+      boolean needsComma = false;\n+      if (typeParameterObj != null) {\n+        sb.append(\"\\\"typeParameterObj\\\":\").append(toString(typeParameterObj));\n+        needsComma = true;\n+      }\n+\n+      if (typeParameterArray != null) {\n+        if (needsComma) {\n+          sb.append(',');\n+        }\n+        sb.append(\"\\\"typeParameterArray\\\":[\");\n+        appendObjectsToBuilder(sb, Arrays.asList(typeParameterArray));\n+        sb.append(']');\n+        needsComma = true;\n+      }\n+\n+      if (listOfTypeParameters != null) {\n+        if (needsComma) {\n+          sb.append(',');\n+        }\n+        sb.append(\"\\\"listOfTypeParameters\\\":[\");\n+        appendObjectsToBuilder(sb, listOfTypeParameters);\n+        sb.append(']');\n+        needsComma = true;\n+      }\n+\n+      if (arrayOfListOfTypeParameters != null) {\n+        if (needsComma) {\n+          sb.append(',');\n+        }\n+        sb.append(\"\\\"arrayOfListOfTypeParameters\\\":[\");\n+        appendObjectsToBuilder(sb, arrayOfListOfTypeParameters);\n+        sb.append(']');\n+        needsComma = true;\n+      }\n+\n+      if (listOfWildcardTypeParameters != null) {\n+        if (needsComma) {\n+          sb.append(',');\n+        }\n+        sb.append(\"\\\"listOfWildcardTypeParameters\\\":[\");\n+        appendObjectsToBuilder(sb, listOfWildcardTypeParameters);\n+        sb.append(']');\n+        needsComma = true;\n+      }\n+\n+      if (arrayOfListOfWildcardTypeParameters != null) {\n+        if (needsComma) {\n+          sb.append(',');\n+        }\n+        sb.append(\"\\\"arrayOfListOfWildcardTypeParameters\\\":[\");\n+        appendObjectsToBuilder(sb, arrayOfListOfWildcardTypeParameters);\n+        sb.append(']');\n+        needsComma = true;\n+      }\n+      sb.append('}');\n+      return sb.toString();\n+    }\n+\n+    private void appendObjectsToBuilder(StringBuilder sb, Iterable<? extends T> iterable) {\n+      boolean isFirst = true;\n+      for (T obj : iterable) {\n+        if (!isFirst) {\n+          sb.append(',');\n+        }\n+        isFirst = false;\n+        sb.append(toString(obj));\n+      }\n+    }\n+\n+    private void appendObjectsToBuilder(StringBuilder sb, List<? extends T>[] arrayOfList) {\n+      boolean isFirst = true;\n+      for (List<? extends T> list : arrayOfList) {\n+        if (!isFirst) {\n+          sb.append(',');\n+        }\n+        isFirst = false;\n+        if (list != null) {\n+          sb.append('[');\n+          appendObjectsToBuilder(sb, list);\n+          sb.append(']');\n+        } else {\n+          sb.append(\"null\");\n+        }\n+      }\n+    }\n+\n+    public String toString(T obj) {\n+      return obj.toString();\n+    }\n+  }\n+\n+  private static class MultiParameters<A, B, C, D, E> {\n+    A a;\n+    B b;\n+    C c;\n+    D d;\n+    E e;\n+    MultiParameters() {\n+    }\n+    MultiParameters(A a, B b, C c, D d, E e) {\n+      super();\n+      this.a = a;\n+      this.b = b;\n+      this.c = c;\n+      this.d = d;\n+      this.e = e;\n+    }\n+    @Override\n+    public int hashCode() {\n+      final int prime = 31;\n+      int result = 1;\n+      result = prime * result + ((a == null) ? 0 : a.hashCode());\n+      result = prime * result + ((b == null) ? 0 : b.hashCode());\n+      result = prime * result + ((c == null) ? 0 : c.hashCode());\n+      result = prime * result + ((d == null) ? 0 : d.hashCode());\n+      result = prime * result + ((e == null) ? 0 : e.hashCode());\n+      return result;\n+    }\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean equals(Object obj) {\n+      if (this == obj) {\n+        return true;\n+      }\n+      if (obj == null) {\n+        return false;\n+      }\n+      if (getClass() != obj.getClass()) {\n+        return false;\n+      }\n+      MultiParameters<A, B, C, D, E> other = (MultiParameters<A, B, C, D, E>) obj;\n+      if (a == null) {\n+        if (other.a != null) {\n+          return false;\n+        }\n+      } else if (!a.equals(other.a)) {\n+        return false;\n+      }\n+      if (b == null) {\n+        if (other.b != null) {\n+          return false;\n+        }\n+      } else if (!b.equals(other.b)) {\n+        return false;\n+      }\n+      if (c == null) {\n+        if (other.c != null) {\n+          return false;\n+        }\n+      } else if (!c.equals(other.c)) {\n+        return false;\n+      }\n+      if (d == null) {\n+        if (other.d != null) {\n+          return false;\n+        }\n+      } else if (!d.equals(other.d)) {\n+        return false;\n+      }\n+      if (e == null) {\n+        if (other.e != null) {\n+          return false;\n+        }\n+      } else if (!e.equals(other.e)) {\n+        return false;\n+      }\n+      return true;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+\n+import junit.framework.TestCase;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * Functional tests for Json primitive values: String, integers, and floating point numbers.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class PrimitiveTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testStringValueSerialization() throws Exception {\n+    String value = \"someRandomStringValue\";\n+    assertEquals('\"' + value + '\"', gson.toJson(value));\n+  }\n+\n+  public void testStringValueDeserialization() throws Exception {\n+    String value = \"someRandomStringValue\";\n+    String actual = gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\n+    assertEquals(value, actual);\n+  }\n+\n+  public void testSingleQuoteInStringSerialization() throws Exception {\n+    String valueWithQuotes = \"beforeQuote'afterQuote\";\n+    String jsonRepresentation = gson.toJson(valueWithQuotes);\n+    assertEquals(valueWithQuotes, gson.fromJson(jsonRepresentation, String.class));\n+  }\n+\n+  public void testSingleQuoteInStringDeserialization() throws Exception {\n+    String value = \"beforeQuote'afterQuote\";\n+    String actual = gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\n+    assertEquals(value, actual);\n+  }\n+\n+  public void testEscapingQuotesInStringSerialization() throws Exception {\n+    String valueWithQuotes = \"beforeQuote\\\"afterQuote\";\n+    String jsonRepresentation = gson.toJson(valueWithQuotes);\n+    String target = gson.fromJson(jsonRepresentation, String.class);\n+    assertEquals(valueWithQuotes, target);\n+  }\n+\n+  public void testEscapingQuotesInStringDeserialization() throws Exception {\n+    String value = \"beforeQuote\\\\\\\"afterQuote\";\n+    String actual = gson.fromJson(\"\\\"\" + value + \"\\\"\", String.class);\n+    String expected = \"beforeQuote\\\"afterQuote\";\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testStringValueAsSingleElementArraySerialization() throws Exception {\n+    String[] target = {\"abc\"};\n+    assertEquals(\"[\\\"abc\\\"]\", gson.toJson(target));\n+    assertEquals(\"[\\\"abc\\\"]\", gson.toJson(target, String[].class));\n+  }\n+\n+  public void testStringValueAsSingleElementArrayDeserialization() throws Exception {\n+    String value = \"someRandomStringValue\";\n+    String actual = gson.fromJson(\"[\\\"\" + value + \"\\\"]\", String.class);\n+    assertEquals(value, actual);\n+  }\n+\n+  public void testPrimitiveIntegerAutoboxedSerialization() {\n+    assertEquals(\"1\", gson.toJson(1));\n+  }\n+\n+  public void testPrimitiveIntegerAutoboxedDeserialization() {\n+    int expected = 1;\n+    int actual = gson.fromJson(\"1\", int.class);\n+    assertEquals(expected, actual);\n+\n+    actual = gson.fromJson(\"1\", Integer.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testPrimitiveIntegerAutoboxedInASingleElementArraySerialization() {\n+    int target[] = {-9332};\n+    assertEquals(\"[-9332]\", gson.toJson(target));\n+    assertEquals(\"[-9332]\", gson.toJson(target, int[].class));\n+    assertEquals(\"[-9332]\", gson.toJson(target, Integer[].class));\n+  }\n+\n+  public void testPrimitiveIntegerAutoboxedInASingleElementArrayDeserialization() {\n+    int expected = 1;\n+    int actual = gson.fromJson(\"[1]\", int.class);\n+    assertEquals(expected, actual);\n+\n+    actual = gson.fromJson(\"[1]\", Integer.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testReallyLongValuesSerialization() {\n+    long value = 333961828784581L;\n+    assertEquals(\"333961828784581\", gson.toJson(value));\n+  }\n+\n+  public void testReallyLongValuesDeserialization() {\n+    String json = \"333961828784581\";\n+    long value = gson.fromJson(json, Long.class);\n+    assertEquals(333961828784581L, value);\n+  }\n+\n+  public void testPrimitiveLongAutoboxedSerialization() {\n+    assertEquals(\"1\", gson.toJson(1L, long.class));\n+    assertEquals(\"1\", gson.toJson(1L, Long.class));\n+  }\n+\n+  public void testPrimitiveLongAutoboxedDeserialization() {\n+    long expected = 1L;\n+    long actual = gson.fromJson(\"1\", long.class);\n+    assertEquals(expected, actual);\n+\n+    actual = gson.fromJson(\"1\", Long.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testPrimitiveLongAutoboxedInASingleElementArraySerialization() {\n+    long[] target = {-23L};\n+    assertEquals(\"[-23]\", gson.toJson(target));\n+    assertEquals(\"[-23]\", gson.toJson(target, long[].class));\n+    assertEquals(\"[-23]\", gson.toJson(target, Long[].class));\n+  }\n+\n+  public void testPrimitiveLongAutoboxedInASingleElementArrayDeserialization() {\n+    long expected = 1L;\n+    long actual = gson.fromJson(\"[1]\", long.class);\n+    assertEquals(expected, actual);\n+\n+    actual = gson.fromJson(\"[1]\", Long.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testPrimitiveBooleanAutoboxedSerialization() {\n+    assertEquals(\"true\", gson.toJson(true));\n+    assertEquals(\"false\", gson.toJson(false));\n+  }\n+\n+  public void testPrimitiveBooleanAutoboxedDeserialization() {\n+    assertEquals(Boolean.FALSE, gson.fromJson(\"[false]\", Boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"[true]\", Boolean.class));\n+\n+    boolean value = gson.fromJson(\"false\", boolean.class);\n+    assertEquals(false, value);\n+    value = gson.fromJson(\"true\", boolean.class);\n+    assertEquals(true, value);\n+  }\n+\n+  public void testPrimitiveBooleanAutoboxedInASingleElementArraySerialization() {\n+    boolean target[] = {false};\n+    assertEquals(\"[false]\", gson.toJson(target));\n+    assertEquals(\"[false]\", gson.toJson(target, boolean[].class));\n+    assertEquals(\"[false]\", gson.toJson(target, Boolean[].class));\n+  }\n+\n+  public void testPrimitiveBooleanAutoboxedInASingleElementArrayDeserialization() {\n+    assertEquals(Boolean.FALSE, gson.fromJson(\"[false]\", Boolean.class));\n+    assertEquals(Boolean.TRUE, gson.fromJson(\"[true]\", Boolean.class));\n+\n+    boolean value = gson.fromJson(\"[false]\", boolean.class);\n+    assertEquals(false, value);\n+    value = gson.fromJson(\"[true]\", boolean.class);\n+    assertEquals(true, value);\n+  }\n+\n+  public void testPrimitiveDoubleAutoboxedSerialization() {\n+    assertEquals(\"-122.08234335\", gson.toJson(-122.08234335));\n+    assertEquals(\"122.08112002\", gson.toJson(new Double(122.08112002)));\n+  }\n+\n+  public void testPrimitiveDoubleAutoboxedDeserialization() {\n+    double actual = gson.fromJson(\"-122.08858585\", double.class);\n+    assertEquals(-122.08858585, actual);\n+\n+    actual = gson.fromJson(\"122.023900008000\", Double.class);\n+    assertEquals(122.023900008, actual);\n+  }\n+\n+  public void testPrimitiveDoubleAutoboxedInASingleElementArraySerialization() {\n+    double[] target = {-122.08D};\n+    assertEquals(\"[-122.08]\", gson.toJson(target));\n+    assertEquals(\"[-122.08]\", gson.toJson(target, double[].class));\n+    assertEquals(\"[-122.08]\", gson.toJson(target, Double[].class));\n+  }\n+\n+  public void testPrimitiveDoubleAutoboxedInASingleElementArrayDeserialization() {\n+    double expected = -122.08;\n+    double actual = gson.fromJson(\"[-122.08]\", double.class);\n+    assertEquals(expected, actual);\n+\n+    actual = gson.fromJson(\"[-122.08]\", Double.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testBigDecimalSerialization() {\n+    BigDecimal target = new BigDecimal(\"-122.0e-21\");\n+    String json = gson.toJson(target);\n+    assertEquals(target, new BigDecimal(json));\n+  }\n+\n+  public void testBigDecimalDeserialization() {\n+    BigDecimal target = new BigDecimal(\"-122.0e-21\");\n+    String json = \"-122.0e-21\";\n+    assertEquals(target, gson.fromJson(json, BigDecimal.class));\n+  }\n+\n+  public void testBigDecimalInASingleElementArraySerialization() {\n+    BigDecimal[] target = {new BigDecimal(\"-122.08e-21\")};\n+    String json = gson.toJson(target);\n+    String actual = extractElementFromArray(json);\n+    assertEquals(target[0], new BigDecimal(actual));\n+\n+    json = gson.toJson(target, BigDecimal[].class);\n+    actual = extractElementFromArray(json);\n+    assertEquals(target[0], new BigDecimal(actual));\n+  }\n+\n+  public void testBigDecimalInASingleElementArrayDeserialization() {\n+    BigDecimal expected = new BigDecimal(\"-122.08e-21\");\n+    BigDecimal actual = gson.fromJson(\"[-122.08e-21]\", BigDecimal.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testSmallValueForBigDecimalSerialization() {\n+    BigDecimal target = new BigDecimal(\"1.55\");\n+    String actual = gson.toJson(target);\n+    assertEquals(target.toString(), actual);\n+  }\n+\n+  public void testSmallValueForBigDecimalDeserialization() {\n+    BigDecimal expected = new BigDecimal(\"1.55\");\n+    BigDecimal actual = gson.fromJson(\"1.55\", BigDecimal.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testBigIntegerSerialization() {\n+    BigInteger target = new BigInteger(\"12121211243123245845384534687435634558945453489543985435\");\n+    assertEquals(target.toString(), gson.toJson(target));\n+  }\n+\n+  public void testBigIntegerDeserialization() {\n+    String json = \"12121211243123245845384534687435634558945453489543985435\";\n+    BigInteger target = new BigInteger(json);\n+    assertEquals(target, gson.fromJson(json, BigInteger.class));\n+  }\n+\n+  public void testBigIntegerInASingleElementArraySerialization() {\n+    BigInteger[] target = {new BigInteger(\"1212121243434324323254365345367456456456465464564564\")};\n+    String json = gson.toJson(target);\n+    String actual = extractElementFromArray(json);\n+    assertEquals(target[0], new BigInteger(actual));\n+\n+    json = gson.toJson(target, BigInteger[].class);\n+    actual = extractElementFromArray(json);\n+    assertEquals(target[0], new BigInteger(actual));\n+  }\n+\n+  public void testBigIntegerInASingleElementArrayDeserialization() {\n+    BigInteger expected = new BigInteger(\"34343434343424242423432323243243242\");\n+    BigInteger actual = gson.fromJson(\"[34343434343424242423432323243243242]\", BigInteger.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testSmallValueForBigIntegerSerialization() {\n+    BigInteger target = new BigInteger(\"15\");\n+    String actual = gson.toJson(target);\n+    assertEquals(target.toString(), actual);\n+  }\n+\n+  public void testSmallValueForBigIntegerDeserialization() {\n+    BigInteger expected = new BigInteger(\"15\");\n+    BigInteger actual = gson.fromJson(\"15\", BigInteger.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testBadValueForBigIntegerDeserialization() {\n+    try {\n+      gson.fromJson(\"15.099\", BigInteger.class);\n+      fail(\"BigInteger can not be decimal values.\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  private String extractElementFromArray(String json) {\n+    return json.substring(json.indexOf('[') + 1, json.indexOf(']'));\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassWithTransientFields;\n+import com.google.gson.common.TestTypes.Nested;\n+import com.google.gson.common.TestTypes.PrimitiveArray;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Functional tests for print formatting.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class PrintFormattingTest extends TestCase {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testCompactFormattingLeavesNoWhiteSpace() {\n+    Gson gson = new Gson();\n+    List list = new ArrayList();\n+    list.add(new BagOfPrimitives());\n+    list.add(new Nested());\n+    list.add(new PrimitiveArray());\n+    list.add(new ClassWithTransientFields());\n+\n+    String json = gson.toJson(list);\n+    assertContainsNoWhiteSpace(json);\n+  }\n+\n+  private static void assertContainsNoWhiteSpace(String str) {\n+    for (char c : str.toCharArray()) {\n+      assertFalse(Character.isWhitespace(c));\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+/**\n+ * Functional tests for the support of {@link Reader}s and {@link Writer}s.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class ReadersWritersTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testWriterForSerialization() throws Exception {\n+    Writer writer = new StringWriter();\n+    BagOfPrimitives src = new BagOfPrimitives();\n+    gson.toJson(src, writer);\n+    assertEquals(src.getExpectedJson(), writer.toString());\n+  }\n+\n+  public void testReaderForDeserialization() throws Exception {\n+    BagOfPrimitives expected = new BagOfPrimitives();\n+    Reader json = new StringReader(expected.getExpectedJson());\n+    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  public void testTopLevelNullObjectSerializationWithWriter() {\n+    StringWriter writer = new StringWriter();\n+    gson.toJson(null, writer);\n+    assertEquals(\"\", writer.toString());\n+  }\n+\n+  public void testTopLevelNullObjectDeserializationWithReader() {\n+    StringReader reader = new StringReader(\"null\");\n+    Integer nullIntObject = gson.fromJson(reader, Integer.class);\n+    assertNull(nullIntObject);\n+  }\n+\n+  public void testTopLevelNullObjectSerializationWithWriterAndSerializeNulls() {\n+    Gson gson = new GsonBuilder().serializeNulls().create();\n+    StringWriter writer = new StringWriter();\n+    gson.toJson(null, writer);\n+    assertEquals(\"null\", writer.toString());\n+  }\n+\n+  public void testTopLevelNullObjectDeserializationWithReaderAndSerializeNulls() {\n+    Gson gson = new GsonBuilder().serializeNulls().create();\n+    StringReader reader = new StringReader(\"null\");\n+    Integer nullIntObject = gson.fromJson(reader, Integer.class);\n+    assertNull(nullIntObject);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/UncategorizedTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.common.TestTypes.ClassOverridingEquals;\n+\n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Functional tests that do not fall neatly into any of the existing classification.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class UncategorizedTest extends TestCase {\n+\n+  private Gson gson = null;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testInvalidJsonDeserializationFails() throws Exception {\n+    try {\n+      gson.fromJson(\"adfasdf1112,,,\\\":\", BagOfPrimitives.class);\n+      fail(\"Bad JSON should throw a ParseException\");\n+    } catch (JsonParseException expected) { }\n+\n+    try {\n+      gson.fromJson(\"{adfasdf1112,,,\\\":}\", BagOfPrimitives.class);\n+      fail(\"Bad JSON should throw a ParseException\");\n+    } catch (JsonParseException expected) { }\n+  }\n+\n+  public void testObjectEqualButNotSameSerialization() throws Exception {\n+    ClassOverridingEquals objA = new ClassOverridingEquals();\n+    ClassOverridingEquals objB = new ClassOverridingEquals();\n+    objB.ref = objA;\n+    String json = gson.toJson(objB);\n+    assertEquals(objB.getExpectedJson(), json);\n+  }\n+\n+  public void testStaticFieldsAreNotSerialized() {\n+    BagOfPrimitives target = new BagOfPrimitives();\n+    assertFalse(gson.toJson(target).contains(\"DEFAULT_VALUE\"));\n+  }\n+\n+  /**\n+   * This test ensures that a custom deserializer is able to return a derived class instance for a\n+   * base class object. For a motivation for this test, see Issue 37 and\n+   * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761\n+   */\n+  public void testReturningDerivedClassesDuringDeserialization() {\n+    Gson gson = new GsonBuilder().registerTypeAdapter(Base.class, new BaseTypeAdapter()).create();\n+    String json = \"{\\\"opType\\\":\\\"OP1\\\"}\";\n+    Base base = gson.fromJson(json, Base.class);\n+    assertTrue(base instanceof Derived1);\n+    assertEquals(OperationType.OP1, base.opType);\n+\n+    json = \"{\\\"opType\\\":\\\"OP2\\\"}\";\n+    base = gson.fromJson(json, Base.class);\n+    assertTrue(base instanceof Derived2);\n+    assertEquals(OperationType.OP2, base.opType);\n+  }\n+\n+  private enum OperationType { OP1, OP2 }\n+  private static class Base {\n+    OperationType opType;\n+  }\n+  private static class Derived1 extends Base {\n+    Derived1() { opType = OperationType.OP1; }\n+  }\n+  private static class Derived2 extends Base {\n+    Derived2() { opType = OperationType.OP2; }\n+  }\n+  private static class BaseTypeAdapter implements JsonDeserializer<Base> {\n+    public Base deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      String opTypeStr = json.getAsJsonObject().get(\"opType\").getAsString();\n+      OperationType opType = OperationType.valueOf(opTypeStr);\n+      switch (opType) {\n+      case OP1:\n+        return new Derived1();\n+      case OP2:\n+        return new Derived2();\n+      }\n+      throw new JsonParseException(\"unknown type: \" + json);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/VersioningTest.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.annotations.Since;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Functional tests for versioning support in Gson.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class VersioningTest extends TestCase {\n+  private static final int A = 0;\n+  private static final int B = 1;\n+  private static final int C = 2;\n+  private static final int D = 3;\n+\n+  private GsonBuilder builder;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    builder = new GsonBuilder();\n+  }\n+\n+  public void testVersionedClassesSerialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    String json1 = gson.toJson(new Version1());\n+    String json2 = gson.toJson(new Version1_1());\n+    assertEquals(json1, json2);\n+  }\n+\n+  public void testVersionedClassesDeserialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    String json = \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\n+    Version1 version1 = gson.fromJson(json, Version1.class);\n+    assertEquals(3, version1.a);\n+    assertEquals(4, version1.b);\n+    Version1_1 version1_1 = gson.fromJson(json, Version1_1.class);\n+    assertEquals(3, version1_1.a);\n+    assertEquals(4, version1_1.b);\n+    assertEquals(C, version1_1.c);\n+  }\n+\n+  public void testIgnoreLaterVersionClassSerialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    assertEquals(\"\", gson.toJson(new Version1_2()));\n+  }\n+\n+  public void testIgnoreLaterVersionClassDeserialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    String json = \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\";\n+    Version1_2 version1_2 = gson.fromJson(json, Version1_2.class);\n+    // Since the class is versioned to be after 1.0, all fields should get set to\n+    // their default values.\n+    assertEquals(A, version1_2.a);\n+    assertEquals(B, version1_2.b);\n+    assertEquals(C, version1_2.c);\n+    assertEquals(D, version1_2.d);\n+  }\n+\n+  public void testVersionedGsonWithUnversionedClassesSerialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, \"stringValue\");\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  public void testVersionedGsonWithUnversionedClassesDeserialization() {\n+    Gson gson = builder.setVersion(1.0).create();\n+    String json = \"{\\\"longValue\\\":10,\\\"intValue\\\":20,\\\"booleanValue\\\":false}\";\n+\n+    BagOfPrimitives expected = new BagOfPrimitives(10, 20, false, null);\n+    BagOfPrimitives actual = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(expected, actual);\n+  }\n+\n+  private static class Version1 {\n+    int a = A;\n+    @Since(1.0) int b = B;\n+  }\n+\n+  private static class Version1_1 extends Version1 {\n+    @Since(1.1) int c = C;\n+  }\n+\n+  @Since(1.2)\n+  private static class Version1_2 extends Version1_1 {\n+    int d = D;\n+  }\n+}", "timestamp": 1220238812, "metainfo": ""}