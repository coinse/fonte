{"sha": "46e65a77c5856d21f2d5e7c90306dbbd894da57e", "log": "Convert RuntimeTypeAdapter to a TypeAdapterFactory; this avoids the need for serializeDefault()", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.typeadapters;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapts values whose runtime type may differ from their declaration type. This\n+ * is necessary when a field's type is not the same type that GSON should create\n+ * when deserializing that field. For example, consider these types:\n+ * <pre>   {@code\n+ *   abstract class Shape {\n+ *     int x;\n+ *     int y;\n+ *   }\n+ *   class Circle extends Shape {\n+ *     int radius;\n+ *   }\n+ *   class Rectangle extends Shape {\n+ *     int width;\n+ *     int height;\n+ *   }\n+ *   class Diamond extends Shape {\n+ *     int width;\n+ *     int height;\n+ *   }\n+ *   class Drawing {\n+ *     Shape bottomShape;\n+ *     Shape topShape;\n+ *   }\n+ * }</pre>\n+ * <p>Without additional type information, the serialized JSON is ambiguous. Is\n+ * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code\n+ *   {\n+ *     \"bottomShape\": {\n+ *       \"width\": 10,\n+ *       \"height\": 5,\n+ *       \"x\": 0,\n+ *       \"y\": 0\n+ *     },\n+ *     \"topShape\": {\n+ *       \"radius\": 2,\n+ *       \"x\": 4,\n+ *       \"y\": 1\n+ *     }\n+ *   }}</pre>\n+ * This class addresses this problem by adding type information to the\n+ * serialized JSON and honoring that type information when the JSON is\n+ * deserialized: <pre>   {@code\n+ *   {\n+ *     \"bottomShape\": {\n+ *       \"type\": \"Diamond\",\n+ *       \"width\": 10,\n+ *       \"height\": 5,\n+ *       \"x\": 0,\n+ *       \"y\": 0\n+ *     },\n+ *     \"topShape\": {\n+ *       \"type\": \"Circle\",\n+ *       \"radius\": 2,\n+ *       \"x\": 4,\n+ *       \"y\": 1\n+ *     }\n+ *   }}</pre>\n+ * Both the type field name ({@code \"type\"}) and the type labels ({@code\n+ * \"Rectangle\"}) are configurable.\n+ *\n+ * <h3>Registering Types</h3>\n+ * Create a {@code RuntimeTypeAdapter} by passing the base type and type field\n+ * name to the {@link #of} factory method. If you don't supply an explicit type\n+ * field name, {@code \"type\"} will be used. <pre>   {@code\n+ *   RuntimeTypeAdapter<Shape> shapeAdapter\n+ *       = RuntimeTypeAdapter.of(Shape.class, \"type\");\n+ * }</pre>\n+ * Next register all of your subtypes. Every subtype must be explicitly\n+ * registered. This protects your application from injection attacks. If you\n+ * don't supply an explicit type label, the type's simple name will be used.\n+ * <pre>   {@code\n+ *   shapeAdapter.registerSubtype(Rectangle.class, \"Rectangle\");\n+ *   shapeAdapter.registerSubtype(Circle.class, \"Circle\");\n+ *   shapeAdapter.registerSubtype(Diamond.class, \"Diamond\");\n+ * }</pre>\n+ * Finally, register the type adapter in your application's GSON builder:\n+ * <pre>   {@code\n+ *   Gson gson = new GsonBuilder()\n+ *       .registerTypeAdapter(Shape.class, shapeAdapter)\n+ *       .create();\n+ * }</pre>\n+ * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n+ *   RuntimeTypeAdapter<Shape> shapeAdapter = RuntimeTypeAdapterFactory.of(Shape.class)\n+ *       .registerSubtype(Rectangle.class)\n+ *       .registerSubtype(Circle.class)\n+ *       .registerSubtype(Diamond.class);\n+ * }</pre>\n+ */\n+public final class RuntimeTypeAdapterFactory<T> implements TypeAdapter.Factory {\n+  private final Class<?> baseType;\n+  private final String typeFieldName;\n+  private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();\n+  private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<Class<?>, String>();\n+\n+  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {\n+    if (typeFieldName == null || baseType == null) {\n+      throw new NullPointerException();\n+    }\n+    this.baseType = baseType;\n+    this.typeFieldName = typeFieldName;\n+  }\n+\n+  /**\n+   * Creates a new runtime type adapter using for {@code baseType} using {@code\n+   * typeFieldName} as the type field name. Type field names are case sensitive.\n+   */\n+  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {\n+    return new RuntimeTypeAdapterFactory<T>(baseType, typeFieldName);\n+  }\n+\n+  /**\n+   * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\n+   * the type field name.\n+   */\n+  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {\n+    return new RuntimeTypeAdapterFactory<T>(baseType, \"type\");\n+  }\n+\n+  /**\n+   * Registers {@code type} identified by {@code label}. Labels are case\n+   * sensitive.\n+   *\n+   * @throws IllegalArgumentException if either {@code type} or {@code label}\n+   *     have already been registered on this type adapter.\n+   */\n+  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {\n+    if (type == null || label == null) {\n+      throw new NullPointerException();\n+    }\n+    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\n+      throw new IllegalArgumentException(\"types and labels must be unique\");\n+    }\n+    labelToSubtype.put(label, type);\n+    subtypeToLabel.put(type, label);\n+    return this;\n+  }\n+\n+  /**\n+   * Registers {@code type} identified by its {@link Class#getSimpleName simple\n+   * name}. Labels are case sensitive.\n+   *\n+   * @throws IllegalArgumentException if either {@code type} or its simple name\n+   *     have already been registered on this type adapter.\n+   */\n+  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {\n+    return registerSubtype(type, type.getSimpleName());\n+  }\n+\n+  @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+    if (type.getRawType() != baseType) {\n+      return null;\n+    }\n+\n+    final Map<String, TypeAdapter<?>> labelToDelegate\n+        = new LinkedHashMap<String, TypeAdapter<?>>();\n+    final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n+        = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n+    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n+      TypeAdapter<?> delegate = context.getNextAdapter(this, TypeToken.get(entry.getValue()));\n+      labelToDelegate.put(entry.getKey(), delegate);\n+      subtypeToDelegate.put(entry.getValue(), delegate);\n+    }\n+\n+    return new TypeAdapter<T>() {\n+      @Override public T read(JsonReader reader) throws IOException {\n+        JsonElement jsonElement = Streams.parse(reader);\n+        JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\n+        if (labelJsonElement == null) {\n+          throw new JsonParseException(\"cannot deserialize \" + baseType\n+              + \" because it does not define a field named \" + typeFieldName);\n+        }\n+        String label = labelJsonElement.getAsString();\n+        @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n+        TypeAdapter<T> delegate = (TypeAdapter<T>) labelToDelegate.get(label);\n+        if (delegate == null) {\n+          throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n+              + label + \"; did you forget to register a subtype?\");\n+        }\n+        return delegate.fromJsonElement(jsonElement);\n+      }\n+\n+      @Override public void write(JsonWriter writer, T value) throws IOException {\n+        Class<?> srcType = value.getClass();\n+        String label = subtypeToLabel.get(srcType);\n+        @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n+        TypeAdapter<T> delegate = (TypeAdapter<T>) subtypeToDelegate.get(srcType);\n+        if (delegate == null) {\n+          throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n+              + \"; did you forget to register a subtype?\");\n+        }\n+        JsonObject jsonObject = delegate.toJsonElement(value).getAsJsonObject();\n+        if (jsonObject.has(typeFieldName)) {\n+          throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n+              + \" because it already defines a field named \" + typeFieldName);\n+        }\n+        JsonObject clone = new JsonObject();\n+        clone.add(typeFieldName, new JsonPrimitive(label));\n+        for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {\n+          clone.add(e.getKey(), e.getValue());\n+        }\n+        Streams.write(clone, true, writer);\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.typeadapters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import junit.framework.TestCase;\n+\n+public final class RuntimeTypeAdapterFactoryTest extends TestCase {\n+\n+  public void testRuntimeTypeAdapter() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class)\n+        .registerSubtype(CreditCard.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, rta)\n+        .create();\n+\n+    CreditCard original = new CreditCard(\"Jesse\", 234);\n+    assertEquals(\"{\\\"type\\\":\\\"CreditCard\\\",\\\"cvv\\\":234,\\\"ownerName\\\":\\\"Jesse\\\"}\",\n+        gson.toJson(original, BillingInstrument.class));\n+    BillingInstrument deserialized = gson.fromJson(\n+        \"{type:'CreditCard',cvv:234,ownerName:'Jesse'}\", BillingInstrument.class);\n+    assertEquals(\"Jesse\", deserialized.ownerName);\n+    assertTrue(deserialized instanceof CreditCard);\n+  }\n+\n+  public void testRuntimeTypeIsBaseType() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class)\n+        .registerSubtype(BillingInstrument.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, rta)\n+        .create();\n+\n+    BillingInstrument original = new BillingInstrument(\"Jesse\");\n+    assertEquals(\"{\\\"type\\\":\\\"BillingInstrument\\\",\\\"ownerName\\\":\\\"Jesse\\\"}\",\n+        gson.toJson(original, BillingInstrument.class));\n+    BillingInstrument deserialized = gson.fromJson(\n+        \"{type:'BillingInstrument',ownerName:'Jesse'}\", BillingInstrument.class);\n+    assertEquals(\"Jesse\", deserialized.ownerName);\n+  }\n+\n+  public void testNullBaseType() {\n+    try {\n+      RuntimeTypeAdapterFactory.of(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullTypeFieldName() {\n+    try {\n+      RuntimeTypeAdapterFactory.of(BillingInstrument.class, null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullSubtype() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class);\n+    try {\n+      rta.registerSubtype(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullLabel() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class);\n+    try {\n+      rta.registerSubtype(CreditCard.class, null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testDuplicateSubtype() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class);\n+    rta.registerSubtype(CreditCard.class, \"CC\");\n+    try {\n+      rta.registerSubtype(CreditCard.class, \"Visa\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testDuplicateLabel() {\n+    RuntimeTypeAdapterFactory<BillingInstrument> rta = RuntimeTypeAdapterFactory.of(\n+        BillingInstrument.class);\n+    rta.registerSubtype(CreditCard.class, \"CC\");\n+    try {\n+      rta.registerSubtype(BankTransfer.class, \"CC\");\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testDeserializeMissingTypeField() {\n+    Object billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)\n+        .registerSubtype(CreditCard.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.fromJson(\"{ownerName:'Jesse'}\", BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testDeserializeMissingSubtype() {\n+    Object billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)\n+        .registerSubtype(BankTransfer.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.fromJson(\"{type:'CreditCard',ownerName:'Jesse'}\", BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testSerializeMissingSubtype() {\n+    Object billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class)\n+        .registerSubtype(BankTransfer.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  public void testSerializeCollidingTypeFieldName() {\n+    Object billingAdapter = RuntimeTypeAdapterFactory.of(BillingInstrument.class, \"cvv\")\n+        .registerSubtype(CreditCard.class);\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(BillingInstrument.class, billingAdapter)\n+        .create();\n+    try {\n+      gson.toJson(new CreditCard(\"Jesse\", 456), BillingInstrument.class);\n+      fail();\n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n+  static class BillingInstrument {\n+    private final String ownerName;\n+    BillingInstrument(String ownerName) {\n+      this.ownerName = ownerName;\n+    }\n+  }\n+\n+  static class CreditCard extends BillingInstrument {\n+    int cvv;\n+    CreditCard(String ownerName, int cvv) {\n+      super(ownerName);\n+      this.cvv = cvv;\n+    }\n+  }\n+\n+  static class BankTransfer extends BillingInstrument {\n+    int bankAccount;\n+    BankTransfer(String ownerName, int bankAccount) {\n+      super(ownerName);\n+      this.bankAccount = bankAccount;\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n         DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS,\n         false, DefaultTypeAdapters.DEFAULT_SERIALIZERS,\n         DefaultTypeAdapters.DEFAULT_DESERIALIZERS, false, DEFAULT_JSON_NON_EXECUTABLE, true,\n-        false, false, LongSerializationPolicy.DEFAULT);\n+        false, false, LongSerializationPolicy.DEFAULT,\n+        Collections.<TypeAdapter.Factory>emptyList());\n   }\n \n   Gson(final ExclusionStrategy deserializationExclusionStrategy,\n       final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n-      LongSerializationPolicy longSerializationPolicy) {\n+      LongSerializationPolicy longSerializationPolicy,\n+      List<TypeAdapter.Factory> typeAdapterFactories) {\n     this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n     this.serializationExclusionStrategy = serializationExclusionStrategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())\n         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())\n         .factory(new CollectionTypeAdapterFactory(constructorConstructor))\n-        .factory(ObjectTypeAdapter.FACTORY)\n-        .factory(new GsonToMiniGsonTypeAdapterFactory(serializers, deserializers,\n-            new JsonDeserializationContext(this), new JsonSerializationContext(this), serializeNulls\n-        ))\n+        .factory(ObjectTypeAdapter.FACTORY);\n+\n+    for (TypeAdapter.Factory factory : typeAdapterFactories) {\n+      builder.factory(factory);\n+    }\n+\n+    builder.factory(new GsonToMiniGsonTypeAdapterFactory(serializers, deserializers,\n+        new JsonDeserializationContext(this), new JsonSerializationContext(this), serializeNulls))\n         .factory(TypeAdapters.URL_FACTORY)\n         .factory(TypeAdapters.URI_FACTORY)\n         .factory(TypeAdapters.UUID_FACTORY)\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n+import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.bind.TypeAdapter;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Date;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n-\n-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n-import com.google.gson.internal.$Gson$Preconditions;\n-import com.google.gson.internal.ParameterizedTypeHandlerMap;\n-import com.google.gson.internal.Primitives;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;\n   private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n   private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final List<TypeAdapter.Factory> typeAdapterFactories\n+      = new ArrayList<TypeAdapter.Factory>();\n   private boolean serializeNulls;\n   private String datePattern;\n   private int dateStyle;\n \n   private GsonBuilder registerTypeAdapter(Type type, Object typeAdapter, boolean isSystem) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+        || typeAdapter instanceof JsonDeserializer<?>\n+        || typeAdapter instanceof InstanceCreator<?>\n+        || typeAdapter instanceof TypeAdapter.Factory);\n     if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type)) {\n       throw new IllegalArgumentException(\n           \"Cannot register type adapters for \" + type);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n       registerDeserializer(type, (JsonDeserializer<?>) typeAdapter, isSystem);\n+    }\n+    if (typeAdapter instanceof TypeAdapter.Factory) {\n+      typeAdapterFactories.add((TypeAdapter.Factory) typeAdapter);\n     }\n     return this;\n   }\n         fieldNamingPolicy, customInstanceCreators, serializeNulls,\n         customSerializers, customDeserializers, complexMapKeySerialization,\n         generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n-        serializeSpecialFloatingPointValues, longSerializationPolicy);\n+        serializeSpecialFloatingPointValues, longSerializationPolicy, typeAdapterFactories);\n   }\n \n   private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n--- a/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java\n package com.google.gson;\n \n import com.google.gson.common.TestTypes.ClassWithNoFields;\n+import com.google.gson.internal.bind.TypeAdapter;\n import java.lang.reflect.Modifier;\n+import java.util.Collections;\n import java.util.LinkedList;\n import junit.framework.TestCase;\n \n         DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS,\n         false, DefaultTypeAdapters.DEFAULT_SERIALIZERS,\n         DefaultTypeAdapters.DEFAULT_DESERIALIZERS, false, Gson.DEFAULT_JSON_NON_EXECUTABLE,\n-        true, false, false, LongSerializationPolicy.DEFAULT);\n+        true, false, false, LongSerializationPolicy.DEFAULT,\n+        Collections.<TypeAdapter.Factory>emptyList());\n     assertEquals(\"{}\", gson.toJson(new ClassWithNoFields() {\n       // empty anonymous class\n     }));", "timestamp": 1317237286, "metainfo": ""}