{"sha": "cbcf7defa344ad1dee63baa0767613a5f9848e86", "log": "Updated Grammar for matching JsonArray to be left-associative rather than right-associative. Gson can now parse arrays of size over 11MB instead of 80KB which was the prior limit. Thanks for the tip, kenotron.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonArray.java\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n    * Creates an empty JsonArray.\n    */\n   public JsonArray() {\n-    elements = new LinkedList<JsonElement>();\n+    elements = new ArrayList<JsonElement>();\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonParserJavacc.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavacc.java\n   JsonArray array = new JsonArray();\n     jj_consume_token(31);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 32:\n+      array = JsonArrayEmpty(array);\n+                               {if (true) return array;}\n+      break;\n     case DIGITS:\n     case NULL:\n     case NAN:\n     case 27:\n     case 31:\n     case 33:\n-      Elements(array);\n-      break;\n-    default:\n-      jj_la1[6] = jj_gen;\n-      ;\n-    }\n+      JsonArrayElement(array);\n+      label_1:\n+      while (true) {\n+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+        case 29:\n+          ;\n+          break;\n+        default:\n+          jj_la1[6] = jj_gen;\n+          break label_1;\n+        }\n+        JsonArrayNextElement(array);\n+      }\n+      jj_consume_token(32);\n+                                                              {if (true) return array;}\n+      break;\n+    default:\n+      jj_la1[7] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonArray JsonArrayEmpty(JsonArray array) throws ParseException {\n     jj_consume_token(32);\n-    array.reverse();\n+        {if (true) return array;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonArray JsonArrayElement(JsonArray array) throws ParseException {\n+  JsonElement element = null;\n+    element = JsonValue();\n+                       array.add(element);\n     {if (true) return array;}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n-  final private void Elements(JsonArray array) throws ParseException {\n-  JsonElement element;\n+  final private JsonArray JsonArrayNextElement(JsonArray array) throws ParseException {\n+  JsonElement element = null;\n+    jj_consume_token(29);\n     element = JsonValue();\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 29:\n-      jj_consume_token(29);\n-      Elements(array);\n-      break;\n-    default:\n-      jj_la1[7] = jj_gen;\n-      ;\n-    }\n-    array.add(element);\n+                           array.add(element);\n+    {if (true) return array;}\n+    throw new Error(\"Missing return statement in function\");\n   }\n \n   final private JsonElement JsonValue() throws ParseException {\n     finally { jj_save(0, xla); }\n   }\n \n-  private boolean jj_3R_4() {\n+  private boolean jj_3R_3() {\n+    if (jj_scan_token(NAN)) return true;\n+    return false;\n+  }\n+\n+  private boolean jj_3R_2() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_3()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_4()) return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean jj_3R_5() {\n     if (jj_scan_token(33)) return true;\n     return false;\n   }\n \n-  private boolean jj_3R_3() {\n+  private boolean jj_3R_4() {\n     Token xsp;\n     xsp = jj_scanpos;\n-    if (jj_3R_4()) jj_scanpos = xsp;\n+    if (jj_3R_5()) jj_scanpos = xsp;\n     if (jj_scan_token(INFINITY)) return true;\n     return false;\n   }\n \n   private boolean jj_3_1() {\n-    if (jj_3R_1()) return true;\n-    return false;\n-  }\n-\n-  private boolean jj_3R_2() {\n-    if (jj_scan_token(NAN)) return true;\n-    return false;\n-  }\n-\n-  private boolean jj_3R_1() {\n-    Token xsp;\n-    xsp = jj_scanpos;\n-    if (jj_3R_2()) {\n-    jj_scanpos = xsp;\n-    if (jj_3R_3()) return true;\n-    }\n+    if (jj_3R_2()) return true;\n     return false;\n   }\n \n       jj_la1_init_1();\n    }\n    private static void jj_la1_init_0() {\n-      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x8c0307c1,0x31800,0x20000000,0x31800,0x880307c0,0x20000000,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n+      jj_la1_0 = new int[] {0x4000000,0x880307c0,0x8c0307c1,0x31800,0x20000000,0x31800,0x20000000,0x880307c0,0x880307c0,0x30740,0x0,0x20,0x40,0x0,0x300,0x0,0x1800,0x30000,};\n    }\n    private static void jj_la1_init_1() {\n-      jj_la1_1 = new int[] {0x0,0x2,0x2,0x0,0x0,0x0,0x2,0x0,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n+      jj_la1_1 = new int[] {0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x3,0x2,0x2,0x4,0x0,0x2,0x2,0x2,0x2,0x0,0x0,};\n    }\n   final private JJCalls[] jj_2_rtns = new JJCalls[1];\n   private boolean jj_rescan = false;\n--- a/gson/src/main/java/com/google/gson/JsonParserJavaccConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavaccConstants.java\n  * Token literal values and constants.\n  * Generated by org.javacc.parser.OtherFilesGen#start()\n  */\n-@SuppressWarnings(\"all\")\n interface JsonParserJavaccConstants {\n \n   /** End of File. */\n--- a/gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java\n    beginColumn = input_stream.getBeginColumn();\n    endLine = input_stream.getEndLine();\n    endColumn = input_stream.getEndColumn();\n-   t = Token.newToken(jjmatchedKind);\n-   t.kind = jjmatchedKind;\n-   t.image = curTokenImage;\n+   t = Token.newToken(jjmatchedKind, curTokenImage);\n \n    t.beginLine = beginLine;\n    t.endLine = endLine;\n--- a/gson/src/main/java/com/google/gson/ParseException.java\n+++ b/gson/src/main/java/com/google/gson/ParseException.java\n-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */\n-package com.google.gson;\n-\n-/**\n- * This exception is thrown when parse errors are encountered.\n- * You can explicitly create objects of this exception type by\n- * calling the method generateParseException in the generated\n- * parser.\n- *\n- * You can modify this class to customize your error reporting\n- * mechanisms so long as you retain the public fields.\n- */\n-@SuppressWarnings(\"all\")\n-final class ParseException extends Exception {\n-\n-  /**\n-   * This constructor is used by the method \"generateParseException\"\n-   * in the generated parser.  Calling this constructor generates\n-   * a new object of this type with the fields \"currentToken\",\n-   * \"expectedTokenSequences\", and \"tokenImage\" set.  The boolean\n-   * flag \"specialConstructor\" is also set to true to indicate that\n-   * this constructor was used to create this object.\n-   * This constructor calls its super class with the empty string\n-   * to force the \"toString\" method of parent class \"Throwable\" to\n-   * print the error message in the form:\n-   *     ParseException: <result of getMessage>\n-   */\n-  public ParseException(Token currentTokenVal,\n-                        int[][] expectedTokenSequencesVal,\n-                        String[] tokenImageVal\n-                       )\n-  {\n-    super(\"\");\n-    specialConstructor = true;\n-    currentToken = currentTokenVal;\n-    expectedTokenSequences = expectedTokenSequencesVal;\n-    tokenImage = tokenImageVal;\n-  }\n-\n-  /**\n-   * The following constructors are for use by you for whatever\n-   * purpose you can think of.  Constructing the exception in this\n-   * manner makes the exception behave in the normal way - i.e., as\n-   * documented in the class \"Throwable\".  The fields \"errorToken\",\n-   * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n-   * relevant information.  The JavaCC generated code does not use\n-   * these constructors.\n-   */\n-\n-  public ParseException() {\n-    super();\n-    specialConstructor = false;\n-  }\n-\n-  public ParseException(String message) {\n-    super(message);\n-    specialConstructor = false;\n-  }\n-\n-  /**\n-   * This variable determines which constructor was used to create\n-   * this object and thereby affects the semantics of the\n-   * \"getMessage\" method (see below).\n-   */\n-  protected boolean specialConstructor;\n-\n-  /**\n-   * This is the last token that has been consumed successfully.  If\n-   * this object has been created due to a parse error, the token\n-   * followng this token will (therefore) be the first error token.\n-   */\n-  public Token currentToken;\n-\n-  /**\n-   * Each entry in this array is an array of integers.  Each array\n-   * of integers represents a sequence of tokens (by their ordinal\n-   * values) that is expected at this point of the parse.\n-   */\n-  public int[][] expectedTokenSequences;\n-\n-  /**\n-   * This is a reference to the \"tokenImage\" array of the generated\n-   * parser within which the parse error occurred.  This array is\n-   * defined in the generated ...Constants interface.\n-   */\n-  public String[] tokenImage;\n-\n-  /**\n-   * This method has the standard behavior when this object has been\n-   * created using the standard constructors.  Otherwise, it uses\n-   * \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n-   * error message and returns it.  If this object has been created\n-   * due to a parse error, and you do not catch it (it gets thrown\n-   * from the parser), then this method is called during the printing\n-   * of the final stack trace, and hence the correct error message\n-   * gets displayed.\n-   */\n-  public String getMessage() {\n-    if (!specialConstructor) {\n-      return super.getMessage();\n-    }\n-    StringBuffer expected = new StringBuffer();\n-    int maxSize = 0;\n-    for (int i = 0; i < expectedTokenSequences.length; i++) {\n-      if (maxSize < expectedTokenSequences[i].length) {\n-        maxSize = expectedTokenSequences[i].length;\n-      }\n-      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(\" \");\n-      }\n-      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n-        expected.append(\"...\");\n-      }\n-      expected.append(eol).append(\"    \");\n-    }\n-    String retval = \"Encountered \\\"\";\n-    Token tok = currentToken.next;\n-    for (int i = 0; i < maxSize; i++) {\n-      if (i != 0) retval += \" \";\n-      if (tok.kind == 0) {\n-        retval += tokenImage[0];\n-        break;\n-      }\n-      retval += add_escapes(tok.image);\n-      tok = tok.next; \n-    }\n-    retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n-    retval += \".\" + eol;\n-    if (expectedTokenSequences.length == 1) {\n-      retval += \"Was expecting:\" + eol + \"    \";\n-    } else {\n-      retval += \"Was expecting one of:\" + eol + \"    \";\n-    }\n-    retval += expected.toString();\n-    return retval;\n-  }\n-\n-  /**\n-   * The end of line string for this machine.\n-   */\n-  protected String eol = System.getProperty(\"line.separator\", \"\\n\");\n- \n-  /**\n-   * Used to convert raw characters to their escaped version\n-   * when these raw version cannot be used as part of an ASCII\n-   * string literal.\n-   */\n-  protected String add_escapes(String str) {\n-      StringBuffer retval = new StringBuffer();\n-      char ch;\n-      for (int i = 0; i < str.length(); i++) {\n-        switch (str.charAt(i))\n-        {\n-           case 0 :\n-              continue;\n-           case '\\b':\n-              retval.append(\"\\\\b\");\n-              continue;\n-           case '\\t':\n-              retval.append(\"\\\\t\");\n-              continue;\n-           case '\\n':\n-              retval.append(\"\\\\n\");\n-              continue;\n-           case '\\f':\n-              retval.append(\"\\\\f\");\n-              continue;\n-           case '\\r':\n-              retval.append(\"\\\\r\");\n-              continue;\n-           case '\\\"':\n-              retval.append(\"\\\\\\\"\");\n-              continue;\n-           case '\\'':\n-              retval.append(\"\\\\\\'\");\n-              continue;\n-           case '\\\\':\n-              retval.append(\"\\\\\\\\\");\n-              continue;\n-           default:\n-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n-                 String s = \"0000\" + Integer.toString(ch, 16);\n-                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n-              } else {\n-                 retval.append(ch);\n-              }\n-              continue;\n-        }\n-      }\n-      return retval.toString();\n-   }\n-\n-}\n+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */\n+/* JavaCCOptions:KEEP_LINE_COL=null */\n+package com.google.gson;\n+\n+/**\n+ * This exception is thrown when parse errors are encountered.\n+ * You can explicitly create objects of this exception type by\n+ * calling the method generateParseException in the generated\n+ * parser.\n+ *\n+ * You can modify this class to customize your error reporting\n+ * mechanisms so long as you retain the public fields.\n+ */\n+@SuppressWarnings(\"all\")\n+final class ParseException extends Exception {\n+\n+  /**\n+   * The version identifier for this Serializable class.\n+   * Increment only if the <i>serialized</i> form of the\n+   * class changes.\n+   */\n+  private static final long serialVersionUID = 1L;\n+\n+  /**\n+   * This constructor is used by the method \"generateParseException\"\n+   * in the generated parser.  Calling this constructor generates\n+   * a new object of this type with the fields \"currentToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" set.\n+   */\n+  public ParseException(Token currentTokenVal,\n+                        int[][] expectedTokenSequencesVal,\n+                        String[] tokenImageVal\n+                       )\n+  {\n+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));\n+    currentToken = currentTokenVal;\n+    expectedTokenSequences = expectedTokenSequencesVal;\n+    tokenImage = tokenImageVal;\n+  }\n+\n+  /**\n+   * The following constructors are for use by you for whatever\n+   * purpose you can think of.  Constructing the exception in this\n+   * manner makes the exception behave in the normal way - i.e., as\n+   * documented in the class \"Throwable\".  The fields \"errorToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n+   * relevant information.  The JavaCC generated code does not use\n+   * these constructors.\n+   */\n+\n+  public ParseException() {\n+    super();\n+  }\n+\n+  /** Constructor with message. */\n+  public ParseException(String message) {\n+    super(message);\n+  }\n+\n+\n+  /**\n+   * This is the last token that has been consumed successfully.  If\n+   * this object has been created due to a parse error, the token\n+   * followng this token will (therefore) be the first error token.\n+   */\n+  public Token currentToken;\n+\n+  /**\n+   * Each entry in this array is an array of integers.  Each array\n+   * of integers represents a sequence of tokens (by their ordinal\n+   * values) that is expected at this point of the parse.\n+   */\n+  public int[][] expectedTokenSequences;\n+\n+  /**\n+   * This is a reference to the \"tokenImage\" array of the generated\n+   * parser within which the parse error occurred.  This array is\n+   * defined in the generated ...Constants interface.\n+   */\n+  public String[] tokenImage;\n+\n+  /**\n+   * It uses \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n+   * error message and returns it.  If this object has been created\n+   * due to a parse error, and you do not catch it (it gets thrown\n+   * from the parser) the correct error message\n+   * gets displayed.\n+   */\n+  private static String initialise(Token currentToken,\n+                           int[][] expectedTokenSequences,\n+                           String[] tokenImage) {\n+    String eol = System.getProperty(\"line.separator\", \"\\n\");\n+    StringBuffer expected = new StringBuffer();\n+    int maxSize = 0;\n+    for (int i = 0; i < expectedTokenSequences.length; i++) {\n+      if (maxSize < expectedTokenSequences[i].length) {\n+        maxSize = expectedTokenSequences[i].length;\n+      }\n+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');\n+      }\n+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n+        expected.append(\"...\");\n+      }\n+      expected.append(eol).append(\"    \");\n+    }\n+    String retval = \"Encountered \\\"\";\n+    Token tok = currentToken.next;\n+    for (int i = 0; i < maxSize; i++) {\n+      if (i != 0) retval += \" \";\n+      if (tok.kind == 0) {\n+        retval += tokenImage[0];\n+        break;\n+      }\n+      retval += \" \" + tokenImage[tok.kind];\n+      retval += \" \\\"\";\n+      retval += add_escapes(tok.image);\n+      retval += \" \\\"\";\n+      tok = tok.next;\n+    }\n+    retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n+    retval += \".\" + eol;\n+    if (expectedTokenSequences.length == 1) {\n+      retval += \"Was expecting:\" + eol + \"    \";\n+    } else {\n+      retval += \"Was expecting one of:\" + eol + \"    \";\n+    }\n+    retval += expected.toString();\n+    return retval;\n+  }\n+\n+  /**\n+   * The end of line string for this machine.\n+   */\n+  protected String eol = System.getProperty(\"line.separator\", \"\\n\");\n+\n+  /**\n+   * Used to convert raw characters to their escaped version\n+   * when these raw version cannot be used as part of an ASCII\n+   * string literal.\n+   */\n+  static String add_escapes(String str) {\n+      StringBuffer retval = new StringBuffer();\n+      char ch;\n+      for (int i = 0; i < str.length(); i++) {\n+        switch (str.charAt(i))\n+        {\n+           case 0 :\n+              continue;\n+           case '\\b':\n+              retval.append(\"\\\\b\");\n+              continue;\n+           case '\\t':\n+              retval.append(\"\\\\t\");\n+              continue;\n+           case '\\n':\n+              retval.append(\"\\\\n\");\n+              continue;\n+           case '\\f':\n+              retval.append(\"\\\\f\");\n+              continue;\n+           case '\\r':\n+              retval.append(\"\\\\r\");\n+              continue;\n+           case '\\\"':\n+              retval.append(\"\\\\\\\"\");\n+              continue;\n+           case '\\'':\n+              retval.append(\"\\\\\\'\");\n+              continue;\n+           case '\\\\':\n+              retval.append(\"\\\\\\\\\");\n+              continue;\n+           default:\n+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                 String s = \"0000\" + Integer.toString(ch, 16);\n+                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+              } else {\n+                 retval.append(ch);\n+              }\n+              continue;\n+        }\n+      }\n+      return retval.toString();\n+   }\n+\n+}\n+/* JavaCC - OriginalChecksum=bf6325585417e7bd5d488795e151433b (do not edit this line) */\n--- a/gson/src/main/java/com/google/gson/SimpleCharStream.java\n+++ b/gson/src/main/java/com/google/gson/SimpleCharStream.java\n-/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */\n-package com.google.gson;\n-\n-/**\n- * An implementation of interface CharStream, where the stream is assumed to\n- * contain only ASCII characters (without unicode processing).\n- */\n-\n-@SuppressWarnings(\"all\")\n-final class SimpleCharStream\n-{\n-  public static final boolean staticFlag = false;\n-  int bufsize;\n-  int available;\n-  int tokenBegin;\n-  public int bufpos = -1;\n-  protected int bufline[];\n-  protected int bufcolumn[];\n-\n-  protected int column = 0;\n-  protected int line = 1;\n-\n-  protected boolean prevCharIsCR = false;\n-  protected boolean prevCharIsLF = false;\n-\n-  protected java.io.Reader inputStream;\n-\n-  protected char[] buffer;\n-  protected int maxNextCharInd = 0;\n-  protected int inBuf = 0;\n-  protected int tabSize = 8;\n-\n-  protected void setTabSize(int i) { tabSize = i; }\n-  protected int getTabSize(int i) { return tabSize; }\n-\n-\n-  protected void ExpandBuff(boolean wrapAround)\n-  {\n-     char[] newbuffer = new char[bufsize + 2048];\n-     int newbufline[] = new int[bufsize + 2048];\n-     int newbufcolumn[] = new int[bufsize + 2048];\n-\n-     try\n-     {\n-        if (wrapAround)\n-        {\n-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n-           System.arraycopy(buffer, 0, newbuffer,\n-                                             bufsize - tokenBegin, bufpos);\n-           buffer = newbuffer;\n-\n-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n-           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n-           bufline = newbufline;\n-\n-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n-           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n-           bufcolumn = newbufcolumn;\n-\n-           maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n-        }\n-        else\n-        {\n-           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n-           buffer = newbuffer;\n-\n-           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n-           bufline = newbufline;\n-\n-           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n-           bufcolumn = newbufcolumn;\n-\n-           maxNextCharInd = (bufpos -= tokenBegin);\n-        }\n-     }\n-     catch (Throwable t)\n-     {\n-        throw new Error(t.getMessage());\n-     }\n-\n-\n-     bufsize += 2048;\n-     available = bufsize;\n-     tokenBegin = 0;\n-  }\n-\n-  protected void FillBuff() throws java.io.IOException\n-  {\n-     if (maxNextCharInd == available)\n-     {\n-        if (available == bufsize)\n-        {\n-           if (tokenBegin > 2048)\n-           {\n-              bufpos = maxNextCharInd = 0;\n-              available = tokenBegin;\n-           }\n-           else if (tokenBegin < 0)\n-              bufpos = maxNextCharInd = 0;\n-           else\n-              ExpandBuff(false);\n-        }\n-        else if (available > tokenBegin)\n-           available = bufsize;\n-        else if ((tokenBegin - available) < 2048)\n-           ExpandBuff(true);\n-        else\n-           available = tokenBegin;\n-     }\n-\n-     int i;\n-     try {\n-        if ((i = inputStream.read(buffer, maxNextCharInd,\n-                                    available - maxNextCharInd)) == -1)\n-        {\n-           inputStream.close();\n-           throw new java.io.IOException();\n-        }\n-        else\n-           maxNextCharInd += i;\n-        return;\n-     }\n-     catch(java.io.IOException e) {\n-        --bufpos;\n-        backup(0);\n-        if (tokenBegin == -1)\n-           tokenBegin = bufpos;\n-        throw e;\n-     }\n-  }\n-\n-  public char BeginToken() throws java.io.IOException\n-  {\n-     tokenBegin = -1;\n-     char c = readChar();\n-     tokenBegin = bufpos;\n-\n-     return c;\n-  }\n-\n-  protected void UpdateLineColumn(char c)\n-  {\n-     column++;\n-\n-     if (prevCharIsLF)\n-     {\n-        prevCharIsLF = false;\n-        line += (column = 1);\n-     }\n-     else if (prevCharIsCR)\n-     {\n-        prevCharIsCR = false;\n-        if (c == '\\n')\n-        {\n-           prevCharIsLF = true;\n-        }\n-        else\n-           line += (column = 1);\n-     }\n-\n-     switch (c)\n-     {\n-        case '\\r' :\n-           prevCharIsCR = true;\n-           break;\n-        case '\\n' :\n-           prevCharIsLF = true;\n-           break;\n-        case '\\t' :\n-           column--;\n-           column += (tabSize - (column % tabSize));\n-           break;\n-        default :\n-           break;\n-     }\n-\n-     bufline[bufpos] = line;\n-     bufcolumn[bufpos] = column;\n-  }\n-\n-  public char readChar() throws java.io.IOException\n-  {\n-     if (inBuf > 0)\n-     {\n-        --inBuf;\n-\n-        if (++bufpos == bufsize)\n-           bufpos = 0;\n-\n-        return buffer[bufpos];\n-     }\n-\n-     if (++bufpos >= maxNextCharInd)\n-        FillBuff();\n-\n-     char c = buffer[bufpos];\n-\n-     UpdateLineColumn(c);\n-     return (c);\n-  }\n-\n-  /**\n-   * @deprecated \n-   * @see #getEndColumn\n-   */\n-\n-  public int getColumn() {\n-     return bufcolumn[bufpos];\n-  }\n-\n-  /**\n-   * @deprecated \n-   * @see #getEndLine\n-   */\n-\n-  public int getLine() {\n-     return bufline[bufpos];\n-  }\n-\n-  public int getEndColumn() {\n-     return bufcolumn[bufpos];\n-  }\n-\n-  public int getEndLine() {\n-     return bufline[bufpos];\n-  }\n-\n-  public int getBeginColumn() {\n-     return bufcolumn[tokenBegin];\n-  }\n-\n-  public int getBeginLine() {\n-     return bufline[tokenBegin];\n-  }\n-\n-  public void backup(int amount) {\n-\n-    inBuf += amount;\n-    if ((bufpos -= amount) < 0)\n-       bufpos += bufsize;\n-  }\n-\n-  public SimpleCharStream(java.io.Reader dstream, int startline,\n-  int startcolumn, int buffersize)\n-  {\n-    inputStream = dstream;\n-    line = startline;\n-    column = startcolumn - 1;\n-\n-    available = bufsize = buffersize;\n-    buffer = new char[buffersize];\n-    bufline = new int[buffersize];\n-    bufcolumn = new int[buffersize];\n-  }\n-\n-  public SimpleCharStream(java.io.Reader dstream, int startline,\n-                          int startcolumn)\n-  {\n-     this(dstream, startline, startcolumn, 4096);\n-  }\n-\n-  public SimpleCharStream(java.io.Reader dstream)\n-  {\n-     this(dstream, 1, 1, 4096);\n-  }\n-  public void ReInit(java.io.Reader dstream, int startline,\n-  int startcolumn, int buffersize)\n-  {\n-    inputStream = dstream;\n-    line = startline;\n-    column = startcolumn - 1;\n-\n-    if (buffer == null || buffersize != buffer.length)\n-    {\n-      available = bufsize = buffersize;\n-      buffer = new char[buffersize];\n-      bufline = new int[buffersize];\n-      bufcolumn = new int[buffersize];\n-    }\n-    prevCharIsLF = prevCharIsCR = false;\n-    tokenBegin = inBuf = maxNextCharInd = 0;\n-    bufpos = -1;\n-  }\n-\n-  public void ReInit(java.io.Reader dstream, int startline,\n-                     int startcolumn)\n-  {\n-     ReInit(dstream, startline, startcolumn, 4096);\n-  }\n-\n-  public void ReInit(java.io.Reader dstream)\n-  {\n-     ReInit(dstream, 1, 1, 4096);\n-  }\n-  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n-  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n-  {\n-     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n-  }\n-\n-  public SimpleCharStream(java.io.InputStream dstream, int startline,\n-  int startcolumn, int buffersize)\n-  {\n-     this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n-  }\n-\n-  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n-                          int startcolumn) throws java.io.UnsupportedEncodingException\n-  {\n-     this(dstream, encoding, startline, startcolumn, 4096);\n-  }\n-\n-  public SimpleCharStream(java.io.InputStream dstream, int startline,\n-                          int startcolumn)\n-  {\n-     this(dstream, startline, startcolumn, 4096);\n-  }\n-\n-  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n-  {\n-     this(dstream, encoding, 1, 1, 4096);\n-  }\n-\n-  public SimpleCharStream(java.io.InputStream dstream)\n-  {\n-     this(dstream, 1, 1, 4096);\n-  }\n-\n-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n-                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n-  {\n-     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n-  }\n-\n-  public void ReInit(java.io.InputStream dstream, int startline,\n-                          int startcolumn, int buffersize)\n-  {\n-     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n-  }\n-\n-  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n-  {\n-     ReInit(dstream, encoding, 1, 1, 4096);\n-  }\n-\n-  public void ReInit(java.io.InputStream dstream)\n-  {\n-     ReInit(dstream, 1, 1, 4096);\n-  }\n-  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n-                     int startcolumn) throws java.io.UnsupportedEncodingException\n-  {\n-     ReInit(dstream, encoding, startline, startcolumn, 4096);\n-  }\n-  public void ReInit(java.io.InputStream dstream, int startline,\n-                     int startcolumn)\n-  {\n-     ReInit(dstream, startline, startcolumn, 4096);\n-  }\n-  public String GetImage()\n-  {\n-     if (bufpos >= tokenBegin)\n-        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n-     else\n-        return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n-                              new String(buffer, 0, bufpos + 1);\n-  }\n-\n-  public char[] GetSuffix(int len)\n-  {\n-     char[] ret = new char[len];\n-\n-     if ((bufpos + 1) >= len)\n-        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n-     else\n-     {\n-        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n-                                                          len - bufpos - 1);\n-        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n-     }\n-\n-     return ret;\n-  }\n-\n-  public void Done()\n-  {\n-     buffer = null;\n-     bufline = null;\n-     bufcolumn = null;\n-  }\n-\n-  /**\n-   * Method to adjust line and column numbers for the start of a token.\n-   */\n-  public void adjustBeginLineColumn(int newLine, int newCol)\n-  {\n-     int start = tokenBegin;\n-     int len;\n-\n-     if (bufpos >= tokenBegin)\n-     {\n-        len = bufpos - tokenBegin + inBuf + 1;\n-     }\n-     else\n-     {\n-        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n-     }\n-\n-     int i = 0, j = 0, k = 0;\n-     int nextColDiff = 0, columnDiff = 0;\n-\n-     while (i < len &&\n-            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n-     {\n-        bufline[j] = newLine;\n-        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n-        bufcolumn[j] = newCol + columnDiff;\n-        columnDiff = nextColDiff;\n-        i++;\n-     } \n-\n-     if (i < len)\n-     {\n-        bufline[j] = newLine++;\n-        bufcolumn[j] = newCol + columnDiff;\n-\n-        while (i++ < len)\n-        {\n-           if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n-              bufline[j] = newLine++;\n-           else\n-              bufline[j] = newLine;\n-        }\n-     }\n-\n-     line = bufline[j];\n-     column = bufcolumn[j];\n-  }\n-\n-}\n+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.1 */\n+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\n+package com.google.gson;\n+\n+/**\n+ * An implementation of interface CharStream, where the stream is assumed to\n+ * contain only ASCII characters (without unicode processing).\n+ */\n+@SuppressWarnings(\"all\")\n+final class SimpleCharStream\n+{\n+/** Whether parser is static. */\n+  public static final boolean staticFlag = false;\n+  int bufsize;\n+  int available;\n+  int tokenBegin;\n+/** Position in buffer. */\n+  public int bufpos = -1;\n+  protected int bufline[];\n+  protected int bufcolumn[];\n+\n+  protected int column = 0;\n+  protected int line = 1;\n+\n+  protected boolean prevCharIsCR = false;\n+  protected boolean prevCharIsLF = false;\n+\n+  protected java.io.Reader inputStream;\n+\n+  protected char[] buffer;\n+  protected int maxNextCharInd = 0;\n+  protected int inBuf = 0;\n+  protected int tabSize = 8;\n+\n+  protected void setTabSize(int i) { tabSize = i; }\n+  protected int getTabSize(int i) { return tabSize; }\n+\n+\n+  protected void ExpandBuff(boolean wrapAround)\n+  {\n+    char[] newbuffer = new char[bufsize + 2048];\n+    int newbufline[] = new int[bufsize + 2048];\n+    int newbufcolumn[] = new int[bufsize + 2048];\n+\n+    try\n+    {\n+      if (wrapAround)\n+      {\n+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n+        buffer = newbuffer;\n+\n+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n+        bufline = newbufline;\n+\n+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n+        bufcolumn = newbufcolumn;\n+\n+        maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n+      }\n+      else\n+      {\n+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+        buffer = newbuffer;\n+\n+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+        bufline = newbufline;\n+\n+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+        bufcolumn = newbufcolumn;\n+\n+        maxNextCharInd = (bufpos -= tokenBegin);\n+      }\n+    }\n+    catch (Throwable t)\n+    {\n+      throw new Error(t.getMessage());\n+    }\n+\n+\n+    bufsize += 2048;\n+    available = bufsize;\n+    tokenBegin = 0;\n+  }\n+\n+  protected void FillBuff() throws java.io.IOException\n+  {\n+    if (maxNextCharInd == available)\n+    {\n+      if (available == bufsize)\n+      {\n+        if (tokenBegin > 2048)\n+        {\n+          bufpos = maxNextCharInd = 0;\n+          available = tokenBegin;\n+        }\n+        else if (tokenBegin < 0)\n+          bufpos = maxNextCharInd = 0;\n+        else\n+          ExpandBuff(false);\n+      }\n+      else if (available > tokenBegin)\n+        available = bufsize;\n+      else if ((tokenBegin - available) < 2048)\n+        ExpandBuff(true);\n+      else\n+        available = tokenBegin;\n+    }\n+\n+    int i;\n+    try {\n+      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)\n+      {\n+        inputStream.close();\n+        throw new java.io.IOException();\n+      }\n+      else\n+        maxNextCharInd += i;\n+      return;\n+    }\n+    catch(java.io.IOException e) {\n+      --bufpos;\n+      backup(0);\n+      if (tokenBegin == -1)\n+        tokenBegin = bufpos;\n+      throw e;\n+    }\n+  }\n+\n+/** Start. */\n+  public char BeginToken() throws java.io.IOException\n+  {\n+    tokenBegin = -1;\n+    char c = readChar();\n+    tokenBegin = bufpos;\n+\n+    return c;\n+  }\n+\n+  protected void UpdateLineColumn(char c)\n+  {\n+    column++;\n+\n+    if (prevCharIsLF)\n+    {\n+      prevCharIsLF = false;\n+      line += (column = 1);\n+    }\n+    else if (prevCharIsCR)\n+    {\n+      prevCharIsCR = false;\n+      if (c == '\\n')\n+      {\n+        prevCharIsLF = true;\n+      }\n+      else\n+        line += (column = 1);\n+    }\n+\n+    switch (c)\n+    {\n+      case '\\r' :\n+        prevCharIsCR = true;\n+        break;\n+      case '\\n' :\n+        prevCharIsLF = true;\n+        break;\n+      case '\\t' :\n+        column--;\n+        column += (tabSize - (column % tabSize));\n+        break;\n+      default :\n+        break;\n+    }\n+\n+    bufline[bufpos] = line;\n+    bufcolumn[bufpos] = column;\n+  }\n+\n+/** Read a character. */\n+  public char readChar() throws java.io.IOException\n+  {\n+    if (inBuf > 0)\n+    {\n+      --inBuf;\n+\n+      if (++bufpos == bufsize)\n+        bufpos = 0;\n+\n+      return buffer[bufpos];\n+    }\n+\n+    if (++bufpos >= maxNextCharInd)\n+      FillBuff();\n+\n+    char c = buffer[bufpos];\n+\n+    UpdateLineColumn(c);\n+    return c;\n+  }\n+\n+  /**\n+   * @deprecated\n+   * @see #getEndColumn\n+   */\n+\n+  public int getColumn() {\n+    return bufcolumn[bufpos];\n+  }\n+\n+  /**\n+   * @deprecated\n+   * @see #getEndLine\n+   */\n+\n+  public int getLine() {\n+    return bufline[bufpos];\n+  }\n+\n+  /** Get token end column number. */\n+  public int getEndColumn() {\n+    return bufcolumn[bufpos];\n+  }\n+\n+  /** Get token end line number. */\n+  public int getEndLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  /** Get token beginning column number. */\n+  public int getBeginColumn() {\n+    return bufcolumn[tokenBegin];\n+  }\n+\n+  /** Get token beginning line number. */\n+  public int getBeginLine() {\n+    return bufline[tokenBegin];\n+  }\n+\n+/** Backup a number of characters. */\n+  public void backup(int amount) {\n+\n+    inBuf += amount;\n+    if ((bufpos -= amount) < 0)\n+      bufpos += bufsize;\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    available = bufsize = buffersize;\n+    buffer = new char[buffersize];\n+    bufline = new int[buffersize];\n+    bufcolumn = new int[buffersize];\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+                          int startcolumn)\n+  {\n+    this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.Reader dstream)\n+  {\n+    this(dstream, 1, 1, 4096);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    if (buffer == null || buffersize != buffer.length)\n+    {\n+      available = bufsize = buffersize;\n+      buffer = new char[buffersize];\n+      bufline = new int[buffersize];\n+      bufcolumn = new int[buffersize];\n+    }\n+    prevCharIsLF = prevCharIsCR = false;\n+    tokenBegin = inBuf = maxNextCharInd = 0;\n+    bufpos = -1;\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.Reader dstream, int startline,\n+                     int startcolumn)\n+  {\n+    ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.Reader dstream)\n+  {\n+    ReInit(dstream, 1, 1, 4096);\n+  }\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n+  {\n+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n+                          int startcolumn) throws java.io.UnsupportedEncodingException\n+  {\n+    this(dstream, encoding, startline, startcolumn, 4096);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+                          int startcolumn)\n+  {\n+    this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n+  {\n+    this(dstream, encoding, 1, 1, 4096);\n+  }\n+\n+  /** Constructor. */\n+  public SimpleCharStream(java.io.InputStream dstream)\n+  {\n+    this(dstream, 1, 1, 4096);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n+                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n+  {\n+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                          int startcolumn, int buffersize)\n+  {\n+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n+  {\n+    ReInit(dstream, encoding, 1, 1, 4096);\n+  }\n+\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream)\n+  {\n+    ReInit(dstream, 1, 1, 4096);\n+  }\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n+                     int startcolumn) throws java.io.UnsupportedEncodingException\n+  {\n+    ReInit(dstream, encoding, startline, startcolumn, 4096);\n+  }\n+  /** Reinitialise. */\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                     int startcolumn)\n+  {\n+    ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+  /** Get token literal value. */\n+  public String GetImage()\n+  {\n+    if (bufpos >= tokenBegin)\n+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n+    else\n+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n+                            new String(buffer, 0, bufpos + 1);\n+  }\n+\n+  /** Get the suffix. */\n+  public char[] GetSuffix(int len)\n+  {\n+    char[] ret = new char[len];\n+\n+    if ((bufpos + 1) >= len)\n+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n+    else\n+    {\n+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n+                                                        len - bufpos - 1);\n+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n+    }\n+\n+    return ret;\n+  }\n+\n+  /** Reset buffer when finished. */\n+  public void Done()\n+  {\n+    buffer = null;\n+    bufline = null;\n+    bufcolumn = null;\n+  }\n+\n+  /**\n+   * Method to adjust line and column numbers for the start of a token.\n+   */\n+  public void adjustBeginLineColumn(int newLine, int newCol)\n+  {\n+    int start = tokenBegin;\n+    int len;\n+\n+    if (bufpos >= tokenBegin)\n+    {\n+      len = bufpos - tokenBegin + inBuf + 1;\n+    }\n+    else\n+    {\n+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n+    }\n+\n+    int i = 0, j = 0, k = 0;\n+    int nextColDiff = 0, columnDiff = 0;\n+\n+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n+    {\n+      bufline[j] = newLine;\n+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n+      bufcolumn[j] = newCol + columnDiff;\n+      columnDiff = nextColDiff;\n+      i++;\n+    }\n+\n+    if (i < len)\n+    {\n+      bufline[j] = newLine++;\n+      bufcolumn[j] = newCol + columnDiff;\n+\n+      while (i++ < len)\n+      {\n+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n+          bufline[j] = newLine++;\n+        else\n+          bufline[j] = newLine;\n+      }\n+    }\n+\n+    line = bufline[j];\n+    column = bufcolumn[j];\n+  }\n+\n+}\n+/* JavaCC - OriginalChecksum=351e3d8e62614bff24f1b9ba2fd77764 (do not edit this line) */\n--- a/gson/src/main/java/com/google/gson/Token.java\n+++ b/gson/src/main/java/com/google/gson/Token.java\n-/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */\n-package com.google.gson;\n-\n-/**\n- * Describes the input token stream.\n- */\n-\n-@SuppressWarnings(\"all\")\n-final class Token {\n-\n-  /**\n-   * An integer that describes the kind of this token.  This numbering\n-   * system is determined by JavaCCParser, and a table of these numbers is\n-   * stored in the file ...Constants.java.\n-   */\n-  public int kind;\n-\n-  /**\n-   * beginLine and beginColumn describe the position of the first character\n-   * of this token; endLine and endColumn describe the position of the\n-   * last character of this token.\n-   */\n-  public int beginLine, beginColumn, endLine, endColumn;\n-\n-  /**\n-   * The string image of the token.\n-   */\n-  public String image;\n-\n-  /**\n-   * A reference to the next regular (non-special) token from the input\n-   * stream.  If this is the last token from the input stream, or if the\n-   * token manager has not read tokens beyond this one, this field is\n-   * set to null.  This is true only if this token is also a regular\n-   * token.  Otherwise, see below for a description of the contents of\n-   * this field.\n-   */\n-  public Token next;\n-\n-  /**\n-   * This field is used to access special tokens that occur prior to this\n-   * token, but after the immediately preceding regular (non-special) token.\n-   * If there are no such special tokens, this field is set to null.\n-   * When there are more than one such special token, this field refers\n-   * to the last of these special tokens, which in turn refers to the next\n-   * previous special token through its specialToken field, and so on\n-   * until the first special token (whose specialToken field is null).\n-   * The next fields of special tokens refer to other special tokens that\n-   * immediately follow it (without an intervening regular token).  If there\n-   * is no such token, this field is null.\n-   */\n-  public Token specialToken;\n-\n-  /**\n-   * Returns the image.\n-   */\n-  public String toString()\n-  {\n-     return image;\n-  }\n-\n-  /**\n-   * Returns a new Token object, by default. However, if you want, you\n-   * can create and return subclass objects based on the value of ofKind.\n-   * Simply add the cases to the switch for all those special cases.\n-   * For example, if you have a subclass of Token called IDToken that\n-   * you want to create if ofKind is ID, simlpy add something like :\n-   *\n-   *    case MyParserConstants.ID : return new IDToken();\n-   *\n-   * to the following switch statement. Then you can cast matchedToken\n-   * variable to the appropriate type and use it in your lexical actions.\n-   */\n-  public static final Token newToken(int ofKind)\n-  {\n-     switch(ofKind)\n-     {\n-       default : return new Token();\n-     }\n-  }\n-\n-}\n+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */\n+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\n+package com.google.gson;\n+\n+/**\n+ * Describes the input token stream.\n+ */\n+@SuppressWarnings(\"all\")\n+final class Token implements java.io.Serializable {\n+\n+  /**\n+   * The version identifier for this Serializable class.\n+   * Increment only if the <i>serialized</i> form of the\n+   * class changes.\n+   */\n+  private static final long serialVersionUID = 1L;\n+\n+  /**\n+   * An integer that describes the kind of this token.  This numbering\n+   * system is determined by JavaCCParser, and a table of these numbers is\n+   * stored in the file ...Constants.java.\n+   */\n+  public int kind;\n+\n+  /** The line number of the first character of this Token. */\n+  public int beginLine;\n+  /** The column number of the first character of this Token. */\n+  public int beginColumn;\n+  /** The line number of the last character of this Token. */\n+  public int endLine;\n+  /** The column number of the last character of this Token. */\n+  public int endColumn;\n+\n+  /**\n+   * The string image of the token.\n+   */\n+  public String image;\n+\n+  /**\n+   * A reference to the next regular (non-special) token from the input\n+   * stream.  If this is the last token from the input stream, or if the\n+   * token manager has not read tokens beyond this one, this field is\n+   * set to null.  This is true only if this token is also a regular\n+   * token.  Otherwise, see below for a description of the contents of\n+   * this field.\n+   */\n+  public Token next;\n+\n+  /**\n+   * This field is used to access special tokens that occur prior to this\n+   * token, but after the immediately preceding regular (non-special) token.\n+   * If there are no such special tokens, this field is set to null.\n+   * When there are more than one such special token, this field refers\n+   * to the last of these special tokens, which in turn refers to the next\n+   * previous special token through its specialToken field, and so on\n+   * until the first special token (whose specialToken field is null).\n+   * The next fields of special tokens refer to other special tokens that\n+   * immediately follow it (without an intervening regular token).  If there\n+   * is no such token, this field is null.\n+   */\n+  public Token specialToken;\n+\n+  /**\n+   * An optional attribute value of the Token.\n+   * Tokens which are not used as syntactic sugar will often contain\n+   * meaningful values that will be used later on by the compiler or\n+   * interpreter. This attribute value is often different from the image.\n+   * Any subclass of Token that actually wants to return a non-null value can\n+   * override this method as appropriate.\n+   */\n+  public Object getValue() {\n+    return null;\n+  }\n+\n+  /**\n+   * No-argument constructor\n+   */\n+  public Token() {}\n+\n+  /**\n+   * Constructs a new token for the specified Image.\n+   */\n+  public Token(int kind)\n+  {\n+    this(kind, null);\n+  }\n+\n+  /**\n+   * Constructs a new token for the specified Image and Kind.\n+   */\n+  public Token(int kind, String image)\n+  {\n+    this.kind = kind;\n+    this.image = image;\n+  }\n+\n+  /**\n+   * Returns the image.\n+   */\n+  public String toString()\n+  {\n+    return image;\n+  }\n+\n+  /**\n+   * Returns a new Token object, by default. However, if you want, you\n+   * can create and return subclass objects based on the value of ofKind.\n+   * Simply add the cases to the switch for all those special cases.\n+   * For example, if you have a subclass of Token called IDToken that\n+   * you want to create if ofKind is ID, simply add something like :\n+   *\n+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);\n+   *\n+   * to the following switch statement. Then you can cast matchedToken\n+   * variable to the appropriate type and use sit in your lexical actions.\n+   */\n+  public static Token newToken(int ofKind, String image)\n+  {\n+    switch(ofKind)\n+    {\n+      default : return new Token(ofKind, image);\n+    }\n+  }\n+\n+  public static Token newToken(int ofKind)\n+  {\n+    return newToken(ofKind, null);\n+  }\n+\n+}\n+/* JavaCC - OriginalChecksum=f683548fa415467062989dfb10c566e6 (do not edit this line) */\n--- a/gson/src/main/java/com/google/gson/TokenMgrError.java\n+++ b/gson/src/main/java/com/google/gson/TokenMgrError.java\n-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */\n-package com.google.gson;\n-\n-@SuppressWarnings(\"all\")\n-final class TokenMgrError extends Error\n-{\n-   /*\n-    * Ordinals for various reasons why an Error of this type can be thrown.\n-    */\n-\n-   /**\n-    * Lexical error occured.\n-    */\n-   static final int LEXICAL_ERROR = 0;\n-\n-   /**\n-    * An attempt wass made to create a second instance of a static token manager.\n-    */\n-   static final int STATIC_LEXER_ERROR = 1;\n-\n-   /**\n-    * Tried to change to an invalid lexical state.\n-    */\n-   static final int INVALID_LEXICAL_STATE = 2;\n-\n-   /**\n-    * Detected (and bailed out of) an infinite loop in the token manager.\n-    */\n-   static final int LOOP_DETECTED = 3;\n-\n-   /**\n-    * Indicates the reason why the exception is thrown. It will have\n-    * one of the above 4 values.\n-    */\n-   int errorCode;\n-\n-   /**\n-    * Replaces unprintable characters by their espaced (or unicode escaped)\n-    * equivalents in the given string\n-    */\n-   protected static final String addEscapes(String str) {\n-      StringBuffer retval = new StringBuffer();\n-      char ch;\n-      for (int i = 0; i < str.length(); i++) {\n-        switch (str.charAt(i))\n-        {\n-           case 0 :\n-              continue;\n-           case '\\b':\n-              retval.append(\"\\\\b\");\n-              continue;\n-           case '\\t':\n-              retval.append(\"\\\\t\");\n-              continue;\n-           case '\\n':\n-              retval.append(\"\\\\n\");\n-              continue;\n-           case '\\f':\n-              retval.append(\"\\\\f\");\n-              continue;\n-           case '\\r':\n-              retval.append(\"\\\\r\");\n-              continue;\n-           case '\\\"':\n-              retval.append(\"\\\\\\\"\");\n-              continue;\n-           case '\\'':\n-              retval.append(\"\\\\\\'\");\n-              continue;\n-           case '\\\\':\n-              retval.append(\"\\\\\\\\\");\n-              continue;\n-           default:\n-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n-                 String s = \"0000\" + Integer.toString(ch, 16);\n-                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n-              } else {\n-                 retval.append(ch);\n-              }\n-              continue;\n-        }\n-      }\n-      return retval.toString();\n-   }\n-\n-   /**\n-    * Returns a detailed message for the Error when it is thrown by the\n-    * token manager to indicate a lexical error.\n-    * Parameters : \n-    *    EOFSeen     : indicates if EOF caused the lexicl error\n-    *    curLexState : lexical state in which this error occured\n-    *    errorLine   : line number when the error occured\n-    *    errorColumn : column number when the error occured\n-    *    errorAfter  : prefix that was seen before this error occured\n-    *    curchar     : the offending character\n-    * Note: You can customize the lexical error message by modifying this method.\n-    */\n-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n-      return(\"Lexical error at line \" +\n-           errorLine + \", column \" +\n-           errorColumn + \".  Encountered: \" +\n-           (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") +\n-           \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n-   }\n-\n-   /**\n-    * You can also modify the body of this method to customize your error messages.\n-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n-    * of end-users concern, so you can return something like : \n-    *\n-    *     \"Internal Error : Please file a bug report .... \"\n-    *\n-    * from this method for such cases in the release version of your parser.\n-    */\n-   public String getMessage() {\n-      return super.getMessage();\n-   }\n-\n-   /*\n-    * Constructors of various flavors follow.\n-    */\n-\n-   public TokenMgrError() {\n-   }\n-\n-   public TokenMgrError(String message, int reason) {\n-      super(message);\n-      errorCode = reason;\n-   }\n-\n-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {\n-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n-   }\n-}\n+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */\n+/* JavaCCOptions: */\n+package com.google.gson;\n+\n+/** Token Manager Error. */\n+@SuppressWarnings(\"all\")\n+final class TokenMgrError extends Error\n+{\n+\n+  /**\n+   * The version identifier for this Serializable class.\n+   * Increment only if the <i>serialized</i> form of the\n+   * class changes.\n+   */\n+  private static final long serialVersionUID = 1L;\n+\n+  /*\n+   * Ordinals for various reasons why an Error of this type can be thrown.\n+   */\n+\n+  /**\n+   * Lexical error occurred.\n+   */\n+  static final int LEXICAL_ERROR = 0;\n+\n+  /**\n+   * An attempt was made to create a second instance of a static token manager.\n+   */\n+  static final int STATIC_LEXER_ERROR = 1;\n+\n+  /**\n+   * Tried to change to an invalid lexical state.\n+   */\n+  static final int INVALID_LEXICAL_STATE = 2;\n+\n+  /**\n+   * Detected (and bailed out of) an infinite loop in the token manager.\n+   */\n+  static final int LOOP_DETECTED = 3;\n+\n+  /**\n+   * Indicates the reason why the exception is thrown. It will have\n+   * one of the above 4 values.\n+   */\n+  int errorCode;\n+\n+  /**\n+   * Replaces unprintable characters by their escaped (or unicode escaped)\n+   * equivalents in the given string\n+   */\n+  protected static final String addEscapes(String str) {\n+    StringBuffer retval = new StringBuffer();\n+    char ch;\n+    for (int i = 0; i < str.length(); i++) {\n+      switch (str.charAt(i))\n+      {\n+        case 0 :\n+          continue;\n+        case '\\b':\n+          retval.append(\"\\\\b\");\n+          continue;\n+        case '\\t':\n+          retval.append(\"\\\\t\");\n+          continue;\n+        case '\\n':\n+          retval.append(\"\\\\n\");\n+          continue;\n+        case '\\f':\n+          retval.append(\"\\\\f\");\n+          continue;\n+        case '\\r':\n+          retval.append(\"\\\\r\");\n+          continue;\n+        case '\\\"':\n+          retval.append(\"\\\\\\\"\");\n+          continue;\n+        case '\\'':\n+          retval.append(\"\\\\\\'\");\n+          continue;\n+        case '\\\\':\n+          retval.append(\"\\\\\\\\\");\n+          continue;\n+        default:\n+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+            String s = \"0000\" + Integer.toString(ch, 16);\n+            retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+          } else {\n+            retval.append(ch);\n+          }\n+          continue;\n+      }\n+    }\n+    return retval.toString();\n+  }\n+\n+  /**\n+   * Returns a detailed message for the Error when it is thrown by the\n+   * token manager to indicate a lexical error.\n+   * Parameters :\n+   *    EOFSeen     : indicates if EOF caused the lexical error\n+   *    curLexState : lexical state in which this error occurred\n+   *    errorLine   : line number when the error occurred\n+   *    errorColumn : column number when the error occurred\n+   *    errorAfter  : prefix that was seen before this error occurred\n+   *    curchar     : the offending character\n+   * Note: You can customize the lexical error message by modifying this method.\n+   */\n+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n+    return(\"Lexical error at line \" +\n+          errorLine + \", column \" +\n+          errorColumn + \".  Encountered: \" +\n+          (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") +\n+          \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n+  }\n+\n+  /**\n+   * You can also modify the body of this method to customize your error messages.\n+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n+   * of end-users concern, so you can return something like :\n+   *\n+   *     \"Internal Error : Please file a bug report .... \"\n+   *\n+   * from this method for such cases in the release version of your parser.\n+   */\n+  public String getMessage() {\n+    return super.getMessage();\n+  }\n+\n+  /*\n+   * Constructors of various flavors follow.\n+   */\n+\n+  /** No arg constructor. */\n+  public TokenMgrError() {\n+  }\n+\n+  /** Constructor with message and reason. */\n+  public TokenMgrError(String message, int reason) {\n+    super(message);\n+    errorCode = reason;\n+  }\n+\n+  /** Full Constructor. */\n+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {\n+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n+  }\n+}\n+/* JavaCC - OriginalChecksum=f9c23e3fca926dbaf51c810110262be0 (do not edit this line) */\n--- a/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n import com.google.gson.common.MoreAsserts;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n     MoreAsserts.assertEquals(expected, actual);\n   }\n \n+  public void testInvalidArrayDeserialization() {\n+    String json = \"[1, 2 3, 4, 5]\";\n+    try {\n+      gson.fromJson(json, int[].class);\n+      fail(\"Gson should not deserialize array elements with missing ,\");\n+    } catch (JsonParseException expected) {      \n+    }\n+  }\n+\n   public void testEmptyArraySerialization() {\n     int[] target = {};\n     assertEquals(\"[]\", gson.toJson(target));\n \n     Integer[] actualObject2 = gson.fromJson(\"[]\", Integer[].class);\n     assertTrue(actualObject2.length == 0);\n-  }\n+\n+    actualObject = gson.fromJson(\"[ ]\", int[].class);\n+    assertTrue(actualObject.length == 0);\n+}\n \n   public void testNullsInArraySerialization() {\n     String[] array = {\"foo\", null, \"bar\"};\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n   }\n \n   public void testClassWithTransientFieldsSerialization() throws Exception {\n-    ClassWithTransientFields target = new ClassWithTransientFields(1L);\n-    assertEquals(target.getExpectedJson(), gson.toJson(target));\n-  }\n-\n+    ClassWithTransientFields<Long> target = new ClassWithTransientFields<Long>(1L);\n+    assertEquals(target.getExpectedJson(), gson.toJson(target));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n   public void testClassWithTransientFieldsDeserialization() throws Exception {\n     String json = \"{\\\"longValue\\\":[1]}\";\n     ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);\n     assertEquals(json, target.getExpectedJson());\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()\n       throws Exception {\n     String json = \"{\\\"transientLongValue\\\":1,\\\"longValue\\\":[1]}\";\n--- a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java\n+++ b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java\n   /**\n    * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96\n    */\n-  // Last I tested, Gson was able to deserialize a byte array of 80KB\n+  // Last I tested, Gson was able to deserialize a byte array of 11MB\n   public void disable_testByteArrayDeserialization() {\n-    for (int numElements = 32768; true; numElements += 4096) {\n+    for (int numElements = 10639296; true; numElements += 16384) {\n       StringBuilder sb = new StringBuilder(numElements*2);\n       sb.append(\"[\");\n       boolean first = true;", "timestamp": 1250903007, "metainfo": ""}