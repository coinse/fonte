{"sha": "125e6d9d3d42516de6b6797be8ef0c59e6360512", "log": "Change field annotations to take precedence over registered type adapters.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n \n   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache\n       = Collections.synchronizedMap(new HashMap<TypeToken<?>, TypeAdapter<?>>());\n-\n-  /** Indicates whether Gson is in the phase of constructor invocation. It is used to determine\n-   * whether to add a constructor in preconfiguredGeneratedTypeAdapter set or not. */\n-  private boolean inConstructorPhase = true;\n-  /** List of type adapters that are generated by Gson during its constructor */\n-  private Set<TypeAdapter<?>> preconfiguredGeneratedTypeAdapters = new HashSet<TypeAdapter<?>>();\n-  /** List of type adapters that are generated by Gson during toJson/fromJson. */\n-  private final ThreadLocal<Set<TypeAdapter<?>>> runtimeGeneratedTypeAdapters =\n-      new ThreadLocal<Set<TypeAdapter<?>>>();\n \n   private final List<TypeAdapterFactory> factories;\n   private final ConstructorConstructor constructorConstructor;\n         constructorConstructor, fieldNamingPolicy, excluder));\n \n     this.factories = Collections.unmodifiableList(factories);\n-    this.preconfiguredGeneratedTypeAdapters = Collections.unmodifiableSet(preconfiguredGeneratedTypeAdapters);\n-    inConstructorPhase = false;\n   }\n \n   private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n         .append(\"}\")\n         .toString();\n   }\n-\n-  public static final class $$Internal {\n-    public static void addGeneratedTypeAdapter(Gson gson, TypeAdapter<?> typeAdapter) {\n-      if (gson.inConstructorPhase) {\n-        gson.preconfiguredGeneratedTypeAdapters.add(typeAdapter);\n-      } else {\n-        Set<TypeAdapter<?>> adapters = getRuntimeGeneratedTypeAdapters(gson);\n-        adapters.add(typeAdapter);\n-      }\n-    }\n-    public static boolean isGeneratedTypeAdapter(Gson gson, TypeAdapter<?> typeAdapter) {\n-      boolean generated = gson.preconfiguredGeneratedTypeAdapters.contains(typeAdapter);\n-      if (!generated) generated = getRuntimeGeneratedTypeAdapters(gson).contains(typeAdapter);\n-      return generated;\n-    }\n-    private static Set<TypeAdapter<?>> getRuntimeGeneratedTypeAdapters(Gson gson) {\n-      Set<TypeAdapter<?>> adapters = gson.runtimeGeneratedTypeAdapters.get();\n-      if (adapters == null) adapters = new HashSet<TypeAdapter<?>>();\n-      gson.runtimeGeneratedTypeAdapters.set(adapters);\n-      return adapters;\n-    }\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java\n+++ b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java\n import com.google.gson.TypeAdapter;\n \n /**\n- * An annotation that indicates the Gson {@link TypeAdapter} to use with a class or a field.\n- * Any type adapters registered in {@link com.google.gson.GsonBuilder} supersede the adapter\n- * specified in this annotation.\n+ * An annotation that indicates the Gson {@link TypeAdapter} to use with a class\n+ * or field.\n  *\n  * <p>Here is an example of how this annotation is used:</p>\n  * <pre>\n  * Since User class specified UserJsonAdapter.class in &#64JsonAdapter annotation, it\n  * will automatically be invoked to serialize/deserialize User instances. <br>\n  *\n- * If the UserJsonAdapter needs a constructor other than a no-args constructor, you must register\n- * an {@link com.google.gson.InstanceCreator} for it.\n- *\n  * <p> Here is an example of how to apply this annotation to a field.\n  * <pre>\n  * private static final class Gadget {\n  *   }\n  * }\n  * </pre>\n- * The above annotation will ensure UserJsonAdapter2 takes precedence over UserJsonAdapter\n- * for the user field of the Gadget class.\n+ *\n+ * It's possible to specify different type adapters on a field, that\n+ * field's type, and in the {@link com.google.gson.GsonBuilder}. Field\n+ * annotations take precedence over {@code GsonBuilder}-registered type\n+ * adapters, which in turn take precedence over annotated types.\n  *\n  * @since 2.3\n  *\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n     this.constructorConstructor = constructorConstructor;\n   }\n \n-  @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n-    Class<? super T> clazz = targetType.getRawType();\n-    JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n-    if (annotation == null) return null;\n-    TypeAdapter adapter = getAnnotationTypeAdapter(gson, constructorConstructor, annotation);\n-    return adapter;\n-  }\n-\n-  static TypeAdapter<?> getAnnotationTypeAdapter(Gson gson,\n-      ConstructorConstructor constructorConstructor, JsonAdapter annotation) {\n-    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n-    ObjectConstructor<? extends TypeAdapter<?>> constructor =\n-        constructorConstructor.get(TypeToken.get(adapterClass));\n-    TypeAdapter<?> adapter = constructor.construct();\n-    Gson.$$Internal.addGeneratedTypeAdapter(gson, adapter);\n-    return adapter;\n+    JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class);\n+    return annotation != null\n+        ? (TypeAdapter<T>) constructorConstructor.get(TypeToken.get(annotation.value())).construct()\n+        : null;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n \n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n \n /**\n  * Type adapter that reflects over the fields and methods of a class.\n     }\n \n     ObjectConstructor<T> constructor = constructorConstructor.get(type);\n-    Adapter<T> adapter = new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n-    Gson.$$Internal.addGeneratedTypeAdapter(gson, adapter);\n-    return adapter;\n+    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n   }\n \n   private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n   }\n \n   private TypeAdapter<?> getFieldAdapter(Gson gson, Field field, TypeToken<?> fieldType) {\n-    TypeAdapter<?> adapter = gson.getAdapter(fieldType);\n-    boolean generatedAdapter = Gson.$$Internal.isGeneratedTypeAdapter(gson, adapter);\n-    if (generatedAdapter && field.isAnnotationPresent(JsonAdapter.class)) {\n-      JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n-      return JsonAdapterAnnotationTypeAdapterFactory.getAnnotationTypeAdapter(\n-          gson, constructorConstructor, annotation);\n-    }\n-    return adapter;\n+    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n+    return (annotation != null)\n+        ? constructorConstructor.get(TypeToken.get(annotation.value())).construct()\n+        : gson.getAdapter(fieldType);\n   }\n \n   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n \n package com.google.gson.functional;\n \n-import java.io.IOException;\n-\n-import junit.framework.TestCase;\n-\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.TypeAdapter;\n import com.google.gson.annotations.JsonAdapter;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import junit.framework.TestCase;\n \n /**\n  * Functional tests for the {@link com.google.gson.annotations.JsonAdapter} annotation on fields.\n  */\n public final class JsonAdapterAnnotationOnFieldsTest extends TestCase {\n-\n-  public void testJsonAdapterInvoked() {\n+  public void testClassAnnotationAdapterTakesPrecedenceOverDefault() {\n     Gson gson = new Gson();\n     String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\n-    assertEquals(\"{\\\"user\\\":{\\\"firstName\\\":\\\"Inderjeet\\\",\\\"lastName\\\":\\\"Singh\\\"}}\", json);\n-    Computer computer = gson.fromJson(\"{'user':{'firstName':'Jesse','lastName':'Wilson'}}\", Computer.class);\n-    assertEquals(\"Jesse Wilson\", computer.user.name);\n+    assertEquals(\"{\\\"user\\\":\\\"UserClassAnnotationAdapter\\\"}\", json);\n+    Computer computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer.class);\n+    assertEquals(\"UserClassAnnotationAdapter\", computer.user.name);\n   }\n \n-  public void testRegisteredTypeAdapterOverridesFieldAnnotation() {\n+  public void testRegisteredTypeAdapterTakesPrecedenceOverClassAnnotationAdapter() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(User.class, new RegisteredUserAdapter())\n+        .create();\n+    String json = gson.toJson(new Computer(new User(\"Inderjeet Singh\")));\n+    assertEquals(\"{\\\"user\\\":\\\"RegisteredUserAdapter\\\"}\", json);\n+    Computer computer = gson.fromJson(\"{'user':'Inderjeet Singh'}\", Computer.class);\n+    assertEquals(\"RegisteredUserAdapter\", computer.user.name);\n+  }\n+\n+  public void testFieldAnnotationTakesPrecedenceOverRegisteredTypeAdapter() {\n     Gson gson = new GsonBuilder()\n       .registerTypeAdapter(Part.class, new TypeAdapter<Part>() {\n         @Override public void write(JsonWriter out, Part part) throws IOException {\n-          out.value(\"registeredAdapter\");\n+          throw new AssertionError();\n         }\n+\n         @Override public Part read(JsonReader in) throws IOException {\n-          return new Part(in.nextString());\n+          throw new AssertionError();\n         }\n       }).create();\n     String json = gson.toJson(new Gadget(new Part(\"screen\")));\n-    assertEquals(\"{\\\"part\\\":\\\"registeredAdapter\\\"}\", json);\n-    Gadget gadget = gson.fromJson(\"{'part':'registeredAdapterValue'}\", Gadget.class);\n-    assertEquals(\"registeredAdapterValue\", gadget.part.name);\n+    assertEquals(\"{\\\"part\\\":\\\"PartJsonFieldAnnotationAdapter\\\"}\", json);\n+    Gadget gadget = gson.fromJson(\"{'part':'screen'}\", Gadget.class);\n+    assertEquals(\"PartJsonFieldAnnotationAdapter\", gadget.part.name);\n   }\n \n-  public void testFieldAnnotationSupersedesClassAnnotation() {\n+  public void testFieldAnnotationTakesPrecedenceOverClassAnnotation() {\n     Gson gson = new Gson();\n     String json = gson.toJson(new Computer2(new User(\"Inderjeet Singh\")));\n-    assertEquals(\"{\\\"user\\\":\\\"userJsonAdapter2\\\"}\", json);\n-    Computer2 target = gson.fromJson(\"{'user':'userJsonAdapter2Value'}\", Computer2.class);\n-    assertEquals(\"userJsonAdapter2Value\", target.user.name);\n+    assertEquals(\"{\\\"user\\\":\\\"UserFieldAnnotationAdapter\\\"}\", json);\n+    Computer2 target = gson.fromJson(\"{'user':'Interjeet Singh'}\", Computer2.class);\n+    assertEquals(\"UserFieldAnnotationAdapter\", target.user.name);\n   }\n \n   private static final class Gadget {\n-    @JsonAdapter(PartJsonAdapter.class)\n+    @JsonAdapter(PartJsonFieldAnnotationAdapter.class)\n     final Part part;\n     Gadget(Part part) {\n       this.part = part;\n     }\n   }\n \n-  private static class PartJsonAdapter extends TypeAdapter<Part> {\n+  private static class PartJsonFieldAnnotationAdapter extends TypeAdapter<Part> {\n     @Override public void write(JsonWriter out, Part part) throws IOException {\n-      out.value(part.name);\n+      out.value(\"PartJsonFieldAnnotationAdapter\");\n     }\n     @Override public Part read(JsonReader in) throws IOException {\n       in.nextString();\n-      return new Part(\"partJsonAdapter\");\n+      return new Part(\"PartJsonFieldAnnotationAdapter\");\n     }\n   }\n \n     }\n   }\n \n-  @JsonAdapter(UserJsonAdapter.class)\n+  @JsonAdapter(UserClassAnnotationAdapter.class)\n   private static class User {\n     public final String name;\n     private User(String name) {\n     }\n   }\n \n-  private static class UserJsonAdapter extends TypeAdapter<User> {\n+  private static class UserClassAnnotationAdapter extends TypeAdapter<User> {\n     @Override public void write(JsonWriter out, User user) throws IOException {\n-      // implement write: combine firstName and lastName into name\n-      out.beginObject();\n-      String[] parts = user.name.split(\" \");\n-      out.name(\"firstName\");\n-      out.value(parts[0]);\n-      out.name(\"lastName\");\n-      out.value(parts[1]);\n-      out.endObject();\n+      out.value(\"UserClassAnnotationAdapter\");\n     }\n     @Override public User read(JsonReader in) throws IOException {\n-      // implement read: split name into firstName and lastName\n-      in.beginObject();\n-      in.nextName();\n-      String firstName = in.nextString();\n-      in.nextName();\n-      String lastName = in.nextString();\n-      in.endObject();\n-      return new User(firstName + \" \" + lastName);\n+      in.nextString();\n+      return new User(\"UserClassAnnotationAdapter\");\n     }\n   }\n \n   private static final class Computer2 {\n     // overrides the JsonAdapter annotation of User with this\n-    @JsonAdapter(UserJsonAdapter2.class)\n+    @JsonAdapter(UserFieldAnnotationAdapter.class)\n     final User user;\n     Computer2(User user) {\n       this.user = user;\n     }\n   }\n-  private static final class UserJsonAdapter2 extends TypeAdapter<User> {\n+\n+  private static final class UserFieldAnnotationAdapter extends TypeAdapter<User> {\n     @Override public void write(JsonWriter out, User user) throws IOException {\n-      out.value(\"userJsonAdapter2\");\n+      out.value(\"UserFieldAnnotationAdapter\");\n     }\n     @Override public User read(JsonReader in) throws IOException {\n-      return new User(in.nextString());\n+      in.nextString();\n+      return new User(\"UserFieldAnnotationAdapter\");\n+    }\n+  }\n+\n+  private static final class RegisteredUserAdapter extends TypeAdapter<User> {\n+    @Override public void write(JsonWriter out, User user) throws IOException {\n+      out.value(\"RegisteredUserAdapter\");\n+    }\n+    @Override public User read(JsonReader in) throws IOException {\n+      in.nextString();\n+      return new User(\"RegisteredUserAdapter\");\n     }\n   }\n \n     Gson gson = new Gson();\n     String json = \"{'part1':'name','part2':{'name':'name2'}}\";\n     GadgetWithTwoParts gadget = gson.fromJson(json, GadgetWithTwoParts.class);\n-    assertEquals(\"partJsonAdapter\", gadget.part1.name);\n+    assertEquals(\"PartJsonFieldAnnotationAdapter\", gadget.part1.name);\n     assertEquals(\"name2\", gadget.part2.name);\n   }\n \n   private static final class GadgetWithTwoParts {\n-    @JsonAdapter(PartJsonAdapter.class) final Part part1;\n+    @JsonAdapter(PartJsonFieldAnnotationAdapter.class) final Part part1;\n     final Part part2; // Doesn't have the JsonAdapter annotation\n     @SuppressWarnings(\"unused\") GadgetWithTwoParts(Part part1, Part part2) {\n       this.part1 = part1;", "timestamp": 1407003763, "metainfo": ""}