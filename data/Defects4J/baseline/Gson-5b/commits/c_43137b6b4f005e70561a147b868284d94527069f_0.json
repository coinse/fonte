{"sha": "43137b6b4f005e70561a147b868284d94527069f", "log": "Fix unsafe allocations on Android", "commit": "\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Type;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import sun.misc.Unsafe;\n \n /**\n  * This class contains a mapping of all the application specific\n  * @author Joel Leitch\n  */\n final class MappedObjectConstructor implements ObjectConstructor {\n-  private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\n-  private static final Unsafe THE_UNSAFE = getUnsafe();\n+  private static final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n \n   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap;\n-  \n+\n   public MappedObjectConstructor(\n       ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\n     instanceCreatorMap = instanceCreators;\n     }\n     return (T) constructWithNoArgConstructor(typeOfT);\n   }\n-  \n-  private static Unsafe getUnsafe() {\n-    try {\n-      Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-      f.setAccessible(true);\n-      return (Unsafe) f.get(null);\n-    } catch (NoSuchFieldException e) {\n-      throw new Error();\n-    } catch (IllegalAccessException e) {\n-      throw new Error();\n-    }\n-  }\n \n   public Object constructArray(Type type, int length) {\n     return Array.newInstance(Types.getRawType(type), length);\n     try {\n       Class<T> clazz = (Class<T>) Types.getRawType(typeOfT);\n       Constructor<T> constructor = getNoArgsConstructor(clazz);\n-      if (constructor == null) {\n-        return (T) THE_UNSAFE.allocateInstance(clazz);\n-      }\n-      return constructor.newInstance();\n-    } catch (InstantiationException e) {\n-      throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n-          + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n-    } catch (IllegalAccessException e) {\n-      throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n-          + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n-    } catch (InvocationTargetException e) {\n+      return constructor == null\n+          ? unsafeAllocator.newInstance(clazz)\n+          : constructor.newInstance();\n+    } catch (Exception e) {\n       throw new RuntimeException((\"Unable to invoke no-args constructor for \" + typeOfT + \". \"\n           + \"Register an InstanceCreator with Gson for this type may fix this problem.\"), e);\n     }\n     }\n   }\n \n-  /**\n-   * Use this methods to register an {@link InstanceCreator} for a new type.\n-   *\n-   * @param <T> the type of class to be mapped with its \"creator\"\n-   * @param typeOfT the instance type that will be created\n-   * @param creator the {@link InstanceCreator} instance to register\n-   */\n-  <T> void register(Type typeOfT, InstanceCreator<? extends T> creator) {\n-    if (instanceCreatorMap.hasSpecificHandlerFor(typeOfT)) {\n-      log.log(Level.WARNING, \"Overriding the existing InstanceCreator for {0}\", typeOfT);\n-    }\n-    instanceCreatorMap.register(typeOfT, creator);\n-  }\n-  \n   @Override\n   public String toString() {\n     return instanceCreatorMap.toString();\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/UnsafeAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Do sneaky things to allocate objects without invoking their constructors.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+abstract class UnsafeAllocator {\n+  public abstract <T> T newInstance(Class<T> c) throws Exception;\n+\n+  public static UnsafeAllocator create() {\n+    // try JVM\n+    // public class Unsafe {\n+    //   public Object allocateInstance(Class<?> type);\n+    // }\n+    try {\n+      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n+      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      final Object unsafe = f.get(null);\n+      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) allocateInstance.invoke(unsafe, c);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, pre-gingerbread\n+    // public class ObjectInputStream {\n+    //   private static native Object newInstance(\n+    //     Class<?> instantiationClass, Class<?> constructorClass);\n+    // }\n+    try {\n+      final Method newInstance = ObjectInputStream.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, Object.class);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvivkm, post-gingerbread\n+    // public class ObjectStreamClass {\n+    //   private static native int getConstructorId(Class<?> c);\n+    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n+    // }\n+    try {\n+      Method getConstructorId = ObjectStreamClass.class\n+          .getDeclaredMethod(\"getConstructorId\", Class.class);\n+      getConstructorId.setAccessible(true);\n+      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n+      final Method newInstance = ObjectStreamClass.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, constructorId);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // give up\n+    return new UnsafeAllocator() {\n+      public <T> T newInstance(Class<T> c) throws InstantiationException {\n+        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+      }\n+    };\n+  }\n+}", "timestamp": 1299804255, "metainfo": ""}