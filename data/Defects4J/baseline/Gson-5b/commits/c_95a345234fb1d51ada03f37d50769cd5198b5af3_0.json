{"sha": "95a345234fb1d51ada03f37d50769cd5198b5af3", "log": "MiniGSON Map adapters and support for nulls.", "commit": "\n--- a/extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/mini/CollectionTypeAdapter.java\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n   }\n \n   public Collection<E> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n     Collection<E> collection = MiniGson.newInstance(constructor);\n     reader.beginArray();\n     while (reader.hasNext()) {\n   }\n \n   public void write(JsonWriter writer, Collection<E> collection) throws IOException {\n+    if (collection == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n     writer.beginArray();\n     for (E element : collection) {\n       elementTypeAdapter.write(writer, element);\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/mini/MapTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.mini;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a homogeneous collection of objects.\n+ */\n+final class MapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof ParameterizedType)) {\n+        return null;\n+      }\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Map.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);\n+      if (keyAndValueTypes[0] != String.class) {\n+        return null; // TODO: return an array-style map adapter\n+      }\n+      TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+\n+      Class<?> constructorType;\n+\n+      if (rawType == Map.class) {\n+        constructorType = LinkedHashMap.class;\n+      } else {\n+        constructorType = rawType;\n+      }\n+\n+      Constructor<?> constructor;\n+      try {\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+      TypeAdapter<T> result = new MapTypeAdapter(valueAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<V> valueTypeAdapter;\n+  private final Constructor<? extends Map<String, V>> constructor;\n+\n+  public MapTypeAdapter(TypeAdapter<V> valueTypeAdapter,\n+      Constructor<? extends Map<String, V>> constructor) {\n+    this.valueTypeAdapter = valueTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Map<String, V> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    Map<String, V> map = MiniGson.newInstance(constructor);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String key = reader.nextName();\n+      V value = valueTypeAdapter.read(reader);\n+      map.put(key, value);\n+    }\n+    reader.endObject();\n+    return map;\n+  }\n+\n+  public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+    if (map == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginObject();\n+    for (Map.Entry<String, V> entry : map.entrySet()) {\n+      writer.name(entry.getKey());\n+      valueTypeAdapter.write(writer, entry.getValue());\n+    }\n+    writer.endObject();\n+  }\n+}\n--- a/extras/src/main/java/com/google/gson/mini/MiniGson.java\n+++ b/extras/src/main/java/com/google/gson/mini/MiniGson.java\n     factories.add(TypeAdapters.STRING_FACTORY);\n     factories.add(ReflectiveTypeAdapter.FACTORY);\n     factories.add(CollectionTypeAdapter.FACTORY);\n+    factories.add(MapTypeAdapter.FACTORY);\n     this.factories = Collections.unmodifiableList(factories);\n   }\n \n    *     deserialize {@code type}.\n    */\n   public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n+    // TODO: create a cache here\n     for (TypeAdapter.Factory factory : factories) {\n       TypeAdapter<T> candidate = factory.create(this, type);\n       if (candidate != null) {\n   public static final class Builder {\n     private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n \n-    public void factory(TypeAdapter.Factory factory) {\n+    public Builder factory(TypeAdapter.Factory factory) {\n       factories.add(factory);\n+      return this;\n     }\n \n-    public <T> void typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+    public <T> Builder typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n       factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+      return this;\n     }\n \n-    public <T> void typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    public <T> Builder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n       factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+      return this;\n     }\n \n-    public <T> void typeHierarchyAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    public <T> Builder typeHierarchyAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n       factories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n+      return this;\n     }\n \n     public MiniGson build() {\n--- a/extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n       Class<? super T> raw = type.getRawType();\n \n       if (!Object.class.isAssignableFrom(raw)) {\n-        // TODO: does this catch primitives?\n-        return null;\n+        return null; // it's a primitive!\n       }\n \n       // TODO: use Joel's constructor calling code (with setAccessible)\n-      Constructor<T> constructor;\n+      Constructor<? super T> constructor;\n       try {\n-        constructor = (Constructor<T>) raw.getDeclaredConstructor();\n+        constructor = raw.getDeclaredConstructor();\n       } catch (NoSuchMethodException e) {\n         return null;\n       }\n     }\n   };\n \n-  private final Constructor<T> constructor;\n+  private final Constructor<? super T> constructor;\n   private final Map<String, BoundField<?>> map;\n   private final BoundField<?>[] boundFields;\n \n-  ReflectiveTypeAdapter(Constructor<T> constructor, Map<String, BoundField<?>> map) {\n+  ReflectiveTypeAdapter(Constructor<? super T> constructor, Map<String, BoundField<?>> map) {\n     this.constructor = constructor;\n     this.map = map;\n     this.boundFields = map.values().toArray(new BoundField<?>[map.size()]);\n   }\n \n   public T read(JsonReader reader) throws IOException {\n-    T instance = MiniGson.newInstance(constructor);\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n+    T instance = (T) MiniGson.newInstance(constructor);\n \n     // TODO: null out the other fields?\n \n   }\n \n   public void write(JsonWriter writer, T value) throws IOException {\n+    if (value == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n     writer.beginObject();\n     for (BoundField<?> boundField : boundFields) {\n       writer.name(boundField.name);\n--- a/extras/src/main/java/com/google/gson/mini/TypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/mini/TypeAdapter.java\n \n   public final T read(Reader in) throws IOException {\n     JsonReader reader = new JsonReader(in);\n-    reader.setLenient(true); // TODO: why?\n+    reader.setLenient(true);\n     return read(reader);\n   }\n \n--- a/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n+++ b/extras/src/test/java/com/google/gson/mini/MiniGsonTest.java\n \n package com.google.gson.mini;\n \n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n import junit.framework.TestCase;\n \n public final class MiniGsonTest extends TestCase {\n \n+  private MiniGson miniGson = new MiniGson.Builder().build();\n+  private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n+  private TypeAdapter<Map<String, Double>> mapAdapter\n+      = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});\n+\n   public void testSerialize() throws IOException {\n-    Person jesse = new Person(\"Jesse\", 29);\n-    Person jodie = new Person(\"Jodie\", 29);\n     Truck truck = new Truck();\n-    truck.passengers = Arrays.asList(jesse, jodie);\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n     truck.horsePower = 300;\n \n-    MiniGson miniGson = new MiniGson.Builder().build();\n-    TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n-\n-    String json = truckAdapter.toJson(truck);\n     assertEquals(\"{'horsePower':300.0,\"\n         + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\",\n-        json.replace('\\\"', '\\''));\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n   }\n \n   public void testDeserialize() throws IOException {\n     String json = \"{'horsePower':300.0,\"\n         + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\";\n+    Truck truck = truckAdapter.fromJson(json);\n+    assertEquals(300.0, truck.horsePower);\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29)), truck.passengers);\n+  }\n \n-    MiniGson miniGson = new MiniGson.Builder().build();\n-    TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n-    Truck truck = truckAdapter.fromJson(json);\n+  public void testSerializeNullField() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = null;\n+    assertEquals(\"{'horsePower':0.0,'passengers':null}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n \n-    assertEquals(300.0, truck.horsePower);\n-    Person jesse = truck.passengers.get(0);\n-    assertEquals(\"Jesse\", jesse.name);\n-    assertEquals(29, jesse.age);\n-    Person jodie = truck.passengers.get(1);\n-    assertEquals(\"Jodie\", jodie.name);\n-    assertEquals(29, jodie.age);\n+  public void testDeserializeNullField() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':null}\");\n+    assertNull(truck.passengers);\n+  }\n+\n+  public void testSerializeNullObject() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList((Person) null);\n+    assertEquals(\"{'horsePower':0.0,'passengers':[null]}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeNullObject() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':[null]}\");\n+    assertEquals(Arrays.asList((Person) null), truck.passengers);\n+  }\n+\n+  public void testSerializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n+    assertEquals(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\");\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", -1), new Person(\"Jodie\", -1)), truck.passengers);\n+  }\n+\n+  private void usePersonNameAdapter() {\n+    TypeAdapter<Person> personNameAdapter = new TypeAdapter<Person>() {\n+      @Override public Person read(JsonReader reader) throws IOException {\n+        String name = reader.nextString();\n+        return new Person(name, -1);\n+      }\n+      @Override public void write(JsonWriter writer, Person value) throws IOException {\n+        writer.value(value.name);\n+      }\n+    };\n+    miniGson = new MiniGson.Builder().typeAdapter(Person.class, personNameAdapter).build();\n+    truckAdapter = miniGson.getAdapter(Truck.class);\n+  }\n+\n+  public void testSerializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(\"{'a':5.0,'b':10.0}\", mapAdapter.toJson(map).replace('\"', '\\''));\n+  }\n+\n+  public void testDeserializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(map, mapAdapter.fromJson(\"{'a':5.0,'b':10.0}\"));\n   }\n \n   static class Truck {\n     double horsePower;\n-    List<Person> passengers;\n+    List<Person> passengers = Collections.emptyList();\n   }\n \n   static class Person {\n     int age;\n     String name;\n-\n     Person(String name, int age) {\n       this.name = name;\n       this.age = age;\n     }\n \n     public Person() {} // TODO: use Joel's constructor code so we don't need this\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Person\n+          && ((Person) o).name.equals(name)\n+          && ((Person) o).age == age;\n+    }\n+    @Override public int hashCode() {\n+      return name.hashCode() ^ age;\n+    }\n   }\n }", "timestamp": 1310420709, "metainfo": ""}