{"sha": "89c18452aee5242646ae7d5562fb73b4795f6c58", "log": "Ensure date with pattern is not override with the \"default\" date type adapter when a custom JsonSerializer/JsonDeserializer is registered.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n     return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy));\n   }\n-  \n+\n   /**\n    * Configures Gson to apply a specific naming policy strategy to an object's field during\n    * serialization and deserialization.\n   private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n-    if (!serializers.hasSpecificHandlerFor(Date.class)\n-        && !deserializers.hasSpecificHandlerFor(Date.class)) {\n-      // NOTE: if a date pattern exists, then that style takes priority\n-      DefaultDateTypeAdapter dateTypeAdapter = null;\n-      if (datePattern != null && !\"\".equals(datePattern.trim())) {\n-        dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n-      } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n-        dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n+    DefaultDateTypeAdapter dateTypeAdapter = null;\n+    if (datePattern != null && !\"\".equals(datePattern.trim())) {\n+      dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n+    } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n+      dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n+    }\n+\n+    if (dateTypeAdapter != null) {\n+      if (!serializers.hasSpecificHandlerFor(Date.class)) {\n+        serializers.register(Date.class, dateTypeAdapter);\n       }\n-\n-      if (dateTypeAdapter != null) {\n-        serializers.register(Date.class, dateTypeAdapter);\n+      if (!deserializers.hasSpecificHandlerFor(Date.class)) {\n         deserializers.register(Date.class, dateTypeAdapter);\n       }\n     }\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n  * limitations under the License.\n  */\n package com.google.gson.functional;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n-import com.google.gson.JsonParseException;\n-import com.google.gson.reflect.TypeToken;\n-\n-import junit.framework.TestCase;\n \n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.util.TreeSet;\n import java.util.UUID;\n \n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+\n /**\n  * Functional test for Json serialization and deserialization for common classes for which default\n  * support is provided in Gson. The tests for Map types are available in {@link MapTest}.\n     String json = \"'http:\\\\/\\\\/google.com\\\\/'\";\n     URL target = gson.fromJson(json, URL.class);\n     assertEquals(urlValue, target.toExternalForm());\n-    \n+\n     gson.fromJson('\"' + urlValue + '\"', URL.class);\n     assertEquals(urlValue, target.toExternalForm());\n   }\n     ClassWithUrlField target = gson.fromJson(json, ClassWithUrlField.class);\n     assertNull(target.url);\n   }\n-  \n+\n   private static class ClassWithUrlField {\n     URL url;\n   }\n     URI target = gson.fromJson(json, URI.class);\n     assertEquals(uriValue, target.toASCIIString());\n   }\n-  \n+\n   public void testUuidSerialization() throws Exception {\n     String uuidValue = \"c237bec1-19ef-4858-a98e-521cf0aad4c0\";\n     UUID uuid = UUID.fromString(uuidValue);\n   // millisecond portion.\n   @SuppressWarnings(\"deprecation\")\n   private void assertEqualsDate(Date date, int year, int month, int day) {\n-      assertEquals(year-1900, date.getYear());    \n-      assertEquals(month, date.getMonth());    \n+      assertEquals(year-1900, date.getYear());\n+      assertEquals(month, date.getMonth());\n       assertEquals(day, date.getDate());\n   }\n \n   @SuppressWarnings(\"deprecation\")\n   private void assertEqualsTime(Date date, int hours, int minutes, int seconds) {\n-    assertEquals(hours, date.getHours());    \n-    assertEquals(minutes, date.getMinutes());        \n+    assertEquals(hours, date.getHours());\n+    assertEquals(minutes, date.getMinutes());\n     assertEquals(seconds, date.getSeconds());\n   }\n \n     java.sql.Date extracted = gson.fromJson(json, java.sql.Date.class);\n     assertEqualsDate(extracted, 2009, 11, 3);\n   }\n-  \n+\n   public void testDefaultJavaSqlTimestampSerialization() {\n     Timestamp now = new java.sql.Timestamp(1259875082000L);\n     String json = gson.toJson(now);\n     assertEqualsDate(extracted, 2009, 11, 3);\n     assertEqualsTime(extracted, 13, 18, 02);\n   }\n-  \n+\n   public void testDefaultJavaSqlTimeSerialization() {\n     Time now = new Time(1259875082000L);\n     String json = gson.toJson(now);\n     Time extracted = gson.fromJson(json, Time.class);\n     assertEqualsTime(extracted, 13, 18, 02);\n   }\n-  \n+\n   public void testDefaultDateSerializationUsingBuilder() throws Exception {\n     Gson gson = new GsonBuilder().create();\n     Date now = new Date();\n     Date now = new Date();\n     String json = gson.toJson(now);\n     Date extracted = gson.fromJson(json, Date.class);\n-    assertEquals(now.toString(), extracted.toString());    \n+    assertEquals(now.toString(), extracted.toString());\n   }\n \n   public void testDefaultCalendarSerialization() throws Exception {\n     assertTrue(json.contains(\"minute\"));\n     assertTrue(json.contains(\"second\"));\n   }\n-  \n+\n   public void testDefaultCalendarDeserialization() throws Exception {\n     Gson gson = new GsonBuilder().create();\n     String json = \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\n     assertTrue(json.contains(\"minute\"));\n     assertTrue(json.contains(\"second\"));\n   }\n-  \n+\n   public void testDefaultGregorianCalendarDeserialization() throws Exception {\n     Gson gson = new GsonBuilder().create();\n     String json = \"{year:2009,month:2,dayOfMonth:11,hourOfDay:14,minute:29,second:23}\";\n     assertEquals(29, cal.get(Calendar.MINUTE));\n     assertEquals(23, cal.get(Calendar.SECOND));\n   }\n-  \n+\n   public void testDateSerializationWithPattern() throws Exception {\n     String pattern = \"yyyy-MM-dd\";\n     DateFormat formatter = new SimpleDateFormat(pattern);\n     String json = gson.toJson(now);\n     assertEquals(\"\\\"\" + formatter.format(now) + \"\\\"\", json);\n   }\n-  \n+\n   @SuppressWarnings(\"deprecation\")\n   public void testDateDeserializationWithPattern() throws Exception {\n     String pattern = \"yyyy-MM-dd\";\n     Date now = new Date();\n     String json = gson.toJson(now);\n     Date extracted = gson.fromJson(json, Date.class);\n-    assertEquals(now.getYear(), extracted.getYear());    \n-    assertEquals(now.getMonth(), extracted.getMonth());    \n-    assertEquals(now.getDay(), extracted.getDay());    \n-  }\n-  \n+    assertEquals(now.getYear(), extracted.getYear());\n+    assertEquals(now.getMonth(), extracted.getMonth());\n+    assertEquals(now.getDay(), extracted.getDay());\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n+  public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {\n+    String pattern = \"yyyy-MM-dd\";\n+    DateFormat formatter = new SimpleDateFormat(pattern);\n+    Gson gson = new GsonBuilder()\n+        .setDateFormat(pattern)\n+        .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {\n+          public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+              throws JsonParseException {\n+            return new Date();\n+          }\n+        })\n+        .create();\n+\n+    Date now = new Date();\n+    String expectedDateString = \"\\\"\" + formatter.format(now) + \"\\\"\";\n+    String json = gson.toJson(now);\n+    assertEquals(expectedDateString, json);\n+  }\n+\n   private static class ClassWithBigDecimal {\n     BigDecimal value;\n     // For use by Gson\n       return \"{\\\"value\\\":\" + value + \"}\";\n     }\n   }\n-  \n+\n   public void testPropertiesSerialization() {\n     Properties props = new Properties();\n     props.setProperty(\"foo\", \"bar\");\n     String expected = \"{\\\"foo\\\":\\\"bar\\\"}\";\n     assertEquals(expected, json);\n   }\n-  \n+\n   public void testPropertiesDeserialization() {\n     String json = \"{foo:'bar'}\";\n     Properties props = gson.fromJson(json, Properties.class);", "timestamp": 1282175932, "metainfo": ""}