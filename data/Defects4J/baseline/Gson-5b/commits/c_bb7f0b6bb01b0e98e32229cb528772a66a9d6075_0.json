{"sha": "bb7f0b6bb01b0e98e32229cb528772a66a9d6075", "log": "Adopt JsonElementWriter in GSON. Add setSerializeNulls() to JsonWriter, so nulls can be skipped from serialization. This does not yet impact JsonElementWriter.  One change in behavior: if the only value is skipped, we now emit \"null\" rather than \"\".", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    */\n   public String toJson(Object src, Type typeOfSrc) {\n     StringWriter writer = new StringWriter();\n-    toJson(toJsonTree(src, typeOfSrc), writer);\n+    toJson(src, typeOfSrc, writer);\n     return writer.toString();\n   }\n \n    * @since 1.2\n    */\n   public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\n-    JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n-    toJson(jsonElement, writer);\n+    try {\n+      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n+      toJson(src, typeOfSrc, jsonWriter);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    }\n   }\n \n   /**\n    * @throws JsonIOException if there was a problem writing to the writer\n    */\n   public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\n-    toJson(toJsonTree(src, typeOfSrc), writer);\n+    TypeAdapter<?> adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));\n+    boolean oldLenient = writer.isLenient();\n+    writer.setLenient(true);\n+    boolean oldHtmlSafe = writer.isHtmlSafe();\n+    writer.setHtmlSafe(htmlSafe);\n+    boolean oldSerializeNulls = writer.getSerializeNulls();\n+    writer.setSerializeNulls(serializeNulls);\n+    try {\n+      ((TypeAdapter<Object>) adapter).write(writer, src);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    } finally {\n+      writer.setLenient(oldLenient);\n+      writer.setHtmlSafe(oldHtmlSafe);\n+      writer.setSerializeNulls(oldSerializeNulls);\n+    }\n   }\n \n   /**\n    */\n   public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n     try {\n-      if (generateNonExecutableJson) {\n-        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n-      }\n-      JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer));\n-      if (prettyPrinting) {\n-        jsonWriter.setIndent(\"  \");\n-      }\n+      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n       toJson(jsonElement, jsonWriter);\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     }\n+  }\n+\n+  /**\n+   * Returns a new JSON writer configured for this GSON and with the non-execute\n+   * prefix if that is configured.\n+   */\n+  private JsonWriter newJsonWriter(Writer writer) throws IOException {\n+    if (generateNonExecutableJson) {\n+      writer.write(JSON_NON_EXECUTABLE_PREFIX);\n+    }\n+    JsonWriter jsonWriter = new JsonWriter(writer);\n+    if (prettyPrinting) {\n+      jsonWriter.setIndent(\"  \");\n+    }\n+    jsonWriter.setSerializeNulls(serializeNulls);\n+    return jsonWriter;\n   }\n \n   /**\n     writer.setLenient(true);\n     boolean oldHtmlSafe = writer.isHtmlSafe();\n     writer.setHtmlSafe(htmlSafe);\n+    boolean oldSerializeNulls = writer.getSerializeNulls();\n+    writer.setSerializeNulls(serializeNulls);\n     try {\n       Streams.write(jsonElement, serializeNulls, writer);\n     } catch (IOException e) {\n     } finally {\n       writer.setLenient(oldLenient);\n       writer.setHtmlSafe(oldHtmlSafe);\n+      writer.setSerializeNulls(oldSerializeNulls);\n     }\n   }\n \n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n \n   private boolean htmlSafe;\n \n+  private String deferredName;\n+\n+  private boolean serializeNulls = true;\n+\n   /**\n    * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n    * For best performance, ensure {@link Writer} is buffered; wrapping in\n   }\n \n   /**\n+   * Sets whether object members are serialized when their value is null.\n+   * This has no impact on array elements. The default is true.\n+   */\n+  public final void setSerializeNulls(boolean serializeNulls) {\n+    this.serializeNulls = serializeNulls;\n+  }\n+\n+  /**\n+   * Returns true if object members are serialized when their value is null.\n+   * This has no impact on array elements. The default is true.\n+   */\n+  public final boolean getSerializeNulls() {\n+    return serializeNulls;\n+  }\n+\n+  /**\n    * Begins encoding a new array. Each call to this method must be paired with\n    * a call to {@link #endArray}.\n    *\n    * @return this writer.\n    */\n   public JsonWriter beginArray() throws IOException {\n+    writeDeferredName();\n     return open(JsonScope.EMPTY_ARRAY, \"[\");\n   }\n \n    * @return this writer.\n    */\n   public JsonWriter beginObject() throws IOException {\n+    writeDeferredName();\n     return open(JsonScope.EMPTY_OBJECT, \"{\");\n   }\n \n     if (context != nonempty && context != empty) {\n       throw new IllegalStateException(\"Nesting problem: \" + stack);\n     }\n+    if (deferredName != null) {\n+      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n+    }\n \n     stack.remove(stack.size() - 1);\n     if (context == nonempty) {\n     if (name == null) {\n       throw new NullPointerException(\"name == null\");\n     }\n-    beforeName();\n-    string(name);\n-    return this;\n+    if (deferredName != null) {\n+      throw new IllegalStateException();\n+    }\n+    deferredName = name;\n+    return this;\n+  }\n+\n+  private void writeDeferredName() throws IOException {\n+    if (deferredName != null) {\n+      beforeName();\n+      string(deferredName);\n+      deferredName = null;\n+    }\n   }\n \n   /**\n     if (value == null) {\n       return nullValue();\n     }\n+    writeDeferredName();\n     beforeValue(false);\n     string(value);\n     return this;\n    * @return this writer.\n    */\n   public JsonWriter nullValue() throws IOException {\n+    if (deferredName != null) {\n+      if (serializeNulls) {\n+        writeDeferredName();\n+      } else {\n+        deferredName = null;\n+        return this; // skip the name and the value\n+      }\n+    }\n     beforeValue(false);\n     out.write(\"null\");\n     return this;\n    * @return this writer.\n    */\n   public JsonWriter value(boolean value) throws IOException {\n+    writeDeferredName();\n     beforeValue(false);\n     out.write(value ? \"true\" : \"false\");\n     return this;\n     if (Double.isNaN(value) || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n+    writeDeferredName();\n     beforeValue(false);\n     out.append(Double.toString(value));\n     return this;\n    * @return this writer.\n    */\n   public JsonWriter value(long value) throws IOException {\n+    writeDeferredName();\n     beforeValue(false);\n     out.write(Long.toString(value));\n     return this;\n       return nullValue();\n     }\n \n+    writeDeferredName();\n     String string = value.toString();\n     if (!lenient\n         && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n--- a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\n   private static final String VALUE = \"blah_1234\";\n \n   private Outer outer;\n-  \n+\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n     outer = new Outer();\n   }\n-  \n+\n   public void testDefaultInnerClassExclusion() throws Exception {\n     Gson gson = new Gson();\n     Outer.Inner target = outer.new Inner(VALUE);\n     String result = gson.toJson(target);\n     assertEquals(target.toJson(), result);\n-    \n+\n     gson = new GsonBuilder().create();\n     target = outer.new Inner(VALUE);\n     result = gson.toJson(target);\n     assertEquals(target.toJson(), result);\n   }\n-  \n+\n   public void testInnerClassExclusion() throws Exception {\n     Gson gson = new GsonBuilder().disableInnerClassSerialization().create();\n     Outer.Inner target = outer.new Inner(VALUE);\n     String result = gson.toJson(target);\n-    assertEquals(\"\", result);\n+    assertEquals(\"null\", result);\n   }\n-  \n+\n   public void testDefaultNestedStaticClassIncluded() throws Exception {\n     Gson gson = new Gson();\n     Outer.Inner target = outer.new Inner(VALUE);\n     String result = gson.toJson(target);\n     assertEquals(target.toJson(), result);\n-    \n+\n     gson = new GsonBuilder().create();\n     target = outer.new Inner(VALUE);\n     result = gson.toJson(target);\n     assertEquals(target.toJson(), result);\n   }\n-  \n+\n   private static class Outer {\n     private class Inner extends NestedClass {\n       public Inner(String value) {\n         super(value);\n       }\n     }\n-        \n+\n   }\n-  \n+\n   private static class NestedClass {\n     private final String value;\n     public NestedClass(String value) {\n       this.value = value;\n     }\n-    \n+\n     public String toJson() {\n       return \"{\\\"value\\\":\\\"\" + value + \"\\\"}\";\n     }\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n     assertEquals(10, target.intValue);\n     assertEquals(20, target.longValue);\n   }\n-  \n+\n   public void testJsonInMixedQuotesDeserialization() {\n     String json = \"{\\\"stringValue\\\":'no message','intValue':10,'longValue':20}\";\n     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n     assertEquals(10, target.intValue);\n     assertEquals(20, target.longValue);\n   }\n-  \n+\n   public void testBagOfPrimitivesSerialization() throws Exception {\n     BagOfPrimitives target = new BagOfPrimitives(10, 20, false, \"stringValue\");\n     assertEquals(target.getExpectedJson(), gson.toJson(target));\n     String stringValue = \"someStringValueInArray\";\n     String classWithObjectsJson = gson.toJson(classWithObjects);\n     String bagOfPrimitivesJson = gson.toJson(bagOfPrimitives);\n-    \n+\n     ClassWithArray classWithArray = new ClassWithArray(\n         new Object[] { stringValue, classWithObjects, bagOfPrimitives });\n     String json = gson.toJson(classWithArray);\n   }\n \n   public void testAnonymousLocalClassesSerialization() throws Exception {\n-    assertEquals(\"\", gson.toJson(new ClassWithNoFields() {\n+    assertEquals(\"null\", gson.toJson(new ClassWithNoFields() {\n       // empty anonymous class\n     }));\n   }\n   }\n \n   /**\n-   * Tests that a class field with type Object can be serialized properly. \n+   * Tests that a class field with type Object can be serialized properly.\n    * See issue 54\n    */\n   public void testClassWithObjectFieldSerialization() {\n     @SuppressWarnings(\"unused\")\n     Object member;\n   }\n-  \n-  public void testInnerClassSerialization() {    \n+\n+  public void testInnerClassSerialization() {\n     Parent p = new Parent();\n     Parent.Child c = p.new Child();\n     String json = gson.toJson(c);\n     assertTrue(json.contains(\"value2\"));\n     assertFalse(json.contains(\"value1\"));\n   }\n-   \n+\n   public void testInnerClassDeserialization() {\n     final Parent p = new Parent();\n     Gson gson = new GsonBuilder().registerTypeAdapter(\n         Parent.Child.class, new InstanceCreator<Parent.Child>() {\n       public Parent.Child createInstance(Type type) {\n         return p.new Child();\n-      }      \n+      }\n     }).create();\n     String json = \"{'value2':3}\";\n     Parent.Child c = gson.fromJson(json, Parent.Child.class);\n     assertEquals(3, c.value2);\n   }\n-   \n+\n   private static class Parent {\n     @SuppressWarnings(\"unused\")\n     int value1 = 1;\n       a = 10;\n     }\n   }\n-  \n+\n   /**\n    * In response to Issue 41 http://code.google.com/p/google-gson/issues/detail?id=41\n    */\n     assertTrue(bag.booleanValue);\n     assertEquals(\"bar\", bag.stringValue);\n   }\n-  \n+\n   public void testStringFieldWithNumberValueDeserialization() {\n     String json = \"{\\\"stringValue\\\":1}\";\n     BagOfPrimitives bag = gson.fromJson(json, BagOfPrimitives.class);\n     assertEquals(\"1\", bag.stringValue);\n-    \n+\n     json = \"{\\\"stringValue\\\":1.5E+6}\";\n     bag = gson.fromJson(json, BagOfPrimitives.class);\n     assertEquals(\"1.5E+6\", bag.stringValue);\n-    \n+\n     json = \"{\\\"stringValue\\\":true}\";\n     bag = gson.fromJson(json, BagOfPrimitives.class);\n     assertEquals(\"true\", bag.stringValue);\n     String b = \"\";\n     String c = \"\";\n   }\n-  \n+\n   public void testJsonObjectSerialization() {\n     Gson gson = new GsonBuilder().serializeNulls().create();\n     JsonObject obj = new JsonObject();\n--- a/gson/src/test/java/com/google/gson/functional/VersioningTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/VersioningTest.java\n     Gson gson = builder.setVersion(1.29).create();\n     String json = gson.toJson(target);\n     assertTrue(json.contains(\"\\\"a\\\":\" + A));\n-    \n+\n     gson = builder.setVersion(1.3).create();\n     json = gson.toJson(target);\n     assertFalse(json.contains(\"\\\"a\\\":\" + A));\n   }\n-  \n+\n   public void testVersionedUntilDeserialization() {\n     Gson gson = builder.setVersion(1.3).create();\n     String json = \"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5}\";\n \n   public void testIgnoreLaterVersionClassSerialization() {\n     Gson gson = builder.setVersion(1.0).create();\n-    assertEquals(\"\", gson.toJson(new Version1_2()));\n+    assertEquals(\"null\", gson.toJson(new Version1_2()));\n   }\n \n   public void testIgnoreLaterVersionClassDeserialization() {\n     SinceUntilMixing target = new SinceUntilMixing();\n     String json = gson.toJson(target);\n     assertFalse(json.contains(\"\\\"b\\\":\" + B));\n-    \n+\n     gson = builder.setVersion(1.2).create();\n     json = gson.toJson(target);\n     assertTrue(json.contains(\"\\\"b\\\":\" + B));\n-    \n+\n     gson = builder.setVersion(1.3).create();\n     json = gson.toJson(target);\n     assertFalse(json.contains(\"\\\"b\\\":\" + B));\n     SinceUntilMixing result = gson.fromJson(json, SinceUntilMixing.class);\n     assertEquals(5, result.a);\n     assertEquals(B, result.b);\n-    \n+\n     gson = builder.setVersion(1.2).create();\n     result = gson.fromJson(json, SinceUntilMixing.class);\n     assertEquals(5, result.a);\n     assertEquals(6, result.b);\n-    \n+\n     gson = builder.setVersion(1.3).create();\n     result = gson.fromJson(json, SinceUntilMixing.class);\n     assertEquals(5, result.a);\n   private static class Version1_2 extends Version1_1 {\n     int d = D;\n   }\n-  \n+\n   private static class SinceUntilMixing {\n     int a = A;\n-    \n+\n     @Since(1.1)\n     @Until(1.3)\n     int b = B;\n--- a/gson/src/test/java/com/google/gson/internal/bind/JsonElementWriterTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonElementWriterTest.java\n   // TODO: more tests\n   // TODO: close support\n   // TODO: figure out what should be returned by an empty writer\n+  // TODO: test when serialize nulls is false\n \n   public void testArray() throws IOException {\n     JsonElementWriter writer = new JsonElementWriter();", "timestamp": 1317366524, "metainfo": ""}