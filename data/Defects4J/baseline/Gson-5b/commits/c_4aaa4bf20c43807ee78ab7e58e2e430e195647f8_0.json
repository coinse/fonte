{"sha": "4aaa4bf20c43807ee78ab7e58e2e430e195647f8", "log": "StringMap was suffering because the string's hashCode was not cached. Address this by preferring the regular String.hashCode until hash collision problems start to occur.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/StringMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/StringMap.java\n   private static final int MAXIMUM_CAPACITY = 1 << 30;\n \n   /**\n+   * Max number of collisions in a single bucket before falling back to\n+   * an unpredictable hash code.\n+   */\n+  private static final int MAX_COLLISIONS = 512;\n+\n+  /**\n    * A dummy entry in the circular linked list of entries in the map.\n    * The first real entry is header.nxt, and the last is header.prv.\n    * If the map is empty, header.nxt == header && header.prv == header.\n    * above.\n    */\n   private int threshold;\n+\n+  /**\n+   * True to use String.hashCode(), which is cached per-string. False to use\n+   * less predictable (but uncached) hash algorithm.\n+   */\n+  private boolean useFastHash = true;\n \n   // Views - lazily initialized\n   private Set<String> keySet;\n       return null;\n     }\n \n-    int hash = hash(key);\n+    int hash = useFastHash ? fastHash(key) : unpredictableHash(key);\n     LinkedEntry<V>[] tab = table;\n     for (LinkedEntry<V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n       String eKey = e.key;\n       throw new NullPointerException(\"key == null\");\n     }\n \n-    int hash = hash(key);\n+    int collisionCount = 0;\n+    int hash = useFastHash ? fastHash(key) : unpredictableHash(key);\n     LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n     for (LinkedEntry<V> e = tab[index]; e != null; e = e.next) {\n+      collisionCount++;\n       if (e.hash == hash && key.equals(e.key)) {\n         V oldValue = e.value;\n         e.value = value;\n       index = hash & (tab.length - 1);\n     }\n     addNewEntry(key, value, hash, index);\n+\n+    /*\n+     * If we suffer a very large number of collisions, fall back from the cached\n+     * String.hashCode() to an (uncached) hash code that isn't predictable.\n+     */\n+    if (collisionCount >= MAX_COLLISIONS) {\n+      LinkedEntry<V> entry = header.nxt;\n+\n+      // clear the table\n+      Arrays.fill(table, null);\n+      size = 0;\n+      header.nxt = header.prv = header;\n+      useFastHash = false;\n+\n+      // fill it up in iteration order\n+      for (; entry != header; entry = entry.nxt) {\n+        put(entry.key, entry.value);\n+      }\n+    }\n+\n     return null;\n   }\n \n     if (key == null || !(key instanceof String)) {\n       return null;\n     }\n-    int hash = hash((String) key);\n+    int hash = useFastHash ? fastHash(key) : unpredictableHash((String) key);\n     LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n     for (LinkedEntry<V> e = tab[index], prev = null;\n       return false;\n     }\n \n-    int hash = hash((String) key);\n+    int hash = useFastHash ? fastHash(key) : unpredictableHash((String) key);\n     LinkedEntry<V>[] tab = table;\n     int index = hash & (tab.length - 1);\n     for (LinkedEntry<V> e = tab[index], prev = null; e != null; prev = e, e = e.next) {\n     }\n   }\n \n+  private static int fastHash(Object key) {\n+    int h = key.hashCode();\n+    // Apply Doug Lea's supplemental hash function to avoid collisions for\n+    // hashes that do not differ in lower or upper bits.\n+    h ^= (h >>> 20) ^ (h >>> 12);\n+    return h ^ (h >>> 7) ^ (h >>> 4);\n+  }\n+\n   private static final int seed = new Random().nextInt();\n-  private static int hash(String key) {\n+  private static int unpredictableHash(String key) {\n     // Ensuring that the hash is unpredictable and well distributed.\n     //\n     // Finding unpredictable hash functions is a bit of a dark art as we need to balance\n       h = h3 ^ (h3 >>> 6); // h3 / 64\n     }\n \n-    /*\n-     * Apply Doug Lea's supplemental hash function to avoid collisions for\n-     * hashes that do not differ in lower or upper bits.\n-     */\n+    // Apply Doug Lea's supplemental hash function to avoid collisions for\n+    // hashes that do not differ in lower or upper bits.\n     h ^= (h >>> 20) ^ (h >>> 12);\n     return h ^ (h >>> 7) ^ (h >>> 4);\n   }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/StringMapTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+public final class StringMapTest extends TestCase {\n+  public void testFallbackFromTooManyCollisions() {\n+    int count = 10000;\n+    StringMap<Integer> map = new StringMap<Integer>();\n+    int index = 0;\n+    List<String> collidingStrings = collidingStrings(1 << 20, count);\n+    for (String string : collidingStrings) {\n+      map.put(string, index++);\n+    }\n+    assertEquals(collidingStrings.size(), map.size());\n+    Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();\n+    for (int i = 0; i < count; i++) {\n+      Map.Entry<String, Integer> entry = iterator.next();\n+      assertEquals(collidingStrings.get(i), entry.getKey());\n+      assertEquals(Integer.valueOf(i), entry.getValue());\n+    }\n+  }\n+\n+  /**\n+   * @param h0 the hash code of the generated strings\n+   */\n+  private List<String> collidingStrings(int h0, int count) {\n+    List<String> result = new ArrayList<String>(count);\n+    int p1 = 31;\n+    int p0 = 31 * 31;\n+    int maxChar = Character.MAX_VALUE;\n+    for (char c0 = 0; c0 <= maxChar && c0 <= h0 / p0; c0++) {\n+      int h1 = h0 - c0 * p0;\n+      for (char c1 = 0; c1 <= maxChar && c1 <= h1 / p1; c1++) {\n+        int h2 = h1 - c1 * p1;\n+        char c2 = (char) h2;\n+        if (h2 != c2) {\n+          continue;\n+        }\n+        result.add(new String(new char[] { c0, c1, c2 } ));\n+        if (result.size() == count) {\n+          return result;\n+        }\n+      }\n+    }\n+    throw new IllegalArgumentException(\"Couldn't find \" + count + \" strings with hashCode \" + h0);\n+  }\n+}", "timestamp": 1341945961, "metainfo": ""}