{"sha": "a991e54157f694d603c013f05e8870ba5e49c78f", "log": "Make fewer calls to out.write() when serializing strings. On one Android test, this improved serialization time of some documents by 83%.                                   TWEETS                                  run          vm htmlSafe   ms linear runtime                    %  Before app_process     true 68.7 ============================== 100%   After app_process     true 35.9 ===============                 52%                                      READER_LONG                             run          vm htmlSafe    ms linear runtime                    %  Before app_process     true 439.0 ============================== 100%  After app_process     true  74.5 =====                           17%", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n  */\n public class JsonWriter implements Closeable {\n \n+  /*\n+   * From RFC 4627, \"All Unicode characters may be placed within the\n+   * quotation marks except for the characters that must be escaped:\n+   * quotation mark, reverse solidus, and the control characters\n+   * (U+0000 through U+001F).\"\n+   *\n+   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n+   * newline characters. This prevents eval() from failing with a syntax\n+   * error. http://code.google.com/p/google-gson/issues/detail?id=341\n+   */\n+  private static final String[] REPLACEMENT_CHARS;\n+  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\n+  static {\n+    REPLACEMENT_CHARS = new String[128];\n+    for (int i = 0; i <= 0x1f; i++) {\n+      REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", (int) i);\n+    }\n+    REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\n+    REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\n+    REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\n+    REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\n+    REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\n+    REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\n+    REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\n+    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\n+    HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\n+    HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\n+    HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\n+    HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\n+    HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\n+  }\n+\n   /** The output data, containing at most one top-level array or object. */\n   private final Writer out;\n \n   }\n \n   private void string(String value) throws IOException {\n+    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n     out.write(\"\\\"\");\n-    for (int i = 0, length = value.length(); i < length; i++) {\n+    int last = 0;\n+    int length = value.length();\n+    for (int i = 0; i < length; i++) {\n       char c = value.charAt(i);\n-\n-      /*\n-       * From RFC 4627, \"All Unicode characters may be placed within the\n-       * quotation marks except for the characters that must be escaped:\n-       * quotation mark, reverse solidus, and the control characters\n-       * (U+0000 through U+001F).\"\n-       *\n-       * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\n-       * newline characters. This prevents eval() from failing with a syntax\n-       * error. http://code.google.com/p/google-gson/issues/detail?id=341\n-       */\n-      switch (c) {\n-      case '\"':\n-      case '\\\\':\n-        out.write('\\\\');\n-        out.write(c);\n-        break;\n-\n-      case '\\t':\n-        out.write(\"\\\\t\");\n-        break;\n-\n-      case '\\b':\n-        out.write(\"\\\\b\");\n-        break;\n-\n-      case '\\n':\n-        out.write(\"\\\\n\");\n-        break;\n-\n-      case '\\r':\n-        out.write(\"\\\\r\");\n-        break;\n-\n-      case '\\f':\n-        out.write(\"\\\\f\");\n-        break;\n-\n-      case '<':\n-      case '>':\n-      case '&':\n-      case '=':\n-      case '\\'':\n-        if (htmlSafe) {\n-          out.write(String.format(\"\\\\u%04x\", (int) c));\n-        } else {\n-          out.write(c);\n+      String replacement;\n+      if (c < 128) {\n+        replacement = replacements[c];\n+        if (replacement == null) {\n+          continue;\n         }\n-        break;\n-\n-      case '\\u2028':\n-      case '\\u2029':\n-        out.write(String.format(\"\\\\u%04x\", (int) c));\n-        break;\n-\n-      default:\n-        if (c <= 0x1F) {\n-          out.write(String.format(\"\\\\u%04x\", (int) c));\n-        } else {\n-          out.write(c);\n-        }\n-        break;\n+      } else if (c == '\\u2028') {\n+        replacement = \"\\\\u2028\";\n+      } else if (c == '\\u2029') {\n+        replacement = \"\\\\u2029\";\n+      } else {\n+        continue;\n       }\n+      if (last < i) {\n+        out.write(value, last, i - last);\n+      }\n+      out.write(replacement);\n+      last = i + 1;\n+    }\n+    if (last < length) {\n+      out.write(value, last, length - last);\n     }\n     out.write(\"\\\"\");\n   }", "timestamp": 1334237077, "metainfo": ""}