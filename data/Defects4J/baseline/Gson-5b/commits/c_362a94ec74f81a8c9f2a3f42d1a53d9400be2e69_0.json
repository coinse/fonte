{"sha": "362a94ec74f81a8c9f2a3f42d1a53d9400be2e69", "log": "Added deserialization support for Double NaN, Infinity, and -Infinity", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n-/* Generated By:JavaCC: Do not edit this line. JsonParser.java */\n-package com.google.gson;\n-\n-@SuppressWarnings(\"all\")\n-final class JsonParser implements JsonParserConstants {\n-\n-  final public JsonElement parse() throws ParseException {\n-  JsonElement json = null;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 23:\n-      json = JsonObject();\n-      break;\n-    case 27:\n-      json = JsonArray();\n-      break;\n-    case DIGITS:\n-    case BOOLEAN:\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-    case 29:\n-      json = JsonPrimitive();\n-      break;\n-    case NULL:\n-      json = JsonNull();\n-      break;\n-    default:\n-      jj_la1[0] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    {if (true) return json;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonObject JsonObject() throws ParseException {\n-  JsonObject o = new JsonObject();\n-    jj_consume_token(23);\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case IDENTIFIER:\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-      Members(o);\n-      break;\n-    default:\n-      jj_la1[1] = jj_gen;\n-      ;\n-    }\n-    jj_consume_token(24);\n-    {if (true) return o;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonNull JsonNull() throws ParseException {\n-  Token t;\n-    t = jj_consume_token(NULL);\n-               {if (true)\n-                return JsonNull.createJsonNull();}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private void Members(JsonObject o) throws ParseException {\n-    Pair(o);\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 25:\n-      jj_consume_token(25);\n-      Members(o);\n-      break;\n-    default:\n-      jj_la1[2] = jj_gen;\n-      ;\n-    }\n-  }\n-\n-  final private void Pair(JsonObject o) throws ParseException {\n-  JsonPrimitive property;\n-  JsonElement value;\n-    property = JsonMemberName();\n-    jj_consume_token(26);\n-    value = JsonValue();\n-    o.add(property.getAsString(), value);\n-  }\n-\n-  final private JsonPrimitive JsonMemberName() throws ParseException {\n-  Token t; JsonPrimitive value;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case IDENTIFIER:\n-      t = jj_consume_token(IDENTIFIER);\n-                   {if (true) return new JsonPrimitive(t.image);}\n-      break;\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-      value = JsonString();\n-                       {if (true) return value;}\n-      break;\n-    default:\n-      jj_la1[3] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonArray JsonArray() throws ParseException {\n-  JsonArray array = new JsonArray();\n-    jj_consume_token(27);\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case DIGITS:\n-    case NULL:\n-    case BOOLEAN:\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-    case 23:\n-    case 27:\n-    case 29:\n-      Elements(array);\n-      break;\n-    default:\n-      jj_la1[4] = jj_gen;\n-      ;\n-    }\n-    jj_consume_token(28);\n-    array.reverse();\n-    {if (true) return array;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private void Elements(JsonArray array) throws ParseException {\n-  JsonElement element;\n-    element = JsonValue();\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 25:\n-      jj_consume_token(25);\n-      Elements(array);\n-      break;\n-    default:\n-      jj_la1[5] = jj_gen;\n-      ;\n-    }\n-    array.add(element);\n-  }\n-\n-  final private JsonElement JsonValue() throws ParseException {\n-  JsonElement o = null;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-      o = JsonString();\n-      break;\n-    case DIGITS:\n-    case 29:\n-      o = JsonNumber();\n-      break;\n-    case 23:\n-      o = JsonObject();\n-      break;\n-    case 27:\n-      o = JsonArray();\n-      break;\n-    case BOOLEAN:\n-      o = JsonBoolean();\n-      break;\n-    case NULL:\n-      o = JsonNull();\n-      break;\n-    default:\n-      jj_la1[6] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    {if (true) return o;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonPrimitive JsonBoolean() throws ParseException {\n-  Token t;\n-    t = jj_consume_token(BOOLEAN);\n-    boolean value = Boolean.valueOf(t.image);\n-    {if (true) return new JsonPrimitive(value);}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonPrimitive JsonPrimitive() throws ParseException {\n-  JsonPrimitive value;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case SINGLE_QUOTE_LITERAL:\n-    case DOUBLE_QUOTE_LITERAL:\n-      value = JsonString();\n-                          {if (true) return value;}\n-      break;\n-    case DIGITS:\n-    case 29:\n-      value = JsonNumber();\n-                          {if (true) return value;}\n-      break;\n-    case BOOLEAN:\n-      value = JsonBoolean();\n-                           {if (true) return value;}\n-      break;\n-    default:\n-      jj_la1[7] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonPrimitive JsonNumber() throws ParseException {\n-  String intpart = null,\n-         fracpart = null,\n-         exppart = null;\n-    intpart = JsonInt();\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 30:\n-      fracpart = JsonFrac();\n-      break;\n-    default:\n-      jj_la1[8] = jj_gen;\n-      ;\n-    }\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case E:\n-      exppart = JsonExp();\n-      break;\n-    default:\n-      jj_la1[9] = jj_gen;\n-      ;\n-    }\n-    Number n;\n-    if (exppart != null || fracpart != null) {\n-      fracpart = (fracpart == null) ? \"\" : fracpart;\n-      exppart = (exppart == null) ? \"\" : exppart;\n-      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n-    } else {\n-      n = new java.math.BigInteger(intpart);\n-    }\n-    {if (true) return new JsonPrimitive(n);}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private String JsonInt() throws ParseException {\n-  String digits;\n-  boolean negative = false;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 29:\n-      jj_consume_token(29);\n-         negative = true;\n-      break;\n-    default:\n-      jj_la1[10] = jj_gen;\n-      ;\n-    }\n-    digits = Digits();\n-    if(negative)\n-      {if (true) return \"-\" + digits;}\n-    {if (true) return digits;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private String JsonFrac() throws ParseException {\n-  String digits;\n-    jj_consume_token(30);\n-    digits = Digits();\n-    {if (true) return \".\" + digits;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private String JsonExp() throws ParseException {\n-  Token t;\n-  String digits;\n-    t = jj_consume_token(E);\n-    digits = Digits();\n-    {if (true) return t.image + digits;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private String Digits() throws ParseException {\n-  Token t;\n-    t = jj_consume_token(DIGITS);\n-    {if (true) return t.image;}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private JsonPrimitive JsonString() throws ParseException {\n-  Token t;\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case SINGLE_QUOTE_LITERAL:\n-      t = jj_consume_token(SINGLE_QUOTE_LITERAL);\n-      break;\n-    case DOUBLE_QUOTE_LITERAL:\n-      t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n-      break;\n-    default:\n-      jj_la1[11] = jj_gen;\n-      jj_consume_token(-1);\n-      throw new ParseException();\n-    }\n-    String value = StringUnmarshaller.unmarshall(t.image);\n-    {if (true) return new JsonPrimitive(value);}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  public JsonParserTokenManager token_source;\n-  SimpleCharStream jj_input_stream;\n-  public Token token, jj_nt;\n-  private int jj_ntk;\n-  private int jj_gen;\n-  final private int[] jj_la1 = new int[12];\n-  static private int[] jj_la1_0;\n-  static {\n-      jj_la1_0();\n-   }\n-   private static void jj_la1_0() {\n-      jj_la1_0 = new int[] {0x288061c0,0x6200,0x2000000,0x6200,0x288061c0,0x2000000,0x288061c0,0x20006140,0x40000000,0x20,0x20000000,0x6000,};\n-   }\n-\n-  public JsonParser(java.io.InputStream stream) {\n-     this(stream, null);\n-  }\n-  public JsonParser(java.io.InputStream stream, String encoding) {\n-    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n-    token_source = new JsonParserTokenManager(jj_input_stream);\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  public void ReInit(java.io.InputStream stream) {\n-     ReInit(stream, null);\n-  }\n-  public void ReInit(java.io.InputStream stream, String encoding) {\n-    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n-    token_source.ReInit(jj_input_stream);\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  public JsonParser(java.io.Reader stream) {\n-    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n-    token_source = new JsonParserTokenManager(jj_input_stream);\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  public void ReInit(java.io.Reader stream) {\n-    jj_input_stream.ReInit(stream, 1, 1);\n-    token_source.ReInit(jj_input_stream);\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  public JsonParser(JsonParserTokenManager tm) {\n-    token_source = tm;\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  public void ReInit(JsonParserTokenManager tm) {\n-    token_source = tm;\n-    token = new Token();\n-    jj_ntk = -1;\n-    jj_gen = 0;\n-    for (int i = 0; i < 12; i++) jj_la1[i] = -1;\n-  }\n-\n-  final private Token jj_consume_token(int kind) throws ParseException {\n-    Token oldToken;\n-    if ((oldToken = token).next != null) token = token.next;\n-    else token = token.next = token_source.getNextToken();\n-    jj_ntk = -1;\n-    if (token.kind == kind) {\n-      jj_gen++;\n-      return token;\n-    }\n-    token = oldToken;\n-    jj_kind = kind;\n-    throw generateParseException();\n-  }\n-\n-  final public Token getNextToken() {\n-    if (token.next != null) token = token.next;\n-    else token = token.next = token_source.getNextToken();\n-    jj_ntk = -1;\n-    jj_gen++;\n-    return token;\n-  }\n-\n-  final public Token getToken(int index) {\n-    Token t = token;\n-    for (int i = 0; i < index; i++) {\n-      if (t.next != null) t = t.next;\n-      else t = t.next = token_source.getNextToken();\n-    }\n-    return t;\n-  }\n-\n-  final private int jj_ntk() {\n-    if ((jj_nt=token.next) == null)\n-      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n-    else\n-      return (jj_ntk = jj_nt.kind);\n-  }\n-\n-  private java.util.Vector jj_expentries = new java.util.Vector();\n-  private int[] jj_expentry;\n-  private int jj_kind = -1;\n-\n-  public ParseException generateParseException() {\n-    jj_expentries.removeAllElements();\n-    boolean[] la1tokens = new boolean[31];\n-    for (int i = 0; i < 31; i++) {\n-      la1tokens[i] = false;\n-    }\n-    if (jj_kind >= 0) {\n-      la1tokens[jj_kind] = true;\n-      jj_kind = -1;\n-    }\n-    for (int i = 0; i < 12; i++) {\n-      if (jj_la1[i] == jj_gen) {\n-        for (int j = 0; j < 32; j++) {\n-          if ((jj_la1_0[i] & (1<<j)) != 0) {\n-            la1tokens[j] = true;\n-          }\n-        }\n-      }\n-    }\n-    for (int i = 0; i < 31; i++) {\n-      if (la1tokens[i]) {\n-        jj_expentry = new int[1];\n-        jj_expentry[0] = i;\n-        jj_expentries.addElement(jj_expentry);\n-      }\n-    }\n-    int[][] exptokseq = new int[jj_expentries.size()][];\n-    for (int i = 0; i < jj_expentries.size(); i++) {\n-      exptokseq[i] = (int[])jj_expentries.elementAt(i);\n-    }\n-    return new ParseException(token, exptokseq, tokenImage);\n-  }\n-\n-  final public void enable_tracing() {\n-  }\n-\n-  final public void disable_tracing() {\n-  }\n-\n-}\n+/* Generated By:JavaCC: Do not edit this line. JsonParser.java */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+final class JsonParser implements JsonParserConstants {\n+\n+  final public JsonElement parse() throws ParseException {\n+  JsonElement json = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 25:\n+      json = JsonObject();\n+      break;\n+    case 29:\n+      json = JsonArray();\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case BOOLEAN:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+    case 31:\n+      json = JsonPrimitive();\n+      break;\n+    case NULL:\n+      json = JsonNull();\n+      break;\n+    default:\n+      jj_la1[0] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return json;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonObject JsonObject() throws ParseException {\n+  JsonObject o = new JsonObject();\n+    jj_consume_token(25);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[1] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(26);\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonNull JsonNull() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(NULL);\n+               {if (true) return JsonNull.createJsonNull();}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Members(JsonObject o) throws ParseException {\n+    Pair(o);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 27:\n+      jj_consume_token(27);\n+      Members(o);\n+      break;\n+    default:\n+      jj_la1[2] = jj_gen;\n+      ;\n+    }\n+  }\n+\n+  final private void Pair(JsonObject o) throws ParseException {\n+  JsonPrimitive property;\n+  JsonElement value;\n+    property = JsonMemberName();\n+    jj_consume_token(28);\n+    value = JsonValue();\n+    o.add(property.getAsString(), value);\n+  }\n+\n+  final private JsonPrimitive JsonMemberName() throws ParseException {\n+  Token t; JsonPrimitive value;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case IDENTIFIER:\n+      t = jj_consume_token(IDENTIFIER);\n+                   {if (true) return new JsonPrimitive(t.image);}\n+      break;\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      value = JsonString();\n+                       {if (true) return value;}\n+      break;\n+    default:\n+      jj_la1[3] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonArray JsonArray() throws ParseException {\n+  JsonArray array = new JsonArray();\n+    jj_consume_token(29);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case DIGITS:\n+    case NULL:\n+    case NAN:\n+    case INFINITY:\n+    case BOOLEAN:\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+    case 25:\n+    case 29:\n+    case 31:\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[4] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(30);\n+    array.reverse();\n+    {if (true) return array;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Elements(JsonArray array) throws ParseException {\n+  JsonElement element;\n+    element = JsonValue();\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 27:\n+      jj_consume_token(27);\n+      Elements(array);\n+      break;\n+    default:\n+      jj_la1[5] = jj_gen;\n+      ;\n+    }\n+    array.add(element);\n+  }\n+\n+  final private JsonElement JsonValue() throws ParseException {\n+  JsonElement o = null;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      o = JsonString();\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case 31:\n+      o = JsonNumber();\n+      break;\n+    case 25:\n+      o = JsonObject();\n+      break;\n+    case 29:\n+      o = JsonArray();\n+      break;\n+    case BOOLEAN:\n+      o = JsonBoolean();\n+      break;\n+    case NULL:\n+      o = JsonNull();\n+      break;\n+    default:\n+      jj_la1[6] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    {if (true) return o;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonBoolean() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(BOOLEAN);\n+    boolean value = Boolean.valueOf(t.image);\n+    {if (true) return new JsonPrimitive(value);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonPrimitive() throws ParseException {\n+  JsonPrimitive value;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+    case DOUBLE_QUOTE_LITERAL:\n+      value = JsonString();\n+                          {if (true) return value;}\n+      break;\n+    case DIGITS:\n+    case NAN:\n+    case INFINITY:\n+    case 31:\n+      value = JsonNumber();\n+                          {if (true) return value;}\n+      break;\n+    case BOOLEAN:\n+      value = JsonBoolean();\n+                           {if (true) return value;}\n+      break;\n+    default:\n+      jj_la1[7] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonNumber() throws ParseException {\n+  String intpart = null,\n+         fracpart = null,\n+         exppart = null;\n+  JsonPrimitive value;\n+    if (jj_2_1(2)) {\n+      value = JsonSpecialNumbers();\n+                                {if (true) return value;}\n+    } else {\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case DIGITS:\n+      case 31:\n+        intpart = JsonInt();\n+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+        case 32:\n+          fracpart = JsonFrac();\n+          break;\n+        default:\n+          jj_la1[8] = jj_gen;\n+          ;\n+        }\n+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+        case E:\n+          exppart = JsonExp();\n+          break;\n+        default:\n+          jj_la1[9] = jj_gen;\n+          ;\n+        }\n+    Number n;\n+    if (exppart != null || fracpart != null) {\n+      fracpart = (fracpart == null) ? \"\" : fracpart;\n+      exppart = (exppart == null) ? \"\" : exppart;\n+      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n+    } else {\n+      n = new java.math.BigInteger(intpart);\n+    }\n+    {if (true) return new JsonPrimitive(n);}\n+        break;\n+      default:\n+        jj_la1[10] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonSpecialNumbers() throws ParseException {\n+  boolean negative = false;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case NAN:\n+      jj_consume_token(NAN);\n+           {if (true) return new JsonPrimitive(Double.NaN);}\n+      break;\n+    case INFINITY:\n+    case 31:\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case 31:\n+        jj_consume_token(31);\n+         negative = true;\n+        break;\n+      default:\n+        jj_la1[11] = jj_gen;\n+        ;\n+      }\n+      jj_consume_token(INFINITY);\n+                                        {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\n+      break;\n+    default:\n+      jj_la1[12] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonInt() throws ParseException {\n+  String digits;\n+  boolean negative = false;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case 31:\n+      jj_consume_token(31);\n+         negative = true;\n+      break;\n+    default:\n+      jj_la1[13] = jj_gen;\n+      ;\n+    }\n+    digits = Digits();\n+    if(negative)\n+      {if (true) return \"-\" + digits;}\n+    {if (true) return digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonFrac() throws ParseException {\n+  String digits;\n+    jj_consume_token(32);\n+    digits = Digits();\n+    {if (true) return \".\" + digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String JsonExp() throws ParseException {\n+  Token t;\n+  String digits;\n+    t = jj_consume_token(E);\n+    digits = Digits();\n+    {if (true) return t.image + digits;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private String Digits() throws ParseException {\n+  Token t;\n+    t = jj_consume_token(DIGITS);\n+    {if (true) return t.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private JsonPrimitive JsonString() throws ParseException {\n+  Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+      t = jj_consume_token(SINGLE_QUOTE_LITERAL);\n+      break;\n+    case DOUBLE_QUOTE_LITERAL:\n+      t = jj_consume_token(DOUBLE_QUOTE_LITERAL);\n+      break;\n+    default:\n+      jj_la1[14] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    String value = StringUnmarshaller.unmarshall(t.image);\n+    {if (true) return new JsonPrimitive(value);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private boolean jj_2_1(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    try { return !jj_3_1(); }\n+    catch(LookaheadSuccess ls) { return true; }\n+    finally { jj_save(0, xla); }\n+  }\n+\n+  final private boolean jj_3R_4() {\n+    if (jj_scan_token(31)) return true;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_3() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_4()) jj_scanpos = xsp;\n+    if (jj_scan_token(INFINITY)) return true;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_1() {\n+    if (jj_3R_1()) return true;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_2() {\n+    if (jj_scan_token(NAN)) return true;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_1() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_2()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_3()) return true;\n+    }\n+    return false;\n+  }\n+\n+  public JsonParserTokenManager token_source;\n+  SimpleCharStream jj_input_stream;\n+  public Token token, jj_nt;\n+  private int jj_ntk;\n+  private Token jj_scanpos, jj_lastpos;\n+  private int jj_la;\n+  public boolean lookingAhead = false;\n+  private boolean jj_semLA;\n+  private int jj_gen;\n+  final private int[] jj_la1 = new int[15];\n+  static private int[] jj_la1_0;\n+  static private int[] jj_la1_1;\n+  static {\n+      jj_la1_0();\n+      jj_la1_1();\n+   }\n+   private static void jj_la1_0() {\n+      jj_la1_0 = new int[] {0xa20187c0,0x18800,0x8000000,0x18800,0xa20187c0,0x8000000,0xa20187c0,0x80018740,0x0,0x20,0x80000040,0x80000000,0x80000300,0x80000000,0x18000,};\n+   }\n+   private static void jj_la1_1() {\n+      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,};\n+   }\n+  final private JJCalls[] jj_2_rtns = new JJCalls[1];\n+  private boolean jj_rescan = false;\n+  private int jj_gc = 0;\n+\n+  public JsonParser(java.io.InputStream stream) {\n+     this(stream, null);\n+  }\n+  public JsonParser(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source = new JsonParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(java.io.InputStream stream) {\n+     ReInit(stream, null);\n+  }\n+  public void ReInit(java.io.InputStream stream, String encoding) {\n+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public JsonParser(java.io.Reader stream) {\n+    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n+    token_source = new JsonParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(java.io.Reader stream) {\n+    jj_input_stream.ReInit(stream, 1, 1);\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public JsonParser(JsonParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(JsonParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    jj_ntk = -1;\n+    jj_gen = 0;\n+    for (int i = 0; i < 15; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  final private Token jj_consume_token(int kind) throws ParseException {\n+    Token oldToken;\n+    if ((oldToken = token).next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    if (token.kind == kind) {\n+      jj_gen++;\n+      if (++jj_gc > 100) {\n+        jj_gc = 0;\n+        for (int i = 0; i < jj_2_rtns.length; i++) {\n+          JJCalls c = jj_2_rtns[i];\n+          while (c != null) {\n+            if (c.gen < jj_gen) c.first = null;\n+            c = c.next;\n+          }\n+        }\n+      }\n+      return token;\n+    }\n+    token = oldToken;\n+    jj_kind = kind;\n+    throw generateParseException();\n+  }\n+\n+  static private final class LookaheadSuccess extends java.lang.Error { }\n+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();\n+  final private boolean jj_scan_token(int kind) {\n+    if (jj_scanpos == jj_lastpos) {\n+      jj_la--;\n+      if (jj_scanpos.next == null) {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n+      } else {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next;\n+      }\n+    } else {\n+      jj_scanpos = jj_scanpos.next;\n+    }\n+    if (jj_rescan) {\n+      int i = 0; Token tok = token;\n+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n+      if (tok != null) jj_add_error_token(kind, i);\n+    }\n+    if (jj_scanpos.kind != kind) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;\n+    return false;\n+  }\n+\n+  final public Token getNextToken() {\n+    if (token.next != null) token = token.next;\n+    else token = token.next = token_source.getNextToken();\n+    jj_ntk = -1;\n+    jj_gen++;\n+    return token;\n+  }\n+\n+  final public Token getToken(int index) {\n+    Token t = lookingAhead ? jj_scanpos : token;\n+    for (int i = 0; i < index; i++) {\n+      if (t.next != null) t = t.next;\n+      else t = t.next = token_source.getNextToken();\n+    }\n+    return t;\n+  }\n+\n+  final private int jj_ntk() {\n+    if ((jj_nt=token.next) == null)\n+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n+    else\n+      return (jj_ntk = jj_nt.kind);\n+  }\n+\n+  private java.util.Vector jj_expentries = new java.util.Vector();\n+  private int[] jj_expentry;\n+  private int jj_kind = -1;\n+  private int[] jj_lasttokens = new int[100];\n+  private int jj_endpos;\n+\n+  private void jj_add_error_token(int kind, int pos) {\n+    if (pos >= 100) return;\n+    if (pos == jj_endpos + 1) {\n+      jj_lasttokens[jj_endpos++] = kind;\n+    } else if (jj_endpos != 0) {\n+      jj_expentry = new int[jj_endpos];\n+      for (int i = 0; i < jj_endpos; i++) {\n+        jj_expentry[i] = jj_lasttokens[i];\n+      }\n+      boolean exists = false;\n+      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {\n+        int[] oldentry = (int[])(e.nextElement());\n+        if (oldentry.length == jj_expentry.length) {\n+          exists = true;\n+          for (int i = 0; i < jj_expentry.length; i++) {\n+            if (oldentry[i] != jj_expentry[i]) {\n+              exists = false;\n+              break;\n+            }\n+          }\n+          if (exists) break;\n+        }\n+      }\n+      if (!exists) jj_expentries.addElement(jj_expentry);\n+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n+    }\n+  }\n+\n+  public ParseException generateParseException() {\n+    jj_expentries.removeAllElements();\n+    boolean[] la1tokens = new boolean[33];\n+    for (int i = 0; i < 33; i++) {\n+      la1tokens[i] = false;\n+    }\n+    if (jj_kind >= 0) {\n+      la1tokens[jj_kind] = true;\n+      jj_kind = -1;\n+    }\n+    for (int i = 0; i < 15; i++) {\n+      if (jj_la1[i] == jj_gen) {\n+        for (int j = 0; j < 32; j++) {\n+          if ((jj_la1_0[i] & (1<<j)) != 0) {\n+            la1tokens[j] = true;\n+          }\n+          if ((jj_la1_1[i] & (1<<j)) != 0) {\n+            la1tokens[32+j] = true;\n+          }\n+        }\n+      }\n+    }\n+    for (int i = 0; i < 33; i++) {\n+      if (la1tokens[i]) {\n+        jj_expentry = new int[1];\n+        jj_expentry[0] = i;\n+        jj_expentries.addElement(jj_expentry);\n+      }\n+    }\n+    jj_endpos = 0;\n+    jj_rescan_token();\n+    jj_add_error_token(0, 0);\n+    int[][] exptokseq = new int[jj_expentries.size()][];\n+    for (int i = 0; i < jj_expentries.size(); i++) {\n+      exptokseq[i] = (int[])jj_expentries.elementAt(i);\n+    }\n+    return new ParseException(token, exptokseq, tokenImage);\n+  }\n+\n+  final public void enable_tracing() {\n+  }\n+\n+  final public void disable_tracing() {\n+  }\n+\n+  final private void jj_rescan_token() {\n+    jj_rescan = true;\n+    for (int i = 0; i < 1; i++) {\n+    try {\n+      JJCalls p = jj_2_rtns[i];\n+      do {\n+        if (p.gen > jj_gen) {\n+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n+          switch (i) {\n+            case 0: jj_3_1(); break;\n+          }\n+        }\n+        p = p.next;\n+      } while (p != null);\n+      } catch(LookaheadSuccess ls) { }\n+    }\n+    jj_rescan = false;\n+  }\n+\n+  final private void jj_save(int index, int xla) {\n+    JJCalls p = jj_2_rtns[index];\n+    while (p.gen > jj_gen) {\n+      if (p.next == null) { p = p.next = new JJCalls(); break; }\n+      p = p.next;\n+    }\n+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;\n+  }\n+\n+  static final class JJCalls {\n+    int gen;\n+    Token first;\n+    int arg;\n+    JJCalls next;\n+  }\n+\n+}\n--- a/gson/src/main/java/com/google/gson/JsonParserConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserConstants.java\n-/* Generated By:JavaCC: Do not edit this line. JsonParserConstants.java */\n-package com.google.gson;\n-\n-@SuppressWarnings(\"all\")\n-interface JsonParserConstants {\n-\n-  int EOF = 0;\n-  int E = 5;\n-  int DIGITS = 6;\n-  int NULL = 7;\n-  int BOOLEAN = 8;\n-  int IDENTIFIER = 9;\n-  int HEX_CHAR = 10;\n-  int UNICODE_CHAR = 11;\n-  int ESCAPE_CHAR = 12;\n-  int SINGLE_QUOTE_LITERAL = 13;\n-  int DOUBLE_QUOTE_LITERAL = 14;\n-  int QUOTE = 15;\n-  int ENDQUOTE = 17;\n-  int CHAR = 18;\n-  int CNTRL_ESC = 19;\n-  int HEX = 21;\n-  int HEX_ESC = 22;\n-\n-  int DEFAULT = 0;\n-  int STRING_STATE = 1;\n-  int ESC_STATE = 2;\n-  int HEX_STATE = 3;\n-\n-  String[] tokenImage = {\n-    \"<EOF>\",\n-    \"\\\" \\\"\",\n-    \"\\\"\\\\t\\\"\",\n-    \"\\\"\\\\n\\\"\",\n-    \"\\\"\\\\r\\\"\",\n-    \"<E>\",\n-    \"<DIGITS>\",\n-    \"\\\"null\\\"\",\n-    \"<BOOLEAN>\",\n-    \"<IDENTIFIER>\",\n-    \"<HEX_CHAR>\",\n-    \"<UNICODE_CHAR>\",\n-    \"<ESCAPE_CHAR>\",\n-    \"<SINGLE_QUOTE_LITERAL>\",\n-    \"<DOUBLE_QUOTE_LITERAL>\",\n-    \"\\\"\\\\\\\"\\\"\",\n-    \"\\\"\\\\\\\\\\\"\",\n-    \"<ENDQUOTE>\",\n-    \"<CHAR>\",\n-    \"<CNTRL_ESC>\",\n-    \"\\\"u\\\"\",\n-    \"<HEX>\",\n-    \"<HEX_ESC>\",\n-    \"\\\"{\\\"\",\n-    \"\\\"}\\\"\",\n-    \"\\\",\\\"\",\n-    \"\\\":\\\"\",\n-    \"\\\"[\\\"\",\n-    \"\\\"]\\\"\",\n-    \"\\\"-\\\"\",\n-    \"\\\".\\\"\",\n-  };\n-\n-}\n+/* Generated By:JavaCC: Do not edit this line. JsonParserConstants.java */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+interface JsonParserConstants {\n+\n+  int EOF = 0;\n+  int E = 5;\n+  int DIGITS = 6;\n+  int NULL = 7;\n+  int NAN = 8;\n+  int INFINITY = 9;\n+  int BOOLEAN = 10;\n+  int IDENTIFIER = 11;\n+  int HEX_CHAR = 12;\n+  int UNICODE_CHAR = 13;\n+  int ESCAPE_CHAR = 14;\n+  int SINGLE_QUOTE_LITERAL = 15;\n+  int DOUBLE_QUOTE_LITERAL = 16;\n+  int QUOTE = 17;\n+  int ENDQUOTE = 19;\n+  int CHAR = 20;\n+  int CNTRL_ESC = 21;\n+  int HEX = 23;\n+  int HEX_ESC = 24;\n+\n+  int DEFAULT = 0;\n+  int STRING_STATE = 1;\n+  int ESC_STATE = 2;\n+  int HEX_STATE = 3;\n+\n+  String[] tokenImage = {\n+    \"<EOF>\",\n+    \"\\\" \\\"\",\n+    \"\\\"\\\\t\\\"\",\n+    \"\\\"\\\\n\\\"\",\n+    \"\\\"\\\\r\\\"\",\n+    \"<E>\",\n+    \"<DIGITS>\",\n+    \"\\\"null\\\"\",\n+    \"\\\"NaN\\\"\",\n+    \"\\\"Infinity\\\"\",\n+    \"<BOOLEAN>\",\n+    \"<IDENTIFIER>\",\n+    \"<HEX_CHAR>\",\n+    \"<UNICODE_CHAR>\",\n+    \"<ESCAPE_CHAR>\",\n+    \"<SINGLE_QUOTE_LITERAL>\",\n+    \"<DOUBLE_QUOTE_LITERAL>\",\n+    \"\\\"\\\\\\\"\\\"\",\n+    \"\\\"\\\\\\\\\\\"\",\n+    \"<ENDQUOTE>\",\n+    \"<CHAR>\",\n+    \"<CNTRL_ESC>\",\n+    \"\\\"u\\\"\",\n+    \"<HEX>\",\n+    \"<HEX_ESC>\",\n+    \"\\\"{\\\"\",\n+    \"\\\"}\\\"\",\n+    \"\\\",\\\"\",\n+    \"\\\":\\\"\",\n+    \"\\\"[\\\"\",\n+    \"\\\"]\\\"\",\n+    \"\\\"-\\\"\",\n+    \"\\\".\\\"\",\n+  };\n+\n+}\n--- a/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n-/* Generated By:JavaCC: Do not edit this line. JsonParserTokenManager.java */\n-package com.google.gson;\n-\n-@SuppressWarnings(\"all\")\n-final class JsonParserTokenManager implements JsonParserConstants\n-{\n-  public  java.io.PrintStream debugStream = System.out;\n-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\n-private final int jjMoveStringLiteralDfa0_3()\n-{\n-   return jjMoveNfa_3(0, 0);\n-}\n-private final void jjCheckNAdd(int state)\n-{\n-   if (jjrounds[state] != jjround)\n-   {\n-      jjstateSet[jjnewStateCnt++] = state;\n-      jjrounds[state] = jjround;\n-   }\n-}\n-private final void jjAddStates(int start, int end)\n-{\n-   do {\n-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n-   } while (start++ != end);\n-}\n-private final void jjCheckNAddTwoStates(int state1, int state2)\n-{\n-   jjCheckNAdd(state1);\n-   jjCheckNAdd(state2);\n-}\n-private final void jjCheckNAddStates(int start, int end)\n-{\n-   do {\n-      jjCheckNAdd(jjnextStates[start]);\n-   } while (start++ != end);\n-}\n-private final void jjCheckNAddStates(int start)\n-{\n-   jjCheckNAdd(jjnextStates[start]);\n-   jjCheckNAdd(jjnextStates[start + 1]);\n-}\n-private final int jjMoveNfa_3(int startState, int curPos)\n-{\n-   int[] nextStates;\n-   int startsAt = 0;\n-   jjnewStateCnt = 4;\n-   int i = 1;\n-   jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n-   for (;;)\n-   {\n-      if (++jjround == 0x7fffffff)\n-         ReInitRounds();\n-      if (curChar < 64)\n-      {\n-         long l = 1L << curChar;\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 1;\n-                  break;\n-               case 1:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 2;\n-                  break;\n-               case 2:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 3;\n-                  break;\n-               case 3:\n-                  if ((0x3ff000000000000L & l) != 0L && kind > 22)\n-                     kind = 22;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else if (curChar < 128)\n-      {\n-         long l = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 1;\n-                  break;\n-               case 1:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 2;\n-                  break;\n-               case 2:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 3;\n-                  break;\n-               case 3:\n-                  if ((0x7e0000007eL & l) != 0L && kind > 22)\n-                     kind = 22;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else\n-      {\n-         int hiByte = (int)(curChar >> 8);\n-         int i1 = hiByte >> 6;\n-         long l1 = 1L << (hiByte & 077);\n-         int i2 = (curChar & 0xff) >> 6;\n-         long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      if (kind != 0x7fffffff)\n-      {\n-         jjmatchedKind = kind;\n-         jjmatchedPos = curPos;\n-         kind = 0x7fffffff;\n-      }\n-      ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))\n-         return curPos;\n-      try { curChar = input_stream.readChar(); }\n-      catch(java.io.IOException e) { return curPos; }\n-   }\n-}\n+/* Generated By:JavaCC: Do not edit this line. JsonParserTokenManager.java */\n+package com.google.gson;\n+\n+@SuppressWarnings(\"all\")\n+final class JsonParserTokenManager implements JsonParserConstants\n+{\n+  public  java.io.PrintStream debugStream = System.out;\n+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }\n+private final int jjMoveStringLiteralDfa0_3()\n+{\n+   return jjMoveNfa_3(0, 0);\n+}\n+private final void jjCheckNAdd(int state)\n+{\n+   if (jjrounds[state] != jjround)\n+   {\n+      jjstateSet[jjnewStateCnt++] = state;\n+      jjrounds[state] = jjround;\n+   }\n+}\n+private final void jjAddStates(int start, int end)\n+{\n+   do {\n+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddTwoStates(int state1, int state2)\n+{\n+   jjCheckNAdd(state1);\n+   jjCheckNAdd(state2);\n+}\n+private final void jjCheckNAddStates(int start, int end)\n+{\n+   do {\n+      jjCheckNAdd(jjnextStates[start]);\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddStates(int start)\n+{\n+   jjCheckNAdd(jjnextStates[start]);\n+   jjCheckNAdd(jjnextStates[start + 1]);\n+}\n+private final int jjMoveNfa_3(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 4;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 24)\n+                     kind = 24;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 1:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 2;\n+                  break;\n+               case 2:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 3;\n+                  break;\n+               case 3:\n+                  if ((0x7e0000007eL & l) != 0L && kind > 24)\n+                     kind = 24;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n private final int jjStopStringLiteralDfa_0(int pos, long active0)\n-{\n+{\n    switch (pos)\n-   {\n-      case 0:\n-         if ((active0 & 0x8000L) != 0L)\n-            return 41;\n-         if ((active0 & 0x80L) != 0L)\n-         {\n-            jjmatchedKind = 9;\n-            return 12;\n-         }\n-         return -1;\n-      case 1:\n-         if ((active0 & 0x80L) != 0L)\n-         {\n-            jjmatchedKind = 9;\n-            jjmatchedPos = 1;\n-            return 12;\n-         }\n-         return -1;\n-      case 2:\n-         if ((active0 & 0x80L) != 0L)\n-         {\n-            jjmatchedKind = 9;\n-            jjmatchedPos = 2;\n-            return 12;\n-         }\n-         return -1;\n-      default :\n-         return -1;\n-   }\n-}\n+   {\n+      case 0:\n+         if ((active0 & 0x380L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            return 12;\n+         }\n+         if ((active0 & 0x20000L) != 0L)\n+            return 41;\n+         return -1;\n+      case 1:\n+         if ((active0 & 0x380L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 1;\n+            return 12;\n+         }\n+         return -1;\n+      case 2:\n+         if ((active0 & 0x100L) != 0L)\n+            return 12;\n+         if ((active0 & 0x280L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 2;\n+            return 12;\n+         }\n+         return -1;\n+      case 3:\n+         if ((active0 & 0x80L) != 0L)\n+            return 12;\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 3;\n+            return 12;\n+         }\n+         return -1;\n+      case 4:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 4;\n+            return 12;\n+         }\n+         return -1;\n+      case 5:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 5;\n+            return 12;\n+         }\n+         return -1;\n+      case 6:\n+         if ((active0 & 0x200L) != 0L)\n+         {\n+            jjmatchedKind = 11;\n+            jjmatchedPos = 6;\n+            return 12;\n+         }\n+         return -1;\n+      default :\n+         return -1;\n+   }\n+}\n private final int jjStartNfa_0(int pos, long active0)\n-{\n-   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);\n-}\n-private final int jjStopAtPos(int pos, int kind)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   return pos + 1;\n-}\n-private final int jjStartNfaWithStates_0(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_0(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_0()\n-{\n-   switch(curChar)\n-   {\n-      case 34:\n-         return jjStartNfaWithStates_0(0, 15, 41);\n-      case 44:\n-         return jjStopAtPos(0, 25);\n-      case 45:\n-         return jjStopAtPos(0, 29);\n-      case 46:\n-         return jjStopAtPos(0, 30);\n-      case 58:\n-         return jjStopAtPos(0, 26);\n-      case 91:\n-         return jjStopAtPos(0, 27);\n-      case 93:\n-         return jjStopAtPos(0, 28);\n-      case 110:\n-         return jjMoveStringLiteralDfa1_0(0x80L);\n-      case 123:\n-         return jjStopAtPos(0, 23);\n-      case 125:\n-         return jjStopAtPos(0, 24);\n-      default :\n-         return jjMoveNfa_0(0, 0);\n-   }\n-}\n-private final int jjMoveStringLiteralDfa1_0(long active0)\n-{\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) {\n-      jjStopStringLiteralDfa_0(0, active0);\n-      return 1;\n-   }\n-   switch(curChar)\n-   {\n-      case 117:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x80L);\n-      default :\n-         break;\n-   }\n-   return jjStartNfa_0(0, active0);\n-}\n-private final int jjMoveStringLiteralDfa2_0(long old0, long active0)\n-{\n-   if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(0, old0); \n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) {\n-      jjStopStringLiteralDfa_0(1, active0);\n-      return 2;\n-   }\n-   switch(curChar)\n-   {\n-      case 108:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x80L);\n-      default :\n-         break;\n-   }\n-   return jjStartNfa_0(1, active0);\n-}\n-private final int jjMoveStringLiteralDfa3_0(long old0, long active0)\n-{\n-   if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(1, old0); \n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) {\n-      jjStopStringLiteralDfa_0(2, active0);\n-      return 3;\n-   }\n-   switch(curChar)\n-   {\n-      case 108:\n-         if ((active0 & 0x80L) != 0L)\n-            return jjStartNfaWithStates_0(3, 7, 12);\n-         break;\n-      default :\n-         break;\n-   }\n-   return jjStartNfa_0(2, active0);\n-}\n+{\n+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);\n+}\n+private final int jjStopAtPos(int pos, int kind)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   return pos + 1;\n+}\n+private final int jjStartNfaWithStates_0(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_0(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_0()\n+{\n+   switch(curChar)\n+   {\n+      case 34:\n+         return jjStartNfaWithStates_0(0, 17, 41);\n+      case 44:\n+         return jjStopAtPos(0, 27);\n+      case 45:\n+         return jjStopAtPos(0, 31);\n+      case 46:\n+         return jjStopAtPos(0, 32);\n+      case 58:\n+         return jjStopAtPos(0, 28);\n+      case 73:\n+         return jjMoveStringLiteralDfa1_0(0x200L);\n+      case 78:\n+         return jjMoveStringLiteralDfa1_0(0x100L);\n+      case 91:\n+         return jjStopAtPos(0, 29);\n+      case 93:\n+         return jjStopAtPos(0, 30);\n+      case 110:\n+         return jjMoveStringLiteralDfa1_0(0x80L);\n+      case 123:\n+         return jjStopAtPos(0, 25);\n+      case 125:\n+         return jjStopAtPos(0, 26);\n+      default :\n+         return jjMoveNfa_0(0, 0);\n+   }\n+}\n+private final int jjMoveStringLiteralDfa1_0(long active0)\n+{\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(0, active0);\n+      return 1;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x100L);\n+      case 110:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x200L);\n+      case 117:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x80L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(0, active0);\n+}\n+private final int jjMoveStringLiteralDfa2_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(0, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(1, active0);\n+      return 2;\n+   }\n+   switch(curChar)\n+   {\n+      case 78:\n+         if ((active0 & 0x100L) != 0L)\n+            return jjStartNfaWithStates_0(2, 8, 12);\n+         break;\n+      case 102:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x200L);\n+      case 108:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x80L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(1, active0);\n+}\n+private final int jjMoveStringLiteralDfa3_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(1, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(2, active0);\n+      return 3;\n+   }\n+   switch(curChar)\n+   {\n+      case 105:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x200L);\n+      case 108:\n+         if ((active0 & 0x80L) != 0L)\n+            return jjStartNfaWithStates_0(3, 7, 12);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(2, active0);\n+}\n+private final int jjMoveStringLiteralDfa4_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(2, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(3, active0);\n+      return 4;\n+   }\n+   switch(curChar)\n+   {\n+      case 110:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(3, active0);\n+}\n+private final int jjMoveStringLiteralDfa5_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(3, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(4, active0);\n+      return 5;\n+   }\n+   switch(curChar)\n+   {\n+      case 105:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(4, active0);\n+}\n+private final int jjMoveStringLiteralDfa6_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(4, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(5, active0);\n+      return 6;\n+   }\n+   switch(curChar)\n+   {\n+      case 116:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x200L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(5, active0);\n+}\n+private final int jjMoveStringLiteralDfa7_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(5, old0); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(6, active0);\n+      return 7;\n+   }\n+   switch(curChar)\n+   {\n+      case 121:\n+         if ((active0 & 0x200L) != 0L)\n+            return jjStartNfaWithStates_0(7, 9, 12);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(6, active0);\n+}\n static final long[] jjbitVec0 = {\n    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n-};\n+};\n static final long[] jjbitVec2 = {\n    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n-};\n-private final int jjMoveNfa_0(int startState, int curPos)\n-{\n-   int[] nextStates;\n-   int startsAt = 0;\n-   jjnewStateCnt = 41;\n-   int i = 1;\n-   jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n-   for (;;)\n-   {\n-      if (++jjround == 0x7fffffff)\n-         ReInitRounds();\n-      if (curChar < 64)\n-      {\n-         long l = 1L << curChar;\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 41:\n-                  if ((0xfffffffbffffdbffL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  else if (curChar == 34)\n-                  {\n-                     if (kind > 14)\n-                        kind = 14;\n-                  }\n-                  break;\n-               case 0:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                  {\n-                     if (kind > 6)\n-                        kind = 6;\n-                     jjCheckNAdd(2);\n-                  }\n-                  else if (curChar == 34)\n-                     jjCheckNAddStates(0, 3);\n-                  else if (curChar == 39)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 1:\n-                  if ((0x280000000000L & l) != 0L && kind > 5)\n-                     kind = 5;\n-                  break;\n-               case 2:\n-                  if ((0x3ff000000000000L & l) == 0L)\n-                     break;\n-                  if (kind > 6)\n-                     kind = 6;\n-                  jjCheckNAdd(2);\n-                  break;\n-               case 12:\n-                  if ((0x3ff000000000000L & l) == 0L)\n-                     break;\n-                  if (kind > 9)\n-                     kind = 9;\n-                  jjstateSet[jjnewStateCnt++] = 12;\n-                  break;\n-               case 14:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 15;\n-                  break;\n-               case 15:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 16;\n-                  break;\n-               case 16:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 17;\n-                  break;\n-               case 17:\n-                  if ((0x3ff000000000000L & l) != 0L && kind > 11)\n-                     kind = 11;\n-                  break;\n-               case 19:\n-                  if (curChar == 39)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 20:\n-                  if ((0xffffff7fffffdbffL & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 22:\n-                  if ((0x808400000000L & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 24:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 25;\n-                  break;\n-               case 25:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 26;\n-                  break;\n-               case 26:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 27;\n-                  break;\n-               case 27:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 29:\n-                  if (curChar == 39 && kind > 13)\n-                     kind = 13;\n-                  break;\n-               case 30:\n-                  if (curChar == 34)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 31:\n-                  if ((0xfffffffbffffdbffL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 33:\n-                  if ((0x808400000000L & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 35:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 36;\n-                  break;\n-               case 36:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 37;\n-                  break;\n-               case 37:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 38;\n-                  break;\n-               case 38:\n-                  if ((0x3ff000000000000L & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 40:\n-                  if (curChar == 34 && kind > 14)\n-                     kind = 14;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else if (curChar < 128)\n-      {\n-         long l = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 41:\n-                  if ((0xffffffffefffffffL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  else if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 34;\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 33;\n-                  break;\n-               case 0:\n-                  if ((0x7fffffe87fffffeL & l) != 0L)\n-                  {\n-                     if (kind > 9)\n-                        kind = 9;\n-                     jjCheckNAdd(12);\n-                  }\n-                  else if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 13;\n-                  if ((0x2000000020L & l) != 0L)\n-                  {\n-                     if (kind > 5)\n-                        kind = 5;\n-                     jjstateSet[jjnewStateCnt++] = 1;\n-                  }\n-                  else if (curChar == 102)\n-                     jjstateSet[jjnewStateCnt++] = 9;\n-                  else if (curChar == 116)\n-                     jjstateSet[jjnewStateCnt++] = 5;\n-                  break;\n-               case 3:\n-                  if (curChar == 101 && kind > 8)\n-                     kind = 8;\n-                  break;\n-               case 4:\n-                  if (curChar == 117)\n-                     jjCheckNAdd(3);\n-                  break;\n-               case 5:\n-                  if (curChar == 114)\n-                     jjstateSet[jjnewStateCnt++] = 4;\n-                  break;\n-               case 6:\n-                  if (curChar == 116)\n-                     jjstateSet[jjnewStateCnt++] = 5;\n-                  break;\n-               case 7:\n-                  if (curChar == 115)\n-                     jjCheckNAdd(3);\n-                  break;\n-               case 8:\n-                  if (curChar == 108)\n-                     jjstateSet[jjnewStateCnt++] = 7;\n-                  break;\n-               case 9:\n-                  if (curChar == 97)\n-                     jjstateSet[jjnewStateCnt++] = 8;\n-                  break;\n-               case 10:\n-                  if (curChar == 102)\n-                     jjstateSet[jjnewStateCnt++] = 9;\n-                  break;\n-               case 11:\n-               case 12:\n-                  if ((0x7fffffe87fffffeL & l) == 0L)\n-                     break;\n-                  if (kind > 9)\n-                     kind = 9;\n-                  jjCheckNAdd(12);\n-                  break;\n-               case 13:\n-                  if (curChar == 117)\n-                     jjstateSet[jjnewStateCnt++] = 14;\n-                  break;\n-               case 14:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 15;\n-                  break;\n-               case 15:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 16;\n-                  break;\n-               case 16:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 17;\n-                  break;\n-               case 17:\n-                  if ((0x7e0000007eL & l) != 0L && kind > 11)\n-                     kind = 11;\n-                  break;\n-               case 18:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 13;\n-                  break;\n-               case 20:\n-                  if ((0xffffffffefffffffL & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 21:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 22;\n-                  break;\n-               case 22:\n-                  if ((0x14404410000000L & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 23:\n-                  if (curChar == 117)\n-                     jjstateSet[jjnewStateCnt++] = 24;\n-                  break;\n-               case 24:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 25;\n-                  break;\n-               case 25:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 26;\n-                  break;\n-               case 26:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 27;\n-                  break;\n-               case 27:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjCheckNAddStates(4, 7);\n-                  break;\n-               case 28:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 23;\n-                  break;\n-               case 31:\n-                  if ((0xffffffffefffffffL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 32:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 33;\n-                  break;\n-               case 33:\n-                  if ((0x14404410000000L & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 34:\n-                  if (curChar == 117)\n-                     jjstateSet[jjnewStateCnt++] = 35;\n-                  break;\n-               case 35:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 36;\n-                  break;\n-               case 36:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 37;\n-                  break;\n-               case 37:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjstateSet[jjnewStateCnt++] = 38;\n-                  break;\n-               case 38:\n-                  if ((0x7e0000007eL & l) != 0L)\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 39:\n-                  if (curChar == 92)\n-                     jjstateSet[jjnewStateCnt++] = 34;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else\n-      {\n-         int hiByte = (int)(curChar >> 8);\n-         int i1 = hiByte >> 6;\n-         long l1 = 1L << (hiByte & 077);\n-         int i2 = (curChar & 0xff) >> 6;\n-         long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 41:\n-               case 31:\n-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n-                     jjCheckNAddStates(0, 3);\n-                  break;\n-               case 20:\n-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n-                     jjAddStates(4, 7);\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      if (kind != 0x7fffffff)\n-      {\n-         jjmatchedKind = kind;\n-         jjmatchedPos = curPos;\n-         kind = 0x7fffffff;\n-      }\n-      ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 41 - (jjnewStateCnt = startsAt)))\n-         return curPos;\n-      try { curChar = input_stream.readChar(); }\n-      catch(java.io.IOException e) { return curPos; }\n-   }\n-}\n+};\n+private final int jjMoveNfa_0(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 41;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 41:\n+                  if ((0xfffffffbffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 34)\n+                  {\n+                     if (kind > 16)\n+                        kind = 16;\n+                  }\n+                  break;\n+               case 0:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                  {\n+                     if (kind > 6)\n+                        kind = 6;\n+                     jjCheckNAdd(2);\n+                  }\n+                  else if (curChar == 34)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 39)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 1:\n+                  if ((0x280000000000L & l) != 0L && kind > 5)\n+                     kind = 5;\n+                  break;\n+               case 2:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 6)\n+                     kind = 6;\n+                  jjCheckNAdd(2);\n+                  break;\n+               case 12:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjstateSet[jjnewStateCnt++] = 12;\n+                  break;\n+               case 14:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 15;\n+                  break;\n+               case 15:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 16;\n+                  break;\n+               case 16:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 17;\n+                  break;\n+               case 17:\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 13)\n+                     kind = 13;\n+                  break;\n+               case 19:\n+                  if (curChar == 39)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 20:\n+                  if ((0xffffff7fffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 22:\n+                  if ((0x808400000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 24:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 25;\n+                  break;\n+               case 25:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 26;\n+                  break;\n+               case 26:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 27;\n+                  break;\n+               case 27:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 29:\n+                  if (curChar == 39 && kind > 15)\n+                     kind = 15;\n+                  break;\n+               case 30:\n+                  if (curChar == 34)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 31:\n+                  if ((0xfffffffbffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 33:\n+                  if ((0x808400000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 35:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 36;\n+                  break;\n+               case 36:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 37;\n+                  break;\n+               case 37:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 38;\n+                  break;\n+               case 38:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 40:\n+                  if (curChar == 34 && kind > 16)\n+                     kind = 16;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 41:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  else if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 33;\n+                  break;\n+               case 0:\n+                  if ((0x7fffffe87fffffeL & l) != 0L)\n+                  {\n+                     if (kind > 11)\n+                        kind = 11;\n+                     jjCheckNAdd(12);\n+                  }\n+                  else if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n+                  if ((0x2000000020L & l) != 0L)\n+                  {\n+                     if (kind > 5)\n+                        kind = 5;\n+                     jjstateSet[jjnewStateCnt++] = 1;\n+                  }\n+                  else if (curChar == 102)\n+                     jjstateSet[jjnewStateCnt++] = 9;\n+                  else if (curChar == 116)\n+                     jjstateSet[jjnewStateCnt++] = 5;\n+                  break;\n+               case 3:\n+                  if (curChar == 101 && kind > 10)\n+                     kind = 10;\n+                  break;\n+               case 4:\n+                  if (curChar == 117)\n+                     jjCheckNAdd(3);\n+                  break;\n+               case 5:\n+                  if (curChar == 114)\n+                     jjstateSet[jjnewStateCnt++] = 4;\n+                  break;\n+               case 6:\n+                  if (curChar == 116)\n+                     jjstateSet[jjnewStateCnt++] = 5;\n+                  break;\n+               case 7:\n+                  if (curChar == 115)\n+                     jjCheckNAdd(3);\n+                  break;\n+               case 8:\n+                  if (curChar == 108)\n+                     jjstateSet[jjnewStateCnt++] = 7;\n+                  break;\n+               case 9:\n+                  if (curChar == 97)\n+                     jjstateSet[jjnewStateCnt++] = 8;\n+                  break;\n+               case 10:\n+                  if (curChar == 102)\n+                     jjstateSet[jjnewStateCnt++] = 9;\n+                  break;\n+               case 11:\n+               case 12:\n+                  if ((0x7fffffe87fffffeL & l) == 0L)\n+                     break;\n+                  if (kind > 11)\n+                     kind = 11;\n+                  jjCheckNAdd(12);\n+                  break;\n+               case 13:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 14;\n+                  break;\n+               case 14:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 15;\n+                  break;\n+               case 15:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 16;\n+                  break;\n+               case 16:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 17;\n+                  break;\n+               case 17:\n+                  if ((0x7e0000007eL & l) != 0L && kind > 13)\n+                     kind = 13;\n+                  break;\n+               case 18:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 13;\n+                  break;\n+               case 20:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 21:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 22;\n+                  break;\n+               case 22:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 23:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 24;\n+                  break;\n+               case 24:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 25;\n+                  break;\n+               case 25:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 26;\n+                  break;\n+               case 26:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 27;\n+                  break;\n+               case 27:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjCheckNAddStates(4, 7);\n+                  break;\n+               case 28:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 23;\n+                  break;\n+               case 31:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 32:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 33;\n+                  break;\n+               case 33:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 34:\n+                  if (curChar == 117)\n+                     jjstateSet[jjnewStateCnt++] = 35;\n+                  break;\n+               case 35:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 36;\n+                  break;\n+               case 36:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 37;\n+                  break;\n+               case 37:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjstateSet[jjnewStateCnt++] = 38;\n+                  break;\n+               case 38:\n+                  if ((0x7e0000007eL & l) != 0L)\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 39:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 34;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 41:\n+               case 31:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjCheckNAddStates(0, 3);\n+                  break;\n+               case 20:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjAddStates(4, 7);\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 41 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n private final int jjStopStringLiteralDfa_2(int pos, long active0)\n-{\n+{\n    switch (pos)\n-   {\n-      default :\n-         return -1;\n-   }\n-}\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n private final int jjStartNfa_2(int pos, long active0)\n-{\n-   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);\n-}\n-private final int jjStartNfaWithStates_2(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_2(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_2()\n-{\n-   switch(curChar)\n-   {\n-      case 117:\n-         return jjStopAtPos(0, 20);\n-      default :\n-         return jjMoveNfa_2(0, 0);\n-   }\n-}\n-private final int jjMoveNfa_2(int startState, int curPos)\n-{\n-   int[] nextStates;\n-   int startsAt = 0;\n-   jjnewStateCnt = 1;\n-   int i = 1;\n-   jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n-   for (;;)\n-   {\n-      if (++jjround == 0x7fffffff)\n-         ReInitRounds();\n-      if (curChar < 64)\n-      {\n-         long l = 1L << curChar;\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0x800400000000L & l) != 0L)\n-                     kind = 19;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else if (curChar < 128)\n-      {\n-         long l = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0x14404410000000L & l) != 0L)\n-                     kind = 19;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else\n-      {\n-         int hiByte = (int)(curChar >> 8);\n-         int i1 = hiByte >> 6;\n-         long l1 = 1L << (hiByte & 077);\n-         int i2 = (curChar & 0xff) >> 6;\n-         long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      if (kind != 0x7fffffff)\n-      {\n-         jjmatchedKind = kind;\n-         jjmatchedPos = curPos;\n-         kind = 0x7fffffff;\n-      }\n-      ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))\n-         return curPos;\n-      try { curChar = input_stream.readChar(); }\n-      catch(java.io.IOException e) { return curPos; }\n-   }\n-}\n+{\n+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);\n+}\n+private final int jjStartNfaWithStates_2(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_2(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_2()\n+{\n+   switch(curChar)\n+   {\n+      case 117:\n+         return jjStopAtPos(0, 22);\n+      default :\n+         return jjMoveNfa_2(0, 0);\n+   }\n+}\n+private final int jjMoveNfa_2(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 1;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x800400000000L & l) != 0L)\n+                     kind = 21;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     kind = 21;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n private final int jjStopStringLiteralDfa_1(int pos, long active0)\n-{\n+{\n    switch (pos)\n-   {\n-      default :\n-         return -1;\n-   }\n-}\n+   {\n+      default :\n+         return -1;\n+   }\n+}\n private final int jjStartNfa_1(int pos, long active0)\n-{\n-   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);\n-}\n-private final int jjStartNfaWithStates_1(int pos, int kind, int state)\n-{\n-   jjmatchedKind = kind;\n-   jjmatchedPos = pos;\n-   try { curChar = input_stream.readChar(); }\n-   catch(java.io.IOException e) { return pos + 1; }\n-   return jjMoveNfa_1(state, pos + 1);\n-}\n-private final int jjMoveStringLiteralDfa0_1()\n-{\n-   switch(curChar)\n-   {\n-      case 92:\n-         return jjStopAtPos(0, 16);\n-      default :\n-         return jjMoveNfa_1(0, 0);\n-   }\n-}\n-private final int jjMoveNfa_1(int startState, int curPos)\n-{\n-   int[] nextStates;\n-   int startsAt = 0;\n-   jjnewStateCnt = 2;\n-   int i = 1;\n-   jjstateSet[0] = startState;\n-   int j, kind = 0x7fffffff;\n-   for (;;)\n-   {\n-      if (++jjround == 0x7fffffff)\n-         ReInitRounds();\n-      if (curChar < 64)\n-      {\n-         long l = 1L << curChar;\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0xfffffffbffffffffL & l) != 0L)\n-                  {\n-                     if (kind > 18)\n-                        kind = 18;\n-                  }\n-                  else if (curChar == 34)\n-                  {\n-                     if (kind > 17)\n-                        kind = 17;\n-                  }\n-                  break;\n-               case 1:\n-                  if ((0xfffffffbffffffffL & l) != 0L)\n-                     kind = 18;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else if (curChar < 128)\n-      {\n-         long l = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if ((0xffffffffefffffffL & l) != 0L)\n-                     kind = 18;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      else\n-      {\n-         int hiByte = (int)(curChar >> 8);\n-         int i1 = hiByte >> 6;\n-         long l1 = 1L << (hiByte & 077);\n-         int i2 = (curChar & 0xff) >> 6;\n-         long l2 = 1L << (curChar & 077);\n-         MatchLoop: do\n-         {\n-            switch(jjstateSet[--i])\n-            {\n-               case 0:\n-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 18)\n-                     kind = 18;\n-                  break;\n-               default : break;\n-            }\n-         } while(i != startsAt);\n-      }\n-      if (kind != 0x7fffffff)\n-      {\n-         jjmatchedKind = kind;\n-         jjmatchedPos = curPos;\n-         kind = 0x7fffffff;\n-      }\n-      ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))\n-         return curPos;\n-      try { curChar = input_stream.readChar(); }\n-      catch(java.io.IOException e) { return curPos; }\n-   }\n-}\n+{\n+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);\n+}\n+private final int jjStartNfaWithStates_1(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_1(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_1()\n+{\n+   switch(curChar)\n+   {\n+      case 92:\n+         return jjStopAtPos(0, 18);\n+      default :\n+         return jjMoveNfa_1(0, 0);\n+   }\n+}\n+private final int jjMoveNfa_1(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 2;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                  {\n+                     if (kind > 20)\n+                        kind = 20;\n+                  }\n+                  else if (curChar == 34)\n+                  {\n+                     if (kind > 19)\n+                        kind = 19;\n+                  }\n+                  break;\n+               case 1:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                     kind = 20;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     kind = 20;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 0:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 20)\n+                     kind = 20;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 2 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n static final int[] jjnextStates = {\n    31, 32, 39, 40, 20, 21, 28, 29, \n-};\n-private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n-{\n-   switch(hiByte)\n-   {\n-      case 0:\n-         return ((jjbitVec2[i2] & l2) != 0L);\n-      default : \n-         if ((jjbitVec0[i1] & l1) != 0L)\n-            return true;\n-         return false;\n-   }\n-}\n-public static final String[] jjstrLiteralImages = {\n-\"\", null, null, null, null, null, null, \"\\156\\165\\154\\154\", null, null, null, \n-null, null, null, null, \"\\42\", null, null, null, null, null, null, null, \"\\173\", \n-\"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n-public static final String[] lexStateNames = {\n-   \"DEFAULT\", \n-   \"STRING_STATE\", \n-   \"ESC_STATE\", \n-   \"HEX_STATE\", \n-};\n+};\n+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec2[i2] & l2) != 0L);\n+      default : \n+         if ((jjbitVec0[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+public static final String[] jjstrLiteralImages = {\n+\"\", null, null, null, null, null, null, \"\\156\\165\\154\\154\", \"\\116\\141\\116\", \n+\"\\111\\156\\146\\151\\156\\151\\164\\171\", null, null, null, null, null, null, null, \"\\42\", null, null, null, null, null, \n+null, null, \"\\173\", \"\\175\", \"\\54\", \"\\72\", \"\\133\", \"\\135\", \"\\55\", \"\\56\", };\n+public static final String[] lexStateNames = {\n+   \"DEFAULT\", \n+   \"STRING_STATE\", \n+   \"ESC_STATE\", \n+   \"HEX_STATE\", \n+};\n public static final int[] jjnewLexState = {\n-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, -1, -1, \n-   -1, -1, -1, -1, -1, -1, \n-};\n+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, \n+   -1, -1, -1, -1, -1, -1, -1, -1, \n+};\n static final long[] jjtoToken = {\n-   0x7fceebe1L, \n-};\n+   0x1ff3bafe1L, \n+};\n static final long[] jjtoSkip = {\n    0x1eL, \n-};\n+};\n static final long[] jjtoMore = {\n-   0x110000L, \n-};\n-protected SimpleCharStream input_stream;\n-private final int[] jjrounds = new int[41];\n-private final int[] jjstateSet = new int[82];\n-protected char curChar;\n-public JsonParserTokenManager(SimpleCharStream stream){\n-   if (SimpleCharStream.staticFlag)\n-      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n-   input_stream = stream;\n-}\n-public JsonParserTokenManager(SimpleCharStream stream, int lexState){\n-   this(stream);\n-   SwitchTo(lexState);\n-}\n-public void ReInit(SimpleCharStream stream)\n-{\n-   jjmatchedPos = jjnewStateCnt = 0;\n-   curLexState = defaultLexState;\n-   input_stream = stream;\n-   ReInitRounds();\n-}\n-private final void ReInitRounds()\n-{\n-   int i;\n-   jjround = 0x80000001;\n-   for (i = 41; i-- > 0;)\n-      jjrounds[i] = 0x80000000;\n-}\n-public void ReInit(SimpleCharStream stream, int lexState)\n-{\n-   ReInit(stream);\n-   SwitchTo(lexState);\n-}\n-public void SwitchTo(int lexState)\n-{\n-   if (lexState >= 4 || lexState < 0)\n-      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n-   else\n-      curLexState = lexState;\n-}\n-\n-protected Token jjFillToken()\n-{\n-   Token t = Token.newToken(jjmatchedKind);\n-   t.kind = jjmatchedKind;\n-   String im = jjstrLiteralImages[jjmatchedKind];\n-   t.image = (im == null) ? input_stream.GetImage() : im;\n-   t.beginLine = input_stream.getBeginLine();\n-   t.beginColumn = input_stream.getBeginColumn();\n-   t.endLine = input_stream.getEndLine();\n-   t.endColumn = input_stream.getEndColumn();\n-   return t;\n-}\n-\n-int curLexState = 0;\n-int defaultLexState = 0;\n-int jjnewStateCnt;\n-int jjround;\n-int jjmatchedPos;\n-int jjmatchedKind;\n-\n-public Token getNextToken() \n-{\n-  int kind;\n-  Token specialToken = null;\n-  Token matchedToken;\n-  int curPos = 0;\n-\n+   0x440000L, \n+};\n+protected SimpleCharStream input_stream;\n+private final int[] jjrounds = new int[41];\n+private final int[] jjstateSet = new int[82];\n+protected char curChar;\n+public JsonParserTokenManager(SimpleCharStream stream){\n+   if (SimpleCharStream.staticFlag)\n+      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n+   input_stream = stream;\n+}\n+public JsonParserTokenManager(SimpleCharStream stream, int lexState){\n+   this(stream);\n+   SwitchTo(lexState);\n+}\n+public void ReInit(SimpleCharStream stream)\n+{\n+   jjmatchedPos = jjnewStateCnt = 0;\n+   curLexState = defaultLexState;\n+   input_stream = stream;\n+   ReInitRounds();\n+}\n+private final void ReInitRounds()\n+{\n+   int i;\n+   jjround = 0x80000001;\n+   for (i = 41; i-- > 0;)\n+      jjrounds[i] = 0x80000000;\n+}\n+public void ReInit(SimpleCharStream stream, int lexState)\n+{\n+   ReInit(stream);\n+   SwitchTo(lexState);\n+}\n+public void SwitchTo(int lexState)\n+{\n+   if (lexState >= 4 || lexState < 0)\n+      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n+   else\n+      curLexState = lexState;\n+}\n+\n+protected Token jjFillToken()\n+{\n+   Token t = Token.newToken(jjmatchedKind);\n+   t.kind = jjmatchedKind;\n+   String im = jjstrLiteralImages[jjmatchedKind];\n+   t.image = (im == null) ? input_stream.GetImage() : im;\n+   t.beginLine = input_stream.getBeginLine();\n+   t.beginColumn = input_stream.getBeginColumn();\n+   t.endLine = input_stream.getEndLine();\n+   t.endColumn = input_stream.getEndColumn();\n+   return t;\n+}\n+\n+int curLexState = 0;\n+int defaultLexState = 0;\n+int jjnewStateCnt;\n+int jjround;\n+int jjmatchedPos;\n+int jjmatchedKind;\n+\n+public Token getNextToken() \n+{\n+  int kind;\n+  Token specialToken = null;\n+  Token matchedToken;\n+  int curPos = 0;\n+\n   EOFLoop :\n-  for (;;)\n-  {   \n-   try   \n-   {     \n-      curChar = input_stream.BeginToken();\n-   }     \n-   catch(java.io.IOException e)\n-   {        \n-      jjmatchedKind = 0;\n-      matchedToken = jjFillToken();\n-      return matchedToken;\n-   }\n-\n-   for (;;)\n-   {\n-     switch(curLexState)\n-     {\n-       case 0:\n-         try { input_stream.backup(0);\n-            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)\n-               curChar = input_stream.BeginToken();\n-         }\n-         catch (java.io.IOException e1) { continue EOFLoop; }\n-         jjmatchedKind = 0x7fffffff;\n-         jjmatchedPos = 0;\n-         curPos = jjMoveStringLiteralDfa0_0();\n-         break;\n-       case 1:\n-         jjmatchedKind = 0x7fffffff;\n-         jjmatchedPos = 0;\n-         curPos = jjMoveStringLiteralDfa0_1();\n-         break;\n-       case 2:\n-         jjmatchedKind = 0x7fffffff;\n-         jjmatchedPos = 0;\n-         curPos = jjMoveStringLiteralDfa0_2();\n-         break;\n-       case 3:\n-         jjmatchedKind = 0x7fffffff;\n-         jjmatchedPos = 0;\n-         curPos = jjMoveStringLiteralDfa0_3();\n-         break;\n-     }\n-     if (jjmatchedKind != 0x7fffffff)\n-     {\n-        if (jjmatchedPos + 1 < curPos)\n-           input_stream.backup(curPos - jjmatchedPos - 1);\n-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n-        {\n-           matchedToken = jjFillToken();\n-       if (jjnewLexState[jjmatchedKind] != -1)\n-         curLexState = jjnewLexState[jjmatchedKind];\n-           return matchedToken;\n-        }\n-        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n-        {\n-         if (jjnewLexState[jjmatchedKind] != -1)\n-           curLexState = jjnewLexState[jjmatchedKind];\n-           continue EOFLoop;\n-        }\n-      if (jjnewLexState[jjmatchedKind] != -1)\n-        curLexState = jjnewLexState[jjmatchedKind];\n-        curPos = 0;\n-        jjmatchedKind = 0x7fffffff;\n-        try {\n-           curChar = input_stream.readChar();\n-           continue;\n-        }\n-        catch (java.io.IOException e1) { }\n-     }\n-     int error_line = input_stream.getEndLine();\n-     int error_column = input_stream.getEndColumn();\n-     String error_after = null;\n-     boolean EOFSeen = false;\n-     try { input_stream.readChar(); input_stream.backup(1); }\n-     catch (java.io.IOException e1) {\n-        EOFSeen = true;\n-        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n-        if (curChar == '\\n' || curChar == '\\r') {\n-           error_line++;\n-           error_column = 0;\n-        }\n-        else\n-           error_column++;\n-     }\n-     if (!EOFSeen) {\n-        input_stream.backup(1);\n-        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n-     }\n-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n-   }\n-  }\n-}\n-\n-}\n+  for (;;)\n+  {   \n+   try   \n+   {     \n+      curChar = input_stream.BeginToken();\n+   }     \n+   catch(java.io.IOException e)\n+   {        \n+      jjmatchedKind = 0;\n+      matchedToken = jjFillToken();\n+      return matchedToken;\n+   }\n+\n+   for (;;)\n+   {\n+     switch(curLexState)\n+     {\n+       case 0:\n+         try { input_stream.backup(0);\n+            while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)\n+               curChar = input_stream.BeginToken();\n+         }\n+         catch (java.io.IOException e1) { continue EOFLoop; }\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_0();\n+         break;\n+       case 1:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_1();\n+         break;\n+       case 2:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_2();\n+         break;\n+       case 3:\n+         jjmatchedKind = 0x7fffffff;\n+         jjmatchedPos = 0;\n+         curPos = jjMoveStringLiteralDfa0_3();\n+         break;\n+     }\n+     if (jjmatchedKind != 0x7fffffff)\n+     {\n+        if (jjmatchedPos + 1 < curPos)\n+           input_stream.backup(curPos - jjmatchedPos - 1);\n+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+           matchedToken = jjFillToken();\n+       if (jjnewLexState[jjmatchedKind] != -1)\n+         curLexState = jjnewLexState[jjmatchedKind];\n+           return matchedToken;\n+        }\n+        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+        {\n+         if (jjnewLexState[jjmatchedKind] != -1)\n+           curLexState = jjnewLexState[jjmatchedKind];\n+           continue EOFLoop;\n+        }\n+      if (jjnewLexState[jjmatchedKind] != -1)\n+        curLexState = jjnewLexState[jjmatchedKind];\n+        curPos = 0;\n+        jjmatchedKind = 0x7fffffff;\n+        try {\n+           curChar = input_stream.readChar();\n+           continue;\n+        }\n+        catch (java.io.IOException e1) { }\n+     }\n+     int error_line = input_stream.getEndLine();\n+     int error_column = input_stream.getEndColumn();\n+     String error_after = null;\n+     boolean EOFSeen = false;\n+     try { input_stream.readChar(); input_stream.backup(1); }\n+     catch (java.io.IOException e1) {\n+        EOFSeen = true;\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+        if (curChar == '\\n' || curChar == '\\r') {\n+           error_line++;\n+           error_column = 0;\n+        }\n+        else\n+           error_column++;\n+     }\n+     if (!EOFSeen) {\n+        input_stream.backup(1);\n+        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+     }\n+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n+   }\n+  }\n+}\n+\n+}\n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n   }\n   \n   public void testDoubleNaNDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"NaN\", Double.class);\n-      gson.fromJson(\"NaN\", double.class);\n-      fail(\"Gson should not accept NaN for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Double.isNaN(gson.fromJson(\"NaN\", Double.class)));\n+    assertTrue(Double.isNaN(gson.fromJson(\"NaN\", double.class)));\n   }\n   public void testFloatNaNSerializationNotSupported() {\n     float nan = (float) Float.NaN;\n   }\n   \n   public void testFloatNaNDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"NaN\", Float.class);\n-      gson.fromJson(\"NaN\", float.class);\n-      fail(\"Gson should not accept NaN for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Float.isNaN(gson.fromJson(\"NaN\", Float.class)));\n+    assertTrue(Float.isNaN(gson.fromJson(\"NaN\", float.class)));\n   }\n \n   public void testBigDecimalNaNDeserializationNotSupported() {\n   }\n   \n   public void testDoubleInfinityDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"Infinity\", Double.class);\n-      gson.fromJson(\"Infinity\", double.class);\n-      fail(\"Gson should not accept positive infinity for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", Double.class)));\n+    assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", double.class)));\n   }\n   \n   public void testFloatInfinitySerializationNotSupported() {\n   }\n   \n   public void testFloatInfinityDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"Infinity\", Float.class);\n-      gson.fromJson(\"Infinity\", float.class);\n-      fail(\"Gson should not accept positive infinity for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", Float.class)));\n+    assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", float.class)));\n   }\n   \n   public void testBigDecimalInfinityDeserializationNotSupported() {\n   }\n   \n   public void testNegativeInfinityDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"-Infinity\", double.class);\n-      gson.fromJson(\"-Infinity\", Double.class);\n-      fail(\"Gson should not accept positive infinity for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", double.class)));\n+    assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", Double.class)));\n   }\n   \n   public void testNegativeInfinityFloatSerializationNotSupported() {\n   }\n   \n   public void testNegativeInfinityFloatDeserializationNotSupported() {\n-    try {\n-      gson.fromJson(\"-Infinity\", float.class);\n-      gson.fromJson(\"-Infinity\", Float.class);\n-      fail(\"Gson should not accept positive infinity for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n+    assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", float.class)));\n+    assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", Float.class)));\n   }\n   \n   public void testNegativeInfinityBigDecimalDeserializationNotSupported() {", "timestamp": 1229725295, "metainfo": ""}