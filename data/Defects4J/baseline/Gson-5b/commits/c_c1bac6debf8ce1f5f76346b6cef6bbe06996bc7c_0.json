{"sha": "c1bac6debf8ce1f5f76346b6cef6bbe06996bc7c", "log": "Converted Date type adapter to the new style. This was the last remaining old style default type adapter.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n  */\n final class DefaultTypeAdapters {\n \n-  private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER = new DefaultDateTypeAdapter();\n-\n   // The constants DEFAULT_SERIALIZERS, DEFAULT_DESERIALIZERS, and DEFAULT_INSTANCE_CREATORS\n   // must be defined after the constants for the type adapters. Otherwise, the type adapter\n   // constants will appear as nulls.\n   private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() {\n     ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n-\n-    map.register(Date.class, DATE_TYPE_ADAPTER, true);\n-    map.register(Timestamp.class, DATE_TYPE_ADAPTER, true);\n-\n     map.makeUnmodifiable();\n     return map;\n   }\n   private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\n         new ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\n-    map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER), true);\n-\n     map.makeUnmodifiable();\n     return map;\n   }\n         = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n     map.makeUnmodifiable();\n     return map;\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\n-    return new JsonDeserializerExceptionWrapper(deserializer);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  */\n \n package com.google.gson;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ParameterizedTypeHandlerMap;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n         .factory(TypeAdapters.LOCALE_FACTORY)\n         .factory(TypeAdapters.INET_ADDRESS_FACTORY)\n         .factory(TypeAdapters.BIT_SET_FACTORY)\n+        .factory(TypeAdapters.DATE_FACTORY)\n         .factory(TypeAdapters.CALENDAR_FACTORY)\n         .factory(TypeAdapters.SQL_TIME_FACTORY)\n         .factory(TypeAdapters.SQL_DATE_FACTORY)\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.StringTokenizer;\n+import java.util.TimeZone;\n import java.util.UUID;\n \n import com.google.gson.JsonIOException;\n     }\n   };\n \n+  private static DateFormat buildIso8601Format() {\n+    DateFormat iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Locale.US);\n+    iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return iso8601Format;\n+  }\n+  \n+  public static final TypeAdapter<Date> DATE = new TypeAdapter<Date>() {\n+    private final DateFormat enUsFormat =\n+    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US);\n+    private final DateFormat localFormat =\n+    DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT);\n+    private final DateFormat iso8601Format = buildIso8601Format();\n+    @Override\n+    public Date read(JsonReader reader) throws IOException {\n+      return deserializeToDate(reader.nextString());\n+    }\n+\n+    private Date deserializeToDate(String json) {\n+      synchronized (localFormat) {\n+        try {\n+          return localFormat.parse(json);\n+        } catch (ParseException ignored) {\n+        }\n+        try {\n+          return enUsFormat.parse(json);\n+        } catch (ParseException ignored) {\n+        }\n+        try {\n+          return iso8601Format.parse(json);\n+        } catch (ParseException e) {\n+          throw new JsonSyntaxException(json, e);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void write(JsonWriter writer, Date value) throws IOException {\n+      synchronized (localFormat) {\n+        String dateFormatAsString = enUsFormat.format(value);\n+        writer.value(dateFormatAsString);\n+      }\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory DATE_FACTORY = newFactory(Date.class, DATE);\n+\n   public static final TypeAdapter.Factory UUID_FACTORY = newFactory(UUID.class, UUID);\n \n   public static final TypeAdapter<Time> SQL_TIME = new TypeAdapter<Time>() {\n   public static final TypeAdapter.Factory SQL_TIME_FACTORY = newFactory(Time.class, SQL_TIME);\n \n   private static final class TimestampTypeAdapter extends TypeAdapter<Timestamp> {\n-    private final DateFormat format = new SimpleDateFormat(\"hh:mm:ss a\");\n     private final MiniGson context;\n     public TimestampTypeAdapter(MiniGson context) {\n       this.context = context;\n     }\n     @Override\n     public void write(JsonWriter writer, Timestamp value) throws IOException {\n-      writer.value(format.format(value));\n+      TypeAdapter<Date> dateTypeAdapter = context.getAdapter(Date.class);\n+      dateTypeAdapter.write(writer, value);\n     }\n   };\n   public static final TypeAdapter.Factory SQL_TIMESTAMP_FACTORY = new TypeAdapter.Factory() {", "timestamp": 1316987488, "metainfo": ""}