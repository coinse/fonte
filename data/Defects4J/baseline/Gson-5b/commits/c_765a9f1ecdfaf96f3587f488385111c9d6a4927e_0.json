{"sha": "765a9f1ecdfaf96f3587f488385111c9d6a4927e", "log": "Brand new classes for streaming JSON efficiently.  Notable features:  - Efficiency. The parser is faster than the current javacc parser. It's also faster than popular libraries for JSON streaming.  - Toggle lenient/strict  - Toggle pretty/compact  - Friendly error messages on bad JSON  - GSON-quality Javadoc  - Non-execute prefix handling  This doesn't wire JsonReader up into Gson just yet. That's coming soon...", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import java.io.Closeable;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * encoded value as a stream of tokens. This stream includes both literal\n+ * values (strings, numbers, booleans, and nulls) as well as the begin and\n+ * end delimiters of objects and arrays. The tokens are traversed in\n+ * depth-first order, the same order that they appear in the JSON document.\n+ * Within JSON objects, name/value pairs are represented by a single token.\n+ *\n+ * <h3>Parsing JSON</h3>\n+ * To create a recursive descent parser your own JSON streams, first create an\n+ * entry point method that creates a {@code JsonReader}.\n+ *\n+ * <p>Next, create handler methods for each structure in your JSON text. You'll\n+ * need a method for each object type and for each array type.\n+ * <ul>\n+ *   <li>Within <strong>array handling</strong> methods, first call {@link\n+ *       #beginArray} to consume the array's opening bracket. Then create a\n+ *       while loop that accumulates values, terminating when {@link #hasNext}\n+ *       is false. Finally, read the array's closing bracket by calling {@link\n+ *       #endArray}.\n+ *   <li>Within <strong>object handling</strong> methods, first call {@link\n+ *       #beginObject} to consume the object's opening brace. Then create a\n+ *       while loop that assigns values to local variables based on their name.\n+ *       This loop should terminate when {@link #hasNext} is false. Finally,\n+ *       read the object's closing brace by calling {@link #endObject}.\n+ * </ul>\n+ * <p>When a nested object or array is encountered, delegate to the\n+ * corresponding handler method.\n+ *\n+ * <p>When an unknown name is encountered, strict parsers should fail with an\n+ * exception. Lenient parsers should call {@link #skipValue()} to recursively\n+ * skip the value's nested tokens, which may otherwise conflict.\n+ *\n+ * <p>If a value may be null, you should first check using {@link #peek()}.\n+ * Null literals can be consumed using either {@link #nextNull()} or {@link\n+ * #skipValue()}.\n+ *\n+ * <h3>Example</h3>\n+ * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n+ * [\n+ *   {\n+ *     \"id\": 912345678901,\n+ *     \"text\": \"How do I read a JSON stream in Java?\",\n+ *     \"geo\": null,\n+ *     \"user\": {\n+ *       \"name\": \"json_newb\",\n+ *       \"followers_count\": 41\n+ *      }\n+ *   },\n+ *   {\n+ *     \"id\": 912345678902,\n+ *     \"text\": \"@json_newb just use JsonReader!\",\n+ *     \"geo\": [50.454722, -104.606667],\n+ *     \"user\": {\n+ *       \"name\": \"jesse\",\n+ *       \"followers_count\": 2\n+ *     }\n+ *   }\n+ * ]}</pre>\n+ * This code implements the parser for the above structure: <pre>   {@code\n+ *\n+ *   public List<Message> readJsonStream(InputStream in) throws IOException {\n+ *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n+ *     return readMessagesArray(reader);\n+ *   }\n+ *\n+ *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n+ *     List<Message> messages = new ArrayList<Message>();\n+ *\n+ *     reader.beginArray();\n+ *     while (reader.hasNext()) {\n+ *       messages.add(readMessage(reader));\n+ *     }\n+ *     reader.endArray();\n+ *     return messages;\n+ *   }\n+ *\n+ *   public Message readMessage(JsonReader reader) throws IOException {\n+ *     long id = -1;\n+ *     String text = null;\n+ *     User user = null;\n+ *     List<Double> geo = null;\n+ *\n+ *     reader.beginObject();\n+ *     while (reader.hasNext()) {\n+ *       String name = reader.nextName();\n+ *       if (name.equals(\"id\")) {\n+ *         id = reader.nextLong();\n+ *       } else if (name.equals(\"text\")) {\n+ *         text = reader.nextString();\n+ *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n+ *         geo = readDoublesArray(reader);\n+ *       } else if (name.equals(\"user\")) {\n+ *         user = readUser(reader);\n+ *       } else {\n+ *         reader.skipValue();\n+ *       }\n+ *     }\n+ *     reader.endObject();\n+ *     return new Message(id, text, user, geo);\n+ *   }\n+ *\n+ *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n+ *     List<Double> doubles = new ArrayList<Double>();\n+ *\n+ *     reader.beginArray();\n+ *     while (reader.hasNext()) {\n+ *       doubles.add(reader.nextDouble());\n+ *     }\n+ *     reader.endArray();\n+ *     return doubles;\n+ *   }\n+ *\n+ *   public User readUser(JsonReader reader) throws IOException {\n+ *     String username = null;\n+ *     int followersCount = -1;\n+ *\n+ *     reader.beginObject();\n+ *     while (reader.hasNext()) {\n+ *       String name = reader.nextName();\n+ *       if (name.equals(\"name\")) {\n+ *         username = reader.nextString();\n+ *       } else if (name.equals(\"followers_count\")) {\n+ *         followersCount = reader.nextInt();\n+ *       } else {\n+ *         reader.skipValue();\n+ *       }\n+ *     }\n+ *     reader.endObject();\n+ *     return new User(username, followersCount);\n+ *   }}</pre>\n+ *\n+ * <h3>Number Handling</h3>\n+ * This reader permits numeric values to be read as strings and string values to\n+ * be read as numbers. For example, both elements of the JSON array {@code\n+ * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n+ * This behavior is intended to prevent lossy numeric conversions: double is\n+ * JavaScript's only numeric type and very large values like {@code\n+ * 9007199254740993} cannot be represented exactly on that platform. To minimize\n+ * precision loss, extremely large values should be written and read as strings\n+ * in JSON.\n+ *\n+ * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n+ * Web servers that serve private data using JSON may be vulnerable to <a\n+ * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n+ * request forgery</a> attacks. In such an attack, a malicious site gains access\n+ * to a private JSON file by executing it with an HTML {@code <script>} tag.\n+ *\n+ * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n+ * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n+ * JSON, strict parsing fails when it is encountered. This class permits the\n+ * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n+ * enabled.\n+ *\n+ * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n+ * of this class are not thread safe.\n+ * \n+ * @author Jesse Wilson\n+ */\n+public final class JsonReader implements Closeable {\n+\n+  /** The only non-execute prefix this parser permits */\n+  private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\n+\n+  /** The input JSON. */\n+  private final Reader in;\n+\n+  /** True to accept non-spec compliant JSON */\n+  private boolean lenient = false;\n+\n+  /**\n+   * Use a manual buffer to easily read and unread upcoming characters, and\n+   * also so we can create strings without an intermediate StringBuilder.\n+   */\n+  private final char[] buffer = new char[1024];\n+  private int pos = 0;\n+  private int limit = 0;\n+\n+  private final List<JsonScope> stack = new ArrayList<JsonScope>();\n+  {\n+    push(JsonScope.EMPTY_DOCUMENT);\n+  }\n+\n+  /**\n+   * True if we've already read the next token. If we have, the string value\n+   * for that token will be assigned to {@code value} if such a string value\n+   * exists. And the token type will be assigned to {@code token} if the token\n+   * type is known. The token type may be null for literals, since we derive\n+   * that lazily.\n+   */\n+  private boolean hasToken;\n+\n+  /**\n+   * The type of the next token to be returned by {@link #peek} and {@link\n+   * #advance}, or {@code null} if it is unknown and must first be derived\n+   * from {@code value}. This value is undefined if {@code hasToken} is false.\n+   */\n+  private JsonToken token;\n+\n+  /** The text of the next name. */\n+  private String name;\n+\n+  /** The text of the next literal value. */\n+  private String value;\n+\n+  /** True if we're currently handling a skipValue() call. */\n+  private boolean skipping = false;\n+\n+  /**\n+   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n+   */\n+  public JsonReader(Reader in) {\n+    if (in == null) {\n+      throw new NullPointerException(\"in == null\");\n+    }\n+    this.in = in;\n+  }\n+\n+  /**\n+   * Configure this parser to be  be liberal in what it accepts. By default,\n+   * this parser is strict and only accepts JSON as specified by <a\n+   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n+   * parser to lenient causes it to ignore the following syntax errors:\n+   *\n+   * <ul>\n+   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n+   *       prefix</a>, <code>\")]}'\\n\"</code>.\n+   *   <li>Streams that include multiple top-level values. With strict parsing,\n+   *       each stream must contain exactly one top-level value.\n+   *   <li>Top-level values of any type. With strict parsing, the top-level\n+   *       value must be an object or an array.\n+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n+   *       Double#isInfinite() infinities}.\n+   *   <li>End of line comments starting with {@code //} or {@code #} and\n+   *       ending with a newline character.\n+   *   <li>C-style comments starting with {@code /*} and ending with\n+   *       {@code *}{@code /}. Such comments may not be nested.\n+   *   <li>Names that are unquoted or {@code 'single quoted'}.\n+   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n+   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n+   *   <li>Unnecessary array separators. These are interpreted as if null\n+   *       was the omitted value.\n+   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n+   *       {@code :}.\n+   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n+   * </ul>\n+   */\n+  public void setLenient(boolean lenient) {\n+    this.lenient = lenient;\n+  }\n+\n+  /**\n+   * Returns true if this parser is liberal in what it accepts.\n+   */\n+  public boolean isLenient() {\n+    return lenient;\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * beginning of a new array.\n+   */\n+  public void beginArray() throws IOException {\n+    expect(JsonToken.BEGIN_ARRAY);\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * end of the current array.\n+   */\n+  public void endArray() throws IOException {\n+    expect(JsonToken.END_ARRAY);\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * beginning of a new object.\n+   */\n+  public void beginObject() throws IOException {\n+    expect(JsonToken.BEGIN_OBJECT);\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * end of the current array.\n+   */\n+  public void endObject() throws IOException {\n+    expect(JsonToken.END_OBJECT);\n+  }\n+\n+  /**\n+   * Consumes {@code expected}.\n+   */\n+  private void expect(JsonToken expected) throws IOException {\n+    quickPeek();\n+    if (token != expected) {\n+      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+    }\n+    advance();\n+  }\n+\n+  /**\n+   * Returns true if the current array or object has another element.\n+   */\n+  public boolean hasNext() throws IOException {\n+    quickPeek();\n+    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n+  }\n+\n+  /**\n+   * Returns the type of the next token without consuming it.\n+   */\n+  public JsonToken peek() throws IOException {\n+    quickPeek();\n+\n+    if (token == null) {\n+      decodeLiteral();\n+    }\n+\n+    return token;\n+  }\n+\n+  /**\n+   * Ensures that a token is ready. After this call either {@code token} or\n+   * {@code value} will be non-null. To ensure {@code token} has a definitive\n+   * value, use {@link #peek()}\n+   */\n+  private JsonToken quickPeek() throws IOException {\n+    if (hasToken) {\n+      return token;\n+    }\n+\n+    switch (peekStack()) {\n+    case EMPTY_DOCUMENT:\n+      if (lenient) {\n+        consumeNonExecutePrefix();\n+      }\n+      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n+      JsonToken firstToken = nextValue();\n+      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n+        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n+      }\n+      return firstToken;\n+    case EMPTY_ARRAY:\n+      return nextInArray(true);\n+    case NONEMPTY_ARRAY:\n+      return nextInArray(false);\n+    case EMPTY_OBJECT:\n+      return nextInObject(true);\n+    case DANGLING_NAME:\n+      return objectValue();\n+    case NONEMPTY_OBJECT:\n+      return nextInObject(false);\n+    case NONEMPTY_DOCUMENT:\n+      try {\n+        JsonToken token = nextValue();\n+        if (lenient) {\n+          return token;\n+        } else {\n+          throw syntaxError(\"Expected EOF\");\n+        }\n+      } catch (EOFException e) {\n+        hasToken = true; // TODO: avoid throwing here?\n+        return token = JsonToken.END_DOCUMENT;\n+      }\n+    case CLOSED:\n+      throw new IllegalStateException(\"JsonReader is closed\");\n+    default:\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  /**\n+   * Consumes the non-execute prefix if it exists.\n+   */\n+  private void consumeNonExecutePrefix() throws IOException {\n+    // fast forward through the leading whitespace\n+    nextNonWhitespace();\n+    pos--;\n+    \n+    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n+      return;\n+    }\n+    \n+    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n+      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n+        return; // not a security token!\n+      }\n+    }\n+    \n+    // we consumed a security token!\n+    pos += NON_EXECUTE_PREFIX.length;\n+  }\n+\n+  /**\n+   * Advances the cursor in the JSON stream to the next token.\n+   */\n+  private JsonToken advance() throws IOException {\n+    quickPeek();\n+\n+    JsonToken result = token;\n+    hasToken = false;\n+    token = null;\n+    value = null;\n+    name = null;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the next token, a {@link JsonToken#NAME property name}, and\n+   * consumes it.\n+   *\n+   * @throws IOException if the next token in the stream is not a property\n+   *     name.\n+   */\n+  public String nextName() throws IOException {\n+    quickPeek();\n+    if (token != JsonToken.NAME) {\n+      throw new IllegalStateException(\"Expected a name but was \" + peek());\n+    }\n+    String result = name;\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link JsonToken#STRING string} value of the next token,\n+   * consuming it. If the next token is a number, this method will return its\n+   * string form.\n+   *\n+   * @throws IllegalStateException if the next token is not a string or if\n+   *     this reader is closed.\n+   */\n+  public String nextString() throws IOException {\n+    peek();\n+    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n+      throw new IllegalStateException(\"Expected a string but was \" + peek());\n+    }\n+\n+    String result = value;\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n+   * consuming it.\n+   *\n+   * @throws IllegalStateException if the next token is not a boolean or if\n+   *     this reader is closed.\n+   */\n+  public boolean nextBoolean() throws IOException {\n+    quickPeek();\n+    if (value == null || token == JsonToken.STRING) {\n+      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n+    }\n+\n+    boolean result;\n+    if (value.equalsIgnoreCase(\"true\")) {\n+      result = true;\n+    } else if (value.equalsIgnoreCase(\"false\")) {\n+      result = false;\n+    } else {\n+      throw new IllegalStateException(\"Not a boolean: \" + value);\n+    }\n+\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is a\n+   * literal null.\n+   *\n+   * @throws IllegalStateException if the next token is not null or if this\n+   *     reader is closed.\n+   */\n+  public void nextNull() throws IOException {\n+    quickPeek();\n+    if (value == null || token == JsonToken.STRING) {\n+      throw new IllegalStateException(\"Expected null but was \" + peek());\n+    }\n+\n+    if (!value.equalsIgnoreCase(\"null\")) {\n+      throw new IllegalStateException(\"Not a null: \" + value);\n+    }\n+\n+    advance();\n+  }\n+\n+  /**\n+   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as a double.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a double, or is non-finite.\n+   */\n+  public double nextDouble() throws IOException {\n+    quickPeek();\n+    if (value == null) {\n+      throw new IllegalStateException(\"Expected a double but was \" + peek());\n+    }\n+\n+    double result = Double.parseDouble(value);\n+\n+    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n+      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n+    }\n+\n+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n+      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n+    }\n+\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as a long. If the next token's numeric value cannot be exactly\n+   * represented by a Java {@code long}, this method throws.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a number, or exactly represented as a long.\n+   */\n+  public long nextLong() throws IOException {\n+    quickPeek();\n+    if (value == null) {\n+      throw new IllegalStateException(\"Expected a long but was \" + peek());\n+    }\n+\n+    long result;\n+    try {\n+      result = Long.parseLong(value);\n+    } catch (NumberFormatException ignored) {\n+      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n+      result = (long) asDouble;\n+      if ((double) result != asDouble) {\n+        throw new NumberFormatException(value);\n+      }\n+    }\n+\n+    if (result >= 1L && value.startsWith(\"0\")) {\n+      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n+    }\n+\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as an int. If the next token's numeric value cannot be exactly\n+   * represented by a Java {@code int}, this method throws.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a number, or exactly represented as an int.\n+   */\n+  public int nextInt() throws IOException {\n+    quickPeek();\n+    if (value == null) {\n+      throw new IllegalStateException(\"Expected an int but was \" + peek());\n+    }\n+\n+    int result;\n+    try {\n+      result = Integer.parseInt(value);\n+    } catch (NumberFormatException ignored) {\n+      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n+      result = (int) asDouble;\n+      if ((double) result != asDouble) {\n+        throw new NumberFormatException(value);\n+      }\n+    }\n+\n+    if (result >= 1L && value.startsWith(\"0\")) {\n+      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n+    }\n+\n+    advance();\n+    return result;\n+  }\n+\n+  /**\n+   * Closes this JSON reader and the underlying {@link Reader}.\n+   */\n+  public void close() throws IOException {\n+    hasToken = false;\n+    value = null;\n+    token = null;\n+    stack.clear();\n+    stack.add(JsonScope.CLOSED);\n+    in.close();\n+  }\n+\n+  /**\n+   * Skips the next value recursively. If it is an object or array, all nested\n+   * elements are skipped. This method is intended for use when the JSON token\n+   * stream contains unrecognized or unhandled values.\n+   */\n+  public void skipValue() throws IOException {\n+    skipping = true;\n+    try {\n+      int count = 0;\n+      do {\n+        JsonToken token = advance();\n+        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n+          count++;\n+        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n+          count--;\n+        }\n+      } while (count != 0);\n+    } finally {\n+      skipping = false;\n+    }\n+  }\n+\n+  private JsonScope peekStack() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  private JsonScope pop() {\n+    return stack.remove(stack.size() - 1);\n+  }\n+\n+  private void push(JsonScope newTop) {\n+    stack.add(newTop);\n+  }\n+\n+  /**\n+   * Replace the value on the top of the stack with the given value.\n+   */\n+  private void replaceTop(JsonScope newTop) {\n+    stack.set(stack.size() - 1, newTop);\n+  }\n+\n+  private JsonToken nextInArray(boolean firstElement) throws IOException {\n+    if (firstElement) {\n+      replaceTop(JsonScope.NONEMPTY_ARRAY);\n+    } else {\n+      /* Look for a comma before each element after the first element. */\n+      switch (nextNonWhitespace()) {\n+      case ']':\n+        pop();\n+        hasToken = true;\n+        return token = JsonToken.END_ARRAY;\n+      case ';':\n+        checkLenient(); // fall-through\n+      case ',':\n+        break;\n+      default:\n+        throw syntaxError(\"Unterminated array\");\n+      }\n+    }\n+\n+    switch (nextNonWhitespace()) {\n+    case ']':\n+      if (firstElement) {\n+        pop();\n+        hasToken = true;\n+        return token = JsonToken.END_ARRAY;\n+      }\n+      // fall-through to handle \",]\"\n+    case ';':\n+    case ',':\n+      /* In lenient mode, a 0-length literal means 'null' */\n+      checkLenient();\n+      pos--;\n+      hasToken = true;\n+      value = \"null\";\n+      return token = JsonToken.NULL;\n+    default:\n+      pos--;\n+      return nextValue();\n+    }\n+  }\n+\n+  private JsonToken nextInObject(boolean firstElement) throws IOException {\n+    /*\n+     * Read delimiters. Either a comma/semicolon separating this and the\n+     * previous name-value pair, or a close brace to denote the end of the\n+     * object.\n+     */\n+    if (firstElement) {\n+      /* Peek to see if this is the empty object. */\n+      switch (nextNonWhitespace()) {\n+      case '}':\n+        pop();\n+        hasToken = true;\n+        return token = JsonToken.END_OBJECT;\n+      default:\n+        pos--;\n+      }\n+    } else {\n+      switch (nextNonWhitespace()) {\n+      case '}':\n+        pop();\n+        hasToken = true;\n+        return token = JsonToken.END_OBJECT;\n+      case ';':\n+      case ',':\n+        break;\n+      default:\n+        throw syntaxError(\"Unterminated object\");\n+      }\n+    }\n+\n+    /* Read the name. */\n+    int quote = nextNonWhitespace();\n+    switch (quote) {\n+    case '\\'':\n+      checkLenient(); // fall-through\n+    case '\"':\n+      name = nextString((char) quote);\n+      break;\n+    default:\n+      checkLenient();\n+      pos--;\n+      name = nextLiteral();\n+      if (name.isEmpty()) {\n+        throw syntaxError(\"Expected name\");\n+      }\n+    }\n+\n+    replaceTop(JsonScope.DANGLING_NAME);\n+    hasToken = true;\n+    return token = JsonToken.NAME;\n+  }\n+\n+  private JsonToken objectValue() throws IOException {\n+    /*\n+     * Read the name/value separator. Usually a colon ':'. In lenient mode\n+     * we also accept an equals sign '=', or an arrow \"=>\".\n+     */\n+    switch (nextNonWhitespace()) {\n+    case ':':\n+      break;\n+    case '=':\n+      checkLenient();\n+      if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n+        pos++;\n+      }\n+      break;\n+    default:\n+      throw syntaxError(\"Expected ':'\");\n+    }\n+\n+    replaceTop(JsonScope.NONEMPTY_OBJECT);\n+    return nextValue();\n+  }\n+\n+  private JsonToken nextValue() throws IOException {\n+    int c = nextNonWhitespace();\n+    switch (c) {\n+    case '{':\n+      push(JsonScope.EMPTY_OBJECT);\n+      hasToken = true;\n+      return token = JsonToken.BEGIN_OBJECT;\n+\n+    case '[':\n+      push(JsonScope.EMPTY_ARRAY);\n+      hasToken = true;\n+      return token = JsonToken.BEGIN_ARRAY;\n+\n+    case '\\'':\n+      checkLenient(); // fall-through\n+    case '\"':\n+      value = nextString((char) c);\n+      hasToken = true;\n+      return token = JsonToken.STRING;\n+\n+    default:\n+      pos--;\n+      return readLiteral();\n+    }\n+  }\n+\n+  /**\n+   * Returns true once {@code limit - pos >= minimum}. If the data is\n+   * exhausted before that many characters are available, this returns\n+   * false.\n+   */\n+  private boolean fillBuffer(int minimum) throws IOException {\n+    if (limit != pos) {\n+      limit -= pos;\n+      System.arraycopy(buffer, pos, buffer, 0, limit);\n+    } else {\n+      limit = 0;\n+    }\n+\n+    pos = 0;\n+    int total;\n+    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n+      limit += total;\n+      if (limit >= minimum) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private int nextNonWhitespace() throws IOException {\n+    while (pos < limit || fillBuffer(1)) {\n+      int c = buffer[pos++];\n+      switch (c) {\n+      case '\\t':\n+      case ' ':\n+      case '\\n':\n+      case '\\r':\n+        continue;\n+\n+      case '/':\n+        if (pos == limit && !fillBuffer(1)) {\n+          return c;\n+        }\n+\n+        checkLenient();\n+        char peek = buffer[pos];\n+        switch (peek) {\n+        case '*':\n+          // skip a /* c-style comment */\n+          pos++;\n+          if (!skipTo(\"*/\")) {\n+            throw syntaxError(\"Unterminated comment\");\n+          }\n+          pos += 2;\n+          continue;\n+\n+        case '/':\n+          // skip a // end-of-line comment\n+          pos++;\n+          skipToEndOfLine();\n+          continue;\n+\n+        default:\n+          return c;\n+        }\n+\n+      case '#':\n+        /*\n+         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n+         * specify this behaviour, but it's required to parse\n+         * existing documents. See http://b/2571423.\n+         */\n+        checkLenient();\n+        skipToEndOfLine();\n+        continue;\n+\n+      default:\n+        return c;\n+      }\n+    }\n+    throw new EOFException(\"End of input\");\n+  }\n+\n+  private void checkLenient() throws IOException {\n+    if (!lenient) {\n+      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n+    }\n+  }\n+\n+  /**\n+   * Advances the position until after the next newline character. If the line\n+   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n+   * caller.\n+   */\n+  private void skipToEndOfLine() throws IOException {\n+    while (pos < limit || fillBuffer(1)) {\n+      char c = buffer[pos++];\n+      if (c == '\\r' || c == '\\n') {\n+        break;\n+      }\n+    }\n+  }\n+\n+  private boolean skipTo(String toFind) throws IOException {\n+    outer:\n+    for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) {\n+      for (int c = 0; c < toFind.length(); c++) {\n+        if (buffer[pos + c] != toFind.charAt(c)) {\n+          continue outer;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Returns the string up to but not including {@code quote}, unescaping any\n+   * character escape sequences encountered along the way. The opening quote\n+   * should have already been read. This consumes the closing quote, but does\n+   * not include it in the returned string.\n+   *\n+   * @param quote either ' or \".\n+   * @throws NumberFormatException if any unicode escape sequences are\n+   *     malformed.\n+   */\n+  private String nextString(char quote) throws IOException {\n+    StringBuilder builder = null;\n+    do {\n+      /* the index of the first character not yet appended to the builder. */\n+      int start = pos;\n+      while (pos < limit) {\n+        int c = buffer[pos++];\n+\n+        if (c == quote) {\n+          if (skipping) {\n+            return \"skipped!\";\n+          } else if (builder == null) {\n+            return new String(buffer, start, pos - start - 1);\n+          } else {\n+            builder.append(buffer, start, pos - start - 1);\n+            return builder.toString();\n+          }\n+\n+        } else if (c == '\\\\') {\n+          if (builder == null) {\n+            builder = new StringBuilder();\n+          }\n+          builder.append(buffer, start, pos - start - 1);\n+          builder.append(readEscapeCharacter());\n+          start = pos;\n+        }\n+      }\n+\n+      if (builder == null) {\n+        builder = new StringBuilder();\n+      }\n+      builder.append(buffer, start, pos - start);\n+    } while (fillBuffer(1));\n+\n+    throw syntaxError(\"Unterminated string\");\n+  }\n+\n+  /**\n+   * Returns the string up to but not including any delimiter characters. This\n+   * does not consume the delimiter character.\n+   */\n+  private String nextLiteral() throws IOException {\n+    StringBuilder builder = null;\n+    do {\n+      /* the index of the first character not yet appended to the builder. */\n+      int start = pos;\n+      while (pos < limit) {\n+        int c = buffer[pos++];\n+        switch (c) {\n+        case '/':\n+        case '\\\\':\n+        case ';':\n+        case '#':\n+        case '=':\n+          checkLenient(); // fall-through\n+\n+        case '{':\n+        case '}':\n+        case '[':\n+        case ']':\n+        case ':':\n+        case ',':\n+        case ' ':\n+        case '\\t':\n+        case '\\f':\n+        case '\\r':\n+        case '\\n':\n+          pos--;\n+          if (skipping) {\n+            return \"skipped!\";\n+          } else if (builder == null) {\n+            return new String(buffer, start, pos - start);\n+          } else {\n+            builder.append(buffer, start, pos - start);\n+            return builder.toString();\n+          }\n+        }\n+      }\n+\n+      if (builder == null) {\n+        builder = new StringBuilder();\n+      }\n+      builder.append(buffer, start, pos - start);\n+    } while (fillBuffer(1));\n+\n+    return builder.toString();\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \" near \" + getSnippet();\n+  }\n+\n+  /**\n+   * Unescapes the character identified by the character or characters that\n+   * immediately follow a backslash. The backslash '\\' should have already\n+   * been read. This supports both unicode escapes \"u000A\" and two-character\n+   * escapes \"\\n\".\n+   *\n+   * @throws NumberFormatException if any unicode escape sequences are\n+   *     malformed.\n+   */\n+  private char readEscapeCharacter() throws IOException {\n+    if (pos == limit && !fillBuffer(1)) {\n+      throw syntaxError(\"Unterminated escape sequence\");\n+    }\n+\n+    char escaped = buffer[pos++];\n+    switch (escaped) {\n+    case 'u':\n+      if (pos + 4 > limit && !fillBuffer(4)) {\n+        throw syntaxError(\"Unterminated escape sequence\");\n+      }\n+      String hex = new String(buffer, pos, 4);\n+      pos += 4;\n+      return (char) Integer.parseInt(hex, 16);\n+\n+    case 't':\n+      return '\\t';\n+\n+    case 'b':\n+      return '\\b';\n+\n+    case 'n':\n+      return '\\n';\n+\n+    case 'r':\n+      return '\\r';\n+\n+    case 'f':\n+      return '\\f';\n+\n+    case '\\'':\n+    case '\"':\n+    case '\\\\':\n+    default:\n+      return escaped;\n+    }\n+  }\n+\n+  /**\n+   * Reads a null, boolean, numeric or unquoted string literal value.\n+   */\n+  private JsonToken readLiteral() throws IOException {\n+    String literal = nextLiteral();\n+    if (literal.isEmpty()) {\n+      throw syntaxError(\"Expected literal value\");\n+    }\n+    value = literal;\n+    hasToken = true;\n+    return token = null; // use decodeLiteral() to get the token type\n+  }\n+\n+  /**\n+   * Assigns {@code nextToken} based on the value of {@code nextValue}.\n+   */\n+  private void decodeLiteral() throws IOException {\n+    if (value.equalsIgnoreCase(\"null\")) {\n+      token = JsonToken.NULL;\n+    } else if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")) {\n+      token = JsonToken.BOOLEAN;\n+    } else {\n+      try {\n+        Double.parseDouble(value); // this work could potentially be cached\n+        token = JsonToken.NUMBER;\n+      } catch (NumberFormatException ignored) {\n+        // this must be an unquoted string\n+        checkLenient();\n+        token = JsonToken.STRING;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Throws a new IO exception with the given message and a context snippet\n+   * with this reader's content.\n+   */\n+  private IOException syntaxError(String message) throws IOException {\n+    throw new JsonSyntaxException(message + \" near \" + getSnippet());\n+  }\n+\n+  private CharSequence getSnippet() {\n+    StringBuilder snippet = new StringBuilder();\n+    int beforePos = Math.min(pos, 20);\n+    snippet.append(buffer, pos - beforePos, beforePos);\n+    int afterPos = Math.min(limit - pos, 20);\n+    snippet.append(buffer, pos, afterPos);\n+    return snippet;\n+  }\n+\n+  @SuppressWarnings(\"serial\")\n+  private static class JsonSyntaxException extends IOException {\n+    private JsonSyntaxException(String s) {\n+      super(s);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/JsonScope.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+/**\n+ * Lexical scoping elements within a JSON reader or writer.\n+ *\n+ * @author Jesse Wilson\n+ */\n+enum JsonScope {\n+\n+    /**\n+     * An array with no elements requires no separators or newlines before\n+     * it is closed.\n+     */\n+    EMPTY_ARRAY,\n+\n+    /**\n+     * A array with at least one value requires a comma and newline before\n+     * the next element.\n+     */\n+    NONEMPTY_ARRAY,\n+\n+    /**\n+     * An object with no name/value pairs requires no separators or newlines\n+     * before it is closed.\n+     */\n+    EMPTY_OBJECT,\n+\n+    /**\n+     * An object whose most recent element is a key. The next element must\n+     * be a value.\n+     */\n+    DANGLING_NAME,\n+\n+    /**\n+     * An object with at least one name/value pair requires a comma and\n+     * newline before the next element.\n+     */\n+    NONEMPTY_OBJECT,\n+\n+    /**\n+     * No object or array has been started.\n+     */\n+    EMPTY_DOCUMENT,\n+\n+    /**\n+     * A document with at an array or object.\n+     */\n+    NONEMPTY_DOCUMENT,\n+\n+    /**\n+     * A document that's been closed and cannot be accessed.\n+     */\n+    CLOSED,\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/JsonToken.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+/**\n+ * A structure, name or value type in a JSON-encoded string.\n+ *\n+ * @author Jesse Wilson\n+ */\n+public enum JsonToken {\n+\n+  /**\n+   * The opening of a JSON array. Written using {@link JsonWriter#beginObject}\n+   * and read using {@link JsonReader#beginObject}.\n+   */\n+  BEGIN_ARRAY,\n+\n+  /**\n+   * The closing of a JSON array. Written using {@link JsonWriter#endArray}\n+   * and read using {@link JsonReader#endArray}.\n+   */\n+  END_ARRAY,\n+\n+  /**\n+   * The opening of a JSON object. Written using {@link JsonWriter#beginObject}\n+   * and read using {@link JsonReader#beginObject}.\n+   */\n+  BEGIN_OBJECT,\n+\n+  /**\n+   * The closing of a JSON object. Written using {@link JsonWriter#endObject}\n+   * and read using {@link JsonReader#endObject}.\n+   */\n+  END_OBJECT,\n+\n+  /**\n+   * A JSON property name. Within objects, tokens alternate between names and\n+   * their values. Written using {@link JsonWriter#name} and read using {@link\n+   * JsonReader#nextName}\n+   */\n+  NAME,\n+\n+  /**\n+   * A JSON string.\n+   */\n+  STRING,\n+\n+  /**\n+   * A JSON number represented in this API by a Java {@code double}, {@code\n+   * long}, or {@code int}.\n+   */\n+  NUMBER,\n+\n+  /**\n+   * A JSON {@code true} or {@code false}.\n+   */\n+  BOOLEAN,\n+\n+  /**\n+   * A JSON {@code null}.\n+   */\n+  NULL,\n+\n+  /**\n+   * The end of the JSON stream. This sentinel value is returned by {@link\n+   * JsonReader#peek()} to signal that the JSON-encoded value has no more\n+   * tokens.\n+   */\n+  END_DOCUMENT\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * encoded value to a stream, one token at a time. The stream includes both\n+ * literal values (strings, numbers, booleans and nulls) as well as the begin\n+ * and end delimiters of objects and arrays.\n+ *\n+ * <h3>Encoding JSON</h3>\n+ * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON\n+ * document must contain one top-level array or object. Call methods on the\n+ * writer as you walk the structure's contents, nesting arrays and objects as\n+ * necessary:\n+ * <ul>\n+ *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n+ *       Write each of the array's elements with the appropriate {@link #value}\n+ *       methods or by nesting other arrays and objects. Finally close the array\n+ *       using {@link #endArray()}.\n+ *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n+ *       Write each of the object's properties by alternating calls to\n+ *       {@link #name} with the property's value. Write property values with the\n+ *       appropriate {@link #value} method or by nesting other objects or arrays.\n+ *       Finally close the object using {@link #endObject()}.\n+ * </ul>\n+ *\n+ * <h3>Example</h3>\n+ * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n+ * [\n+ *   {\n+ *     \"id\": 912345678901,\n+ *     \"text\": \"How do I stream JSON in Java?\",\n+ *     \"geo\": null,\n+ *     \"user\": {\n+ *       \"name\": \"json_newb\",\n+ *       \"followers_count\": 41\n+ *      }\n+ *   },\n+ *   {\n+ *     \"id\": 912345678902,\n+ *     \"text\": \"@json_newb just use JsonWriter!\",\n+ *     \"geo\": [50.454722, -104.606667],\n+ *     \"user\": {\n+ *       \"name\": \"jesse\",\n+ *       \"followers_count\": 2\n+ *     }\n+ *   }\n+ * ]}</pre>\n+ * This code encodes the above structure: <pre>   {@code\n+ *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n+ *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n+ *     writer.setIndentSpaces(4);\n+ *     writeMessagesArray(writer, messages);\n+ *     writer.close();\n+ *   }\n+ *\n+ *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n+ *     writer.beginArray();\n+ *     for (Message message : messages) {\n+ *       writeMessage(writer, message);\n+ *     }\n+ *     writer.endArray();\n+ *   }\n+ *\n+ *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n+ *     writer.beginObject();\n+ *     writer.name(\"id\").value(message.getId());\n+ *     writer.name(\"text\").value(message.getText());\n+ *     if (message.getGeo() != null) {\n+ *       writer.name(\"geo\");\n+ *       writeDoublesArray(writer, message.getGeo());\n+ *     } else {\n+ *       writer.name(\"geo\").nullValue();\n+ *     }\n+ *     writer.name(\"user\");\n+ *     writeUser(writer, message.getUser());\n+ *     writer.endObject();\n+ *   }\n+ *\n+ *   public void writeUser(JsonWriter writer, User user) throws IOException {\n+ *     writer.beginObject();\n+ *     writer.name(\"name\").value(user.getName());\n+ *     writer.name(\"followers_count\").value(user.getFollowersCount());\n+ *     writer.endObject();\n+ *   }\n+ *\n+ *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n+ *     writer.beginArray();\n+ *     for (Double value : doubles) {\n+ *       writer.value(value);\n+ *     }\n+ *     writer.endArray();\n+ *   }}</pre>\n+ *\n+ * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n+ * Instances of this class are not thread safe. Calls that would result in a\n+ * malformed JSON string will fail with an {@link IllegalStateException}.\n+ * \n+ * @author Jesse Wilson\n+ */\n+public final class JsonWriter implements Closeable {\n+\n+  /** The output data, containing at most one top-level array or object. */\n+  private final Writer out;\n+\n+  private final List<JsonScope> stack = new ArrayList<JsonScope>();\n+  {\n+    stack.add(JsonScope.EMPTY_DOCUMENT);\n+  }\n+\n+  /**\n+   * A string containing a full set of spaces for a single level of\n+   * indentation, or null for no pretty printing.\n+   */\n+  private String indent;\n+\n+  /**\n+   * The name/value separator; either \":\" or \": \".\n+   */\n+  private String separator = \":\";\n+\n+  /**\n+   * Creates a new instance that writes a JSON-encoded stream to {@code out}.\n+   * For best performance, ensure {@link Writer} is buffered; wrapping in\n+   * {@link java.io.BufferedWriter BufferedWriter} if necessary.\n+   */\n+  public JsonWriter(Writer out) {\n+    if (out == null) {\n+      throw new NullPointerException(\"out == null\");\n+    }\n+    this.out = out;\n+  }\n+\n+  /**\n+   * Sets the indentation string to be repeated for each level of indentation\n+   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n+   * will be compact. Otherwise the encoded document will be more\n+   * human-readable.\n+   *\n+   * @param indent a string containing only whitespace.\n+   */\n+  public void setIndent(String indent) {\n+    if (indent.isEmpty()) {\n+      this.indent = null;\n+      this.separator = \":\";\n+    } else {\n+      this.indent = indent;\n+      this.separator = \": \";\n+    }\n+  }\n+\n+  /**\n+   * Begins encoding a new array. Each call to this method must be paired with\n+   * a call to {@link #endArray}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter beginArray() throws IOException {\n+    return open(JsonScope.EMPTY_ARRAY, \"[\");\n+  }\n+\n+  /**\n+   * Ends encoding the current array.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter endArray() throws IOException {\n+    return close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, \"]\");\n+  }\n+\n+  /**\n+   * Begins encoding a new object. Each call to this method must be paired\n+   * with a call to {@link #endObject}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter beginObject() throws IOException {\n+    return open(JsonScope.EMPTY_OBJECT, \"{\");\n+  }\n+\n+  /**\n+   * Ends encoding the current object.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter endObject() throws IOException {\n+    return close(JsonScope.EMPTY_OBJECT, JsonScope.NONEMPTY_OBJECT, \"}\");\n+  }\n+\n+  /**\n+   * Enters a new scope by appending any necessary whitespace and the given\n+   * bracket.\n+   */\n+  private JsonWriter open(JsonScope empty, String openBracket) throws IOException {\n+    beforeValue(true);\n+    stack.add(empty);\n+    out.write(openBracket);\n+    return this;\n+  }\n+\n+  /**\n+   * Closes the current scope by appending any necessary whitespace and the\n+   * given bracket.\n+   */\n+  private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)\n+      throws IOException {\n+    JsonScope context = peek();\n+    if (context != nonempty && context != empty) {\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+\n+    stack.remove(stack.size() - 1);\n+    if (context == nonempty) {\n+      newline();\n+    }\n+    out.write(closeBracket);\n+    return this;\n+  }\n+\n+  /**\n+   * Returns the value on the top of the stack.\n+   */\n+  private JsonScope peek() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  /**\n+   * Replace the value on the top of the stack with the given value.\n+   */\n+  private void replaceTop(JsonScope topOfStack) {\n+    stack.set(stack.size() - 1, topOfStack);\n+  }\n+\n+  /**\n+   * Encodes the property name.\n+   *\n+   * @param name the name of the forthcoming value. May not be null.\n+   * @return this writer.\n+   */\n+  public JsonWriter name(String name) throws IOException {\n+    if (name == null) {\n+      throw new NullPointerException(\"name == null\");\n+    }\n+    beforeName();\n+    string(name);\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value the literal string value, or null to encode a null literal.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(String value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+    beforeValue(false);\n+    string(value);\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code null}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter nullValue() throws IOException {\n+    beforeValue(false);\n+    out.write(\"null\");\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter value(boolean value) throws IOException {\n+    beforeValue(false);\n+    out.write(value ? \"true\" : \"false\");\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n+   *     {@link Double#isInfinite() infinities}.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(double value) throws IOException {\n+    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n+    }\n+    beforeValue(false);\n+    out.append(Double.toString(value));\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @return this writer.\n+   */\n+  public JsonWriter value(long value) throws IOException {\n+    beforeValue(false);\n+    out.write(Long.toString(value));\n+    return this;\n+  }\n+\n+  /**\n+   * Encodes {@code value}.\n+   *\n+   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n+   *     {@link Double#isInfinite() infinities}.\n+   * @return this writer.\n+   */\n+  public JsonWriter value(Number value) throws IOException {\n+    if (value == null) {\n+      return nullValue();\n+    }\n+\n+    String string = value.toString();\n+    if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\n+      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n+    }\n+    beforeValue(false);\n+    out.append(string);\n+    return this;\n+  }\n+\n+  /**\n+   * Ensures all buffered data is written to the underlying {@link Writer}\n+   * and flushes that writer.\n+   */\n+  public void flush() throws IOException {\n+    out.flush();\n+  }\n+\n+  /**\n+   * Flushes and closes this writer and the underlying {@link Writer}.\n+   *\n+   * @throws IOException if the JSON document is incomplete.\n+   */\n+  public void close() throws IOException {\n+    out.close();\n+\n+    if (peek() != JsonScope.NONEMPTY_DOCUMENT) {\n+      throw new IOException(\"Incomplete document\");\n+    }\n+  }\n+\n+  private void string(String value) throws IOException {\n+    out.write(\"\\\"\");\n+    for (int i = 0, length = value.length(); i < length; i++) {\n+      char c = value.charAt(i);\n+\n+      /*\n+       * From RFC 4627, \"All Unicode characters may be placed within the\n+       * quotation marks except for the characters that must be escaped:\n+       * quotation mark, reverse solidus, and the control characters\n+       * (U+0000 through U+001F).\"\n+       */\n+      switch (c) {\n+      case '\"':\n+      case '\\\\':\n+      case '/':\n+        out.write('\\\\');\n+        out.write(c);\n+        break;\n+\n+      case '\\t':\n+        out.write(\"\\\\t\");\n+        break;\n+\n+      case '\\b':\n+        out.write(\"\\\\b\");\n+        break;\n+\n+      case '\\n':\n+        out.write(\"\\\\n\");\n+        break;\n+\n+      case '\\r':\n+        out.write(\"\\\\r\");\n+        break;\n+\n+      case '\\f':\n+        out.write(\"\\\\f\");\n+        break;\n+\n+      default:\n+        if (c <= 0x1F) {\n+          out.write(String.format(\"\\\\u%04x\", (int) c));\n+        } else {\n+          out.write(c);\n+        }\n+        break;\n+      }\n+\n+    }\n+    out.write(\"\\\"\");\n+  }\n+\n+  private void newline() throws IOException {\n+    if (indent == null) {\n+      return;\n+    }\n+\n+    out.write(\"\\n\");\n+    for (int i = 1; i < stack.size(); i++) {\n+      out.write(indent);\n+    }\n+  }\n+\n+  /**\n+   * Inserts any necessary separators and whitespace before a name. Also\n+   * adjusts the stack to expect the name's value.\n+   */\n+  private void beforeName() throws IOException {\n+    JsonScope context = peek();\n+    if (context == JsonScope.NONEMPTY_OBJECT) { // first in object\n+      out.write(',');\n+    } else if (context != JsonScope.EMPTY_OBJECT) { // not in an object!\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+    newline();\n+    replaceTop(JsonScope.DANGLING_NAME);\n+  }\n+\n+  /**\n+   * Inserts any necessary separators and whitespace before a literal value,\n+   * inline array, or inline object. Also adjusts the stack to expect either a\n+   * closing bracket or another element.\n+   *\n+   * @param root true if the value is a new array or object, the two values\n+   *     permitted as top-level elements.\n+   */\n+  private void beforeValue(boolean root) throws IOException {\n+    switch (peek()) {\n+    case EMPTY_DOCUMENT: // first in document\n+      if (!root) {\n+        throw new IllegalStateException(\n+            \"JSON must start with an array or an object.\");\n+      }\n+      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n+      break;\n+\n+    case EMPTY_ARRAY: // first in array\n+      replaceTop(JsonScope.NONEMPTY_ARRAY);\n+      newline();\n+      break;\n+\n+    case NONEMPTY_ARRAY: // another in array\n+      out.append(',');\n+      newline();\n+      break;\n+\n+    case DANGLING_NAME: // value for name\n+      out.append(separator);\n+      replaceTop(JsonScope.NONEMPTY_OBJECT);\n+      break;\n+\n+    case NONEMPTY_DOCUMENT:\n+        throw new IllegalStateException(\n+            \"JSON must have only one top-level value.\");\n+\n+    default:\n+      throw new IllegalStateException(\"Nesting problem: \" + stack);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+public final class JsonReaderTest extends TestCase {\n+\n+  public void testReadArray() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true, true]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(true, reader.nextBoolean());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testReadEmptyArray() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[]\"));\n+    reader.beginArray();\n+    assertFalse(reader.hasNext());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testReadObject() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\n+        \"{\\\"a\\\": \\\"android\\\", \\\"b\\\": \\\"banana\\\"}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(\"android\", reader.nextString());\n+    assertEquals(\"b\", reader.nextName());\n+    assertEquals(\"banana\", reader.nextString());\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testReadEmptyObject() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{}\"));\n+    reader.beginObject();\n+    assertFalse(reader.hasNext());\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testSkipObject() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\n+        \"{\\\"a\\\": { \\\"c\\\": [], \\\"d\\\": [true, true, {}] }, \\\"b\\\": \\\"banana\\\"}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    reader.skipValue();\n+    assertEquals(\"b\", reader.nextName());\n+    reader.skipValue();\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testHelloWorld() throws IOException {\n+    String json = \"{\\n\" +\n+        \"   \\\"hello\\\": true,\\n\" +\n+        \"   \\\"foo\\\": [\\\"world\\\"]\\n\" +\n+        \"}\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginObject();\n+    assertEquals(\"hello\", reader.nextName());\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(\"foo\", reader.nextName());\n+    reader.beginArray();\n+    assertEquals(\"world\", reader.nextString());\n+    reader.endArray();\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testNulls() {\n+    try {\n+      new JsonReader(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testEmptyString() throws IOException {\n+    try {\n+      new JsonReader(new StringReader(\"\")).beginArray();\n+    } catch (IOException expected) {\n+    }\n+    try {\n+      new JsonReader(new StringReader(\"\")).beginObject();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testNoTopLevelObject() throws IOException {\n+    try {\n+      new JsonReader(new StringReader(\"true\")).nextBoolean();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testCharacterUnescaping() throws IOException {\n+    String json = \"[\\\"a\\\",\"\n+        + \"\\\"a\\\\\\\"\\\",\"\n+        + \"\\\"\\\\\\\"\\\",\"\n+        + \"\\\":\\\",\"\n+        + \"\\\",\\\",\"\n+        + \"\\\"\\\\b\\\",\"\n+        + \"\\\"\\\\f\\\",\"\n+        + \"\\\"\\\\n\\\",\"\n+        + \"\\\"\\\\r\\\",\"\n+        + \"\\\"\\\\t\\\",\"\n+        + \"\\\" \\\",\"\n+        + \"\\\"\\\\\\\\\\\",\"\n+        + \"\\\"{\\\",\"\n+        + \"\\\"}\\\",\"\n+        + \"\\\"[\\\",\"\n+        + \"\\\"]\\\",\"\n+        + \"\\\"\\\\u0000\\\",\"\n+        + \"\\\"\\\\u0019\\\",\"\n+        + \"\\\"\\\\u20AC\\\"\"\n+        + \"]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    assertEquals(\"a\", reader.nextString());\n+    assertEquals(\"a\\\"\", reader.nextString());\n+    assertEquals(\"\\\"\", reader.nextString());\n+    assertEquals(\":\", reader.nextString());\n+    assertEquals(\",\", reader.nextString());\n+    assertEquals(\"\\b\", reader.nextString());\n+    assertEquals(\"\\f\", reader.nextString());\n+    assertEquals(\"\\n\", reader.nextString());\n+    assertEquals(\"\\r\", reader.nextString());\n+    assertEquals(\"\\t\", reader.nextString());\n+    assertEquals(\" \", reader.nextString());\n+    assertEquals(\"\\\\\", reader.nextString());\n+    assertEquals(\"{\", reader.nextString());\n+    assertEquals(\"}\", reader.nextString());\n+    assertEquals(\"[\", reader.nextString());\n+    assertEquals(\"]\", reader.nextString());\n+    assertEquals(\"\\0\", reader.nextString());\n+    assertEquals(\"\\u0019\", reader.nextString());\n+    assertEquals(\"\\u20AC\", reader.nextString());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testIntegersWithFractionalPartSpecified() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[1.0,1.0,1.0]\"));\n+    reader.beginArray();\n+    assertEquals(1.0, reader.nextDouble());\n+    assertEquals(1, reader.nextInt());\n+    assertEquals(1L, reader.nextLong());\n+  }\n+\n+  public void testDoubles() throws IOException {\n+    String json = \"[-0.0,\"\n+        + \"1.0,\"\n+        + \"1.7976931348623157E308,\"\n+        + \"4.9E-324,\"\n+        + \"0.0,\"\n+        + \"-0.5,\"\n+        + \"2.2250738585072014E-308,\"\n+        + \"3.141592653589793,\"\n+        + \"2.718281828459045]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    assertEquals(-0.0, reader.nextDouble());\n+    assertEquals(1.0, reader.nextDouble());\n+    assertEquals(1.7976931348623157E308, reader.nextDouble());\n+    assertEquals(4.9E-324, reader.nextDouble());\n+    assertEquals(0.0, reader.nextDouble());\n+    assertEquals(-0.5, reader.nextDouble());\n+    assertEquals(2.2250738585072014E-308, reader.nextDouble());\n+    assertEquals(3.141592653589793, reader.nextDouble());\n+    assertEquals(2.718281828459045, reader.nextDouble());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testStrictNonFiniteDoubles() throws IOException {\n+    String json = \"[NaN]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    try {\n+      reader.nextDouble();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+  }\n+\n+  public void testLenientNonFiniteDoubles() throws IOException {\n+    String json = \"[NaN, -Infinity, Infinity]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertTrue(Double.isNaN(reader.nextDouble()));\n+    assertEquals(Double.NEGATIVE_INFINITY, reader.nextDouble());\n+    assertEquals(Double.POSITIVE_INFINITY, reader.nextDouble());\n+    reader.endArray();\n+  }\n+\n+  public void testLongs() throws IOException {\n+    String json = \"[0,0,0,\"\n+        + \"1,1,1,\"\n+        + \"-1,-1,-1,\"\n+        + \"-9223372036854775808,\"\n+        + \"9223372036854775807]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    assertEquals(0L, reader.nextLong());\n+    assertEquals(0, reader.nextInt());\n+    assertEquals(0.0, reader.nextDouble());\n+    assertEquals(1L, reader.nextLong());\n+    assertEquals(1, reader.nextInt());\n+    assertEquals(1.0, reader.nextDouble());\n+    assertEquals(-1L, reader.nextLong());\n+    assertEquals(-1, reader.nextInt());\n+    assertEquals(-1.0, reader.nextDouble());\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(Long.MIN_VALUE, reader.nextLong());\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(Long.MAX_VALUE, reader.nextLong());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  /**\n+   * This test fails because there's no double for 9223372036854775806, and\n+   * our long parsing uses Double.parseDouble() for fractional values.\n+   */\n+  public void testHighPrecisionLong() throws IOException {\n+    String json = \"[9223372036854775806.000]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    assertEquals(9223372036854775806L, reader.nextLong());\n+    reader.endArray();\n+  }\n+\n+  public void testNumberWithOctalPrefix() throws IOException {\n+    String json = \"[01]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    try {\n+      reader.nextLong();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    try {\n+      reader.nextDouble();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(\"01\", reader.nextString());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testBooleans() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true,false]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(false, reader.nextBoolean());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testMixedCaseLiterals() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[True,TruE,False,FALSE,NULL,nulL]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(false, reader.nextBoolean());\n+    assertEquals(false, reader.nextBoolean());\n+    reader.nextNull();\n+    reader.nextNull();\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testMissingValue() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testPrematureEndOfInput() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":true,\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(true, reader.nextBoolean());\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testPrematurelyClosed() throws IOException {\n+    try {\n+      JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":[]}\"));\n+      reader.beginObject();\n+      reader.close();\n+      reader.nextName();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+\n+    try {\n+      JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":[]}\"));\n+      reader.close();\n+      reader.beginObject();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+\n+    try {\n+      JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":true}\"));\n+      reader.beginObject();\n+      reader.nextName();\n+      reader.peek();\n+      reader.close();\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testNextFailuresDoNotAdvance() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":true}\"));\n+    reader.beginObject();\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    assertEquals(\"a\", reader.nextName());\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.beginArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.endArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.beginObject();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.endObject();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    assertEquals(true, reader.nextBoolean());\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.beginArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    try {\n+      reader.endArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+    reader.close();\n+  }\n+\n+  public void testStringNullIsNotNull() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[\\\"null\\\"]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextNull();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testNullLiteralIsNotAString() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[null]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testStrictNameValueSeparator() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\"=true}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"{\\\"a\\\"=>true}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientNameValueSeparator() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\"=true}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(true, reader.nextBoolean());\n+\n+    reader = new JsonReader(new StringReader(\"{\\\"a\\\"=>true}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(true, reader.nextBoolean());\n+  }\n+\n+  public void testStrictComments() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[// comment \\n true]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"[# comment \\n true]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"[/* comment */ true]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientComments() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[// comment \\n true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+\n+    reader = new JsonReader(new StringReader(\"[# comment \\n true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+\n+    reader = new JsonReader(new StringReader(\"[/* comment */ true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+  }\n+\n+  public void testStrictUnquotedNames() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{a:true}\"));\n+    reader.beginObject();\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientUnquotedNames() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{a:true}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+  }\n+\n+  public void testStrictSingleQuotedNames() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{'a':true}\"));\n+    reader.beginObject();\n+    try {\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientSingleQuotedNames() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{'a':true}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+  }\n+\n+  public void testStrictUnquotedStrings() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[a]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientUnquotedStrings() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[a]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(\"a\", reader.nextString());\n+  }\n+\n+  public void testStrictSingleQuotedStrings() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"['a']\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextString();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientSingleQuotedStrings() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"['a']\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(\"a\", reader.nextString());\n+  }\n+\n+  public void testStrictSemicolonDelimitedArray() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true;true]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextBoolean();\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientSemicolonDelimitedArray() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true;true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(true, reader.nextBoolean());\n+  }\n+\n+  public void testStrictSemicolonDelimitedNameValuePair() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    try {\n+      reader.nextBoolean();\n+      reader.nextName();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientSemicolonDelimitedNameValuePair() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":true;\\\"b\\\":true}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(\"b\", reader.nextName());\n+  }\n+\n+  public void testStrictUnnecessaryArraySeparators() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true,,true]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    try {\n+      reader.nextNull();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"[,true]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextNull();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"[true,]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    try {\n+      reader.nextNull();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+\n+    reader = new JsonReader(new StringReader(\"[,]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextNull();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientUnnecessaryArraySeparators() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true,,true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    reader.nextNull();\n+    assertEquals(true, reader.nextBoolean());\n+    reader.endArray();\n+\n+    reader = new JsonReader(new StringReader(\"[,true]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.nextNull();\n+    assertEquals(true, reader.nextBoolean());\n+    reader.endArray();\n+\n+    reader = new JsonReader(new StringReader(\"[true,]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    reader.nextNull();\n+    reader.endArray();\n+\n+    reader = new JsonReader(new StringReader(\"[,]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.nextNull();\n+    reader.nextNull();\n+    reader.endArray();\n+  }\n+\n+  public void testStrictMultipleTopLevelValues() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[] []\"));\n+    reader.beginArray();\n+    reader.endArray();\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientMultipleTopLevelValues() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[] true {}\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.endArray();\n+    assertEquals(true, reader.nextBoolean());\n+    reader.beginObject();\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testStrictTopLevelValueType() {\n+    JsonReader reader = new JsonReader(new StringReader(\"true\"));\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientTopLevelValueType() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"true\"));\n+    reader.setLenient(true);\n+    assertEquals(true, reader.nextBoolean());\n+  }\n+\n+  public void testStrictNonExecutePrefix() {\n+    JsonReader reader = new JsonReader(new StringReader(\")]}'\\n []\"));\n+    try {\n+      reader.beginArray();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientNonExecutePrefix() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\")]}'\\n []\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testLenientNonExecutePrefixWithLeadingWhitespace() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"\\r\\n \\t)]}'\\n []\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testLenientPartialNonExecutePrefix() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\")]}' []\"));\n+    reader.setLenient(true);\n+    assertEquals(\")\", reader.nextString()); // lenient is almost too lenient!\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/stream/JsonWriterTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+public final class JsonWriterTest extends TestCase {\n+\n+  public void testWrongTopLevelType() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    try {\n+      jsonWriter.value(\"a\");\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testTwoNames() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\");\n+    try {\n+      jsonWriter.name(\"a\");\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testNameWithoutValue() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\");\n+    try {\n+      jsonWriter.endObject();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testValueWithoutName() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    try {\n+      jsonWriter.value(true);\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testMultipleTopLevelValues() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray().endArray();\n+    try {\n+      jsonWriter.beginArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testBadNestingObject() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.beginObject();\n+    try {\n+      jsonWriter.endArray();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testBadNestingArray() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.beginArray();\n+    try {\n+      jsonWriter.endObject();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+  }\n+\n+  public void testNullName() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    try {\n+      jsonWriter.name(null);\n+      fail();\n+    } catch (NullPointerException expected) {\n+    }\n+  }\n+\n+  public void testNullStringValue() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\");\n+    jsonWriter.value((String) null);\n+    jsonWriter.endObject();\n+    assertEquals(\"{\\\"a\\\":null}\", stringWriter.toString());\n+  }\n+\n+  public void testNonFiniteDoubles() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    try {\n+      jsonWriter.value(Double.NaN);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      jsonWriter.value(Double.NEGATIVE_INFINITY);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      jsonWriter.value(Double.POSITIVE_INFINITY);\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testNonFiniteBoxedDoubles() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    try {\n+      jsonWriter.value(new Double(Double.NaN));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      jsonWriter.value(new Double(Double.NEGATIVE_INFINITY));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+    try {\n+      jsonWriter.value(new Double(Double.POSITIVE_INFINITY));\n+      fail();\n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testDoubles() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(-0.0);\n+    jsonWriter.value(1.0);\n+    jsonWriter.value(Double.MAX_VALUE);\n+    jsonWriter.value(Double.MIN_VALUE);\n+    jsonWriter.value(0.0);\n+    jsonWriter.value(-0.5);\n+    jsonWriter.value(Double.MIN_NORMAL);\n+    jsonWriter.value(Math.PI);\n+    jsonWriter.value(Math.E);\n+    jsonWriter.endArray();\n+    jsonWriter.close();\n+    assertEquals(\"[-0.0,\"\n+        + \"1.0,\"\n+        + \"1.7976931348623157E308,\"\n+        + \"4.9E-324,\"\n+        + \"0.0,\"\n+        + \"-0.5,\"\n+        + \"2.2250738585072014E-308,\"\n+        + \"3.141592653589793,\"\n+        + \"2.718281828459045]\", stringWriter.toString());\n+  }\n+\n+  public void testLongs() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(0);\n+    jsonWriter.value(1);\n+    jsonWriter.value(-1);\n+    jsonWriter.value(Long.MIN_VALUE);\n+    jsonWriter.value(Long.MAX_VALUE);\n+    jsonWriter.endArray();\n+    jsonWriter.close();\n+    assertEquals(\"[0,\"\n+        + \"1,\"\n+        + \"-1,\"\n+        + \"-9223372036854775808,\"\n+        + \"9223372036854775807]\", stringWriter.toString());\n+  }\n+\n+  public void testNumbers() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(new BigInteger(\"0\"));\n+    jsonWriter.value(new BigInteger(\"9223372036854775808\"));\n+    jsonWriter.value(new BigInteger(\"-9223372036854775809\"));\n+    jsonWriter.value(new BigDecimal(\"3.141592653589793238462643383\"));\n+    jsonWriter.endArray();\n+    jsonWriter.close();\n+    assertEquals(\"[0,\"\n+        + \"9223372036854775808,\"\n+        + \"-9223372036854775809,\"\n+        + \"3.141592653589793238462643383]\", stringWriter.toString());\n+  }\n+\n+  public void testBooleans() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(true);\n+    jsonWriter.value(false);\n+    jsonWriter.endArray();\n+    assertEquals(\"[true,false]\", stringWriter.toString());\n+  }\n+\n+  public void testNulls() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.nullValue();\n+    jsonWriter.endArray();\n+    assertEquals(\"[null]\", stringWriter.toString());\n+  }\n+\n+  public void testStrings() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.value(\"a\");\n+    jsonWriter.value(\"a\\\"\");\n+    jsonWriter.value(\"\\\"\");\n+    jsonWriter.value(\":\");\n+    jsonWriter.value(\",\");\n+    jsonWriter.value(\"\\b\");\n+    jsonWriter.value(\"\\f\");\n+    jsonWriter.value(\"\\n\");\n+    jsonWriter.value(\"\\r\");\n+    jsonWriter.value(\"\\t\");\n+    jsonWriter.value(\" \");\n+    jsonWriter.value(\"\\\\\");\n+    jsonWriter.value(\"{\");\n+    jsonWriter.value(\"}\");\n+    jsonWriter.value(\"[\");\n+    jsonWriter.value(\"]\");\n+    jsonWriter.value(\"\\0\");\n+    jsonWriter.value(\"\\u0019\");\n+    jsonWriter.endArray();\n+    assertEquals(\"[\\\"a\\\",\"\n+        + \"\\\"a\\\\\\\"\\\",\"\n+        + \"\\\"\\\\\\\"\\\",\"\n+        + \"\\\":\\\",\"\n+        + \"\\\",\\\",\"\n+        + \"\\\"\\\\b\\\",\"\n+        + \"\\\"\\\\f\\\",\"\n+        + \"\\\"\\\\n\\\",\"\n+        + \"\\\"\\\\r\\\",\"\n+        + \"\\\"\\\\t\\\",\"\n+        + \"\\\" \\\",\"\n+        + \"\\\"\\\\\\\\\\\",\"\n+        + \"\\\"{\\\",\"\n+        + \"\\\"}\\\",\"\n+        + \"\\\"[\\\",\"\n+        + \"\\\"]\\\",\"\n+        + \"\\\"\\\\u0000\\\",\"\n+        + \"\\\"\\\\u0019\\\"]\", stringWriter.toString());\n+  }\n+\n+  public void testEmptyArray() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.endArray();\n+    assertEquals(\"[]\", stringWriter.toString());\n+  }\n+\n+  public void testEmptyObject() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.endObject();\n+    assertEquals(\"{}\", stringWriter.toString());\n+  }\n+\n+  public void testObjectsInArrays() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginArray();\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\").value(5);\n+    jsonWriter.name(\"b\").value(false);\n+    jsonWriter.endObject();\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"c\").value(6);\n+    jsonWriter.name(\"d\").value(true);\n+    jsonWriter.endObject();\n+    jsonWriter.endArray();\n+    assertEquals(\"[{\\\"a\\\":5,\\\"b\\\":false},\"\n+        + \"{\\\"c\\\":6,\\\"d\\\":true}]\", stringWriter.toString());\n+  }\n+\n+  public void testArraysInObjects() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\");\n+    jsonWriter.beginArray();\n+    jsonWriter.value(5);\n+    jsonWriter.value(false);\n+    jsonWriter.endArray();\n+    jsonWriter.name(\"b\");\n+    jsonWriter.beginArray();\n+    jsonWriter.value(6);\n+    jsonWriter.value(true);\n+    jsonWriter.endArray();\n+    jsonWriter.endObject();\n+    assertEquals(\"{\\\"a\\\":[5,false],\"\n+        + \"\\\"b\\\":[6,true]}\", stringWriter.toString());\n+  }\n+\n+  public void testDeepNestingArrays() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    for (int i = 0; i < 20; i++) {\n+      jsonWriter.beginArray();\n+    }\n+    for (int i = 0; i < 20; i++) {\n+      jsonWriter.endArray();\n+    }\n+    assertEquals(\"[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]\", stringWriter.toString());\n+  }\n+\n+  public void testDeepNestingObjects() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    for (int i = 0; i < 20; i++) {\n+      jsonWriter.name(\"a\");\n+      jsonWriter.beginObject();\n+    }\n+    for (int i = 0; i < 20; i++) {\n+      jsonWriter.endObject();\n+    }\n+    jsonWriter.endObject();\n+    assertEquals(\"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":\"\n+        + \"{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\\\"a\\\":{\"\n+        + \"}}}}}}}}}}}}}}}}}}}}}\", stringWriter.toString());\n+  }\n+\n+  public void testRepeatedName() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\").value(true);\n+    jsonWriter.name(\"a\").value(false);\n+    jsonWriter.endObject();\n+    // JsonWriter doesn't attempt to detect duplicate names\n+    assertEquals(\"{\\\"a\\\":true,\\\"a\\\":false}\", stringWriter.toString());\n+  }\n+\n+  public void testPrettyPrintObject() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.setIndent(\"   \");\n+\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\").value(true);\n+    jsonWriter.name(\"b\").value(false);\n+    jsonWriter.name(\"c\").value(5.0);\n+    jsonWriter.name(\"e\").nullValue();\n+    jsonWriter.name(\"f\").beginArray();\n+    jsonWriter.value(6.0);\n+    jsonWriter.value(7.0);\n+    jsonWriter.endArray();\n+    jsonWriter.name(\"g\").beginObject();\n+    jsonWriter.name(\"h\").value(8.0);\n+    jsonWriter.name(\"i\").value(9.0);\n+    jsonWriter.endObject();\n+    jsonWriter.endObject();\n+\n+    String expected = \"{\\n\"\n+        + \"   \\\"a\\\": true,\\n\"\n+        + \"   \\\"b\\\": false,\\n\"\n+        + \"   \\\"c\\\": 5.0,\\n\"\n+        + \"   \\\"e\\\": null,\\n\"\n+        + \"   \\\"f\\\": [\\n\"\n+        + \"      6.0,\\n\"\n+        + \"      7.0\\n\"\n+        + \"   ],\\n\"\n+        + \"   \\\"g\\\": {\\n\"\n+        + \"      \\\"h\\\": 8.0,\\n\"\n+        + \"      \\\"i\\\": 9.0\\n\"\n+        + \"   }\\n\"\n+        + \"}\";\n+    assertEquals(expected, stringWriter.toString());\n+  }\n+\n+  public void testPrettyPrintArray() throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+    jsonWriter.setIndent(\"   \");\n+\n+    jsonWriter.beginArray();\n+    jsonWriter.value(true);\n+    jsonWriter.value(false);\n+    jsonWriter.value(5.0);\n+    jsonWriter.nullValue();\n+    jsonWriter.beginObject();\n+    jsonWriter.name(\"a\").value(6.0);\n+    jsonWriter.name(\"b\").value(7.0);\n+    jsonWriter.endObject();\n+    jsonWriter.beginArray();\n+    jsonWriter.value(8.0);\n+    jsonWriter.value(9.0);\n+    jsonWriter.endArray();\n+    jsonWriter.endArray();\n+\n+    String expected = \"[\\n\"\n+        + \"   true,\\n\"\n+        + \"   false,\\n\"\n+        + \"   5.0,\\n\"\n+        + \"   null,\\n\"\n+        + \"   {\\n\"\n+        + \"      \\\"a\\\": 6.0,\\n\"\n+        + \"      \\\"b\\\": 7.0\\n\"\n+        + \"   },\\n\"\n+        + \"   [\\n\"\n+        + \"      8.0,\\n\"\n+        + \"      9.0\\n\"\n+        + \"   ]\\n\"\n+        + \"]\";\n+    assertEquals(expected, stringWriter.toString());\n+  }\n+}", "timestamp": 1282812242, "metainfo": ""}