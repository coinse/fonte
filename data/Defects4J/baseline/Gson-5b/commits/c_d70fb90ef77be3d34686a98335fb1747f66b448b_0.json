{"sha": "d70fb90ef77be3d34686a98335fb1747f66b448b", "log": "Added methods to convert to JsonElement in TypeAdapter. Using lenient mode while working with Gson. Handling nulls while invoking legacy Gson type adapters.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import java.util.List;\n import java.util.Map;\n \n+import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapter;\n import com.google.gson.internal.bind.MiniGson;\n   public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n     // Serialize 'src' to JSON, then deserialize that to a JSON tree.\n     TypeAdapter adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));\n-    StringWriter writer = new StringWriter();\n-    try {\n-      adapter.write(writer, src);\n-    } catch (IOException e) {\n-      throw new RuntimeException(e);\n-    }\n-    return Streams.parse(new JsonReader(new StringReader(writer.toString())));\n+    return adapter.toJsonElement(src);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java\n import java.io.StringWriter;\n import java.lang.reflect.Type;\n \n+import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.MiniGson;\n import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n           // TODO: handle if serializer is null\n           throw new UnsupportedOperationException();\n         }\n+        if (value == null) {\n+          writer.nullValue();\n+          return;\n+        }\n         JsonElement element = serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n         Streams.write(element, serializeNulls, writer);\n       }\n     return new JsonSerializationContext() {\n       @Override\n       JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType, boolean defaultOnly) {\n-        try {\n-          TypeToken typeToken = TypeToken.get(typeOfSrc);\n-          String json = miniGson.getAdapter(typeToken).toJson(src);\n-          JsonReader jsonReader = new JsonReader(new StringReader(json));\n-          jsonReader.setLenient(true);\n-          return Streams.parse(jsonReader);\n-        } catch (IOException e) {\n-          throw new RuntimeException(e);\n-        }\n+        TypeToken typeToken = TypeToken.get(typeOfSrc);\n+        return miniGson.getAdapter(typeToken).toJsonElement(src);\n       }\n     };\n   }\n     return new JsonDeserializationContext() {\n       @Override\n       public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n-        try {\n-          TypeToken typeToken = TypeToken.get(typeOfT);\n-          StringWriter stringWriter = new StringWriter();\n-          JsonWriter jsonWriter = new JsonWriter(stringWriter);\n-          jsonWriter.setLenient(true);\n-          Streams.write(json, serializeNulls, jsonWriter);\n-          Object target = miniGson.getAdapter(typeToken).fromJson(stringWriter.toString());\n-          return (T) target;\n-        } catch (IOException e) {\n-          throw new JsonParseException(e);\n-        }\n+        TypeToken typeToken = TypeToken.get(typeOfT);\n+        return (T) miniGson.getAdapter(typeToken).fromJsonElement(json);\n       }\n     };\n   }\n--- a/gson/src/main/java/com/google/gson/JsonElement.java\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.Streams;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.io.StringWriter;\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n  */\n package com.google.gson;\n \n+import com.google.gson.internal.Streams;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.MalformedJsonException;\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.LazilyParsedNumber;\n+\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n--- a/gson/src/main/java/com/google/gson/JsonStreamParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n+import com.google.gson.internal.Streams;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.MalformedJsonException;\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.internal;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * This class holds a number value that is lazily converted to a specific number type\n+ *\n+ * @author Inderjeet Singh\n+ */\n+@SuppressWarnings(\"serial\")\n+public final class LazilyParsedNumber extends Number {\n+  private final String value;\n+\n+  public LazilyParsedNumber(String value) {\n+    this.value = value;\n+  }\n+\n+  @Override\n+  public int intValue() {\n+    try {\n+      return Integer.parseInt(value);\n+    } catch (NumberFormatException e) {\n+      try {\n+        return (int) Long.parseLong(value);\n+      } catch (NumberFormatException nfe) {\n+        return new BigInteger(value).intValue(); \n+      }\n+    }\n+  }\n+\n+  @Override\n+  public long longValue() {\n+    try {\n+      return Long.parseLong(value);\n+    } catch (NumberFormatException e) {\n+      return new BigInteger(value).longValue(); \n+    }\n+  }\n+\n+  @Override\n+  public float floatValue() {\n+    return Float.parseFloat(value);\n+  }\n+\n+  @Override\n+  public double doubleValue() {\n+    return Double.parseDouble(value);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return value;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonIOException;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import com.google.gson.stream.MalformedJsonException;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Map;\n+\n+/**\n+ * Reads and writes GSON parse trees over streams.\n+ */\n+public final class Streams {\n+\n+  /**\n+   * Takes a reader in any state and returns the next value as a JsonElement.\n+   */\n+  public static JsonElement parse(JsonReader reader) throws JsonParseException {\n+    boolean isEmpty = true;\n+    try {\n+      reader.peek();\n+      isEmpty = false;\n+      return parseRecursive(reader);\n+    } catch (EOFException e) {\n+      /*\n+       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\n+       * empty documents instead of throwing.\n+       */\n+      if (isEmpty) {\n+        return JsonNull.INSTANCE;\n+      }\n+      throw new JsonIOException(e);\n+    } catch (MalformedJsonException e) {\n+      throw new JsonSyntaxException(e);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    } catch (NumberFormatException e) {\n+      throw new JsonSyntaxException(e);\n+    }\n+  }\n+\n+  private static JsonElement parseRecursive(JsonReader reader) throws IOException {\n+    switch (reader.peek()) {\n+    case STRING:\n+      return new JsonPrimitive(reader.nextString());\n+    case NUMBER:\n+      String number = reader.nextString();\n+      return new JsonPrimitive(new LazilyParsedNumber(number));\n+    case BOOLEAN:\n+      return new JsonPrimitive(reader.nextBoolean());\n+    case NULL:\n+      reader.nextNull();\n+      return JsonNull.INSTANCE;\n+    case BEGIN_ARRAY:\n+      JsonArray array = new JsonArray();\n+      reader.beginArray();\n+      while (reader.hasNext()) {\n+        array.add(parseRecursive(reader));\n+      }\n+      reader.endArray();\n+      return array;\n+    case BEGIN_OBJECT:\n+      JsonObject object = new JsonObject();\n+      reader.beginObject();\n+      while (reader.hasNext()) {\n+        object.add(reader.nextName(), parseRecursive(reader));\n+      }\n+      reader.endObject();\n+      return object;\n+    case END_DOCUMENT:\n+    case NAME:\n+    case END_OBJECT:\n+    case END_ARRAY:\n+    default:\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+  /**\n+   * Writes the JSON element to the writer, recursively.\n+   */\n+  public static void write(JsonElement element, boolean serializeNulls, JsonWriter writer)\n+      throws IOException {\n+    if (element == null || element.isJsonNull()) {\n+      if (serializeNulls) {\n+        writer.nullValue();\n+      }\n+\n+    } else if (element.isJsonPrimitive()) {\n+      JsonPrimitive primitive = element.getAsJsonPrimitive();\n+      if (primitive.isNumber()) {\n+        writer.value(primitive.getAsNumber());\n+      } else if (primitive.isBoolean()) {\n+        writer.value(primitive.getAsBoolean());\n+      } else {\n+        writer.value(primitive.getAsString());\n+      }\n+\n+    } else if (element.isJsonArray()) {\n+      writer.beginArray();\n+      for (JsonElement e : element.getAsJsonArray()) {\n+        /* always print null when its parent element is an array! */\n+        if (e.isJsonNull()) {\n+          writer.nullValue();\n+          continue;\n+        }\n+        write(e, serializeNulls, writer);\n+      }\n+      writer.endArray();\n+\n+    } else if (element.isJsonObject()) {\n+      writer.beginObject();\n+      for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) {\n+        JsonElement value = e.getValue();\n+        if (!serializeNulls && value.isJsonNull()) {\n+          continue;\n+        }\n+        writer.name(e.getKey());\n+        write(value, serializeNulls, writer);\n+      }\n+      writer.endObject();\n+\n+    } else {\n+      throw new IllegalArgumentException(\"Couldn't write \" + element.getClass());\n+    }\n+  }\n+\n+  public static Writer writerForAppendable(Appendable appendable) {\n+    return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable);\n+  }\n+\n+  /**\n+   * Adapts an {@link Appendable} so it can be passed anywhere a {@link Writer}\n+   * is used.\n+   */\n+  private static class AppendableWriter extends Writer {\n+    private final Appendable appendable;\n+    private final CurrentWrite currentWrite = new CurrentWrite();\n+\n+    private AppendableWriter(Appendable appendable) {\n+      this.appendable = appendable;\n+    }\n+\n+    @Override public void write(char[] chars, int offset, int length) throws IOException {\n+      currentWrite.chars = chars;\n+      appendable.append(currentWrite, offset, offset + length);\n+    }\n+\n+    @Override public void write(int i) throws IOException {\n+      appendable.append((char) i);\n+    }\n+\n+    @Override public void flush() {}\n+    @Override public void close() {}\n+\n+    /**\n+     * A mutable char sequence pointing at a single char[].\n+     */\n+    static class CurrentWrite implements CharSequence {\n+      char[] chars;\n+      public int length() {\n+        return chars.length;\n+      }\n+      public char charAt(int i) {\n+        return chars[i];\n+      }\n+      public CharSequence subSequence(int start, int end) {\n+        return new String(chars, start, end - start);\n+      }\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapter.java\n \n package com.google.gson.internal.bind;\n \n-import com.google.gson.reflect.TypeToken;\n-import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.io.Reader;\n import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n \n public abstract class TypeAdapter<T> {\n   public abstract T read(JsonReader reader) throws IOException;\n     return read(reader);\n   }\n \n+  public JsonElement toJsonElement(T src) {\n+    try {\n+      StringWriter stringWriter = new StringWriter();\n+      JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+      jsonWriter.setLenient(true);\n+      write(jsonWriter, src);\n+      JsonReader reader = new JsonReader(new StringReader(stringWriter.toString()));\n+      reader.setLenient(true);\n+      return Streams.parse(reader);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  public T fromJsonElement(JsonElement json) {\n+    try {\n+      StringWriter stringWriter = new StringWriter();\n+      JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+      jsonWriter.setLenient(true);\n+      Streams.write(json, false, jsonWriter);\n+      JsonReader jsonReader = new JsonReader(new StringReader(stringWriter.toString()));\n+      jsonReader.setLenient(true);\n+      return read(jsonReader);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n   public interface Factory {\n     <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type);\n   }\n--- a/gson/src/test/java/com/google/gson/JsonParserTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java\n package com.google.gson;\n \n import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.internal.Streams;\n import com.google.gson.stream.JsonReader;\n import java.io.CharArrayReader;\n import java.io.CharArrayWriter;", "timestamp": 1312339218, "metainfo": ""}