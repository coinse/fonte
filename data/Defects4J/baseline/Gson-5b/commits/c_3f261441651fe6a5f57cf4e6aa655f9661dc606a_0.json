{"sha": "3f261441651fe6a5f57cf4e6aa655f9661dc606a", "log": "Fix date adapters to work when run in any time zone.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.MiniGson;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n+import com.google.gson.internal.bind.SqlDateTypeAdapter;\n import com.google.gson.internal.bind.TimeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n         .factory(DateTypeAdapter.FACTORY)\n         .factory(TypeAdapters.CALENDAR_FACTORY)\n         .factory(TimeTypeAdapter.FACTORY)\n-        .factory(TypeAdapters.SQL_DATE_FACTORY)\n-        .factory(TypeAdapters.SQL_TIMESTAMP_FACTORY)\n+        .factory(SqlDateTypeAdapter.FACTORY)\n+        .factory(TypeAdapters.TIMESTAMP_FACTORY)\n         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))\n         .factory(ArrayTypeAdapter.FACTORY)\n         .factory(TypeAdapters.ENUM_FACTORY)\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n import java.util.TimeZone;\n \n /**\n- * Adapter for Time. Although this class appears stateless, it is not.\n+ * Adapter for Date. Although this class appears stateless, it is not.\n  * DateFormat captures its time zone and locale when it is created, which gives\n  * this class state. DateFormat isn't thread safe either, so this class has\n  * to synchronize its read and write methods.\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+\n+/**\n+ * Adapter for java.sql.Date. Although this class appears stateless, it is not.\n+ * DateFormat captures its time zone and locale when it is created, which gives\n+ * this class state. DateFormat isn't thread safe either, so this class has\n+ * to synchronize its read and write methods.\n+ */\n+public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {\n+  public static final Factory FACTORY = new Factory() {\n+    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      return typeToken.getRawType() == java.sql.Date.class\n+          ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n+    }\n+  };\n+\n+  private final DateFormat format = new SimpleDateFormat(\"MMM d, yyyy\");\n+\n+  @Override\n+  public synchronized java.sql.Date read(JsonReader reader) throws IOException {\n+    try {\n+      final long utilDate = format.parse(reader.nextString()).getTime();\n+      return new java.sql.Date(utilDate);\n+    } catch (ParseException e) {\n+      throw new JsonSyntaxException(e);\n+    }\n+  }\n+\n+  @Override\n+  public synchronized void write(JsonWriter writer, java.sql.Date value) throws IOException {\n+    writer.value(format.format(value));\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n import java.net.URISyntaxException;\n import java.net.URL;\n import java.sql.Timestamp;\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n import java.util.BitSet;\n import java.util.Calendar;\n import java.util.Date;\n       int i = 0;\n       JsonToken tokenType = reader.peek();\n       while (tokenType != JsonToken.END_ARRAY) {\n-        boolean set = false;\n+        boolean set;\n         switch (tokenType) {\n         case NUMBER:\n           set = reader.nextInt() != 0;\n \n   public static final TypeAdapter.Factory UUID_FACTORY = newFactory(UUID.class, UUID);\n \n-  private static final class TimestampTypeAdapter extends TypeAdapter<Timestamp> {\n-    private final MiniGson context;\n-    public TimestampTypeAdapter(MiniGson context) {\n-      this.context = context;\n-    }\n-    @Override\n-    public Timestamp read(JsonReader reader) throws IOException {\n-      TypeAdapter<Date> dateTypeAdapter = context.getAdapter(Date.class);\n-      Date date = dateTypeAdapter.read(reader);\n-      return new java.sql.Timestamp(date.getTime());\n-    }\n-    @Override\n-    public void write(JsonWriter writer, Timestamp value) throws IOException {\n-      TypeAdapter<Date> dateTypeAdapter = context.getAdapter(Date.class);\n-      dateTypeAdapter.write(writer, value);\n-    }\n-  };\n-  public static final TypeAdapter.Factory SQL_TIMESTAMP_FACTORY = new TypeAdapter.Factory() {\n-    @SuppressWarnings(\"unchecked\")\n+  public static final TypeAdapter.Factory TIMESTAMP_FACTORY = new TypeAdapter.Factory() {\n+    @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n-      return typeToken.getRawType() == Timestamp.class\n-          ? (TypeAdapter<T>) new TimestampTypeAdapter(context) : null;\n-    }\n-  };\n-\n-  public static final TypeAdapter<java.sql.Date> SQL_DATE = new TypeAdapter<java.sql.Date>() {\n-    private final DateFormat format = new SimpleDateFormat(\"MMM d, yyyy\");\n-    @Override\n-    public java.sql.Date read(JsonReader reader) throws IOException {\n-      try {\n-        synchronized (format) {\n-          Date date = format.parse(reader.nextString());\n-          return new java.sql.Date(date.getTime());\n+      if (typeToken.getRawType() != Timestamp.class) {\n+        return null;\n+      }\n+\n+      final TypeAdapter<Date> dateTypeAdapter = context.getAdapter(Date.class);\n+      return (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n+        @Override public Timestamp read(JsonReader reader) throws IOException {\n+          Date date = dateTypeAdapter.read(reader);\n+          return new Timestamp(date.getTime());\n         }\n-      } catch (ParseException e) {\n-        throw new JsonSyntaxException(e);\n-      }\n-    }\n-    @Override\n-    public void write(JsonWriter writer, java.sql.Date value) throws IOException {\n-      writer.value(format.format(value));\n-    }\n-  };\n-\n-  public static final TypeAdapter.Factory SQL_DATE_FACTORY = newFactory(java.sql.Date.class, SQL_DATE);\n+\n+        @Override public void write(JsonWriter writer, Timestamp value) throws IOException {\n+          dateTypeAdapter.write(writer, value);\n+        }\n+      };\n+    }\n+  };\n \n   public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\n     private static final String YEAR = \"year\";\n       }\n     };\n   }\n+\n }", "timestamp": 1317232614, "metainfo": ""}