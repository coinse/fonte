{"sha": "ad5ff0f2d9c08fb25d821bdc038934642c3c7367", "log": "Created a wrapper for runtime type determination.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n     };\n \n     TypeAdapter.Factory excludedTypeFactory = new TypeAdapter.Factory() {\n-      @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n         Class<?> rawType = type.getRawType();\n         if (serializationExclusionStrategy.shouldSkipClass(rawType)\n             || deserializationExclusionStrategy.shouldSkipClass(rawType)) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n     }\n   };\n \n-  private final MiniGson context;\n   private final Class<E> componentType;\n   private final TypeAdapter<E> componentTypeAdapter;\n \n   public ArrayTypeAdapter(MiniGson context, TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n-    this.context = context;\n-    this.componentTypeAdapter = componentTypeAdapter;\n+    this.componentTypeAdapter =\n+      new TypeAdapterRuntimeTypeWrapper<E>(context, componentTypeAdapter, componentType);\n     this.componentType = componentType;\n   }\n \n     writer.beginArray();\n     for (int i = 0, length = Array.getLength(array); i < length; i++) {\n       final E value = (E) Array.get(array, i);\n-      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(componentType, value);\n-      TypeAdapter t = runtimeType != componentType ?\n-          context.getAdapter(TypeToken.get(runtimeType)) : componentTypeAdapter;\n-      t.write(writer, value);\n+      componentTypeAdapter.write(writer, value);\n     }\n     writer.endArray();\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n     }\n   };\n \n-  private final MiniGson context;\n-  private final Type elementType;\n   private final TypeAdapter<E> elementTypeAdapter;\n   private final Constructor<? extends Collection<E>> constructor;\n \n   public CollectionTypeAdapter(MiniGson context, Type elementType, TypeAdapter<E> elementTypeAdapter,\n       Constructor<? extends Collection<E>> constructor) {\n-    this.context = context;\n-    this.elementType = elementType;\n-    this.elementTypeAdapter = elementTypeAdapter;\n+    this.elementTypeAdapter =\n+      new TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\n     this.constructor = constructor;\n   }\n \n \n     writer.beginArray();\n     for (E element : collection) {\n-      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(elementType, element);\n-      TypeAdapter t = runtimeType != elementType ?\n-          context.getAdapter(TypeToken.get(runtimeType)) : elementTypeAdapter;\n-      t.write(writer, element);\n+      elementTypeAdapter.write(writer, element);\n     }\n     writer.endArray();\n   }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        Type declaredTypeOfField = fieldType.getType();\n-        Type resolvedTypeOfField = Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, fieldValue);\n-        TypeAdapter t = resolvedTypeOfField != declaredTypeOfField ?\n-            context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;\n+        TypeAdapter t =\n+          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.internal.bind;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+final class TypeAdapterRuntimeTypeWrapper<T> extends TypeAdapter<T> {\n+\n+  private final MiniGson context;\n+  private final TypeAdapter<T> delegate;\n+  private final Type type;\n+\n+  TypeAdapterRuntimeTypeWrapper(MiniGson context, TypeAdapter<T> delegate, Type type) {\n+    this.context = context;\n+    this.delegate = delegate;\n+    this.type = type;\n+  }\n+\n+  @Override\n+  public T read(JsonReader reader) throws IOException {\n+    return delegate.read(reader);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void write(JsonWriter writer, T value) throws IOException {\n+    Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(type, value);\n+    TypeAdapter t = runtimeType != type ?\n+        context.getAdapter(TypeToken.get(runtimeType)) : delegate;\n+    t.write(writer, value);\n+  }\n+}", "timestamp": 1312504884, "metainfo": ""}