{"sha": "796a3812791d3d2ac3d70c63f0d02a04131fe5b4", "log": "Kill GsonInternalAccess. Clients to this were all broken because nobody was ever assigning INSTANCE.", "commit": "\n--- a/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/graph/GraphTypeAdapterFactory.java\n import com.google.gson.JsonElement;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n       return null;\n     }\n \n-    final TypeAdapter<T> typeAdapter = GsonInternalAccess.INSTANCE.getNextAdapter(gson, this, type);\n+    final TypeAdapter<T> typeAdapter = gson.getNextAdapter(this, type);\n     final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\n     return new TypeAdapter<T>() {\n       @Override public void write(JsonWriter out, T value) throws IOException {\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n \n import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n-import com.google.gson.JsonIOException;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonParseException;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.bind.JsonTreeWriter;\n-import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n     final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate\n         = new LinkedHashMap<Class<?>, TypeAdapter<?>>();\n     for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\n-      TypeAdapter<?> delegate = GsonInternalAccess.INSTANCE\n-          .getNextAdapter(gson, this, TypeToken.get(entry.getValue()));\n+      TypeAdapter<?> delegate = gson.getNextAdapter(this, TypeToken.get(entry.getValue()));\n       labelToDelegate.put(entry.getKey(), delegate);\n       subtypeToDelegate.put(entry.getValue(), delegate);\n     }\n           throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n               + label + \"; did you forget to register a subtype?\");\n         }\n-        return fromJsonTree(delegate, jsonElement);\n-      }\n-\n-      // TODO: remove this when TypeAdapter.fromJsonTree() is public\n-      private T fromJsonTree(TypeAdapter<T> delegate, JsonElement jsonTree) {\n-        try {\n-          JsonReader jsonReader = new JsonTreeReader(jsonTree);\n-          jsonReader.setLenient(true);\n-          return delegate.read(jsonReader);\n-        } catch (IOException e) {\n-          throw new JsonIOException(e);\n-        }\n+        return delegate.fromJsonTree(jsonElement);\n       }\n \n       @Override public void write(JsonWriter out, T value) throws IOException {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \"; did you forget to register a subtype?\");\n         }\n-        JsonObject jsonObject = toJsonTree(delegate, value).getAsJsonObject();\n+        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\n         if (jsonObject.has(typeFieldName)) {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \" because it already defines a field named \" + typeFieldName);\n         }\n         Streams.write(clone, out);\n       }\n-\n-      // TODO: remove this when TypeAdapter.toJsonTree() is public\n-      private JsonElement toJsonTree(TypeAdapter<T> delegate, T value) {\n-        try {\n-          JsonTreeWriter jsonWriter = new JsonTreeWriter();\n-          jsonWriter.setLenient(true);\n-          delegate.write(jsonWriter, value);\n-          return jsonWriter.get();\n-        } catch (IOException e) {\n-          throw new JsonIOException(e);\n-        }\n-      }\n     };\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n-import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n package com.google.gson;\n \n import com.google.gson.internal.$Gson$Preconditions;\n-import com.google.gson.internal.GsonInternalAccess;\n import com.google.gson.internal.Streams;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n         TypeAdapter<T> d = delegate;\n         return d != null\n             ? d\n-            : (delegate = GsonInternalAccess.INSTANCE.getNextAdapter(gson, Excluder.this, type));\n+            : (delegate = gson.getNextAdapter(Excluder.this, type));\n       }\n     };\n   }", "timestamp": 1325421740, "metainfo": ""}