{"sha": "3b1056c097cd615c531c1ffd5ccb772d65d2e814", "log": "Renamed JsonParserAsync to JsonStreamParser as that is a more appropriate name. Added a TODO in JsonSerializationVisitor per code review of r453.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   }\n \n   // This takes care of situations where the field was declared as an Object, but the\n-  // actual value contains something more specific. See Issue 54.      \n+  // actual value contains something more specific. See Issue 54.\n+  // TODO (inder): This solution will not work if the field is of a generic type, but \n+  // the actual object is of a raw type (which is a sub-class of the generic type).\n   private Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) {\n     if (type instanceof Class<?>) {\n       Class<?> typeAsClass = (Class<?>) type;\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/JsonStreamParser.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import java.io.EOFException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Iterator;\n+\n+/**\n+ * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader\n+ * asynchronously. This class is not thread-safe.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ * @since 1.4\n+ */\n+public final class JsonStreamParser implements Iterator<JsonElement> {\n+\n+  private final JsonParserJavacc parser;\n+  private boolean eof;\n+  private JsonElement nextElement;\n+\n+  /**\n+   * @param json The string containing JSON elements concatenated to each other.\n+   * @since 1.4\n+   */\n+  public JsonStreamParser(String json) {\n+    this(new StringReader(json));      \n+  }\n+  \n+  /**\n+   * @param reader The data stream containing JSON elements concatenated to each other.\n+   * @since 1.4\n+   */\n+  public JsonStreamParser(Reader reader) {\n+    parser = new JsonParserJavacc(reader);      \n+    eof = false;\n+    nextElement = null;\n+  }\n+  \n+  /**\n+   * Returns the next available {@link JsonElement} on the reader. Null if none available.\n+   * \n+   * @return the next available {@link JsonElement} on the reader. Null if none available.\n+   * @throws JsonParseException if the incoming stream is malformed JSON.\n+   * @since 1.4\n+   */\n+  public JsonElement next() throws JsonParseException {\n+    if (eof) {\n+      return null;\n+    }\n+    if (nextElement != null) {\n+      JsonElement returnValue = nextElement;\n+      nextElement = null;\n+      return returnValue;\n+    }\n+    try {\n+      JsonElement element = parser.parse();\n+      return element;\n+    } catch (TokenMgrError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (ParseException e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (StackOverflowError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (OutOfMemoryError e) {\n+      throw new JsonParseException(\"Failed parsing JSON source to Json\", e);\n+    } catch (JsonParseException e) {\n+      if (e.getCause() instanceof EOFException) {\n+        eof = true;\n+        return null;\n+      } else {\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  public boolean hasNext() {\n+    nextElement = next();\n+    return nextElement != null;\n+  }\n+\n+  public void remove() {\n+    throw new UnsupportedOperationException();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/JsonStreamParserTest.java\n+package com.google.gson;\n+\n+import java.util.Iterator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link JsonStreamParser}\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class JsonStreamParserTest extends TestCase {\n+  \n+  public void testParseTwoStrings() {\n+    JsonStreamParser parser = new JsonStreamParser(\"'one' 'two'\");\n+    String actualOne = parser.next().getAsString();\n+    assertEquals(\"one\", actualOne);\n+    String actualTwo = parser.next().getAsString();\n+    assertEquals(\"two\", actualTwo);\n+  }\n+  \n+  public void testIterator() {\n+    Iterator<JsonElement> parser = new JsonStreamParser(\"'one' 'two'\");\n+    assertTrue(parser.hasNext());\n+    assertEquals(\"one\", parser.next().getAsString());\n+    assertTrue(parser.hasNext());\n+    assertEquals(\"two\", parser.next().getAsString());\n+    assertFalse(parser.hasNext());\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.JsonElement;\n-import com.google.gson.JsonParserAsync;\n+import com.google.gson.JsonStreamParser;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n \n import junit.framework.TestCase;\n     writer.write(gson.toJson(\"one\").toCharArray());\n     writer.write(gson.toJson(\"two\").toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n-    JsonParserAsync parser = new JsonParserAsync(reader);\n+    JsonStreamParser parser = new JsonStreamParser(reader);\n     String actualOne = gson.fromJson(parser.next(), String.class);\n     assertEquals(\"one\", actualOne);\n     String actualTwo = gson.fromJson(parser.next(), String.class);\n     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \"two\");\n     writer.write(gson.toJson(expectedTwo).toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n-    JsonParserAsync parser = new JsonParserAsync(reader);\n+    JsonStreamParser parser = new JsonStreamParser(reader);\n     BagOfPrimitives actualOne = gson.fromJson(parser.next(), BagOfPrimitives.class);\n     assertEquals(\"one\", actualOne.stringValue);\n     BagOfPrimitives actualTwo = gson.fromJson(parser.next(), BagOfPrimitives.class);", "timestamp": 1254419188, "metainfo": ""}