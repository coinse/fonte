{"sha": "9a80d095d9afb3aedcde4c275fb4a8619a5e3a35", "log": "Fix a regression I introduced with the changes to type hierarchy registration. If the registered type was a raw type, we need to also match the parameterizations of that type.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n   private final Map<Type, InstanceCreator<?>> instanceCreators\n       = new HashMap<Type, InstanceCreator<?>>();\n-  private final List<TypeAdapter.Factory> factories\n-      = new ArrayList<TypeAdapter.Factory>();\n+  private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n-  private final List<TypeAdapter.Factory> hierarchyFactories\n-      = new ArrayList<TypeAdapter.Factory>();\n+  private final List<TypeAdapter.Factory> hierarchyFactories = new ArrayList<TypeAdapter.Factory>();\n   private boolean serializeNulls;\n   private String datePattern;\n   private int dateStyle = DateFormat.DEFAULT;\n           \"Cannot register type adapters for \" + type);\n     }\n     if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n+      instanceCreators.put(type, (InstanceCreator) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\n       TypeToken<?> typeToken = TypeToken.get(type);\n-      factories.add(TreeTypeAdapter.newFactory(typeToken, typeAdapter));\n+      factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\n     }\n     if (typeAdapter instanceof TypeAdapter<?>) {\n       factories.add(TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter)typeAdapter));\n   }\n \n   /**\n-   * Configures Gson to use a custom {@link InstanceCreator} for the specified type. If an instance\n-   * creator was previously registered for the specified class, it is overwritten. Since this method\n-   * takes a type instead of a Class object, it can be used to register a specific handler for a\n-   * generic type corresponding to a raw type.\n-   *\n-   *\n-   * @param typeOfT The Type definition for T\n-   * @param instanceCreator the instance creator for T\n-   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n-   */\n-  private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n-      InstanceCreator<? extends T> instanceCreator) {\n-    instanceCreators.put(typeOfT, instanceCreator);\n-    return this;\n-  }\n-\n-  /**\n    * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n-   * This method combines the registration of an {@link InstanceCreator}, {@link JsonSerializer},\n-   * and a {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter}\n-   * implements all the required interfaces for custom serialization with Gson.\n-   * If an instance creator, serializer or deserializer was previously registered for the specified\n-   * type hierarchy, it is overwritten. If an instance creator, serializer or deserializer is\n-   * registered for a specific type in the type hierarchy, it will be invoked instead of the one\n-   * registered for the type hierarchy.\n+   * This method combines the registration of a {@link JsonSerializer} and a {@link\n+   * JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements both of\n+   * the required interfaces for custom serialization with Gson. If a serializer or deserializer was\n+   * previously registered for the specified type hierarchy, it is overwritten. If a serializer or\n+   * deserializer is registered for a specific type in the type hierarchy, it will be invoked\n+   * instead of the one registered for the type hierarchy.\n    *\n    * @param baseType the class definition for the type adapter being registered for the base class\n    *        or interface\n-   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n-   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n+   * @param typeAdapter This object must implement at least one of {@link JsonSerializer} or {@link\n+   *        JsonDeserializer} interfaces.\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.7\n    */\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n         : (delegate = gson.getNextAdapter(skipPast, typeToken));\n   }\n \n+  /**\n+   * Returns a new factory that will match each type against {@code exactType}.\n+   */\n   public static Factory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n-    return new SingleTypeFactory(typeAdapter, exactType, null);\n+    return new SingleTypeFactory(typeAdapter, exactType, false, null);\n   }\n \n+  /**\n+   * Returns a new factory that will match each type and its raw type against\n+   * {@code exactType}.\n+   */\n+  public static Factory newFactoryWithMatchRawType(TypeToken<?> exactType, Object typeAdapter) {\n+    // only bother matching raw types if exact type is a raw type\n+    boolean matchRawType = exactType.getType() == exactType.getRawType();\n+    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\n+  }\n+\n+  /**\n+   * Returns a new factory that will match each type's raw type for assignability\n+   * to {@code hierarchyType}.\n+   */\n   public static Factory newTypeHierarchyFactory(Class<?> hierarchyType, Object typeAdapter) {\n-    return new SingleTypeFactory(typeAdapter, null, hierarchyType);\n+    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\n   }\n \n   private static class SingleTypeFactory implements TypeAdapter.Factory {\n     private final TypeToken<?> exactType;\n+    private final boolean matchRawType;\n     private final Class<?> hierarchyType;\n     private final JsonSerializer<?> serializer;\n     private final JsonDeserializer<?> deserializer;\n \n-    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, Class<?> hierarchyType) {\n+    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n+        Class<?> hierarchyType) {\n       serializer = typeAdapter instanceof JsonSerializer\n           ? (JsonSerializer) typeAdapter\n           : null;\n           : null;\n       $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n       this.exactType = exactType;\n+      this.matchRawType = matchRawType;\n       this.hierarchyType = hierarchyType;\n     }\n \n     @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n     public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n       boolean matches = exactType != null\n-          ? exactType.equals(type)\n+          ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()\n           : hierarchyType.isAssignableFrom(type.getRawType());\n       return matches\n           ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,", "timestamp": 1322055505, "metainfo": ""}