{"sha": "6d50bcea8711642c90caa6db6b1f13ccd38290c1", "log": "Added serialize and deserialize parameters to the Expose annotation that control whether a field gets exposed during serialization or deserialization.", "commit": "\n--- a/gson/src/main/java/com/google/gson/ExposeAnnotationBasedExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/ExposeAnnotationBasedExclusionStrategy.java\n  */\n class ExposeAnnotationBasedExclusionStrategy implements ExclusionStrategy {\n \n+  enum Phase {\n+    SERIALIZATION, DESERIALIZATION\n+  }\n+\n+  private final Phase phase;\n+  \n+  public ExposeAnnotationBasedExclusionStrategy(Phase phase) {\n+    this.phase = phase;\n+  }\n+\n   public boolean shouldSkipClass(Class<?> clazz) {\n     return false;\n   }\n \n   public boolean shouldSkipField(Field f) {\n-    return f.getAnnotation(Expose.class) == null;\n+    Expose annotation = f.getAnnotation(Expose.class);\n+    if (annotation == null) {\n+      return true;\n+    }\n+    switch (phase) {\n+    case SERIALIZATION:\n+      return !annotation.serialize();\n+    case DESERIALIZATION:\n+      return !annotation.deserialize();\n+    default:\n+      throw new IllegalStateException();\n+    }\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n-  private final ExclusionStrategy strategy;\n+\n+  private final ExclusionStrategy serializationStrategy;\n+\n+  private final ExclusionStrategy deserializationStrategy;\n+  \n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n \n    * encountering inner class references.\n    */\n   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n-    this(strategy, fieldNamingPolicy, \n+    this(strategy, strategy, fieldNamingPolicy, \n         new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\n         DEFAULT_JSON_FORMATTER, false, DefaultTypeAdapters.getDefaultSerializers(),\n         DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE);\n   }\n \n-  Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy, \n-      MappedObjectConstructor objectConstructor, JsonFormatter formatter, boolean serializeNulls,\n+  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, \n+      FieldNamingStrategy fieldNamingPolicy, MappedObjectConstructor objectConstructor, \n+      JsonFormatter formatter, boolean serializeNulls, \n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, \n       boolean generateNonExecutableGson) {\n-    this.strategy = strategy;\n+    this.serializationStrategy = serializationStrategy;\n+    this.deserializationStrategy = deserializationStrategy;\n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.formatter = formatter;\n     this.generateNonExecutableJson = generateNonExecutableGson;\n   }\n   \n-  private ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n+  private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\n     return new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n   }\n \n       return JsonNull.createJsonNull();\n     }\n     JsonSerializationContext context = new JsonSerializationContextDefault(\n-        createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n+        createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\n     return context.serialize(src, typeOfSrc);\n   }\n \n       return null;\n     }\n     JsonDeserializationContext context = new JsonDeserializationContextDefault(\n-        createDefaultObjectNavigatorFactory(), deserializers, objectConstructor);\n+        createDefaultObjectNavigatorFactory(deserializationStrategy), deserializers, \n+        objectConstructor);\n     T target = (T) context.deserialize(json, typeOfT);\n     return target;\n   }\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n import java.util.List;\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n+import com.google.gson.ExposeAnnotationBasedExclusionStrategy.Phase;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n       new AnonymousAndLocalClassExclusionStrategy();\n   private static final InnerClassExclusionStrategy innerClassExclusionStrategy =\n       new InnerClassExclusionStrategy();\n-  private static final ExposeAnnotationBasedExclusionStrategy exposeAnnotationExclusionStrategy =\n-      new ExposeAnnotationBasedExclusionStrategy();\n+  private static final ExposeAnnotationBasedExclusionStrategy \n+    exposeAnnotationSerializationExclusionStrategy =\n+      new ExposeAnnotationBasedExclusionStrategy(Phase.SERIALIZATION);\n+  private static final ExposeAnnotationBasedExclusionStrategy \n+    exposeAnnotationDeserializationExclusionStrategy =\n+      new ExposeAnnotationBasedExclusionStrategy(Phase.DESERIALIZATION);\n   \n   private double ignoreVersionsAfter;\n   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\n-    strategies.add(modifierBasedExclusionStrategy);\n-    strategies.add(anonAndLocalClassExclusionStrategy);\n+    List<ExclusionStrategy> serializationStrategies = new LinkedList<ExclusionStrategy>();\n+    List<ExclusionStrategy> deserializationStrategies = new LinkedList<ExclusionStrategy>();\n+    serializationStrategies.add(modifierBasedExclusionStrategy);\n+    deserializationStrategies.add(modifierBasedExclusionStrategy);\n+    serializationStrategies.add(anonAndLocalClassExclusionStrategy);\n+    deserializationStrategies.add(anonAndLocalClassExclusionStrategy);\n \n     if (!serializeInnerClasses) {\n-      strategies.add(innerClassExclusionStrategy);\n+      serializationStrategies.add(innerClassExclusionStrategy);\n+      deserializationStrategies.add(innerClassExclusionStrategy);\n     }\n     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n-      strategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n+      serializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n+      deserializationStrategies.add(new VersionExclusionStrategy(ignoreVersionsAfter));\n     }\n     if (excludeFieldsWithoutExposeAnnotation) {\n-      strategies.add(exposeAnnotationExclusionStrategy);\n-    }\n-    ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n+      serializationStrategies.add(exposeAnnotationSerializationExclusionStrategy);\n+      deserializationStrategies.add(exposeAnnotationDeserializationExclusionStrategy);\n+    }\n+    ExclusionStrategy serializationExclusionStrategy = \n+      new DisjunctionExclusionStrategy(serializationStrategies);\n+    ExclusionStrategy deserializationExclusionStrategy = \n+      new DisjunctionExclusionStrategy(deserializationStrategies);\n \n     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf();\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf();\n \n     JsonFormatter formatter =  prettyPrinting ?\n         new JsonPrintFormatter(escapeHtmlChars) : new JsonCompactFormatter(escapeHtmlChars);\n-    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor,\n-        formatter, serializeNulls, customSerializers, customDeserializers, generateNonExecutableJson);\n+    Gson gson = new Gson(serializationExclusionStrategy, deserializationExclusionStrategy, \n+        fieldNamingPolicy, objConstructor, formatter, serializeNulls, customSerializers, \n+        customDeserializers, generateNonExecutableJson);\n     return gson;\n   }\n \n--- a/gson/src/main/java/com/google/gson/annotations/Expose.java\n+++ b/gson/src/main/java/com/google/gson/annotations/Expose.java\n  * <p><pre>\n  * public class User {\n  *   &#64Expose private String firstName;\n- *   &#64Expose private String lastName;\n- *   &#64Expose private String emailAddress;\n+ *   &#64Expose(serialize = false) private String lastName;\n+ *   &#64Expose (serialize = false, deserialize = false) private String emailAddress;\n  *   private String password;\n  * }\n  * </pre></p>\n  * with {@code Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()}\n  * then the {@code toJson()} and {@code fromJson()} methods of Gson will exclude the\n  * {@code password} field. This is because the {@code password} field is not marked with the\n- * {@code @Expose} annotation.\n+ * {@code @Expose} annotation. Gson will also exclude {@code lastName} and {@code emailAddress}\n+ * from serialization since {@code serialize} is set to {@code false}. Similarly, Gson will\n+ * exclude {@code emailAddress} from deserialization since {@code deserialize} is set to false.\n  *\n  * <p>Note that another way to achieve the same effect would have been to just mark the\n  * {@code password} field as {@code transient}, and Gson would have excluded it even with default\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)\n public @interface Expose {\n-  // This is a marker annotation with no additional properties\n+  \n+  /**\n+   * If true, the field marked with this annotation is written out in the JSON while serializing.\n+   * If false, the field marked with this annotation is skipped from the serialized output. \n+   * Defaults to true.\n+   * @since 1.4\n+   */\n+  public boolean serialize() default true;\n+\n+  /**\n+   * If true, the field marked with this annotation is deserialized from the JSON.\n+   * If false, the field marked with this annotation is skipped during deserialization. \n+   * Defaults to true.\n+   * @since 1.4\n+   */\n+  public boolean deserialize() default true;\n }\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java\n \n package com.google.gson;\n \n+import com.google.gson.ExposeAnnotationBasedExclusionStrategy.Phase;\n import com.google.gson.annotations.Expose;\n \n import junit.framework.TestCase;\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    strategy = new ExposeAnnotationBasedExclusionStrategy();\n+    strategy = new ExposeAnnotationBasedExclusionStrategy(Phase.SERIALIZATION);\n   }\n \n   public void testNeverSkipClasses() throws Exception {\n--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\n   }\n \n   public void testExposeAnnotationDeserialization() throws Exception {\n-    String json = '{' + \"\\\"a\\\":\" + 3 + \",\\\"b\\\":\" + 4 + '}';\n+    String json = \"{a:3,b:4,d:20.0}\";\n     ClassWithExposedFields target = gson.fromJson(json, ClassWithExposedFields.class);\n \n     assertEquals(3, (int) target.a);\n     assertNull(target.b);\n+    assertFalse(target.d == 20);\n   }\n \n   public void testNoExposedFieldSerialization() throws Exception {\n   }\n \n   public void testNoExposedFieldDeserialization() throws Exception {\n-    String json = '{' + \"\\\"a\\\":\" + 4 + \",\\\"b\\\":\" + 5 + '}';\n+    String json = \"{a:4,b:5}\";\n     ClassWithNoExposedFields obj = gson.fromJson(json, ClassWithNoExposedFields.class);\n \n     assertEquals(0, obj.a);\n   private static class ClassWithExposedFields {\n     @Expose private final Integer a;\n     private final Integer b;\n+    @Expose(serialize = false) final long c;\n+    @Expose(deserialize = false) final double d;\n+    @Expose(serialize = false, deserialize = false) final char e;\n \n     ClassWithExposedFields() {\n       this(null, null);\n     }\n \n     public ClassWithExposedFields(Integer a, Integer b) {\n+      this(a, b, 1L, 2.0, 'a');\n+    }\n+    public ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {\n       this.a = a;\n       this.b = b;\n+      this.c = c;\n+      this.d = d;\n+      this.e = e;\n     }\n \n     public String getExpectedJson() {\n-      if (a == null) {\n-        return \"{}\";\n+      StringBuilder sb = new StringBuilder(\"{\");\n+      if (a != null) {\n+        sb.append(\"\\\"a\\\":\").append(a).append(\",\");\n       }\n-      return '{' + \"\\\"a\\\":\" + a + '}';\n+      sb.append(\"\\\"d\\\":\").append(d);\n+      sb.append(\"}\");\n+      return sb.toString();\n     }\n \n     public String getExpectedJsonWithoutAnnotations() {\n-      StringBuilder stringBuilder = new StringBuilder();\n-      boolean requiresComma = false;\n-      stringBuilder.append('{');\n-      if (a != null) {\n-        stringBuilder.append(\"\\\"a\\\":\").append(a);\n-        requiresComma = true;\n-      }\n-      if (b != null) {\n-        if (requiresComma) {\n-          stringBuilder.append(',');\n-        }\n-        stringBuilder.append(\"\\\"b\\\":\").append(b);\n-      }\n-      stringBuilder.append('}');\n-      return stringBuilder.toString();\n+      return String.format(\"{\\\"a\\\":%d,\\\"b\\\":%d,\\\"c\\\":%d,\\\"d\\\":%f,\\\"e\\\":\\\"%c\\\"}\", a, b, c, d, e);\n     }\n   }\n \n     public ClassWithInterfaceField(SomeInterface interfaceField) {\n       this.interfaceField = interfaceField;\n     }\n-  }\n+  }  \n }", "timestamp": 1242776873, "metainfo": ""}