{"sha": "8ee2c24f616b1a3c133611091ef352caceb065aa", "log": "renamed JsonElementReader to JsonTreeReader", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n-import com.google.gson.internal.bind.JsonElementReader;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n import com.google.gson.internal.bind.ObjectTypeAdapter;\n     if (json == null) {\n       return null;\n     }\n-    return (T) fromJson(new JsonElementReader(json), typeOfT);\n+    return (T) fromJson(new JsonTreeReader(json), typeOfT);\n   }\n \n   static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.bind.JsonElementReader;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonElementWriter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n \n   public T fromJsonTree(JsonElement json) {\n     try {\n-      JsonReader jsonReader = new JsonElementReader(json);\n+      JsonReader jsonReader = new JsonTreeReader(json);\n       jsonReader.setLenient(true);\n       return read(jsonReader);\n     } catch (IOException e) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonNull;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This reader walks the elements of a JsonElement as if it was coming from a\n+ * character stream.\n+ *\n+ * @author Jesse Wilson\n+ */\n+public final class JsonTreeReader extends JsonReader {\n+  private static final Reader UNREADABLE_READER = new Reader() {\n+    @Override public int read(char[] buffer, int offset, int count) throws IOException {\n+      throw new AssertionError();\n+    }\n+    @Override public void close() throws IOException {\n+      throw new AssertionError();\n+    }\n+  };\n+  private static final Object SENTINEL_CLOSED = new Object();\n+\n+  private final List<Object> stack = new ArrayList<Object>();\n+\n+  public JsonTreeReader(JsonElement element) {\n+    super(UNREADABLE_READER);\n+    stack.add(element);\n+  }\n+\n+  @Override public void beginArray() throws IOException {\n+    expect(JsonToken.BEGIN_ARRAY);\n+    JsonArray array = (JsonArray) peekStack();\n+    stack.add(array.iterator());\n+  }\n+\n+  @Override public void endArray() throws IOException {\n+    expect(JsonToken.END_ARRAY);\n+    popStack(); // empty iterator\n+    popStack(); // array\n+  }\n+\n+  @Override public void beginObject() throws IOException {\n+    expect(JsonToken.BEGIN_OBJECT);\n+    JsonObject object = (JsonObject) peekStack();\n+    stack.add(object.entrySet().iterator());\n+  }\n+\n+  @Override public void endObject() throws IOException {\n+    expect(JsonToken.END_OBJECT);\n+    popStack(); // empty iterator\n+    popStack(); // object\n+  }\n+\n+  @Override public boolean hasNext() throws IOException {\n+    JsonToken token = peek();\n+    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;\n+  }\n+\n+  @Override public JsonToken peek() throws IOException {\n+    if (stack.isEmpty()) {\n+      return JsonToken.END_DOCUMENT;\n+    }\n+\n+    Object o = peekStack();\n+    if (o instanceof Iterator) {\n+      boolean isObject = stack.get(stack.size() - 2) instanceof JsonObject;\n+      Iterator<?> iterator = (Iterator<?>) o;\n+      if (iterator.hasNext()) {\n+        if (isObject) {\n+          return JsonToken.NAME;\n+        } else {\n+          stack.add(iterator.next());\n+          return peek();\n+        }\n+      } else {\n+        return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+      }\n+    } else if (o instanceof JsonObject) {\n+      return JsonToken.BEGIN_OBJECT;\n+    } else if (o instanceof JsonArray) {\n+      return JsonToken.BEGIN_ARRAY;\n+    } else if (o instanceof JsonPrimitive) {\n+      JsonPrimitive primitive = (JsonPrimitive) o;\n+      if (primitive.isString()) {\n+        return JsonToken.STRING;\n+      } else if (primitive.isBoolean()) {\n+        return JsonToken.BOOLEAN;\n+      } else if (primitive.isNumber()) {\n+        return JsonToken.NUMBER;\n+      } else {\n+        throw new AssertionError();\n+      }\n+    } else if (o instanceof JsonNull) {\n+      return JsonToken.NULL;\n+    } else if (o == SENTINEL_CLOSED) {\n+      throw new IllegalStateException(\"JsonReader is closed\");\n+    } else {\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  private Object peekStack() {\n+    return stack.get(stack.size() - 1);\n+  }\n+\n+  private Object popStack() {\n+    return stack.remove(stack.size() - 1);\n+  }\n+\n+  private void expect(JsonToken expected) throws IOException {\n+    if (peek() != expected) {\n+      throw new IllegalStateException(\"Expected \" + expected + \" but was \" + peek());\n+    }\n+  }\n+\n+  @Override public String nextName() throws IOException {\n+    expect(JsonToken.NAME);\n+    Iterator<?> i = (Iterator<?>) peekStack();\n+    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+    stack.add(entry.getValue());\n+    return (String) entry.getKey();\n+  }\n+\n+  @Override public String nextString() throws IOException {\n+    JsonToken token = peek();\n+    if (token != JsonToken.STRING && token != JsonToken.NUMBER) {\n+      throw new IllegalStateException(\"Expected \" + JsonToken.STRING + \" but was \" + token);\n+    }\n+    return ((JsonPrimitive) popStack()).getAsString();\n+  }\n+\n+  @Override public boolean nextBoolean() throws IOException {\n+    expect(JsonToken.BOOLEAN);\n+    return ((JsonPrimitive) popStack()).getAsBoolean();\n+  }\n+\n+  @Override public void nextNull() throws IOException {\n+    expect(JsonToken.NULL);\n+    popStack();\n+  }\n+\n+  @Override public double nextDouble() throws IOException {\n+    JsonToken token = peek();\n+    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+    }\n+    double result = ((JsonPrimitive) peekStack()).getAsDouble();\n+    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n+      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n+    }\n+    popStack();\n+    return result;\n+  }\n+\n+  @Override public long nextLong() throws IOException {\n+    JsonToken token = peek();\n+    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+    }\n+    long result = ((JsonPrimitive) peekStack()).getAsLong();\n+    popStack();\n+    return result;\n+  }\n+\n+  @Override public int nextInt() throws IOException {\n+    JsonToken token = peek();\n+    if (token != JsonToken.NUMBER && token != JsonToken.STRING) {\n+      throw new IllegalStateException(\"Expected \" + JsonToken.NUMBER + \" but was \" + token);\n+    }\n+    int result = ((JsonPrimitive) peekStack()).getAsInt();\n+    popStack();\n+    return result;\n+  }\n+\n+  @Override public void close() throws IOException {\n+    stack.clear();\n+    stack.add(SENTINEL_CLOSED);\n+  }\n+\n+  @Override public void skipValue() throws IOException {\n+    if (peek() == JsonToken.NAME) {\n+      nextName();\n+    } else {\n+      popStack();\n+    }\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName();\n+  }\n+\n+  public void promoteNameToValue() throws IOException {\n+    expect(JsonToken.NAME);\n+    Iterator<?> i = (Iterator<?>) peekStack();\n+    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n+    stack.add(entry.getValue());\n+    stack.add(new JsonPrimitive((String)entry.getKey()));\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n import java.util.List;\n \n import com.google.gson.internal.JsonReaderInternalAccess;\n-import com.google.gson.internal.bind.JsonElementReader;\n+import com.google.gson.internal.bind.JsonTreeReader;\n \n /**\n  * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n   static {\n     JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n       @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n-        if (reader instanceof JsonElementReader) {\n-          ((JsonElementReader)reader).promoteNameToValue();\n+        if (reader instanceof JsonTreeReader) {\n+          ((JsonTreeReader)reader).promoteNameToValue();\n           return;\n         }\n         reader.peek();\n--- a/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java\n \n   public void testNumbers() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[1, 2, 3]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(1, reader.nextInt());\n     assertEquals(2L, reader.nextLong());\n \n   public void testLenientNansAndInfinities() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[NaN, -Infinity, Infinity]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.setLenient(true);\n     reader.beginArray();\n     assertTrue(Double.isNaN(reader.nextDouble()));\n \n   public void testStrictNansAndInfinities() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[NaN, -Infinity, Infinity]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.setLenient(false);\n     reader.beginArray();\n     try {\n \n   public void testNumbersFromStrings() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[\\\"1\\\", \\\"2\\\", \\\"3\\\"]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(1, reader.nextInt());\n     assertEquals(2L, reader.nextLong());\n \n   public void testStringsFromNumbers() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[1]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(\"1\", reader.nextString());\n     reader.endArray();\n \n   public void testBooleans() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[true, false]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(true, reader.nextBoolean());\n     assertEquals(false, reader.nextBoolean());\n \n   public void testNulls() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[null,null]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     reader.nextNull();\n     reader.nextNull();\n \n   public void testStrings() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[\\\"A\\\",\\\"B\\\"]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(\"A\", reader.nextString());\n     assertEquals(\"B\", reader.nextString());\n \n   public void testArray() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[1, 2, 3]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     assertEquals(JsonToken.BEGIN_ARRAY, reader.peek());\n     reader.beginArray();\n     assertEquals(JsonToken.NUMBER, reader.peek());\n \n   public void testObject() throws IOException {\n     JsonElement element = new JsonParser().parse(\"{\\\"A\\\": 1, \\\"B\\\": 2}\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     assertEquals(JsonToken.BEGIN_OBJECT, reader.peek());\n     reader.beginObject();\n     assertEquals(JsonToken.NAME, reader.peek());\n \n   public void testEmptyArray() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     reader.endArray();\n   }\n \n   public void testNestedArrays() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[[],[[]]]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     reader.beginArray();\n     reader.endArray();\n \n   public void testNestedObjects() throws IOException {\n     JsonElement element = new JsonParser().parse(\"{\\\"A\\\":{},\\\"B\\\":{\\\"C\\\":{}}}\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginObject();\n     assertEquals(\"A\", reader.nextName());\n     reader.beginObject();\n \n   public void testEmptyObject() throws IOException {\n     JsonElement element = new JsonParser().parse(\"{}\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginObject();\n     reader.endObject();\n   }\n \n   public void testSkipValue() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[\\\"A\\\",{\\\"B\\\":[[]]},\\\"C\\\",[[]],\\\"D\\\",null]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     assertEquals(\"A\", reader.nextString());\n     reader.skipValue();\n \n   public void testWrongType() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[[],\\\"A\\\"]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     try {\n       reader.nextBoolean();\n \n   public void testEarlyClose() throws IOException {\n     JsonElement element = new JsonParser().parse(\"[1, 2, 3]\");\n-    JsonElementReader reader = new JsonElementReader(element);\n+    JsonTreeReader reader = new JsonTreeReader(element);\n     reader.beginArray();\n     reader.close();\n     try {", "timestamp": 1322879847, "metainfo": ""}