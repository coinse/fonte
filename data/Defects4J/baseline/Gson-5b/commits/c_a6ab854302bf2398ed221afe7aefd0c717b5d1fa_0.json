{"sha": "a6ab854302bf2398ed221afe7aefd0c717b5d1fa", "log": "Fix a bug where we were unlinking nodes that shouldn't have been unlinked.  Found by Guava's awesome collections test suite!", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n   }\n \n   @Override public V put(K key, V value) {\n-    return putInternal(key, value);\n+    if (key == null) {\n+      throw new NullPointerException(\"key == null\");\n+    }\n+    Node<K, V> created = find(key, true);\n+    V result = created.value;\n+    created.value = value;\n+    return result;\n   }\n \n   @Override public void clear() {\n   @Override public V remove(Object key) {\n     Node<K, V> node = removeInternalByKey(key);\n     return node != null ? node.value : null;\n-  }\n-\n-  V putInternal(K key, V value) {\n-    Node<K, V> created = find(key, true);\n-    V result = created.value;\n-    created.value = value;\n-    return result;\n   }\n \n   /**\n   // TODO(jwilson): don't throw ClassCastExceptions on unknown types\n   @SuppressWarnings(\"unchecked\") // this method throws ClassCastExceptions!\n   Node<K, V> findByObject(Object key) {\n-    return find((K) key, false);\n+    return key != null ? find((K) key, false) : null;\n   }\n \n   /**\n   /**\n    * Removes {@code node} from this tree, rearranging the tree's structure as\n    * necessary.\n-   */\n-  void removeInternal(Node<K, V> node) {\n-    // Unlink the node.\n-    node.prev.next = node.next;\n-    node.next.prev = node.prev;\n-    node.next = node.prev = null; // Help the GC (for performance)\n+   *\n+   * @param unlink true to also unlink this node from the iteration linked list.\n+   */\n+  void removeInternal(Node<K, V> node, boolean unlink) {\n+    if (unlink) {\n+      node.prev.next = node.next;\n+      node.next.prev = node.prev;\n+      node.next = node.prev = null; // Help the GC (for performance)\n+    }\n \n     Node<K, V> left = node.left;\n     Node<K, V> right = node.right;\n        */\n \n       Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\n-      removeInternal(adjacent); // takes care of rebalance and size--\n+      removeInternal(adjacent, false); // takes care of rebalance and size--\n \n       int leftHeight = 0;\n       left = node.left;\n   Node<K, V> removeInternalByKey(Object key) {\n     Node<K, V> node = findByObject(key);\n     if (node != null) {\n-      removeInternal(node);\n+      removeInternal(node, true);\n     }\n     return node;\n   }\n       if (lastReturned == null) {\n         throw new IllegalStateException();\n       }\n-      LinkedTreeMap.this.removeInternal(lastReturned);\n+      LinkedTreeMap.this.removeInternal(lastReturned, true);\n       lastReturned = null;\n       expectedModCount = modCount;\n     }\n       if (node == null) {\n         return false;\n       }\n-      removeInternal(node);\n+      removeInternal(node, true);\n       return true;\n     }\n \n--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Map;\n import junit.framework.TestCase;\n \n public final class LinkedTreeMapTest extends TestCase {\n     assertIterationOrder(map.values(), \"android\", \"cola\", \"bbq\");\n   }\n \n+  public void testRemoveRootDoesNotDoubleUnlink() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    Iterator<Map.Entry<String,String>> it = map.entrySet().iterator();\n+    it.next();\n+    it.next();\n+    it.next();\n+    it.remove();\n+    assertIterationOrder(map.keySet(), \"a\", \"c\");\n+  }\n+\n   // TODO: test contains with non-string key\n \n   private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {", "timestamp": 1347424918, "metainfo": ""}