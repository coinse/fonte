{"sha": "83e5a4937cf13ab9b94a7bb12ce2fefa168752ed", "log": "Renamed Gson.getNextAdapter to getDelegateAdapter. Deleted testParameterizedMapSubclassDeserialization which we decided to not fix. Added simple tests for getDelegateAdapter", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  */\n \n package com.google.gson;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n+ * @author Jesse Wilson\n  */\n public final class Gson {\n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n   }\n \n   /**\n-   * TODO: needs documentation\n+   * This method is used to get an alternate type adapter for the specified type. This is used\n+   * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\n+   * may have registered. This features is typically used when you want to register a type\n+   * adapter that does a little bit of work but then delegates further processing to the Gson\n+   * default type adapter. Here is an example:\n+   * <p>Let's say we want to write a type adapter that counts the number of objects being read\n+   *  from or written to JSON. We can achieve this by writing a type adapter factory that uses\n+   *  the <code>getDelegateAdapter</code> method:\n+   *  <pre> {@code\n+   *  class StatsTypeAdapterFactory implements TypeAdapterFactory {\n+   *    public int numReads = 0;\n+   *    public int numWrites = 0;\n+   *    public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {\n+   *      final TypeAdapter&lt;T&gt; delegate = gson.getDelegateAdapter(this, type);\n+   *      return new TypeAdapter&lt;T&gt;() {\n+   *        public void write(JsonWriter out, T value) throws IOException {\n+   *          ++numWrites;\n+   *          delegate.write(out, value);\n+   *        }\n+   *        public T read(JsonReader in) throws IOException {\n+   *          ++numReads;\n+   *          return delegate.read(in);\n+   *        }\n+   *      };\n+   *    }\n+   *  }\n+   *  } </pre>\n+   *  This factory can now be used like this:\n+   *  <pre> {@code\n+   *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();\n+   *  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();\n+   *  // Call gson.toJson() and fromJson methods on objects\n+   *  System.out.println(\"Num JSON reads\" + stats.numReads);\n+   *  System.out.println(\"Num JSON writes\" + stats.numWrites);\n+   *  }</pre>\n+   *  Note that since you can not override type adapter factories for String and Java primitive\n+   *  types, our stats factory will not count the number of String or primitives that will be\n+   *  read or written. \n+   * @param skipPast The type adapter factory that needs to be skipped while searching for\n+   *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter\n+   *   factory from where {@link getDelegateAdapter} method is being invoked).\n+   * @param type Type for which the delegate adapter is being searched for.\n+   *\n    * @since 2.2\n    */\n-  public <T> TypeAdapter<T> getNextAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n+  public <T> TypeAdapter<T> getDelegateAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n     boolean skipPastFound = false;\n \n     for (TypeAdapterFactory factory : factories) {\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n     TypeAdapter<T> d = delegate;\n     return d != null\n         ? d\n-        : (delegate = gson.getNextAdapter(skipPast, typeToken));\n+        : (delegate = gson.getDelegateAdapter(skipPast, typeToken));\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n         TypeAdapter<T> d = delegate;\n         return d != null\n             ? d\n-            : (delegate = gson.getNextAdapter(Excluder.this, type));\n+            : (delegate = gson.getDelegateAdapter(Excluder.this, type));\n       }\n     };\n   }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)} method.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class DelegateTypeAdapterTest extends TestCase {\n+\n+  private StatsTypeAdapterFactory stats;\n+  private Gson gson;\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    stats = new StatsTypeAdapterFactory();\n+    gson = new GsonBuilder()\n+      .registerTypeAdapterFactory(stats)\n+      .create();\n+  }\n+\n+  public void testDelegateInvokedOnObjectsButNotOnPrimitives() {\n+    List<BagOfPrimitives> bags = new ArrayList<BagOfPrimitives>();\n+    for (int i = 0; i < 10; ++i) {\n+      bags.add(new BagOfPrimitives(i, i, i % 2 == 0, String.valueOf(i)));\n+    }\n+    String json = gson.toJson(bags);\n+    bags = gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>(){}.getType());\n+    // 11: 1 list object, and 10 entries. stats not invoked on individual fields of\n+    // BagOfPrimitives since those are primitives.\n+    assertEquals(11, stats.numReads);\n+    assertEquals(11, stats.numWrites);\n+  }\n+\n+  public void testDelegateNotInvokedOnStrings() {\n+    String[] bags = {\"1\", \"2\", \"3\", \"4\"};\n+    String json = gson.toJson(bags);\n+    bags = gson.fromJson(json, String[].class);\n+    // Only 1 array object. stats not invoked on individual strings.\n+    assertEquals(1, stats.numReads);\n+    assertEquals(1, stats.numWrites);\n+  }\n+\n+  private static class StatsTypeAdapterFactory implements TypeAdapterFactory {\n+    public int numReads = 0;\n+    public int numWrites = 0;\n+\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n+      return new TypeAdapter<T>() {\n+        @Override\n+        public void write(JsonWriter out, T value) throws IOException {\n+          ++numWrites;\n+          delegate.write(out, value);\n+        }\n+\n+        @Override\n+        public T read(JsonReader in) throws IOException {\n+          ++numReads;\n+          return delegate.read(in);\n+        }\n+      };\n+    }\n+  }\n+}", "timestamp": 1334256567, "metainfo": ""}