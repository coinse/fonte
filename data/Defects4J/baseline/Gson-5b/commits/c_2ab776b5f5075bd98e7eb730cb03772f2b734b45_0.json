{"sha": "2ab776b5f5075bd98e7eb730cb03772f2b734b45", "log": "Merge pull request #771 from google/jw/global-leniency  Add setting for leniency on Gson instance.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  */\n public final class Gson {\n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+  static final boolean DEFAULT_LENIENT = false;\n+  static final boolean DEFAULT_PRETTY_PRINT = false;\n+  static final boolean DEFAULT_ESCAPE_HTML = true;\n+  static final boolean DEFAULT_SERIALIZE_NULLS = false;\n+  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\n+  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n   private final boolean htmlSafe;\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n+  private final boolean lenient;\n \n   final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n     @SuppressWarnings(\"unchecked\")\n    */\n   public Gson() {\n     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n-        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\n-        true, false, false, LongSerializationPolicy.DEFAULT,\n-        Collections.<TypeAdapterFactory>emptyList());\n+        Collections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\n+        DEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\n+        DEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\n+        LongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n   }\n \n   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n       final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n-      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n+      boolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n       List<TypeAdapterFactory> typeAdapterFactories) {\n     this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.generateNonExecutableJson = generateNonExecutableGson;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n+    this.lenient = lenient;\n \n     List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n \n   }\n \n   /**\n+   * Returns a new JSON writer configured for the settings on this Gson instance.\n+   */\n+  public JsonReader newJsonReader(Reader reader) {\n+    JsonReader jsonReader = new JsonReader(reader);\n+    jsonReader.setLenient(lenient);\n+    return jsonReader;\n+  }\n+\n+  /**\n    * Writes the JSON for {@code jsonElement} to {@code writer}.\n    * @throws JsonIOException if there was a problem writing to the writer\n    */\n    * @since 1.2\n    */\n   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n-    JsonReader jsonReader = new JsonReader(json);\n+    JsonReader jsonReader = newJsonReader(json);\n     Object object = fromJson(jsonReader, classOfT);\n     assertFullConsumption(object, jsonReader);\n     return Primitives.wrap(classOfT).cast(object);\n    */\n   @SuppressWarnings(\"unchecked\")\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n-    JsonReader jsonReader = new JsonReader(json);\n+    JsonReader jsonReader = newJsonReader(json);\n     T object = (T) fromJson(jsonReader, typeOfT);\n     assertFullConsumption(object, jsonReader);\n     return object;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n+import com.google.gson.stream.JsonReader;\n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n import java.text.DateFormat;\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n+\n+import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;\n+import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;\n+import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;\n+import static com.google.gson.Gson.DEFAULT_LENIENT;\n+import static com.google.gson.Gson.DEFAULT_PRETTY_PRINT;\n+import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;\n+import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n   private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n   private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();\n-  private boolean serializeNulls;\n+  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;\n   private String datePattern;\n   private int dateStyle = DateFormat.DEFAULT;\n   private int timeStyle = DateFormat.DEFAULT;\n-  private boolean complexMapKeySerialization;\n-  private boolean serializeSpecialFloatingPointValues;\n-  private boolean escapeHtmlChars = true;\n-  private boolean prettyPrinting;\n-  private boolean generateNonExecutableJson;\n+  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\n+  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\n+  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\n+  private boolean prettyPrinting = DEFAULT_PRETTY_PRINT;\n+  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\n+  private boolean lenient = DEFAULT_LENIENT;\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n   }\n \n   /**\n+   * By default, Gson is strict and only accepts JSON as specified by\n+   * <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. This option makes the parser\n+   * liberal in what it accepts.\n+   *\n+   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n+   * @see JsonReader#setLenient(boolean)\n+   */\n+  public GsonBuilder setLenient() {\n+    lenient = true;\n+    return this;\n+  }\n+\n+  /**\n    * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\n    * Gson to pass-through HTML characters as is.\n    *\n \n     return new Gson(excluder, fieldNamingPolicy, instanceCreators,\n         serializeNulls, complexMapKeySerialization,\n-        generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n+        generateNonExecutableJson, escapeHtmlChars, prettyPrinting, lenient,\n         serializeSpecialFloatingPointValues, longSerializationPolicy, factories);\n   }\n \n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   }\n \n   /**\n-   * Configure this parser to be  be liberal in what it accepts. By default,\n+   * Configure this parser to be liberal in what it accepts. By default,\n    * this parser is strict and only accepts JSON as specified by <a\n    * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n    * parser to lenient causes it to ignore the following syntax errors:\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/LeniencyTest.java\n+/*\n+ * Copyright (C) 2016 The Gson Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.reflect.TypeToken;\n+import java.util.List;\n+import junit.framework.TestCase;\n+\n+import static java.util.Collections.singletonList;\n+\n+/**\n+ * Functional tests for leniency option.\n+ */\n+public class LeniencyTest extends TestCase {\n+\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new GsonBuilder().setLenient().create();\n+  }\n+\n+  public void testLenientFromJson() {\n+    List<String> json = gson.fromJson(\"\"\n+        + \"[ # One!\\n\"\n+        + \"  'Hi' #Element!\\n\"\n+        + \"] # Array!\", new TypeToken<List<String>>() {}.getType());\n+    assertEquals(singletonList(\"Hi\"), json);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n       TypeToken<?> fieldType, JsonAdapter annotation) {\n     Class<?> value = annotation.value();\n+    final TypeAdapter<?> typeAdapter;\n     if (TypeAdapter.class.isAssignableFrom(value)) {\n-          Class<TypeAdapter<?>> typeAdapter = (Class<TypeAdapter<?>>) value;\n-      return constructorConstructor.get(TypeToken.get(typeAdapter)).construct();\n-    }\n-    if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n-          Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n-      return constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n+      Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n+    } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n+      Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n+      typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n           .construct()\n           .create(gson, fieldType);\n+    } else {\n+      throw new IllegalArgumentException(\n+          \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n     }\n \n-    throw new IllegalArgumentException(\n-        \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n+    return typeAdapter.nullSafe();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n     assertFalse(json.contains(\"jsonAdapter\"));\n   }\n \n+  public void testNullSafeObjectFromJson() {\n+    Gson gson = new Gson();\n+    NullableClass fromJson = gson.fromJson(\"null\", NullableClass.class);\n+    assertNull(fromJson);\n+  }\n+\n   @JsonAdapter(A.JsonAdapter.class)\n   private static class A {\n     final String value;\n     }\n   }\n \n+  @JsonAdapter(value = NullableClassJsonAdapter.class)\n+  private static class NullableClass {\n+  }\n+\n+  private static class NullableClassJsonAdapter extends TypeAdapter<NullableClass> {\n+    @Override\n+    public void write(JsonWriter out, NullableClass value) throws IOException {\n+      out.value(\"nullable\");\n+    }\n+\n+    @Override\n+    public NullableClass read(JsonReader in) throws IOException {\n+      in.nextString();\n+      return new NullableClass();\n+    }\n+  }\n+\n   @JsonAdapter(FooJsonAdapter.class)\n   private static enum Foo { BAR, BAZ }\n   private static class FooJsonAdapter extends TypeAdapter<Foo> {\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n       this.part2 = part2;\n     }\n   }\n+\n+  public void testJsonAdapterWrappedInNullSafeAsRequested() {\n+    Gson gson = new Gson();\n+    String fromJson = \"{'part':null}\";\n+\n+    GadgetWithOptionalPart gadget = gson.fromJson(fromJson, GadgetWithOptionalPart.class);\n+    assertNull(gadget.part);\n+\n+    String toJson = gson.toJson(gadget);\n+    assertFalse(toJson.contains(\"PartJsonFieldAnnotationAdapter\"));\n+  }\n+\n+  private static final class GadgetWithOptionalPart {\n+    @JsonAdapter(value = PartJsonFieldAnnotationAdapter.class)\n+    final Part part;\n+\n+    private GadgetWithOptionalPart(Part part) {\n+      this.part = part;\n+    }\n+  }\n }", "timestamp": 1453143803, "metainfo": ""}