{"sha": "bf549f0589105a42f159c78a621fc28087561d16", "log": "Added support for JsonAdapter annotation on fields", "commit": "\n--- a/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java\n+++ b/gson/src/main/java/com/google/gson/annotations/JsonAdapter.java\n  */\n // Note that the above example is taken from JsonAdapterANnotationTest.\n @Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.TYPE)\n+@Target({ElementType.TYPE, ElementType.FIELD})\n public @interface JsonAdapter {\n \n   Class<? extends TypeAdapter<?>> value();\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n     Class<? super T> clazz = targetType.getRawType();\n     JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n     if (annotation == null) return null;\n-    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n-    ObjectConstructor<? extends TypeAdapter<?>> constructor = constructorConstructor.get(TypeToken.get(adapterClass));\n-    TypeAdapter adapter = constructor.construct();\n+    TypeAdapter adapter = getAnnotationTypeAdapter(constructorConstructor, annotation);\n     return adapter;\n   }\n+\n+  static TypeAdapter<?> getAnnotationTypeAdapter(\n+      ConstructorConstructor constructorConstructor, JsonAdapter annotation) {\n+    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n+    ObjectConstructor<? extends TypeAdapter<?>> constructor =\n+        constructorConstructor.get(TypeToken.get(adapterClass));\n+    return constructor.construct();\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n \n package com.google.gson.internal.bind;\n \n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.annotations.JsonAdapter;\n import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Type;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n \n /**\n  * Type adapter that reflects over the fields and methods of a class.\n       final Gson context, final Field field, final String name,\n       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n-\n     // special casing primitives here saves ~5% on Android...\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n-      final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n+      final TypeAdapter<?> typeAdapter = getFieldAdapter(context, field, fieldType);\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         }\n       }\n     };\n+  }\n+\n+  private TypeAdapter<?> getFieldAdapter(Gson context, Field field, TypeToken<?> fieldType) {\n+    TypeAdapter<?> adapter = context.getAdapter(fieldType);\n+    // check if the registered adapter is a reflective type adapter. If so, JsonAdapter\n+    // annotation should take precedence. Somewhat hackish, but works.\n+    if (adapter instanceof Adapter && field.isAnnotationPresent(JsonAdapter.class)) {\n+      JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n+      return JsonAdapterAnnotationTypeAdapterFactory.getAnnotationTypeAdapter(\n+          constructorConstructor, annotation);\n+    }\n+    return adapter;\n   }\n \n   private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.annotations.JsonAdapter;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for the {@link com.google.gson.annotations.JsonAdapter} annotation on classes.\n+ */\n+public final class JsonAdapterAnnotationOnClassesTest extends TestCase {\n+\n+  public void testJsonAdapterInvoked() {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new A(\"bar\"));\n+    assertEquals(\"\\\"jsonAdapter\\\"\", json);\n+\n+   // Also invoke the JsonAdapter javadoc sample\n+    json = gson.toJson(new User(\"Inderjeet\", \"Singh\"));\n+    assertEquals(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\", json);\n+    User user = gson.fromJson(\"{'name':'Joel Leitch'}\", User.class);\n+    assertEquals(\"Joel\", user.firstName);\n+    assertEquals(\"Leitch\", user.lastName);\n+  }\n+\n+  public void testRegisteredAdapterOverridesJsonAdapter() {\n+    TypeAdapter<A> typeAdapter = new TypeAdapter<A>() {\n+      @Override public void write(JsonWriter out, A value) throws IOException {\n+        out.value(\"registeredAdapter\");\n+      }\n+      @Override public A read(JsonReader in) throws IOException {\n+        return new A(in.nextString());\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, typeAdapter)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"registeredAdapter\\\"\", json);\n+  }\n+\n+  /**\n+   * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\n+   */\n+  public void testRegisteredSerializerOverridesJsonAdapter() {\n+    JsonSerializer<A> serializer = new JsonSerializer<A>() {\n+      public JsonElement serialize(A src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        return new JsonPrimitive(\"registeredSerializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, serializer)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"registeredSerializer\\\"\", json);\n+    A target = gson.fromJson(\"abcd\", A.class);\n+    assertEquals(\"jsonAdapter\", target.value);\n+  }\n+\n+  /**\n+   * The deserializer overrides Json adapter, but for serializer the jsonAdapter is used.\n+   */\n+  public void testRegisteredDeserializerOverridesJsonAdapter() {\n+    JsonDeserializer<A> deserializer = new JsonDeserializer<A>() {\n+      public A deserialize(JsonElement json, Type typeOfT,\n+          JsonDeserializationContext context) throws JsonParseException {\n+        return new A(\"registeredDeserializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(A.class, deserializer)\n+      .create();\n+    String json = gson.toJson(new A(\"abcd\"));\n+    assertEquals(\"\\\"jsonAdapter\\\"\", json);\n+    A target = gson.fromJson(\"abcd\", A.class);\n+    assertEquals(\"registeredDeserializer\", target.value);\n+  }\n+\n+  public void testIncorrectTypeAdapterFails() {\n+    try {\n+      String json = new Gson().toJson(new ClassWithIncorrectJsonAdapter(\"bar\"));\n+      fail(json);\n+    } catch (ClassCastException expected) {}\n+  }\n+\n+  public void testSuperclassTypeAdapterNotInvoked() {\n+    String json = new Gson().toJson(new B(\"bar\"));\n+    assertFalse(json.contains(\"jsonAdapter\"));\n+  }\n+\n+  @JsonAdapter(A.JsonAdapter.class)\n+  private static class A {\n+    final String value;\n+    A(String value) {\n+      this.value = value;\n+    }\n+    private static final class JsonAdapter extends TypeAdapter<A> { \n+      @Override public void write(JsonWriter out, A value) throws IOException {\n+        out.value(\"jsonAdapter\");\n+      }\n+      @Override public A read(JsonReader in) throws IOException {\n+        in.nextString();\n+        return new A(\"jsonAdapter\");\n+      }\n+    }\n+  }\n+\n+  private static final class B extends A {\n+    B(String value) {\n+      super(value);\n+    }\n+  }\n+  // Note that the type is NOT TypeAdapter<ClassWithIncorrectJsonAdapter> so this\n+  // should cause error\n+  @JsonAdapter(A.JsonAdapter.class)\n+  private static final class ClassWithIncorrectJsonAdapter {\n+    @SuppressWarnings(\"unused\") final String value;\n+    ClassWithIncorrectJsonAdapter(String value) {\n+      this.value = value;\n+    }\n+  }\n+\n+  // This class is used in JsonAdapter Javadoc as an example\n+  @JsonAdapter(UserJsonAdapter.class)\n+  private static class User {\n+    final String firstName, lastName;\n+    User(String firstName, String lastName) {\n+      this.firstName = firstName;\n+      this.lastName = lastName;\n+    }\n+  }\n+  private static class UserJsonAdapter extends TypeAdapter<User> {\n+    @Override public void write(JsonWriter out, User user) throws IOException {\n+      // implement write: combine firstName and lastName into name\n+      out.beginObject();\n+      out.name(\"name\");\n+      out.value(user.firstName + \" \" + user.lastName);\n+      out.endObject();\n+      // implement the write method\n+    }\n+    @Override public User read(JsonReader in) throws IOException {\n+      // implement read: split name into firstName and lastName\n+      in.beginObject();\n+      in.nextName();\n+      String[] nameParts = in.nextString().split(\" \");\n+      in.endObject();\n+      return new User(nameParts[0], nameParts[1]);\n+    }\n+  }\n+\n+}", "timestamp": 1394350084, "metainfo": ""}