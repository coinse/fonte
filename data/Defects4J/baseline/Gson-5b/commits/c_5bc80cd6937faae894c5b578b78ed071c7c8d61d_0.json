{"sha": "5bc80cd6937faae894c5b578b78ed071c7c8d61d", "log": "Moved Cache, LruCache, Pair, Primitives and UnsafeAllocator to com.google.gson and made them package private.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Cache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Defines generic cache interface.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+interface Cache<K, V> {\n+\n+  /**\n+   * Adds the new value object into the cache for the given key.  If the key already\n+   * exists, then this method will override the value for the key.\n+   *\n+   * @param key the key identifier for the {@code value} object\n+   * @param value the value object to store in the cache\n+   */\n+  void addElement(K key, V value);\n+\n+  /**\n+   * Retrieve the cached value for the given {@code key}.\n+   *\n+   * @param key the key identifying the value\n+   * @return the cached value for the given {@code key}\n+   */\n+  V getElement(K key);\n+\n+  /**\n+   * Removes the value from the cache for the given key.\n+   *\n+   * @param key the key identifying the value to remove\n+   * @return the value for the given {@code key}\n+   */\n+  V removeElement(K key);\n+}\n--- a/gson/src/main/java/com/google/gson/DefaultConstructorAllocator.java\n+++ b/gson/src/main/java/com/google/gson/DefaultConstructorAllocator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Cache;\n-import com.google.gson.internal.$LruCache;\n \n import java.lang.reflect.Constructor;\n \n   private static final Constructor<Null> NULL_CONSTRUCTOR = createNullConstructor();\n \n   // Package private for testing purposes.\n-  final $Cache<Class<?>, Constructor<?>> constructorCache;\n+  final Cache<Class<?>, Constructor<?>> constructorCache;\n \n   public DefaultConstructorAllocator() {\n     this(200);\n   }\n \n   public DefaultConstructorAllocator(int cacheSize) {\n-    constructorCache = new $LruCache<Class<?>, Constructor<?>>(cacheSize);\n+    constructorCache = new LruCache<Class<?>, Constructor<?>>(cacheSize);\n   }\n \n   private static final Constructor<Null> createNullConstructor() {\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Cache;\n-import com.google.gson.internal.$LruCache;\n-import com.google.gson.internal.$Pair;\n import com.google.gson.internal.$Preconditions;\n \n import java.lang.annotation.Annotation;\n   private static final String MAX_CACHE_PROPERTY_NAME =\n       \"com.google.gson.annotation_cache_size_hint\";\n \n-  private static final $Cache<$Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n-      new $LruCache<$Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n+  private static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n+      new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n \n   private final Class<?> declaringClazz;\n   private final Field field;\n    */\n   public Collection<Annotation> getAnnotations() {\n     if (annotations == null) {\n-      $Pair<Class<?>, String> key = new $Pair<Class<?>, String>(declaringClazz, name);\n+      Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name);\n       annotations = ANNOTATION_CACHE.getElement(key);\n       if (annotations == null) {\n         annotations = Collections.unmodifiableCollection(\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Primitives;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n    */\n   public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n-    return $Primitives.wrap(classOfT).cast(object);\n+    return Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n     JsonReader jsonReader = new JsonReader(json);\n     Object object = fromJson(jsonReader, classOfT);\n     assertFullConsumption(object, jsonReader);\n-    return $Primitives.wrap(classOfT).cast(object);\n+    return Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n    */\n   public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n-    return $Primitives.wrap(classOfT).cast(object);\n+    return Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Pair;\n import com.google.gson.internal.$Preconditions;\n \n import java.lang.reflect.Type;\n \n   @SuppressWarnings(\"unchecked\")\n   public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n-    $Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n+    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n     if (pair == null) {\n       return false;\n     }\n   }\n \n   protected Object invokeCustomDeserializer(JsonElement element,\n-      $Pair<JsonDeserializer<?>, ObjectTypePair> pair) {\n+      Pair<JsonDeserializer<?>, ObjectTypePair> pair) {\n     if (element == null || element.isJsonNull()) {\n       return null;\n     }\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Pair;\n-import com.google.gson.internal.$Primitives;\n \n import java.lang.reflect.Type;\n \n         throw new JsonParseException(\"Expecting object found: \" + json);\n       }\n       JsonElement child = json.getAsJsonObject().get(fName);\n-      boolean isPrimitive = $Primitives.isPrimitive(declaredTypeOfField);\n+      boolean isPrimitive = Primitives.isPrimitive(declaredTypeOfField);\n       if (child == null) { // Child will be null if the field wasn't present in Json\n         return true;\n       } else if (child.isJsonNull()) {\n         return true;\n       }\n       ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false);\n-      $Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n+      Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n       if (pair == null) {\n         return false;\n       }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Pair;\n import com.google.gson.internal.$Types;\n import com.google.gson.internal.$Preconditions;\n \n    */\n   @SuppressWarnings(\"unchecked\")\n   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\n-    $Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n+    Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n     if (pair == null) {\n       return null;\n     }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/LruCache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of the {@link Cache} interface that evict objects from the cache using an\n+ * LRU (least recently used) algorithm.  Object start getting evicted from the cache once the\n+ * {@code maxCapacity} is reached.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+final class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {\n+  private static final long serialVersionUID = 1L;\n+\n+  private final int maxCapacity;\n+\n+  public LruCache(int maxCapacity) {\n+    super(maxCapacity, 0.7F, true);\n+    this.maxCapacity = maxCapacity;\n+  }\n+\n+  public synchronized void addElement(K key, V value) {\n+    put(key, value);\n+  }\n+\n+  public synchronized V getElement(K key) {\n+    return get(key);\n+  }\n+\n+  public synchronized V removeElement(K key) {\n+    return remove(key);\n+  }\n+\n+  @Override\n+  protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n+    return size() > maxCapacity;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n package com.google.gson;\n \n import com.google.gson.internal.$Types;\n-import com.google.gson.internal.$UnsafeAllocator;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n  * @author Joel Leitch\n  */\n final class MappedObjectConstructor implements ObjectConstructor {\n-  private static final $UnsafeAllocator unsafeAllocator = $UnsafeAllocator.create();\n+  private static final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n   private static final DefaultConstructorAllocator defaultConstructorAllocator =\n       new DefaultConstructorAllocator(500);\n \n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n package com.google.gson;\n \n import com.google.gson.internal.$Types;\n-import com.google.gson.internal.$Primitives;\n \n import java.lang.reflect.Type;\n \n   private static boolean isPrimitiveOrString(Object objectToVisit) {\n     Class<?> realClazz = objectToVisit.getClass();\n     return realClazz == Object.class || realClazz == String.class\n-        || $Primitives.unwrap(realClazz).isPrimitive();\n+        || Primitives.unwrap(realClazz).isPrimitive();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n  */\n package com.google.gson;\n \n-import com.google.gson.internal.$Pair;\n \n import java.lang.reflect.Type;\n \n     return String.format(\"preserveType: %b, type: %s, obj: %s\", preserveType, type, obj);\n   }\n \n-  <HANDLER> $Pair<HANDLER, ObjectTypePair> getMatchingHandler(\n+  <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(\n       ParameterizedTypeHandlerMap<HANDLER> handlers) {\n     HANDLER handler = null;\n     if (!preserveType && obj != null) {\n       ObjectTypePair moreSpecificType = toMoreSpecificType();\n       handler = handlers.getHandlerFor(moreSpecificType.type);\n       if (handler != null) {\n-        return new $Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n+        return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n       }\n     }\n     // Try the specified type\n     handler = handlers.getHandlerFor(type);\n-    return handler == null ? null : new $Pair<HANDLER, ObjectTypePair>(handler, this);\n+    return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n   }\n \n   ObjectTypePair toMoreSpecificType() {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Pair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n+final class Pair<FIRST, SECOND> {\n+  public final FIRST first;\n+  public final SECOND second;\n+\n+  public Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    Pair<?, ?> that = (Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Pair;\n import com.google.gson.internal.$Types;\n \n import java.lang.reflect.Type;\n   private static final Logger logger =\n       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n   private final Map<Type, T> map = new HashMap<Type, T>();\n-  private final List<$Pair<Class<?>, T>> typeHierarchyList = new ArrayList<$Pair<Class<?>, T>>();\n+  private final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n   private boolean modifiable = true;\n \n   public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n-    $Pair<Class<?>, T> pair = new $Pair<Class<?>, T>(typeOfT, value);\n+    Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n     registerForTypeHierarchy(pair);\n   }\n \n-  public synchronized void registerForTypeHierarchy($Pair<Class<?>, T> pair) {\n+  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n \n   private int getIndexOfAnOverriddenHandler(Class<?> type) {\n     for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n-      $Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n+      Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n       if (type.isAssignableFrom(entry.first)) {\n         return i;\n       }\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n     for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      $Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n+      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n       int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\n       if (index < 0) {\n         registerForTypeHierarchy(entry);\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n     for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      $Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n+      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n       registerForTypeHierarchy(entry);\n     }\n   }\n   }\n \n   private T getHandlerForTypeHierarchy(Class<?> type) {\n-    for ($Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n       if (entry.first.isAssignableFrom(type)) {\n         return entry.second;\n       }\n   public String toString() {\n     StringBuilder sb = new StringBuilder(\"{mapForTypeHierarchy:{\");\n     boolean first = true;\n-    for ($Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n       if (first) {\n         first = false;\n       } else {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Primitives.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+\n+import java.lang.reflect.Type;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.gson.internal.$Preconditions;\n+\n+/**\n+ * Contains static utility methods pertaining to primitive types and their\n+ * corresponding wrapper types.\n+ *\n+ * @author Kevin Bourrillion\n+ */\n+final class Primitives {\n+  private Primitives() {}\n+\n+  /** A map from primitive types to their corresponding wrapper types. */\n+  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n+\n+  /** A map from wrapper types to their corresponding primitive types. */\n+  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n+\n+  // Sad that we can't use a BiMap. :(\n+\n+  static {\n+    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\n+    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n+\n+    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);\n+    add(primToWrap, wrapToPrim, byte.class, Byte.class);\n+    add(primToWrap, wrapToPrim, char.class, Character.class);\n+    add(primToWrap, wrapToPrim, double.class, Double.class);\n+    add(primToWrap, wrapToPrim, float.class, Float.class);\n+    add(primToWrap, wrapToPrim, int.class, Integer.class);\n+    add(primToWrap, wrapToPrim, long.class, Long.class);\n+    add(primToWrap, wrapToPrim, short.class, Short.class);\n+    add(primToWrap, wrapToPrim, void.class, Void.class);\n+\n+    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\n+    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n+  }\n+\n+  private static void add(Map<Class<?>, Class<?>> forward,\n+      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n+    forward.put(key, value);\n+    backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public static boolean isPrimitive(Type type) {\n+    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n+  }\n+\n+  /**\n+   * Returns {@code true} if {@code type} is one of the nine\n+   * primitive-wrapper types, such as {@link Integer}.\n+   *\n+   * @see Class#isPrimitive\n+   */\n+  public static boolean isWrapperType(Class<?> type) {\n+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n+        $Preconditions.checkNotNull(type));\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> wrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n+        $Preconditions.checkNotNull(type));\n+    return (wrapped == null) ? type : wrapped;\n+  }\n+\n+  /**\n+   * Returns the corresponding primitive type of {@code type} if it is a\n+   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     unwrap(Integer.class) == int.class\n+   *     unwrap(int.class) == int.class\n+   *     unwrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> unwrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n+        $Preconditions.checkNotNull(type));\n+    return (unwrapped == null) ? type : unwrapped;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n package com.google.gson;\n \n import com.google.gson.ObjectNavigator.Visitor;\n-import com.google.gson.internal.$LruCache;\n import com.google.gson.internal.$Types;\n import com.google.gson.internal.$Preconditions;\n \n  * @author Jesse Wilson\n  */\n final class ReflectingFieldNavigator {\n-  private static final $LruCache<Type, List<Class<?>>> classCache =\n-    new $LruCache<Type, List<Class<?>>>(500);\n-  private static final $LruCache<Class<?>, Field[]> fieldsCache =\n-    new $LruCache<Class<?>, Field[]>(500);\n+  private static final LruCache<Type, List<Class<?>>> classCache =\n+    new LruCache<Type, List<Class<?>>>(500);\n+  private static final LruCache<Class<?>, Field[]> fieldsCache =\n+    new LruCache<Class<?>, Field[]>(500);\n \n   private final ExclusionStrategy exclusionStrategy;\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/UnsafeAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Do sneaky things to allocate objects without invoking their constructors.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+abstract class UnsafeAllocator {\n+  public abstract <T> T newInstance(Class<T> c) throws Exception;\n+\n+  public static UnsafeAllocator create() {\n+    // try JVM\n+    // public class Unsafe {\n+    //   public Object allocateInstance(Class<?> type);\n+    // }\n+    try {\n+      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n+      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      final Object unsafe = f.get(null);\n+      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) allocateInstance.invoke(unsafe, c);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, pre-gingerbread\n+    // public class ObjectInputStream {\n+    //   private static native Object newInstance(\n+    //     Class<?> instantiationClass, Class<?> constructorClass);\n+    // }\n+    try {\n+      final Method newInstance = ObjectInputStream.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, Object.class);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvivkm, post-gingerbread\n+    // public class ObjectStreamClass {\n+    //   private static native int getConstructorId(Class<?> c);\n+    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n+    // }\n+    try {\n+      Method getConstructorId = ObjectStreamClass.class\n+          .getDeclaredMethod(\"getConstructorId\", Class.class);\n+      getConstructorId.setAccessible(true);\n+      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n+      final Method newInstance = ObjectStreamClass.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+      newInstance.setAccessible(true);\n+      return new UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, constructorId);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // give up\n+    return new UnsafeAllocator() {\n+      @Override\n+      public <T> T newInstance(Class<T> c) {\n+        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/LruCacheTest.java\n+++ b/gson/src/test/java/com/google/gson/LruCacheTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Cache;\n-import com.google.gson.internal.$LruCache;\n \n import junit.framework.TestCase;\n \n /**\n- * Unit test for the {@link $LruCache} class.\n+ * Unit test for the {@link LruCache} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n public class LruCacheTest extends TestCase {\n \n   public void testCacheHitAndMiss() throws Exception {\n-    $Cache<String, Integer> cache = new $LruCache<String, Integer>(3);\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n \n     String key = \"key1\";\n     assertNull(cache.getElement(key));\n   }\n \n   public void testCacheKeyOverwrite() throws Exception {\n-    $Cache<String, Integer> cache = new $LruCache<String, Integer>(3);\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n \n     String key = \"key1\";\n     assertNull(cache.getElement(key));\n   }\n \n   public void testCacheEviction() throws Exception {\n-    $Cache<String, Integer> cache = new $LruCache<String, Integer>(5);\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(5);\n \n     cache.addElement(\"key1\", 1);\n     cache.addElement(\"key2\", 2);\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Primitives;\n import com.google.gson.internal.$Types;\n \n import java.lang.reflect.InvocationTargetException;\n \n     private String getExpectedJson(Object obj) {\n       Class<?> clazz = obj.getClass();\n-      if ($Primitives.isWrapperType($Primitives.wrap(clazz))) {\n+      if (Primitives.isWrapperType(Primitives.wrap(clazz))) {\n         return obj.toString();\n       } else if (obj.getClass().equals(String.class)) {\n         return \"\\\"\" + obj.toString() + \"\\\"\";\n     @SuppressWarnings(\"unchecked\")\n     public static<T> String getExpectedJson(MyParameterizedType<T> obj) {\n       Class<T> clazz = (Class<T>) obj.value.getClass();\n-      boolean addQuotes = !clazz.isArray() && !$Primitives.unwrap(clazz).isPrimitive();\n+      boolean addQuotes = !clazz.isArray() && !Primitives.unwrap(clazz).isPrimitive();\n       StringBuilder sb = new StringBuilder(\"{\\\"\");\n       sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\n       if (addQuotes) {\n       Class<?> rawType = $Types.getRawType(genericClass);\n       String className = rawType.getSimpleName();\n       T value = (T) json.getAsJsonObject().get(className).getAsObject();\n-      if ($Primitives.isPrimitive(genericClass)) {\n+      if (Primitives.isPrimitive(genericClass)) {\n         PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n         value = (T) typeAdapter.adaptType(value, rawType);\n       }\n--- a/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n+++ b/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Primitives;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T adaptType(Object from, Class<T> to) {\n-    Class<?> aClass = $Primitives.wrap(to);\n-    if ($Primitives.isWrapperType(aClass)) {\n+    Class<?> aClass = Primitives.wrap(to);\n+    if (Primitives.isWrapperType(aClass)) {\n       if (aClass == Character.class) {\n         String value = from.toString();\n         if (value.length() == 1) {", "timestamp": 1301493546, "metainfo": ""}