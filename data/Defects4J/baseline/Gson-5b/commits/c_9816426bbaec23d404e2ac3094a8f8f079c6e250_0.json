{"sha": "9816426bbaec23d404e2ac3094a8f8f079c6e250", "log": "Add new Cache interface and LRU Cache implementation to cache field annotations per \"Class\" (rather than per instance).  This results in a significant speed-up (approx. 3X) when serializing/deserializing the same classes over and over again.", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/Cache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+/**\n+ * Defines generic cache interface.\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+interface Cache<K, V> {\n+\n+  /**\n+   * Adds the new value object into the cache for the given key.  If the key already\n+   * exists, then this method will override the value for the key.\n+   *\n+   * @param key the key identifier for the {@code value} object\n+   * @param value the value object to store in the cache\n+   */\n+  void addElement(K key, V value);\n+\n+  /**\n+   * Retrieve the cached value for the given {@code key}.\n+   *\n+   * @param key the key identifying the value\n+   * @return the cached value for the given {@code key}\n+   */\n+  V getElement(K key);\n+  \n+  /**\n+   * Removes the value from the cache for the given key.\n+   * \n+   * @param key the key identifying the value to remove\n+   * @return the value for the given {@code key}\n+   */\n+  V removeElement(K key);\n+\n+  /**\n+   * Removes everything from this cache.\n+   */\n+  void clear();\n+  \n+  /**\n+   * @return the number of objects in this cache\n+   */\n+  int size();\n+}\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n  * @since 1.4\n  */\n public final class FieldAttributes {\n+  // TODO(Joel): Fix how we configure this cache in a follow-up CL.\n+  private static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n+      new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(1500);\n+\n+  private final Class<?> parentClazz;\n   private final Field field;\n   private final Class<?> declaredType;\n   private final boolean isSynthetic;\n    *\n    * @param f the field to pull attributes from\n    */\n-  FieldAttributes(final Field f) {\n-    Preconditions.checkNotNull(f);\n-    field = f;\n-    name = field.getName();\n+  FieldAttributes(final Class<?> parentClazz, final Field f) {\n+    Preconditions.checkNotNull(parentClazz);\n+    this.parentClazz = parentClazz;\n+    name = f.getName();\n     declaredType = f.getType();\n     isSynthetic = f.isSynthetic();\n-    modifiers = field.getModifiers();\n+    modifiers = f.getModifiers();\n+    field = f;\n   }\n \n   /**\n    */\n   public Collection<Annotation> getAnnotations() {\n     if (annotations == null) {\n-      annotations = Collections.unmodifiableCollection(\n-          Arrays.asList(field.getAnnotations()));\n+      Pair<Class<?>, String> key = new Pair<Class<?>, String>(parentClazz, name);\n+      annotations = ANNOTATION_CACHE.getElement(key);\n+      if (annotations == null) {\n+        annotations = Collections.unmodifiableCollection(\n+            Arrays.asList(field.getAnnotations()));\n+        ANNOTATION_CACHE.addElement(key, annotations);\n+      }\n     }\n     return annotations;\n   }\n--- a/gson/src/main/java/com/google/gson/LowerCamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/LowerCamelCaseSeparatorNamingPolicy.java\n package com.google.gson;\n \n /**\n- * A {@link FieldNamingStrategy} that ensures the JSON field names consist of only\n+ * A {@link FieldNamingStrategy2} that ensures the JSON field names consist of only\n  * lower case letters and are separated by a particular {@code separatorString}.\n  *\n  *<p>The following is an example:</p>\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/LruCache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of the {@link Cache} interface that evict objects from the cache using an\n+ * LRU (least recently used) algorithm.  Object start getting evicted from the cache once the\n+ * {@code maxCapacity} is reached.\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {\n+  private static final long serialVersionUID = 1L;\n+\n+  private final int maxCapacity;\n+\n+  LruCache(int maxCapacity) {\n+    super(maxCapacity, 0.7F, true);\n+    this.maxCapacity = maxCapacity;\n+  }\n+\n+  public void addElement(K key, V value) {\n+    put(key, value);\n+  }\n+\n+  public void clear() {\n+    super.clear();\n+  }\n+\n+  public V getElement(K key) {\n+    return get(key);\n+  }\n+\n+  public V removeElement(K key) {\n+    return remove(key);\n+  }\n+\n+  public int size() {\n+    return super.size();\n+  }\n+  \n+  @Override\n+  protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n+    return size() > maxCapacity;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n     Field[] fields = clazz.getDeclaredFields();\n     AccessibleObject.setAccessible(fields, true);\n     for (Field f : fields) {\n-      FieldAttributes fieldAttributes = new FieldAttributes(f);\n+      FieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\n       if (exclusionStrategy.shouldSkipField(fieldAttributes)\n           || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n         continue; // skip\n--- a/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/DisjunctionExclusionStrategyTest.java\n   private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);\n   private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);\n   private static final Class<?> CLAZZ = String.class;\n-  private static final FieldAttributes FIELD = new FieldAttributes(CLAZZ.getFields()[0]);\n+  private static final FieldAttributes FIELD = new FieldAttributes(CLAZZ, CLAZZ.getFields()[0]);\n \n   public void testBadInstantiation() throws Exception {\n     try {\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategyTest.java\n \n   public void testSkipNonAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"hiddenField\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testSkipExplicitlySkippedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testNeverSkipExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"exposedField\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyExposedField\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   @SuppressWarnings(\"unused\")\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategyTest.java\n \n   public void testSkipNonAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"hiddenField\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testSkipExplicitlySkippedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testNeverSkipExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"exposedField\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n     Field f = MockObject.class.getField(\"explicitlyExposedField\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n   }\n \n   @SuppressWarnings(\"unused\")\n--- a/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n+++ b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    fieldAttributes = new FieldAttributes(Foo.class.getField(\"bar\"));\n+    fieldAttributes = new FieldAttributes(Foo.class, Foo.class.getField(\"bar\"));\n   }\n \n   public void testNullField() throws Exception {\n     try {\n-      new FieldAttributes(null);\n+      new FieldAttributes(Foo.class, null);\n       fail(\"Field parameter can not be null\");\n-    } catch (IllegalArgumentException expected) { }\n+    } catch (NullPointerException expected) { }\n   }\n \n   public void testModifiers() throws Exception {\n--- a/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java\n \n   public void testExcludeInnerClassField() throws Exception {\n     Field f = getClass().getField(\"innerClass\");\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n   }\n \n   public void testIncludeStaticNestedClassObject() throws Exception {\n \n   public void testIncludeStaticNestedClassField() throws Exception {\n     Field f = getClass().getField(\"staticNestedClass\");\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));\n   }\n \n   class InnerClass {\n--- a/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/JavaFieldNamingPolicyTest.java\n   }\n \n   public void testFieldNamingPolicy() throws Exception {\n-    FieldAttributes f = new FieldAttributes(String.class.getFields()[0]);\n+    FieldAttributes f = new FieldAttributes(String.class, String.class.getFields()[0]);\n     assertEquals(f.getName(), namingPolicy.translateName(f));\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/LruCacheTest.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit test for the {@link LruCache} class.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class LruCacheTest extends TestCase {\n+\n+  public void testCacheHitAndMiss() throws Exception {\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n+    \n+    String key = \"key1\";\n+    assertNull(cache.getElement(key));\n+    cache.addElement(key, 1);\n+    assertEquals(1, cache.getElement(key).intValue());\n+    \n+    String key2 = \"key2\";\n+    cache.addElement(key2, 2);\n+    assertEquals(1, cache.getElement(key).intValue());\n+    assertEquals(2, cache.getElement(key2).intValue());\n+  }\n+  \n+  public void testCacheKeyOverwrite() throws Exception {\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n+    \n+    String key = \"key1\";\n+    assertNull(cache.getElement(key));\n+    cache.addElement(key, 1);\n+    assertEquals(1, cache.getElement(key).intValue());\n+    \n+    cache.addElement(key, 5);\n+    assertEquals(5, cache.getElement(key).intValue());\n+  }\n+  \n+  public void testCacheEviction() throws Exception {\n+    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n+\n+    cache.addElement(\"key1\", 1);\n+    cache.addElement(\"key2\", 2);\n+    cache.addElement(\"key3\", 3);\n+    assertEquals(1, cache.getElement(\"key1\").intValue());\n+    assertEquals(2, cache.getElement(\"key2\").intValue());\n+    assertEquals(3, cache.getElement(\"key3\").intValue());\n+\n+    // Access key1 to show key2 will be evicted (shows not a FIFO cache)\n+    cache.getElement(\"key1\");\n+    cache.addElement(\"key4\", 4);\n+    assertEquals(1, cache.getElement(\"key1\").intValue());\n+    assertNull(cache.getElement(\"key2\"));\n+    assertEquals(3, cache.getElement(\"key3\").intValue());\n+    assertEquals(4, cache.getElement(\"key4\").intValue());\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/NullExclusionStrategyTest.java\n \n   public void testNeverSkipsField() throws Exception {\n     assertFalse(strategy.shouldSkipField(\n-        new FieldAttributes(String.class.getFields()[0])));\n+        new FieldAttributes(String.class, String.class.getFields()[0])));\n   }\n }\n--- a/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java\n \n   public void testFieldWithAnnotation() throws Exception {\n     String fieldName = \"fieldWithAnnotation\";\n-    FieldAttributes f = new FieldAttributes(SomeObject.class.getField(fieldName));\n+    FieldAttributes f = new FieldAttributes(\n+        SomeObject.class, SomeObject.class.getField(fieldName));\n \n     assertFalse(ANNOTATED_FIELD_NAME.equals(fieldName));\n     assertEquals(ANNOTATED_FIELD_NAME, policy.translateName(f));\n \n   public void testFieldWithoutAnnotation() throws Exception {\n     String fieldName = \"fieldWithoutAnnotation\";\n-    FieldAttributes f = new FieldAttributes(SomeObject.class.getField(fieldName));\n+    FieldAttributes f = new FieldAttributes(\n+        SomeObject.class, SomeObject.class.getField(fieldName));\n \n     assertEquals(fieldName, policy.translateName(f));\n   }\n--- a/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);\n \n     assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n   }\n \n   public void testClassAndFieldAreBehindInVersion() throws Exception {\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);\n \n     assertFalse(strategy.shouldSkipClass(clazz));\n-    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertFalse(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n   }\n \n   public void testClassAndFieldAreAheadInVersion() throws Exception {\n     VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);\n \n     assertTrue(strategy.shouldSkipClass(clazz));\n-    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));\n+    assertTrue(strategy.shouldSkipField(new FieldAttributes(clazz, f)));\n   }\n \n   @Since(VERSION)", "timestamp": 1263083541, "metainfo": ""}