{"sha": "3aeb70e0305a598a9ceddc0390d693874dcc892d", "log": "Adapter for Object.class", "commit": "\n--- a/gson/src/main/java/com/google/gson/BaseMapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/BaseMapTypeAdapter.java\n abstract class BaseMapTypeAdapter\n     implements JsonSerializer<Map<?, ?>>, JsonDeserializer<Map<?, ?>> {\n \n-  protected static final JsonElement serialize(JsonSerializationContext context,\n+  protected static JsonElement serialize(JsonSerializationContext context,\n       Object src, Type srcType) {\n     return context.serialize(src, srcType, false, false);\n   }\n \n-  protected static final Map<Object, Object> constructMapType(\n+  protected static Map<Object, Object> constructMapType(\n       Type mapType, JsonDeserializationContext context) {\n     return context.construct(mapType);\n   }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapter;\n+import com.google.gson.internal.bind.GsonCompatibleMapTypeAdapter;\n import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.ObjectTypeAdapter;\n import com.google.gson.internal.bind.ReflectiveTypeAdapter;\n-import com.google.gson.internal.bind.StringToValueMapTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n \n import java.io.IOException;\n import java.io.Reader;\n-import java.io.StringReader;\n import java.io.StringWriter;\n import java.io.Writer;\n import java.lang.reflect.Field;\n         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())\n         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())\n         .factory(excludedTypeFactory)\n+        .factory(GsonCompatibleMapTypeAdapter.FACTORY)\n         .factory(new GsonToMiniGsonTypeAdapter(serializers, deserializers, serializeNulls))\n         .factory(CollectionTypeAdapter.FACTORY)\n-        .factory(StringToValueMapTypeAdapter.FACTORY)\n         .factory(ArrayTypeAdapter.FACTORY)\n+        .factory(ObjectTypeAdapter.FACTORY)\n         .factory(reflectiveTypeAdapterFactory);\n \n     this.miniGson = builder.build();\n--- a/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java\n       }\n     };\n   }\n-  \n+\n   public JsonSerializationContext createSerializationContext(final MiniGson miniGson) {\n     return new JsonSerializationContext() {\n       @Override\n         TypeToken typeToken = TypeToken.get(typeOfT);\n         return (T) miniGson.getAdapter(typeToken).fromJsonElement(json);\n       }\n+\n+      @Override public <T> T construct(Type type) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override public Object constructArray(Type type, int length) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override public <T> T deserializeDefault(JsonElement json, Type typeOfT) throws JsonParseException {\n+        throw new UnsupportedOperationException();\n+      }\n     };\n   }\n }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n     this(null, null, null, null);\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n+  /**\n+   * TODO: remove this from the public API\n+   */\n+  @SuppressWarnings(\"unchecked\") @Deprecated\n   public <T> T construct(Type type) {\n     Object instance = objectConstructor.construct(type);\n     return (T) instance;\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n       } else {\n         constructorType = rawType;\n       }\n+      // TODO: Queue=LinkedList, SortedSet=TreeSet\n \n-      Constructor<?> constructor;\n+      Constructor<?> constructor = null;\n       try {\n         constructor = constructorType.getConstructor();\n-      } catch (NoSuchMethodException e) {\n-        return null;\n+      } catch (NoSuchMethodException ignored) {\n       }\n \n       @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n       return null;\n     }\n \n+    if (constructor == null) {\n+      throw new UnsupportedOperationException(\"TODO: use unsafeAllocator.newInstance\");\n+    }\n     Collection<E> collection = Reflection.newInstance(constructor);\n     reader.beginArray();\n     while (reader.hasNext()) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/GsonCompatibleMapTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a map whose keys are any type.\n+ */\n+public final class GsonCompatibleMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Map.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type childGenericType = Object.class;\n+      if (type instanceof ParameterizedType) {\n+        Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n+        childGenericType = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc)[1];\n+      }\n+      TypeAdapter valueAdapter = context.getAdapter(TypeToken.get(childGenericType));\n+\n+      Constructor<?> constructor;\n+      try {\n+        Class<?> constructorType = (rawType == Map.class) ? LinkedHashMap.class : rawType;\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+      TypeAdapter<T> result = new GsonCompatibleMapTypeAdapter(valueAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<V> valueTypeAdapter;\n+  private final Constructor<? extends Map<String, V>> constructor;\n+\n+  public GsonCompatibleMapTypeAdapter(TypeAdapter<V> valueTypeAdapter,\n+      Constructor<? extends Map<String, V>> constructor) {\n+    this.valueTypeAdapter = valueTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Map<String, V> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    Map<String, V> map = Reflection.newInstance(constructor);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String key = reader.nextName();\n+      V value = valueTypeAdapter.read(reader);\n+      map.put(key, value);\n+    }\n+    reader.endObject();\n+    return map;\n+  }\n+\n+  public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+    if (map == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginObject();\n+    for (Map.Entry<String, V> entry : map.entrySet()) {\n+      writer.name(entry.getKey());\n+      valueTypeAdapter.write(writer, entry.getValue());\n+    }\n+    writer.endObject();\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n       factories.add(CollectionTypeAdapter.FACTORY);\n       factories.add(StringToValueMapTypeAdapter.FACTORY);\n       factories.add(ArrayTypeAdapter.FACTORY);\n+      factories.add(ObjectTypeAdapter.FACTORY);\n       factories.add(ReflectiveTypeAdapter.FACTORY);\n     }\n     this.factories = Collections.unmodifiableList(factories);\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Adapts types whose static type is only 'Object'. Uses getClass() on\n+ * serialization and a primitive/Map/List on deserialization.\n+ */\n+public final class ObjectTypeAdapter extends TypeAdapter<Object> {\n+  public static final Factory FACTORY = new Factory() {\n+    @SuppressWarnings(\"unchecked\")\n+    @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+      if (type.getRawType() == Object.class) {\n+        return (TypeAdapter<T>) new ObjectTypeAdapter(context);\n+      }\n+      return null;\n+    }\n+  };\n+\n+  private final MiniGson miniGson;\n+\n+  private ObjectTypeAdapter(MiniGson miniGson) {\n+    this.miniGson = miniGson;\n+  }\n+\n+  @Override public Object read(JsonReader reader) throws IOException {\n+    JsonToken token = reader.peek();\n+    switch (token) {\n+    case BEGIN_ARRAY:\n+      List<Object> list = new ArrayList<Object>();\n+      reader.beginArray();\n+      while (reader.hasNext()) {\n+        list.add(read(reader));\n+      }\n+      reader.endArray();\n+      return list;\n+\n+    case BEGIN_OBJECT:\n+      Map<String, Object> map = new LinkedHashMap<String, Object>();\n+      reader.beginObject();\n+      while (reader.hasNext()) {\n+        map.put(reader.nextName(), read(reader));\n+      }\n+      reader.endObject();\n+      return map;\n+\n+    case STRING:\n+      return reader.nextString();\n+\n+    case NUMBER:\n+      return reader.nextDouble();\n+\n+    case BOOLEAN:\n+      return reader.nextBoolean();\n+\n+    case NULL:\n+      reader.nextNull();\n+      return null;\n+\n+    }\n+    throw new IllegalStateException();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override public void write(JsonWriter writer, Object value) throws IOException {\n+    if (value == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) miniGson.getAdapter(value.getClass());\n+    if (typeAdapter instanceof ObjectTypeAdapter) {\n+      writer.beginObject();\n+      writer.endObject();\n+      return;\n+    }\n+\n+    typeAdapter.write(writer, value);\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n \n   public static class FactoryImpl implements Factory {\n     public boolean serializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-      return true;\n+      return !f.isSynthetic();\n     }\n     public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredType) {\n-      return true;\n+      return !f.isSynthetic();\n     }\n \n     public String getFieldName(Class<?> declaringClazz, Field f, Type declaredType) {\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import java.util.Arrays;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+public final class ObjectTypeAdapterTest extends TestCase {\n+  private final MiniGson gson = new MiniGson.Builder().build();\n+  private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);\n+\n+  public void testDeserialize() throws Exception {\n+    Map<?, ?> map = (Map) adapter.fromJson(\"{a: 5, b: [1, 2, null]}\");\n+    assertEquals(5.0, map.get(\"a\"));\n+    assertEquals(Arrays.asList(1.0, 2.0, null), map.get(\"b\"));\n+  }\n+\n+  public void testSerialize() throws Exception {\n+    Object object = new Object() {\n+      Object a = 5;\n+      Object b = Arrays.asList(1, 2, null);\n+    };\n+    assertEquals(\"{'a':5,'b':[1,2,null]}\", adapter.toJson(object).replace(\"\\\"\", \"'\"));\n+  }\n+\n+  public void testSerializeObject() throws Exception {\n+    assertEquals(\"{}\", adapter.toJson(new Object()));\n+  }\n+}", "timestamp": 1315539076, "metainfo": ""}