{"sha": "32afd1a4e45e4ae42bb6bceb8a5823dfe8b44fa2", "log": "Fixing parsing of unquoted strings to be (somewhat) consistent with previous versions of Gson. The difference with this version is that Gson will throw a more specific exception rather than JsonParseException.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n package com.google.gson;\n \n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import com.google.gson.stream.MalformedJsonException;\n+\n import java.io.IOException;\n import java.io.Reader;\n import java.io.StringReader;\n    * @since 1.2\n    */\n   public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n-    Object object = fromJson(new JsonReader(json), classOfT);\n+    JsonReader jsonReader = new JsonReader(json);\n+    Object object = fromJson(jsonReader, classOfT);\n+    assertFullConsumption(object, jsonReader);\n     return Primitives.wrap(classOfT).cast(object);\n   }\n \n    * @since 1.2\n    */\n   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n-    return this.<T>fromJson(new JsonReader(json), typeOfT);\n+    JsonReader jsonReader = new JsonReader(json);\n+    T object = fromJson(jsonReader, typeOfT);\n+    assertFullConsumption(object, jsonReader);\n+    return object;\n+  }\n+\n+  private static void assertFullConsumption(Object obj, JsonReader reader) {\n+    try {\n+      if (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\n+        throw new JsonIOException(\"JSON document was not fully consumed.\");\n+      }\n+    } catch (MalformedJsonException e) {\n+      throw new JsonSyntaxException(e);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    }\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n package com.google.gson;\n \n import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.MalformedJsonException;\n+\n import java.io.EOFException;\n+import java.io.IOException;\n import java.io.Reader;\n import java.io.StringReader;\n \n /**\n  * A parser to parse Json into a parse tree of {@link JsonElement}s\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  * @since 1.3\n  */\n public final class JsonParser {\n-  \n+\n   /**\n    * Parses the specified JSON string into a parse tree\n-   * \n+   *\n    * @param json JSON text\n-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON \n+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\n    * @throws JsonParseException if the specified text is not valid JSON\n    * @since 1.3\n    */\n   public JsonElement parse(String json) throws JsonSyntaxException {\n     return parse(new StringReader(json));\n   }\n-  \n+\n   /**\n    * Parses the specified JSON string into a parse tree\n-   * \n+   *\n    * @param json JSON text\n-   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON \n+   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\n    * @throws JsonParseException if the specified text is not valid JSON\n    * @since 1.3\n    */\n   public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\n-    return parse(new JsonReader(json));\n+    try {\n+      JsonReader jsonReader = new JsonReader(json);\n+      JsonElement element = parse(jsonReader);\n+      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\n+        throw new JsonSyntaxException(\"Did not consume the entire document.\");\n+      }\n+      return element;\n+    } catch (MalformedJsonException e) {\n+      throw new JsonSyntaxException(e);\n+    } catch (IOException e) {\n+      throw new JsonIOException(e);\n+    } catch (NumberFormatException e) {\n+      throw new JsonSyntaxException(e);\n+    }\n   }\n \n   /**\n--- a/gson/src/test/java/com/google/gson/JsonParserTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java\n \n import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.stream.JsonReader;\n+\n+import junit.framework.TestCase;\n+\n import java.io.CharArrayReader;\n import java.io.CharArrayWriter;\n import java.io.StringReader;\n-import junit.framework.TestCase;\n \n /**\n  * Unit test for {@link JsonParser}\n- * \n+ *\n  * @author Inderjeet Singh\n  */\n public class JsonParserTest extends TestCase {\n-  \n   private JsonParser parser;\n-  \n+\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n     parser = new JsonParser();\n   }\n-  \n+\n   public void testParseString() {\n     String json = \"{a:10,b:'c'}\";\n     JsonElement e = parser.parse(json);\n     assertEquals(10, e.getAsJsonObject().get(\"a\").getAsInt());\n     assertEquals(\"c\", e.getAsJsonObject().get(\"b\").getAsString());\n   }\n-  \n+\n   public void testParseEmptyString() {\n     JsonElement e = parser.parse(\"\\\"   \\\"\");\n     assertTrue(e.isJsonPrimitive());\n     JsonElement e = parser.parse(\"     \");\n     assertTrue(e.isJsonNull());\n   }\n-  \n+\n+  public void testParseUnquotedStringSentence() {\n+    String unquotedSentence = \"Test is a test..blah blah\";\n+    try {\n+      parser.parse(unquotedSentence);\n+      fail();\n+    } catch (JsonSyntaxException expected) { }\n+  }\n+\n   public void testParseMixedArray() {\n     String json = \"[{},13,\\\"stringValue\\\"]\";\n     JsonElement e = parser.parse(json);\n     assertTrue(e.isJsonArray());\n-    \n+\n     JsonArray  array = e.getAsJsonArray();\n     assertEquals(\"{}\", array.get(0).toString());\n     assertEquals(13, array.get(1).getAsInt());\n     assertEquals(10, e.getAsJsonObject().get(\"a\").getAsInt());\n     assertEquals(\"c\", e.getAsJsonObject().get(\"b\").getAsString());\n   }\n-  \n+\n   public void testReadWriteTwoObjects() throws Exception {\n-    Gson gson= new Gson();\n+    Gson gson = new Gson();\n     CharArrayWriter writer= new CharArrayWriter();\n     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, \"one\");\n     writer.write(gson.toJson(expectedOne).toCharArray());\n     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \"two\");\n     writer.write(gson.toJson(expectedTwo).toCharArray());\n     CharArrayReader reader = new CharArrayReader(writer.toCharArray());\n-  \n+\n     JsonReader parser = new JsonReader(reader);\n     parser.setLenient(true);\n     JsonElement element1 = Streams.parse(parser);\n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n \n package com.google.gson.functional;\n \n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.LongSerializationPolicy;\n+import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n+\n+import junit.framework.TestCase;\n+\n import java.io.StringReader;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n-\n-import com.google.gson.*;\n-import junit.framework.TestCase;\n-\n-import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n \n /**\n  * Functional tests for Json primitive values: integers, and floating point numbers.\n     value = gson.fromJson(\"[true]\", boolean.class);\n     assertEquals(true, value);\n   }\n-  \n+\n   public void testNumberSerialization() {\n     Number expected = 1L;\n     String json = gson.toJson(expected);\n     assertEquals(expected.toString(), json);\n-    \n+\n     json = gson.toJson(expected, Number.class);\n     assertEquals(expected.toString(), json);\n   }\n-  \n+\n   public void testNumberDeserialization() {\n     String json = \"1\";\n     Number expected = new Integer(json);\n     Number actual = gson.fromJson(json, Number.class);\n     assertEquals(expected.intValue(), actual.intValue());\n-    \n+\n     json = String.valueOf(Long.MAX_VALUE);\n     expected = new Long(json);\n     actual = gson.fromJson(json, Number.class);\n     assertEquals(\"[-122.08]\", gson.toJson(target, double[].class));\n     assertEquals(\"[-122.08]\", gson.toJson(target, Double[].class));\n   }\n-  \n+\n   public void testDoubleAsStringRepresentationDeserialization() {\n     String doubleValue = \"1.0043E+5\";\n     Double expected = Double.valueOf(doubleValue);\n     double actual1 = gson.fromJson(doubleValue, double.class);\n     assertEquals(expected.doubleValue(), actual1);\n   }\n-  \n+\n   public void testDoubleNoFractAsStringRepresentationDeserialization() {\n     String doubleValue = \"1E+5\";\n     Double expected = Double.valueOf(doubleValue);\n     BigDecimal actual = gson.fromJson(\"1.55\", BigDecimal.class);\n     assertEquals(expected, actual);\n   }\n-  \n+\n   public void testBigDecimalPreservePrecisionSerialization() {\n     String expectedValue = \"1.000\";\n     BigDecimal obj = new BigDecimal(expectedValue);\n     String actualValue = gson.toJson(obj);\n-    \n+\n     assertEquals(expectedValue, actualValue);\n   }\n-  \n+\n   public void testBigDecimalPreservePrecisionDeserialization() {\n     String json = \"1.000\";\n     BigDecimal expected = new BigDecimal(json);\n     BigDecimal actual = gson.fromJson(json, BigDecimal.class);\n-    \n+\n     assertEquals(expected, actual);\n   }\n \n     BigDecimal actual = gson.fromJson(doubleValue, BigDecimal.class);\n     assertEquals(expected, actual);\n   }\n-  \n+\n   public void testBigDecimalNoFractAsStringRepresentationDeserialization() {\n     String doubleValue = \"5E+5\";\n     BigDecimal expected = new BigDecimal(doubleValue);\n       fail(\"BigInteger can not be decimal values.\");\n     } catch (JsonParseException expected) { }\n   }\n-  \n+\n   public void testOverridingDefaultPrimitiveSerialization() {\n     CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();\n     gson = new GsonBuilder()\n     long value = 1L;\n     String serializedValue = gson.toJson(value);\n     assertEquals(String.valueOf(value + CrazyLongTypeAdapter.DIFFERENCE), serializedValue);\n-    \n+\n     long deserializedValue = gson.fromJson(serializedValue, long.class);\n     assertEquals(value, deserializedValue);\n   }\n   private String extractElementFromArray(String json) {\n     return json.substring(json.indexOf('[') + 1, json.indexOf(']'));\n   }\n-  \n+\n   public void testDoubleNaNSerializationNotSupportedByDefault() {\n     try {\n       double nan = Double.NaN;\n       gson.toJson(nan);\n       fail(\"Gson should not accept NaN for serialization\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Double.NaN);\n       fail(\"Gson should not accept NaN for serialization\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-    \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testDoubleNaNSerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     double nan = Double.NaN;\n     assertEquals(\"NaN\", gson.toJson(nan));\n     assertEquals(\"NaN\", gson.toJson(Double.NaN));\n   }\n-  \n+\n   public void testDoubleNaNDeserialization() {\n     assertTrue(Double.isNaN(gson.fromJson(\"NaN\", Double.class)));\n     assertTrue(Double.isNaN(gson.fromJson(\"NaN\", double.class)));\n   }\n-  \n+\n   public void testFloatNaNSerializationNotSupportedByDefault() {\n     try {\n       float nan = Float.NaN;\n       gson.toJson(nan);\n       fail(\"Gson should not accept NaN for serialization\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Float.NaN);\n       fail(\"Gson should not accept NaN for serialization\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-  \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testFloatNaNSerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     float nan = Float.NaN;\n     assertEquals(\"NaN\", gson.toJson(nan));\n     assertEquals(\"NaN\", gson.toJson(Float.NaN));\n   }\n-  \n+\n   public void testFloatNaNDeserialization() {\n     assertTrue(Float.isNaN(gson.fromJson(\"NaN\", Float.class)));\n     assertTrue(Float.isNaN(gson.fromJson(\"NaN\", float.class)));\n     try {\n       gson.fromJson(\"NaN\", BigDecimal.class);\n       fail(\"Gson should not accept NaN for deserialization by default.\");\n-    } catch (JsonParseException expected) {      \n+    } catch (JsonParseException expected) {\n     }\n   }\n \n       double infinity = Double.POSITIVE_INFINITY;\n       gson.toJson(infinity);\n       fail(\"Gson should not accept positive infinity for serialization by default.\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Double.POSITIVE_INFINITY);\n       fail(\"Gson should not accept positive infinity for serialization by default.\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-  \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testDoubleInfinitySerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     double infinity = Double.POSITIVE_INFINITY;\n     assertEquals(\"Infinity\", gson.toJson(infinity));\n     assertEquals(\"Infinity\", gson.toJson(Double.POSITIVE_INFINITY));\n   }\n-  \n+\n   public void testDoubleInfinityDeserialization() {\n     assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", Double.class)));\n     assertTrue(Double.isInfinite(gson.fromJson(\"Infinity\", double.class)));\n   }\n-  \n+\n   public void testFloatInfinitySerializationNotSupportedByDefault() {\n     try {\n       float infinity = Float.POSITIVE_INFINITY;\n       gson.toJson(infinity);\n       fail(\"Gson should not accept positive infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Float.POSITIVE_INFINITY);\n       fail(\"Gson should not accept positive infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-  \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testFloatInfinitySerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     float infinity = Float.POSITIVE_INFINITY;\n     assertEquals(\"Infinity\", gson.toJson(infinity));\n     assertEquals(\"Infinity\", gson.toJson(Float.POSITIVE_INFINITY));\n   }\n-  \n+\n   public void testFloatInfinityDeserialization() {\n     assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", Float.class)));\n     assertTrue(Float.isInfinite(gson.fromJson(\"Infinity\", float.class)));\n   }\n-  \n+\n   public void testBigDecimalInfinityDeserializationNotSupported() {\n     try {\n       gson.fromJson(\"Infinity\", BigDecimal.class);\n       fail(\"Gson should not accept positive infinity for deserialization with BigDecimal\");\n-    } catch (JsonParseException expected) {      \n-    }\n-  }\n-  \n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n   public void testNegativeInfinitySerializationNotSupportedByDefault() {\n     try {\n       double negativeInfinity = Double.NEGATIVE_INFINITY;\n       gson.toJson(negativeInfinity);\n       fail(\"Gson should not accept negative infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Double.NEGATIVE_INFINITY);\n       fail(\"Gson should not accept negative infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-  \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testNegativeInfinitySerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     double negativeInfinity = Double.NEGATIVE_INFINITY;\n     assertEquals(\"-Infinity\", gson.toJson(negativeInfinity));\n     assertEquals(\"-Infinity\", gson.toJson(Double.NEGATIVE_INFINITY));\n   }\n-  \n+\n   public void testNegativeInfinityDeserialization() {\n     assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", double.class)));\n     assertTrue(Double.isInfinite(gson.fromJson(\"-Infinity\", Double.class)));\n   }\n-  \n+\n   public void testNegativeInfinityFloatSerializationNotSupportedByDefault() {\n     try {\n       float negativeInfinity = Float.NEGATIVE_INFINITY;\n       gson.toJson(negativeInfinity);\n       fail(\"Gson should not accept negative infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n+    } catch (IllegalArgumentException expected) {\n     }\n     try {\n       gson.toJson(Float.NEGATIVE_INFINITY);\n       fail(\"Gson should not accept negative infinity for serialization by default\");\n-    } catch (IllegalArgumentException expected) {      \n-    }\n-  }\n-  \n+    } catch (IllegalArgumentException expected) {\n+    }\n+  }\n+\n   public void testNegativeInfinityFloatSerialization() {\n     Gson gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();\n     float negativeInfinity = Float.NEGATIVE_INFINITY;\n     assertEquals(\"-Infinity\", gson.toJson(negativeInfinity));\n     assertEquals(\"-Infinity\", gson.toJson(Float.NEGATIVE_INFINITY));\n   }\n-  \n+\n   public void testNegativeInfinityFloatDeserialization() {\n     assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", float.class)));\n     assertTrue(Float.isInfinite(gson.fromJson(\"-Infinity\", Float.class)));\n   }\n-  \n+\n   public void testBigDecimalNegativeInfinityDeserializationNotSupported() {\n     try {\n       gson.fromJson(\"-Infinity\", BigDecimal.class);\n       fail(\"Gson should not accept positive infinity for deserialization\");\n-    } catch (JsonParseException expected) {      \n-    }\n-  }  \n-  \n+    } catch (JsonParseException expected) {\n+    }\n+  }\n+\n   public void testLongAsStringSerialization() throws Exception {\n     gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();\n     String result = gson.toJson(15L);\n     assertEquals(\"\\\"15\\\"\", result);\n-    \n+\n     // Test with an integer and ensure its still a number\n     result = gson.toJson(2);\n     assertEquals(\"2\", result);\n   }\n-  \n+\n   public void testLongAsStringDeserialization() throws Exception {\n     long value = gson.fromJson(\"\\\"15\\\"\", long.class);\n     assertEquals(15, value);\n     value = gson.fromJson(\"\\\"25\\\"\", long.class);\n     assertEquals(25, value);\n   }\n-  \n+\n+  public void testQuotedStringSerializationAndDeserialization() throws Exception {\n+    String value = \"String Blah Blah Blah...1, 2, 3\";\n+    String serializedForm = gson.toJson(value);\n+    assertEquals(\"\\\"\" + value + \"\\\"\", serializedForm);\n+\n+    String actual = gson.fromJson(serializedForm, String.class);\n+    assertEquals(value, actual);\n+  }\n+\n+  public void testUnquotedStringDeserialization() throws Exception {\n+    String value = \"String Blah Blah Blah...1, 2, 3\";\n+    try {\n+      gson.fromJson(value, String.class);\n+      fail();\n+    } catch (JsonSyntaxException expected) { }\n+  }\n+\n   public void testHtmlCharacterSerialization() throws Exception {\n     String target = \"<script>var a = 12;</script>\";\n     String result = gson.toJson(target);\n     assertFalse(result.equals('\"' + target + '\"'));\n-    \n+\n     gson = new GsonBuilder().disableHtmlEscaping().create();\n     result = gson.toJson(target);\n     assertTrue(result.equals('\"' + target + '\"'));\n     ClassWithIntegerField target = gson.fromJson(json, ClassWithIntegerField.class);\n     assertEquals(10, target.i.intValue());\n   }\n-  \n+\n   private static class ClassWithIntegerField {\n     Integer i;\n   }\n-  \n+\n   public void testPrimitiveClassLiteral() {\n     assertEquals(1, gson.fromJson(\"1\", int.class).intValue());\n     assertEquals(1, gson.fromJson(new StringReader(\"1\"), int.class).intValue());", "timestamp": 1289354577, "metainfo": ""}