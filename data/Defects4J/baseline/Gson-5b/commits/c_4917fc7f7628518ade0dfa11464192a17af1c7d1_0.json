{"sha": "4917fc7f7628518ade0dfa11464192a17af1c7d1", "log": "Lift restriction on naming when using the \"@SerializedNamed\" annotation.  Fix for Issue 290.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Escaper.java\n+++ b/gson/src/main/java/com/google/gson/Escaper.java\n     htmlEscapeSet.add('>');\n     htmlEscapeSet.add('&');\n     htmlEscapeSet.add('=');\n-    htmlEscapeSet.add('\\''); \n+    htmlEscapeSet.add('\\'');\n //    htmlEscapeSet.add('/');  -- Removing slash for now since it causes some incompatibilities\n     HTML_ESCAPE_CHARS = Collections.unmodifiableSet(htmlEscapeSet);\n   }\n \n   private final boolean escapeHtmlCharacters;\n-  \n+\n   Escaper(boolean escapeHtmlCharacters) {\n     this.escapeHtmlCharacters = escapeHtmlCharacters;\n   }\n-  \n+\n   public String escapeJsonString(CharSequence plainText) {\n-    StringBuffer escapedString = new StringBuffer(plainText.length() + 20);\n+    StringBuilder escapedString = new StringBuilder(plainText.length() + 20);\n     try {\n       escapeJsonString(plainText, escapedString);\n     } catch (IOException e) {\n     return escapedString.toString();\n   }\n \n-  private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException {\n+  private void escapeJsonString(CharSequence plainText, StringBuilder out) throws IOException {\n     int pos = 0;  // Index just past the last char in plainText written to out.\n     int len = plainText.length();\n-    \n+\n     for (int charCount, i = 0; i < len; i += charCount) {\n       int codePoint = Character.codePointAt(plainText, i);\n       charCount = Character.charCount(codePoint);\n-      \n+\n        if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) {\n           continue;\n        }\n      }\n      out.append(plainText, pos, len);\n   }\n-  \n+\n   private boolean mustEscapeCharInJsString(int codepoint) {\n     if (!Character.isSupplementaryCodePoint(codepoint)) {\n       char c = (char) codepoint;\n--- a/gson/src/main/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicy.java\n import com.google.gson.annotations.SerializedName;\n \n /**\n- * A {@link FieldNamingStrategy2} that acts as a chain of responsibility.  If the\n- * {@link com.google.gson.annotations.SerializedName} annotation is applied to a field then this\n- * strategy will translate the name to the {@code serializedName.value()}; otherwise it delegates\n- * to the wrapped {@link FieldNamingStrategy2}.\n+ * A {@link FieldNamingStrategy2} that acts as a chain of responsibility. If the\n+ * {@link com.google.gson.annotations.SerializedName} annotation is applied to a\n+ * field then this strategy will translate the name to the {@code\n+ * serializedName.value()}; otherwise it delegates to the wrapped\n+ * {@link FieldNamingStrategy2}.\n  *\n- * <p>NOTE: this class performs JSON field name validation for any of the fields marked with\n- * an {@code @SerializedName} annotation.</p>\n+ * <p>\n+ * NOTE: this class performs JSON field name validation for any of the fields\n+ * marked with an {@code @SerializedName} annotation.\n+ * </p>\n  *\n  * @see SerializedName\n  *\n  * @author Joel Leitch\n  */\n final class SerializedNameAnnotationInterceptingNamingPolicy implements FieldNamingStrategy2 {\n-  private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\n   private final FieldNamingStrategy2 delegate;\n \n   SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\n \n   public String translateName(FieldAttributes f) {\n     SerializedName serializedName = f.getAnnotation(SerializedName.class);\n-    return serializedName == null ? delegate.translateName(f)\n-        : fieldNameValidator.validate(serializedName.value());\n+    return serializedName == null ? delegate.translateName(f) : serializedName.value();\n   }\n }\n--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n  */\n package com.google.gson.functional;\n \n-import java.lang.reflect.Field;\n-\n import com.google.gson.FieldNamingPolicy;\n import com.google.gson.FieldNamingStrategy;\n import com.google.gson.Gson;\n \n import junit.framework.TestCase;\n \n+import java.lang.reflect.Field;\n+\n /**\n  * Functional tests for naming policies.\n  *\n  * @author Joel Leitch\n  */\n public class NamingPolicyTest extends TestCase {\n-\n   private GsonBuilder builder;\n \n   @Override\n     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);\n     assertEquals(\"someValue\", deserializedObject.someConstantStringInstanceField);\n   }\n-  \n+\n   public void testGsonWithLowerCaseDashPolicySerialization() {\n     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).create();\n     StringWrapper target = new StringWrapper(\"blah\");\n     StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);\n     assertEquals(\"someValue\", deserializedObject.someConstantStringInstanceField);\n   }\n-  \n+\n   public void testGsonWithLowerCaseUnderscorePolicySerialization() {\n     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)\n         .create();\n         gson.fromJson(expected.getExpectedJson(), ClassWithSerializedNameFields.class);\n     assertEquals(expected.f, actual.f);\n   }\n-  \n+\n   public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerialization() {\n     Gson gson = builder.create();\n     ClassWithDuplicateFields target = new ClassWithDuplicateFields(10);\n     String actual = gson.toJson(target);\n     assertEquals(\"{\\\"a\\\":10}\", actual);\n-    \n+\n     target = new ClassWithDuplicateFields(3.0D);\n     actual = gson.toJson(target);\n     assertEquals(\"{\\\"a\\\":3.0}\", actual);\n   }\n-  \n+\n   public void testGsonWithUpperCamelCaseSpacesPolicySerialiation() {\n     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES)\n         .create();\n     assertEquals(\"{\\\"Some Constant String Instance Field\\\":\\\"\"\n         + target.someConstantStringInstanceField + \"\\\"}\", gson.toJson(target));\n   }\n-  \n+\n   public void testGsonWithUpperCamelCaseSpacesPolicyDeserialiation() {\n     Gson gson = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES)\n         .create();\n     assertEquals(\"{\\\"A\\\":10}\", actual);\n   }\n \n+  public void testComplexFieldNameStrategy() throws Exception {\n+    Gson gson = new Gson();\n+    String json = gson.toJson(new ClassWithComplexFieldName(10));\n+    String escapedFieldName = \"@value\\\\\\\"_s$\\\\\\\\\";\n+    assertEquals(\"{\\\"\" + escapedFieldName + \"\\\":10}\", json);\n+\n+    ClassWithComplexFieldName obj = gson.fromJson(json, ClassWithComplexFieldName.class);\n+    assertEquals(10, obj.value);\n+  }\n+\n   private static class UpperCaseNamingStrategy implements FieldNamingStrategy {\n     public String translateName(Field f) {\n       return f.getName().toUpperCase();\n   private static class ClassWithDuplicateFields {\n     public Integer a;\n     @SerializedName(\"a\") public Double b;\n-    \n+\n     public ClassWithDuplicateFields(Integer a) {\n       this(a, null);\n     }\n-    \n+\n     public ClassWithDuplicateFields(Double b) {\n       this(null, b);\n     }\n-    \n+\n     public ClassWithDuplicateFields(Integer a, Double b) {\n       this.a = a;\n       this.b = b;\n     }\n   }\n+\n+  private static class ClassWithComplexFieldName {\n+    @SerializedName(\"@value\\\"_s$\\\\\") public final long value;\n+\n+    ClassWithComplexFieldName(long value) {\n+      this.value = value;\n+    }\n+  }\n }", "timestamp": 1302629359, "metainfo": ""}