{"sha": "1e18dce002158992bbda1d3a19952fdf07f308f4", "log": "Don't subclass ThreadLocal.  This attempts to address issue 402, wherein subclassing ThreadLocal is pinning a reference to a class, which transitively pins the entire application in containers like Tomcat.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    * The proxy is wired up once the initial adapter has been created.\n    */\n   private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n-      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>() {\n-    @Override protected Map<TypeToken<?>, FutureTypeAdapter<?>> initialValue() {\n-      return new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n-    }\n-  };\n+      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n \n   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache\n       = Collections.synchronizedMap(new HashMap<TypeToken<?>, TypeAdapter<?>>());\n     }\n \n     Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n+    if (threadCalls == null) {\n+      threadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n+      calls.set(threadCalls);\n+    }\n+\n     // the key and value type parameters always agree\n     FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n     if (ongoingCall != null) {", "timestamp": 1350960094, "metainfo": ""}