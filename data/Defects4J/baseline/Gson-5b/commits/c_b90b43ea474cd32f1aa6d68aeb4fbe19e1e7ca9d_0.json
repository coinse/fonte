{"sha": "b90b43ea474cd32f1aa6d68aeb4fbe19e1e7ca9d", "log": "A few minor fixes and one incompatible Java 1.6 API call.", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n package com.google.gson;\n \n import com.google.gson.internal.ParameterizedTypeHandlerMap;\n+\n import java.lang.reflect.Type;\n import java.sql.Time;\n import java.sql.Timestamp;\n     return map;\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\n     ParameterizedTypeHandlerMap<InstanceCreator<?>> map\n         = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n \n import com.google.gson.JsonSyntaxException;\n import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n       this.boundFields = boundFields;\n     }\n \n-    @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n+    @Override\n     public T read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       } catch (IllegalStateException e) {\n         throw new JsonSyntaxException(e);\n       } catch (IllegalAccessException e) {\n-        throw new AssertionError();\n+        throw new AssertionError(e);\n       }\n       reader.endObject();\n       return instance;\n     }\n \n+    @Override\n     public void write(JsonWriter writer, T value) throws IOException {\n       if (value == null) {\n         writer.nullValue(); // TODO: better policy here?\n       }\n \n       // TODO: GSON includes subclass fields during serialization\n-      if (false) {\n-        Class<?> runtimeType = value.getClass();\n-        if (runtimeType != type.getRawType()) {\n-          TypeAdapter<?> adapter = context.getAdapter(runtimeType);\n-          ((TypeAdapter) adapter).write(writer, value);\n-          return;\n-        }\n-      }\n+//      if (false) {\n+//        Class<?> runtimeType = value.getClass();\n+//        if (runtimeType != type.getRawType()) {\n+//          TypeAdapter<?> adapter = context.getAdapter(runtimeType);\n+//          ((TypeAdapter) adapter).write(writer, value);\n+//          return;\n+//        }\n+//      }\n \n       writer.beginObject();\n       try {\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.JsonIOException;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.URI;\n   private TypeAdapters() {}\n \n   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n+    @Override\n     public Boolean read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return reader.nextBoolean();\n     }\n+    @Override\n     public void write(JsonWriter writer, Boolean value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(boolean.class, Boolean.class, BOOLEAN);\n \n   public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         throw new JsonSyntaxException(e);\n       }\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(byte.class, Byte.class, BYTE);\n \n   public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         throw new JsonSyntaxException(e);\n       }\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(short.class, Short.class, SHORT);\n \n   public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         throw new JsonSyntaxException(e);\n       }\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(int.class, Integer.class, INTEGER);\n \n   public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         throw new JsonSyntaxException(e);\n       }\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(long.class, Long.class, LONG);\n \n   public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return (float) reader.nextDouble();\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(float.class, Float.class, FLOAT);\n \n   public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n+    @Override\n     public Number read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return reader.nextDouble();\n     }\n+    @Override\n     public void write(JsonWriter writer, Number value) throws IOException {\n       writer.value(value);\n     }\n       = newFactory(double.class, Double.class, DOUBLE);\n \n   public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n+    @Override\n     public String read(JsonReader reader) throws IOException {\n       JsonToken peek = reader.peek();\n       if (peek == JsonToken.NULL) {\n       }\n       return reader.nextString();\n     }\n+    @Override\n     public void write(JsonWriter writer, String value) throws IOException {\n       writer.value(value);\n     }\n   public static final TypeAdapter.Factory STRING_FACTORY = newFactory(String.class, STRING);\n \n   public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n+    @Override\n     public StringBuilder read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return new StringBuilder(reader.nextString());\n     }\n+    @Override\n     public void write(JsonWriter writer, StringBuilder value) throws IOException {\n       writer.value(value.toString());\n     }\n     newFactory(StringBuilder.class, STRING_BUILDER);\n \n   public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n+    @Override\n     public StringBuffer read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return new StringBuffer(reader.nextString());\n     }\n+    @Override\n     public void write(JsonWriter writer, StringBuffer value) throws IOException {\n       writer.value(value.toString());\n     }\n     newFactory(StringBuffer.class, STRING_BUFFER);\n \n   public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n+    @Override\n     public URL read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       String nextString = reader.nextString();\n       return \"null\".equals(nextString) ? null : new URL(nextString);\n     }\n+    @Override\n     public void write(JsonWriter writer, URL value) throws IOException {\n       writer.value(value == null ? null : value.toExternalForm());\n     }\n   public static final TypeAdapter.Factory URL_FACTORY = newFactory(URL.class, URL);\n \n   public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n+    @Override\n     public URI read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         String nextString = reader.nextString();\n         return \"null\".equals(nextString) ? null : new URI(nextString);\n       } catch (URISyntaxException e) {\n-        throw new IOException(e);\n-      }\n-    }\n+        throw new JsonIOException(e);\n+      }\n+    }\n+    @Override\n     public void write(JsonWriter writer, URI value) throws IOException {\n       writer.value(value == null ? null : value.toASCIIString());\n     }\n   public static final TypeAdapter.Factory URI_FACTORY = newFactory(URI.class, URI);\n \n   public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n+    @Override\n     public InetAddress read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return InetAddress.getByName(reader.nextString());\n     }\n+    @Override\n     public void write(JsonWriter writer, InetAddress value) throws IOException {\n       writer.value(value.getHostAddress());\n     }\n     newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n \n   public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n+    @Override\n     public UUID read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n       }\n       return java.util.UUID.fromString(reader.nextString());\n     }\n+    @Override\n     public void write(JsonWriter writer, UUID value) throws IOException {\n       writer.value(value.toString());\n     }\n   public static final TypeAdapter.Factory UUID_FACTORY = newFactory(UUID.class, UUID);\n \n   public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n+    @Override\n     public Locale read(JsonReader reader) throws IOException {\n       if (reader.peek() == JsonToken.NULL) {\n         reader.nextNull(); // TODO: does this belong here?\n         return new Locale(language, country, variant);\n       }\n     }\n+    @Override\n     public void write(JsonWriter writer, Locale value) throws IOException {\n       writer.value(value.toString());\n     }\n--- a/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n import com.google.gson.common.MoreAsserts;\n import com.google.gson.common.TestTypes.BagOfPrimitives;\n import com.google.gson.common.TestTypes.ClassWithObjects;\n-import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n \n package com.google.gson.functional;\n \n+import com.google.gson.Gson;\n+import com.google.gson.common.MoreAsserts;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n-\n-import junit.framework.TestCase;\n-\n-import com.google.gson.Gson;\n-import com.google.gson.JsonParseException;\n-import com.google.gson.common.MoreAsserts;\n-import com.google.gson.common.TestTypes.BagOfPrimitives;\n-import com.google.gson.reflect.TypeToken;\n \n /**\n  * Functional tests for Json serialization and deserialization of collections.", "timestamp": 1316148952, "metainfo": ""}