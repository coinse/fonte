{"sha": "5d56ace149ae3264d2502d49dd85302fc613a27c", "log": "Fixed precedence parsing of group OR (,) in CSS selectors.  Added tests, and repaired cheekily / hastily / incorrectly modified test.", "commit": "\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n     CombiningEvaluator(Collection<Evaluator> evaluators) {\n         this();\n         this.evaluators.addAll(evaluators);\n+    }\n+\n+    Evaluator rightMostEvaluator() {\n+        return evaluators.size() > 0 ? evaluators.get(evaluators.size() - 1) : null;\n+    }\n+    \n+    void replaceRightMostEvaluator(Evaluator replacement) {\n+        evaluators.set(evaluators.size() - 1, replacement);\n     }\n \n     static final class And extends CombiningEvaluator {\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n     private void combinator(char combinator) {\n         tq.consumeWhitespace();\n         String subQuery = consumeSubQuery(); // support multi > childs\n-        Evaluator e;\n-\n-        if (evals.size() == 1)\n-            e = evals.get(0);\n-        else\n-            e = new CombiningEvaluator.And(evals);\n+\n+        Evaluator rootEval; // the new topmost evaluator\n+        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n+        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n+        boolean replaceRightMost = false;\n+\n+        if (evals.size() == 1) {\n+            rootEval = currentEval = evals.get(0);\n+            // make sure OR (,) has precedence:\n+            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n+                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n+                replaceRightMost = true;\n+            }\n+        }\n+        else {\n+            rootEval = currentEval = new CombiningEvaluator.And(evals);\n+        }\n         evals.clear();\n-        Evaluator f = parse(subQuery);\n-\n+\n+        // for most combinators: change the current eval into an AND of the current eval and the new eval\n         if (combinator == '>')\n-            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n+            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediateParent(currentEval));\n         else if (combinator == ' ')\n-            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n+            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.Parent(currentEval));\n         else if (combinator == '+')\n-            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n+            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.ImmediatePreviousSibling(currentEval));\n         else if (combinator == '~')\n-            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n-        else if (combinator == ',') { // group or\n+            currentEval = new CombiningEvaluator.And(newEval, new StructuralEvaluator.PreviousSibling(currentEval));\n+        else if (combinator == ',') { // group or.\n             CombiningEvaluator.Or or;\n-            if (e instanceof CombiningEvaluator.Or) {\n-                or = (CombiningEvaluator.Or) e;\n-                or.add(f);\n+            if (currentEval instanceof CombiningEvaluator.Or) {\n+                or = (CombiningEvaluator.Or) currentEval;\n+                or.add(newEval);\n             } else {\n                 or = new CombiningEvaluator.Or();\n-                or.add(e);\n-                or.add(f);\n+                or.add(currentEval);\n+                or.add(newEval);\n             }\n-            evals.add(or);\n+            currentEval = or;\n         }\n         else\n             throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n+\n+        if (replaceRightMost)\n+            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n+        else rootEval = currentEval;\n+        evals.add(rootEval);\n     }\n \n     private String consumeSubQuery() {\n--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n             Element parent = element.parent();\n             return parent != null && evaluator.matches(root, parent);\n         }\n+\n+        public String toString() {\n+            return String.format(\":ImmediateParent%s\", evaluator);\n+        }\n     }\n \n     static class PreviousSibling extends StructuralEvaluator {\n--- /dev/null\n+++ b/src/test/java/org/jsoup/select/QueryParserTest.java\n+package org.jsoup.select;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Tests for the Selector Query Parser.\n+ *\n+ * @author Jonathan Hedley\n+ */\n+public class QueryParserTest {\n+    @Test public void testOrGetsCorrectPrecedence() {\n+        // tests that a selector \"a b, c d, e f\" evals to (a AND b) OR (c AND d) OR (e AND f)\"\n+        // top level or, three child ands\n+        Evaluator eval = QueryParser.parse(\"a b, c d, e f\");\n+        assertTrue(eval instanceof CombiningEvaluator.Or);\n+        CombiningEvaluator.Or or = (CombiningEvaluator.Or) eval;\n+        assertEquals(3, or.evaluators.size());\n+        for (Evaluator innerEval: or.evaluators) {\n+            assertTrue(innerEval instanceof CombiningEvaluator.And);\n+            CombiningEvaluator.And and = (CombiningEvaluator.And) innerEval;\n+            assertEquals(2, and.evaluators.size());\n+            assertTrue(and.evaluators.get(0) instanceof Evaluator.Tag);\n+            assertTrue(and.evaluators.get(1) instanceof StructuralEvaluator.Parent);\n+        }\n+    }\n+\n+    @Test public void testParsesMultiCorrectly() {\n+        Evaluator eval = QueryParser.parse(\".foo > ol, ol > li + li\");\n+        assertTrue(eval instanceof CombiningEvaluator.Or);\n+        CombiningEvaluator.Or or = (CombiningEvaluator.Or) eval;\n+        assertEquals(2, or.evaluators.size());\n+\n+        CombiningEvaluator.And andLeft = (CombiningEvaluator.And) or.evaluators.get(0);\n+        CombiningEvaluator.And andRight = (CombiningEvaluator.And) or.evaluators.get(1);\n+\n+        assertEquals(\"ol :ImmediateParent.foo\", andLeft.toString());\n+        assertEquals(2, andLeft.evaluators.size());\n+        assertEquals(\"li :prevli :ImmediateParentol\", andRight.toString());\n+        assertEquals(2, andLeft.evaluators.size());\n+    }\n+}\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         Document doc = Jsoup.parse(h);\n         Elements els = doc.select(\".foo > ol, ol > li + li\");\n \n-        assertEquals(2, els.size());\n-        assertEquals(\"li\", els.get(0).tagName());\n-        assertEquals(\"Three\", els.get(1).text());\n+        assertEquals(3, els.size());\n+        assertEquals(\"ol\", els.get(0).tagName());\n+        assertEquals(\"Two\", els.get(1).text());\n+        assertEquals(\"Three\", els.get(2).text());\n     }\n \n     @Test public void generalSiblings() {", "timestamp": 1333686316, "metainfo": ""}