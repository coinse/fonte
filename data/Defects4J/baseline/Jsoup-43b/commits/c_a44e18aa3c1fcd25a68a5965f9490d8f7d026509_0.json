{"sha": "a44e18aa3c1fcd25a68a5965f9490d8f7d026509", "log": "Merge branch 'master' of https://github.com/jkowalczyk/jsoup into jkowalczyk-master", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n         private Charset charset = Charset.forName(\"UTF-8\");\n         private CharsetEncoder charsetEncoder = charset.newEncoder();\n         private boolean prettyPrint = true;\n+        private boolean forceAllElementAsBlock = false;\n         private int indentAmount = 1;\n \n         public OutputSettings() {}\n          */\n         public OutputSettings prettyPrint(boolean pretty) {\n             prettyPrint = pretty;\n+            return this;\n+        }\n+        \n+        /**\n+         * Get if forceAllElementAsBlock is enabled. Default is false. If enable, the HTML output methods will consider\n+         * all tags as block.\n+         * @return if pretty printing is enabled.\n+         */\n+        public boolean forceAllElementAsBlock() {\n+            return forceAllElementAsBlock;\n+        }\n+        \n+        /**\n+         * force or unforce rendering all elements as block.\n+         * @param forceBlock new forceAllElementAsBlock setting\n+         * @return this, for chaining\n+         */\n+        public OutputSettings forceAllElementAsBlock(boolean forceBlock) {\n+            forceAllElementAsBlock = forceBlock;\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n+        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.forceAllElementAsBlock()) )\n             indent(accum, depth, out);\n         accum\n                 .append(\"<\")\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n-            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n+            if (out.prettyPrint() && (!childNodes.isEmpty() && (tag.formatAsBlock() || (out.forceAllElementAsBlock() && childNodes.size()>1) || (out.forceAllElementAsBlock() && childNodes.size()==1 && !(childNodes.iterator().next() instanceof TextNode) ) )))\n                 indent(accum, depth, out);\n             accum.append(\"</\").append(tagName()).append(\">\");\n         }\n     }\n \n     private void html(StringBuilder accum) {\n-        for (Node node : childNodes)\n+        for (Node node : childNodes) \n             node.outerHtml(accum);\n     }\n     \n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             html = normaliseWhitespace(html);\n         }\n \n-        if (out.prettyPrint() && siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank())\n+        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.forceAllElementAsBlock() && siblingNodes().size()>0 && !isBlank()) )) \n             indent(accum, depth, out);\n         accum.append(html);\n     }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n         assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>Hello <span>jsoup <span>users</span></span></p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n     }\n+    \n+    @Test public void testForceAllElementAsBlock() {\n+        Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n+        doc.outputSettings().forceAllElementAsBlock(true);\n+        assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>\\n    Hello \\n    <span>\\n     jsoup \\n     <span>users</span>\\n    </span>\\n   </p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n+    }\n \n     @Test public void testSetIndent() {\n         Document doc = Jsoup.parse(\"<div><p>Hello\\nthere</p></div>\");\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Collector;\n-import org.jsoup.select.Elements;\n-import org.jsoup.select.Evaluator;\n-import org.jsoup.select.Selector;\n+import org.jsoup.select.*;\n \n import java.util.*;\n import java.util.regex.Pattern;\n      * a filtered list of children that are elements, and the index is based on that filtered list.\n      * \n      * @param index the index number of the element to retrieve\n-     * @return the child element, if it exists, or {@code null} if absent.\n+     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n      * @see #childNode(int)\n      */\n     public Element child(int index) {\n     /**\n      * Add a node child node to this element.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element appendChild(Node child) {\n         addChildren(child);\n         return this;\n     }\n-    \n+\n     /**\n      * Add a node to the start of this element's children.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element prependChild(Node child) {\n         Validate.notNull(child);\n         \n         addChildren(0, child);\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n+     *\n+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n+     * end\n+     * @param children child nodes to insert\n+     * @return this element, for chaining.\n+     */\n+    public Element insertChildren(int index, Collection<? extends Node> children) {\n+        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n+        int currentSize = childNodeSize();\n+        if (index < 0) index += currentSize +1; // roll around\n+        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n+\n+        ArrayList<Node> nodes = new ArrayList<Node>(children);\n+        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n+        addChildren(index, nodeArray);\n         return this;\n     }\n     \n      * @see #textNodes()\n      */\n     public String text() {\n-        StringBuilder sb = new StringBuilder();\n-        text(sb);\n-        return sb.toString().trim();\n-    }\n-\n-    private void text(StringBuilder accum) {\n-        appendWhitespaceIfBr(this, accum);\n-        \n-        for (Node child : childNodes) {\n-            if (child instanceof TextNode) {\n-                TextNode textNode = (TextNode) child;\n-                appendNormalisedText(accum, textNode);\n-            } else if (child instanceof Element) {\n-                Element element = (Element) child;\n-                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n-                    accum.append(\" \");\n-                element.text(accum);\n+        final StringBuilder accum = new StringBuilder();\n+        new NodeTraversor(new NodeVisitor() {\n+            public void head(Node node, int depth) {\n+                if (node instanceof TextNode) {\n+                    TextNode textNode = (TextNode) node;\n+                    appendNormalisedText(accum, textNode);\n+                } else if (node instanceof Element) {\n+                    Element element = (Element) node;\n+                    if (accum.length() > 0 &&\n+                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n+                        !TextNode.lastCharIsWhitespace(accum))\n+                        accum.append(\" \");\n+                }\n             }\n-        }\n+\n+            public void tail(Node node, int depth) {\n+            }\n+        }).traverse(this);\n+        return accum.toString().trim();\n     }\n \n     /**\n         }\n     }\n \n-    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n+    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n         String text = textNode.getWholeText();\n \n-        if (!preserveWhitespace()) {\n+        if (!preserveWhitespace(textNode.parent())) {\n             text = TextNode.normaliseWhitespace(text);\n             if (TextNode.lastCharIsWhitespace(accum))\n                 text = TextNode.stripLeadingWhitespace(text);\n             accum.append(\" \");\n     }\n \n-    boolean preserveWhitespace() {\n-        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n+    static boolean preserveWhitespace(Node node) {\n+        // looks only at this element and one level up, to prevent recursion & needless stack searches\n+        if (node != null && node instanceof Element) {\n+            Element element = (Element) node;\n+            return element.tag.preserveWhitespace() ||\n+                element.parent() != null && element.parent().tag.preserveWhitespace();\n+        }\n+        return false;\n     }\n \n     /**\n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames(); // creates linked set of class names from class attribute\n+        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n         return clone;\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     }\n \n     /**\n-     Get a child node by index\n+     Get a child node by its 0-based index.\n      @param index index of child node\n-     @return the child node at this index.\n+     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n      */\n     public Node childNode(int index) {\n         return childNodes.get(index);\n      @return list of children. If no children, returns an empty list.\n      */\n     public List<Node> childNodes() {\n-        // actually returns the real list, as this method is hit many times during selection, and so is a GC time-sink\n-        // leaving the documentation as is (warning of unmodifiability) to discourage out-of-API modifications\n-        return childNodes;\n+        return Collections.unmodifiableList(childNodes);\n+    }\n+\n+    /**\n+     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\n+     * nodes\n+     * @return a deep copy of this node's children\n+     */\n+    public List<Node> childNodesCopy() {\n+        List<Node> children = new ArrayList<Node>(childNodes.size());\n+        for (Node node : childNodes) {\n+            children.add(node.clone());\n+        }\n+        return children;\n+    }\n+\n+    /**\n+     * Get the number of child nodes that this node holds.\n+     * @return the number of child nodes that this node holds.\n+     */\n+    public final int childNodeSize() {\n+        return childNodes.size();\n     }\n     \n     protected Node[] childNodesAsArray() {\n-        return childNodes.toArray(new Node[childNodes().size()]);\n+        return childNodes.toArray(new Node[childNodeSize()]);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n         String html = Entities.escape(getWholeText(), out);\n-        if (out.prettyPrint() && parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {\n+        if (out.prettyPrint() && parent() instanceof Element && !Element.preserveWhitespace((Element) parent())) {\n             html = normaliseWhitespace(html);\n         }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n                             LinkedList<Element> stack = tb.getStack();\n-                            for (int si = 0; si < stack.size(); si++) {\n+                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n+                            // run-aways\n+                            for (int si = 0; si < stack.size() && si < 64; si++) {\n                                 Element el = stack.get(si);\n                                 if (el == formatEl) {\n                                     commonAncestor = stack.get(si - 1);\n                             }\n \n                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                             for (Node childNode : childNodes) {\n                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                             }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     }\n \n     /**\n+     * Parse a fragment of XML into a list of nodes.\n+     *\n+     * @param fragmentXml the fragment of XML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @return list of nodes parsed from the input XML.\n+     */\n+    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n+        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+    }\n+\n+    /**\n      * Parse a fragment of HTML into the {@code body} of a Document.\n      *\n      * @param bodyHtml fragment of HTML\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n             \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n-            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n             \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n     };\n     private static final String[] inlineTags = {\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n-            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n+            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n+            \"ins\", \"del\", \"s\"\n     };\n     private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.nodes.*;\n \n import java.util.Iterator;\n+import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n             }\n         }\n     }\n+\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n+        initialiseParse(inputFragment, baseUri, errors);\n+        runParser();\n+        return doc.childNodes();\n+    }\n }\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n     public Elements(Element... elements) {\n         this(Arrays.asList(elements));\n     }\n-    \n+\n+    /**\n+     * Creates a deep copy of these elements.\n+     * @return a deep copy\n+     */\n     @Override\n \tpublic Elements clone() {\n     \tList<Element> elements = new ArrayList<Element>();\n     // list-like methods\n     /**\n      Get the first matched element.\n-     @return The first matched element, or <code>null</code> if contents is empty;\n+     @return The first matched element, or <code>null</code> if contents is empty.\n      */\n     public Element first() {\n         return contents.isEmpty() ? null : contents.get(0);\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n         \n         while (node != null) {\n             visitor.head(node, depth);\n-            if (node.childNodes().size() > 0) {\n+            if (node.childNodeSize() > 0) {\n                 node = node.childNode(0);\n                 depth++;\n             } else {\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n import java.util.Map;\n         assertEquals(\"<div><p>One</p><p><span>Two</span></p></div><p><span>Two</span><span>Three</span></p>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n+    @Test public void testClonesClassnames() {\n+        Document doc = Jsoup.parse(\"<div class='one two'></div>\");\n+        Element div = doc.select(\"div\").first();\n+        Set<String> classes = div.classNames();\n+        assertEquals(2, classes.size());\n+        assertTrue(classes.contains(\"one\"));\n+        assertTrue(classes.contains(\"two\"));\n+\n+        Element copy = div.clone();\n+        Set<String> copyClasses = copy.classNames();\n+        assertEquals(2, copyClasses.size());\n+        assertTrue(copyClasses.contains(\"one\"));\n+        assertTrue(copyClasses.contains(\"two\"));\n+        copyClasses.add(\"three\");\n+        copyClasses.remove(\"one\");\n+\n+        assertTrue(classes.contains(\"one\"));\n+        assertFalse(classes.contains(\"three\"));\n+        assertFalse(copyClasses.contains(\"one\"));\n+        assertTrue(copyClasses.contains(\"three\"));\n+\n+        assertEquals(\"\", div.html());\n+        assertEquals(\"\", copy.html());\n+    }\n+\n     @Test public void testTagNameSet() {\n         Document doc = Jsoup.parse(\"<div><i>Hello</i>\");\n         doc.select(\"i\").first().tagName(\"em\");\n         assertEquals(\"<p>One</p>\", els.get(0).outerHtml());\n         assertEquals(\"<p>Three</p>\", els.get(1).outerHtml());\n     }\n+\n+    @Test public void testChildThrowsIndexOutOfBoundsOnMissing() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p></div>\");\n+        Element div = doc.select(\"div\").first();\n+\n+        assertEquals(2, div.children().size());\n+        assertEquals(\"One\", div.child(0).text());\n+\n+        try {\n+            div.child(3);\n+            fail(\"Should throw index out of bounds\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    @Test\n+    public void moveByAppend() {\n+        // test for https://github.com/jhy/jsoup/issues/239\n+        // can empty an element and append its children to another element\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(4, div1.childNodeSize());\n+        List<Node> children = div1.childNodes();\n+        assertEquals(4, children.size());\n+\n+        div2.insertChildren(0, children);\n+\n+        assertEquals(0, children.size()); // children is backed by div1.childNodes, moved, so should be 0 now\n+        assertEquals(0, div1.childNodeSize());\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\"></div>\\n<div id=\\\"2\\\">\\n Text \\n <p>One</p> Text \\n <p>Two</p>\\n</div>\",\n+            doc.body().html());\n+    }\n+\n+    @Test\n+    public void insertChildrenArgumentValidation() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        List<Node> children = div1.childNodes();\n+\n+        try {\n+            div2.insertChildren(6, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n+\n+        try {\n+            div2.insertChildren(-5, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        try {\n+            div2.insertChildren(0, null);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void insertChildrenAtPosition() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text1 <p>One</p> Text2 <p>Two</p></div><div id=2>Text3 <p>Three</p></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Elements p1s = div1.select(\"p\");\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(2, div2.childNodeSize());\n+        div2.insertChildren(-1, p1s);\n+        assertEquals(2, div1.childNodeSize()); // moved two out\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(3, p1s.get(1).siblingIndex()); // should be last\n+\n+        List<Node> els = new ArrayList<Node>();\n+        Element el1 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span1\");\n+        Element el2 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span2\");\n+        TextNode tn1 = new TextNode(\"Text4\", \"\");\n+        els.add(el1);\n+        els.add(el2);\n+        els.add(tn1);\n+\n+        assertNull(el1.parent());\n+        div2.insertChildren(-2, els);\n+        assertEquals(div2, el1.parent());\n+        assertEquals(7, div2.childNodeSize());\n+        assertEquals(3, el1.siblingIndex());\n+        assertEquals(4, el2.siblingIndex());\n+        assertEquals(5, tn1.siblingIndex());\n+    }\n+\n+    @Test\n+    public void insertChildrenAsCopy() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        Elements ps = doc.select(\"p\").clone();\n+        ps.first().text(\"One cloned\");\n+        div2.insertChildren(-1, ps);\n+\n+        assertEquals(4, div1.childNodeSize()); // not moved -- cloned\n+        assertEquals(2, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\">Text <p>One</p> Text <p>Two</p></div><div id=\\\"2\\\"><p>One cloned</p><p>Two</p></div>\",\n+            TextUtil.stripNewlines(doc.body().html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n         assertEquals(\"odd\", el.attr(\"abs:href\"));\n     }\n \n+    @Test public void handleAbsOnFileUris() {\n+        Document doc = Jsoup.parse(\"<a href='password'>One/a><a href='/var/log/messages'>Two</a>\", \"file:/etc/\");\n+        Element one = doc.select(\"a\").first();\n+        assertEquals(\"file:/etc/password\", one.absUrl(\"href\"));\n+        Element two = doc.select(\"a\").get(1);\n+        assertEquals(\"file:/var/log/messages\", two.absUrl(\"href\"));\n+    }\n+\n+    @Test\n+    public void handleAbsOnLocalhostFileUris() {\n+        Document doc = Jsoup.parse(\"<a href='password'>One/a><a href='/var/log/messages'>Two</a>\", \"file://localhost/etc/\");\n+        Element one = doc.select(\"a\").first();\n+        assertEquals(\"file://localhost/etc/password\", one.absUrl(\"href\"));\n+    }\n+\n     /*\n     Test for an issue with Java's abs URL handler.\n      */\n         assertEquals(\"<p>One</p>\", nodes.get(0).outerHtml());\n         assertEquals(\"<p>Three</p>\", nodes.get(1).outerHtml());\n     }\n+\n+    @Test public void childNodesCopy() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text 1 <p>One</p> Text 2 <p>Two<p>Three</div><div id=2>\");\n+        Element div1 = doc.select(\"#1\").first();\n+        Element div2 = doc.select(\"#2\").first();\n+        List<Node> divChildren = div1.childNodesCopy();\n+        assertEquals(5, divChildren.size());\n+        TextNode tn1 = (TextNode) div1.childNode(0);\n+        TextNode tn2 = (TextNode) divChildren.get(0);\n+        tn2.text(\"Text 1 updated\");\n+        assertEquals(\"Text 1 \", tn1.text());\n+        div2.insertChildren(-1, divChildren);\n+        assertEquals(\"<div id=\\\"1\\\">Text 1 <p>One</p> Text 2 <p>Two</p><p>Three</p></div><div id=\\\"2\\\">Text 1 updated\"\n+            +\"<p>One</p> Text 2 <p>Two</p><p>Three</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         Element div = doc.getElementById(\"1\");\n         assertEquals(\"<html> <foo><&amp;\", div.text());\n         assertEquals(0, div.children().size());\n-        assertEquals(1, div.childNodes().size()); // no elements, one text node\n+        assertEquals(1, div.childNodeSize()); // no elements, one text node\n     }\n \n     @Test public void handlesInvalidStartTags() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URISyntaxException;\n+import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotSame;\n         assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n         assertEquals(\"#comment\", doc.childNode(2).nodeName());\n     }\n+\n+    @Test public void xmlFragment() {\n+        String xml = \"<one src='/foo/' />Two<three><four /></three>\";\n+        List<Node> nodes = Parser.parseXmlFragment(xml, \"http://example.com/\");\n+        assertEquals(3, nodes.size());\n+\n+        assertEquals(\"http://example.com/foo/\", nodes.get(0).absUrl(\"src\"));\n+        assertEquals(\"one\", nodes.get(0).nodeName());\n+        assertEquals(\"Two\", ((TextNode)nodes.get(1)).text());\n+    }\n }\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n         Document dirtyDoc = Jsoup.parse(dirty);\n         Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n         assertFalse(cleanDoc == null);\n-        assertEquals(0, cleanDoc.body().childNodes().size());\n+        assertEquals(0, cleanDoc.body().childNodeSize());\n     }\n \n     @Test public void cleansInternationalText() {", "timestamp": 1359247560, "metainfo": ""}