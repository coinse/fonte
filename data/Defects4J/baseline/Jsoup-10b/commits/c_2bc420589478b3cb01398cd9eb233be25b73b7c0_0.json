{"sha": "2bc420589478b3cb01398cd9eb233be25b73b7c0", "log": "Initial implementation of TokenStream.", "commit": "\n--- a/src/main/java/org/jsoup/parser/ParserRuntimeException.java\n+++ b/src/main/java/org/jsoup/parser/ParserRuntimeException.java\n package org.jsoup.parser;\n \n /**\n- TODO: Document\n+ Runtime exception to wrap up unlikely checked exceptions thrown when parsing.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class ParserRuntimeException {\n+public class ParserRuntimeException extends RuntimeException {\n+    private Position pos;\n+\n+    public ParserRuntimeException(String message, Throwable cause, Position pos) {\n+        super(message, cause);\n+        this.pos = pos;\n+    }\n+\n+    public Position getPos() {\n+        return pos;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Position.java\n+++ b/src/main/java/org/jsoup/parser/Position.java\n package org.jsoup.parser;\n \n /**\n- TODO: Document\n+ The start position (line & column number) that a token / node was found at.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Position {\n+public final class Position implements Cloneable {\n+    private int offset = 0;\n+    private int lineNum = 1;\n+    private int colNum = 1;\n+\n+    public int incOffset() {\n+        return offset++;\n+    }\n+\n+    public int incLineNum() {\n+        return lineNum++;\n+    }\n+\n+    public int incColNum() {\n+        return colNum++;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    public void setOffset(int offset) {\n+        this.offset = offset;\n+    }\n+\n+    public int getLineNum() {\n+        return lineNum;\n+    }\n+\n+    public void setLineNum(int lineNum) {\n+        this.lineNum = lineNum;\n+    }\n+\n+    public int getColNum() {\n+        return colNum;\n+    }\n+\n+    public void setColNum(int colNum) {\n+        this.colNum = colNum;\n+    }\n+\n+    @Override\n+    protected Position clone() {\n+        try {\n+            return (Position) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Position position = (Position) o;\n+\n+        if (colNum != position.colNum) return false;\n+        if (lineNum != position.lineNum) return false;\n+        if (offset != position.offset) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = offset;\n+        result = 31 * result + lineNum;\n+        result = 31 * result + colNum;\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s:%s\", lineNum, colNum);\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n package org.jsoup.parser;\n \n /**\n- TODO: Document\n+ A Token of HTML. Internal use only.\n \n- @author Jonathan Hedley, jonathan@hedley.net, Dec 19, 2009 */\n-public class Token {\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+class Token {\n+    private String data;\n+    private Position pos;\n+\n+\n+    Token(String data, Position pos) {\n+        this.data = data;\n+        this.pos = pos;\n+    }\n+\n+    public String getData() {\n+        return data;\n+    }\n+\n+    public void setData(String data) {\n+        this.data = data;\n+    }\n+\n+    public Position getPos() {\n+        return pos;\n+    }\n+\n+    public void setPos(Position pos) {\n+        this.pos = pos;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Token token = (Token) o;\n+\n+        if (data != null ? !data.equals(token.data) : token.data != null) return false;\n+        if (pos != null ? !pos.equals(token.pos) : token.pos != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = data != null ? data.hashCode() : 0;\n+        result = 31 * result + (pos != null ? pos.hashCode() : 0);\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s (%s)\", data, pos);\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/TokenStream.java\n+++ b/src/main/java/org/jsoup/parser/TokenStream.java\n package org.jsoup.parser;\n \n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n /**\n- TODO: Document\n+ Splits a given input into a stream of {@link Token Tokens}. (Internal use only).\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class TokenStream {\n+class TokenStream implements Iterator<Token> {\n+    private static final int BUFFER_SIZE = 5 * 1024;\n+    private static final char LT = \"<\".charAt(0);\n+    private static final char GT = \">\".charAt(0);\n+    private static final char NL = \"\\n\".charAt(0);\n+\n+    private final Reader in;\n+    private final CharBuffer buffer;\n+    private final StringBuilder accum;\n+    private final boolean autoCloseReader;\n+    private final Position pos;\n+\n+    private TokenStream(Reader reader, boolean autoCloseReader) {\n+        this.in = reader;\n+        this.autoCloseReader = autoCloseReader;\n+        buffer = CharBuffer.allocate(BUFFER_SIZE);\n+        accum = new StringBuilder(BUFFER_SIZE / 2);\n+        pos = new Position();\n+\n+        fillBuffer();\n+    }\n+\n+    /**\n+     TokenStream factory: extract tokens from the supplied Reader. Don't forget to close the Reader once you're done.\n+     @param reader input reader\n+     @return TokenStream of HTML.\n+     */\n+    public static TokenStream create(Reader reader) {\n+        return new TokenStream(reader, false);\n+    }\n+\n+    /**\n+     TokenStream factory method: extract tokens from a String.\n+     @param data String of HTML data.\n+     @return TokenStream of HTML.\n+     */\n+    public static TokenStream create(String data) {\n+        StringReader reader = new StringReader(data);\n+        return new TokenStream(reader, true);\n+    }\n+\n+    /**\n+     Test if there are any more tokens to be retrieved.\n+     @return true if there are tokens remaining, false if all have been read.\n+     */\n+    public boolean hasNext() {\n+        boolean hasNext = (buffer.hasRemaining() || (fillBuffer() > -1));\n+\n+        if (!hasNext && autoCloseReader)\n+            try {\n+                in.close();\n+            } catch (IOException e) {\n+                throw new ParserRuntimeException(\"IO exception whilst auto-closing reader\", e, pos);\n+            }\n+        return hasNext;\n+    }\n+\n+    /**\n+     Retrieve the next Token. Make sure there are some left using hasNext().\n+     @return next token from stream.\n+     */\n+    public Token next() {\n+        Position curPos = pos.clone();\n+\n+        String tokenData = accumulate();\n+        return new Token(tokenData, curPos);\n+    }\n+\n+    List<Token> asList() {\n+        List<Token> tokens = new ArrayList<Token>();\n+        while (hasNext()) {\n+            tokens.add(next());\n+        }\n+        return tokens;\n+    }\n+\n+    private String accumulate() {\n+        while (hasNext()) {\n+            buffer.mark();\n+            char c = buffer.get();\n+\n+            if (c == LT && accum.length() > 0) {\n+                // leave on stack for next accumulate\n+                buffer.reset();\n+                return captureAccum();\n+            } else {\n+                accum.append(c);\n+                pos.incOffset();\n+                pos.incColNum();\n+\n+                if (c == GT) {\n+                    return captureAccum();\n+                } else if (c == NL) {\n+                    pos.incLineNum();\n+                }\n+            }\n+        }\n+        return captureAccum();\n+    }\n+\n+    private int fillBuffer() {\n+        buffer.clear();\n+        try {\n+            int charsRead = in.read(buffer);\n+            buffer.flip();\n+            return charsRead;\n+        } catch (IOException e) {\n+            throw new ParserRuntimeException(\"IO exception whilst reading\", e, pos);\n+        }\n+    }\n+\n+    private String captureAccum() {\n+        String output = accum.toString();\n+        accum.delete(0, accum.length());\n+        return output;\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException();\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/TokenStreamTest.java\n+++ b/src/test/java/org/jsoup/parser/TokenStreamTest.java\n package org.jsoup.parser;\n \n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import java.util.List;\n+\n+\n /**\n- TODO: Document\n+ TokenStream test cases.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TokenStreamTest {\n+    @Test\n+    public void createTokenStreamFromString() {\n+        List<Token> tokens = TokenStream.create(\"<html><body><p>Hello world!</p></body></html>\").asList();\n+        assertEquals(\"Correct num tokens\", 7, tokens.size());\n+    }\n+\n+    // TODO: test data, positions, line breaks\n }", "timestamp": 1309605099, "metainfo": ""}