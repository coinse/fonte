{"sha": "3502de0ed0d928516c0751095af62e48f574f803", "log": "Fix #177", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n //System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n             // And just in case a field name was to be returned, wipe it\n             _nextToken = null;\n-            // and last thing, [Issue#33], better ignore attributes\n+            // and last thing, [dataformat-xml#33], better ignore attributes\n             _xmlTokens.skipAttributes();\n             return true;\n         }\n     // DEBUGGING\n     /*\n     @Override\n-    public JsonToken nextToken() throws IOException, JsonParseException\n+    public JsonToken nextToken() throws IOException\n     {\n         JsonToken t = nextToken0();\n         if (t != null) {\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n-        _binaryValue = null; // to fix [Issue-29]\n+        _binaryValue = null;\n         if (_nextToken != null) {\n             JsonToken t = _nextToken;\n             _currToken = t;\n         }\n         int token = _xmlTokens.next();\n \n-        /* Need to have a loop just because we may have to eat/convert\n-         * a start-element that indicates an array element.\n-         */\n+        // Need to have a loop just because we may have to eat/convert\n+        // a start-element that indicates an array element.\n         while (token == XmlTokenStream.XML_START_ELEMENT) {\n             // If we thought we might get leaf, no such luck\n             if (_mayBeLeaf) {\n                 return (_currToken = JsonToken.START_OBJECT);\n             }\n             if (_parsingContext.inArray()) {\n-                /* Yup: in array, so this element could be verified; but it won't be reported\n-                 * anyway, and we need to process following event.\n-                 */\n+                // Yup: in array, so this element could be verified; but it won't be\n+                // reported anyway, and we need to process following event.\n                 token = _xmlTokens.next();\n                 _mayBeLeaf = true;\n                 continue;\n             String name = _xmlTokens.getLocalName();\n             _parsingContext.setCurrentName(name);\n \n-            /* Ok: virtual wrapping can be done by simply repeating\n-             * current START_ELEMENT. Couple of ways to do it; but\n-             * start by making _xmlTokens replay the thing...\n-             */\n+            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n+            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                 _xmlTokens.repeatStartElement();\n             }\n \n             _mayBeLeaf = true;\n-            /* Ok: in array context we need to skip reporting field names. But what's the best way\n-             * to find next token?\n-             */\n+            // Ok: in array context we need to skip reporting field names.\n+            // But what's the best way to find next token?\n             return (_currToken = JsonToken.FIELD_NAME);\n         }\n \n                     }\n                 }\n                 return (_currToken = JsonToken.VALUE_STRING);\n-            }\n-            // If not a leaf, need to transform into property...\n+            } else {\n+                // [dataformat-xml#177]: empty text may also need to be skipped\n+                if (_parsingContext.inObject()\n+                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n+                    _currToken = JsonToken.END_OBJECT;\n+                    _parsingContext = _parsingContext.getParent();\n+                    _namesToWrap = _parsingContext.getNamesToWrap();\n+                    return _currToken;\n+                }\n+            }\n+            // If not a leaf (or otherwise ignorable), need to transform into property...\n             _parsingContext.setCurrentName(_cfgNameForTextElement);\n             _nextToken = JsonToken.VALUE_STRING;\n             return (_currToken = JsonToken.FIELD_NAME);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/EmptyListDeserTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+// for [dataformat-xml#177]\n+public class EmptyListDeserTest extends XmlTestBase\n+{\n+    static class Config\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String id;\n+        \n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Entry> entry;\n+    }\n+\n+    static class Entry\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String id;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testEmptyList() throws Exception\n+    {\n+        Config r = MAPPER.readValue(\n+                \"<Config id='123'>\\n\"+\n+                \"  <entry id='foo'> </entry>\\n\"+\n+                \"</Config>\\n\",\n+                Config.class);\n+        assertNotNull(r);\n+    }\n+}", "timestamp": 1450931551, "metainfo": ""}