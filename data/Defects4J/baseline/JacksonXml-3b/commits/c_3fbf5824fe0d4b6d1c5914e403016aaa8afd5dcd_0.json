{"sha": "3fbf5824fe0d4b6d1c5914e403016aaa8afd5dcd", "log": "Fix issue #72", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    /**\n+     * (Simple) Names of properties, for which virtual wrapping is needed\n+     * to compensate: these are so-called 'unwrapped' XML lists where property\n+     * name is used for elements, and not as List markers.\n+     */\n     protected final Set<String> _namesToWrap;\n-    \n+\n     /*\n     /**********************************************************************\n     /* Construction\n         this(delegate, null);\n     }\n \n-    public WrapperHandlingDeserializer(BeanDeserializerBase delegate,\n-            Set<String> namesToWrap) {\n+    public WrapperHandlingDeserializer(BeanDeserializerBase delegate, Set<String> namesToWrap)\n+    {\n         super(delegate);\n         _namesToWrap = namesToWrap;\n     }\n             BeanProperty property, JsonDeserializer<?> newDelegatee0)\n     {\n         BeanDeserializerBase newDelegatee = _verifyDeserType(newDelegatee0);\n-\n-//System.out.println(\"DEBUG: createContextual!\");\n         \n         // Let's go through the properties now...\n         Iterator<SettableBeanProperty> it = newDelegatee.properties();\n     /**********************************************************************\n      */\n \n-    protected void _configureParser(JsonParser jp)\n+    protected final void _configureParser(JsonParser jp)\n         throws IOException, JsonProcessingException\n     {\n         /* 19-Aug-2013, tatu: Although we should not usually get called with\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n         if (!deser.getValueInstantiator().canCreateFromString()) {\n             SettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\n             if (textProp != null) {\n-//                System.err.println(\"DEBUG: gotcha! \"+textProp);\n-                // !!! TODO\n+                return new XmlTextDeserializer(deser, textProp);\n             }\n         }\n         return new WrapperHandlingDeserializer(deser);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTextDeserializer.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.std.DelegatingDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Delegating deserializer that is used in the special cases where\n+ * we may sometimes see a \"plain\" String value but need to map it\n+ * as if it was a property of POJO. The impedance is introduced by\n+ * heuristic conversion from XML events into rough JSON equivalents;\n+ * and this is one work-around that can only be done after the fact.\n+ */\n+public class XmlTextDeserializer\n+    extends DelegatingDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Property index of the \"XML text property\"; needed for finding actual\n+     * property instance after resolution and contextualization: instance\n+     * may change, but index will remain constant.\n+     */\n+    protected final int _xmlTextPropertyIndex;\n+    \n+    /**\n+     * Actual property that is indicated to be of type \"XML Text\" (and\n+     * is the only element-valued property)\n+     */\n+    protected final SettableBeanProperty _xmlTextProperty;\n+\n+    protected final ValueInstantiator _valueInstantiator;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Construction\n+    /**********************************************************************\n+     */\n+\n+    public XmlTextDeserializer(BeanDeserializerBase delegate, SettableBeanProperty prop)\n+    {\n+        super(delegate);\n+        _xmlTextProperty = prop;\n+        _xmlTextPropertyIndex = prop.getPropertyIndex();\n+        _valueInstantiator = delegate.getValueInstantiator();\n+    }\n+    \n+    public XmlTextDeserializer(BeanDeserializerBase delegate, int textPropIndex)\n+    {\n+        super(delegate);\n+        _xmlTextPropertyIndex = textPropIndex;\n+        _valueInstantiator = delegate.getValueInstantiator();\n+        _xmlTextProperty = delegate.findProperty(textPropIndex);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Abstract method implementations\n+    /**********************************************************************\n+     */\n+    \n+    @Override\n+    protected JsonDeserializer<?> newDelegatingInstance(JsonDeserializer<?> newDelegatee) {\n+        return new XmlTextDeserializer(_verifyDeserType(newDelegatee), _xmlTextPropertyIndex);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Overridden methods\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * We need to override this method; otherwise underlying changes to XML text\n+     * property will go unnoticed. Otherwise default handling should work fine.\n+     */\n+    @Override\n+    protected JsonDeserializer<?> _createContextual(DeserializationContext ctxt,\n+            BeanProperty property, JsonDeserializer<?> newDelegatee0)\n+    {\n+        BeanDeserializerBase newDelegatee = _verifyDeserType(newDelegatee0);\n+        return new XmlTextDeserializer(newDelegatee, _xmlTextPropertyIndex);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Overridden deserialization methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+            _xmlTextProperty.deserializeAndSet(jp, ctxt, bean);\n+            return bean;\n+        }\n+        return _delegatee.deserialize(jp,  ctxt);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            _xmlTextProperty.deserializeAndSet(jp, ctxt, bean);\n+            return bean;\n+        }\n+        return ((JsonDeserializer<Object>)_delegatee).deserialize(jp, ctxt, bean);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _delegatee.deserializeWithType(jp, ctxt, typeDeserializer);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal methods\n+    /**********************************************************************\n+     */\n+\n+    protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n+    {\n+        if (!(deser instanceof BeanDeserializerBase)) {\n+            throw new IllegalArgumentException(\"Can not change delegate to be of type \"\n+                    +deser.getClass().getName());\n+        }\n+        return (BeanDeserializerBase) deser;\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestTextValue.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestTextValue.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n \n         protected String textValue;\n     }\n \n+    // [Issue#72]\n+    \n+    static class TextOnlyBean\n+    {\n+        @JacksonXmlText\n+        protected String textValue;\n+\n+        public TextOnlyBean() { }\n+        public TextOnlyBean(String str, boolean foo) { textValue = str; }\n+    }\n+\n+    @JsonPropertyOrder({ \"a\", \"b\" })\n+    static class TextOnlyWrapper\n+    {\n+        public TextOnlyBean a, b;\n+\n+        public TextOnlyWrapper() { }\n+        public TextOnlyWrapper(String a, String b) {\n+            this.a = new TextOnlyBean(a, true);\n+            this.b = new TextOnlyBean(b, true);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n         String json = mapper.writeValueAsString(node);\n         assertEquals(XML, json);\n     }\n+\n+    // [Issue#72]\n+    public void testTextOnlyPojo() throws Exception\n+    {\n+        XmlMapper mapper = xmlMapper(true);\n+        TextOnlyWrapper input = new TextOnlyWrapper(\"foo\", \"bar\");\n+        // serialization should work fine\n+        String xml = mapper.writeValueAsString(input);\n+        assertEquals(\"<TextOnlyWrapper><a>foo</a><b>bar</b></TextOnlyWrapper>\", xml);\n+        // but how about deser?\n+        TextOnlyWrapper result = mapper.readValue(xml, TextOnlyWrapper.class);\n+        assertNotNull(result);\n+        assertEquals(\"foo\", result.a.textValue);\n+        assertEquals(\"bar\", result.b.textValue);\n+    }\n }", "timestamp": 1376979716, "metainfo": ""}