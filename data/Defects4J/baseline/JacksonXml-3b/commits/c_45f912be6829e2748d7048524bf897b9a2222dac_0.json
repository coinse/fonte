{"sha": "45f912be6829e2748d7048524bf897b9a2222dac", "log": "Merge branch '2.6'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n         if (!_objectIndenter.isInline()) {\n             if (_justHadStartElement) {\n                 _justHadStartElement = false;\n-            } else {\n-                _objectIndenter.writeIndentation(sw, _nesting);\n             }\n+            _objectIndenter.writeIndentation(sw, _nesting);\n             ++_nesting;\n         }\n         sw.writeStartElement(nsURI, localName);\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n \n public class TestIndentation extends XmlTestBase\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     static class StringWrapperBean {\n         public StringWrapper string;\n         \n         public IntWrapperBean(int i) { wrapped = new IntWrapper(i); }\n     }\n \n-    // [Issue#45]\n+    // [dataformat-xml#45]\n     static class AttrBean {\n         @JacksonXmlProperty(isAttribute=true)\n         public int count = 3;\n         public PojoFor123(String name) {\n             this.name = name;       \n         }\n+    }\n+\n+    // for [dataformat-xml#172]\n+    static class Company {\n+        @JacksonXmlElementWrapper(localName=\"e\")\n+        public List<Employee> employee = new ArrayList<Employee>();\n+    }\n+\n+    static class Employee {\n+        public String id;\n+        public EmployeeType type;\n+\n+        public Employee(String id) {\n+            this.id = id;\n+            type = EmployeeType.FULL_TIME;\n+        }\n+    }\n+\n+    static enum EmployeeType {\n+        FULL_TIME;\n     }\n \n     /*\n         StringWrapperBean input = new StringWrapperBean(\"abc\");\n         String xml = _xmlMapper.writeValueAsString(input); \n \n-System.err.println(\"XML == \"+xml);        \n-        \n         // should have at least one linefeed, space...\n         if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n             fail(\"No indentation: XML == \"+xml);\n         assertEquals(\"b\", map.get(\"a\"));\n     }\n \n-    // [Issue#45]: Use of attributes should not force linefeed for empty elements\n+    // [dataformat-xml#45]: Use of attributes should not force linefeed for empty elements\n     public void testWithAttr() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new AttrBean());\n         assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\", xml);\n     }\n \n-}\n+    public void testMultiLevel172() throws Exception\n+    {\n+        Company root = new Company();\n+        root.employee.add(new Employee(\"abc\"));\n+        String xml = _xmlMapper.writeValueAsString(root);\n+        assertEquals(\"<Company>\\n\"\n+                +\"  <e>\\n\"\n+                +\"    <employee>\\n\"\n+                +\"      <id>abc</id>\\n\"\n+                +\"      <type>FULL_TIME</type>\\n\"\n+                +\"    </employee>\\n\"\n+                +\"  </e>\\n\"\n+                +\"</Company>\",\n+                xml);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.PropertyName;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n-\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n \n /**\n      */\n     public final static boolean DEFAULT_USE_WRAPPER = true;\n \n-    protected final boolean _cfgDefaultUseWrapper;\n+    // non-final from 2.7 on, to allow mapper to change\n+    protected boolean _cfgDefaultUseWrapper;\n     \n     public JacksonXmlAnnotationIntrospector() {\n         this(DEFAULT_USE_WRAPPER);\n         }\n         return null;\n     }\n-    \n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        _cfgDefaultUseWrapper = b;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Overrides for name, property detection\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      */\n     public Boolean isOutputAsCData(Annotated ann);\n \n+    /**\n+     * @since 2.7\n+     */\n+    public void setDefaultUseWrapper(boolean b);\n+    \n     /*\n     /**********************************************************************\n     /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n         public String findNamespace(Annotated ann)\n         {\n             String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.findNamespace(ann);\n             }\n             return value;\n         public Boolean isOutputAsAttribute(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsAttribute(ann);\n             }\n             return value;\n         public Boolean isOutputAsText(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsText(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsText(ann);\n             }\n             return value;\n         @Override\n         public Boolean isOutputAsCData(Annotated ann) {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsCData(ann);\n             }\n             return value;\n+        }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            if (_xmlPrimary != null) {\n+                _xmlPrimary.setDefaultUseWrapper(b);\n+            }\n+            if (_xmlSecondary != null) {\n+                _xmlSecondary.setDefaultUseWrapper(b);\n+            }\n         }\n     }\n \n             //There is no CData annotation in JAXB\n             return null;\n         }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            // not used with JAXB\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n         _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n     }\n \n-    // @since 2.1\n     @Override\n     public XmlMapper copy()\n     {\n     protected void setXMLTextElementName(String name) {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n+    /**\n+     * Since 2.7\n+     */\n+    public XmlMapper setDefaultUseWrapper(boolean state) {\n+        // ser and deser configs should usually have the same introspector, so:\n+        AnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\n+        for (AnnotationIntrospector ai : ai0.allIntrospectors()) {\n+            if (ai instanceof XmlAnnotationIntrospector) {\n+                ((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n+            }\n+        }\n+        return this;\n+    }\n \n     /*\n     /**********************************************************\n     /* Access to configuration settings\n     /**********************************************************\n      */\n-\n-    /**\n-     * @deprecated Since 2.1, use {@link #getFactory} instead\n-     */\n-    @Override\n-    @Deprecated\n-    public XmlFactory getJsonFactory() {\n-        return (XmlFactory) _jsonFactory;\n-    }\n \n     @Override\n     public XmlFactory getFactory() {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n  * implementation that\n  * builds on {@link JaxbAnnotationIntrospector}.\n  *<p>\n- * NOTE: since version 2.4, it should NOT be necessary to use this class;\n+ * NOTE: since version 2.4, it may NOT be necessary to use this class;\n  * instead, plain {@link JaxbAnnotationIntrospector} should fully work.\n  * With previous versions some aspects were not fully working and this\n  * class was necessary.\n     extends JaxbAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n-    private static final long serialVersionUID = 6477843393758275877L;\n+    private static final long serialVersionUID = 1L; // since 2.7\n \n     @Deprecated\n     public XmlJaxbAnnotationIntrospector() {\n     /**********************************************************************\n      */\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public String findNamespace(Annotated ann) {\n         return super.findNamespace(ann);\n     }\n \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsAttribute(Annotated ann) {\n         return super.isOutputAsAttribute(ann);\n     }\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n     public Boolean isOutputAsCData(Annotated ann) {\n         //There is no CData annotation in JAXB\n         return null;\n+    }\n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        // nothing to do with JAXB\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n public class XmlBeanPropertyWriter\n     extends BeanPropertyWriter\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* Config settings\n      * Element name used for items in the collection\n      */\n     protected final QName _wrappedQName;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: construction, configuration\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = JsonMappingException.from(gen0,\n+                    \"Infinite recursion (StackOverflowError)\");\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            JsonMappingException mapE = JsonMappingException.from(gen0, \"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n     \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value)\n+    public void serializeValue(JsonGenerator gen, Object value)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final Class<?> cls = value.getClass();\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         // From super-class implementation\n         final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n         } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n     \n     // @since 2.1\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         }\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n         return new QName(ns, name.getSimpleName());\n     }\n \n-    protected ToXmlGenerator _asXmlGenerator(JsonGenerator jgen)\n+    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n         throws JsonMappingException\n     {\n         // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n-        if (!(jgen instanceof ToXmlGenerator)) {\n+        if (!(gen instanceof ToXmlGenerator)) {\n             // but verify\n-            if (!(jgen instanceof TokenBuffer)) {\n-                throw new JsonMappingException(\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"\n-                            +jgen.getClass().getName());\n-                }\n-                return null;\n-        }\n-        return (ToXmlGenerator) jgen;\n+            if (!(gen instanceof TokenBuffer)) {\n+                throw JsonMappingException.from(gen,\n+                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n+            }\n+            return null;\n+        }\n+        return (ToXmlGenerator) gen;\n     }    \n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n     private void assertVersion(Versioned vers)\n     {\n         final Version v = vers.version();\n-        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUnknownVersion());\n         Version exp = PackageVersion.VERSION;\n         assertEquals(exp.toFullString(), v.toFullString());\n         assertEquals(exp, v);\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n \n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n-import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n \n     public void setUp() throws Exception\n     {\n         super.setUp();\n-        JacksonXmlModule module = new JacksonXmlModule();\n-        module.setDefaultUseWrapper(false);\n-        _xmlMapper = new XmlMapper(module);\n-        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.PascalCaseStrategy());\n+        _xmlMapper = new XmlMapper()\n+            .setDefaultUseWrapper(false);\n+        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.UpperCamelCaseStrategy());\n         _xmlMapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n     }\n     ", "timestamp": 1449430460, "metainfo": ""}