{"sha": "cc9fa1ebf89fd034597e35a7f4c75a3c44db1dfc", "log": "Merge pull request #96 from pgelinas/unwrapped-support  Unwrapped support", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n+import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Copy of {@link UnwrappingBeanSerializer} required to extend\n+ * {@link XmlBeanSerializerBase} for XML-specific handling.\n+ * \n+ * @author Pascal G\u00e9linas\n+ * \n+ */\n+public class UnwrappingXmlBeanSerializer extends XmlBeanSerializerBase {\n+    /**\n+     * Transformer used to add prefix and/or suffix for properties of unwrapped\n+     * POJO.\n+     */\n+    protected final NameTransformer _nameTransformer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating unwrapping instance of a standard\n+     * <code>BeanSerializer</code>\n+     */\n+    public UnwrappingXmlBeanSerializer(XmlBeanSerializerBase src, NameTransformer transformer)\n+    {\n+        super(src, transformer);\n+        _nameTransformer = transformer;\n+    }\n+\n+    public UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, ObjectIdWriter objectIdWriter)\n+    {\n+        super(src, objectIdWriter);\n+        _nameTransformer = src._nameTransformer;\n+    }\n+\n+    public UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, ObjectIdWriter objectIdWriter, Object filterId)\n+    {\n+        super(src, objectIdWriter, filterId);\n+        _nameTransformer = src._nameTransformer;\n+    }\n+\n+    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, String[] toIgnore)\n+    {\n+        super(src, toIgnore);\n+        _nameTransformer = src._nameTransformer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer(NameTransformer transformer)\n+    {\n+        // !!! 23-Jan-2012, tatu: Should we chain transformers?\n+        return new UnwrappingXmlBeanSerializer(this, transformer);\n+    }\n+\n+    @Override\n+    public boolean isUnwrappingSerializer()\n+    {\n+        return true; // sure is\n+    }\n+\n+    @Override\n+    public BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter)\n+    {\n+        return new UnwrappingXmlBeanSerializer(this, objectIdWriter);\n+    }\n+\n+    @Override\n+    protected BeanSerializerBase withFilterId(Object filterId)\n+    {\n+        return new UnwrappingXmlBeanSerializer(this, _objectIdWriter, filterId);\n+    }\n+\n+    @Override\n+    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n+    {\n+        return new UnwrappingXmlBeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * JSON Array output can not be done if unwrapping operation is requested;\n+     * so implementation will simply return 'this'.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer()\n+    {\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation that differs between impls\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serialization method that will delegate actual output to configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, false);\n+            return;\n+        }\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"UnwrappingXmlBeanSerializer for \" + handledType().getName();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n \n import java.io.IOException;\n \n-import javax.xml.namespace.QName;\n-\n-import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n-import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n-import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n-import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n \n /**\n- * Specific sub-class of {@link BeanSerializer} needed to take care\n- * of some xml-specific aspects, such as distinction between attributes\n- * and elements.\n+ * Variant of {@link BeanSerializer} for Xml handling.\n+ * \n+ * @author Pascal G\u00e9linas\n  */\n-public class XmlBeanSerializer extends BeanSerializer\n-{\n-    /**\n-     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n-     * instances; to mark instances that are to be written out as attributes.\n-     * Created as separate non-interned String to ensure there are no collisions.\n+public class XmlBeanSerializer extends XmlBeanSerializerBase {\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n      */\n-    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n-\n-    /**\n-     * Number of attributes to write; these will have been ordered to be the first\n-     * properties to write.\n-     */\n-    protected final int _attributeCount;\n-\n-    /**\n-     * Index of \"text value\" property we have, if any; can have at most\n-     * one such property.\n-     */\n-    protected final int _textPropertyIndex;\n-\n-    /**\n-     * Array that contains namespace URIs associated with properties, if any;\n-     * null if no namespace definitions have been assigned\n-     */\n-    protected final QName[] _xmlNames;\n-\n     public XmlBeanSerializer(BeanSerializerBase src)\n     {\n         super(src);\n-        \n-        /* Then make sure attributes are sorted before elements, keep track\n-         * of how many there are altogether\n-         */\n-        int attrCount = 0;\n-        for (BeanPropertyWriter bpw : _props) {\n-            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n-                attrCount = _orderAttributesFirst(_props, _filteredProps);\n-                break;\n-            }\n-        }\n-        _attributeCount = attrCount;\n-\n-        // And then collect namespace information\n-        _xmlNames = new QName[_props.length];\n-        int textIndex = -1;\n-        for (int i = 0, len = _props.length; i < len; ++i) {\n-            BeanPropertyWriter bpw = _props[i];\n-            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n-            String ns = null;\n-            if (info != null) {\n-                ns = info.getNamespace();\n-                if (textIndex < 0 && info.isText()) {\n-                    textIndex = i;\n-                }\n-            }\n-            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n-        }\n-        _textPropertyIndex = textIndex;\n     }\n \n-    protected XmlBeanSerializer(XmlBeanSerializer src, ObjectIdWriter objectIdWriter)\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)\n+    {\n+        super(src, objectIdWriter, filterId);\n+    }\n+\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter)\n     {\n         super(src, objectIdWriter);\n-        _attributeCount = src._attributeCount;\n-        _textPropertyIndex = src._textPropertyIndex;\n-        _xmlNames = src._xmlNames;\n+    }\n+\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, String[] toIgnore)\n+    {\n+        super(src, toIgnore);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n+\n     @Override\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n-        // 19-Feb-2012, tatu: Should support unwrapping for XML too... but not yet done\n-//        return new UnwrappingBeanSerializer(this, unwrapper);\n-        throw new UnsupportedOperationException(\"Unwrapping serialization not yet supported for XML\");\n+        return new UnwrappingXmlBeanSerializer(this, unwrapper);\n+    }\n+    \n+    @Override\n+    public BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter)\n+    {\n+        return new XmlBeanSerializer(this, objectIdWriter, _propertyFilterId);\n     }\n \n     @Override\n-    public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n-        return new XmlBeanSerializer(this, objectIdWriter);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Overridden serialization methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Main serialization method needs to be overridden to allow XML-specific\n-     * extra handling, such as indication of whether to write attributes or\n-     * elements.\n-     */\n-    @Override\n-    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected BeanSerializerBase withFilterId(Object filterId)\n     {\n-        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFields(bean, jgen0, provider);\n-            return;\n-        }\n-        \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getActiveView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-\n-        final int attrCount = _attributeCount;\n-        if (attrCount > 0) {\n-            xgen.setNextIsAttribute(true);\n-        }\n-        final int textIndex = _textPropertyIndex;\n-        final QName[] xmlNames = _xmlNames;\n-        int i = 0;\n-\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                if (i == attrCount) {\n-                    xgen.setNextIsAttribute(false);\n-                }\n-                // also: if this is property to write as text (\"unwrap\"), need to:\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(true);\n-                }\n-                xgen.setNextName(xmlNames[i]);\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    prop.serializeAsField(bean, xgen, provider);\n-                }\n-                // Reset to avoid next value being written as unwrapped, \n-                // for example when property is suppressed\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(false);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n+        return new XmlBeanSerializer(this, _objectIdWriter, filterId);\n     }\n \n     @Override\n-    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen0,\n-            SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n     {\n-        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFieldsFiltered(bean, jgen0, provider);\n-            return;\n+        return new XmlBeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * Implementation has to check whether as-array serialization\n+     * is possible reliably; if (and only if) so, will construct\n+     * a {@link BeanAsArraySerializer}, otherwise will return this\n+     * serializer as is.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer()\n+    {\n+        /* Can not:\n+         * \n+         * - have Object Id (may be allowed in future)\n+         * - have any getter\n+         * \n+         */\n+        if ((_objectIdWriter == null)\n+                && (_anyGetterWriter == null)\n+                && (_propertyFilterId == null)\n+                ) {\n+            return new BeanAsArraySerializer(this);\n         }\n-        \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n-        \n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getActiveView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n-        // better also allow missing filter actually..\n-        if (filter == null) {\n-            serializeFields(bean, jgen0, provider);\n-            return;\n-        }\n-\n-        final int attrCount = _attributeCount;\n-        if (attrCount > 0) {\n-            xgen.setNextIsAttribute(true);\n-        }\n-        final int textIndex = _textPropertyIndex;\n-        final QName[] xmlNames = _xmlNames;\n-\n-        int i = 0;\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                if (i == attrCount) {\n-                    xgen.setNextIsAttribute(false);\n-                }\n-                // also: if this is property to write as text (\"unwrap\"), need to:\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(true);\n-                }\n-                xgen.setNextName(xmlNames[i]);\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    filter.serializeAsField(bean, xgen, provider, prop);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n-    }\n-    \n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n-            return;\n-        }\n-\n-        /* Ok: let's serialize type id as attribute, but if (and only if!)\n-         * we are using AS_PROPERTY\n-         */\n-        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n-            xgen.setNextIsAttribute(true);\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n-            if (_attributeCount == 0) { // if no attributes, need to reset\n-                xgen.setNextIsAttribute(false);\n-            }\n-        } else {\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n-        }\n-    }\n-    \n-    @Override\n-    protected void _serializeObjectId(Object bean,\n-                                      JsonGenerator jgen,\n-                                      SerializerProvider provider,\n-                                      TypeSerializer typeSer,\n-                                      WritableObjectId objectId) throws IOException, JsonProcessingException,\n-            JsonGenerationException {\n-        /* Ok: let's serialize type id as attribute, but if (and only if!)\n-         * we are using AS_PROPERTY\n-         */\n-        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n-            xgen.setNextIsAttribute(true);\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n-            if (_attributeCount == 0) { // if no attributes, need to reset\n-                xgen.setNextIsAttribute(false);\n-            }\n-        } else {\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n-        }\n+        // already is one, so:\n+        return this;\n     }\n \n     /*\n     /**********************************************************\n-    /* Helper methods\n+    /* JsonSerializer implementation that differs between impls\n     /**********************************************************\n      */\n \n-    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    /**\n+     * Main serialization method that will delegate actual output to configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n     {\n-        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n-        return (info != null) && info.isAttribute();\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, true);\n+            return;\n+        }\n+        jgen.writeStartObject();\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n     }\n \n-    /**\n-     * Method for re-sorting lists of bean properties such that attributes are strictly\n-     * written before elements.\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n      */\n-    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n-            BeanPropertyWriter[] filteredProperties)\n+\n+    @Override\n+    public String toString()\n     {\n-        int attrCount = 0;\n-\n-        for (int i = 0, len = properties.length; i < len; ++i) {\n-            BeanPropertyWriter bpw = properties[i];\n-\n-            if (!_isAttribute(bpw)) {\n-                continue;\n-            }\n-\n-            // Move attribute a few places done as necessary\n-            int moveBy = i-attrCount;\n-            if (moveBy > 0) {\n-                System.arraycopy(properties, attrCount, properties, attrCount+1, moveBy);\n-                properties[attrCount] = bpw;\n-                if (filteredProperties != null) {\n-                    BeanPropertyWriter fbpw = filteredProperties[i];\n-                    System.arraycopy(filteredProperties, attrCount, filteredProperties, attrCount+1, moveBy);\n-                    filteredProperties[attrCount] = fbpw;\n-                }\n-            }\n-            ++attrCount;\n-        }\n-        return attrCount;\n+        return \"XmlBeanSerializer for \" + handledType().getName();\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n+import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n+\n+/**\n+ * Specific sub-class of {@link BeanSerializerBase} needed to take care\n+ * of some xml-specific aspects, such as distinction between attributes\n+ * and elements.\n+ */\n+public abstract class XmlBeanSerializerBase extends BeanSerializerBase\n+{\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+\n+    /**\n+     * Number of attributes to write; these will have been ordered to be the first\n+     * properties to write.\n+     */\n+    protected final int _attributeCount;\n+\n+    /**\n+     * Index of \"text value\" property we have, if any; can have at most\n+     * one such property.\n+     */\n+    protected final int _textPropertyIndex;\n+\n+    /**\n+     * Array that contains namespace URIs associated with properties, if any;\n+     * null if no namespace definitions have been assigned\n+     */\n+    protected final QName[] _xmlNames;\n+\n+    public XmlBeanSerializerBase(BeanSerializerBase src)\n+    {\n+        super(src);\n+        \n+        /* Then make sure attributes are sorted before elements, keep track\n+         * of how many there are altogether\n+         */\n+        int attrCount = 0;\n+        for (BeanPropertyWriter bpw : _props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                attrCount = _orderAttributesFirst(_props, _filteredProps);\n+                break;\n+            }\n+        }\n+        _attributeCount = attrCount;\n+\n+        // And then collect namespace information\n+        _xmlNames = new QName[_props.length];\n+        int textIndex = -1;\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _props[i];\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                ns = info.getNamespace();\n+                if (textIndex < 0 && info.isText()) {\n+                    textIndex = i;\n+                }\n+            }\n+            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+        }\n+        _textPropertyIndex = textIndex;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter)\n+    {\n+        super(src, objectIdWriter);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)\n+    {\n+        super(src, objectIdWriter, filterId);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n+    {\n+        super(src, toIgnore);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+    \n+    public XmlBeanSerializerBase(XmlBeanSerializerBase src, NameTransformer transformer)\n+    {\n+        super(src, transformer);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden serialization methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serialization method needs to be overridden to allow XML-specific\n+     * extra handling, such as indication of whether to write attributes or\n+     * elements.\n+     */\n+    @Override\n+    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n+        if (!(jgen0 instanceof ToXmlGenerator)) {\n+            super.serializeFields(bean, jgen0, provider);\n+            return;\n+        }\n+        \n+        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        final BeanPropertyWriter[] props;\n+        // !!! TODO: change to use non-deprecated version in 2.3\n+        if (_filteredProps != null && provider.getActiveView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+\n+        final int attrCount = _attributeCount;\n+        boolean isAttribute = xgen._nextIsAttribute;\n+        if (attrCount > 0) {\n+            xgen.setNextIsAttribute(true);\n+        }\n+        final int textIndex = _textPropertyIndex;\n+        final QName[] xmlNames = _xmlNames;\n+        int i = 0;\n+\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                // 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer \n+                // that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.\n+                if (i == attrCount && !(isAttribute && isUnwrappingSerializer())) {\n+                    xgen.setNextIsAttribute(false);\n+                }\n+                // also: if this is property to write as text (\"unwrap\"), need to:\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(true);\n+                }\n+                xgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, xgen, provider);\n+                }\n+                // Reset to avoid next value being written as unwrapped, \n+                // for example when property is suppressed\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(false);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    @Override\n+    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen0,\n+            SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n+        if (!(jgen0 instanceof ToXmlGenerator)) {\n+            super.serializeFieldsFiltered(bean, jgen0, provider);\n+            return;\n+        }\n+        \n+        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        \n+        final BeanPropertyWriter[] props;\n+        // !!! TODO: change to use non-deprecated version in 2.3\n+        if (_filteredProps != null && provider.getActiveView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n+        // better also allow missing filter actually..\n+        if (filter == null) {\n+            serializeFields(bean, jgen0, provider);\n+            return;\n+        }\n+\n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            xgen.setNextIsAttribute(true);\n+        }\n+        final int textIndex = _textPropertyIndex;\n+        final QName[] xmlNames = _xmlNames;\n+\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    xgen.setNextIsAttribute(false);\n+                }\n+                // also: if this is property to write as text (\"unwrap\"), need to:\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(true);\n+                }\n+                xgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    filter.serializeAsField(bean, xgen, provider, prop);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+    \n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            return;\n+        }\n+\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+        }\n+    }\n+    \n+    @Override\n+    protected void _serializeObjectId(Object bean,\n+                                      JsonGenerator jgen,\n+                                      SerializerProvider provider,\n+                                      TypeSerializer typeSer,\n+                                      WritableObjectId objectId) throws IOException, JsonProcessingException,\n+            JsonGenerationException {\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+\n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n+            BeanPropertyWriter[] filteredProperties)\n+    {\n+        int attrCount = 0;\n+\n+        for (int i = 0, len = properties.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = properties[i];\n+            \n+            if (!_isAttribute(bpw)) {\n+                continue;\n+            }\n+            \n+            // Move attribute a few places done as necessary\n+            int moveBy = i - attrCount;\n+            if (moveBy > 0) {\n+                System.arraycopy(properties, attrCount, properties, attrCount + 1, moveBy);\n+                properties[attrCount] = bpw;\n+                if (filteredProperties != null) {\n+                    BeanPropertyWriter fbpw = filteredProperties[i];\n+                    System.arraycopy(filteredProperties, attrCount, filteredProperties, attrCount+1, moveBy);\n+                    filteredProperties[attrCount] = fbpw;\n+                }\n+            }\n+            ++attrCount;\n+        }\n+        return attrCount;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             String ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\n             Boolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\n             Boolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\n-            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO,\n+            bpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\n             \t\tnew XmlInfo(isAttribute, ns, isText));\n \n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestUnwrappingWithXML.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+// for #12\n+public class TestUnwrappingWithXML extends XmlTestBase\n+{\n+    @JsonPropertyOrder({\"x\", \"y\"})\n+    final static class Location {\n+        public int x;\n+        public int y;\n+\n+        public Location() { }\n+        public Location(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    // IMPORTANT: ordering DOES matter here\n+    @JsonPropertyOrder({ \"name\", \"location\" })\n+    static class Unwrapping {\n+        public String name;\n+        @JsonUnwrapped(prefix=\"loc.\")\n+        public Location location;\n+\n+        public Unwrapping() { }\n+        public Unwrapping(String str, int x, int y) {\n+            name = str;\n+            location = new Location(x, y);\n+        }\n+    }\n+\n+    static class UnwrappingWithAttributes{\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String name;\n+        @JacksonXmlProperty(isAttribute=true)\n+        @JsonUnwrapped(prefix=\"loc.\")\n+        public Location location;\n+\n+        public UnwrappingWithAttributes() { }\n+        public UnwrappingWithAttributes(String str, int x, int y) {\n+            name = str;\n+            location = new Location(x, y);\n+        }\n+    }\n+\n+    static class UnwrappingSubWithAttributes{\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String name;\n+        @JsonUnwrapped(prefix=\"loc.\")\n+        public LocationWithAttributes location;\n+\n+        public UnwrappingSubWithAttributes() { }\n+        public UnwrappingSubWithAttributes(String str, int x, int y) {\n+            name = str;\n+            location = new LocationWithAttributes(x, y);\n+        }\n+    }\n+\n+    @JsonPropertyOrder({\"x\", \"y\"})\n+    final static class LocationWithAttributes {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public int x;\n+        public int y;\n+\n+        public LocationWithAttributes() { }\n+        public LocationWithAttributes(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+   * Simple test to verify that explicit schema mapping works fine\n+     * with unwrapped entities\n+     */\n+    public void testSimpleUnwrappingRoundtrip()\n+        throws Exception\n+    {\n+        final String XML = \"<Unwrapping><name>Joe</name><loc.x>15</loc.x><loc.y>27</loc.y></Unwrapping>\";\n+        ObjectMapper mapper = xmlMapper(false);\n+        Unwrapping wrapper = mapper.reader(Unwrapping.class).readValue(XML);\n+        assertNotNull(wrapper);\n+        assertNotNull(wrapper.location);\n+        assertEquals(15, wrapper.location.x);\n+        assertEquals(27, wrapper.location.y);\n+\n+        // should also write out the same way\n+        assertEquals(XML, mapper.writerWithType(Unwrapping.class).writeValueAsString(wrapper));\n+    }\n+\n+    public void testUnwrappingWithAttribute()\n+        throws Exception\n+    {\n+        final String XML = \"<UnwrappingWithAttributes name=\\\"Joe\\\" loc.x=\\\"15\\\" loc.y=\\\"27\\\"/>\";\n+        ObjectMapper mapper = xmlMapper(false);\n+        UnwrappingWithAttributes wrapper = mapper.reader(UnwrappingWithAttributes.class).readValue(XML);\n+        assertNotNull(wrapper);\n+        assertNotNull(wrapper.location);\n+        assertEquals(15, wrapper.location.x);\n+        assertEquals(27, wrapper.location.y);\n+\n+        // should also write out the same way\n+        assertEquals(XML, mapper.writerWithType(UnwrappingWithAttributes.class).writeValueAsString(wrapper));\n+    }\n+\n+    public void testUnwrappingSubWithAttribute()\n+        throws Exception\n+    {\n+        final String XML = \"<UnwrappingSubWithAttributes name=\\\"Joe\\\" loc.x=\\\"15\\\"><loc.y>27</loc.y></UnwrappingSubWithAttributes>\";\n+        ObjectMapper mapper = xmlMapper(false);\n+        UnwrappingSubWithAttributes wrapper = mapper.reader(UnwrappingSubWithAttributes.class).readValue(XML);\n+        assertNotNull(wrapper);\n+        assertNotNull(wrapper.location);\n+        assertEquals(15, wrapper.location.x);\n+        assertEquals(27, wrapper.location.y);\n+\n+        // should also write out the same way\n+        assertEquals(XML, mapper.writerWithType(UnwrappingSubWithAttributes.class).writeValueAsString(wrapper));\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;\n+import com.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector;\n \n /**\n  * Additional extension interface used above and beyond\n      */\n     public String findNamespace(Annotated ann);\n \n-    // Method used to check if specified property has annotation that indicates\n-    // that it should be wrapped in an element; and if so, name to use.\n-    // Note: local name of \"\" is used to indicate that name should default\n-    // to using name (local name and namespace) of property itself.\n-    //\n-    // Removed in 2.1\n-//    public QName findWrapperElement(Annotated ann);\n-\n-    // Method used to find out name to use for the outermost (root) XML element\n-    // name when serializing (since there is no property that would define it);\n-    // this overrides default name based on type of object.\n-    //\n-    // Removed in 2.1\n-//    public QName findRootElement(Annotated ann);\n-\n     /**\n      * Method used to check whether given annotated element\n      * (field, method, constructor parameter) has indicator that suggests\n      * it should be serialized as text, without element wrapper.\n      */\n     public Boolean isOutputAsText(Annotated ann);\n-    \n+\n     /*\n     /**********************************************************************\n     /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n         public Pair(AnnotationIntrospector p, AnnotationIntrospector s)\n         {\n             super(p, s);\n-            _xmlPrimary = (p instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) p : null;\n-            _xmlSecondary = (s instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) s : null;\n+            if (p instanceof XmlAnnotationIntrospector) {\n+                _xmlPrimary = (XmlAnnotationIntrospector) p;\n+            } else if (p instanceof JaxbAnnotationIntrospector) {\n+                _xmlPrimary = new JaxbWrapper((JaxbAnnotationIntrospector) p);\n+            } else {\n+                _xmlPrimary = null;\n+            }\n+\n+            if (s instanceof XmlAnnotationIntrospector) {\n+                _xmlSecondary = (XmlAnnotationIntrospector) s;\n+            } else if (s instanceof JaxbAnnotationIntrospector) {\n+                _xmlSecondary = new JaxbWrapper((JaxbAnnotationIntrospector) s);\n+            } else {\n+                _xmlSecondary = null;\n+            }\n         }\n \n         public static XmlAnnotationIntrospector.Pair instance(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n             return value;\n         }\n \n-        // These were removed in 2.1\n-        /*\n-        @Override\n-        public QName findWrapperElement(Annotated ann)\n-        {\n-            QName value = (_xmlPrimary == null) ? null : _xmlPrimary.findWrapperElement(ann);\n-            if (value == null && _xmlSecondary != null) {\n-                value = _xmlSecondary.findWrapperElement(ann);\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public QName findRootElement(Annotated ann)\n-        {\n-            QName value = (_xmlPrimary == null) ? null : _xmlPrimary.findRootElement(ann);\n-            if (value == null && _xmlSecondary != null) {\n-                value = _xmlSecondary.findRootElement(ann);\n-            }\n-            return value;\n-        }\n-        */\n-        \n         @Override\n         public Boolean isOutputAsAttribute(Annotated ann)\n         {\n             }\n             return value;\n         }\n-    \n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Helper class used to adapt JaxbAnnoationIntrospector as\n+    /* XmlAnnotationIntrospector\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Wrapper we need to adapt {@link JaxbAnnotationIntrospector} as\n+     * {@link XmlAnnotationIntrospector}: something we can not (alas!)\n+     * do in JAXB module because of dependency direction (JAXB module\n+     * has no knowledge of this module).\n+     */\n+    static class JaxbWrapper implements XmlAnnotationIntrospector\n+    {\n+        protected final JaxbAnnotationIntrospector _intr;\n+\n+        public JaxbWrapper(JaxbAnnotationIntrospector i) {\n+            _intr = i;\n+        }\n+        \n+        @Override\n+        public String findNamespace(Annotated ann) {\n+            return _intr.findNamespace(ann);\n+        }\n+\n+        @Override\n+        public Boolean isOutputAsAttribute(Annotated ann) {\n+            return _intr.isOutputAsAttribute(ann);\n+        }\n+\n+        @Override\n+        public Boolean isOutputAsText(Annotated ann) {\n+            return _intr.isOutputAsText(ann);\n+        }\n+        \n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n     {\n         final String ns = _xmlReader.getNamespaceURI();\n         final String localName = _xmlReader.getLocalName();\n+        _attributeCount = _xmlReader.getAttributeCount();\n         _nextAttributeIndex = 0;\n+\n         /* Support for virtual wrapping: in wrapping, may either\n          * create a new wrapper scope (if in sub-tree, or matches\n          * wrapper element itself), or implicitly close existing\n                 return (_currentState = XML_END_ELEMENT);\n             }\n         }\n-        _attributeCount = _xmlReader.getAttributeCount();\n         _localName = localName;\n         _namespaceURI = ns;\n         return (_currentState = XML_START_ELEMENT);\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Member;\n-\n-import javax.xml.bind.annotation.XmlAttribute;\n-import javax.xml.bind.annotation.XmlElement;\n-import javax.xml.bind.annotation.XmlRootElement;\n-import javax.xml.bind.annotation.XmlValue;\n \n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n /**\n  * Alternative {@link com.fasterxml.jackson.databind.AnnotationIntrospector}\n  * implementation that\n- * builds on introspector from Jackson XC package that uses JAXB annotations,\n- * not Jackson annotations.\n+ * builds on {@link JaxbAnnotationIntrospector}.\n+ *<p>\n+ * NOTE: since version 2.4, it should NOT be necessary to use this class;\n+ * instead, plain {@link JaxbAnnotationIntrospector} should fully work.\n+ * With previous versions some aspects were not fully working and this\n+ * class was necessary.\n  */\n public class XmlJaxbAnnotationIntrospector\n     extends JaxbAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n-\tprivate static final long serialVersionUID = 6477843393758275877L;\n+    private static final long serialVersionUID = 6477843393758275877L;\n \n-\t@Deprecated\n+    @Deprecated\n     public XmlJaxbAnnotationIntrospector() {\n         super();\n     }\n     /**********************************************************************\n      */\n     \n+    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n-    public String findNamespace(Annotated ann)\n-    {\n-        String ns = null;\n-\n-        /* 10-Oct-2009, tatus: I suspect following won't work quite\n-         *  as well as it should, wrt. defaulting to package.\n-         *  But it should work well enough to get things started --\n-         *  currently this method is not needed, and when it is,\n-         *  this can be improved.\n-         */\n-        if (ann instanceof AnnotatedClass) {\n-            /* For classes, it must be @XmlRootElement. Also, we do\n-             * want to use defaults from package, base class\n-             */\n-            XmlRootElement elem = findRootElementAnnotation((AnnotatedClass) ann);\n-            if (elem != null) {\n-                ns = elem.namespace();\n-            }\n-        } else {\n-            // For others, XmlElement or XmlAttribute work (anything else?)\n-            XmlElement elem = findAnnotation(XmlElement.class, ann, false, false, false);\n-            if (elem != null) {\n-                ns = elem.namespace();\n-            }\n-            if (ns == null || MARKER_FOR_DEFAULT.equals(ns)) {\n-                XmlAttribute attr = findAnnotation(XmlAttribute.class, ann, false, false, false);\n-                if (attr != null) {\n-                    ns = attr.namespace();\n-                }\n-            }\n-        }\n-        // JAXB uses marker for \"not defined\"\n-        if (MARKER_FOR_DEFAULT.equals(ns)) {\n-            ns = null;\n-        }\n-        return ns;\n+    public String findNamespace(Annotated ann) {\n+        return super.findNamespace(ann);\n     }\n \n-    /**\n-     * Here we assume fairly simple logic; if there is <code>XmlAttribute</code> to be found,\n-     * we consider it an attibute; if <code>XmlElement</code>, not-an-attribute; and otherwise\n-     * we will consider there to be no information.\n-     * Caller is likely to default to considering things as elements.\n-     */\n+    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n-    public Boolean isOutputAsAttribute(Annotated ann)\n-    {\n-        XmlAttribute attr = findAnnotation(XmlAttribute.class, ann, false, false, false);\n-        if (attr != null) {\n-            return Boolean.TRUE;\n-        }\n-        XmlElement elem = findAnnotation(XmlElement.class, ann, false, false, false);\n-        if (elem != null) {\n-            return Boolean.FALSE;\n-        }\n-        return null;\n+    public Boolean isOutputAsAttribute(Annotated ann) {\n+        return super.isOutputAsAttribute(ann);\n     }\n     \n+    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n-    public Boolean isOutputAsText(Annotated ann)\n-    {\n-    \tXmlValue attr = findAnnotation(XmlValue.class, ann, false, false, false);\n-        if (attr != null) {\n-            return Boolean.TRUE;\n-        }\n-        return null;\n+    public Boolean isOutputAsText(Annotated ann) {\n+        return super.isOutputAsText(ann);\n     }\n     \n     /*\n     /* Helper methods\n     /**********************************************************************\n      */\n-    \n-    private XmlRootElement findRootElementAnnotation(AnnotatedClass ac)\n-    {\n-        // Yes, check package, no class (already included), yes superclasses\n-        return findAnnotation(XmlRootElement.class, ac, true, false, true);\n-    }\n-\n+ \n     /*\n     private String handleJaxbDefault(String value)\n     {\n     }\n     */\n \n-    /* NOTE: copied verbatim from Jackson 1.9, since its visibility was\n-     * lowered (accidentally...)\n-     */\n+    @Deprecated // since 2.4; not used by this module\n     protected <A extends Annotation> A findAnnotation(Class<A> annotationClass, Annotated annotated,\n             boolean includePackage, boolean includeClass, boolean includeSuperclasses)\n     {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n         throws Exception\n     {\n         Object value = get(bean);\n-        \n-        /* Hmmh. Does the default null serialization work ok here? For now let's assume\n-         * it does; can change later if not.\n+\n+        /* 13-Feb-2014, tatu: As per [#103], default handling does not really\n+         *   work here. Rather, we need just a wrapping and should NOT call\n+         *   null handler, as it does not know what to do...\n+         *   \n+         *   Question, however, is what should it be serialized as. We have two main\n+         *   choices; equivalent empty List, and \"nothing\" (missing). Let's start with\n+         *   empty List? But producing missing entry is non-trivial...\n          */\n         if (value == null) {\n-            if (_nullSerializer != null) {\n-                jgen.writeFieldName(_name);\n-                _nullSerializer.serialize(null, jgen, prov);\n+            // if (_nullSerializer != null) { ... }\n+\n+            // For Empty List, we'd do this:\n+            /*\n+            @SuppressWarnings(\"resource\")\n+            final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n+            if (xmlGen != null) {\n+                xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\n+                xmlGen.finishWrappedValue(_wrapperQName, _wrappedQName);\n             }\n+            */\n+            // but for missing thing, well, just output nothing\n+            \n             return;\n         }\n-        \n+\n         // then find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            _handleSelfReference(bean, ser);\n+            // NOTE: method signature here change 2.3->2.4\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n         }\n \n+        @SuppressWarnings(\"resource\")\n+        final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n         // Ok then; addition we want to do is to add wrapper element, and that's what happens here\n         // 19-Aug-2013, tatu: ... except for those nasty 'convertValue()' calls...\n-        @SuppressWarnings(\"resource\")\n-        final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n         if (xmlGen != null) {\n             xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\n         }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector;\n \n public class AnnotationUtil\n {\n         for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n             if (intr instanceof XmlAnnotationIntrospector) {\n                 String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            } else  if (intr instanceof JaxbAnnotationIntrospector) {\n+                String ns = ((JaxbAnnotationIntrospector) intr).findNamespace(prop);\n                 if (ns != null) {\n                     return ns;\n                 }\n                 if (b != null) {\n                     return b;\n                 }\n-            }\n+            } else  if (intr instanceof JaxbAnnotationIntrospector) {\n+                Boolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+           }\n         }\n         return null;\n     }\n                 if (b != null) {\n                     return b;\n                 }\n+            } else  if (intr instanceof JaxbAnnotationIntrospector) {\n+                Boolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n             }\n         }\n         return null;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n         return this;\n     }\n \n-    public QName findRootName(JavaType rootType, MapperConfig<?> config)\n-    {\n+    public QName findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n public abstract class XmlTestBase\n     extends TestCase\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     /**\n      * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n      */\n-    protected static class FiveMinuteUser {\n+    public static class FiveMinuteUser {\n         public enum Gender { MALE, FEMALE };\n \n         public static class Name\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestBinaryData.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestBinaryData extends XmlTestBase\n+{\n+    public static class Data {\n+        public byte[] bytes;\n+    }\n+\n+    public static class TwoData {\n+        public Data data1;\n+        public Data data2;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+//    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // for [https://github.com/FasterXML/jackson-dataformat-xml/issues/29]\n+    public void testTwoBinaryProps() throws Exception\n+    {\n+        /* Hmmh. Looks like XmlMapper has some issues with convertValue:\n+         * should investigate at some point. But not now...\n+         */\n+        final ObjectMapper jsonMapper = new ObjectMapper();\n+        String BIN1 = jsonMapper.convertValue(\"Hello\".getBytes(\"UTF-8\"), String.class);\n+        String BIN2 = jsonMapper.convertValue(\"world!!\".getBytes(\"UTF-8\"), String.class);\n+        String xml = \n+            \"<TwoData>\" +\n+                    \"<data1><bytes>\" + BIN1 + \"</bytes></data1>\" +\n+                    \"<data2><bytes>\" + BIN2 + \"</bytes></data2>\" +\n+            \"</TwoData>\";\n+\n+        TwoData two = new XmlMapper().readValue(xml, TwoData.class);\n+        assertEquals(\"Hello\", new String(two.data1.bytes, \"UTF-8\"));\n+        assertEquals(\"world!!\", new String(two.data2.bytes, \"UTF-8\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestDeserialization.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;\n+\n+public class TestDeserialization extends XmlTestBase\n+{\n+    static class AttributeBean\n+    {\n+        @JacksonXmlProperty(isAttribute=true, localName=\"attr\")\n+        public String text = \"?\";\n+    }\n+\n+    static class Optional {\n+        @JacksonXmlText\n+        public String number = \"NOT SET\";\n+        public String type = \"NOT SET\";\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    /**\n+     * Unit test to ensure that we can successfully also round trip\n+     * example Bean used in Jackson tutorial\n+     */\n+    public void testRoundTripWithJacksonExample() throws Exception\n+    {\n+        FiveMinuteUser user = new FiveMinuteUser(\"Joe\", \"Sixpack\",\n+                true, FiveMinuteUser.Gender.MALE, new byte[] { 1, 2, 3 , 4, 5 });\n+        String xml = MAPPER.writeValueAsString(user);\n+        FiveMinuteUser result = MAPPER.readValue(xml, FiveMinuteUser.class);\n+        assertEquals(user, result);\n+    }\n+\n+    public void testFromAttribute() throws Exception\n+    {\n+        AttributeBean bean = MAPPER.readValue(\"<AttributeBean attr=\\\"abc\\\"></AttributeBean>\", AttributeBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"abc\", bean.text);\n+    }\n+    \n+    // [Issue#14]\n+    public void testMapWithAttr() throws Exception\n+    {\n+        final String xml = \"<order><person lang='en'>John Smith</person></order>\";\n+        Map<?,?> map = MAPPER.readValue(xml, Map.class);\n+    \t\n+    \t// Will result in equivalent of:\n+    \t// { \"person\" : {\n+    \t//     \"lang\" : \"en\",\n+    \t//     \"\" : \"John Smith\"\n+    \t//   }\n+    \t// }\n+    \t//\n+    \t// which may or may not be what we want. Without attribute\n+    \t// we would just have '{ \"person\" : \"John Smith\" }'\n+    \t\n+    \t    assertNotNull(map);\n+    }\n+\n+    // // Tests for [Issue#64]\n+\n+    public void testOptionalAttr() throws Exception\n+    {\n+        Optional ob = MAPPER.readValue(\"<Optional type='work'>123-456-7890</Optional>\",\n+                Optional.class);\n+        assertNotNull(ob);\n+        assertEquals(\"123-456-7890\", ob.number);\n+        assertEquals(\"work\", ob.type);\n+    }\n+\n+    public void testMissingOptionalAttr() throws Exception\n+    {\n+        Optional ob = MAPPER.readValue(\"<Optional>123-456-7890</Optional>\",\n+                Optional.class);\n+        assertNotNull(ob);\n+        assertEquals(\"123-456-7890\", ob.number);\n+        assertEquals(\"NOT SET\", ob.type);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestEnums.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestEnums extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static enum TestEnum { A, B, C; }\n+\n+    static class EnumBean\n+    {\n+        public TestEnum value;\n+\n+        public EnumBean() { }\n+        public EnumBean(TestEnum v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testEnum() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        String str = mapper.writeValueAsString(new EnumBean(TestEnum.B));\n+        EnumBean result = mapper.readValue(str, EnumBean.class);\n+        assertNotNull(result);\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestStringValues.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestStringValues extends XmlTestBase\n+{\n+    protected static class Bean2\n+    {\n+        public String a, b;\n+\n+        @Override\n+        public String toString() {\n+            return \"[a=\"+a+\",b=\"+b+\"]\";\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testSimpleStringElement() throws Exception\n+    {\n+        // first, simple one to verify baseline\n+        StringBean bean = MAPPER.readValue(\"<StringBean><text>text!</text></StringBean>\", StringBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"text!\", bean.text);\n+    }\n+    \n+    public void testEmptyStringElement() throws Exception\n+    {\n+        // then with empty element\n+        StringBean bean = MAPPER.readValue(\"<StringBean><text></text></StringBean>\", StringBean.class);\n+        assertNotNull(bean);\n+        // empty String or null?\n+        // 22-Sep-2012, tatu: Seems to be 'null', but should probably be fixed to \"\"\n+//        assertEquals(\"\", bean.text);\n+        assertNull(bean.text);\n+    }\n+    \n+    public void testMissingString() throws Exception\n+    {\n+        StringBean baseline = new StringBean();\n+        // then missing\n+        StringBean bean = MAPPER.readValue(\"<StringBean />\", StringBean.class);\n+        assertNotNull(bean);\n+        assertEquals(baseline.text, bean.text);\n+    }\n+\n+    public void testStringWithAttribute() throws Exception\n+    {\n+        // and then the money shot: with 'standard' attribute...\n+        StringBean bean = MAPPER.readValue(\"<StringBean><text xml:lang='fi'>Pulla</text></StringBean>\", StringBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"Pulla\", bean.text);\n+    }\n+\n+    public void testStringsWithAttribute() throws Exception\n+    {\n+        Bean2 bean = MAPPER.readValue(\n+                \"<Bean2>\\n\"\n+                +\"<a xml:lang='fi'>abc</a>\"\n+                +\"<b xml:lang='en'>def</b>\"\n+//                +\"<a>abc</a><b>def</b>\"\n+                +\"</Bean2>\\n\",\n+                Bean2.class);\n+        assertNotNull(bean);\n+        assertEquals(\"abc\", bean.a);\n+        assertEquals(\"def\", bean.b);\n+    }\n+    \n+    public void testStringArrayWithAttribute() throws Exception\n+    {\n+        // should even work for arrays of those\n+        StringBean[] beans = MAPPER.readValue(\n+                \"<StringBean>\\n\"\n+                +\"<StringBean><text xml:lang='fi'>Pulla</text></StringBean>\"\n+                +\"<StringBean><text xml:lang='se'>Bulla</text></StringBean>\"\n+                +\"<StringBean><text xml:lang='en'>Good stuff</text></StringBean>\"\n+                +\"</StringBean>\",\n+                StringBean[].class);\n+        assertNotNull(beans);\n+        assertEquals(3, beans.length);\n+        assertEquals(\"Pulla\", beans[0].text);\n+        assertEquals(\"Bulla\", beans[1].text);\n+        assertEquals(\"Good stuff\", beans[2].text);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestViews.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+/*\n+ * Tests for ('JSON') Views, other filtering.\n+ */\n+public class TestViews extends XmlTestBase\n+{\n+    static class RestrictedView { };\n+\n+    static class Foo\n+    {\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public String restrictedFooProperty;\n+\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public Bar[] bars;\n+    }\n+\n+    static class Bar\n+    {\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public int restrictedBarProperty;\n+    }\n+\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n+    static class NonNullBean\n+    {\n+        public String nullName = null;\n+        public String name = \"Bob\";\n+    }\n+\n+    @JsonFilter(\"filter44\")\n+    public class Issue44Bean {\n+        @JacksonXmlProperty(isAttribute=true)\n+        protected String first = \"abc\";\n+\n+        public int second = 13;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testIssue7() throws Exception\n+    {\n+        Foo foo = new Foo();\n+        foo.restrictedFooProperty = \"test\";\n+\n+        Bar bar1 = new Bar();\n+        bar1.restrictedBarProperty = 10;\n+\n+        Bar bar2 = new Bar();\n+        bar2.restrictedBarProperty = 11;\n+\n+        foo.bars = new Bar[] { bar1, bar2 };\n+\n+        ObjectMapper xmlMapper = new XmlMapper();\n+\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_FIELDS, false );\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false );\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false );\n+        xmlMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n+\n+        String xml = xmlMapper.writerWithView(RestrictedView.class).writeValueAsString(foo);\n+        \n+        // views not used for deserialization\n+        Foo result = xmlMapper.readValue(xml, Foo.class);\n+        assertEquals(\"test\", result.restrictedFooProperty);\n+        assertNotNull(result.bars);\n+        assertEquals(2, result.bars.length);\n+        assertEquals(10, result.bars[0].restrictedBarProperty);\n+        assertEquals(11, result.bars[1].restrictedBarProperty);\n+        \n+    }\n+\n+    public void testNullSuppression() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new NonNullBean());\n+        assertEquals(\"<NonNullBean><name>Bob</name></NonNullBean>\", xml);\n+    }\n+\n+    public void testIssue44() throws IOException\n+    {\n+        String exp = \"<Issue44Bean first=\\\"abc\\\"><second>13</second></Issue44Bean>\";\n+        Issue44Bean bean = new Issue44Bean();\n+\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filter44\",\n+                SimpleBeanPropertyFilter.serializeAllExcept(\"filterMe\"));\n+        ObjectWriter writer = _xmlMapper.writer(prov);\n+\n+        // as well as with proper filter\n+        assertEquals(exp, writer.writeValueAsString(bean));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/AttributeFailIssue108Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class AttributeFailIssue108Test extends XmlTestBase\n+{\n+    static class Foo {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Bar> firstBar = new ArrayList<Bar>();\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Bar> secondBar = new ArrayList<Bar>();\n+    }\n+\n+    static class Bar {\n+        public String value;\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public int id;\n+    }\n+\n+    public void testIdsFromAttributes() throws Exception {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        Foo foo = new Foo();\n+        Bar bar1 = new Bar();\n+        bar1.id = 1;\n+        bar1.value = \"FIRST\";\n+        foo.firstBar.add(bar1);\n+        Bar bar2 = new Bar();\n+        bar2.value = \"SECOND\";\n+        bar2.id = 2;\n+        foo.secondBar.add(bar2);\n+        String string = xmlMapper.writeValueAsString(foo);\n+        Foo fooRead = xmlMapper.readValue(string, Foo.class);\n+        assertEquals(foo.secondBar.get(0).id, fooRead.secondBar.get(0).id);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/Issue37AdapterTest.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.*;\n+import java.util.*;\n+\n+import javax.xml.bind.annotation.*;\n+import javax.xml.bind.annotation.adapters.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n+\n+public class Issue37AdapterTest extends XmlTestBase\n+{\n+    @XmlJavaTypeAdapter(URLEncoderMapDataAdapter.class)\n+    public static class MapData\n+    {\n+        public String key;\n+        public String value;\n+\n+        public MapData() { }\n+\n+        public MapData(String key, String value) {\n+            super();\n+            this.key = key;\n+            this.value = value;\n+        }\n+    }\n+\n+    public static class URLEncoderMapDataAdapter extends XmlAdapter<MapData[], Map<String, String>>\n+    {\n+        public URLEncoderMapDataAdapter() { }\n+\n+        @Override\n+        public MapData[] marshal(Map<String, String> arg0) throws Exception {\n+            MapData[] mapElements = new MapData[arg0.size()];\n+            int i = 0;\n+            for (Map.Entry<String, String> entry : arg0.entrySet()) {\n+                mapElements[i++] = new MapData(encodeKey(entry.getKey()), entry.getValue());\n+            }\n+\n+            return mapElements;\n+        }\n+\n+        @Override\n+        public Map<String, String> unmarshal(MapData[] arg0) throws Exception {\n+            Map<String, String> r = new HashMap<String, String>();\n+            for (MapData mapelement : arg0) {\n+                r.put(decodeKey(mapelement.key), mapelement.value);\n+            }\n+            return r;\n+        }\n+\n+        private final static String ENCODING = \"UTF-8\";\n+\n+        private String encodeKey(String key) throws UnsupportedEncodingException {\n+            return URLEncoder.encode(key, ENCODING);\n+        }\n+\n+        private String decodeKey(String key) throws UnsupportedEncodingException {\n+            return URLDecoder.decode(key, ENCODING);\n+        }\n+    }\n+\n+    @XmlRootElement(name = \"DocWithMapData\")\n+    public static class DocWithMapData\n+    {\n+        @XmlJavaTypeAdapter(value = URLEncoderMapDataAdapter.class) // type = MapData[].class)\n+        public Map<String, String> mapDatas;\n+    }\n+\n+    @XmlRootElement(name = \"DocWithMapDataSimpleAnnotation\")\n+    public static class DocWithMapDataSimpleAnnotation\n+    {\n+        @XmlJavaTypeAdapter(URLEncoderMapDataAdapter.class)\n+        public Map<String, String> mapDatas;\n+    }\n+\n+    private Map<String, String> simpleMapData = singletonMap(\"key\", \"value\");\n+\n+    private Map<String, String> needEncodingMapData = singletonMap(\"my/key\", \"my/value\");\n+\n+    private Map<String,String> singletonMap(String a, String b) {\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(a,b);\n+        return map;\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /***********************************************************************\n+     */\n+\n+    protected XmlMapper _jaxbMapper;\n+\n+    protected XmlMapper _nonJaxbMapper;\n+\n+    @Override\n+    public void setUp() throws Exception\n+    {\n+        super.setUp();\n+        _jaxbMapper = new XmlMapper();\n+        _nonJaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr =\n+            XmlAnnotationIntrospector.Pair.instance(new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()),\n+                new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testSimpleKeyMap() throws Exception\n+    {\n+        DocWithMapData bean = new DocWithMapData();\n+        bean.mapDatas = simpleMapData;\n+\n+        assertEquals(\"<DocWithMapData><mapDatas><key>value</key></mapDatas></DocWithMapData>\",\n+            _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    public void testNeedEncodingKeyMap() throws Exception\n+    {\n+        DocWithMapData bean = new DocWithMapData();\n+        bean.mapDatas = needEncodingMapData;\n+\n+        String xml = _jaxbMapper.writeValueAsString(bean);\n+        \n+        assertEquals(\"<DocWithMapData><mapDatas><my%2Fkey>my/value</my%2Fkey></mapDatas></DocWithMapData>\",\n+                xml);\n+    }\n+\n+    public void testSimpleKeyMapSimpleAnnotation() throws Exception\n+    {\n+        DocWithMapDataSimpleAnnotation bean = new DocWithMapDataSimpleAnnotation();\n+        bean.mapDatas = simpleMapData;\n+\n+        assertEquals(\n+            \"<DocWithMapDataSimpleAnnotation><mapDatas><key>value</key></mapDatas></DocWithMapDataSimpleAnnotation>\",\n+            _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    public void testNeedEncodingKeyMapSimpleAnnotation() throws Exception\n+    {\n+        DocWithMapDataSimpleAnnotation bean = new DocWithMapDataSimpleAnnotation();\n+        bean.mapDatas = needEncodingMapData;\n+\n+        assertEquals(\n+            \"<DocWithMapDataSimpleAnnotation><mapDatas><my%2Fkey>my/value</my%2Fkey></mapDatas></DocWithMapDataSimpleAnnotation>\",\n+            _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    public void testNeedEncodingKeyMap_nonJaxb() throws Exception\n+    {\n+        DocWithMapData bean = new DocWithMapData();\n+        bean.mapDatas = needEncodingMapData;\n+\n+        assertEquals(\n+            \"<DocWithMapData><mapDatas><my%2Fkey>my/value</my%2Fkey></mapDatas></DocWithMapData>\",\n+            _nonJaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    public void testNeedEncodingKeyMapSimpleAnnotation_nonJaxb() throws Exception\n+    {\n+        DocWithMapDataSimpleAnnotation bean = new DocWithMapDataSimpleAnnotation();\n+        bean.mapDatas = needEncodingMapData;\n+\n+        assertEquals(\n+            \"<DocWithMapDataSimpleAnnotation><mapDatas><my%2Fkey>my/value</my%2Fkey></mapDatas></DocWithMapDataSimpleAnnotation>\",\n+            _nonJaxbMapper.writeValueAsString(bean));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/Issue97Test.java\n+/*\n+ * Copyright (c) 2002-2014 Nu Echo Inc. All rights reserved.\n+ */\n+\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.junit.runner.*;\n+import org.junit.runners.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.*;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+/**\n+ * @author Nu Echo Inc.\n+ */\n+@RunWith(JUnit4.class)\n+public class Issue97Test extends XmlTestBase\n+{\n+    @JsonTypeInfo(property = \"type\", use = Id.NAME)\n+    public static abstract class Foo {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String data;\n+    }\n+\n+    @JsonTypeName(\"good\")\n+    public static class FooGood extends Foo {\n+        public String bar;\n+    }\n+\n+    @JsonTypeName(\"bad\")\n+    public static class FooBad extends Foo {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<String> bar;\n+    }\n+\n+    @Test\n+    public void testGood() throws Exception {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.registerSubtypes(FooGood.class);\n+\n+        String xml = \"<Foo type=\\\"good\\\" data=\\\"dummy\\\"><bar>FOOBAR</bar></Foo>\";\n+        Foo fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooGood.class));\n+\n+        xml = \"<Foo data=\\\"dummy\\\" type=\\\"good\\\" ><bar>FOOBAR</bar></Foo>\";\n+        fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooGood.class));\n+    }\n+    \n+    @Test\n+    public void testBad() throws Exception {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.registerSubtypes(FooBad.class);\n+\n+        String xml = \"<Foo type=\\\"bad\\\" data=\\\"dummy\\\"><bar><bar>FOOBAR</bar></bar></Foo>\";\n+        Foo fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooBad.class));\n+\n+        xml = \"<Foo data=\\\"dummy\\\" type=\\\"bad\\\"><bar><bar>FOOBAR</bar></bar></Foo>\";\n+        fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooBad.class));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/AttributesWithJAXBTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.io.IOException;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector;\n+\n+public class AttributesWithJAXBTest extends XmlTestBase\n+{\n+    @XmlAccessorType(value = XmlAccessType.FIELD)\n+    public class Jurisdiction {\n+        @XmlAttribute(name=\"name\",required=true)\n+        protected String name = \"Foo\";\n+\n+        @XmlAttribute(name=\"value\",required=true)\n+        protected int value = 13;\n+    }\n+\n+    @XmlRootElement(name=\"problem\")\n+    public static class Problem {\n+        @XmlAttribute(name=\"id\")     \n+        public String id;\n+        public String description;\n+\n+        public Problem() { }\n+        public Problem(String id, String description) {\n+            this.id = id;\n+            this.description = description;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testTwoAttributes() throws IOException\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+//        mapper.setAnnotationIntrospector(new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+        mapper.setAnnotationIntrospector(new JaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+        String xml = mapper.writeValueAsString(new Jurisdiction());\n+        assertEquals(\"<Jurisdiction name=\\\"Foo\\\" value=\\\"13\\\"/>\", xml);\n+    }\n+\n+    public void testAttributeAndElement() throws IOException\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.setAnnotationIntrospector(new JaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+        String xml = mapper.writeValueAsString(new Problem(\"x\", \"Stuff\"));\n+        assertEquals(\"<problem id=\\\"x\\\"><description>Stuff</description></problem>\", xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/ElementWrapperTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class ElementWrapperTest extends XmlTestBase\n+{\n+    @XmlRootElement(name = \"Individual\")\n+    static class MyPerson {\n+          public String name;\n+\n+          @XmlElementWrapper(name = \"offspring\")\n+          @XmlElement(name = \"kid\")\n+          public List<MyPerson> children = new ArrayList<MyPerson>();\n+    }\n+\n+    @XmlRootElement(name=\"p\")\n+    static class MyPerson2 {\n+        public String name;\n+\n+        public List<MyPerson2> child = new ArrayList<MyPerson2>();\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testElementWrapper() throws Exception\n+    {\n+        XmlMapper _jaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+            (new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()),\n+                    new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+\n+        MyPerson person = new MyPerson();\n+        person.name = \"Jay\";\n+\n+        MyPerson child = new MyPerson();\n+        child.name = \"Junior\";\n+        \n+        person.children.add(child);\n+\n+        String xml = _jaxbMapper.writer().writeValueAsString(person);\n+        \n+        String expected = \"<Individual><name>Jay</name>\"\n+                + \"<offspring><kid><name>Junior</name><offspring/></kid></offspring></Individual>\";\n+        assertEquals(expected, xml);\n+    }\n+\n+    // And with JAXB, default should be \"no wrapper\"\n+    public void testNoElementWrapper() throws Exception\n+    {\n+        XmlMapper jaxbMapper = new XmlMapper();\n+        jaxbMapper.setAnnotationIntrospector(new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+\n+        MyPerson2 person = new MyPerson2();\n+        person.name = \"Jay\";\n+\n+        MyPerson2 child = new MyPerson2();\n+        child.name = \"Junior\";\n+        \n+        person.child.add(child);\n+\n+        String xml = jaxbMapper.writeValueAsString(person);\n+        \n+        String expected = \"<p><name>Jay</name><child><name>Junior</name></child></p>\";\n+        assertEquals(expected, xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/WithJAXBAnnotationsTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.io.IOException;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n+\n+/**\n+ * Although XML-backed data binding does not rely (or directly build) on JAXB\n+ * annotations, it should be possible to use them similar to how they are used\n+ * with default Jackson JSON data binding. Let's verify this is the case.\n+ */\n+public class WithJAXBAnnotationsTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper types\n+    /**********************************************************************\n+     */\n+\n+    @XmlRootElement(name=\"bean\")\n+    public static class RootBean\n+    {\n+        public String value = \"text\";\n+    }\n+    \n+    public static class AttrBean\n+    {        \n+        @XmlAttribute\n+        public String attr = \"3\";\n+    }\n+\n+    @javax.xml.bind.annotation.XmlRootElement(name=\"Simple\")\n+    static class WithXmlValue\n+    {\n+        @javax.xml.bind.annotation.XmlAttribute\n+        public int a = 13;\n+\n+        @javax.xml.bind.annotation.XmlValue\n+        public String text = \"something\";\n+    }\n+\n+    @XmlRootElement(name = \"Individual\")\n+    static class MyPerson {\n+        @XmlAttribute(name = \"identifier\")\n+        public Long id;\n+\n+        @XmlElement(name = \"givenName\")\n+        public String firstName;\n+    \n+        @XmlElement(name = \"surName\")\n+        public String lastName;\n+\n+        public Long getId() {\n+            return id;\n+        }\n+        public void setId(final Long id) {\n+            this.id = id;\n+        }\n+\n+        public String getFirstName() {\n+            return firstName;\n+        }\n+        public void setFirstName(final String firstName) {\n+            this.firstName = firstName;\n+        }\n+\n+        public String getLastName() {\n+            return lastName;\n+        }\n+        public void setLastName(final String lastName) {\n+            this.lastName = lastName;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /**********************************************************************\n+     */\n+\n+    protected XmlMapper _jaxbMapper;\n+    protected XmlMapper _nonJaxbMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jaxbMapper = new XmlMapper();\n+        _nonJaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+            (new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()), new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Unit test for verifying that root element name can be overridden\n+     * with {@link XmlRootElement} annotation.\n+     */\n+    public void testRootName() throws Exception\n+    {\n+        RootBean bean = new RootBean();\n+        // without JAXB annotations will use class simple name:\n+        assertEquals(\"<RootBean><value>text</value></RootBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<bean><value>text</value></bean>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    /**\n+     * Unit test for verifying that a property defaults to being written as\n+     * element, but can be redefined with {@link XmlAttribute} annotation.\n+     */\n+    public void testSerializeAsAttr() throws Exception\n+    {\n+        AttrBean bean = new AttrBean();\n+        assertEquals(\"<AttrBean><attr>3</attr></AttrBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<AttrBean attr=\\\"3\\\"/>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    /**\n+     * Unit test for verifying correct handling of\n+     * {@link XmlValue} annotation.\n+     */\n+    public void testAsTextWithJAXB() throws IOException\n+    {\n+    \t// first: serialize\n+    \tString xml = _jaxbMapper.writeValueAsString(new WithXmlValue());\n+    \tassertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+\n+    \t// and then deserialize back...\n+    \tWithXmlValue result = _jaxbMapper.readValue(\"<Simple a='99'>else</Simple>\",\n+    \t\t\tWithXmlValue.class);\n+    \tassertEquals(99, result.a);\n+    \tassertEquals(\"else\", result.text);\n+    }\n+\n+    public void testPersonAsXml() throws Exception {\n+        MyPerson person = new MyPerson();\n+        person.id = Long.valueOf(1L);\n+        person.firstName = \"Jay\";\n+        person.lastName = \"Unit\";\n+    \n+        String json = _jaxbMapper.writeValueAsString(person);\n+// System.out.println(\"Person: \" + json);\n+    \n+        String expected = \"<Individual identifier=\\\"1\\\"><givenName>Jay</givenName>\"\n+                +\"<surName>Unit</surName></Individual>\";\n+        assertEquals(expected, json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/Issue101UnwrappedListAttributesTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+// Failing unit test(s) wrt [Issue#64]\n+public class Issue101UnwrappedListAttributesTest extends XmlTestBase\n+{\n+    static class Optional {\n+        @JacksonXmlText\n+        public String number = \"NOT SET\";\n+\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String type = \"NOT SET\";\n+\n+        public Optional() { }\n+        \n+        // uncommenting this ALSO works:\n+//        public Optional(String n) { number = n; }\n+    }\n+\n+    static class Optionals {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Optional> optional;\n+    } \n+\n+    // For [Issue#101]\n+    @JacksonXmlRootElement(localName = \"root\")    \n+    @JsonPropertyOrder({ \"unwrapped\", \"name\" })\n+    static class Root {\n+        @JacksonXmlProperty(localName = \"unwrapped\")\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<UnwrappedElement> unwrapped;\n+\n+        public String name;\n+    }\n+\n+     static class UnwrappedElement {\n+        public UnwrappedElement () {}\n+\n+        public UnwrappedElement (String id, String type) {\n+            this.id = id;\n+            this.type = type;\n+        }\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String id;\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String type;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+\n+    // // [Issue#64]\n+    public void testOptionalsWithMissingType() throws Exception\n+    {\n+//        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional type='work'>123-456-7890</optional></MultiOptional>\",\n+        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional>123-456-7890</optional></MultiOptional>\",\n+                Optionals.class);\n+        assertNotNull(ob);\n+        assertNotNull(ob.optional);\n+        assertEquals(1, ob.optional.size());\n+\n+//            System.err.println(\"ob: \" + ob); // works fine\n+\n+        Optional opt = ob.optional.get(0);\n+        assertEquals(\"123-456-7890\", opt.number);\n+        assertEquals(\"NOT SET\", opt.type);\n+    }\n+\n+    // [Issue#101]\n+    public void testWithTwoAttributes() throws Exception\n+    {\n+        final String EXP = \"<root>\"\n+                +\"<unwrapped id=\\\"1\\\" type=\\\"string\\\"/>\"\n+                +\"<unwrapped id=\\\"2\\\" type=\\\"string\\\"/>\"\n+                +\"<name>test</name>\"\n+                +\"</root>\";\n+        Root rootOb = new Root();\n+        rootOb.unwrapped = Arrays.asList(\n+                new UnwrappedElement(\"1\", \"string\"),\n+                new UnwrappedElement(\"2\", \"string\")\n+        );\n+        rootOb.name = \"test\";\n+\n+        // First, serialize, which works\n+        String xml = MAPPER.writeValueAsString(rootOb);\n+        assertEquals(EXP, xml);\n+\n+        // then try deserialize\n+        Root result = MAPPER.readValue(xml, Root.class);\n+        assertNotNull(result);\n+        assertEquals(rootOb.name, result.name);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/Issue43Test.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class Issue43Test extends XmlTestBase\n+{\n+    static class Name {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String language;\n+\n+        @JacksonXmlText\n+        public String text;\n+\n+//        public String data;\n+\n+        public Name() { }\n+    }\n+\n+    static class RoomName {\n+        @JacksonXmlElementWrapper(localName = \"names\", useWrapping=true)\n+        @JsonProperty(\"name\")\n+        public List<Name> names;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testIssue43() throws Exception\n+    {\n+        String xmlData = \"<roomName><names>\"\n+                +\"<name language=\\\"en\\\">SPECIAL</name>\"\n+                +\"</names></roomName>\";\n+\n+        XmlMapper xmlMapper = new XmlMapper();\n+        RoomName roomName = xmlMapper.readValue(xmlData, RoomName.class);\n+        assertEquals(1, roomName.names.size());\n+        assertEquals(\"SPECIAL\", roomName.names.get(0).text);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAnnotationSharingTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+\n+// for [Issue#55]\n+public class ListAnnotationSharingTest extends XmlTestBase\n+{\n+    static class Wrapper {\n+        @JacksonXmlElementWrapper(localName = \"Points\", useWrapping = true)\n+        @JsonProperty(\"Point\")\n+        private List<Point> points = new ArrayList<Point>();\n+\n+        public List<Point> getPoints() {\n+            return points;\n+        }\n+    }\n+\n+    static class Point {\n+        public int x, y;\n+\n+        public Point() { }\n+        public Point(int x, int y) { this.x = x;\n+            this.y = y;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+     public void testAnnotationSharing() throws Exception\n+     {\n+         Wrapper input = new Wrapper();\n+         input.points.add(new Point(1, 2));\n+         String xml = MAPPER.writeValueAsString(input);\n+\n+         assertEquals(\"<Wrapper><Points><Point><x>1</x><y>2</y></Point></Points></Wrapper>\", xml);\n+\n+         // and then back\n+         Wrapper result = MAPPER.readValue(xml, Wrapper.class);\n+         assertEquals(1, result.points.size());\n+     }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListDeserializationTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class ListDeserializationTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JacksonXmlRootElement(localName = \"person\", namespace =\"http://example.org/person\" )\n+    public static class Person\n+    {\n+        @JacksonXmlProperty( isAttribute = true )\n+        public String id;\n+        public String name;\n+        public int age;\n+\n+        @JacksonXmlElementWrapper(localName = \"notes\")\n+        @JacksonXmlProperty(localName = \"note\" )\n+        public List<String> notes = new ArrayList<String>();\n+\n+        public Person() { }\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+    }\n+\n+    public static class PersonWithGetters\n+    {\n+       @JacksonXmlProperty( isAttribute = true )\n+       public String id;\n+\n+       protected List<String> _notes = new ArrayList<String>();\n+              \n+       public PersonWithGetters() { }\n+       public PersonWithGetters(String id) {\n+           this.id = id;\n+       }\n+\n+       @JacksonXmlElementWrapper(localName = \"notes\")\n+       @JacksonXmlProperty( localName = \"note\" )\n+       public List<String> getStuff() {\n+           return _notes;\n+       }\n+\n+       public void setStuff(List<String> n) {\n+           _notes = n;\n+       }\n+    }\n+\n+    static class ListBeanWrapped\n+    {\n+        @JacksonXmlElementWrapper\n+        public List<Integer> values;\n+    }\n+\n+    static class ListBeanUnwrapped\n+    {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Integer> values;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    {\n+        // easier for eye:\n+        MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n+    }\n+\n+    /* Issue#17 [https://github.com/FasterXML/jackson-dataformat-xml/issues/17]\n+     * \n+     * Problems deserializing otherwise properly wrapped lists\n+     */\n+    public void testWrappedList() throws Exception\n+    {\n+        Person p = new Person( \"Name\", 30 );\n+        p.notes.add(\"note 1\");\n+        p.notes.add(\"note 2\");\n+        String xml = MAPPER.writeValueAsString( p );\n+        Person result = MAPPER.readValue(xml, Person.class);\n+        assertNotNull(result);\n+        assertEquals(\"Name\", result.name);\n+        assertEquals(30, result.age);\n+        assertEquals(2, result.notes.size());\n+        assertEquals(\"note 1\", result.notes.get(0));\n+        assertEquals(\"note 2\", result.notes.get(1));\n+    }\n+\n+    public void testWrappedListWithGetters() throws Exception\n+    {\n+        PersonWithGetters p = new PersonWithGetters(\"abc\");\n+        p._notes.add(\"note 1\");\n+        p._notes.add(\"note 2\");\n+        String xml = MAPPER.writeValueAsString( p );\n+        PersonWithGetters result = MAPPER.readValue(xml, PersonWithGetters.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.id);\n+        assertEquals(2, result._notes.size());\n+        assertEquals(\"note 1\", result._notes.get(0));\n+        assertEquals(\"note 2\", result._notes.get(1));\n+    }\n+\n+    public void testWrappedListBeanDeser() throws Exception\n+    {\n+        ListBeanWrapped bean = MAPPER.readValue(\n+                \"<ListBeanWrapped><values><values>1</values><values>2</values><values>3</values></values></ListBeanWrapped>\",\n+                ListBeanWrapped.class);\n+        assertNotNull(bean);\n+        assertNotNull(bean.values);\n+        assertEquals(3, bean.values.size());\n+        assertEquals(Integer.valueOf(1), bean.values.get(0));\n+        assertEquals(Integer.valueOf(2), bean.values.get(1));\n+        assertEquals(Integer.valueOf(3), bean.values.get(2));\n+    }\n+\n+    // for [Issue#33]\n+    public void testWrappedListWithAttribute() throws Exception\n+    {\n+        ListBeanWrapped bean = MAPPER.readValue(\n+                \"<ListBeanWrapped><values id='123'><values>1</values><values>2</values></values></ListBeanWrapped>\",\n+                ListBeanWrapped.class);\n+        assertNotNull(bean);\n+        assertNotNull(bean.values);\n+        if (bean.values.size() < 2) { // preliminary check\n+            fail(\"List should have 2 entries, had \"+bean.values.size());\n+        }\n+        assertEquals(Integer.valueOf(1), bean.values.get(0));\n+        assertEquals(Integer.valueOf(2), bean.values.get(1));\n+        assertEquals(2, bean.values.size());\n+    }\n+\n+    public void testUnwrappedListBeanDeser() throws Exception\n+    {\n+        /*\n+        ListBeanUnwrapped foo = new ListBeanUnwrapped();\n+        foo.values = new ArrayList<Integer>();\n+        foo.values.add(1);\n+        foo.values.add(2);\n+        foo.values.add(3);\n+System.out.println(\"List -> \"+MAPPER.writeValueAsString(foo));\n+*/\n+        \n+        ListBeanUnwrapped bean = MAPPER.readValue(\n+                \"<ListBeanUnwrapped><values>1</values><values>2</values><values>3</values></ListBeanUnwrapped>\",\n+                ListBeanUnwrapped.class);\n+        assertNotNull(bean);\n+        assertNotNull(bean.values);\n+        assertEquals(3, bean.values.size());\n+        assertEquals(Integer.valueOf(1), bean.values.get(0));\n+        assertEquals(Integer.valueOf(2), bean.values.get(1));\n+        assertEquals(Integer.valueOf(3), bean.values.get(2));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListRoundtripTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class ListRoundtripTest extends XmlTestBase\n+{\n+    @JacksonXmlRootElement(localName=\"parents\")\n+    public static class Parents {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Parent> parent = new ArrayList<Parent>();\n+    }\n+\n+    @JsonPropertyOrder({ \"name\", \"desc\", \"prop\" })\n+    public static class Parent {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String name;\n+\n+        public String description;\n+      \n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Prop> prop = new ArrayList<Prop>();\n+\n+        public Parent() { }\n+        public Parent(String name, String desc) {\n+            this.name = name;\n+            description = desc;\n+        }\n+    }\n+\n+    static class Prop {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String name;\n+\n+        public String value;\n+\n+        public Prop() { }\n+        public Prop(String name, String value) {\n+            this.name = name;\n+            this.value = value;\n+        }\n+    }\n+\n+    // For [Issue#58]\n+    @JacksonXmlRootElement(localName = \"point\")\n+    static class Point {\n+        @JacksonXmlProperty(localName = \"x\", isAttribute = true)\n+        int x;\n+        @JacksonXmlProperty(localName = \"y\", isAttribute = true)\n+        int y;\n+\n+        public Point() { }\n+        public Point(int x, int y) { this.x = x; this.y = y; }\n+    }\n+\n+    @JacksonXmlRootElement(localName = \"Points\")\n+    static class PointContainer {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        @JacksonXmlProperty(localName = \"point\")\n+        public List<Point> points;\n+    }\n+\n+    // For [Issue#64]\n+    static class Optional {\n+        @JacksonXmlText\n+        public String number = \"NOT SET\";\n+\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String type = \"NOT SET\";\n+    }\n+\n+    static class Optionals {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Optional> optional;\n+    } \n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    { // easier for eye, uncomment for testing\n+//        MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n+    }\n+    \n+    public void testParentListRoundtrip() throws Exception\n+    {\n+        Parents root = new Parents();\n+        Parent parent1 = new Parent(\"a\", \"First\");\n+        root.parent.add(parent1);\n+        parent1.prop.add(new Prop(\"width\", \"13\"));\n+        parent1.prop.add(new Prop(\"height\", \"10\"));\n+        Parent parent2 = new Parent(\"b\", \"Second\");\n+        parent2.prop.add(new Prop(\"x\", \"1\"));\n+        parent2.prop.add(new Prop(\"y\", \"2\"));\n+        root.parent.add(parent2);\n+\n+        String xml = MAPPER.writeValueAsString(root);\n+        assertNotNull(xml);\n+\n+        // then bring it back\n+        Parents result = MAPPER.readValue(xml, Parents.class);\n+        assertNotNull(result.parent);\n+        assertEquals(2, result.parent.size());\n+        Parent p2 = result.parent.get(1);\n+        assertNotNull(p2);\n+        assertEquals(\"b\", p2.name);\n+        assertEquals(\"Second\", p2.description);\n+\n+        assertEquals(2, p2.prop.size());\n+        Prop prop2 = p2.prop.get(1);\n+        assertNotNull(prop2);\n+        assertEquals(\"2\", prop2.value);\n+    }\n+\n+    public void testListWithAttrOnlyValues() throws Exception\n+    {\n+        PointContainer obj = new PointContainer();\n+        obj.points = new ArrayList<Point>();\n+        obj.points.add(new Point(1, 2));\n+        obj.points.add(new Point(3, 4));\n+        obj.points.add(new Point(5, 6));\n+\n+        String xml = MAPPER.writeValueAsString(obj);\n+\n+        PointContainer converted = MAPPER.readValue(xml, PointContainer.class);\n+\n+        assertEquals(3, converted.points.size());\n+        assertNotNull(converted.points.get(0));\n+        assertNotNull(converted.points.get(1));\n+        assertNotNull(converted.points.get(2));\n+\n+        assertEquals(2, converted.points.get(0).y);\n+        assertEquals(4, converted.points.get(1).y);\n+        assertEquals(6, converted.points.get(2).y);\n+    }\n+\n+    // // [Issue#64]\n+    \n+    public void testOptionals() throws Exception\n+    {\n+        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional type='work'>123-456-7890</optional></MultiOptional>\",\n+                Optionals.class);\n+        assertNotNull(ob);\n+        assertNotNull(ob.optional);\n+        assertEquals(1, ob.optional.size());\n+//        System.err.println(\"ob: \" + ob); // works fine\n+        Optional opt = ob.optional.get(0);\n+        assertEquals(\"123-456-7890\", opt.number);\n+        assertEquals(\"work\", opt.type);\n+    }\n+\n+    /*// comment out for release\n+    public void testOptionalsWithMissingType() throws Exception\n+    {\n+//        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional type='work'>123-456-7890</optional></MultiOptional>\",\n+        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional>123-456-7890</optional></MultiOptional>\",\n+                Optionals.class);\n+        assertNotNull(ob);\n+        assertNotNull(ob.optional);\n+        assertEquals(1, ob.optional.size());\n+\n+//            System.err.println(\"ob: \" + ob); // works fine\n+\n+        Optional opt = ob.optional.get(0);\n+        assertEquals(\"123-456-7890\", opt.number);\n+        assertEquals(\"NOT SET\", opt.type);\n+    }\n+*/    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListSerializationTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+\n+public class ListSerializationTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+    static class ListBean\n+    {\n+        public final List<Integer> values = new ArrayList<Integer>();\n+\n+        public ListBean() { }\n+        public ListBean(int... ints) {\n+            for (int i : ints) {\n+                values.add(Integer.valueOf(i));\n+            }\n+        }\n+    }\n+\n+    static class StringListBean\n+    {\n+        // to see what JAXB gives, uncomment:\n+        //@javax.xml.bind.annotation.XmlElementWrapper(name=\"stringList\")\n+        @JacksonXmlElementWrapper(localName=\"stringList\")\n+        public List<StringBean> strings;\n+        \n+        public StringListBean() { strings = new ArrayList<StringBean>(); }\n+        public StringListBean(String... texts)\n+        {\n+            strings = new ArrayList<StringBean>();\n+            for (String text : texts) {\n+                strings.add(new StringBean(text));\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+ \n+    public void testSimpleWrappedList() throws IOException\n+    {\n+        String xml = MAPPER.writeValueAsString(new ListBean(1, 2, 3));\n+        xml = removeSjsxpNamespace(xml);\n+        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper...\n+        assertEquals(\"<ListBean><values><values>1</values><values>2</values><values>3</values></values></ListBean>\", xml);\n+    }\n+\n+    public void testStringList() throws IOException\n+    {\n+        StringListBean list = new StringListBean(\"a\", \"b\", \"c\");\n+        String xml = MAPPER.writeValueAsString(list);\n+        xml = removeSjsxpNamespace(xml);\n+        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper... but it's what we have now\n+        assertEquals(\"<StringListBean><stringList>\"\n+                +\"<strings><text>a</text></strings>\"\n+                +\"<strings><text>b</text></strings>\"\n+                +\"<strings><text>c</text></strings>\"\n+                +\"</stringList></StringListBean>\", xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class NestedUnwrappedListsTest  extends XmlTestBase\n+{\n+    // // // Test\n+\n+    static class ServiceDelivery {\n+        public String responseTimestamp;\n+        public List<VehicleMonitoringDelivery> vehicleMonitoringDelivery;    \n+    }\n+\n+    static class VehicleMonitoringDelivery {\n+        public String responseTimestamp;\n+        public String validUntil;\n+        public List<VehicleActivity> vehicleActivity;\n+    }\n+\n+    static class VehicleActivity {\n+        public String recordedAtTime;    \n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /**********************************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception\n+    {\n+        super.setUp();\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(false);\n+        _xmlMapper = new XmlMapper(module);\n+        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.PascalCaseStrategy());\n+        _xmlMapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testNested1_2() throws Exception\n+    {\n+        final String XML =\n+\"<ServiceDelivery>\\n\"\n++\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"    <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"    <ValidUntil>2012-09-12T09:29:17.213-04:00</ValidUntil>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2012-09-12T09:28:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2013-09-12T09:29:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"</ServiceDelivery>\\n\"\n+                ;\n+        \n+        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n+        assertNotNull(svc);\n+        assertNotNull(svc.vehicleMonitoringDelivery);\n+        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n+        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n+        assertEquals(\"2012-09-12T09:28:17.213-04:00\", del.responseTimestamp);\n+        assertNotNull(del);\n+        assertNotNull(del.vehicleActivity);\n+        assertEquals(2, del.vehicleActivity.size());\n+        VehicleActivity act = del.vehicleActivity.get(1);\n+        assertNotNull(act);\n+        assertEquals(\"2013-09-12T09:29:07.536-04:00\", act.recordedAtTime);\n+    }\n+\n+    public void testNestedWithEmpty() throws Exception\n+    {\n+        final String XML =\n+\"<ServiceDelivery>\\n\"\n++\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"</ServiceDelivery>\\n\"\n+                ;\n+        \n+        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n+        assertNotNull(svc);\n+        assertNotNull(svc.vehicleMonitoringDelivery);\n+        assertEquals(0, svc.vehicleMonitoringDelivery.size());\n+    }\n+\n+    public void testNestedWithEmpty2() throws Exception\n+    {\n+        final String XML =\n+\"<ServiceDelivery>\\n\"\n++\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"</ServiceDelivery>\\n\"\n+                ;\n+        \n+        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n+        assertNotNull(svc);\n+        assertNotNull(svc.vehicleMonitoringDelivery);\n+        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n+        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n+        assertNotNull(del.vehicleActivity);\n+        assertEquals(0, del.vehicleActivity.size());\n+    }\n+    \n+    public void testNested1_2b() throws Exception\n+    {\n+        final String XML =\n+\"<ServiceDelivery>\\n\"\n++\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2012-09-12T09:28:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2013-09-12T09:29:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"    <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"    <ValidUntil>2012-09-12T09:29:17.213-04:00</ValidUntil>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"</ServiceDelivery>\\n\"\n+                ;\n+        \n+        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n+        assertNotNull(svc);\n+        assertEquals(\"2012-09-12T09:28:17.213-04:00\", svc.responseTimestamp);\n+        assertNotNull(svc.vehicleMonitoringDelivery);\n+        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n+        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n+        assertEquals(\"2012-09-12T09:29:17.213-04:00\", del.validUntil);\n+        assertNotNull(del);\n+        assertNotNull(del.vehicleActivity);\n+        assertEquals(2, del.vehicleActivity.size());\n+        VehicleActivity act = del.vehicleActivity.get(1);\n+        assertNotNull(act);\n+        assertEquals(\"2013-09-12T09:29:07.536-04:00\", act.recordedAtTime);\n+    }\n+    \n+    public void testNested2_1() throws Exception\n+    {\n+        final String XML =\n+\"<ServiceDelivery>\\n\"\n++\"  <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"    <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"    <ValidUntil>2012-09-12T09:29:17.213-04:00</ValidUntil>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2012-09-12T09:28:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"  <VehicleMonitoringDelivery>\\n\"\n++\"    <ResponseTimestamp>2012-09-12T09:28:17.213-04:00</ResponseTimestamp>\\n\"\n++\"    <ValidUntil>2012-09-12T09:29:17.213-04:00</ValidUntil>\\n\"\n++\"    <VehicleActivity>\\n\"\n++\"      <RecordedAtTime>2012-09-12T09:28:07.536-04:00</RecordedAtTime>\\n\"\n++\"    </VehicleActivity>\\n\"\n++\"  </VehicleMonitoringDelivery>\\n\"\n++\"</ServiceDelivery>\\n\"\n+                ;\n+        \n+        ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n+        assertNotNull(svc);\n+        assertEquals(\"2012-09-12T09:28:17.213-04:00\", svc.responseTimestamp);\n+        assertNotNull(svc.vehicleMonitoringDelivery);\n+        assertEquals(2, svc.vehicleMonitoringDelivery.size());\n+        VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(1);\n+        assertNotNull(del);\n+        assertNotNull(del.vehicleActivity);\n+        assertEquals(1, del.vehicleActivity.size());\n+        assertEquals(\"2012-09-12T09:28:07.536-04:00\", del.vehicleActivity.get(0).recordedAtTime);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/RootListHandlingTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+/**\n+ * Tests for verifying that Lists (and arrays) can be serialized even\n+ * when they are root values.\n+ */\n+public class RootListHandlingTest extends XmlTestBase\n+{\n+    @JacksonXmlRootElement(localName=\"SR\")\n+    @JsonPropertyOrder({ \"id\", \"name\", \"description\" })\n+    public static class SampleResource {\n+        private Long id;\n+        private String name;\n+        private String description;\n+\n+        public SampleResource() { }\n+        public SampleResource(long id, String n, String d) {\n+            this.id = id;\n+            name = n;\n+            description = d;\n+        }\n+        \n+        public Long getId() {\n+            return id;\n+        }\n+\n+        public void setId(Long id) {\n+            this.id = id;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        public void setDescription(String description) {\n+            this.description = description;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Test for ensuring that we can use \".withRootName()\" to override\n+    // default name AND annotation\n+    public void testRenamedRootItem() throws Exception\n+    {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        String xml = xmlMapper\n+                .writer()\n+                .withRootName(\"Shazam\")\n+                .writeValueAsString(new SampleResource(123, \"Foo\", \"Barfy!\"))\n+                .trim();\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<Shazam><id>123</id><name>Foo</name><description>Barfy!</description></Shazam>\", xml);\n+    }\n+    \n+    // for [Issue#38] -- root-level Collections not supported\n+    public void testListSerialization() throws Exception\n+    {\n+        _testListSerialization(true);\n+        _testListSerialization(false);\n+    }\n+        \n+    private void _testListSerialization(boolean useWrapping) throws Exception\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(useWrapping);\n+        XmlMapper xmlMapper = new XmlMapper(module);\n+        AnnotationIntrospector introspector = new JacksonAnnotationIntrospector();\n+        xmlMapper.setAnnotationIntrospector(introspector);\n+\n+        SampleResource r1 = new SampleResource();\n+        r1.setId(123L);\n+        r1.setName(\"Albert\");\n+        r1.setDescription(\"desc\");\n+\n+        SampleResource r2 = new SampleResource();\n+        r2.setId(123L);\n+        r2.setName(\"William\");\n+        r2.setDescription(\"desc2\");\n+\n+        List<SampleResource> l = new ArrayList<SampleResource>();\n+        l.add(r1);\n+        l.add(r2);\n+\n+        // to see what JAXB might do, uncomment:\n+//System.out.println(\"By JAXB: \"+jaxbSerialized(l)); //  ArrayList.class, SampleResource.class));\n+\n+        String xml = xmlMapper\n+            .writerWithDefaultPrettyPrinter()\n+            .writeValueAsString(l)\n+            .trim();\n+\n+        // first trivial sanity checks\n+        assertNotNull(xml);\n+        if (xml.indexOf(\"<ArrayList>\") < 0) {\n+            fail(\"Unexpected output: should have <ArrayList> as root element, got: \"+xml);\n+        }\n+\n+        // and then try reading back\n+        JavaType resListType = xmlMapper.getTypeFactory()\n+                .constructCollectionType(List.class, SampleResource.class);\n+        Object ob = xmlMapper.reader(resListType).readValue(xml);\n+        assertNotNull(ob);\n+\n+//      System.err.println(\"XML -> \"+xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(ob));\n+        \n+        assertTrue(ob instanceof List);\n+        List<?> resultList = (List<?>) ob;\n+        assertEquals(2, resultList.size());\n+        assertEquals(SampleResource.class, resultList.get(0).getClass());\n+        assertEquals(SampleResource.class, resultList.get(1).getClass());\n+        SampleResource rr = (SampleResource) resultList.get(1);\n+        assertEquals(\"William\", rr.getName());\n+    }\n+\n+    // Related to #38 as well\n+    public void testArraySerialization() throws Exception\n+    {\n+        _testArraySerialization(true);\n+        _testArraySerialization(false);\n+    }\n+    \n+    private void _testArraySerialization(boolean useWrapping) throws Exception\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(useWrapping);\n+        XmlMapper xmlMapper = new XmlMapper(module);\n+        AnnotationIntrospector introspector = new JacksonAnnotationIntrospector();\n+        xmlMapper.setAnnotationIntrospector(introspector);\n+\n+        SampleResource r1 = new SampleResource();\n+        r1.setId(123L);\n+        r1.setName(\"Albert\");\n+        r1.setDescription(\"desc\");\n+\n+        SampleResource r2 = new SampleResource();\n+        r2.setId(123L);\n+        r2.setName(\"William\");\n+        r2.setDescription(\"desc2\");\n+\n+        SampleResource[] input = new SampleResource[] { r1, r2 };\n+\n+        // to see what JAXB might do, uncomment:\n+//System.out.println(\"By JAXB: \"+jaxbSerialized(input));\n+\n+        String xml = xmlMapper\n+            .writerWithDefaultPrettyPrinter()\n+            .writeValueAsString(input)\n+            .trim();\n+\n+        // first trivial sanity checks\n+        assertNotNull(xml);\n+        // Is this good name? If not, what should be used instead?\n+        if (xml.indexOf(\"<SampleResources>\") < 0) {\n+            fail(\"Unexpected output: should have <SampleResources> as root element, got: \"+xml);\n+        }\n+\n+        // and then try reading back\n+        SampleResource[] result = xmlMapper.reader(SampleResource[].class).readValue(xml);\n+        assertNotNull(result);\n+\n+//      System.err.println(\"XML -> \"+xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(ob));\n+        \n+        assertEquals(2, result.length);\n+        SampleResource rr = result[1];\n+        assertEquals(\"desc2\", rr.getDescription());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/UnwrappedListsTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class UnwrappedListsTest extends XmlTestBase\n+{\n+    static class Value {\n+        public String v;\n+\n+        public Value() { }\n+        public Value(String str) { v = str; }\n+    }\n+\n+    @XmlRootElement(name=\"list\")\n+    @JsonRootName(\"list\")\n+    static class WrappedList {\n+        @XmlElementWrapper(name=\"WRAP\")\n+        @JacksonXmlElementWrapper(localName = \"WRAP\")\n+        public Value[] value;\n+    }\n+\n+    @XmlRootElement(name=\"list\")\n+    @JsonRootName(\"list\")\n+    static class UnwrappedList {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public Value[] value;\n+    }\n+\n+    static class DefaultList {\n+        public Value[] value;\n+    }\n+\n+    // [Issue#64]\n+    static class Optionals {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Optional> optional;\n+    } \n+\n+    static class Optional {\n+        @JacksonXmlText\n+        public String number = \"NOT SET\";\n+\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String type = \"NOT SET\";\n+\n+        public Optional() { }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testWrappedLists() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        WrappedList list = new WrappedList();\n+        list.value = new Value[] { new Value(\"a\"), new Value(\"b\") };\n+\n+        // First, serialize:\n+        \n+        String json = mapper.writeValueAsString(list);\n+//      withJAXB(list);\n+        assertEquals(\"<list><WRAP><value><v>a</v></value><value><v>b</v></value></WRAP></list>\", json);\n+\n+        // then deserialize back\n+        WrappedList output = mapper.readValue(json, WrappedList.class);\n+        assertNotNull(output);\n+        assertNotNull(output.value);\n+        assertEquals(2, output.value.length);\n+    }\n+    \n+    public void testUnwrappedLists() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+\n+        UnwrappedList list = new UnwrappedList();\n+        list.value = new Value[] { new Value(\"c\"), new Value(\"d\") };\n+        String json = mapper.writeValueAsString(list);\n+        \n+//        System.out.println(\"Unwrapped == \"+json);\n+//        withJAXB(list);\n+        assertEquals(\"<list><value><v>c</v></value><value><v>d</v></value></list>\", json);\n+\n+        // then deserialize back\n+        UnwrappedList output = mapper.readValue(json, UnwrappedList.class);\n+        assertNotNull(output);\n+        assertNotNull(output.value);\n+        assertEquals(2, output.value.length);\n+    \n+    }\n+\n+    /**\n+     * Test to verify that default wrapping setting is used\n+     */\n+    public void testDefaultWrapping() throws Exception\n+    {\n+        // by default, should be using wrapping, so:\n+        XmlMapper mapper = new XmlMapper();\n+        DefaultList input = new DefaultList();\n+        input.value = new Value[] { new Value(\"a\"), new Value(\"b\") };\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"<DefaultList><value><value><v>a</v></value><value><v>b</v></value></value></DefaultList>\", json);\n+        DefaultList output = mapper.readValue(json, DefaultList.class);\n+        assertNotNull(output.value);\n+        assertEquals(2, output.value.length);\n+\n+        // but can be changed not to use wrapping by default\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(false);\n+        mapper = new XmlMapper(module);\n+        json = mapper.writeValueAsString(input);\n+        assertEquals(\"<DefaultList><value><v>a</v></value><value><v>b</v></value></DefaultList>\", json);\n+        output = mapper.readValue(json, DefaultList.class);\n+        assertNotNull(output.value);\n+        assertEquals(2, output.value.length);\n+    }\n+\n+    public void testDefaultWrappingWithEmptyLists() throws Exception\n+    {\n+        // by default, should be using wrapping, so:\n+        XmlMapper mapper = new XmlMapper();\n+        String json = \"<DefaultList><value><value></value></value></DefaultList>\";\n+        DefaultList output = mapper.readValue(json, DefaultList.class);\n+        assertNotNull(output.value);\n+        assertEquals(1, output.value.length);\n+\n+        // but without, should work as well\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(false);\n+        mapper = new XmlMapper(module);\n+        json = \"<DefaultList><value></value></DefaultList>\";\n+        output = mapper.readValue(json, DefaultList.class);\n+        assertNotNull(output.value);\n+        assertEquals(1, output.value.length);\n+    }\n+\n+    // // [Issue#64]\n+    public void testOptionalsWithMissingType() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+//        Optionals ob = MAPPER.readValue(\"<MultiOptional><optional type='work'>123-456-7890</optional></MultiOptional>\",\n+        Optionals ob = mapper.readValue(\"<MultiOptional><optional>123-456-7890</optional></MultiOptional>\",\n+                Optionals.class);\n+        assertNotNull(ob);\n+        assertNotNull(ob.optional);\n+        assertEquals(1, ob.optional.size());\n+\n+//            System.err.println(\"ob: \" + ob); // works fine\n+\n+        Optional opt = ob.optional.get(0);\n+        assertEquals(\"123-456-7890\", opt.number);\n+        assertEquals(\"NOT SET\", opt.type);\n+    }\n+\n+    /*\n+    void withJAXB(Object ob) throws Exception\n+    {\n+        JAXBContext jc = JAXBContext.newInstance(ob.getClass());\n+        Marshaller m = jc.createMarshaller();\n+        System.out.print(\"JAXB      -> \");\n+        StringWriter sw = new StringWriter();\n+        m.marshal(ob, sw);\n+        String xml = sw.toString();\n+        if (xml.indexOf(\"<?xml\") == 0) {\n+            xml = xml.substring(xml.indexOf(\"?>\")+2);\n+        }\n+        System.out.println(xml);\n+   }\n+   */\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/WrappedListsTest.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class WrappedListsTest extends XmlTestBase\n+{\n+    static class Order  {\n+        @JacksonXmlElementWrapper(localName = \"line_items\")\n+        @JacksonXmlProperty(localName = \"item\")  \n+        private List<ListItem> line_items; // new ArrayList<ListItem>();\n+    }\n+\n+    static class ListItem {\n+        public int id;\n+        \n+        public ListItem(int id) { this.id = id; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = xmlMapper(true);\n+\n+    // For [Issue#103]\n+    public void testEmptyList() throws Exception\n+    {\n+        String xml = MAPPER.writeValueAsString(new Order());\n+        assertEquals(\"<Order/>\", xml);\n+        // If we expected Empty list, it'd be:\n+//        assertEquals(\"<Order><line_items/></Order>\", xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/ArrayConversionsTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.*;\n+import java.lang.reflect.Array;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/* NOTE: copied from jackson-databind (with some pruning)\n+ */\n+\n+/**\n+ * Conversion tests to ensure that standard ObjectMapper conversions\n+ * work despite XmlMapper having to add XML-specific work-arounds.\n+ */\n+public class ArrayConversionsTest extends XmlTestBase\n+{\n+    static class IntListWrapper {\n+        public List<Integer> values;\n+    }\n+\n+    static class IntArrayWrapper {\n+        public int[] values;\n+\n+        public IntArrayWrapper() { }\n+        public IntArrayWrapper(int[] v) { values = v; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Test methods\n+    /********************************************************\n+     */\n+\n+    public void testNullXform() throws Exception {\n+        _testNullXform(xmlMapper(true));\n+        _testNullXform(xmlMapper(false));\n+    }\n+    \n+    private void _testNullXform(ObjectMapper mapper) throws Exception\n+    {\n+        // when given null, null should be returned without conversion (Java null has no type)\n+        assertNull(mapper.convertValue(null, Integer.class));\n+        assertNull(mapper.convertValue(null, String.class));\n+        assertNull(mapper.convertValue(null, byte[].class));\n+    }\n+\n+    /**\n+     * Tests to verify that primitive number arrays round-trip\n+     * correctly, i.e. type -> type gives equal (although\n+     * not necessarily same) output\n+     */\n+    public void testArrayIdentityTransforms() throws Exception {\n+        _testArrayIdentityTransforms(xmlMapper(true));\n+        _testArrayIdentityTransforms(xmlMapper(false));\n+    }\n+\n+    private void _testArrayIdentityTransforms(ObjectMapper mapper) throws Exception\n+    {\n+        // first integral types\n+        // (note: byte[] is ok, even if it goes to base64 and back)\n+        verifyByteArrayConversion(mapper, bytes(), byte[].class);\n+        verifyShortArrayConversion(mapper, shorts(), short[].class);\n+        verifyIntArrayConversion(mapper, ints(), int[].class);\n+        verifyLongArrayConversion(mapper, longs(), long[].class);\n+        // then primitive decimal types\n+        verifyFloatArrayConversion(mapper, floats(), float[].class);\n+        verifyDoubleArrayConversion(mapper, doubles(), float[].class);\n+    }\n+\n+    public void testByteArrayFrom() throws Exception {\n+        _testByteArrayFrom(xmlMapper(true));\n+        _testByteArrayFrom(xmlMapper(false));\n+    }\n+\n+    private void _testByteArrayFrom(ObjectMapper mapper) throws Exception\n+    {\n+        /* Note: byte arrays are tricky, since they are considered\n+         * binary data primarily, not as array of numbers. Hence\n+         * output will be base64 encoded...\n+         */\n+        byte[] data = _convert(mapper, \"c3VyZS4=\", byte[].class);\n+        byte[] exp = \"sure.\".getBytes(\"Ascii\");\n+        verifyIntegralArrays(exp, data, exp.length);\n+    }\n+    \n+    public void testShortArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        short[] data = shorts();\n+        verifyShortArrayConversion(mapper, data, byte[].class);\n+        verifyShortArrayConversion(mapper, data, int[].class);\n+        verifyShortArrayConversion(mapper, data, long[].class);\n+    }\n+\n+    public void testIntArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+\n+        int[] data = ints();\n+        verifyIntArrayConversion(mapper, data, byte[].class);\n+        verifyIntArrayConversion(mapper, data, short[].class);\n+        verifyIntArrayConversion(mapper, data, long[].class);\n+\n+        List<Number> expNums = _numberList(data, data.length);\n+        // Alas, due to type erasure, need to use TypeRef, not just class\n+        List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() {});\n+        assertEquals(expNums, actNums);\n+    }\n+\n+    public void testLongArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        long[] data = longs();\n+        verifyLongArrayConversion(mapper, data, byte[].class);\n+        verifyLongArrayConversion(mapper, data, short[].class);\n+        verifyLongArrayConversion(mapper, data, int[].class);\n+ \n+        List<Number> expNums = _numberList(data, data.length);\n+        List<Long> actNums = mapper.convertValue(data, new TypeReference<List<Long>>() {});\n+        assertEquals(expNums, actNums);        \n+    }\n+\n+    public void testListToIntArray() throws Exception\n+    {\n+        _testListToIntArray(true);\n+        _testListToIntArray(false);\n+    }\n+\n+    private void _testListToIntArray(boolean wrap) throws Exception\n+    {\n+        final XmlMapper mapper = xmlMapper(wrap);\n+        List<Integer> in = new ArrayList<Integer>();\n+        in.add(1);\n+        in.add(2);\n+        in.add(3);\n+        int[] out = mapper.convertValue(in, int[].class);\n+        assertEquals(3, out.length);\n+        for (int i = 0; i < out.length; ++i) {\n+            assertEquals(i+1, out[i]);\n+        }\n+    }\n+    \n+    public void testListAsProperty() throws Exception\n+    {\n+        _testListAsProperty(true);\n+        _testListAsProperty(false);\n+    }\n+\n+    private void _testListAsProperty(boolean wrap) throws Exception\n+    {\n+        final XmlMapper mapper = xmlMapper(wrap);\n+        IntListWrapper mid = mapper.convertValue(new IntArrayWrapper(new int[] { 1, 2, 3}),\n+                IntListWrapper.class);\n+        assertNotNull(mid);\n+        assertNotNull(mid.values);\n+        assertEquals(3, mid.values.size());\n+\n+        IntArrayWrapper output = mapper.convertValue(mid, IntArrayWrapper.class);\n+        assertEquals(3, output.values.length);\n+        assertEquals(3, output.values[2]);\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Helper methods\n+    /********************************************************\n+     */\n+\n+    // note: all value need to be within byte range\n+    \n+    private byte[] bytes() { return new byte[] { 1, -1, 0, 98, 127 }; }\n+    private short[] shorts() { return new short[] { 1, -1, 0, 98, 127 }; }\n+    private int[] ints() { return new int[] { 1, -1, 0, 98, 127 }; }\n+    private long[] longs() { return new long[] { 1, -1, 0, 98, 127 }; }\n+\n+    // note: use values that are exact in binary\n+\n+    private double[] doubles() { return new double[] { 0.0, 0.25, -0.125, 10.5, 9875.0 }; }\n+    private float[] floats() { return new float[] {\n+            0.0f, 0.25f, -0.125f, 10.5f, 9875.0f };\n+    }\n+\n+    private <T> void verifyByteArrayConversion(ObjectMapper mapper, byte[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyShortArrayConversion(ObjectMapper mapper, short[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyIntArrayConversion(ObjectMapper mapper, int[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyLongArrayConversion(ObjectMapper mapper, long[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyFloatArrayConversion(ObjectMapper mapper, float[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    private <T> void verifyDoubleArrayConversion(ObjectMapper mapper, double[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    \n+    private <T> T _convert(ObjectMapper mapper, Object input, Class<T> outputType)\n+    {\n+        // must be a primitive array, like \"int[].class\"\n+        if (!outputType.isArray()) throw new IllegalArgumentException();\n+        if (!outputType.getComponentType().isPrimitive()) throw new IllegalArgumentException();\n+        T result = mapper.convertValue(input, outputType);\n+        // sanity check first:\n+        assertNotNull(result);\n+        assertEquals(outputType, result.getClass());\n+        return result;\n+    }\n+\n+    private List<Number> _numberList(Object numberArray, int size)\n+    {\n+        ArrayList<Number> result = new ArrayList<Number>(size);\n+        for (int i = 0; i < size; ++i) {\n+            result.add((Number) Array.get(numberArray, i));\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Helper method for checking that given collections contain integral Numbers\n+     * that essentially contain same values in same order\n+     */\n+    private void verifyIntegralArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).longValue();\n+            double value2 = ((Number) n2).longValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+    private void verifyDoubleArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).doubleValue();\n+            double value2 = ((Number) n2).doubleValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/ObjectId104Test.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/**\n+ * Unit test to showcase issue #104, based on TestObjectIdDeserialization unit test in databind package.\n+ */\n+public class ObjectId104Test extends XmlTestBase {\n+    // // Classes for external id from property annotations:\n+    \n+    static class IdWrapper\n+    {\n+        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n+        public ValueNode node;\n+\n+        public IdWrapper() { }\n+        public IdWrapper(int v) {\n+            node = new ValueNode(v);\n+        }\n+    }\n+\n+    static class ValueNode {\n+        public List<Integer> value= new ArrayList<Integer>();\n+        public IdWrapper next;\n+        \n+        public ValueNode() { this(0); }\n+        public ValueNode(int v) { value.add(v); }\n+    }\n+    \n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // Another test to ensure ordering is not required (i.e. can do front references)\n+    public void testSimpleCollectionDeserWithForwardRefs() throws Exception\n+    {\n+        IdWrapper result = MAPPER.readValue(\"<IdWrapper><node><value><value>7</value></value><next><node>1</node></next><id>1</id></node></IdWrapper>\"\n+                ,IdWrapper.class);\n+        assertEquals(7, (int)result.node.value.get(0));\n+        assertSame(result.node, result.node.next.node);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class PolymorphicTypesTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class BaseTypeWithClassProperty { }\n+\n+    static class SubTypeWithClassProperty extends BaseTypeWithClassProperty {\n+        public String name;\n+\n+        public SubTypeWithClassProperty() { }\n+        public SubTypeWithClassProperty(String s) { name = s; }\n+    }\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    protected static class BaseTypeWithClassObject { }\n+\n+    protected static class SubTypeWithClassObject extends BaseTypeWithClassObject {\n+        public String name;\n+    \n+        public SubTypeWithClassObject() { }\n+        public SubTypeWithClassObject(String s) { name = s; }\n+    }\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    protected static class TypeWithClassPropertyAndObjectId {\n+        public String id;\n+\n+        public TypeWithClassPropertyAndObjectId() {}\n+        public TypeWithClassPropertyAndObjectId(String id) { this.id = id; }\n+    }\n+\n+    protected static class Wrapper {\n+        public List<TypeWithClassPropertyAndObjectId> data;\n+\n+        public Wrapper(){}\n+        public Wrapper(List<TypeWithClassPropertyAndObjectId> data) { this.data = data; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAsClassProperty() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassProperty(\"Foobar\"));\n+\n+        // Type info should be written as an attribute, so:\n+        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n+         *   inclusion, which allows use of attribute over element, so:\n+         */\n+        final String exp = \n+            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.dataformat.xml.misc.PolymorphicTypesTest..SubTypeWithClassProperty\\\">\"\n+            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.types.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n+            +\"<name>Foobar</name></SubTypeWithClassProperty>\"\n+                ;\n+        assertEquals(exp, xml);\n+        \n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassProperty.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassProperty.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassProperty) result).name);\n+    }\n+        \n+    public void testAsClassObject() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassObject(\"Foobar\"));\n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassObject.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassObject.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassObject) result).name);\n+    }\n+\n+    /**\n+     * Test for issue 81\n+     */\n+    public void testAsPropertyWithObjectId() throws Exception\n+    {\n+        List<TypeWithClassPropertyAndObjectId> data = new ArrayList<PolymorphicTypesTest.TypeWithClassPropertyAndObjectId>();\n+        TypeWithClassPropertyAndObjectId object = new TypeWithClassPropertyAndObjectId(\"Foobar\");\n+        data.add(object);\n+        // This will be written as an id reference instead of object; as such, no type info will be written.\n+        data.add(object);\n+        String xml = _xmlMapper.writeValueAsString(new Wrapper(data));\n+        Wrapper result = _xmlMapper.readValue(xml, Wrapper.class);\n+        assertNotNull(result);\n+        assertSame(result.data.get(0), result.data.get(1));\n+        assertEquals(\"Foobar\", result.data.get(0).id);\n+    }\n+}\n+   \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class TextValueTest extends XmlTestBase\n+{\n+    static class Simple\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        // same as: @javax.xml.bind.annotation.XmlAttribute\n+        public int a = 13;\n+\n+        @JacksonXmlText\n+        // about same as: @javax.xml.bind.annotation.XmlValue\n+        public String text = \"something\";\n+    }\n+\t\n+    // [Issue#24]\n+\n+    static class Main {\n+        @JsonProperty(\"com.test.stack\") public Stack stack;\n+    }\n+    static class Stack {\n+        public String name;\n+\n+        @JsonProperty(\"com.test.stack.slot\")\n+        public Slot slot;\n+    }\n+    static class Slot {\n+        @JsonProperty(\"name\")\n+        public String name;\n+\n+        @JsonProperty(\"id\")\n+        public String id;\n+\n+        @JsonProperty(\"height\")\n+        public String height;\n+\n+        @JsonProperty(\"width\")\n+        public String width;\n+\n+        @JacksonXmlText\n+        public String value;\n+    }\n+\n+    static class JAXBStyle\n+    {\n+        public String value;\n+    }\n+\n+    // [Issue#66]\n+    static class Issue66Bean\n+    {\n+        @JacksonXmlProperty(isAttribute = true)\n+        protected String id;\n+\n+        @JacksonXmlText\n+        protected String textValue;\n+    }\n+\n+    // [Issue#72]\n+    \n+    static class TextOnlyBean\n+    {\n+        @JacksonXmlText\n+        protected String textValue;\n+\n+        public TextOnlyBean() { }\n+        public TextOnlyBean(String str, boolean foo) { textValue = str; }\n+    }\n+\n+    @JsonPropertyOrder({ \"a\", \"b\" })\n+    static class TextOnlyWrapper\n+    {\n+        public TextOnlyBean a, b;\n+\n+        public TextOnlyWrapper() { }\n+        public TextOnlyWrapper(String a, String b) {\n+            this.a = new TextOnlyBean(a, true);\n+            this.b = new TextOnlyBean(b, true);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testSerializeAsText() throws IOException\n+    {\n+        String xml = MAPPER.writeValueAsString(new Simple());\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+        // [Issue#56]: should work with indentation as well\n+        xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Simple());\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+    }\n+\n+    public void testDeserializeAsText() throws IOException\n+    {\n+        Simple result = MAPPER.readValue(\"<Simple a='99'>else</Simple>\", Simple.class);\n+        assertEquals(99, result.a);\n+        assertEquals(\"else\", result.text);\n+    }\n+    \n+    public void testIssue24() throws Exception\n+    {\n+        final String TEXT = \"+/null/this is a long string\";\n+        final String XML =\n+    \t\t\t\"<main>\\n\"\n+    \t\t\t+\"<com.test.stack name='stack1'>\\n\"\n+    \t\t\t+\"<com.test.stack.slot height='0' id='0' name='slot0' width='0'>\"\n+    \t\t\t+TEXT\n+    \t\t\t+\"</com.test.stack.slot>\\n\"\n+    \t\t\t+\"</com.test.stack>\\n\"\n+    \t\t\t+\"</main>\";\n+        Main main = MAPPER.readValue(XML, Main.class);\n+        assertNotNull(main.stack);\n+        assertNotNull(main.stack.slot);\n+        assertEquals(TEXT, main.stack.slot.value);\n+    }\n+\n+    // for [Issue#36]\n+    public void testAlternateTextElementName() throws IOException\n+    {\n+        final String XML = \"<JAXBStyle>foo</JAXBStyle>\";\n+        // first: verify that without change, POJO would not match:\n+        try {\n+            MAPPER.readValue(XML, JAXBStyle.class);\n+            fail(\"Should have failed\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Unrecognized\");\n+        }\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setXMLTextElementName(\"value\");\n+        XmlMapper mapper = new XmlMapper(module);\n+        JAXBStyle pojo = mapper.readValue(XML, JAXBStyle.class);\n+        assertEquals(\"foo\", pojo.value);\n+    }\n+\n+    // [Issue#66], implicit property from \"XmlText\"\n+    public void testIssue66() throws Exception\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(false);\n+        XmlMapper mapper = new XmlMapper(module);\n+        final String XML = \"<Issue66Bean id=\\\"id\\\">text</Issue66Bean>\";\n+\n+        // let's start with deserialization\n+        Issue66Bean node = mapper.readValue(XML, Issue66Bean.class);\n+        assertEquals(\"id\", node.id);\n+        assertEquals(\"text\", node.textValue);\n+\n+        // Let's serialize too\n+        String json = mapper.writeValueAsString(node);\n+        assertEquals(XML, json);\n+    }\n+\n+    // [Issue#72]\n+    public void testTextOnlyPojo() throws Exception\n+    {\n+        XmlMapper mapper = xmlMapper(true);\n+        TextOnlyWrapper input = new TextOnlyWrapper(\"foo\", \"bar\");\n+        // serialization should work fine\n+        String xml = mapper.writeValueAsString(input);\n+        assertEquals(\"<TextOnlyWrapper><a>foo</a><b>bar</b></TextOnlyWrapper>\", xml);\n+        // but how about deser?\n+        TextOnlyWrapper result = mapper.readValue(xml, TextOnlyWrapper.class);\n+        assertNotNull(result);\n+        assertEquals(\"foo\", result.a.textValue);\n+        assertEquals(\"bar\", result.b.textValue);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;\n+\n+public class XmlTextTest extends XmlTestBase\n+{\n+    @JsonPropertyOrder({\"first\",\"second\"})\n+    class Data{\n+        @JacksonXmlText\n+        public String first;\n+        public String second;\n+        public Data(String first, String second) {\n+            this.first = first;\n+            this.second = second;\n+        }\n+    }\n+\n+    public void testXmlTextWithSuppressedValue() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        mapper.setSerializationInclusion(Include.NON_EMPTY);\n+        String xml = mapper.writeValueAsString(new Data(\"\",\"second\"));\n+        String expectedXml = \"<Data><second>second</second></Data>\";\n+        assertEquals(expectedXml, xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class TestIndentation extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class StringWrapperBean {\n+        public StringWrapper string;\n+        \n+        public StringWrapperBean() { }\n+        public StringWrapperBean(String s) { string = new StringWrapper(s); }\n+    }\n+\n+    static class IntWrapperBean {\n+        public IntWrapper wrapped;\n+        \n+        public IntWrapperBean() { }\n+        public IntWrapperBean(int i) { wrapped = new IntWrapper(i); }\n+    }\n+\n+    // [Issue#45]\n+    static class AttrBean {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public int count = 3;\n+    }\n+\n+    static class AttrBean2 {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public int count = 3;\n+\n+        public int value = 14;\n+    }\n+\n+    public class PojoFor123\n+    {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String name;\n+\n+        @JsonInclude(JsonInclude.Include.NON_EMPTY) \n+        public String property;\n+        \n+        public PojoFor123(String name) {\n+            this.name = name;       \n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+        _xmlMapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Verify [JACKSON-444], Issue #1\n+    public void testSimpleStringBean() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new StringWrapperBean(\"abc\")); \n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+        \tfail(\"No indentation: XML == \"+xml);\n+        }\n+        // Let's verify we get similar stuff back, first:\n+        StringWrapperBean result = _xmlMapper.readValue(xml, StringWrapperBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.string.str);\n+\n+    }\n+\n+    public void testSimpleIntBean() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new IntWrapperBean(42)); \n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+        \tfail(\"No indentation: XML == \"+xml);\n+        }\n+        // Let's verify we get similar stuff back, first:\n+        IntWrapperBean result = _xmlMapper.readValue(xml, IntWrapperBean.class);\n+        assertNotNull(result);\n+        assertEquals(42, result.wrapped.i);\n+    }\n+    \n+    public void testSimpleMap() throws Exception\n+    {\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(\"a\", \"b\");\n+        String xml = _xmlMapper.writeValueAsString(map);\n+\n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+            fail(\"No indentation: XML == \"+xml);\n+        }\n+        \n+        // Let's verify we get similar stuff back, first:\n+        Map<?,?> result = _xmlMapper.readValue(xml, Map.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(\"b\", map.get(\"a\"));\n+    }\n+\n+    // [Issue#45]: Use of attributes should not force linefeed for empty elements\n+    public void testWithAttr() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttrBean());\n+        assertEquals(\"<AttrBean count=\\\"3\\\"/>\", xml);\n+        String xml2 = _xmlMapper.writeValueAsString(new AttrBean2());\n+        assertEquals(\"<AttrBean2 count=\\\"3\\\">\\n  <value>14</value>\\n</AttrBean2>\", xml2);\n+    }\n+\n+    public void testEmptyElem() throws Exception\n+    {\n+        PojoFor123 simple = new PojoFor123(\"foobar\");\n+        String xml = _xmlMapper.writeValueAsString(simple);\n+        assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\", xml);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestJDKSerializability.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+/**\n+ * Unit test related to core [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n+ * as it relates to XmlFactory.\n+ */\n+public class TestJDKSerializability extends XmlTestBase\n+{\n+    @JacksonXmlRootElement(localName=\"MyPojo\")\n+    static class MyPojo {\n+        public int x;\n+        private int y;\n+        \n+        public MyPojo() { }\n+        public MyPojo(int x0, int y0) {\n+            x = x0;\n+            y = y0;\n+        }\n+        \n+        public int getY() { return y; }\n+        public void setY(int y) { this.y = y; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */    \n+\n+    public void testXmlFactory() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        String origXml = \"<root><a>text</a></root>\";\n+        assertEquals(origXml, _writeXml(f, false));\n+\n+        // Ok: freeze dry factory, thaw, and try to use again:\n+        byte[] frozen = jdkSerialize(f);\n+        XmlFactory f2 = jdkDeserialize(frozen);\n+        assertNotNull(f2);\n+        assertEquals(origXml, _writeXml(f2, false));\n+\n+        // Let's also try byte-based variant, for fun...\n+        assertEquals(origXml, _writeXml(f2, true));\n+    }\n+\n+    public void testMapper() throws IOException\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        final String EXP = \"<MyPojo><x>2</x><y>3</y></MyPojo>\";\n+        final MyPojo p = new MyPojo(2, 3);\n+        assertEquals(EXP, mapper.writeValueAsString(p));\n+\n+        byte[] bytes = jdkSerialize(mapper);\n+        XmlMapper mapper2 = jdkDeserialize(bytes);\n+        assertEquals(EXP, mapper2.writeValueAsString(p));\n+        MyPojo p2 = mapper2.readValue(EXP, MyPojo.class);\n+        assertEquals(p.x, p2.x);\n+        assertEquals(p.y, p2.y);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"resource\")\n+    protected String _writeXml(XmlFactory f, boolean useBytes) throws IOException\n+    {\n+        if (useBytes) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            ToXmlGenerator jg = f.createGenerator(bytes);\n+            _write(f, jg);\n+            return bytes.toString(\"UTF-8\");\n+        }\n+        StringWriter sw = new StringWriter();\n+        ToXmlGenerator jg = f.createGenerator(sw);\n+        _write(f, jg);\n+        return sw.toString();\n+    }\n+        \n+    protected void _write(JsonFactory f, ToXmlGenerator jg) throws IOException\n+    {\n+        jg.setNextName(new QName(\"root\"));\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"a\");\n+        jg.writeString(\"text\");\n+        jg.writeEndObject();\n+        jg.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestNamespaces.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+public class TestNamespaces extends XmlTestBase\n+{\n+    @JacksonXmlRootElement(localName=\"person\", namespace=\"http://example.org/person\" )\n+    static class Person\n+    {\n+        private String name;\n+\n+        @JacksonXmlProperty(namespace = \"http://example.org/person\")\n+        public String getName() { return name; }\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    // [Issue-26]: should prefer the \"default namespace\"\n+    public void testRootNamespace() throws Exception\n+    {\n+        Person person = new Person();\n+        person.setName( \"hello\" );\n+        \n+        XmlMapper xmlMapper = new XmlMapper();\n+        String xml = xmlMapper.writeValueAsString(person);\n+\n+        // should use \"the default namespace\"...\n+        final String PREFIX = \"<person xmlns=\";\n+        if (!xml.startsWith(PREFIX)) {\n+            fail(\"Expected XML to begin with '\"+PREFIX+\"', instead got: \"+xml);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestSerialization extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class StringBean2\n+    {\n+        public String text = \"foobar\";\n+    }\n+\n+    static class AttributeBean\n+    {\n+        @JacksonXmlProperty(isAttribute=true, localName=\"attr\")\n+        public String text = \"something\";\n+    }\n+\n+    static class AttrAndElem\n+    {\n+        public String elem = \"whatever\";\n+        \n+        @JacksonXmlProperty(isAttribute=true, localName=\"id\")\n+        public int attr = 42;\n+    }\n+\n+    static class WrapperBean<T>\n+    {\n+        public T value;\n+\n+        public WrapperBean() { }\n+        public WrapperBean(T v) { value = v; }\n+    }\n+\n+    static class MapBean\n+    {\n+        public Map<String,Integer> map;\n+\n+        public MapBean() { }\n+        public MapBean(Map<String,Integer> v) { map = v; }\n+    }\n+    \n+    static class NsElemBean\n+    {\n+        @JacksonXmlProperty(namespace=\"http://foo\")\n+        public String text = \"blah\";\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"root\")\n+    static class RootBean\n+    {\n+        public String value = \"123\";\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"nsRoot\", namespace=\"http://foo\")\n+    static class NsRootBean\n+    {\n+        public String value = \"abc\";\n+    }\n+\n+    static class CustomSerializer extends StdScalarSerializer<String>\n+    {\n+        public CustomSerializer() { super(String.class); }\n+        \n+        @Override\n+        public void serialize(String value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException {\n+            jgen.writeString(\"custom:\"+value);\n+        }\n+    }\n+\n+    static class CustomMap extends LinkedHashMap<String, Integer> { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Unit test to verify that root name is properly set\n+    public void testRootName() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new StringBean());\n+        \n+        // Hmmh. Looks like JDK Stax may adds bogus ns declaration. As such,\n+        // let's just check that name starts ok...\n+        if (!xml.startsWith(\"<StringBean\")) {\n+            fail(\"Expected root name of 'StringBean'; but XML document is [\"+xml+\"]\");\n+        }\n+\n+        // and then see that basic non-namespace root is ok\n+        xml = _xmlMapper.writeValueAsString(new RootBean());\n+        assertEquals(\"<root><value>123</value></root>\", xml);\n+\n+        // and namespace one too\n+        xml = _xmlMapper.writeValueAsString(new NsRootBean());\n+        if (xml.indexOf(\"nsRoot\") < 0) { // verify localName\n+            fail(\"Expected root name of 'nsRoot'; but XML document is [\"+xml+\"]\");\n+        }\n+        // and NS declaration\n+        if (xml.indexOf(\"http://foo\") < 0) {\n+            fail(\"Expected NS declaration for 'http://foo', not found, XML document is [\"+xml+\"]\");\n+        }\n+    }\n+    \n+    public void testSimpleAttribute() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttributeBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<AttributeBean attr=\\\"something\\\"/>\", xml);\n+    }\n+\n+    public void testSimpleAttrAndElem() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttrAndElem());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<AttrAndElem id=\\\"42\\\"><elem>whatever</elem></AttrAndElem>\", xml);\n+    }\n+\n+    public void testSimpleNsElem() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new NsElemBean());\n+        xml = removeSjsxpNamespace(xml);\n+        // here we assume woodstox automatic prefixes, not very robust but:\n+        assertEquals(\"<NsElemBean><wstxns1:text xmlns:wstxns1=\\\"http://foo\\\">blah</wstxns1:text></NsElemBean>\", xml);\n+    }\n+\n+    @SuppressWarnings(\"boxing\")\n+    public void testMap() throws IOException\n+    {\n+        // First, map in a general wrapper\n+        LinkedHashMap<String,Integer> map = new LinkedHashMap<String,Integer>();\n+        map.put(\"a\", 1);\n+        map.put(\"b\", 2);\n+\n+        String xml;\n+        \n+        xml = _xmlMapper.writeValueAsString(new WrapperBean<Map<?,?>>(map));\n+        assertEquals(\"<WrapperBean><value>\"\n+                +\"<a>1</a>\"\n+                +\"<b>2</b>\"\n+                +\"</value></WrapperBean>\",\n+                xml);\n+\n+        // then as strongly typed\n+        xml = _xmlMapper.writeValueAsString(new MapBean(map));\n+        assertEquals(\"<MapBean><map>\"\n+                +\"<a>1</a>\"\n+                +\"<b>2</b>\"\n+                +\"</map></MapBean>\",\n+                xml);\n+    }\n+\n+    public void testNakedMap() throws IOException\n+    {\n+        CustomMap input = new CustomMap();        \n+        input.put(\"a\", 123);\n+        input.put(\"b\", 456);\n+        String xml = _xmlMapper.writeValueAsString(input);\n+\n+        \n+//        System.err.println(\"XML = \"+xml);\n+        \n+        CustomMap result = _xmlMapper.readValue(xml, CustomMap.class);\n+        assertEquals(2, result.size());\n+\n+        assertEquals(Integer.valueOf(456), result.get(\"b\"));\n+    }\n+    \n+    // for [Issue#41]\n+    public void testCustomSerializer() throws Exception\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.addSerializer(String.class, new CustomSerializer());\n+        XmlMapper xml = new XmlMapper(module);\n+        assertEquals(\"<String>custom:foo</String>\", xml.writeValueAsString(\"foo\"));\n+    }\n+    \n+    // manual 'test' to see \"what would JAXB do?\"\n+    /*\n+    public void testJAXB() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        javax.xml.bind.JAXB.marshal(new StringListBean(\"a\", \"b\", \"c\"), sw);\n+        System.out.println(\"JAXB -> \"+sw);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerializationAttr.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+public class TestSerializationAttr extends XmlTestBase\n+{\n+    static class NsAttrBean\n+    {\n+        @JacksonXmlProperty(namespace=\"http://foo\", isAttribute=true)\n+        public String attr = \"3\";\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"test\", namespace=\"http://root\")\n+    static class Issue19Bean\n+    {\n+        @JsonProperty\n+        @JacksonXmlProperty(namespace = \"http://my.ns\")\n+        public boolean booleanA = true;\n+\n+        @JsonProperty\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String id = \"abc\";\n+    }\n+\n+    public class Jurisdiction {\n+        @JacksonXmlProperty(isAttribute=true)\n+        protected String name = \"Foo\";\n+        @JacksonXmlProperty(isAttribute=true)\n+        protected int value = 13;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleNsAttr() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new NsAttrBean());\n+        xml = removeSjsxpNamespace(xml);\n+        // here we assume woodstox automatic prefixes, not very robust but:\n+        assertEquals(\"<NsAttrBean xmlns:wstxns1=\\\"http://foo\\\" wstxns1:attr=\\\"3\\\"/>\", xml);\n+    }\n+\n+    public void testIssue19() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new Issue19Bean());\n+        xml = removeSjsxpNamespace(xml);\n+        xml = xml.replaceAll(\"\\\"\", \"'\");\n+        // as with above, assumes exact NS allocation strategy, not optimal:\n+        assertEquals(\"<test xmlns='http://root' id='abc'>\"\n+        \t\t+\"<wstxns1:booleanA xmlns:wstxns1='http://my.ns'>true</wstxns1:booleanA></test>\",\n+        \txml);\n+    }\n+\n+    public void testIssue6() throws IOException\n+    {\n+        assertEquals(\"<Jurisdiction name=\\\"Foo\\\" value=\\\"13\\\"/>\",\n+                _xmlMapper.writeValueAsString(new Jurisdiction()));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    // manual 'test' to see \"what would JAXB do?\"\n+    /*\n+    public void testJAXB() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        javax.xml.bind.JAXB.marshal(new StringListBean(\"a\", \"b\", \"c\"), sw);\n+        System.out.println(\"JAXB -> \"+sw);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerializationManual.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+public class TestSerializationManual extends XmlTestBase\n+{\n+    public static class Value {\n+        public int num;\n+\n+        public Value(int n) { num = n; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testIssue54() throws Exception\n+    {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        xmlMapper.enable(ToXmlGenerator.Feature.WRITE_XML_DECLARATION);\n+        StringWriter sw = new StringWriter();\n+        ToXmlGenerator generator = (ToXmlGenerator) xmlMapper.getFactory().createGenerator(sw);\n+        generator.initGenerator();\n+\n+        generator.setNextName(new QName(\"items\"));\n+        generator.writeStartObject();\n+        ArrayList<Value> values = new ArrayList<Value>();\n+        values.add(new Value(13));\n+        values.add(new Value(456));\n+        for (Value value : values) {\n+            generator.writeFieldName(\"foo\");\n+            generator.setNextName(new QName(\"item\"));\n+            generator.writeObject(value);\n+        }\n+        generator.writeEndObject();\n+        generator.close();\n+        \n+        String xml = sw.toString();\n+        \n+        // Remove XML declaration\n+        assertTrue(xml.startsWith(\"<?xml version\"));\n+        int ix = xml.indexOf(\"?>\");\n+        xml = xml.substring(ix+2).trim();\n+        \n+        assertEquals(\"<items><item><num>13</num></item><item><num>456</num></item></items>\", xml);\n+   }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerializationOrdering.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class TestSerializationOrdering extends XmlTestBase\n+{\n+    @JsonPropertyOrder({\"a\", \"c\" })\n+    static class Bean91 {\n+        public String a;\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String b;\n+        public String c;\n+\n+        public Bean91(String a, String b, String c) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+        }\n+    }\n+\n+    public void testOrdering() throws Exception\n+    {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        String xml = xmlMapper.writeValueAsString(new Bean91(\"1\", \"2\", \"3\"));\n+        assertEquals(\"<Bean91 b=\\\"2\\\"><a>1</a><c>3</c></Bean91>\", xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerializerCustom.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/**\n+ * Unit test(s) for [Issue#42], problems with custom (de)serializer.\n+ */\n+@SuppressWarnings(\"serial\")\n+public class TestSerializerCustom extends XmlTestBase\n+{\n+    @JsonPropertyOrder({ \"name\", \"obj\" })\n+    static class Item {\n+        public String name;\n+        public Foo obj;\n+        public Item(String name, Foo obj) {\n+          this.name = name;\n+          this.obj = obj;\n+        }\n+    }\n+\n+    static class Foo {\n+        public String name;\n+        protected Foo() { }\n+        public Foo(String name) {\n+          this.name = name;\n+        }\n+    }\n+\n+    static class ItemDeserializer extends StdDeserializer<Item> {\n+        public ItemDeserializer() {\n+          super(Item.class);\n+        }\n+\n+        @Override\n+        public Item deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+          ObjectCodec oc = jp.getCodec();\n+          JsonNode json = oc.readTree(jp);\n+          JsonNode foo = json.get(\"obj\");\n+          if (foo == null) {\n+              throw new IllegalStateException(\"missing foo property\");\n+          }\n+          return new Item(json.path(\"name\").asText(),\n+                  oc.treeToValue(foo, Foo.class));\n+        }\n+    }\n+\n+    public class ItemSerializer extends StdSerializer<Item> {\n+        public ItemSerializer() {\n+          super(Item.class);\n+        }\n+\n+        @Override\n+        public void serialize(Item value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+          jgen.writeStartObject();\n+          jgen.writeObjectField(\"obj\", value.obj);\n+          jgen.writeStringField(\"name\", value.name);\n+          jgen.writeEndObject();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testIssue42() throws Exception\n+    {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        SimpleModule m = new SimpleModule(\"module\", new Version(1,0,0,null,null,null));\n+        m.addSerializer(Item.class, new ItemSerializer());\n+        m.addDeserializer(Item.class, new ItemDeserializer());\n+        xmlMapper.registerModule(m);\n+\n+        Item value = new Item(\"itemName\", new Foo(\"fooName\"));\n+        String xml = xmlMapper.writeValueAsString(value);\n+        \n+        Item result = xmlMapper.readValue(xml, Item.class);\n+        assertNotNull(result);\n+        assertEquals(\"itemName\", result.name);\n+        assertNotNull(result.obj);\n+        assertEquals(\"fooName\", result.obj.name);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestXmlDeclaration.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+public class TestXmlDeclaration extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testXml10Declaration() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);\n+        String xml = mapper.writeValueAsString(new StringBean(\"123\"));\n+        assertEquals(xml, \"<?xml version='1.0' encoding='UTF-8'?><StringBean><text>123</text></StringBean>\");\n+    }\n+\n+    public void testXml11Declaration() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.configure(ToXmlGenerator.Feature.WRITE_XML_1_1, true);\n+        String xml = mapper.writeValueAsString(new StringBean(\"abcd\"));\n+        assertEquals(xml, \"<?xml version='1.1' encoding='UTF-8'?><StringBean><text>abcd</text></StringBean>\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/FormatDetectionTest.java\n+package com.fasterxml.jackson.dataformat.xml.stream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+\n+public class FormatDetectionTest extends XmlTestBase\n+{\n+    static class POJO {\n+        public int x, y;\n+        \n+        public POJO() { }\n+        public POJO(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    static class ListPOJO {\n+        @JacksonXmlElementWrapper(localName=\"list\")\n+        public List<POJO> v = new ArrayList<POJO>();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, success\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleValidXmlDecl() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?xml version='1.0'?><root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidRoot() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidDoctype() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<!DOCTYPE root [ ]>   <root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleValidComment() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"  <!-- comment -->  <root></root>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidPI() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?target foo?><root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleViaObjectReader() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        XmlMapper xmlMapper = new XmlMapper();\n+\n+        ObjectReader detecting = mapper.reader(POJO.class);\n+        detecting = detecting\n+                .withFormatDetection(detecting, xmlMapper.reader(POJO.class));\n+        POJO pojo = detecting.readValue(utf8Bytes(\"<POJO><y>3</y><x>1</x></POJO>\"));\n+        assertNotNull(pojo);\n+        assertEquals(1, pojo.x);\n+        assertEquals(3, pojo.y);\n+    }\n+    \n+    public void testListViaObjectReader() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        XmlMapper xmlMapper = new XmlMapper();\n+        ListPOJO list = new ListPOJO();\n+        list.v.add(new POJO(1, 2));\n+        list.v.add(new POJO(3, 4));\n+        String xml = xmlMapper.writeValueAsString(list);\n+\n+        ObjectReader detecting = mapper.reader(ListPOJO.class);\n+        ListPOJO resultList = detecting\n+                .withFormatDetection(detecting, xmlMapper.reader(ListPOJO.class))\n+                .readValue(utf8Bytes(xml));\n+        assertNotNull(resultList);\n+        assertEquals(2, resultList.v.size());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, error handling\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleInvalid() throws Exception\n+    {\n+        DataFormatDetector detector = new DataFormatDetector(new XmlFactory());\n+        final String NON_XML = \"{\\\"foo\\\":\\\"bar\\\"}\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_XML.getBytes(\"UTF-8\")));\n+        // should not have match\n+        assertFalse(matcher.hasMatch());\n+        // and thus:\n+        assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength());\n+        // also:\n+        assertNull(matcher.createParserWithMatch());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlGeneratorTest.java\n+package com.fasterxml.jackson.dataformat.xml.stream;\n+\n+import java.io.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+public class XmlGeneratorTest extends XmlTestBase\n+{\n+    public void testSimpleElement() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createGenerator(out);\n+        // root name is special, need to be fed first:\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"elem\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root><elem>value</elem></root>\", xml);\n+    }\n+\n+    public void testSimpleAttribute() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createGenerator(out);\n+        // root name is special, need to be fed first:\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.setNextIsAttribute(true);\n+        gen.writeFieldName(\"attr\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root attr=\\\"value\\\"/>\", xml);\n+    }\n+\n+    public void testSecondLevelAttribute() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createGenerator(out);\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"elem\");\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.setNextIsAttribute(true);\n+        gen.writeFieldName(\"attr\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root><elem attr=\\\"value\\\"/></root>\", xml);\n+    }\n+\n+    public void testAttrAndElem() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createGenerator(out);\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.writeFieldName(\"attr\");\n+        gen.setNextIsAttribute(true);\n+        gen.writeNumber(-3);\n+\n+        // Also let's add child element as well\n+        gen.setNextIsAttribute(false);\n+        gen.writeFieldName(\"elem\");\n+        gen.writeNumber(13);\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = removeSjsxpNamespace(out.toString());\n+        assertEquals(\"<root attr=\\\"-3\\\"><elem>13</elem></root>\", xml);\n+    }\n+\n+    // [Issue#6], missing overrides for File-backed generator\n+    public void testWriteToFile() throws Exception\n+    {\n+        ObjectMapper mapper = new XmlMapper();\n+        File f = File.createTempFile(\"test\", \".tst\");\n+        mapper.writeValue(f, new IntWrapper(42));\n+\n+        String xml = readAll(f).trim();\n+\n+        assertEquals(\"<IntWrapper><i>42</i></IntWrapper>\", xml);\n+        f.delete();\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n+package com.fasterxml.jackson.dataformat.xml.stream;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+\n+\n+public class XmlParserTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected JsonFactory _jsonFactory;\n+    protected XmlFactory _xmlFactory;\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jsonFactory = new JsonFactory();\n+        _xmlFactory = new XmlFactory();\n+        _xmlMapper = new XmlMapper();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testSimplest() throws Exception\n+    {\n+        assertEquals(\"{\\\"leaf\\\":\\\"abc\\\"}\",\n+                _readXmlWriteJson(\"<root><leaf>abc</leaf></root>\"));\n+    }\n+\n+    public void testSimpleWithEmpty() throws Exception\n+    {\n+        assertEquals(\"{\\\"leaf\\\":null}\",\n+                _readXmlWriteJson(\"<root><leaf /></root>\"));\n+    }\n+\n+    public void testSimpleNested() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":\\\"xyz\\\"}}}\",\n+                _readXmlWriteJson(\"<root><a><b><c>xyz</c></b></a></root>\"));\n+    }\n+\n+    /**\n+     * Unit test that verifies that we can write sample document from JSON\n+     * specification as XML, and read it back in \"as JSON\", with\n+     * expected transformation.\n+     */\n+    public void testRoundTripWithSample() throws Exception\n+    {\n+        // First: let's convert from sample JSON doc to default xml output\n+        JsonNode root = new ObjectMapper().readTree(SAMPLE_DOC_JSON_SPEC);\n+        String xml = _xmlMapper.writeValueAsString(root);\n+        \n+        // Here we would ideally use base class test method. Alas, it won't\n+        // work due to couple of problems;\n+        // (a) All values are reported as Strings (not ints, for example\n+        // (b) XML mangles arrays, so all we see are objects.\n+        // Former could be worked around; latter less so at this point.\n+\n+        // So, for now, let's just do sort of minimal verification, manually\n+        JsonParser jp = _xmlMapper.getFactory().createParser(xml);\n+        \n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        verifyFieldName(jp, \"Image\");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        verifyFieldName(jp, \"Width\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        verifyFieldName(jp, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        verifyFieldName(jp, \"Title\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        verifyFieldName(jp, \"Thumbnail\");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        verifyFieldName(jp, \"Url\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        verifyFieldName(jp, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        verifyFieldName(jp, \"Width\");\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+\n+        // Note: arrays are \"eaten\"; wrapping is done using BeanPropertyWriter, so:\n+        //assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        //verifyFieldName(jp, \"IDs\");\n+        //assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(jp));\n+\n+        // no matching entry for array:\n+        //assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+        \n+        jp.close();\n+    }\n+\n+    /**\n+     * Test to ensure functionality used to force an element to be reported\n+     * as \"JSON\" Array, instead of default Object.\n+     */\n+    public void testForceElementAsArray() throws Exception\n+    {\n+        final String XML = \"<array><elem>value</elem><elem><property>123</property></elem><elem>1</elem></array>\";\n+\n+        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n+\n+        // First: verify handling without forcing array handling:\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <array>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"value\", xp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <property>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken());\n+        assertEquals(\"property\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"123\", xp.getText());\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // <object>\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"1\", xp.getText());\n+\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </array>\n+        xp.close();\n+\n+        // And then with array handling:\n+        xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n+        assertTrue(xp.getParsingContext().inRoot());\n+\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <array>\n+        assertTrue(xp.getParsingContext().inObject()); // true until we do following:\n+\n+        // must request 'as-array' handling, which will \"convert\" current token:\n+        assertTrue(\"Should 'convert' START_OBJECT to START_ARRAY\", xp.isExpectedStartArrayToken());\n+        assertToken(JsonToken.START_ARRAY, xp.getCurrentToken()); // <elem>\n+        assertTrue(xp.getParsingContext().inArray());\n+\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertTrue(xp.getParsingContext().inArray());\n+        assertEquals(\"value\", xp.getText());\n+\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <property>\n+        assertTrue(xp.getParsingContext().inObject());\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken());\n+        assertEquals(\"property\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"123\", xp.getText());\n+        assertTrue(xp.getParsingContext().inObject());\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </property>\n+        assertTrue(xp.getParsingContext().inArray());\n+\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertTrue(xp.getParsingContext().inArray());\n+        assertEquals(\"1\", xp.getText());\n+\n+        assertToken(JsonToken.END_ARRAY, xp.nextToken()); // </array>\n+        assertTrue(xp.getParsingContext().inRoot());\n+        xp.close();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+\n+    public void testXmlAttributes() throws Exception\n+    {\n+        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n+\n+        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n+\n+        // First: verify handling without forcing array handling:\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\n+        assertEquals(\"max\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"7\", xp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n+        assertEquals(\"offset\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"9\", xp.getText());\n+\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n+        xp.close();\n+    }\n+\n+    private String _readXmlWriteJson(String xml) throws IOException\n+    {\n+        StringWriter w = new StringWriter();\n+\n+        JsonParser jp = _xmlFactory.createParser(xml);\n+        JsonGenerator jg = _jsonFactory.createGenerator(w);\n+        while (jp.nextToken() != null) {\n+            jg.copyCurrentEvent(jp);\n+        }\n+        jp.close();\n+        jg.close();\n+        return w.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlTokenStreamTest.java\n+package com.fasterxml.jackson.dataformat.xml.stream;\n+\n+import java.io.*;\n+\n+import javax.xml.stream.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream;\n+\n+public class XmlTokenStreamTest extends XmlTestBase\n+{\n+    public void testSimple() throws Exception\n+    {\n+        String XML = \"<root><leaf id='123'>abc</leaf></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"leaf\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_NAME, tokens.next());\n+        assertEquals(\"id\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_VALUE, tokens.next());\n+        assertEquals(\"123\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_TEXT, tokens.next());\n+        assertEquals(\"abc\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+\n+    public void testRootAttributes() throws Exception\n+    {\n+        String XML = \"<root id='x' />\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_NAME, tokens.next());\n+        assertEquals(\"id\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_VALUE, tokens.next());\n+        assertEquals(\"x\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+    \n+    public void testEmptyTags() throws Exception\n+    {\n+        String XML = \"<root><leaf /></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"leaf\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+\n+    public void testNested() throws Exception\n+    {\n+        String XML = \"<root><a><b><c>abc</c></b></a></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"a\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"b\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"c\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_TEXT, tokens.next());\n+        assertEquals(\"abc\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+    \n+}", "timestamp": 1396671002, "metainfo": ""}