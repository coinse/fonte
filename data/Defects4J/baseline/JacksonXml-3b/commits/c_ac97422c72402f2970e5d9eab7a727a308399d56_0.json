{"sha": "ac97422c72402f2970e5d9eab7a727a308399d56", "log": "Added main codebase as well", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/FromXmlParser.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import org.codehaus.jackson.Base64Variant;\n+import org.codehaus.jackson.JsonLocation;\n+import org.codehaus.jackson.JsonParseException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+import org.codehaus.jackson.ObjectCodec;\n+import org.codehaus.jackson.impl.JsonParserMinimalBase;\n+import org.codehaus.jackson.impl.JsonReadContext;\n+import org.codehaus.jackson.io.IOContext;\n+import org.codehaus.jackson.util.ByteArrayBuilder;\n+\n+import com.fasterxml.jackson.xml.util.XmlTokenStream;\n+\n+/**\n+ * {@link JsonParser} implementation that exposes XML structure as\n+ * set of JSON events that can be used for data binding.\n+ * \n+ * @since 1.6\n+ */\n+public class FromXmlParser\n+    extends JsonParserMinimalBase\n+{\n+    /**\n+     * Enumeration that defines all togglable features for XML parsers\n+     */\n+    public enum Feature {\n+        DUMMY_PLACEHOLDER(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+\n+    /**\n+     * In cases where a start element has both attributes and non-empty textual\n+     * value, we have to create a bogus property; we will use this as\n+     * the property name.\n+     */\n+    protected final static String UNNAMED_TEXT_PROPERTY = \"\";\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link org.codehaus.jackson.smile.SmileGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+    \n+    protected ObjectCodec _objectCodec;\n+\n+    /*\n+    /**********************************************************\n+    /* I/O state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Information about parser context, context in which\n+     * the next token is to be parsed (root, array, object).\n+     */\n+    protected JsonReadContext _parsingContext;\n+    \n+    protected final XmlTokenStream _xmlTokens;\n+\n+    /**\n+     * We need special handling to keep track of whether a value\n+     * may be exposed as simple leaf value.\n+     */\n+    protected boolean _mayBeLeaf;\n+\n+    protected JsonToken _nextToken;\n+\n+    protected String _currText;\n+    \n+    /*\n+    /**********************************************************\n+    /* Parsing state, parsed values\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n+     * we better reuse it for remainder of content.\n+     */\n+    protected ByteArrayBuilder _byteArrayBuilder = null;\n+\n+    /**\n+     * We will hold on to decoded binary data, for duration of\n+     * current event, so that multiple calls to\n+     * {@link #getBinaryValue} will not need to decode data more\n+     * than once.\n+     */\n+    protected byte[] _binaryValue;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamReader xmlReader)\n+    {\n+        super(genericParserFeatures);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _objectCodec = codec;\n+        _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+        // and thereby start a scope\n+        _nextToken = JsonToken.START_OBJECT;\n+        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public FromXmlParser enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public FromXmlParser disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public FromXmlParser configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamReader getStaxReader() {\n+        return _xmlTokens.getXmlReader();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonParser impl\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to get the name associated with\n+     * the current event.\n+     */\n+    @Override\n+    public String getCurrentName()\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-395]: start markers require information from parent\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonReadContext parent = _parsingContext.getParent();\n+            return parent.getCurrentName();\n+        }\n+        return _parsingContext.getCurrentName();\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            try {\n+                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n+                    _xmlTokens.closeCompletely();\n+                } else {\n+                    _xmlTokens.close();\n+                }\n+            } finally {\n+                // as per [JACKSON-324], do in finally block\n+                // Also, internal buffer(s) can now be released as well\n+                _releaseBuffers();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    @Override\n+    public JsonReadContext getParsingContext()\n+    {\n+        return _parsingContext;\n+    }\n+\n+    /**\n+     * Method that return the <b>starting</b> location of the current\n+     * token; that is, position of the first character from input\n+     * that starts the current token.\n+     */\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        return _xmlTokens.getTokenLocation();\n+    }\n+\n+    /**\n+     * Method that returns location of the last processed character;\n+     * usually for error reporting purposes\n+     */\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        return _xmlTokens.getCurrentLocation();\n+    }\n+\n+    /**\n+     * Since xml representation can not really distinguish between array\n+     * and object starts (both are represented with elements), this method\n+     * is overridden and taken to mean that expecation is that the current\n+     * start element is to mean 'start array', instead of default of\n+     * 'start object'.\n+     */\n+    @Override\n+    public boolean isExpectedStartArrayToken() {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.START_OBJECT) {\n+            _currToken = JsonToken.START_ARRAY;\n+            // Ok: must replace current context with array as well\n+            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            // And just in case a field name was to be returned, wipe it\n+            _nextToken = null;\n+            return true;\n+        }\n+        return (t == JsonToken.START_ARRAY);\n+    }\n+    \n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        if (_nextToken != null) {\n+            JsonToken t = _nextToken;\n+            _currToken = t;\n+            _nextToken = null;\n+            switch (t) {\n+            case START_OBJECT:\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                break;\n+            case START_ARRAY:\n+                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+                break;\n+            case END_OBJECT:\n+            case END_ARRAY:\n+                _parsingContext = _parsingContext.getParent();\n+                break;\n+            case FIELD_NAME:\n+                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                break;\n+            default: // VALUE_STRING, VALUE_NULL\n+                // should be fine as is?\n+            }\n+            return t;\n+        }\n+\n+        int token = _xmlTokens.next();\n+        \n+        /* Need to have a loop just because we may have to eat/convert\n+         * a start-element that indicates an array element.\n+         */\n+        while (token == XmlTokenStream.XML_START_ELEMENT) {\n+\n+            // If we thought we might get leaf, no such luck\n+            if (_mayBeLeaf) {\n+                // leave _mayBeLeaf set, as we start a new context\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            if (_parsingContext.inArray()) {\n+                /* Yup: in array, so this element could be verified; but it won't be reported\n+                 * anyway, and we need to process following event.\n+                 */\n+                token = _xmlTokens.next();\n+                _mayBeLeaf = true;\n+                continue;\n+            }\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            _mayBeLeaf = true;\n+            /* Ok: in array context we need to skip reporting field names. But what's the best way\n+             * to find next token?\n+             * \n+             */\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        }\n+\n+        // Ok; beyond start element, what do we get?\n+        switch (token) {\n+        case XmlTokenStream.XML_END_ELEMENT:\n+            // Simple, except that if this is a leaf, need to suppress end:\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                return (_currToken = JsonToken.VALUE_NULL);\n+            }\n+            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+            _parsingContext = _parsingContext.getParent();\n+            return _currToken;\n+            \n+        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+            // If there was a chance of leaf node, no more...\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _currText = _xmlTokens.getText();\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            _mayBeLeaf = false;\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+            _currText = _xmlTokens.getText();\n+            return (_currToken = JsonToken.VALUE_STRING);\n+        case XmlTokenStream.XML_TEXT:\n+            _currText = _xmlTokens.getText();\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                // Also: must skip following END_ELEMENT\n+                _xmlTokens.skipEndElement();\n+                return (_currToken = JsonToken.VALUE_STRING);\n+            }\n+            // If not a leaf, need to transform into property...\n+            _parsingContext.setCurrentName(UNNAMED_TEXT_PROPERTY);\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_END:\n+            return (_currToken = null);\n+        }\n+        // should never get here\n+        _throwInternal();\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText() throws IOException, JsonParseException\n+    {\n+        switch (_currToken) {\n+        case FIELD_NAME:\n+            return getCurrentName();\n+        case VALUE_STRING:\n+            return _currText;\n+        }\n+        return (_currToken == null) ? null : _currToken.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? null : text.toCharArray();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? 0 : text.length();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return 0;\n+    }\n+\n+    /**\n+     * XML input actually would offer access to character arrays; but since\n+     * we must coalesce things it cannot really be exposed.\n+     */\n+    @Override\n+    public boolean hasTextCharacters()\n+    {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, binary\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_binaryValue == null) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+        }        \n+        return _binaryValue;\n+    }\n+    \n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+    \n+        final String str = getText();\n+        int ptr = 0;\n+        int len = str.length();\n+\n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0, null);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1, null);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2, null);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3, null);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+        return builder.toByteArray();\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new JsonParseException(base, JsonLocation.NA);\n+    }\n+\n+    protected void _reportBase64EOF()\n+        throws JsonParseException\n+    {\n+        throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Numeric accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls for stuff from JsonParser\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when an EOF is encountered between tokens.\n+     * If so, it may be a legitimate EOF, but only iff there\n+     * is no open non-root context.\n+     */\n+    @Override\n+    protected void _handleEOF() throws JsonParseException\n+    {\n+        if (!_parsingContext.inRoot()) {\n+            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    protected void _releaseBuffers() throws IOException\n+    {\n+        /*\n+        _textBuffer.releaseBuffers();\n+        char[] buf = _nameCopyBuffer;\n+        if (buf != null) {\n+            _nameCopyBuffer = null;\n+            _ioContext.releaseNameCopyBuffer(buf);\n+        }\n+        */\n+    }\n+\n+    protected ByteArrayBuilder _getByteArrayBuilder()\n+    {\n+        if (_byteArrayBuilder == null) {\n+            _byteArrayBuilder = new ByteArrayBuilder();\n+        } else {\n+            _byteArrayBuilder.reset();\n+        }\n+        return _byteArrayBuilder;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/JacksonXmlAnnotationIntrospector.java\n+package com.fasterxml.jackson.xml;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import org.codehaus.jackson.map.introspect.Annotated;\n+import org.codehaus.jackson.map.introspect.AnnotatedField;\n+import org.codehaus.jackson.map.introspect.AnnotatedMethod;\n+import org.codehaus.jackson.map.introspect.AnnotatedParameter;\n+import org.codehaus.jackson.map.introspect.JacksonAnnotationIntrospector;\n+import org.codehaus.jackson.map.jsontype.TypeIdResolver;\n+import org.codehaus.jackson.map.jsontype.impl.StdTypeResolverBuilder;\n+\n+import com.fasterxml.jackson.xml.annotate.*;\n+\n+/**\n+ * Extension of {@link JacksonAnnotationIntrospector} that is needed to support\n+ * additional xml-specific annotation that Jackson provides. Note, however, that\n+ * there is no JAXB annotation support here; that is provided with\n+ * separate introspector (see {@link org.codehaus.jackson.xc.JaxbAnnotationIntrospector}).\n+ * \n+ * @since 1.7\n+ */\n+public class JacksonXmlAnnotationIntrospector\n+    extends JacksonAnnotationIntrospector\n+    implements XmlAnnotationIntrospector\n+{    \n+    /*\n+    /**********************************************************\n+    /* XmlAnnotationIntrospector\n+    /**********************************************************\n+     */\n+\n+    //@Override\n+    public Boolean isOutputAsAttribute(Annotated ann)\n+    {\n+        JacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\n+        if (prop != null) {\n+            return prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+\n+    //@Override\n+    public String findNamespace(Annotated ann)\n+    {\n+        JacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\n+        if (prop != null) {\n+            return prop.namespace();\n+        }\n+        return null;\n+    }\n+\n+    //@Override\n+    public QName findWrapperElement(Annotated ann)\n+    {\n+        JacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\n+        if (w != null) {\n+            return new QName(w.namespace(), w.localName());\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for name, property detection\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public String findSerializablePropertyName(AnnotatedField af)\n+    {\n+        JacksonXmlProperty pann = af.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findSerializablePropertyName(af);\n+    }\n+\n+    @Override\n+    public String findSettablePropertyName(AnnotatedMethod am)\n+    {\n+        JacksonXmlProperty pann = am.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findSettablePropertyName(am);\n+    }\n+\n+    @Override\n+    public String findDeserializablePropertyName(AnnotatedField af)\n+    {\n+        JacksonXmlProperty pann = af.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findDeserializablePropertyName(af);\n+    }\n+\n+    @Override\n+    public String findPropertyNameForParam(AnnotatedParameter ap)\n+    {\n+        JacksonXmlProperty pann = ap.getAnnotation(JacksonXmlProperty.class);\n+        // can not return empty String here, so:\n+        if (pann != null) {\n+            String name = pann.localName();\n+            if (name.length() > 0) {\n+                return name;\n+            }\n+        }\n+        return super.findPropertyNameForParam(ap);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overrides for non-public helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will override this method so that we can return instance\n+     * that cleans up type id property name to be a valid xml name.\n+     */\n+    @Override\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n+    {\n+        return new XmlTypeResolverBuilder();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Since XML names can not contain all characters JSON names can, we may\n+     * need to replace characters. Let's start with trivial replacement of\n+     * ASCII characters that can not be included.\n+     */\n+    protected static String sanitizeXmlName(String name)\n+    {\n+        StringBuilder sb = new StringBuilder(name);\n+        int changes = 0;\n+        for (int i = 0, len = name.length(); i < len; ++i) {\n+            char c = name.charAt(i);\n+            if (c > 127) continue;\n+            if (c >= 'a' && c <= 'z') continue;\n+            if (c >= 'A' && c <= 'Z') continue;\n+            if (c >= '0' && c <= '9') continue;\n+            if (c == '_' || c == '.' || c == '-') continue;\n+            // Ok, need to replace\n+            ++changes;\n+            sb.setCharAt(i, '_');\n+        }\n+        if (changes == 0) {\n+            return name;\n+        }\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Custom specialization of {@link StdTypeResolverBuilder}; needed so that\n+     * type id property name can be modified as necessary to make it legal\n+     * xml element or attribute name.\n+     */\n+    protected static class XmlTypeResolverBuilder extends StdTypeResolverBuilder\n+    {\n+        @Override\n+        public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n+        {\n+            super.init(idType, idRes);\n+            if (_typeProperty != null) {\n+                _typeProperty = sanitizeXmlName(_typeProperty);\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n+        {\n+            // ok to have null/empty; will restore to use defaults\n+            if (typeIdPropName == null || typeIdPropName.length() == 0) {\n+                typeIdPropName = _idType.getDefaultPropertyName();\n+            }\n+            _typeProperty = sanitizeXmlName(typeIdPropName);\n+            return this;\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ToXmlGenerator.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import org.codehaus.stax2.XMLStreamWriter2;\n+import org.codehaus.stax2.ri.Stax2WriterAdapter;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.impl.JsonGeneratorBase;\n+import org.codehaus.jackson.impl.JsonWriteContext;\n+import org.codehaus.jackson.io.IOContext;\n+import org.codehaus.jackson.io.SerializedString;\n+\n+import com.fasterxml.jackson.xml.util.DefaultXmlPrettyPrinter;\n+import com.fasterxml.jackson.xml.util.StaxUtil;\n+\n+/**\n+ * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n+ * Operation requires calling code (usually either standard Jackson serializers,\n+ * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n+ * additional configuration calls beyond regular {@link JsonGenerator} API,\n+ * mostly to pass namespace information.\n+ * \n+ * @since 1.6\n+ */\n+public final class ToXmlGenerator\n+    extends JsonGeneratorBase\n+{\n+    /**\n+     * If we support optional definition of element names, this is the element\n+     * name to use...\n+     */\n+    protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n+    \n+    /**\n+     * Enumeration that defines all togglable extra XML-specific features\n+     */\n+    public enum Feature {\n+        /**\n+         * Feature that controls whether XML declaration should be written before\n+         * when generator is initialized (true) or not (false)\n+         */\n+        WRITE_XML_DECLARATION(false),\n+\n+        /**\n+         * Feature that controls whether output should be done as XML 1.1; if so,\n+         * certain aspects may differ from default (1.0) processing: for example,\n+         * XML declaration will be automatically added (regardless of setting\n+         * <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n+         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n+         * control characters (Ascii codes 0 through 31) as well as additional linefeeds\n+         * and name characters.\n+         */\n+        WRITE_XML_1_1(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    final protected XMLStreamWriter2 _xmlWriter;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link org.codehaus.jackson.smile.SmileGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+\n+    /*\n+    /**********************************************************\n+    /* XML Output state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element or attribute name to use for next output call.\n+     * Assigned by either code that initiates serialization\n+     * or bean serializer.\n+     */\n+    protected QName _nextName = null;\n+\n+    /**\n+     * Marker flag that indicates whether next name to write\n+     * implies an attribute (true) or element (false)\n+     */\n+    protected boolean _nextIsAttribute = false;\n+    \n+    /**\n+     * To support proper serialization of arrays it is necessary to keep\n+     * stack of element names, so that we can \"revert\" to earlier \n+     */\n+    protected LinkedList<QName> _elementNameStack = new LinkedList<QName>();\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator(IOContext ctxt, int genericGeneratorFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamWriter sw)\n+    {\n+        super(genericGeneratorFeatures, codec);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n+    }\n+\n+    /**\n+     * Method called before writing any other output, to optionally\n+     * output XML declaration.\n+     */\n+    public void initGenerator()  throws IOException, JsonGenerationException\n+    {\n+        try {\n+            if ((_xmlFeatures & Feature.WRITE_XML_1_1.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n+            } else if ((_xmlFeatures & Feature.WRITE_XML_DECLARATION.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public ToXmlGenerator disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public ToXmlGenerator configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamWriter getStaxWriter() {\n+        return _xmlWriter;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, passing XML specific settings\n+    /**********************************************************\n+     */\n+\n+    public void setNextIsAttribute(boolean isAttribute)\n+    {\n+        _nextIsAttribute = isAttribute;\n+    }\n+\n+    public final void setNextName(QName name)\n+    {\n+        _nextName = name;\n+    }\n+\n+    /**\n+     * Methdod called when a structured (collection, array, map) is being\n+     * output.\n+     * \n+     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n+     * @param wrappedName Element used around individual content items (can not\n+     *   be null)\n+     */\n+    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+        this.setNextName(wrappedName);\n+    }\n+\n+    /**\n+     * Method called after a structured collection output has completed\n+     */\n+    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        // First: wrapper to close?\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeEndElement();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator method overrides\n+    /**********************************************************\n+     */\n+    \n+    /* Most overrides in this section are just to make methods final,\n+     * to allow better inlining...\n+     */\n+\n+    @Override\n+    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    {\n+        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        // Should this ever get called?\n+        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n+        setNextName(new QName(ns, name));\n+    }\n+    \n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+    }\n+    \n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            _handleStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        _writeContext = _writeContext.getParent();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            _handleEndObject();\n+        }\n+    }\n+\n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleStartObject() throws IOException, JsonGenerationException\n+    {\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // Need to keep track of names to make Lists work correctly\n+        _elementNameStack.addLast(_nextName);\n+        try {\n+            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleEndObject() throws IOException, JsonGenerationException\n+    {\n+        // We may want to repeat same element, so:\n+        _nextName = _elementNameStack.removeLast();\n+        try {\n+            // note: since attributes don't nest, can only have one attribute active, so:\n+            _nextIsAttribute = false;\n+            _xmlWriter.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+    \n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) { // must write attribute name and value with one call\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text);\n+                _xmlWriter.writeEndElement();\n+            } \n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }    \n+    \n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        writeString(text.getValue());\n+    }\n+    \n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, unprocessed (\"raw\")\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException\n+    {\n+        writeRaw(String.valueOf(c));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, base64-encoded binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        if (data == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write Binary value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                // Stax2 API only has 'full buffer' write method:\n+                byte[] fullBuffer = toFullBuffer(data, offset, len);\n+                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBinary(data, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    private byte[] toFullBuffer(byte[] data, int offset, int len)\n+    {\n+        // might already be ok:\n+        if (offset == 0 && len == data.length) {\n+            return data;\n+        }\n+        byte[] result = new byte[len];\n+        if (len > 0) {\n+            System.arraycopy(data, offset, result, 0, len);\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, primitive\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write boolean value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), state);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBoolean(state);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write null value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // !!! TODO: proper use of 'xsd:isNil'\n+        try {\n+            if (_nextIsAttribute) {\n+                /* With attributes, best just leave it out, right? (since there's no way\n+                 * to use 'xsi:nil')\n+                 */\n+            } else {\n+                _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(int i) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInt(i);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(long l) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeLong(l);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(double d) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDouble(d);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(float f) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeFloat(f);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException\n+    {\n+        if (dec == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDecimalAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDecimal(dec);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException\n+    {\n+        if (v == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntegerAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), v);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInteger(v);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException,JsonGenerationException, UnsupportedOperationException\n+    {\n+        writeString(encodedValue);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations, overrides for other methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected final void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeValue();\n+        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n+            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n+        }\n+    }\n+\n+    /**\n+     * Standard JSON indenter does not work well with XML, use\n+     * default XML indenter instead.\n+     */\n+    @Override\n+    public final JsonGenerator useDefaultPrettyPrinter()\n+    {\n+        return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void flush() throws IOException\n+    {\n+        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n+            try {\n+                _xmlWriter.flush();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+//        boolean wasClosed = _closed;\n+        super.close();\n+\n+        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n+         *   scopes.\n+         */\n+        // First: let's see that we still have buffers...\n+        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n+            try {\n+                while (true) {\n+                    JsonStreamContext ctxt = getOutputContext();\n+                    if (ctxt.inArray()) {\n+                        writeEndArray();\n+                    } else if (ctxt.inObject()) {\n+                        writeEndObject();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n+                 *   hit by this as a collateral problem in some cases. Yuck.\n+                 */\n+                throw new JsonGenerationException(e);\n+            }\n+        }\n+        try {\n+            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n+                _xmlWriter.closeCompletely();\n+            } else {\n+                _xmlWriter.close();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void _releaseBuffers() {\n+        // Nothing to do here, as we have no buffers\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected void handleMissingName()\n+    {\n+        throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlAnnotationIntrospector.java\n+package com.fasterxml.jackson.xml;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.map.introspect.Annotated;\n+\n+/**\n+ * Additional extension interface used above and beyond\n+ * {@link org.codehaus.jackson.map.AnnotationIntrospector} to\n+ * handle XML-specific configuration.\n+ * \n+ * @since 1.7\n+ */\n+public interface XmlAnnotationIntrospector\n+{\n+    /**\n+     * Method that can be called to figure out generic namespace\n+     * property for an annotated object.\n+     *\n+     * @return Null if annotated thing does not define any\n+     *   namespace information; non-null namespace (which may\n+     *   be empty String) otherwise\n+     */\n+    public String findNamespace(Annotated ann);\n+\n+    /**\n+     * Method used to check whether given annotated element\n+     * (field, method, constructor parameter) has indicator that suggest\n+     * it be output as an XML attribute or not (as element)\n+     */\n+    public Boolean isOutputAsAttribute(Annotated ann);\n+\n+    /**\n+     * Method to check if specified property has annotation that indicates\n+     * that it should be wrapped in an element; and if so, name to use.\n+     * Note: local name of \"\" is used to indicate that name should default\n+     * to using name (local name and namespace) of property itself.\n+     */\n+    public QName findWrapperElement(Annotated ann);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlBeanPropertyWriter.java\n+package com.fasterxml.jackson.xml;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.map.JsonSerializer;\n+import org.codehaus.jackson.map.SerializerProvider;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.impl.PropertySerializerMap;\n+\n+/**\n+ * Property writer sub-class used for handling element wrapping needed for serializing\n+ * collection (array, Collection; possibly Map) types.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /*\n+    /**********************************************************\n+    /* Config settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element name used as wrapper for collection.\n+     */\n+    protected final QName _wrapperName;\n+\n+    /**\n+     * Element name used for items in the collection\n+     */\n+    protected final QName _wrappedName;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName)\n+    {\n+        super(wrapped);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+    }\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName,\n+            JsonSerializer<Object> serializer)\n+    {\n+        super(wrapped, serializer);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+    }\n+    \n+    @Override\n+    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n+    {\n+        // sanity check to ensure sub-classes override...\n+        if (getClass() != XmlBeanPropertyWriter.class) {\n+            throw new IllegalStateException(\"Sub-class does not override 'withSerializer()'; needs to!\");\n+        }\n+        return new XmlBeanPropertyWriter(this, _wrapperName, _wrappedName, ser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridden version so that we can wrap output within wrapper element if\n+     * and as necessary.\n+     */\n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        /* Hmmh. Does the default null serialization work ok here? For now let's assume\n+         * it does; can change later if not.\n+         */\n+        if (value == null) {\n+            if (!_suppressNulls) {\n+                jgen.writeFieldName(_name);\n+                prov.defaultSerializeNull(jgen);\n+            }\n+            return;\n+        }\n+        // For non-nulls, first: simple check for direct cycles\n+        if (value == bean) {\n+            _reportSelfReference(bean);\n+        }\n+        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n+            return;\n+        }\n+\n+        // Ok then; addition we want to do is to add wrapper element, and that's what happens here\n+        ToXmlGenerator xmlGen = (ToXmlGenerator) jgen;\n+        xmlGen.startWrappedValue(_wrapperName, _wrappedName);\n+        \n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+\n+        xmlGen.finishWrappedValue(_wrapperName, _wrappedName);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlBeanSerializer.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.IOException;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.map.JsonMappingException;\n+import org.codehaus.jackson.map.SerializerProvider;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+\n+/**\n+ * Specific sub-class of {@link BeanSerializer} needed to take care\n+ * of some xml-specific aspects, such as distinction between attributes\n+ * and elements.\n+ */\n+public class XmlBeanSerializer extends BeanSerializer\n+{\n+    /**\n+     * Number of attributes to write; these will have been ordered to be the first\n+     * properties to write.\n+     */\n+    protected final int _attributeCount;\n+\n+    /**\n+     * Array that contains namespace URIs associated with properties, if any;\n+     * null if no namespace definitions have been assigned\n+     */\n+    protected final QName[] _xmlNames;\n+    \n+    public XmlBeanSerializer(Class<?> type, BeanPropertyWriter[] props,\n+            BeanPropertyWriter[] filteredProps, Object filterId,\n+            int attrCount, QName[] xmlNames)\n+    {\n+        super(type, props, filteredProps, filterId);\n+        _attributeCount = attrCount;\n+        _xmlNames = xmlNames;\n+    }\n+\n+    protected XmlBeanSerializer(XmlBeanSerializer src, BeanPropertyWriter[] filtered)\n+    {\n+        super(src, filtered);\n+        _attributeCount = src._attributeCount;\n+        _xmlNames = src._xmlNames;\n+    }\n+    \n+    @Override\n+    public BeanSerializer withFiltered(BeanPropertyWriter[] filtered)\n+    {\n+        if (filtered == _filteredProps) {\n+            return this;\n+        }\n+        return new XmlBeanSerializer(this, filtered);\n+    }\n+\n+    /**\n+     * Main serialization method needs to be overridden to allow XML-specific\n+     * extra handling, such as indication of whether to write attributes or\n+     * elements.\n+     */\n+    @Override\n+    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final ToXmlGenerator jgen = (ToXmlGenerator) jgen0;\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+    \n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            jgen.setNextIsAttribute(true);\n+        }\n+        final QName[] xmlNames = _xmlNames;\n+        \n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    jgen.setNextIsAttribute(false);\n+                }\n+                jgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, jgen, provider);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n+             *   have many stack frames to spare... just one or two; can't\n+             *   make many calls.\n+             */\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlBeanSerializerFactory.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.SerializerFactory;\n+import org.codehaus.jackson.map.introspect.AnnotatedMember;\n+import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+import org.codehaus.jackson.map.ser.BeanSerializerFactory;\n+import org.codehaus.jackson.map.ser.PropertyBuilder;\n+import org.codehaus.jackson.map.type.TypeBindings;\n+\n+/**\n+ * Specialized version of {@link BeanSerializerFactory} which is used to\n+ * add specific overrides to handle XML-specific details such as\n+ * difference between attributes and elements.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlBeanSerializerFactory extends BeanSerializerFactory\n+{\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    protected final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: creation, configuration\n+    /**********************************************************\n+     */\n+    \n+    protected XmlBeanSerializerFactory(Config config)\n+    {\n+        super(config);\n+    }\n+\n+    @Override\n+    public SerializerFactory withConfig(Config config)\n+    {\n+        // Same as super-class, we require all sub-classes to override this method:\n+        if (getClass() != XmlBeanSerializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of XmlBeanSerializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n+                    +\"additional serializer definitions\");\n+        }\n+        return new XmlBeanSerializerFactory(config);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods from standard bean serializer factory\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected BeanSerializer instantiateBeanSerializer(SerializationConfig config,\n+            BasicBeanDescription beanDesc,\n+            List<BeanPropertyWriter> properties)\n+    {\n+        BeanPropertyWriter[] writers = properties.toArray(new BeanPropertyWriter[properties.size()]);\n+        // Ok: how many attributes do we have to write? namespaces?\n+        QName[] xmlNames = new QName[properties.size()];\n+        int attrCount = 0;\n+        int i = 0;\n+        for (BeanPropertyWriter bpw : properties) {\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                if (info.isAttribute()) {\n+                    ++attrCount;\n+                }\n+                ns = info.getNamespace();\n+            }\n+            xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+            ++i;\n+        }\n+        return new XmlBeanSerializer(beanDesc.getBeanClass(), writers, null,\n+                findFilterId(config, beanDesc),\n+                attrCount, xmlNames);\n+    }\n+\n+    /**\n+     * Need to override to sort properties so that we will always start with attributes (if any),\n+     * followed by elements.\n+     */\n+    @Override\n+    protected List<BeanPropertyWriter> sortBeanProperties(SerializationConfig config, BasicBeanDescription beanDesc,\n+            List<BeanPropertyWriter> props)\n+    {\n+        props = super.sortBeanProperties(config, beanDesc, props);\n+        // Ok: let's first see if we any attributes; if not, just return lists as is:\n+        for (BeanPropertyWriter bpw : props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                props = _orderAttributesFirst(props);\n+                break;\n+            }\n+        }\n+        return props;\n+    }\n+    \n+    /**\n+     * Need to override this specific method so that we can inject XML-specific information\n+     * into bean writer, so that it can be retrieved later on\n+     */\n+    @Override\n+    protected BeanPropertyWriter _constructWriter(SerializationConfig config, TypeBindings typeContext,\n+            PropertyBuilder pb, boolean staticTyping, String name, AnnotatedMember propertyMember)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        String ns = findNamespaceAnnotation(intr, propertyMember);\n+        Boolean isAttribute = findIsAttributeAnnotation(intr, propertyMember);\n+\n+        BeanPropertyWriter propertyWriter = super._constructWriter(config, typeContext, pb, staticTyping, name, propertyMember);\n+        propertyWriter.setInternalSetting(KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+\n+        // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n+        Class<?> type = propertyMember.getRawType();\n+        if (_isContainerType(type)) {\n+            String localName = null, wrapperNs = null;\n+\n+            QName wrappedName = new QName(ns, propertyWriter.getName());\n+            QName wrapperName = findWrapperName(intr, propertyMember);\n+            if (wrapperName != null) {\n+                localName = wrapperName.getLocalPart();\n+                wrapperNs = wrapperName.getNamespaceURI();\n+            }\n+            /* Empty/missing localName means \"use property name as wrapper\"; later on\n+             * should probably make missing (null) mean \"don't add a wrapper\"\n+             */\n+            if (localName == null || localName.length() == 0) {\n+                wrapperName = wrappedName;\n+            } else {\n+                wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n+            }\n+            return new XmlBeanPropertyWriter(propertyWriter, wrapperName, wrappedName);\n+        }\n+        \n+        return propertyWriter;\n+    }\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    private boolean _isContainerType(Class<?> rawType)\n+    {\n+        if (rawType.isArray()) {\n+            // Just one special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            if (rawType == byte[].class) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return Map.class.isAssignableFrom(rawType) || Collection.class.isAssignableFrom(rawType);\n+    }\n+    \n+    private String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n+                if (n != null) {\n+                    return n;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    private List<BeanPropertyWriter> _orderAttributesFirst(List<BeanPropertyWriter> props)\n+    {\n+        List<BeanPropertyWriter> attrs = new ArrayList<BeanPropertyWriter>();\n+        List<BeanPropertyWriter> elems = new ArrayList<BeanPropertyWriter>();\n+        for (BeanPropertyWriter bpw : props) {\n+            if (_isAttribute(bpw)) {\n+                attrs.add(bpw);\n+            } else {\n+                elems.add(bpw);\n+            }\n+        }\n+        if (elems.size() > 0) {\n+            attrs.addAll(elems);\n+        }\n+        return attrs;\n+    }    \n+\n+    private boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper container class used to contain xml specific information\n+     * we need to retain to construct proper bean serializer\n+     */\n+    protected final static class XmlInfo\n+    {\n+        protected final String _namespace;\n+        protected final boolean _isAttribute;\n+        \n+        public XmlInfo(Boolean isAttribute, String ns)\n+        {\n+            _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n+            _namespace = (ns == null) ? \"\" : ns;\n+        }\n+\n+        public String getNamespace() { return _namespace; }\n+        public boolean isAttribute() { return _isAttribute; }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlFactory.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.*;\n+\n+import javax.xml.stream.*;\n+\n+import org.codehaus.stax2.io.Stax2ByteArraySource;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.io.IOContext;\n+\n+import com.fasterxml.jackson.xml.util.StaxUtil;\n+\n+/**\n+* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n+* instances.\n+*<p>\n+* Implements {@link JsonFactory} since interface for constructing XML backed\n+* parsers and generators is quite similar to dealing with JSON.\n+* \n+* @author tatu\n+* \n+* @since 1.6\n+*/\n+public class XmlFactory extends JsonFactory\n+{\n+    /**\n+     * Bitfield (set of flags) of all parser features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n+\n+    /**\n+     * Bitfield (set of flags) of all generator features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected int _xmlParserFeatures = DEFAULT_XML_PARSER_FEATURE_FLAGS;\n+\n+    protected int _xmlGeneratorFeatures = DEFAULT_XML_GENERATOR_FEATURE_FLAGS;\n+\n+    protected XMLInputFactory _xmlInputFactory;\n+\n+    protected XMLOutputFactory _xmlOutputFactory;\n+\n+    /*\n+    /**********************************************************\n+    /* Factory construction, configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default constructor used to create factory instances.\n+     * Creation of a factory instance is a light-weight operation,\n+     * but it is still a good idea to reuse limited number of\n+     * factory instances (and quite often just a single instance):\n+     * factories are used as context for storing some reused\n+     * processing objects (such as symbol tables parsers use)\n+     * and this reuse only works within context of a single\n+     * factory instance.\n+     */\n+    public XmlFactory() { this(null); }\n+\n+    public XmlFactory(ObjectCodec oc) {\n+        this(oc, null, null);\n+    }\n+\n+    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    {\n+        this(null, xmlIn, xmlOut);\n+    }\n+    \n+    public XmlFactory(ObjectCodec oc,\n+            XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    {\n+        super(oc);\n+        if (xmlIn == null) {\n+            /* 24-Jun-2010, tatu: Ugh. JDK authors seem to waffle on what the name of\n+             *   factory constructor method is...\n+             */\n+            //xmlIn = XMLInputFactory.newFactory();\n+            xmlIn = XMLInputFactory.newInstance();\n+        }\n+        if (xmlOut == null) {\n+            //xmlOut = XMLOutputFactory.newFactory();\n+            xmlOut = XMLOutputFactory.newInstance();\n+        }\n+        // Better ensure namespaces get built properly, so:\n+        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n+        // and for parser, force coalescing as well (much simpler to use)\n+        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, true);\n+        _xmlInputFactory = xmlIn;\n+        _xmlOutputFactory = xmlOut;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, parser settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified parser feature\n+     * (check {@link FromXmlParser.Feature} for list of features)\n+     */\n+    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n+    {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified parser feature\n+     * (check {@link FromXmlParser.Feature} for list of features)\n+     */\n+    public XmlFactory enable(FromXmlParser.Feature f) {\n+        _xmlParserFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified parser features\n+     * (check {@link JsonParser.Feature} for list of features)\n+     */\n+    public XmlFactory disable(FromXmlParser.Feature f) {\n+        _xmlParserFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Checked whether specified parser feature is enabled.\n+     */\n+    public final boolean isEnabled(FromXmlParser.Feature f) {\n+        return (_xmlParserFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Configuration, generator settings\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified generator feature\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     *\n+     * @since 1.2\n+     */\n+    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Method for enabling specified generator features\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     */\n+    public XmlFactory enable(ToXmlGenerator.Feature f) {\n+        _xmlGeneratorFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified generator feature\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     */\n+    public XmlFactory disable(ToXmlGenerator.Feature f) {\n+        _xmlGeneratorFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Check whether specified generator feature is enabled.\n+     */\n+    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n+        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional configuration\n+    /**********************************************************\n+     */\n+\n+    public void setXMLInputFactory(XMLInputFactory f) {\n+        _xmlInputFactory = f;\n+    }\n+\n+    public void setXMLOutputFactory(XMLOutputFactory f) {\n+        _xmlOutputFactory = f;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden parts of public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     *<p>\n+     * note: co-variant return type\n+     */\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(OutputStream out, JsonEncoding enc)\n+        throws IOException\n+    {\n+        // false -> we won't manage the stream unless explicitly directed to\n+        IOContext ctxt = _createContext(out, false);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(Writer out)\n+        throws IOException\n+    {\n+        IOContext ctxt = _createContext(out, false);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(File f, JsonEncoding enc)\n+        throws IOException\n+    {\n+        OutputStream out = new FileOutputStream(f);\n+        // true -> yes, we have to manage the stream since we created it\n+        IOContext ctxt = _createContext(out, true);\n+        ctxt.setEncoding(enc);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden internal factory methods\n+    /**********************************************************\n+     */\n+\n+    //protected IOContext _createContext(Object srcRef, boolean resourceManaged)\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(InputStream in, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(in);\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(Reader r, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(r);\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n+    {\n+        try {\n+            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n+    {\n+        try {\n+            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n+    {\n+        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n+        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n+        sw.setDefaultNamespace(\"\");\n+        return sw;\n+    }\n+\n+    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n+    {\n+        // for now, nothing to do... except let's find the root element\n+        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n+            ;\n+        }\n+        return sr;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlMapper.java\n+package com.fasterxml.jackson.xml;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.map.*;\n+import org.codehaus.jackson.util.VersionUtil;\n+\n+import com.fasterxml.jackson.xml.util.XmlRootNameLookup;\n+\n+/**\n+ * Customized {@link ObjectMapper} that will read and write XML instead of JSON,\n+ * using XML-backed {@link JsonFactory} implementation ({@link XmlFactory}).\n+ *<p>\n+ * Mapper itself overrides some aspects of functionality to try to handle\n+ * data binding aspects as similar to JAXB as possible.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlMapper extends ObjectMapper\n+{\n+    private final static AnnotationIntrospector XML_ANNOTATION_INTROSPECTOR = new JacksonXmlAnnotationIntrospector();\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public XmlMapper()\n+    {\n+        this(new XmlFactory());\n+    }\n+    \n+    public XmlMapper(XmlFactory xmlFactory)\n+    {\n+        /* Need to override serializer provider (due to root name handling);\n+         * deserializer provider fine as is\n+         */\n+        super(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n+        \n+        // Bean serializers are somewhat customized as well:\n+        _serializerFactory = new XmlBeanSerializerFactory(null);\n+        // as is introspector\n+        _deserializationConfig.setAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n+        _serializationConfig.setAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n+    }\n+\n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     */\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access to configuration settings\n+    /**********************************************************\n+     */\n+\n+    public ObjectMapper configure(ToXmlGenerator.Feature f, boolean state) {\n+        ((XmlFactory)_jsonFactory).configure(f, state);\n+        return this;\n+    }\n+\n+    public ObjectMapper configure(FromXmlParser.Feature f, boolean state) {\n+        ((XmlFactory)_jsonFactory).configure(f, state);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * XML indentation differs from JSON indentation, thereby\n+     * need to change default pretty-printer\n+     */\n+    @Override\n+    protected PrettyPrinter _defaultPrettyPrinter() {\n+        return null; // new DefaultPrettyPrinter();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlSerializerProvider.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.IOException;\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.SerializerFactory;\n+import org.codehaus.jackson.map.ser.StdSerializerProvider;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.xml.util.XmlRootNameLookup;\n+\n+/**\n+ * We need to override some parts of {@link org.codehaus.jackson.map.SerializerProvider}\n+ * implementation to handle oddities of XML output, like \"extra\" root element.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlSerializerProvider extends StdSerializerProvider\n+{\n+    /**\n+     * If all we get to serialize is a null, there's no way to figure out\n+     * expected root name; so let's just default to something like \"<null>\"...\n+     */\n+    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n+    \n+    protected final XmlRootNameLookup _rootNameLookup;\n+    \n+    protected XmlSerializerProvider(XmlRootNameLookup rootNames)\n+    {\n+        super();\n+        _rootNameLookup = rootNames;\n+    }\n+\n+    protected XmlSerializerProvider(SerializationConfig config, XmlSerializerProvider src,\n+            SerializerFactory f)\n+    {\n+        super(config, src, f);\n+        _rootNameLookup  = src._rootNameLookup;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf)\n+    {\n+        return new XmlSerializerProvider(config, this, jsf);\n+    }\n+    \n+    @Override\n+    protected  void _serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = (value == null) ? ROOT_NAME_FOR_NULL\n+                : _rootNameLookup.findRootName(value.getClass(), _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super._serializeValue(jgen, value);\n+    }\n+\n+    @Override\n+    protected  void _serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = _rootNameLookup.findRootName(rootType, _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super._serializeValue(jgen, value, rootType);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/annotate/JacksonXmlElementWrapper.java\n+package com.fasterxml.jackson.xml.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.codehaus.jackson.annotate.JacksonAnnotation;\n+\n+/**\n+ * Annotation that is similar to JAXB <code>javax.xml.bind.annotation.XmlElementWrapper</code>,\n+ * to indicate wrapper element to use (if any) for Collection types (arrays,\n+ * <code>java.util.Collection</code>). If defined, a separate container (wrapper) element\n+ * is used; if not, entries are written without wrapping.\n+ * Name of wrapper element defaults to name of the property but can be explicitly defined\n+ * to something else.\n+ * \n+ * @author tatu\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JacksonXmlElementWrapper\n+{\n+    String namespace() default \"\";\n+    String localName() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/annotate/JacksonXmlProperty.java\n+package com.fasterxml.jackson.xml.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.codehaus.jackson.annotate.JacksonAnnotation;\n+\n+/**\n+ * Annotation that can be used to provide XML-specific configuration\n+ * for properties, above and beyond what\n+ * {@link org.codehaus.jackson.annotate.JsonProperty} contains.\n+ * It is an alternative to using JAXB annotations.\n+ * \n+ * @since 1.7\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JacksonXmlProperty\n+{\n+    boolean isAttribute() default false;\n+    String namespace() default \"\";\n+    String localName() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/annotate/package-info.java\n+/**\n+ * Package that contains additional annotations that can be\n+ * used to configure XML-specific aspects of serialization\n+ * and deserialization\n+ * \n+ * @since 1.7\n+ */\n+package com.fasterxml.jackson.xml.annotate;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/package-info.java\n+/**\n+ * Package that contains XML-based backends which can serialize POJOs\n+ * to and deserialize from XML, using Stax XML parsers and generators\n+ * for XML processing and mostly standard Jackson data binding otherwise.\n+ * \n+ * @since 1.6\n+ */\n+package com.fasterxml.jackson.xml;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/DefaultXmlPrettyPrinter.java\n+package com.fasterxml.jackson.xml.util;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.PrettyPrinter;\n+\n+import com.fasterxml.jackson.xml.ToXmlGenerator;\n+\n+/**\n+ * Indentation to use with XML is different from JSON, because JSON\n+ * requires use of separator characters and XML just basic whitespace.\n+ * \n+ * @since 1.7\n+ */\n+public class DefaultXmlPrettyPrinter\n+    implements PrettyPrinter\n+{\n+    /*\n+    /**********************************************************\n+    /* Root-level values\n+    /**********************************************************\n+     */\n+\n+    //@Override\n+    public void writeRootValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // Not sure if this should ever be applicable; but if multiple roots were allowed, we'd use linefeed\n+        jgen.writeRaw('\\n');\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Array values\n+    /**********************************************************\n+     */\n+    \n+    //@Override\n+    public void beforeArrayValues(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+\n+    //@Override\n+    public void writeStartArray(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+\n+    //@Override\n+    public void writeArrayValueSeparator(JsonGenerator jgen)  throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+\n+    //@Override\n+    public void writeEndArray(JsonGenerator jgen, int nrOfValues) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Object values\n+    /**********************************************************\n+     */\n+    \n+    //@Override\n+    public void beforeObjectEntries(JsonGenerator jg)  throws IOException, JsonGenerationException {\n+        // TODO Auto-generated method stub\n+    }\n+\n+    //@Override\n+    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        ((ToXmlGenerator) jgen)._handleStartObject();\n+    }\n+\n+    //@Override\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+\n+    //@Override\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+    \n+    //@Override\n+    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException {\n+        ((ToXmlGenerator) jgen)._handleEndObject();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/StaxUtil.java\n+package com.fasterxml.jackson.xml.util;\n+\n+import java.io.IOException;\n+\n+import javax.xml.stream.*;\n+\n+public class StaxUtil\n+{\n+    /**\n+     * Adapter method used when only IOExceptions are declared to be thrown, but\n+     * a {@link XMLStreamException} was caught.\n+     *<p>\n+     * Note: dummy type variable is used for convenience, to allow caller to claim\n+     * that this method returns result of any necessary type.\n+     */\n+    public static <T> T throwXmlAsIOException(XMLStreamException e) throws IOException\n+    {\n+        Throwable t = e;\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        if (t instanceof Error) throw (Error) t;\n+        if (t instanceof RuntimeException) throw (RuntimeException) t;\n+        throw new IOException(t);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/XmlRootNameLookup.java\n+package com.fasterxml.jackson.xml.util;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.MapperConfig;\n+import org.codehaus.jackson.map.introspect.AnnotatedClass;\n+import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n+import org.codehaus.jackson.map.type.ClassKey;\n+import org.codehaus.jackson.map.util.LRUMap;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.xml.XmlAnnotationIntrospector;\n+\n+/**\n+ * Helper class used for efficiently finding root element name used with\n+ * XML serializations.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlRootNameLookup\n+{\n+    /**\n+     * For efficient operation, let's try to minimize number of times we\n+     * need to introspect root element name to use.\n+     */\n+    protected final LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n+\n+    public XmlRootNameLookup() { }\n+\n+    public QName findRootName(JavaType rootType, MapperConfig<?> config)\n+    {\n+        return findRootName(rootType.getRawClass(), config);\n+    }\n+\n+    public QName findRootName(Class<?> rootType, MapperConfig<?> config)\n+    {\n+        ClassKey key = new ClassKey(rootType);\n+        QName name;\n+        synchronized (_rootNames) {\n+            name = _rootNames.get(key);\n+            if (name == null) {\n+                BasicBeanDescription beanDesc = (BasicBeanDescription) config.introspectClassAnnotations(rootType);\n+                AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+                AnnotatedClass ac = beanDesc.getClassInfo();\n+                String localName = intr.findRootName(ac);\n+                // No answer so far? Let's just default to using simple class name\n+                if (localName == null) {\n+                    // Should we strip out enclosing class tho? For now, nope:\n+                    localName = rootType.getSimpleName();\n+                    name = new QName(\"\", localName);\n+                } else {\n+                    // Otherwise let's see if there's namespace, too\n+                    String ns = findNamespace(intr, ac);\n+                    if (ns == null) { // some QName impls barf on nulls...\n+                        ns = \"\";\n+                    }\n+                    name = new QName(ns, localName);\n+                }\n+                _rootNames.put(key, name);\n+            }\n+        }\n+        return name;\n+    }\n+\n+    private String findNamespace(AnnotationIntrospector ai, AnnotatedClass ann)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(ann);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/XmlTokenStream.java\n+package com.fasterxml.jackson.xml.util;\n+\n+import java.io.IOException;\n+import javax.xml.stream.*;\n+\n+import org.codehaus.stax2.XMLStreamLocation2;\n+import org.codehaus.stax2.XMLStreamReader2;\n+import org.codehaus.stax2.ri.Stax2ReaderAdapter;\n+\n+import org.codehaus.jackson.JsonLocation;\n+\n+/**\n+ * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n+ * abstract out all irrelevant details, and to expose equivalent of flat token\n+ * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n+ * content) all of which is just to simplify\n+ * actual higher-level conversion to JSON tokens\n+ * \n+ * @since 1.7\n+ */\n+public class XmlTokenStream\n+{\n+    public final static int XML_START_ELEMENT = 1;\n+    public final static int XML_END_ELEMENT = 2;\n+    public final static int XML_ATTRIBUTE_NAME = 3;\n+    public final static int XML_ATTRIBUTE_VALUE = 4;\n+    public final static int XML_TEXT = 5;\n+    public final static int XML_END = 6;\n+\n+    /*\n+    /**********************************************************************\n+    /* Configuration\n+    /**********************************************************************\n+     */\n+\n+    final protected XMLStreamReader2 _xmlReader;\n+\n+    final protected Object _sourceReference;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Parsing state\n+    /**********************************************************************\n+     */\n+\n+    protected int _currentState;\n+\n+    protected int _attributeCount;\n+    \n+    /**\n+     * Index of the next attribute of the current START_ELEMENT\n+     * to return (as field name and value pair), if any; -1\n+     * when no attributes to return\n+     */\n+    protected int _nextAttributeIndex = 0;\n+\n+    protected String _localName;\n+\n+    protected String _namespaceURI;\n+\n+    protected String _textValue;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Life-cycle\n+    /**********************************************************************\n+     */\n+\n+    public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n+    {\n+        _sourceReference = sourceRef;\n+        // Let's ensure we point to START_ELEMENT...\n+        if (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\n+            throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+                    +XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n+        }\n+        _xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n+        _currentState = XML_START_ELEMENT;\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        _attributeCount = _xmlReader.getAttributeCount();\n+    }\n+\n+    public XMLStreamReader2 getXmlReader() {\n+        return _xmlReader;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Public API\n+    /**********************************************************************\n+     */\n+\n+    public int next() throws IOException \n+    {\n+        try {\n+            return _next();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    public void skipEndElement() throws IOException\n+    {\n+        try {\n+            int type = _next();\n+            if (type != XML_END_ELEMENT) {\n+                throw new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public int getCurrentToken() { return _currentState; }\n+\n+    public String getText() { return _textValue; }\n+    public String getLocalName() { return _localName; }\n+    public String getNamespaceURI() { return _namespaceURI; }\n+    public boolean hasAttributes() {\n+        return (_currentState == XML_START_ELEMENT) && (_attributeCount > 0);\n+    }\n+    \n+    public void closeCompletely() throws IOException\n+    {\n+        try {\n+            _xmlReader.closeCompletely();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public void close() throws IOException\n+    {\n+        try {\n+            _xmlReader.close();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public JsonLocation getCurrentLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getCurrentLocation());\n+    }\n+    public JsonLocation getTokenLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal methods, parsing\n+    /**********************************************************************\n+     */\n+\n+    private final int _next() throws XMLStreamException\n+    {\n+        switch (_currentState) {\n+        case XML_ATTRIBUTE_VALUE:\n+            ++_nextAttributeIndex;\n+            // fall through\n+        case XML_START_ELEMENT: // attributes to return?\n+            if (_nextAttributeIndex < _attributeCount) {\n+                _localName = _xmlReader.getAttributeLocalName(0);\n+                _namespaceURI = _xmlReader.getAttributeNamespace(0);\n+                _textValue = _xmlReader.getAttributeValue(0);\n+                return (_currentState = XML_ATTRIBUTE_NAME);\n+            }\n+            // otherwise need to find START/END_ELEMENT or text\n+            String text = _collectUntilTag();\n+            // If it's START_ELEMENT, ignore any text\n+            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n+                return _initStartElement();\n+            }\n+            // For END_ELEMENT we will return text, if any\n+            if (text != null) {\n+                _textValue = text;\n+                return (_currentState = XML_TEXT);\n+            }\n+            return (_currentState = XML_END_ELEMENT);\n+        case XML_ATTRIBUTE_NAME:\n+            // if we just returned name, will need to just send value next\n+            return (_currentState = XML_ATTRIBUTE_VALUE);\n+        case XML_TEXT:\n+            // text is always followed by END_ELEMENT\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+\n+        // Ok: must be END_ELEMENT; see what tag we get (or end)\n+        switch (_skipUntilTag()) {\n+        case XMLStreamConstants.END_DOCUMENT:\n+            return (_currentState = XML_END);\n+        case XMLStreamConstants.END_ELEMENT:\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+        // START_ELEMENT...\n+        return _initStartElement();\n+    }\n+    \n+    private final String _collectUntilTag() throws XMLStreamException\n+    {\n+        String text = null;\n+        while (true) {\n+            switch (_xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return text;\n+                // note: SPACE is ignorable (and seldom seen), not to be included\n+            case XMLStreamConstants.CHARACTERS:\n+            case XMLStreamConstants.CDATA:\n+                if (text == null) {\n+                    text = _xmlReader.getText();\n+                } else { // can be optimized in future, if need be:\n+                    text += _xmlReader.getText();\n+                }\n+                break;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+\n+    private final int _skipUntilTag() throws XMLStreamException\n+    {\n+        while (true) {\n+            int type;\n+            switch (type = _xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return type;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal methods, other\n+    /**********************************************************************\n+     */\n+    \n+    private final int _initStartElement() throws XMLStreamException\n+    {\n+        _nextAttributeIndex = 0;\n+        _attributeCount = _xmlReader.getAttributeCount();\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        return (_currentState = XML_START_ELEMENT);\n+    }\n+    \n+    private JsonLocation _extractLocation(XMLStreamLocation2 location)\n+    {\n+        if (location == null) { // just for impls that might pass null...\n+            return new JsonLocation(_sourceReference, -1, -1, -1);\n+        }\n+        return new JsonLocation(_sourceReference,\n+                location.getCharacterOffset(),\n+                location.getLineNumber(),\n+                location.getColumnNumber());\n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/xml/TestDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestDeserialization.java\n \n import java.util.List;\n \n-import org.codehaus.jackson.xml.XmlMapper;\n-import org.codehaus.jackson.xml.annotate.JacksonXmlProperty;\n+\n+import com.fasterxml.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.xml.annotate.JacksonXmlProperty;\n \n public class TestDeserialization extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestIndentation.java\n import java.util.*;\n \n import org.codehaus.jackson.map.SerializationConfig;\n-import org.codehaus.jackson.xml.XmlMapper;\n+\n+import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestIndentation extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n package com.fasterxml.jackson.xml;\n \n import org.codehaus.jackson.annotate.JsonTypeInfo;\n-import org.codehaus.jackson.xml.XmlMapper;\n+\n+import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestPolymorphic extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestSerialization.java\n import java.io.*;\n import java.util.*;\n \n-import org.codehaus.jackson.xml.XmlMapper;\n-import org.codehaus.jackson.xml.annotate.JacksonXmlElementWrapper;\n-import org.codehaus.jackson.xml.annotate.JacksonXmlProperty;\n+\n+import com.fasterxml.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.xml.annotate.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.xml.annotate.JacksonXmlProperty;\n \n public class TestSerialization extends XmlTestBase\n {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestWithJAXBAnnotations.java\n+package com.fasterxml.jackson.xml;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.introspect.JacksonAnnotationIntrospector;\n+import org.codehaus.jackson.xc.JaxbAnnotationIntrospector;\n+\n+/**\n+ * Although XML-backed data binding does not rely (or directly build) on JAXB\n+ * annotations, it should be possible to use them similar to how they are used\n+ * with default Jackson JSON data binding. Let's verify this is the case.\n+ */\n+public class TestWithJAXBAnnotations extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @XmlRootElement(name=\"bean\")\n+    public static class SimpleBean\n+    {\n+        public String value = \"text\";\n+        \n+        @XmlAttribute\n+        public String attr = \"3\";\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleSerialize() throws Exception\n+    {\n+        XmlMapper mapper = getJaxbAndJacksonMapper();\n+        String xml = mapper.writeValueAsString(new SimpleBean());\n+        assertEquals(\"<bean attr=\\\"3\\\"><value>text</value></bean>\", xml);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper getJaxbAndJacksonMapper()\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        AnnotationIntrospector intr = new AnnotationIntrospector.Pair(new JaxbAnnotationIntrospector(),\n+                        new JacksonAnnotationIntrospector());\n+        mapper.getDeserializationConfig().setAnnotationIntrospector(intr);\n+        mapper.getSerializationConfig().setAnnotationIntrospector(intr);\n+        return mapper;\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n package com.fasterxml.jackson.xml;\n \n-import org.codehaus.jackson.xml.ToXmlGenerator;\n-import org.codehaus.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.xml.ToXmlGenerator;\n+import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestXmlDeclaration extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n \n import javax.xml.namespace.QName;\n \n-import org.codehaus.jackson.xml.ToXmlGenerator;\n-import org.codehaus.jackson.xml.XmlFactory;\n+import com.fasterxml.jackson.xml.ToXmlGenerator;\n+import com.fasterxml.jackson.xml.XmlFactory;\n \n public class TestXmlGenerator extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n \n import org.codehaus.jackson.*;\n import org.codehaus.jackson.map.ObjectMapper;\n-import org.codehaus.jackson.xml.FromXmlParser;\n-import org.codehaus.jackson.xml.XmlFactory;\n-import org.codehaus.jackson.xml.XmlMapper;\n+\n+import com.fasterxml.jackson.xml.FromXmlParser;\n+import com.fasterxml.jackson.xml.XmlFactory;\n+import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestXmlParser extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlTokenStream.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlTokenStream.java\n \n import javax.xml.stream.*;\n \n-import org.codehaus.jackson.xml.util.XmlTokenStream;\n+import com.fasterxml.jackson.xml.util.XmlTokenStream;\n \n public class TestXmlTokenStream extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/XmlTestBase.java\n package com.fasterxml.jackson.xml;\n \n import java.io.IOException;\n+\n+import junit.framework.TestCase;\n \n import org.codehaus.jackson.JsonParseException;\n import org.codehaus.jackson.JsonParser;\n import org.codehaus.jackson.JsonToken;\n-\n-import junit.framework.TestCase;\n \n public abstract class XmlTestBase\n     extends TestCase", "timestamp": 1293776557, "metainfo": ""}