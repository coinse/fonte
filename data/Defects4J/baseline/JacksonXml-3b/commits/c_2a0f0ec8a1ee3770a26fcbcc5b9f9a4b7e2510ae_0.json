{"sha": "2a0f0ec8a1ee3770a26fcbcc5b9f9a4b7e2510ae", "log": "Merge branch '2.5'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n  *<p>\n  * Mapper itself overrides some aspects of functionality to try to handle\n  * data binding aspects as similar to JAXB as possible.\n+ *<p>\n+ * Note that most of configuration should be done by pre-constructing\n+ * {@link JacksonXmlModule} explicitly, instead of relying on default settings.\n  */\n public class XmlMapper extends ObjectMapper\n {\n-    // as of 2.5\n-    private static final long serialVersionUID = -1212805483143619605L;\n+    // as of 2.6\n+    private static final long serialVersionUID = 1L;\n \n     protected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n     \n     // need to hold on to module instance just in case copy() is used\n     protected final JacksonXmlModule _xmlModule;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: construction, configuration\n \n     /**\n      * Method called by {@link JacksonXmlModule} to pass configuration\n-     * information to {@link XmlFactory}, during registration.\n+     * information to {@link XmlFactory}, during registration; NOT\n+     * exposed as public method since configuration should be done\n+     * via {@link JacksonXmlModule}.\n      * \n      * @since 2.1\n      */\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n         JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n         */\n \n-        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property);\n+        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n         BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n         \n         // Let's go through the properties now...\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n \n         final boolean _defaultState;\n         final int _mask;\n-        \n+\n         /**\n          * Method that calculates bit set (flags) of all features that\n          * are enabled by default.\n             }\n             return flags;\n         }\n-        \n+\n         private Feature(boolean defaultState) {\n             _defaultState = defaultState;\n             _mask = (1 << ordinal());\n         }\n-        \n+\n         public boolean enabledByDefault() { return _defaultState; }\n         public int getMask() { return _mask; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration\n      * Method called before writing any other output, to optionally\n      * output XML declaration.\n      */\n-    public void initGenerator()  throws IOException, JsonGenerationException\n+    public void initGenerator()  throws IOException\n     {\n         if (_initialized) {\n             return;\n      * @param wrappedName Element used around individual content items (can not\n      *   be null)\n      */\n-    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n     {\n         if (wrapperName != null) {\n             try {\n     /**\n      * Method called after a structured collection output has completed\n      */\n-    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n     {\n         // First: wrapper to close?\n         if (wrapperName != null) {\n      * \n      * @since 2.2\n      */\n-    public void writeRepeatedFieldName() throws IOException, JsonGenerationException\n+    public void writeRepeatedFieldName() throws IOException\n     {\n         if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n             _reportError(\"Can not write a field name, expecting a value\");\n      */\n \n     @Override\n-    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    public final void writeFieldName(String name)  throws IOException\n     {\n         if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n             _reportError(\"Can not write a field name, expecting a value\");\n     }\n     \n     @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n+    public final void writeStringField(String fieldName, String value) throws IOException\n     {\n         writeFieldName(fieldName);\n         writeString(value);\n      */\n \n     @Override\n-    public final void writeStartArray() throws IOException, JsonGenerationException\n+    public final void writeStartArray() throws IOException\n     {\n         _verifyValueWrite(\"start an array\");\n         _writeContext = _writeContext.createChildArrayContext();\n     }\n     \n     @Override\n-    public final void writeEndArray() throws IOException, JsonGenerationException\n+    public final void writeEndArray() throws IOException\n     {\n         if (!_writeContext.inArray()) {\n             _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n     }\n \n     @Override\n-    public final void writeStartObject() throws IOException, JsonGenerationException\n+    public final void writeStartObject() throws IOException\n     {\n         _verifyValueWrite(\"start an object\");\n         _writeContext = _writeContext.createChildObjectContext();\n     }\n \n     @Override\n-    public final void writeEndObject() throws IOException, JsonGenerationException\n+    public final void writeEndObject() throws IOException\n     {\n         if (!_writeContext.inObject()) {\n             _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n     }\n \n     // note: public just because pretty printer needs to make a callback\n-    public final void _handleStartObject() throws IOException, JsonGenerationException\n+    public final void _handleStartObject() throws IOException\n     {\n         if (_nextName == null) {\n             handleMissingName();\n     }\n     \n     // note: public just because pretty printer needs to make a callback\n-    public final void _handleEndObject() throws IOException, JsonGenerationException\n+    public final void _handleEndObject() throws IOException\n     {\n         // We may want to repeat same element, so:\n         if (_elementNameStack.isEmpty()) {\n      */\n \n     @Override\n-    public void writeFieldName(SerializableString name)\n-        throws IOException, JsonGenerationException\n+    public void writeFieldName(SerializableString name) throws IOException\n     {\n         writeFieldName(name.getValue());\n     }\n     \n     @Override\n-    public void writeString(String text) throws IOException,JsonGenerationException\n+    public void writeString(String text) throws IOException\n     {\n         _verifyValueWrite(\"write String value\");\n         if (_nextName == null) {\n     }    \n     \n     @Override\n-    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    public void writeString(char[] text, int offset, int len) throws IOException\n     {\n         _verifyValueWrite(\"write String value\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+    public void writeString(SerializableString text) throws IOException {\n         writeString(text.getValue());\n     }\n     \n     @Override\n-    public void writeRawUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n         // could add support for this case if we really want it (and can make Stax2 support it)\n         _reportUnsupportedOperation();\n     }\n \n     @Override\n-    public void writeUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n         // could add support for this case if we really want it (and can make Stax2 support it)\n         _reportUnsupportedOperation();\n      */\n \n     @Override\n-    public void writeRaw(String text) throws IOException, JsonGenerationException\n+    public void writeRaw(String text) throws IOException\n     {\n         // [Issue#39]\n         if (_stax2Emulation) {\n     }\n \n     @Override\n-    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException\n+    public void writeRaw(String text, int offset, int len) throws IOException\n     {\n         // [Issue#39]\n         if (_stax2Emulation) {\n     }\n \n     @Override\n-    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    public void writeRaw(char[] text, int offset, int len) throws IOException\n     {\n         // [Issue#39]\n         if (_stax2Emulation) {\n     }\n \n     @Override\n-    public void writeRaw(char c) throws IOException, JsonGenerationException\n+    public void writeRaw(char c) throws IOException\n     {\n         writeRaw(String.valueOf(c));\n     }\n \n     @Override\n     public void writeBinary(Base64Variant b64variant,\n-    \t\tbyte[] data, int offset, int len)\n-        throws IOException, JsonGenerationException\n+    \t\tbyte[] data, int offset, int len) throws IOException\n     {\n         if (data == null) {\n             writeNull();\n      */\n \n     @Override\n-    public void writeBoolean(boolean value) throws IOException, JsonGenerationException\n+    public void writeBoolean(boolean value) throws IOException\n     {\n         _verifyValueWrite(\"write boolean value\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNull() throws IOException, JsonGenerationException\n+    public void writeNull() throws IOException\n     {\n         _verifyValueWrite(\"write null value\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNumber(int i) throws IOException, JsonGenerationException\n+    public void writeNumber(int i) throws IOException\n     {\n         _verifyValueWrite(\"write number\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNumber(long l) throws IOException, JsonGenerationException\n+    public void writeNumber(long l) throws IOException\n     {\n         _verifyValueWrite(\"write number\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNumber(double d) throws IOException, JsonGenerationException\n+    public void writeNumber(double d) throws IOException\n     {\n         _verifyValueWrite(\"write number\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNumber(float f) throws IOException, JsonGenerationException\n+    public void writeNumber(float f) throws IOException\n     {\n         _verifyValueWrite(\"write number\");\n         if (_nextName == null) {\n     }\n \n     @Override\n-    public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException\n+    public void writeNumber(BigDecimal dec) throws IOException\n     {\n         if (dec == null) {\n             writeNull();\n     }\n \n     @Override\n-    public void writeNumber(BigInteger value)\n-\t\tthrows IOException, JsonGenerationException\n+    public void writeNumber(BigInteger value) throws IOException\n     {\n         if (value == null) {\n             writeNull();\n      */\n     \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyValueWrite(String typeMsg) throws IOException\n     {\n         int status = _writeContext.writeValue();\n         if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n     /**\n      * Standard JSON indenter does not work well with XML, use\n      * default XML indenter instead.\n+     *<p>\n+     * !!! TODO: same as implementation in core 2.6; override may be\n+     * removed from 2.7\n      */\n     @Override\n     public final JsonGenerator useDefaultPrettyPrinter()\n         if (_cfgPrettyPrinter != null) {\n             return this;\n         }\n-        return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n+        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n+    }\n+\n+    @Override\n+    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n+        return new DefaultXmlPrettyPrinter();\n     }\n \n     @Override\n         \t\t(XmlPrettyPrinter) pp : null;\n         return this;\n     }\n-    \n+\n+\n     /*\n     /**********************************************************\n     /* Low-level output handling\n      */\n \n     @Override\n-    public final void flush() throws IOException\n+    public void flush() throws IOException\n     {\n         if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n             try {\n         return false;\n     }\n     \n-    protected void handleMissingName()\n-    {\n+    protected void handleMissingName() {\n         throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n     // Verify [JACKSON-444], Issue #1\n     public void testSimpleStringBean() throws Exception\n     {\n-        String xml = _xmlMapper.writeValueAsString(new StringWrapperBean(\"abc\")); \n+        StringWrapperBean input = new StringWrapperBean(\"abc\");\n+        String xml = _xmlMapper.writeValueAsString(input); \n+\n         // should have at least one linefeed, space...\n         if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n-        \tfail(\"No indentation: XML == \"+xml);\n+            fail(\"No indentation: XML == \"+xml);\n         }\n         // Let's verify we get similar stuff back, first:\n         StringWrapperBean result = _xmlMapper.readValue(xml, StringWrapperBean.class);\n         assertNotNull(result);\n         assertEquals(\"abc\", result.string.str);\n \n+        // Try via ObjectWriter as well\n+        xml = _xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(input);\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+            fail(\"No indentation: XML == \"+xml);\n+        }\n+        result = _xmlMapper.readValue(xml, StringWrapperBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.string.str);\n     }\n \n     public void testSimpleIntBean() throws Exception", "timestamp": 1429925877, "metainfo": ""}