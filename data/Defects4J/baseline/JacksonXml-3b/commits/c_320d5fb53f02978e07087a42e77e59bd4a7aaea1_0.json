{"sha": "320d5fb53f02978e07087a42e77e59bd4a7aaea1", "log": "Fixes to handling of unwrapped Lists; only one test fail to go", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n      */\n     public void addVirtualWrapping(Set<String> namesToWrap)\n     {\n+//System.out.println(\"AddWraps: \"+namesToWrap+\" (current name=\"+_parsingContext.getCurrentName()+\")\");        \n+\n+        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n+         *   problems with Lists-in-Lists properties\n+         */\n+        String name = _xmlTokens.getLocalName();\n+        if (name != null && namesToWrap.contains(name)) {\n+//System.out.println(\"!!! AddWraps matches CURRENT name... flash repeat; nextToken=\"+_nextToken);\n+            _xmlTokens.repeatStartElement();\n+        }\n         _namesToWrap = namesToWrap;\n         _parsingContext.setNamesToWrap(namesToWrap);\n     }\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-395]: start markers require information from parent\n+        String name;\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n             XmlReadContext parent = _parsingContext.getParent();\n-            return parent.getCurrentName();\n-        }\n-        return _parsingContext.getCurrentName();\n+            name = parent.getCurrentName();\n+        } else {\n+            name = _parsingContext.getCurrentName();\n+        }\n+        // sanity check\n+        if (name == null) {\n+            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n+        }\n+        return name;\n     }\n \n     @Override\n      * 'start object'.\n      */\n     @Override\n-    public boolean isExpectedStartArrayToken() {\n+    public boolean isExpectedStartArrayToken()\n+    {\n         JsonToken t = _currToken;\n         if (t == JsonToken.START_OBJECT) {        \t\n             _currToken = JsonToken.START_ARRAY;\n             // Ok: must replace current context with array as well\n             _parsingContext.convertToArray();\n+//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n             // And just in case a field name was to be returned, wipe it\n             _nextToken = null;\n             // and last thing, [Issue#33], better ignore attributes\n             _xmlTokens.skipAttributes();\n             return true;\n         }\n+//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n         return (t == JsonToken.START_ARRAY);\n     }\n \n-    /*\n     // DEBUGGING\n+    /*\n     @Override\n     public JsonToken nextToken() throws IOException, JsonParseException\n     {\n         JsonToken t = nextToken0();\n-        switch (t) {\n-        case FIELD_NAME:\n-            System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n-            break;\n-        case VALUE_STRING:\n-            System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n-            break;\n-        default:\n-            System.out.println(\"JsonToken: \"+t);\n+        if (t != null) {\n+            switch (t) {\n+            case FIELD_NAME:\n+                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n+                break;\n+            case VALUE_STRING:\n+                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n+                break;\n+            default:\n+                System.out.println(\"JsonToken: \"+t);\n+            }\n         }\n         return t;\n     } \n          * a start-element that indicates an array element.\n          */\n         while (token == XmlTokenStream.XML_START_ELEMENT) {\n-\n             // If we thought we might get leaf, no such luck\n             if (_mayBeLeaf) {\n+//System.out.println(\"In mayBeLeaf (array? \"+_parsingContext.inArray()+\"): add START_OBJECT (\"+_xmlTokens.getLocalName()+\"), append FIELD_NAME\");\n                 // leave _mayBeLeaf set, as we start a new context\n                 _nextToken = JsonToken.FIELD_NAME;\n                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                 return (_currToken = JsonToken.START_OBJECT);\n             }\n             if (_parsingContext.inArray()) {\n+//System.out.println(\"In ARRAY: skip field '\"+_xmlTokens.getLocalName());\n                 /* Yup: in array, so this element could be verified; but it won't be reported\n                  * anyway, and we need to process following event.\n                  */\n                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                 return (_currToken = JsonToken.START_OBJECT);\n             }\n-            _mayBeLeaf = false;\n             _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n             return (_currToken = JsonToken.FIELD_NAME);\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n  */\n public class XmlTokenStream\n {\n+    // // // main token states:\n+    \n     public final static int XML_START_ELEMENT = 1;\n     public final static int XML_END_ELEMENT = 2;\n     public final static int XML_ATTRIBUTE_NAME = 3;\n     public final static int XML_TEXT = 5;\n     public final static int XML_END = 6;\n \n+    // // // token replay states\n+\n+    private final static int REPLAY_START_DUP = 1;\n+    private final static int REPLAY_END = 2;\n+    private final static int REPLAY_START_DELAYED = 3;\n+    \n     /*\n     /**********************************************************************\n     /* Configuration\n     protected String _namespaceURI;\n \n     protected String _textValue;\n-\n+    \n     /*\n     /**********************************************************************\n     /* State for handling virtual wrapping\n      */\n     \n     /**\n-     * Status flag used to \"replay\" current event\n-     */\n-    protected boolean _repeatElement;\n+     * Flag used to indicate that given element should be \"replayed\".\n+     */\n+    protected int _repeatElement;\n \n     /**\n      * Wrapping state, if any active (null if none)\n      */\n     protected ElementWrapper _currentWrapper;\n+\n+    /**\n+     * In cases where we need to 'inject' a virtual END_ELEMENT, we may also\n+     * need to restore START_ELEMENT afterwards; if so, this is where names\n+     * are held.\n+     */\n+    protected String _nextLocalName;\n+    protected String _nextNamespaceURI;\n     \n     /*\n     /**********************************************************************\n             System.out.println(\" XML-token: XML_TEXT '\"+_textValue+\"'\");\n             break;\n         case XML_END: \n+            System.out.println(\" XML-token: XML_END\");\n+            break;\n         default:\n             throw new IllegalStateException();\n         }\n     }\n     */\n     \n-    public int next () throws IOException \n-    {\n-        if (_repeatElement) {\n+    public int next() throws IOException \n+    {\n+        if (_repeatElement != 0) {\n             return _handleRepeatElement();\n         }\n         try {\n                     +XML_START_ELEMENT+\") but \"+_currentState);\n         }\n         // Important: add wrapper, to keep track...\n-        _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n-        _repeatElement = true;\n+        if (_currentWrapper == null) {\n+            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n+        } else {\n+            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n+        }\n+        _repeatElement = REPLAY_START_DUP;\n     }\n \n     /**\n             } else {\n                 // implicit end is more interesting:\n                 _localName = _currentWrapper.getWrapperLocalName();\n+                _namespaceURI = _currentWrapper.getWrapperNamespace();\n                 _currentWrapper = _currentWrapper.getParent();\n+//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n+                // Important! We also need to restore the START_ELEMENT, so:\n+                _nextLocalName = localName;\n+                _nextNamespaceURI = ns;\n+                _repeatElement = REPLAY_START_DELAYED;\n                 return (_currentState = XML_END_ELEMENT);\n             }\n         }\n      */\n     protected int _handleRepeatElement() throws IOException \n     {\n-        _repeatElement = false;\n-        if (_currentState == XML_START_ELEMENT) {\n+        int type = _repeatElement;\n+        _repeatElement = 0;\n+        if (type == REPLAY_START_DUP) {\n+//System.out.println(\"handleRepeat for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n             // important: add the virtual element second time, but not with name to match\n             _currentWrapper = _currentWrapper.intermediateWrapper();\n-        } else if (_currentState == XML_END_ELEMENT) {\n+            return XML_START_ELEMENT;\n+        }\n+        if (type == REPLAY_END) {\n+//System.out.println(\"handleRepeat for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n             _localName = _xmlReader.getLocalName();\n             _namespaceURI = _xmlReader.getNamespaceURI();\n-        }\n-        return _currentState;\n+            return XML_END_ELEMENT;\n+        }\n+        if (type == REPLAY_START_DELAYED) {\n+            _currentWrapper = _currentWrapper.intermediateWrapper();\n+            _localName = _nextLocalName;\n+            _namespaceURI = _nextNamespaceURI;\n+            _nextLocalName = null;\n+            _nextNamespaceURI = null;\n+            \n+//System.out.println(\"handleRepeat for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n+\n+            return XML_START_ELEMENT;\n+        }\n+        throw new IllegalStateException(\"Unrecognized type to repeat: \"+type);\n     }\n     \n     private final int _handleEndElement()\n             ElementWrapper w = _currentWrapper;\n             // important: if we close the scope, must duplicate END_ELEMENT as well\n             if (w.isMatching()) {\n-                _repeatElement = true;\n+                _repeatElement = REPLAY_END;\n                 _localName = w.getWrapperLocalName();\n                 _namespaceURI = w.getWrapperNamespace();\n+//System.out.println(\" requestRepeat of END_ELEMENT '\"+_localName);\n             } else {\n                 _currentWrapper = _currentWrapper.getParent();\n             }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/unwrapped/TestNestedUnwrappedLists.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/unwrapped/TestNestedUnwrappedLists.java\n         \n         ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n         assertNotNull(svc);\n+        assertEquals(\"2012-09-12T09:28:17.213-04:00\", svc.responseTimestamp);\n         assertNotNull(svc.vehicleMonitoringDelivery);\n         assertEquals(2, svc.vehicleMonitoringDelivery.size());\n         VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(1);", "timestamp": 1347913333, "metainfo": ""}