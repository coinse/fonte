{"sha": "5da9f1f0a4495f9ad46484756653bbccda3224fb", "log": "...", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestDeserialization.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.util.List;\n+\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlProperty;\n+\n+public class TestDeserialization extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class AttributeBean\n+    {\n+        @JacksonXmlProperty(isAttribute=true, localName=\"attr\")\n+        public String text = \"?\";\n+    }\n+\n+    static class ListBean\n+    {\n+        public List<Integer> values;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Unit test to ensure that we can succesfully also roundtrip\n+     * example Bean used in Jackson tutorial\n+     */\n+    public void testRoundTripWithJacksonExample() throws Exception\n+    {\n+        FiveMinuteUser user = new FiveMinuteUser(\"Joe\", \"Sixpack\",\n+                true, FiveMinuteUser.Gender.MALE, new byte[] { 1, 2, 3 , 4, 5 });\n+        XmlMapper mapper = new XmlMapper();\n+        String xml = mapper.writeValueAsString(user);\n+        FiveMinuteUser result = mapper.readValue(xml, FiveMinuteUser.class);\n+        assertEquals(user, result);\n+    }\n+\n+    public void testFromAttribute() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        AttributeBean bean = mapper.readValue(\"<AttributeBean attr=\\\"abc\\\"></AttributeBean>\", AttributeBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"abc\", bean.text);\n+    }\n+\n+    public void testListBean() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        ListBean bean = mapper.readValue(\n+                \"<ListBean><values><values>1</values><values>2</values><values>3</values></values></ListBean>\",\n+                ListBean.class);\n+        assertNotNull(bean);\n+        assertNotNull(bean.values);\n+        assertEquals(3, bean.values.size());\n+        assertEquals(Integer.valueOf(1), bean.values.get(0));\n+        assertEquals(Integer.valueOf(2), bean.values.get(1));\n+        assertEquals(Integer.valueOf(3), bean.values.get(2));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestEnums.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+\n+public class TestEnums extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static enum TestEnum { A, B, C; }\n+\n+    static class EnumBean\n+    {\n+        public TestEnum value;\n+\n+        public EnumBean() { }\n+        public EnumBean(TestEnum v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testEnum() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        String str = mapper.writeValueAsString(new EnumBean(TestEnum.B));\n+        EnumBean result = mapper.readValue(str, EnumBean.class);\n+        assertNotNull(result);\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestIndentation.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+\n+\n+public class TestIndentation extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class Bean {\n+        public StringWrapper string;\n+        \n+        public Bean() { }\n+        public Bean(String s) { string = new StringWrapper(s); }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+        _xmlMapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Verify [JACKSON-444]\n+    public void testSimpleBean() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new Bean(\"abc\")); \n+//System.out.println(\"XML = \"+xml);\n+\n+        // Let's verify we get similar stuff back, first:\n+        Bean result = _xmlMapper.readValue(xml, Bean.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.string.str);\n+\n+    }\n+\n+    public void testSimpleMap() throws Exception\n+    {\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(\"a\", \"b\");\n+        String xml = _xmlMapper.writeValueAsString(map);\n+\n+        // Let's verify we get similar stuff back, first:\n+        Map<?,?> result = _xmlMapper.readValue(xml, Map.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(\"b\", map.get(\"a\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestPolymorphic.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+\n+\n+public class TestPolymorphic extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class BaseTypeWithClassProperty { }\n+\n+    static class SubTypeWithClassProperty extends BaseTypeWithClassProperty {\n+        public String name;\n+\n+        public SubTypeWithClassProperty() { }\n+        public SubTypeWithClassProperty(String s) { name = s; }\n+    }\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+    static class BaseTypeWithClassArray { }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    private static class BaseTypeWithClassObject { }\n+\n+    protected static class SubTypeWithClassObject extends BaseTypeWithClassObject {\n+        public String name;\n+    \n+        public SubTypeWithClassObject() { }\n+        public SubTypeWithClassObject(String s) { name = s; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAsClassProperty() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassProperty(\"Foobar\"));\n+\n+        // Type info should be written as an attribute, so:\n+        /* 08-Jan-2010, tatu: Alas, the simplest way to implement support requires a change\n+         *   to Jackson (since BeanSerializer.serializeWithType() is final; shouldn't be!).\n+         *   Need to wait...\n+         */\n+        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n+         *   inclusion, which allows use of attribute over element, so:\n+         */\n+        final String exp = \n+            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.xml.TestPolymorphic..SubTypeWithClassProperty\\\">\"\n+            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n+            +\"<name>Foobar</name></SubTypeWithClassProperty>\"\n+                ;\n+        assertEquals(exp, xml);\n+        \n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassProperty.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassProperty.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassProperty) result).name);\n+    }\n+        \n+    public void testAsClassObject() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassObject(\"Foobar\"));\n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassObject.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassObject.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassObject) result).name);\n+    }\n+}\n+   \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestSerialization.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlRootElement;\n+\n+public class TestSerialization extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class StringBean2\n+    {\n+        public String text = \"foobar\";\n+    }\n+\n+    static class AttributeBean\n+    {\n+        @JacksonXmlProperty(isAttribute=true, localName=\"attr\")\n+        public String text = \"something\";\n+    }\n+\n+    static class AttrAndElem\n+    {\n+        public String elem = \"whatever\";\n+        \n+        @JacksonXmlProperty(isAttribute=true, localName=\"id\")\n+        public int attr = 42;\n+    }\n+\n+    static class ListBean\n+    {\n+        public final List<Integer> values = new ArrayList<Integer>();\n+\n+        public ListBean() { }\n+        public ListBean(int... ints) {\n+            for (int i : ints) {\n+                values.add(Integer.valueOf(i));\n+            }\n+        }\n+    }\n+\n+    static class WrapperBean<T>\n+    {\n+        public T value;\n+\n+        public WrapperBean() { }\n+        public WrapperBean(T v) { value = v; }\n+    }\n+\n+    static class MapBean\n+    {\n+        public Map<String,Integer> map;\n+\n+        public MapBean() { }\n+        public MapBean(Map<String,Integer> v) { map = v; }\n+    }\n+    \n+    static class StringListBean\n+    {\n+        // to see what JAXB gives, uncomment:\n+        //@javax.xml.bind.annotation.XmlElementWrapper(name=\"stringList\")\n+        @JacksonXmlElementWrapper(localName=\"stringList\")\n+        public List<StringBean> strings;\n+        \n+        public StringListBean() { strings = new ArrayList<StringBean>(); }\n+        public StringListBean(String... texts)\n+        {\n+            strings = new ArrayList<StringBean>();\n+            for (String text : texts) {\n+                strings.add(new StringBean(text));\n+            }\n+        }\n+    }\n+    \n+    static class NsElemBean\n+    {\n+        @JacksonXmlProperty(namespace=\"http://foo\")\n+        public String text = \"blah\";\n+    }\n+\n+    static class NsAttrBean\n+    {\n+        @JacksonXmlProperty(namespace=\"http://foo\", isAttribute=true)\n+        public String attr = \"3\";\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"root\")\n+    static class RootBean\n+    {\n+        public String value = \"123\";\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"nsRoot\", namespace=\"http://foo\")\n+    static class NsRootBean\n+    {\n+        public String value = \"abc\";\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Unit test to verify that root name is properly set\n+    public void testRootName() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new StringBean());\n+        \n+        // Hmmh. Looks like JDK Stax may adds bogus ns declaration. As such,\n+        // let's just check that name starts ok...\n+        if (!xml.startsWith(\"<StringBean\")) {\n+            fail(\"Expected root name of 'StringBean'; but XML document is [\"+xml+\"]\");\n+        }\n+\n+        // and then see that basic non-namespace root is ok\n+        xml = _xmlMapper.writeValueAsString(new RootBean());\n+        assertEquals(\"<root><value>123</value></root>\", xml);\n+\n+        // and namespace one too\n+        xml = _xmlMapper.writeValueAsString(new NsRootBean());\n+        if (xml.indexOf(\"nsRoot\") < 0) { // verify localName\n+            fail(\"Expected root name of 'nsRoot'; but XML document is [\"+xml+\"]\");\n+        }\n+        // and NS declaration\n+        if (xml.indexOf(\"http://foo\") < 0) {\n+            fail(\"Expected NS declaration for 'http://foo', not found, XML document is [\"+xml+\"]\");\n+        }\n+    }\n+    \n+    public void testSimpleAttribute() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttributeBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<AttributeBean attr=\\\"something\\\"/>\", xml);\n+    }\n+\n+    public void testSimpleAttrAndElem() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttrAndElem());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<AttrAndElem id=\\\"42\\\"><elem>whatever</elem></AttrAndElem>\", xml);\n+    }\n+\n+    public void testSimpleNsElem() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new NsElemBean());\n+        xml = removeSjsxpNamespace(xml);\n+        // here we assume woodstox automatic prefixes, not very robust but:\n+        assertEquals(\"<NsElemBean><wstxns1:text xmlns:wstxns1=\\\"http://foo\\\">blah</wstxns1:text></NsElemBean>\", xml);\n+    }\n+\n+    public void testSimpleNsAttr() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new NsAttrBean());\n+        xml = removeSjsxpNamespace(xml);\n+        // here we assume woodstox automatic prefixes, not very robust but:\n+        assertEquals(\"<NsAttrBean xmlns:wstxns1=\\\"http://foo\\\" wstxns1:attr=\\\"3\\\"/>\", xml);\n+    }\n+    \n+    public void testSimpleList() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new ListBean(1, 2, 3));\n+        xml = removeSjsxpNamespace(xml);\n+        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper...\n+        assertEquals(\"<ListBean><values><values>1</values><values>2</values><values>3</values></values></ListBean>\", xml);\n+    }\n+\n+    public void testStringList() throws IOException\n+    {\n+        StringListBean list = new StringListBean(\"a\", \"b\", \"c\");\n+        String xml = _xmlMapper.writeValueAsString(list);\n+        xml = removeSjsxpNamespace(xml);\n+        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper... but it's what we have now\n+        assertEquals(\"<StringListBean><stringList>\"\n+                +\"<strings><text>a</text></strings>\"\n+                +\"<strings><text>b</text></strings>\"\n+                +\"<strings><text>c</text></strings>\"\n+                +\"</stringList></StringListBean>\", xml);\n+    }\n+\n+    public void testMap() throws IOException\n+    {\n+        // First, map in a general wrapper\n+        LinkedHashMap<String,Integer> map = new LinkedHashMap<String,Integer>();\n+        map.put(\"a\", 1);\n+        map.put(\"b\", 2);\n+\n+        String xml;\n+        \n+        xml = _xmlMapper.writeValueAsString(new WrapperBean<Map<?,?>>(map));\n+        assertEquals(\"<WrapperBean><value>\"\n+                +\"<a>1</a>\"\n+                +\"<b>2</b>\"\n+                +\"</value></WrapperBean>\",\n+                xml);\n+\n+        // then as strongly typed\n+        xml = _xmlMapper.writeValueAsString(new MapBean(map));\n+        assertEquals(\"<MapBean><map>\"\n+                +\"<a>1</a>\"\n+                +\"<b>2</b>\"\n+                +\"</map></MapBean>\",\n+                xml);\n+    }\n+    \n+    // manual 'test' to see \"what would JAXB do?\"\n+    /*\n+    public void testJAXB() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        javax.xml.bind.JAXB.marshal(new StringListBean(\"a\", \"b\", \"c\"), sw);\n+        System.out.println(\"JAXB -> \"+sw);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestVersions.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.Versioned;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+\n+\n+public class TestVersions extends XmlTestBase\n+{\n+    /**\n+     * Not a good to do this, but has to do, for now...\n+     */\n+    private final static int MAJOR_VERSION = 2;\n+    private final static int MINOR_VERSION = 0;\n+\n+    // could inject using Maven filters as well...\n+    private final static String GROUP_ID = \"com.fasterxml.jackson.datatype\";\n+    private final static String ARTIFACT_ID = \"jackson-datatype-hibernate\";\n+    \n+    public void testMapperVersions()\n+    {\n+        assertVersion(new XmlMapper());\n+        assertVersion(new XmlFactory());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void assertVersion(Versioned vers)\n+    {\n+        final Version v = vers.version();\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertEquals(MAJOR_VERSION, v.getMajorVersion());\n+        assertEquals(MINOR_VERSION, v.getMinorVersion());\n+        // Check patch level initially, comment out for maint versions\n+        assertEquals(0, v.getPatchLevel());\n+        assertEquals(GROUP_ID, v.getGroupId());\n+        assertEquals(ARTIFACT_ID, v.getArtifactId());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestViews.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+\n+public class TestViews extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class RestrictedView { };\n+\n+    static class Foo\n+    {\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public String restrictedFooProperty;\n+\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public Bar[] bars;\n+    }\n+\n+    static class Bar\n+    {\n+        @JsonView(RestrictedView.class)\n+        @JsonProperty\n+        public int restrictedBarProperty;\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testIssue7() throws Exception\n+    {\n+        Foo foo = new Foo();\n+        foo.restrictedFooProperty = \"test\";\n+\n+        Bar bar1 = new Bar();\n+        bar1.restrictedBarProperty = 10;\n+\n+        Bar bar2 = new Bar();\n+        bar2.restrictedBarProperty = 11;\n+\n+        foo.bars = new Bar[] { bar1, bar2 };\n+\n+        ObjectMapper xmlMapper = new XmlMapper();\n+\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_FIELDS, false );\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false );\n+        xmlMapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false );\n+        xmlMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n+\n+        String xml = xmlMapper.writerWithView(RestrictedView.class).writeValueAsString(foo);\n+\n+        // views not used for deserialization\n+        Foo result = xmlMapper.readValue(xml, Foo.class);\n+        assertEquals(\"test\", result.restrictedFooProperty);\n+        assertNotNull(result.bars);\n+        assertEquals(2, result.bars.length);\n+        assertEquals(10, result.bars[0].restrictedBarProperty);\n+        assertEquals(11, result.bars[1].restrictedBarProperty);\n+        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXMLFormatDetection.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.ByteArrayInputStream;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+\n+public class TestXMLFormatDetection extends XmlTestBase\n+{\n+    public void testSimpleValidXmlDecl() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?xml version='1.0'?><root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidRoot() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidDoctype() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<!DOCTYPE root [ ]>   <root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleValidComment() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"  <!-- comment -->  <root></root>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidPI() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?target foo?><root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleInvalid() throws Exception\n+    {\n+        DataFormatDetector detector = new DataFormatDetector(new XmlFactory());\n+        final String NON_XML = \"{\\\"foo\\\":\\\"bar\\\"}\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_XML.getBytes(\"UTF-8\")));\n+        // should not have match\n+        assertFalse(matcher.hasMatch());\n+        // and thus:\n+        assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength());\n+        // also:\n+        assertNull(matcher.createParserWithMatch());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlDeclaration.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+public class TestXmlDeclaration extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testXml10Declaration() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true);\n+        String xml = mapper.writeValueAsString(new StringBean(\"123\"));\n+        assertEquals(xml, \"<?xml version='1.0' encoding='UTF-8'?><StringBean><text>123</text></StringBean>\");\n+    }\n+\n+    public void testXml11Declaration() throws Exception\n+    {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.configure(ToXmlGenerator.Feature.WRITE_XML_1_1, true);\n+        String xml = mapper.writeValueAsString(new StringBean(\"abcd\"));\n+        assertEquals(xml, \"<?xml version='1.1' encoding='UTF-8'?><StringBean><text>abcd</text></StringBean>\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlGenerator.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+public class TestXmlGenerator extends XmlTestBase\n+{\n+    public void testSimpleElement() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createJsonGenerator(out);\n+        // root name is special, need to be fed first:\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"elem\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root><elem>value</elem></root>\", xml);\n+    }\n+\n+    public void testSimpleAttribute() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createJsonGenerator(out);\n+        // root name is special, need to be fed first:\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.setNextIsAttribute(true);\n+        gen.writeFieldName(\"attr\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root attr=\\\"value\\\"/>\", xml);\n+    }\n+\n+    public void testSecondLevelAttribute() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createJsonGenerator(out);\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"elem\");\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.setNextIsAttribute(true);\n+        gen.writeFieldName(\"attr\");\n+        gen.writeString(\"value\");\n+        gen.writeEndObject();\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = out.toString();\n+        // one more thing: remove that annoying 'xmlns' decl, if it's there:\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<root><elem attr=\\\"value\\\"/></root>\", xml);\n+    }\n+\n+    public void testAttrAndElem() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        StringWriter out = new StringWriter();\n+        ToXmlGenerator gen = f.createJsonGenerator(out);\n+        gen.setNextName(new QName(\"root\"));\n+        gen.writeStartObject();\n+        // and also need to force attribute\n+        gen.writeFieldName(\"attr\");\n+        gen.setNextIsAttribute(true);\n+        gen.writeNumber(-3);\n+\n+        // Also let's add child element as well\n+        gen.setNextIsAttribute(false);\n+        gen.writeFieldName(\"elem\");\n+        gen.writeNumber(13);\n+        gen.writeEndObject();\n+        gen.close();\n+        String xml = removeSjsxpNamespace(out.toString());\n+        assertEquals(\"<root attr=\\\"-3\\\"><elem>13</elem></root>\", xml);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlParser.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+\n+\n+public class TestXmlParser extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected JsonFactory _jsonFactory;\n+    protected XmlFactory _xmlFactory;\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jsonFactory = new JsonFactory();\n+        _xmlFactory = new XmlFactory();\n+        _xmlMapper = new XmlMapper();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testSimplest() throws Exception\n+    {\n+        assertEquals(\"{\\\"leaf\\\":\\\"abc\\\"}\",\n+                _readXmlWriteJson(\"<root><leaf>abc</leaf></root>\"));\n+    }\n+\n+    public void testSimpleWithEmpty() throws Exception\n+    {\n+        assertEquals(\"{\\\"leaf\\\":null}\",\n+                _readXmlWriteJson(\"<root><leaf /></root>\"));\n+    }\n+\n+    public void testSimpleNested() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":{\\\"b\\\":{\\\"c\\\":\\\"xyz\\\"}}}\",\n+                _readXmlWriteJson(\"<root><a><b><c>xyz</c></b></a></root>\"));\n+    }\n+\n+    /**\n+     * Unit test that verifies that we can write sample document from JSON\n+     * specification as XML, and read it back in \"as JSON\", with\n+     * expected transformation.\n+     */\n+    public void testRoundTripWithSample() throws Exception\n+    {\n+        // First: let's convert from sample JSON doc to default xml output\n+        JsonNode root = new ObjectMapper().readTree(SAMPLE_DOC_JSON_SPEC);\n+        String xml = _xmlMapper.writeValueAsString(root);\n+        \n+        // Here we would ideally use base class test method. Alas, it won't\n+        // work due to couple of problems;\n+        // (a) All values are reported as Strings (not ints, for example\n+        // (b) XML mangles arrays, so all we see are objects.\n+        // Former could be worked around; latter less so at this point.\n+\n+        // So, for now, let's just do sort of minimal verification, manually\n+        JsonParser jp = _xmlMapper.getJsonFactory().createJsonParser(xml);\n+        \n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        verifyFieldName(jp, \"Image\");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        verifyFieldName(jp, \"Width\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        verifyFieldName(jp, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        verifyFieldName(jp, \"Title\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        verifyFieldName(jp, \"Thumbnail\");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        verifyFieldName(jp, \"Url\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        verifyFieldName(jp, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        verifyFieldName(jp, \"Width\");\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+\n+        // Note: arrays are \"eaten\"; wrapping is done using BeanPropertyWriter, so:\n+        //assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        //verifyFieldName(jp, \"IDs\");\n+        //assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n+        verifyFieldName(jp, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(jp));\n+\n+        // no matching entry for array:\n+        //assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+        \n+        jp.close();\n+    }\n+\n+    /**\n+     * Test to ensure functionality used to force an element to be reported\n+     * as \"JSON\" Array, instead of default Object.\n+     */\n+    public void testForceElementAsArray() throws Exception\n+    {\n+        final String XML = \"<array><elem>value</elem><elem><property>123</property></elem><elem>1</elem></array>\";\n+\n+        FromXmlParser xp = (FromXmlParser) _xmlFactory.createJsonParser(new StringReader(XML));\n+\n+        // First: verify handling without forcing array handling:\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <array>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"value\", xp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <property>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken());\n+        assertEquals(\"property\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"123\", xp.getText());\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // <object>\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <elem>\n+        assertEquals(\"elem\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"1\", xp.getText());\n+\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </array>\n+        xp.close();\n+\n+        // And then with array handling:\n+        xp = (FromXmlParser) _xmlFactory.createJsonParser(new StringReader(XML));\n+        assertTrue(xp.getParsingContext().inRoot());\n+\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <array>\n+        assertTrue(xp.getParsingContext().inObject()); // true until we do following:\n+\n+        // must request 'as-array' handling, which will \"convert\" current token:\n+        assertTrue(\"Should 'convert' START_OBJECT to START_ARRAY\", xp.isExpectedStartArrayToken());\n+        assertToken(JsonToken.START_ARRAY, xp.getCurrentToken()); // <elem>\n+        assertTrue(xp.getParsingContext().inArray());\n+\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertTrue(xp.getParsingContext().inArray());\n+        assertEquals(\"value\", xp.getText());\n+\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <property>\n+        assertTrue(xp.getParsingContext().inObject());\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken());\n+        assertEquals(\"property\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"123\", xp.getText());\n+        assertTrue(xp.getParsingContext().inObject());\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </property>\n+        assertTrue(xp.getParsingContext().inArray());\n+\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertTrue(xp.getParsingContext().inArray());\n+        assertEquals(\"1\", xp.getText());\n+\n+        assertToken(JsonToken.END_ARRAY, xp.nextToken()); // </array>\n+        assertTrue(xp.getParsingContext().inRoot());\n+        xp.close();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+\n+    public void testXmlAttributes() throws Exception\n+    {\n+        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n+\n+        FromXmlParser xp = (FromXmlParser) _xmlFactory.createJsonParser(new StringReader(XML));\n+\n+        // First: verify handling without forcing array handling:\n+        assertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\n+        assertEquals(\"max\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"7\", xp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n+        assertEquals(\"offset\", xp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n+        assertEquals(\"9\", xp.getText());\n+\n+        assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n+        xp.close();\n+    }\n+\n+    private String _readXmlWriteJson(String xml) throws IOException\n+    {\n+        StringWriter w = new StringWriter();\n+\n+        JsonParser jp = _xmlFactory.createJsonParser(xml);\n+        JsonGenerator jg = _jsonFactory.createJsonGenerator(w);\n+        while (jp.nextToken() != null) {\n+            jg.copyCurrentEvent(jp);\n+        }\n+        jg.close();\n+        return w.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlTokenStream.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+\n+import javax.xml.stream.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.util.XmlTokenStream;\n+\n+public class TestXmlTokenStream extends XmlTestBase\n+{\n+    public void testSimple() throws Exception\n+    {\n+        String XML = \"<root><leaf id='123'>abc</leaf></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"leaf\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_NAME, tokens.next());\n+        assertEquals(\"id\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_VALUE, tokens.next());\n+        assertEquals(\"123\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_TEXT, tokens.next());\n+        assertEquals(\"abc\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+\n+    public void testRootAttributes() throws Exception\n+    {\n+        String XML = \"<root id='x' />\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_NAME, tokens.next());\n+        assertEquals(\"id\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_ATTRIBUTE_VALUE, tokens.next());\n+        assertEquals(\"x\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+    \n+    public void testEmptyTags() throws Exception\n+    {\n+        String XML = \"<root><leaf /></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        // must point to START_ELEMENT, so:\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"leaf\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+\n+    public void testNested() throws Exception\n+    {\n+        String XML = \"<root><a><b><c>abc</c></b></a></root>\";\n+        XMLStreamReader sr = XMLInputFactory.newInstance().createXMLStreamReader(new StringReader(XML));\n+        sr.nextTag();\n+        XmlTokenStream tokens = new XmlTokenStream(sr, XML);\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.getCurrentToken());\n+        assertEquals(\"root\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"a\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"b\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_START_ELEMENT, tokens.next());\n+        assertEquals(\"c\", tokens.getLocalName());\n+        assertEquals(XmlTokenStream.XML_TEXT, tokens.next());\n+        assertEquals(\"abc\", tokens.getText());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END_ELEMENT, tokens.next());\n+        assertEquals(XmlTokenStream.XML_END, tokens.next());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public abstract class XmlTestBase\n+    extends TestCase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    protected static class StringBean\n+    {\n+        public String text;\n+\n+        public StringBean() { this(\"foobar\"); }\n+        public StringBean(String s) { text = s; }\n+    }\n+\n+    /**\n+     * Simple wrapper around String type, usually to test value\n+     * conversions or wrapping\n+     */\n+    protected static class StringWrapper {\n+        public String str;\n+\n+        public StringWrapper() { }\n+        public StringWrapper(String value) {\n+            str = value;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    protected XmlTestBase() {\n+        super();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods, other\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method that tries to remove unnecessary namespace\n+     * declaration that default JDK XML parser (SJSXP) seems fit\n+     * to add.\n+     */\n+    protected static String removeSjsxpNamespace(String xml)\n+    {\n+        final String match = \" xmlns=\\\"\\\"\";\n+        int ix = xml.indexOf(match);\n+        if (ix > 0) {\n+            xml = xml.substring(0, ix) + xml.substring(ix+match.length());\n+        }\n+        return xml;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestEnums.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestEnums extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static enum TestEnum { A, B, C; }\n+    \n+    static class UntypedEnumBean\n+    {\n+       @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"__type\")\n+// this would actually work:\n+//        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+        public Object value;\n+\n+        public UntypedEnumBean() { }\n+        public UntypedEnumBean(TestEnum v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testUntypedEnum() throws Exception\n+    {\n+        ObjectMapper mapper = new XmlMapper();\n+        String str = mapper.writeValueAsString(new UntypedEnumBean(TestEnum.B));\n+        UntypedEnumBean result = mapper.readValue(str, UntypedEnumBean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        Object ob = result.value;\n+        assertSame(TestEnum.class, ob.getClass());\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestPolymorphic.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+\n+\n+public class TestPolymorphic extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class BaseTypeWithClassProperty { }\n+\n+    static class SubTypeWithClassProperty extends BaseTypeWithClassProperty {\n+        public String name;\n+\n+        public SubTypeWithClassProperty() { }\n+        public SubTypeWithClassProperty(String s) { name = s; }\n+    }\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+    static class BaseTypeWithClassArray { }\n+\n+    static class SubTypeWithClassArray extends BaseTypeWithClassArray {\n+        public String name;\n+\n+        public SubTypeWithClassArray() { }\n+        public SubTypeWithClassArray(String s) { name = s; }\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    static class BaseTypeWithClassObject { }\n+\n+    static class SubTypeWithClassObject extends BaseTypeWithClassObject {\n+        public String name;\n+    \n+        public SubTypeWithClassObject() { }\n+        public SubTypeWithClassObject(String s) { name = s; }\n+    }\n+    \n+    /**\n+     * If not used as root element, need to use a wrapper\n+     */\n+    static class ClassArrayWrapper\n+    {\n+        public BaseTypeWithClassArray wrapped;\n+\n+        public ClassArrayWrapper() { }\n+        public ClassArrayWrapper(String s) { wrapped = new SubTypeWithClassArray(s); }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /* 19-Dec-2010, tatu: Let's hold off these tests, due to issues with inclusions.\n+     */\n+    // Does not work since array wrapping is not explicitly forced (unlike with collection\n+    // property of a bean\n+    public void testAsClassArray() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassArray(\"Foobar\"));\n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassArray.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassArray.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassArray) result).name);\n+    }\n+\n+    // Hmmh. Does not yet quite work either, since we do not properly force\n+    // array context when writing...\n+    public void testAsWrappedClassArray() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new ClassArrayWrapper(\"Foobar\"));\n+        ClassArrayWrapper result = _xmlMapper.readValue(xml, ClassArrayWrapper.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassArray.class, result.wrapped.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassArray) result.wrapped).name);\n+    }\n+}\n+   \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/TestWithJAXBAnnotations.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n+\n+/**\n+ * Although XML-backed data binding does not rely (or directly build) on JAXB\n+ * annotations, it should be possible to use them similar to how they are used\n+ * with default Jackson JSON data binding. Let's verify this is the case.\n+ */\n+public class TestWithJAXBAnnotations extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper types\n+    /**********************************************************************\n+     */\n+\n+    @XmlRootElement(name=\"bean\")\n+    public static class RootBean\n+    {\n+        public String value = \"text\";\n+    }\n+    \n+    public static class AttrBean\n+    {        \n+        @XmlAttribute\n+        public String attr = \"3\";\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /**********************************************************************\n+     */\n+\n+    protected XmlMapper _jaxbMapper;\n+    protected XmlMapper _nonJaxbMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jaxbMapper = new XmlMapper();\n+        _nonJaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+            (new XmlJaxbAnnotationIntrospector(), new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Unit test for verifying that root element name can be overridden\n+     * with <code>@XmlRootElement</code> annotation.\n+     */\n+    public void testRootName() throws Exception\n+    {\n+        RootBean bean = new RootBean();\n+        // without JAXB annotations will use class simple name:\n+        assertEquals(\"<RootBean><value>text</value></RootBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<bean><value>text</value></bean>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    /**\n+     * Unit test for verifying that a propery defaults to being written as\n+     * element, but can be redefined with <code>@XmlAttribute</code> annotation.\n+     */\n+    public void testSerializeAsAttr() throws Exception\n+    {\n+        AttrBean bean = new AttrBean();\n+        assertEquals(\"<AttrBean><attr>3</attr></AttrBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<AttrBean attr=\\\"3\\\"/>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+}", "timestamp": 1329717453, "metainfo": ""}