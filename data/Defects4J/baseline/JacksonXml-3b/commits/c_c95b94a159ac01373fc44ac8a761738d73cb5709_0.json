{"sha": "c95b94a159ac01373fc44ac8a761738d73cb5709", "log": "bit closer to supporting unwrapped arrays/collections...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n import java.io.IOException;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.Set;\n \n import javax.xml.stream.XMLStreamReader;\n import javax.xml.stream.XMLStreamWriter;\n     protected JsonToken _nextToken;\n \n     protected String _currText;\n+\n+    protected Set<String> _namesToWrap;\n     \n     /*\n     /**********************************************************\n     public XMLStreamReader getStaxReader() {\n         return _xmlTokens.getXmlReader();\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Internal API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that may be called to indicate that specified names\n+     * (only local parts retained currently: this may be changed in\n+     * future) should be considered \"auto-wrapping\", meaning that\n+     * they will be doubled to contain two opening elements, two\n+     * matching closing elements. This is needed for supporting\n+     * handling of so-called \"unwrapped\" array types, something\n+     * XML mappings like JAXB often use.\n+     *<p>\n+     * NOTE: this method is considered part of internal implementation\n+     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n+     * between minor versions (it is however expected not to change in\n+     * patch versions). So if you have to use it, be prepared for\n+     * possible additional work.\n+     * \n+     * @since 2.1\n+     */\n+    public void addVirtualWrapping(Set<String> namesToWrap)\n+    {\n+        _namesToWrap = namesToWrap;\n+        _parsingContext.setNamesToWrap(namesToWrap);\n+    }\n+\n     /*\n     /**********************************************************\n     /* JsonParser impl\n             case END_OBJECT:\n             case END_ARRAY:\n                 _parsingContext = _parsingContext.getParent();\n+                _namesToWrap = _parsingContext.getNamesToWrap();\n                 break;\n             case FIELD_NAME:\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _mayBeLeaf = true;\n                 continue;\n             }\n-            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            String name = _xmlTokens.getLocalName();\n+            _parsingContext.setCurrentName(name);\n+\n+            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n+//                System.err.println(\"VOILA! Wrap '\"+name+\"'!\");\n+            }\n+\n             _mayBeLeaf = true;\n             /* Ok: in array context we need to skip reporting field names. But what's the best way\n              * to find next token?\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n package com.fasterxml.jackson.dataformat.xml.deser;\n \n-import java.util.Iterator;\n+import java.io.IOException;\n+import java.util.*;\n \n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.std.DelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  * Delegating deserializer whose only function is to handle case of\n public class WrapperHandlingDeserializer\n     extends DelegatingDeserializer\n {\n+    protected final Set<String> _namesToWrap;\n+    \n     /*\n     /**********************************************************************\n     /* Construction\n     /**********************************************************************\n      */\n \n-    public WrapperHandlingDeserializer(BeanDeserializerBase delegate)\n-    {\n-        super(delegate);\n+    public WrapperHandlingDeserializer(BeanDeserializerBase delegate) {\n+        this(delegate, null);\n     }\n \n+    public WrapperHandlingDeserializer(BeanDeserializerBase delegate,\n+            Set<String> namesToWrap) {\n+        super(delegate);\n+        _namesToWrap = namesToWrap;\n+    }\n+    \n     /*\n     /**********************************************************************\n     /* Abstract method implementations\n     \n     @Override\n     protected JsonDeserializer<?> newDelegatingInstance(JsonDeserializer<?> newDelegatee) {\n-        return new WrapperHandlingDeserializer(_verifyDeserType(newDelegatee));\n+        return new WrapperHandlingDeserializer(_verifyDeserType(newDelegatee),\n+                _namesToWrap);\n     }\n     \n     /*\n         // Let's go through the properties now...\n         Iterator<SettableBeanProperty> it = newDelegatee.properties();\n         final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        HashSet<String> unwrappedNames = null;\n         while (it.hasNext()) {\n             SettableBeanProperty prop = it.next();\n+            /* First things first: only consider array/Collection types\n+             * (not perfect check, but simplest reasonable check)\n+             */\n+            JavaType type = prop.getType();\n+            if (!(type.isArrayType() || type.isCollectionLikeType())) {\n+                continue;\n+            }\n             AnnotatedMember acc = prop.getMember();\n             PropertyName wrapperName = (acc == null) ? null : intr.findWrapperName(acc);\n-//System.out.println(\"Prop '\"+prop.getName()+\"', wrapper -> \"+wrapperName);\n-\n+            // skip anything with wrapper (should work as is)\n+            if (wrapperName != null && wrapperName.hasSimpleName()) {\n+                continue;\n+            }\n+            if (unwrappedNames == null) {\n+                unwrappedNames = new HashSet<String>();\n+            }\n+            // not optimal; should be able to use PropertyName...\n+            unwrappedNames.add(prop.getName());\n         }\n-//        System.out.println(\"DEBUG: /createContextual\");\n-        \n-        /*\n-        if (newDelegatee == _delegatee) {\n-            return this;\n+        // Ok: if nothing to take care of, just return the delegatee...\n+        if (unwrappedNames == null) {\n+            return newDelegatee;\n         }\n-        return newDelegatingInstance(newDelegatee);\n-        */\n-\n-        return newDelegatee;\n+        // Otherwise, create the thing that can deal with virtual wrapping\n+        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n     }\n \n+    /*\n+    /**********************************************************************\n+    /* Overridden deserialization methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        _configureParser(jp);\n+        return _delegatee.deserialize(jp,  ctxt);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Object intoValue)\n+        throws IOException, JsonProcessingException\n+    {\n+        _configureParser(jp);\n+        return ((JsonDeserializer<Object>)_delegatee).deserialize(jp, ctxt, intoValue);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        _configureParser(jp);\n+        return _delegatee.deserializeWithType(jp, ctxt, typeDeserializer);\n+    }\n+    \n     /*\n     /**********************************************************************\n     /* Internal methods\n     /**********************************************************************\n      */\n \n+    protected void _configureParser(JsonParser jp)\n+    {\n+        ((FromXmlParser) jp).addVirtualWrapping(_namesToWrap);\n+    }\n+    \n     protected BeanDeserializerBase _verifyDeserType(JsonDeserializer<?> deser)\n     {\n         if (!(deser instanceof BeanDeserializerBase)) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharTypes;\n \n     protected String _currentName;\n \n+    protected Set<String> _namesToWrap;\n+    \n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speeds up things\n         _lineNr = lineNr;\n         _columnNr = colNr;\n         _currentName = null;\n+        _namesToWrap = null;\n     }\n \n     // // // Factory methods\n         return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n     }\n \n+    public void setNamesToWrap(Set<String> namesToWrap) {\n+        _namesToWrap = namesToWrap;\n+    }\n+\n+    public Set<String> getNamesToWrap() { \n+        return _namesToWrap;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* State changes", "timestamp": 1347161776, "metainfo": ""}