{"sha": "4b5c9b7c5c4d70e0cf6f8944837e54be862a27cc", "log": "Starting to resolve unit test failures", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n     extends JacksonAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n+    /**\n+     * For backwards compatibility with 2.0, the default behavior is\n+     * to assume use of List wrapper if no annotations are used.\n+     */\n+    public final static boolean DEFAULT_USE_WRAPPER = true;\n+\n+    protected final boolean _cfgDefaultUseWrapper;\n+    \n+    public JacksonXmlAnnotationIntrospector() {\n+        this(DEFAULT_USE_WRAPPER);\n+    }\n+\n+    public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n+        _cfgDefaultUseWrapper = defaultUseWrapper;\n+    }\n+    \n     /*\n     /**********************************************************************\n     /* Overrides of JacksonAnnotationIntrospector impls\n     {\n         JacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\n         if (w != null) {\n+            // Special case: wrapping explicitly blocked?\n+            if (!w.useWrapping()) {\n+                return PropertyName.NO_NAME;\n+            }\n             return PropertyName.construct(w.localName(), w.namespace());\n+        } else {\n+            /* 09-Sep-2012, tatu: In absence of configurating we need to use our\n+             *   default settings...\n+             */\n+            if (_cfgDefaultUseWrapper) {\n+                return PropertyName.USE_DEFAULT;\n+            }\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n public class JacksonXmlModule extends SimpleModule\n {\n     private final static AnnotationIntrospector XML_ANNOTATION_INTROSPECTOR = new JacksonXmlAnnotationIntrospector();\n-    \n+\n     public JacksonXmlModule()\n     {\n         super(\"JackxonXmlModule\", ModuleVersion.instance.version());\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlElementWrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlElementWrapper.java\n  * to indicate wrapper element to use (if any) for Collection types (arrays,\n  * <code>java.util.Collection</code>). If defined, a separate container (wrapper) element\n  * is used; if not, entries are written without wrapping.\n- * Name of wrapper element defaults to name of the property but can be explicitly defined\n- * to something else.\n- * \n- * @author tatu\n  */\n @Target({ElementType.FIELD, ElementType.METHOD})\n @Retention(RetentionPolicy.RUNTIME)\n public @interface JacksonXmlElementWrapper\n {\n-    String namespace() default \"\";\n-    String localName() default \"\";\n+    /**\n+     * Marker value (empty String) that denotes that the underlying property\n+     * name should also be used as the wrapper name, effectively \"doubling\"\n+     * start and end elements.\n+     * \n+     * @since 2.1\n+     */\n+    public final static String USE_PROPERTY_NAME = \"\";\n+    \n+    String namespace() default USE_PROPERTY_NAME;\n+    String localName() default USE_PROPERTY_NAME;\n+\n+    /**\n+     * Optional property that can be used to explicitly disable wrapping,\n+     * usually via mix-ins, or when using <code>AnnotationIntrospector</code>\n+     * pairs.\n+     * \n+     * @since 2.1\n+     */\n+    boolean useWrapping() default true;\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n             AnnotatedMember acc = prop.getMember();\n             PropertyName wrapperName = (acc == null) ? null : intr.findWrapperName(acc);\n             // skip anything with wrapper (should work as is)\n-            if (wrapperName != null && wrapperName.hasSimpleName()) {\n+            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                 continue;\n             }\n             if (unwrappedNames == null) {\n         if (unwrappedNames == null) {\n             return newDelegatee;\n         }\n-//System.out.println(\"Unwrapped for (): \"+unwrappedNames);       \n         // Otherwise, create the thing that can deal with virtual wrapping\n         return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n             if (acc == null) {\n                 continue;\n             }\n-            // first: do we need to handle wrapping (for Lists)?\n+            /* First: handle \"as text\"? Such properties\n+             * are exposed as values of 'unnamed' fields; so one way to\n+             * map them is to rename property to have name \"\"... (and\n+             * hope this does not break other parts...)\n+             */\n+\n+            Boolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\n+            if (b != null && b.booleanValue()) {\n+                // unwrapped properties will appear as 'unnamed' (empty String)\n+                propDefs.set(i, prop.withName(\"\"));\n+                continue;\n+            }\n+            // second: do we need to handle wrapping (for Lists)?\n             PropertyName wrapperName = intr.findWrapperName(acc);\n-            if (wrapperName != null) {\n+            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n                 String localName = wrapperName.getSimpleName();\n                 if ((localName != null && localName.length() > 0)\n                         && !localName.equals(prop.getName())) {\n                     propDefs.set(i, prop.withName(localName));\n                     continue;\n                 }\n-            } else {\n-                /* If not, how about \"as text\" unwrapping? Such properties\n-                 * are exposed as values of 'unnamed' fields; so one way to\n-                 * map them is to rename property to have name \"\"... (and\n-                 * hope this does not break other parts...)\n-                 */\n-                Boolean b = AnnotationUtil.findIsTextAnnotation(intr, acc);\n-                if (b != null && b.booleanValue()) {\n-                    // unwrapped properties will appear as 'unnamed' (empty String)\n-                    propDefs.set(i, prop.withName(\"\"));\n-                    continue;\n-                }\n+                // otherwise unwrapped; needs handling but later on\n             }\n-            // otherwise unwrapped; needs handling but later on\n         }\n         return propDefs;\n     }\n-\n-    /*\n-    @Override\n-    public BeanDeserializerBuilder updateBuilder(DeserializationConfig config,\n-            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n-    {\n-        Iterator<SettableBeanProperty> it = builder.getProperties();\n-        while (it.hasNext()) {\n-            SettableBeanProperty prop = it.next();\n-            System.out.println(\"Builder, prop '\"+prop.getName()+\"', type \"+prop.getType()+\", hasSer \"+prop.hasValueDeserializer());\n-        }\n-        return builder;\n-    }\n-    */\n \n     @Override\n     public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n             //  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n             //   typed Collection...\n-            if (TypeUtil.isIndexedType(bpw.getType())) {\n-                String localName = null, wrapperNs = null;\n+            if (!TypeUtil.isIndexedType(bpw.getType())) {\n+                continue;\n+            }\n+            PropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\n+            PropertyName wrapperName = intr.findWrapperName(member);\n \n-                PropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\n-                PropertyName wrapperName = intr.findWrapperName(member);\n-                \n-                if (wrapperName != null) {\n-                    localName = wrapperName.getSimpleName();\n-                    wrapperNs = wrapperName.getNamespace();\n-                }\n-                /* 21-Aug-2012, tatu: Missing localName means \"use property name as wrapper\",\n-                 *   empty \"no wrapper\"\n-                 */\n-                if (localName == null) {\n-                    wrapperName = wrappedName;\n-                } else if (localName.length() == 0) {\n-                    // Empty wrapper name is explicit \"DO NOT wrap\" Lists indicator, so:\n-                    continue;\n-                } else {\n-                    wrapperName = PropertyName.construct(localName, (wrapperNs == null) ? \"\" : wrapperNs);\n-                }\n-                beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n+            // first things first: no wrapping?\n+            if (wrapperName == null || wrapperName == PropertyName.NO_NAME) {\n+                continue;\n             }\n+            // no local name? Just double the wrapped name for wrapper\n+            String localName = wrapperName.getSimpleName();\n+            if (localName == null || localName.length() == 0) {\n+                wrapperName = wrappedName;\n+            }\n+            beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n         }\n         return beanProperties;\n     }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n \n public class TestDeserialization extends XmlTestBase\n \n     static class ListBean\n     {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n         public List<Integer> values;\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestViews.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestViews.java\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n /*\n- * Tests for ('Json') Views, other filtering.\n+ * Tests for ('JSON') Views, other filtering.\n  */\n public class TestViews extends XmlTestBase\n {\n         xmlMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n \n         String xml = xmlMapper.writerWithView(RestrictedView.class).writeValueAsString(foo);\n-\n-System.out.println(\"XML == \"+xml);        \n         \n         // views not used for deserialization\n         Foo result = xmlMapper.readValue(xml, Foo.class);", "timestamp": 1347246906, "metainfo": ""}