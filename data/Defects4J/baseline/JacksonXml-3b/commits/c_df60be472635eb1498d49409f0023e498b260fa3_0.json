{"sha": "df60be472635eb1498d49409f0023e498b260fa3", "log": "Merge branch '2.6'", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/EmptyList177Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+// for [dataformat-xml#177]\n+public class EmptyList177Test extends XmlTestBase\n+{\n+    static class Config\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String id;\n+        \n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Entry> entry;\n+    }\n+\n+    static class Entry\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String id;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testEmptyList() throws Exception\n+    {\n+        Config r = MAPPER.readValue(\n+                \"<Config id='123'>\\n\"+\n+                \"  <entry id='foo'> </entry>\\n\"+\n+                \"</Config>\\n\",\n+                Config.class);\n+        assertNotNull(r);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.PropertyName;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n-\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n \n /**\n      */\n     public final static boolean DEFAULT_USE_WRAPPER = true;\n \n-    protected final boolean _cfgDefaultUseWrapper;\n+    // non-final from 2.7 on, to allow mapper to change\n+    protected boolean _cfgDefaultUseWrapper;\n     \n     public JacksonXmlAnnotationIntrospector() {\n         this(DEFAULT_USE_WRAPPER);\n         }\n         return null;\n     }\n-    \n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        _cfgDefaultUseWrapper = b;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Overrides for name, property detection\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      */\n     public Boolean isOutputAsCData(Annotated ann);\n \n+    /**\n+     * @since 2.7\n+     */\n+    public void setDefaultUseWrapper(boolean b);\n+    \n     /*\n     /**********************************************************************\n     /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n         public String findNamespace(Annotated ann)\n         {\n             String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.findNamespace(ann);\n             }\n             return value;\n         public Boolean isOutputAsAttribute(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsAttribute(ann);\n             }\n             return value;\n         public Boolean isOutputAsText(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsText(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsText(ann);\n             }\n             return value;\n         @Override\n         public Boolean isOutputAsCData(Annotated ann) {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsCData(ann);\n             }\n             return value;\n+        }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            if (_xmlPrimary != null) {\n+                _xmlPrimary.setDefaultUseWrapper(b);\n+            }\n+            if (_xmlSecondary != null) {\n+                _xmlSecondary.setDefaultUseWrapper(b);\n+            }\n         }\n     }\n \n             //There is no CData annotation in JAXB\n             return null;\n         }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            // not used with JAXB\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n         _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n     }\n \n-    // @since 2.1\n     @Override\n     public XmlMapper copy()\n     {\n     protected void setXMLTextElementName(String name) {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n+    /**\n+     * Since 2.7\n+     */\n+    public XmlMapper setDefaultUseWrapper(boolean state) {\n+        // ser and deser configs should usually have the same introspector, so:\n+        AnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\n+        for (AnnotationIntrospector ai : ai0.allIntrospectors()) {\n+            if (ai instanceof XmlAnnotationIntrospector) {\n+                ((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n+            }\n+        }\n+        return this;\n+    }\n \n     /*\n     /**********************************************************\n     /* Access to configuration settings\n     /**********************************************************\n      */\n-\n-    /**\n-     * @deprecated Since 2.1, use {@link #getFactory} instead\n-     */\n-    @Override\n-    @Deprecated\n-    public XmlFactory getJsonFactory() {\n-        return (XmlFactory) _jsonFactory;\n-    }\n \n     @Override\n     public XmlFactory getFactory() {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n      */\n     public void writeEndElement(XMLStreamWriter2 sw, int nrOfEntries) throws XMLStreamException;\n \n+    /**\n+     * Method for trying to write a linefeed to separate entities outside of the\n+     * root element (that is, in prolog or epilog), most often called to separate\n+     * XML declaration from the root element.\n+     *\n+     * @since 2.7\n+     */\n+    public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException;\n+    \n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName, String text, boolean isCData)\n         throws XMLStreamException;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n      * String (\"\").\n      */\n     public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n-    \n+\n     /**\n      * Enumeration that defines all togglable features for XML parsers.\n      * None defined so far (2.6), so just a placeholder.\n      */\n     @Override\n     public boolean requiresCustomCodec() {\n-        return false;\n+        return true;\n     }\n     \n     /*\n      * the current event.\n      */\n     @Override\n-    public String getCurrentName()\n-        throws IOException, JsonParseException\n+    public String getCurrentName() throws IOException\n     {\n         // [JACKSON-395]: start markers require information from parent\n         String name;\n      */\n \n     @Override\n-    public String getText() throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         if (_currToken == null) {\n             return null;\n \n     // @since 2.1\n     @Override\n-    public final String getValueAsString() throws IOException, JsonParseException {\n+    public final String getValueAsString() throws IOException {\n         return getValueAsString(null);\n     }\n \n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n+    public String getValueAsString(String defValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t == null) {\n     }\n     \n     @Override\n-    public char[] getTextCharacters() throws IOException, JsonParseException {\n+    public char[] getTextCharacters() throws IOException {\n         String text = getText();\n         return (text == null)  ? null : text.toCharArray();\n     }\n \n     @Override\n-    public int getTextLength() throws IOException, JsonParseException {\n+    public int getTextLength() throws IOException {\n         String text = getText();\n         return (text == null)  ? 0 : text.length();\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException {\n+    public int getTextOffset() throws IOException {\n         return 0;\n     }\n \n      */\n \n     @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+    public Object getEmbeddedObject() throws IOException {\n         // no way to embed POJOs for now...\n         return null;\n     }\n \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n  * implementation that\n  * builds on {@link JaxbAnnotationIntrospector}.\n  *<p>\n- * NOTE: since version 2.4, it should NOT be necessary to use this class;\n+ * NOTE: since version 2.4, it may NOT be necessary to use this class;\n  * instead, plain {@link JaxbAnnotationIntrospector} should fully work.\n  * With previous versions some aspects were not fully working and this\n  * class was necessary.\n     extends JaxbAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n-    private static final long serialVersionUID = 6477843393758275877L;\n+    private static final long serialVersionUID = 1L; // since 2.7\n \n     @Deprecated\n     public XmlJaxbAnnotationIntrospector() {\n     /**********************************************************************\n      */\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public String findNamespace(Annotated ann) {\n         return super.findNamespace(ann);\n     }\n \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsAttribute(Annotated ann) {\n         return super.isOutputAsAttribute(ann);\n     }\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n     public Boolean isOutputAsCData(Annotated ann) {\n         //There is no CData annotation in JAXB\n         return null;\n+    }\n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        // nothing to do with JAXB\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n      * {@link ToXmlGenerator.Feature}s\n      * are enabled.\n      */\n-    protected int _xmlFeatures;\n+    protected int _formatFeatures;\n \n     /**\n      * We may need to use XML-specific indentation as well\n     /**********************************************************\n      */\n \n-    public ToXmlGenerator(IOContext ctxt, int genericGeneratorFeatures, int xmlFeatures,\n+    public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\n             ObjectCodec codec, XMLStreamWriter sw)\n     {\n-        super(genericGeneratorFeatures, codec);\n-        _xmlFeatures = xmlFeatures;\n+        super(stdFeatures, codec);\n+        _formatFeatures = xmlFeatures;\n         _ioContext = ctxt;\n         _originalXmlWriter = sw;\n         _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n         }\n         _initialized = true;\n         try {\n-            if ((_xmlFeatures & Feature.WRITE_XML_1_1.getMask()) != 0) {\n+            if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n                 _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n-            } else if ((_xmlFeatures & Feature.WRITE_XML_DECLARATION.getMask()) != 0) {\n+            } else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n                 _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n+            } else {\n+                return;\n+            }\n+            // as per [dataformat-xml#172], try adding indentation\n+            if (_xmlPrettyPrinter != null) {\n+                // ... but only if it is likely to succeed:\n+                if (!_stax2Emulation) {\n+                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n      * default XML indenter instead.\n      *<p>\n      * !!! TODO: same as implementation in core 2.6; override may be\n-     * removed from 2.7\n+     * removed from 2.8\n      */\n     @Override\n     public final JsonGenerator useDefaultPrettyPrinter()\n         return -1;\n     }\n \n+    @Override\n+    public int getFormatFeatures() {\n+        return _formatFeatures;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonGenerator overrideFormatFeatures(int values, int mask)\n+    {\n+        int oldF = _formatFeatures;\n+        int newF = (_formatFeatures & ~mask) | (values & mask);\n+\n+        if (oldF != newF) {\n+            _formatFeatures = newF;\n+        }\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended API, configuration\n      */\n \n     public ToXmlGenerator enable(Feature f) {\n-        _xmlFeatures |= f.getMask();\n+        _formatFeatures |= f.getMask();\n         return this;\n     }\n \n     public ToXmlGenerator disable(Feature f) {\n-        _xmlFeatures &= ~f.getMask();\n+        _formatFeatures &= ~f.getMask();\n         return this;\n     }\n \n     public final boolean isEnabled(Feature f) {\n-        return (_xmlFeatures & f.getMask()) != 0;\n+        return (_formatFeatures & f.getMask()) != 0;\n     }\n \n     public ToXmlGenerator configure(Feature f, boolean state) {\n      */\n \n     @Override\n-    public final void writeFieldName(String name)  throws IOException\n+    public final void writeFieldName(String name) throws IOException\n     {\n         if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n             _reportError(\"Can not write a field name, expecting a value\");\n             // note: since attributes don't nest, can only have one attribute active, so:\n             _nextIsAttribute = false;\n             _xmlWriter.writeEndElement();\n+            // [databind-xml#172]: possibly also need indentation\n+            if (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n+                // ... but only if it is likely to succeed:\n+                if (!_stax2Emulation) {\n+                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n+                }\n+            }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n         }\n     @Override\n     public void writeRaw(String text) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n     @Override\n     public void writeRaw(String text, int offset, int len) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n     @Override\n     public void writeRaw(char[] text, int offset, int len) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n public class XmlBeanPropertyWriter\n     extends BeanPropertyWriter\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* Config settings\n      * Element name used for items in the collection\n      */\n     protected final QName _wrappedQName;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: construction, configuration\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = JsonMappingException.from(gen0,\n+                    \"Infinite recursion (StackOverflowError)\");\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            JsonMappingException mapE = JsonMappingException.from(gen0, \"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n  */\n public class XmlSerializerProvider extends DefaultSerializerProvider\n {\n-    // As of 2.5\n-    private static final long serialVersionUID = -4138605166320336475L;\n+    // As of 2.7\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * If all we get to serialize is a null, there's no way to figure out\n      * expected root name; so let's just default to something like \"&lt;null>\"...\n      */\n     protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n-    \n+\n     protected final XmlRootNameLookup _rootNameLookup;\n-    \n+\n     public XmlSerializerProvider(XmlRootNameLookup rootNames)\n     {\n         super();\n         super(src, config, f);\n         _rootNameLookup  = src._rootNameLookup;\n     }\n-    \n+\n     /*\n     /**********************************************************************\n     /* Overridden methods\n             SerializerFactory jsf) {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n-    \n+\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final Class<?> cls = value.getClass();\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         // From super-class implementation\n         final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n         } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n     \n     // @since 2.1\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         }\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n         return new QName(ns, name.getSimpleName());\n     }\n \n-    protected ToXmlGenerator _asXmlGenerator(JsonGenerator jgen)\n+    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n         throws JsonMappingException\n     {\n         // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n-        if (!(jgen instanceof ToXmlGenerator)) {\n+        if (!(gen instanceof ToXmlGenerator)) {\n             // but verify\n-            if (!(jgen instanceof TokenBuffer)) {\n-                throw new JsonMappingException(\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"\n-                            +jgen.getClass().getName());\n-                }\n-                return null;\n-        }\n-        return (ToXmlGenerator) jgen;\n+            if (!(gen instanceof TokenBuffer)) {\n+                throw JsonMappingException.from(gen,\n+                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n+            }\n+            return null;\n+        }\n+        return (ToXmlGenerator) gen;\n     }    \n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n      */\n     public interface Indenter\n     {\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException;\n-\n-        public void writeIndentation(XMLStreamWriter2 sw, int level)\n-            throws XMLStreamException;\n-        \n+        public void writeIndentation(JsonGenerator g, int level) throws IOException;\n+\n+        public void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n+\n         /**\n          * @return True if indenter is considered inline (does not add linefeeds),\n          *   false otherwise\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void writeRootValueSeparator(JsonGenerator gen) throws IOException {\n         // Not sure if this should ever be applicable; but if multiple roots were allowed, we'd use linefeed\n-        jgen.writeRaw('\\n');\n+        gen.writeRaw('\\n');\n     }\n     \n     /*\n      */\n     \n     @Override\n-    public void beforeArrayValues(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void beforeArrayValues(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jgen)\n-    \t\tthrows IOException, JsonGenerationException\n-    {\n+    public void writeStartArray(JsonGenerator gen) throws IOException {\n         // anything to do here?\n     }\n \n     @Override\n-    public void writeArrayValueSeparator(JsonGenerator jgen)  throws IOException, JsonGenerationException {\n+    public void writeArrayValueSeparator(JsonGenerator gen)  throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeEndArray(JsonGenerator jgen, int nrOfValues)\n-    \t\tthrows IOException, JsonGenerationException\n-    {\n+    public void writeEndArray(JsonGenerator gen, int nrOfValues) throws IOException {\n         // anything to do here?\n     }\n     \n      */\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jgen)\n+    public void beforeObjectEntries(JsonGenerator gen)\n         throws IOException, JsonGenerationException\n     {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator gen) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             if (_nesting > 0) {\n-                _objectIndenter.writeIndentation(jgen, _nesting);\n+                _objectIndenter.writeIndentation(gen, _nesting);\n             }\n             ++_nesting;\n         }\n         _justHadStartElement = true;\n-        ((ToXmlGenerator) jgen)._handleStartObject();\n-    }\n-\n-    @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jgen)\n-            throws IOException, JsonGenerationException\n-    {\n+        ((ToXmlGenerator) gen)._handleStartObject();\n+    }\n+\n+    @Override\n+    public void writeObjectEntrySeparator(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void writeObjectFieldValueSeparator(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n     \n     @Override\n-    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator gen, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n         if (_justHadStartElement) {\n             _justHadStartElement = false;\n         } else {\n-            _objectIndenter.writeIndentation(jgen, _nesting);\n-        }\n-        ((ToXmlGenerator) jgen)._handleEndObject();\n+            _objectIndenter.writeIndentation(gen, _nesting);\n+        }\n+        ((ToXmlGenerator) gen)._handleEndObject();\n     }\n     \n     /*\n         sw.writeEmptyElement(nsURI, localName);\n         _justHadStartElement = false;\n     }\n-    \n+\n+    @Override // since 2.7\n+    public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException\n+    {\n+        // 06-Dec-2015, tatu: Alternatively could try calling `writeSpace()`...\n+        sw.writeRaw(Lf2SpacesIndenter.SYSTEM_LINE_SEPARATOR);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper classes\n         }\n         \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator g, int level) throws IOException\n         {\n-            jg.writeRaw(' ');\n+            g.writeRaw(' ');\n         }\n \n         @Override\n         public boolean isInline() { return false; }\n \n         @Override\n-        public void writeIndentation(XMLStreamWriter2 sw, int level)\n-            throws XMLStreamException\n+        public void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException\n         {\n             sw.writeRaw(SYSTEM_LINE_SEPARATOR);\n             level += level; // 2 spaces per level\n         }\n         \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator jg, int level) throws IOException\n         {\n             jg.writeRaw(SYSTEM_LINE_SEPARATOR);\n             level += level; // 2 spaces per level\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n         if (name != null) {\n             return name;\n         }\n-\n-        // 06-Dec-2015, tatu: as per [dataformat-xlm#171], need to actually do\n-        //    bit more of syncing, unfortunately. Jackson 2.7 should resolve\n-        //    the actual problem, but until then...\n         name = _findRootName(rootType, config);\n-\n         synchronized (_rootNames) {\n             _rootNames.put(key, name);\n         }\n         return name;\n     }\n     \n-    protected synchronized QName _findRootName(Class<?> rootType, MapperConfig<?> config)\n+    // NOTE: needed to be synchronized in 2.6.4, but 2.7.0 adds a proper fix\n+    // for annotation introspection hence not needed any more\n+    protected QName _findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n     private void assertVersion(Versioned vers)\n     {\n         final Version v = vers.version();\n-        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUnknownVersion());\n         Version exp = PackageVersion.VERSION;\n         assertEquals(exp.toFullString(), v.toFullString());\n         assertEquals(exp, v);\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n     /**********************************************************\n      */\n \n+    protected static String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n+    }\n+\n     protected byte[] utf8Bytes(String str) {\n         try {\n             return str.getBytes(\"UTF-8\");\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestStringValues.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestStringValues.java\n             return \"[a=\"+a+\",b=\"+b+\"]\";\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertNotNull(bean);\n         // empty String or null?\n         // 22-Sep-2012, tatu: Seems to be 'null', but should probably be fixed to \"\"\n+        // Also see [dataformat-xml#162]\n //        assertEquals(\"\", bean.text);\n         assertNull(bean.text);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestStringValues162.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestStringValues162 extends XmlTestBase\n+{\n+    static class Name {\n+        public String first;\n+        public String last;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+\n+    public void testEmptyString162() throws Exception\n+    {\n+        Name name = MAPPER.readValue(\"<name><first>Ryan</first><last></last></name>\",\n+                Name.class);\n+        assertNotNull(name);\n+        assertEquals(\"Ryan\", name.first);\n+        assertEquals(\"\", name.last);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n \n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n-import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n \n     public void setUp() throws Exception\n     {\n         super.setUp();\n-        JacksonXmlModule module = new JacksonXmlModule();\n-        module.setDefaultUseWrapper(false);\n-        _xmlMapper = new XmlMapper(module);\n-        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.PascalCaseStrategy());\n+        _xmlMapper = new XmlMapper()\n+            .setDefaultUseWrapper(false);\n+        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.UpperCamelCaseStrategy());\n         _xmlMapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n     }\n     \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/EmptyPolymorphicTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+// test(s) for [dataformat-xml#111]\n+public class EmptyPolymorphicTest extends XmlTestBase\n+{\n+    static class Data {\n+        public String name;\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+        @JsonSubTypes({ @JsonSubTypes.Type(EmptyProxy.class) })\n+        public Proxy proxy;\n+\n+        public Data() { }\n+        public Data(String n) {\n+            name = n;\n+            proxy = new EmptyProxy();\n+        }\n+    }\n+\n+    static interface Proxy { }\n+\n+    @JsonTypeName(\"empty\")\n+    static class EmptyProxy implements Proxy { }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    protected XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testEmpty() throws Exception\n+    {\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Data(\"Foobar\"));\n+        System.out.println(\"XML:\\n\"+xml);\n+        final Data data = MAPPER.readValue(xml, Data.class);\n+//                \"<data><name>Foobar</name><proxy><empty></empty></proxy></data>\"\n+        assertNotNull(data);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n         public SubTypeWithClassProperty() { }\n         public SubTypeWithClassProperty(String s) { name = s; }\n     }\n-    \n+\n     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n     protected static class BaseTypeWithClassObject { }\n \n         super.setUp();\n         _xmlMapper = new XmlMapper();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassProperty(\"Foobar\"));\n \n         // Type info should be written as an attribute, so:\n-        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n-         *   inclusion, which allows use of attribute over element, so:\n-         */\n         final String exp = \n             \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.dataformat.xml.misc.PolymorphicTypesTest..SubTypeWithClassProperty\\\">\"\n             //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.types.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n     }\n \n     /**\n-     * Test for issue 81\n+     * Test for [dataformat-xml#81]\n      */\n     public void testAsPropertyWithObjectId() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n     {\n         String xml = MAPPER.writeValueAsString(new Simple());\n         assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n-        // [Issue#56]: should work with indentation as well\n+        // [dataformat-xml#56]: should work with indentation as well\n         xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Simple());\n-        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\\n\", xml);\n     }\n \n     public void testDeserializeAsText() throws IOException\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n     /**********************************************************\n      */\n \n-    // Verify [JACKSON-444], Issue #1\n+    // Verify [dataformat-xml#1]\n     public void testSimpleStringBean() throws Exception\n     {\n         StringWrapperBean input = new StringWrapperBean(\"abc\");\n     public void testWithAttr() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new AttrBean());\n-        assertEquals(\"<AttrBean count=\\\"3\\\"/>\", xml);\n+        assertEquals(\"<AttrBean count=\\\"3\\\"/>\\n\", xml);\n         String xml2 = _xmlMapper.writeValueAsString(new AttrBean2());\n-        assertEquals(\"<AttrBean2 count=\\\"3\\\">\\n  <value>14</value>\\n</AttrBean2>\", xml2);\n+        assertEquals(\"<AttrBean2 count=\\\"3\\\">\\n  <value>14</value>\\n</AttrBean2>\\n\", xml2);\n     }\n \n     public void testEmptyElem() throws Exception\n     {\n         PojoFor123 simple = new PojoFor123(\"foobar\");\n         String xml = _xmlMapper.writeValueAsString(simple);\n-        assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\", xml);\n+        assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\\n\", xml);\n     }\n \n     public void testMultiLevel172() throws Exception\n     {\n         Company root = new Company();\n         root.employee.add(new Employee(\"abc\"));\n-        String xml = _xmlMapper.writeValueAsString(root);\n-        assertEquals(\"<Company>\\n\"\n+        String xml = _xmlMapper.writer()\n+                .with(ToXmlGenerator.Feature.WRITE_XML_DECLARATION)\n+                .writeValueAsString(root);\n+        // unify possible apostrophes to quotes\n+        xml = aposToQuotes(xml);\n+        // with indentation, should get linefeeds in prolog/epilog too\n+        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n+                +\"<Company>\\n\"\n                 +\"  <e>\\n\"\n                 +\"    <employee>\\n\"\n                 +\"      <id>abc</id>\\n\"\n                 +\"      <type>FULL_TIME</type>\\n\"\n                 +\"    </employee>\\n\"\n                 +\"  </e>\\n\"\n-                +\"</Company>\",\n+                +\"</Company>\\n\",\n                 xml);\n     }\n }", "timestamp": 1450914899, "metainfo": ""}