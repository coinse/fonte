{"sha": "948d377c7aafb0ed91a244415df07f3f6c106be2", "log": "refactoring", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.dataformat.xml.annotate.*;\n+\n+\n+/**\n+ * Extension of {@link JacksonAnnotationIntrospector} that is needed to support\n+ * additional xml-specific annotation that Jackson provides. Note, however, that\n+ * there is no JAXB annotation support here; that is provided with\n+ * separate introspector (see {@link org.codehaus.jackson.xc.JaxbAnnotationIntrospector}).\n+ */\n+public class JacksonXmlAnnotationIntrospector\n+    extends JacksonAnnotationIntrospector\n+    implements XmlAnnotationIntrospector\n+{    \n+    /*\n+    /**********************************************************************\n+    /* XmlAnnotationIntrospector\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public Boolean isOutputAsAttribute(Annotated ann)\n+    {\n+        JacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\n+        if (prop != null) {\n+            return prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public String findNamespace(Annotated ann)\n+    {\n+        JacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\n+        if (prop != null) {\n+            return prop.namespace();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public QName findWrapperElement(Annotated ann)\n+    {\n+        JacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\n+        if (w != null) {\n+            return new QName(w.namespace(), w.localName());\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public QName findRootElement(Annotated ann)\n+    {\n+        JacksonXmlRootElement root = ann.getAnnotation(JacksonXmlRootElement.class);\n+        if (root != null) {\n+            return new QName(root.namespace(), root.localName());\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Overrides for name, property detection\n+    /**********************************************************************\n+     */\n+    \n+    @Override\n+    public String findSerializationName(AnnotatedField af)\n+    {\n+        JacksonXmlProperty pann = af.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findSerializationName(af);\n+    }\n+\n+    @Override\n+    public String findSerializationName(AnnotatedMethod am)\n+    {\n+        JacksonXmlProperty pann = am.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findSerializationName(am);\n+    }\n+\n+    @Override\n+    public String findDeserializationName(AnnotatedField af)\n+    {\n+        JacksonXmlProperty pann = af.getAnnotation(JacksonXmlProperty.class);\n+        if (pann != null) {\n+            return pann.localName();\n+        }\n+        return super.findDeserializationName(af);\n+    }\n+\n+    @Override\n+    public String findDeserializationName(AnnotatedParameter ap)\n+    {\n+        JacksonXmlProperty pann = ap.getAnnotation(JacksonXmlProperty.class);\n+        // can not return empty String here, so:\n+        if (pann != null) {\n+            String name = pann.localName();\n+            if (name.length() > 0) {\n+                return name;\n+            }\n+        }\n+        return super.findDeserializationName(ap);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Overrides for non-public helper methods\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * We will override this method so that we can return instance\n+     * that cleans up type id property name to be a valid xml name.\n+     */\n+    @Override\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n+    {\n+        return new XmlTypeResolverBuilder();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier;\n+\n+\n+/**\n+ * Module that implements most functionality needed to support producing and\n+ * consuming XML instead of JSON.\n+ */\n+public class JacksonXmlModule extends SimpleModule\n+{\n+    private final static AnnotationIntrospector XML_ANNOTATION_INTROSPECTOR = new JacksonXmlAnnotationIntrospector();\n+    \n+    public JacksonXmlModule()\n+    {\n+        super(\"JackxonXmlModule\", ModuleVersion.instance.version());\n+    }\n+    \n+    @Override\n+    public void setupModule(SetupContext context)\n+    {\n+        // Need to modify BeanSerializer that is used\n+        context.addBeanSerializerModifier(new XmlBeanSerializerModifier());\n+        // as well as AnnotationIntrospector\n+        context.insertAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ModuleVersion.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Helper class used for finding and caching version information\n+ * for this module.\n+ */\n+class ModuleVersion extends VersionUtil\n+{\n+    public final static ModuleVersion instance = new ModuleVersion();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+\n+/**\n+ * Additional extension interface used above and beyond\n+ * {@link AnnotationIntrospector} to handle XML-specific configuration.\n+ */\n+public interface XmlAnnotationIntrospector\n+{\n+    /**\n+     * Method that can be called to figure out generic namespace\n+     * property for an annotated object.\n+     *\n+     * @return Null if annotated thing does not define any\n+     *   namespace information; non-null namespace (which may\n+     *   be empty String) otherwise\n+     */\n+    public String findNamespace(Annotated ann);\n+\n+    /**\n+     * Method used to check whether given annotated element\n+     * (field, method, constructor parameter) has indicator that suggest\n+     * it be output as an XML attribute or not (as element)\n+     */\n+    public Boolean isOutputAsAttribute(Annotated ann);\n+\n+    /**\n+     * Method used to check if specified property has annotation that indicates\n+     * that it should be wrapped in an element; and if so, name to use.\n+     * Note: local name of \"\" is used to indicate that name should default\n+     * to using name (local name and namespace) of property itself.\n+     */\n+    public QName findWrapperElement(Annotated ann);\n+\n+    /**\n+     * Method used to find out name to use for the outermost (root) XML element\n+     * name when serializing (since there is no property that would define it);\n+     * this overrides default name based on type of object.\n+     */\n+    public QName findRootElement(Annotated ann);\n+    \n+    /*\n+    /**********************************************************************\n+    /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n+    /* (potential) XMLAnnotationIntrospector instance\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Extension of <code>AnnotationIntrospector.Pair</code> that can\n+     * also dispatch 'XmlAnnotationIntrospector' methods.\n+     */\n+    public static class Pair extends AnnotationIntrospector.Pair\n+        implements XmlAnnotationIntrospector\n+    {\n+        protected final XmlAnnotationIntrospector _xmlPrimary;\n+        protected final XmlAnnotationIntrospector _xmlSecondary;\n+        \n+        public Pair(AnnotationIntrospector p, AnnotationIntrospector s)\n+        {\n+            super(p, s);\n+            _xmlPrimary = (p instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) p : null;\n+            _xmlSecondary = (s instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) s : null;\n+        }\n+\n+        public static XmlAnnotationIntrospector.Pair instance(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n+            return new XmlAnnotationIntrospector.Pair(a1, a2);\n+        }\n+        \n+        @Override\n+        public String findNamespace(Annotated ann)\n+        {\n+            String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.findNamespace(ann);\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public QName findWrapperElement(Annotated ann)\n+        {\n+            QName value = (_xmlPrimary == null) ? null : _xmlPrimary.findWrapperElement(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.findWrapperElement(ann);\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public QName findRootElement(Annotated ann)\n+        {\n+            QName value = (_xmlPrimary == null) ? null : _xmlPrimary.findRootElement(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.findRootElement(ann);\n+            }\n+            return value;\n+        }\n+        \n+        @Override\n+        public Boolean isOutputAsAttribute(Annotated ann)\n+        {\n+            Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.isOutputAsAttribute(ann);\n+            }\n+            return value;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+\n+import javax.xml.stream.*;\n+\n+import org.codehaus.stax2.io.Stax2ByteArraySource;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.InputAccessor;\n+import com.fasterxml.jackson.core.format.MatchStrength;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n+\n+\n+/**\n+* Factory used for constructing {@link FromXmlParser} and {@link ToXmlGenerator}\n+* instances.\n+*<p>\n+* Implements {@link JsonFactory} since interface for constructing XML backed\n+* parsers and generators is quite similar to dealing with JSON.\n+* \n+* @author tatu\n+*/\n+public class XmlFactory extends JsonFactory\n+{\n+    /**\n+     * Name used to identify JSON format\n+     * (and returned by {@link #getFormatName()}\n+     */\n+    public final static String FORMAT_NAME_XML = \"XML\";\n+\n+    /**\n+     * Bitfield (set of flags) of all parser features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n+\n+    /**\n+     * Bitfield (set of flags) of all generator features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected int _xmlParserFeatures = DEFAULT_XML_PARSER_FEATURE_FLAGS;\n+\n+    protected int _xmlGeneratorFeatures = DEFAULT_XML_GENERATOR_FEATURE_FLAGS;\n+\n+    protected XMLInputFactory _xmlInputFactory;\n+\n+    protected XMLOutputFactory _xmlOutputFactory;\n+\n+    /*\n+    /**********************************************************\n+    /* Factory construction, configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default constructor used to create factory instances.\n+     * Creation of a factory instance is a light-weight operation,\n+     * but it is still a good idea to reuse limited number of\n+     * factory instances (and quite often just a single instance):\n+     * factories are used as context for storing some reused\n+     * processing objects (such as symbol tables parsers use)\n+     * and this reuse only works within context of a single\n+     * factory instance.\n+     */\n+    public XmlFactory() { this(null); }\n+\n+    public XmlFactory(ObjectCodec oc) {\n+        this(oc, null, null);\n+    }\n+\n+    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    {\n+        this(null, xmlIn, xmlOut);\n+    }\n+    \n+    public XmlFactory(ObjectCodec oc,\n+            XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    {\n+        super(oc);\n+        if (xmlIn == null) {\n+            /* 24-Jun-2010, tatu: Ugh. JDK authors seem to waffle on what the name of\n+             *   factory constructor method is...\n+             */\n+            //xmlIn = XMLInputFactory.newFactory();\n+            xmlIn = XMLInputFactory.newInstance();\n+        }\n+        if (xmlOut == null) {\n+            //xmlOut = XMLOutputFactory.newFactory();\n+            xmlOut = XMLOutputFactory.newInstance();\n+        }\n+        // Better ensure namespaces get built properly, so:\n+        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n+        // and for parser, force coalescing as well (much simpler to use)\n+        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, true);\n+        _xmlInputFactory = xmlIn;\n+        _xmlOutputFactory = xmlOut;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, parser settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified XML parser feature.\n+     */\n+    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n+    {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified XML parser feature.\n+     */\n+    public XmlFactory enable(FromXmlParser.Feature f) {\n+        _xmlParserFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified XML parser feature.\n+     */\n+    public XmlFactory disable(FromXmlParser.Feature f) {\n+        _xmlParserFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Checked whether specified XML parser feature is enabled.\n+     */\n+    public final boolean isEnabled(FromXmlParser.Feature f) {\n+        return (_xmlParserFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Configuration, generator settings\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified XML generator feature.\n+     */\n+    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Method for enabling specified XML generator feature.\n+     */\n+    public XmlFactory enable(ToXmlGenerator.Feature f) {\n+        _xmlGeneratorFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified XML generator feature.\n+     */\n+    public XmlFactory disable(ToXmlGenerator.Feature f) {\n+        _xmlGeneratorFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Check whether specified XML generator feature is enabled.\n+     */\n+    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n+        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional configuration\n+    /**********************************************************\n+     */\n+\n+    public void setXMLInputFactory(XMLInputFactory f) {\n+        _xmlInputFactory = f;\n+    }\n+\n+    public void setXMLOutputFactory(XMLOutputFactory f) {\n+        _xmlOutputFactory = f;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Format detection functionality (since 1.8)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns short textual id identifying format\n+     * this factory supports.\n+     *<p>\n+     * Note: sub-classes should override this method; default\n+     * implementation will return null for all sub-classes\n+     */\n+    public String getFormatName()\n+    {\n+        return FORMAT_NAME_XML;\n+    }\n+\n+    public MatchStrength hasFormat(InputAccessor acc) throws IOException\n+    {\n+        return hasXMLFormat(acc);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden parts of public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     *<p>\n+     * note: co-variant return type\n+     */\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(OutputStream out, JsonEncoding enc)\n+        throws IOException\n+    {\n+        // false -> we won't manage the stream unless explicitly directed to\n+        IOContext ctxt = _createContext(out, false);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(Writer out)\n+        throws IOException\n+    {\n+        IOContext ctxt = _createContext(out, false);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+\n+    @Override\n+    public ToXmlGenerator createJsonGenerator(File f, JsonEncoding enc)\n+        throws IOException\n+    {\n+        OutputStream out = new FileOutputStream(f);\n+        // true -> yes, we have to manage the stream since we created it\n+        IOContext ctxt = _createContext(out, true);\n+        ctxt.setEncoding(enc);\n+        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, _createXmlWriter(out));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden internal factory methods\n+    /**********************************************************\n+     */\n+\n+    //protected IOContext _createContext(Object srcRef, boolean resourceManaged)\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(InputStream in, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(in);\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(Reader r, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(r);\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * parser.\n+     */\n+    @Override\n+    protected FromXmlParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        XMLStreamReader sr;\n+        try {\n+            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n+            sr = _initializeXmlReader(sr);\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+        return new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n+                _objectCodec, sr);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal factory methods\n+    /**********************************************************************\n+     */\n+\n+    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n+    {\n+        try {\n+            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n+    {\n+        try {\n+            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n+        } catch (XMLStreamException e) {\n+            return StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n+    {\n+        // And just for Sun Stax parser (JDK default), seems that we better define default namespace\n+        // (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\n+        sw.setDefaultNamespace(\"\");\n+        return sw;\n+    }\n+\n+    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n+    {\n+        // for now, nothing to do... except let's find the root element\n+        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n+            ;\n+        }\n+        return sr;\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal methods, format auto-detection\n+    /**********************************************************************\n+     */\n+\n+    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n+    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n+    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n+\n+    private final static byte BYTE_x = (byte) 'x';\n+    private final static byte BYTE_m = (byte) 'm';\n+    private final static byte BYTE_l = (byte) 'l';\n+    private final static byte BYTE_D = (byte) 'D';\n+\n+    private final static byte BYTE_LT = (byte) '<';\n+    private final static byte BYTE_QMARK = (byte) '?';\n+    private final static byte BYTE_EXCL = (byte) '!';\n+    private final static byte BYTE_HYPHEN = (byte) '-';\n+    \n+    /**\n+     * Method that tries to figure out if content seems to be in some kind\n+     * of XML format.\n+     * Note that implementation here is not nearly as robust as what underlying\n+     * Stax parser will do; the idea is to first support common encodings,\n+     * then expand as needed (for example, it is not all that hard to support\n+     * UTF-16; but it is some work and not needed quite yet)\n+     */\n+    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n+    {\n+        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n+         * we would actually see the XML declaration\n+         */\n+        if (!acc.hasMoreBytes()) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        byte b = acc.nextByte();\n+        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n+        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_2) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_3) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = acc.nextByte();\n+        }\n+        // otherwise: XML declaration?\n+        boolean maybeXmlDecl = (b == BYTE_LT);\n+        if (!maybeXmlDecl) {\n+            int ch = skipSpace(acc, b);\n+            if (ch < 0) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = (byte) ch;\n+            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n+            if (b != BYTE_LT) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+        }\n+        if (!acc.hasMoreBytes()) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        b = acc.nextByte();\n+        // Couple of choices here\n+        if (b == BYTE_QMARK) { // <?\n+            b = acc.nextByte();\n+            if (b == BYTE_x) {\n+                if (maybeXmlDecl) {\n+                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n+                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n+                            return MatchStrength.FULL_MATCH;\n+                        }\n+                    }\n+                }\n+                // but even with just partial match, we ought to be fine\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+            // Ok to start with some other char too; just not xml declaration\n+            if (validXmlNameStartChar(acc, b)) {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+        } else if (b == BYTE_EXCL) {\n+            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n+             * <![CDATA[ ]]> can NOT come outside of root\n+             */\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = acc.nextByte();\n+            if (b == BYTE_HYPHEN) {\n+                if (!acc.hasMoreBytes()) {\n+                    return MatchStrength.INCONCLUSIVE;\n+                }\n+                if (acc.nextByte() == BYTE_HYPHEN) {\n+                    return MatchStrength.SOLID_MATCH;\n+                }\n+            } else if (b == BYTE_D) {\n+                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n+            }\n+        } else {\n+            // maybe root element? Just needs to match first char.\n+            if (validXmlNameStartChar(acc, b)) {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+        }\n+        return MatchStrength.NO_MATCH;\n+    }\n+\n+    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n+        throws IOException\n+    {\n+        /* Can make it actual real XML check in future; for now we do just crude\n+         * check for ASCII range\n+         */\n+        int ch = (int) b & 0xFF;\n+        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n+            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n+        throws IOException\n+    {\n+        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != matchStr.charAt(i)) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+        }\n+        return fullMatchStrength;\n+    }\n+    \n+    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n+    {\n+        while (true) {\n+            int ch = (int) b & 0xFF;\n+            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n+                return ch;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return -1;\n+            }\n+            b = acc.nextByte();\n+            ch = (int) b & 0xFF;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n+\n+\n+/**\n+ * Customized {@link ObjectMapper} that will read and write XML instead of JSON,\n+ * using XML-backed {@link JsonFactory} implementation ({@link XmlFactory}).\n+ *<p>\n+ * Mapper itself overrides some aspects of functionality to try to handle\n+ * data binding aspects as similar to JAXB as possible.\n+ */\n+public class XmlMapper extends ObjectMapper\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public XmlMapper()\n+    {\n+        this(new XmlFactory());\n+    }\n+    \n+    public XmlMapper(XmlFactory xmlFactory)\n+    {\n+        /* Need to override serializer provider (due to root name handling);\n+         * deserializer provider fine as is\n+         */\n+        super(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n+        // but all the rest is done via Module interface!\n+        this.registerModule(new JacksonXmlModule());\n+    }\n+\n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     */\n+    @Override\n+    public Version version() {\n+        return ModuleVersion.instance.version();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access to configuration settings\n+    /**********************************************************\n+     */\n+\n+    public ObjectMapper configure(ToXmlGenerator.Feature f, boolean state) {\n+        ((XmlFactory)_jsonFactory).configure(f, state);\n+        return this;\n+    }\n+\n+    public ObjectMapper configure(FromXmlParser.Feature f, boolean state) {\n+        ((XmlFactory)_jsonFactory).configure(f, state);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * XML indentation differs from JSON indentation, thereby\n+     * need to change default pretty-printer\n+     */\n+    @Override\n+    protected PrettyPrinter _defaultPrettyPrinter() {\n+        return null; // new DefaultPrettyPrinter();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.MinimalClassNameIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Custom specialization of {@link StdTypeResolverBuilder}; needed so that\n+ * type id property name can be modified as necessary to make it legal\n+ * XML element or attribute name.\n+ */\n+public class XmlTypeResolverBuilder extends StdTypeResolverBuilder\n+{\n+    @Override\n+    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n+    {\n+        super.init(idType, idRes);\n+        if (_typeProperty != null) {\n+            _typeProperty = sanitizeXmlTypeName(_typeProperty);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n+    {\n+        // ok to have null/empty; will restore to use defaults\n+        if (typeIdPropName == null || typeIdPropName.length() == 0) {\n+            typeIdPropName = _idType.getDefaultPropertyName();\n+        }\n+        _typeProperty = sanitizeXmlTypeName(typeIdPropName);\n+        return this;\n+    }\n+\n+    @Override\n+    protected TypeIdResolver idResolver(MapperConfig<?> config,\n+            JavaType baseType, Collection<NamedType> subtypes,\n+            boolean forSer, boolean forDeser)\n+    {\n+        if (_customIdResolver != null) {\n+            return _customIdResolver;\n+        }\n+        // Only override handlings of class, minimal class; name is good as is\n+        switch (_idType) {\n+        case CLASS:\n+            return new XmlClassNameIdResolver(baseType, config.getTypeFactory());\n+        case MINIMAL_CLASS:\n+            return new XmlMinimalClassNameIdResolver(baseType, config.getTypeFactory());\n+        }\n+        return super.idResolver(config, baseType, subtypes, forSer, forDeser);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal helper methods\n+    /**********************************************************************\n+     */\n+    \n+    /**\n+     * Since XML names can not contain all characters JSON names can, we may\n+     * need to replace characters. Let's start with trivial replacement of\n+     * ASCII characters that can not be included.\n+     */\n+    protected static String sanitizeXmlTypeName(String name)\n+    {\n+        StringBuilder sb = new StringBuilder(name);\n+        int changes = 0;\n+        for (int i = 0, len = name.length(); i < len; ++i) {\n+            char c = name.charAt(i);\n+            if (c > 127) continue;\n+            if (c >= 'a' && c <= 'z') continue;\n+            if (c >= 'A' && c <= 'Z') continue;\n+            if (c >= '0' && c <= '9') continue;\n+            if (c == '_' || c == '.' || c == '-') continue;\n+            // Ok, need to replace\n+            ++changes;\n+            sb.setCharAt(i, '_');\n+        }\n+        if (changes == 0) {\n+            return name;\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Helper method for encoding regular Java class name in form that\n+     * can be used as XML element name.\n+     */\n+    protected static String encodeXmlClassName(String className)\n+    {\n+        /* For now, let's just replace '$'s with double dots...\n+         * Perhaps make configurable in future?\n+         */\n+        int ix = className.lastIndexOf('$');\n+        if (ix >= 0) {\n+            StringBuilder sb = new StringBuilder(className);\n+            do {\n+                sb.replace(ix, ix+1, \"..\");\n+                ix = className.lastIndexOf('$', ix-1);\n+            } while (ix >= 0);\n+            className = sb.toString();\n+        }\n+        return className;\n+    }\n+\n+    /**\n+     * Helper method for decoding \"XML safe\" Java class name back into\n+     * actual class name\n+     */\n+    protected static String decodeXmlClassName(String className)\n+    {\n+        int ix = className.lastIndexOf(\"..\");\n+        if (ix >= 0) {\n+            StringBuilder sb = new StringBuilder(className);\n+            do {\n+                sb.replace(ix, ix+2, \"$\");\n+                ix = className.lastIndexOf(\"..\", ix-1);\n+            } while (ix >= 0);\n+            className = sb.toString();\n+        }\n+        return className;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Customized class name handlers\n+    /**********************************************************************\n+     */\n+\n+    protected static class XmlClassNameIdResolver\n+        extends ClassNameIdResolver\n+    {\n+        public XmlClassNameIdResolver(JavaType baseType, TypeFactory typeFactory)\n+        {\n+            super(baseType, typeFactory);\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            return encodeXmlClassName(super.idFromValue(value));\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            return super.typeFromId(decodeXmlClassName(id));\n+        }\n+    }\n+\n+    protected static class XmlMinimalClassNameIdResolver\n+        extends MinimalClassNameIdResolver\n+    {\n+        public XmlMinimalClassNameIdResolver(JavaType baseType, TypeFactory typeFactory)\n+        {\n+            super(baseType, typeFactory);\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            return encodeXmlClassName(super.idFromValue(value));\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            return super.typeFromId(decodeXmlClassName(id));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotate/JacksonXmlElementWrapper.java\n+package com.fasterxml.jackson.dataformat.xml.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation that is similar to JAXB <code>javax.xml.bind.annotation.XmlElementWrapper</code>,\n+ * to indicate wrapper element to use (if any) for Collection types (arrays,\n+ * <code>java.util.Collection</code>). If defined, a separate container (wrapper) element\n+ * is used; if not, entries are written without wrapping.\n+ * Name of wrapper element defaults to name of the property but can be explicitly defined\n+ * to something else.\n+ * \n+ * @author tatu\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JacksonXmlElementWrapper\n+{\n+    String namespace() default \"\";\n+    String localName() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotate/JacksonXmlProperty.java\n+package com.fasterxml.jackson.dataformat.xml.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation that can be used to provide XML-specific configuration\n+ * for properties, above and beyond what\n+ * {@link org.codehaus.jackson.annotate.JsonProperty} contains.\n+ * It is an alternative to using JAXB annotations.\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JacksonXmlProperty\n+{\n+    boolean isAttribute() default false;\n+    String namespace() default \"\";\n+    String localName() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotate/JacksonXmlRootElement.java\n+package com.fasterxml.jackson.dataformat.xml.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation that can be used to define name of root element used\n+ * for the root-level object when serialized, which normally uses\n+ * name of the type (class). It is similar to JAXB <code>XmlRootElement</code>.\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JacksonXmlRootElement\n+{\n+    String namespace() default \"\";\n+    String localName() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotate/package-info.java\n+/**\n+ * Package that contains additional annotations that can be\n+ * used to configure XML-specific aspects of serialization\n+ * and deserialization\n+ */\n+package com.fasterxml.jackson.dataformat.xml.annotate;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.json.JsonReadContext;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlTokenStream;\n+\n+\n+/**\n+ * {@link JsonParser} implementation that exposes XML structure as\n+ * set of JSON events that can be used for data binding.\n+ */\n+public class FromXmlParser\n+    extends ParserMinimalBase\n+{\n+    /**\n+     * Enumeration that defines all togglable features for XML parsers\n+     */\n+    public enum Feature {\n+        DUMMY_PLACEHOLDER(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+\n+    /**\n+     * In cases where a start element has both attributes and non-empty textual\n+     * value, we have to create a bogus property; we will use this as\n+     * the property name.\n+     */\n+    protected final static String UNNAMED_TEXT_PROPERTY = \"\";\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link FromXmlParser.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+    \n+    protected ObjectCodec _objectCodec;\n+\n+    /*\n+    /**********************************************************\n+    /* I/O state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Information about parser context, context in which\n+     * the next token is to be parsed (root, array, object).\n+     */\n+    protected JsonReadContext _parsingContext;\n+    \n+    protected final XmlTokenStream _xmlTokens;\n+\n+    /**\n+     * We need special handling to keep track of whether a value\n+     * may be exposed as simple leaf value.\n+     */\n+    protected boolean _mayBeLeaf;\n+\n+    protected JsonToken _nextToken;\n+\n+    protected String _currText;\n+    \n+    /*\n+    /**********************************************************\n+    /* Parsing state, parsed values\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n+     * we better reuse it for remainder of content.\n+     */\n+    protected ByteArrayBuilder _byteArrayBuilder = null;\n+\n+    /**\n+     * We will hold on to decoded binary data, for duration of\n+     * current event, so that multiple calls to\n+     * {@link #getBinaryValue} will not need to decode data more\n+     * than once.\n+     */\n+    protected byte[] _binaryValue;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamReader xmlReader)\n+    {\n+        super(genericParserFeatures);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _objectCodec = codec;\n+        _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+        // and thereby start a scope\n+        _nextToken = JsonToken.START_OBJECT;\n+        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public FromXmlParser enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public FromXmlParser disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public FromXmlParser configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamReader getStaxReader() {\n+        return _xmlTokens.getXmlReader();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonParser impl\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to get the name associated with\n+     * the current event.\n+     */\n+    @Override\n+    public String getCurrentName()\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-395]: start markers require information from parent\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonReadContext parent = _parsingContext.getParent();\n+            return parent.getCurrentName();\n+        }\n+        return _parsingContext.getCurrentName();\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            try {\n+                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n+                    _xmlTokens.closeCompletely();\n+                } else {\n+                    _xmlTokens.close();\n+                }\n+            } finally {\n+                // as per [JACKSON-324], do in finally block\n+                // Also, internal buffer(s) can now be released as well\n+                _releaseBuffers();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    @Override\n+    public JsonReadContext getParsingContext()\n+    {\n+        return _parsingContext;\n+    }\n+\n+    /**\n+     * Method that return the <b>starting</b> location of the current\n+     * token; that is, position of the first character from input\n+     * that starts the current token.\n+     */\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        return _xmlTokens.getTokenLocation();\n+    }\n+\n+    /**\n+     * Method that returns location of the last processed character;\n+     * usually for error reporting purposes\n+     */\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        return _xmlTokens.getCurrentLocation();\n+    }\n+\n+    /**\n+     * Since xml representation can not really distinguish between array\n+     * and object starts (both are represented with elements), this method\n+     * is overridden and taken to mean that expecation is that the current\n+     * start element is to mean 'start array', instead of default of\n+     * 'start object'.\n+     */\n+    @Override\n+    public boolean isExpectedStartArrayToken() {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.START_OBJECT) {\n+            _currToken = JsonToken.START_ARRAY;\n+            // Ok: must replace current context with array as well\n+            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            // And just in case a field name was to be returned, wipe it\n+            _nextToken = null;\n+            return true;\n+        }\n+        return (t == JsonToken.START_ARRAY);\n+    }\n+    \n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        if (_nextToken != null) {\n+            JsonToken t = _nextToken;\n+            _currToken = t;\n+            _nextToken = null;\n+            switch (t) {\n+            case START_OBJECT:\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                break;\n+            case START_ARRAY:\n+                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+                break;\n+            case END_OBJECT:\n+            case END_ARRAY:\n+                _parsingContext = _parsingContext.getParent();\n+                break;\n+            case FIELD_NAME:\n+                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                break;\n+            default: // VALUE_STRING, VALUE_NULL\n+                // should be fine as is?\n+            }\n+            return t;\n+        }\n+\n+        int token = _xmlTokens.next();\n+        \n+        /* Need to have a loop just because we may have to eat/convert\n+         * a start-element that indicates an array element.\n+         */\n+        while (token == XmlTokenStream.XML_START_ELEMENT) {\n+\n+            // If we thought we might get leaf, no such luck\n+            if (_mayBeLeaf) {\n+                // leave _mayBeLeaf set, as we start a new context\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            if (_parsingContext.inArray()) {\n+                /* Yup: in array, so this element could be verified; but it won't be reported\n+                 * anyway, and we need to process following event.\n+                 */\n+                token = _xmlTokens.next();\n+                _mayBeLeaf = true;\n+                continue;\n+            }\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            _mayBeLeaf = true;\n+            /* Ok: in array context we need to skip reporting field names. But what's the best way\n+             * to find next token?\n+             * \n+             */\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        }\n+\n+        // Ok; beyond start element, what do we get?\n+        switch (token) {\n+        case XmlTokenStream.XML_END_ELEMENT:\n+            // Simple, except that if this is a leaf, need to suppress end:\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                return (_currToken = JsonToken.VALUE_NULL);\n+            }\n+            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+            _parsingContext = _parsingContext.getParent();\n+            return _currToken;\n+            \n+        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+            // If there was a chance of leaf node, no more...\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _currText = _xmlTokens.getText();\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            _mayBeLeaf = false;\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+            _currText = _xmlTokens.getText();\n+            return (_currToken = JsonToken.VALUE_STRING);\n+        case XmlTokenStream.XML_TEXT:\n+            _currText = _xmlTokens.getText();\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                // Also: must skip following END_ELEMENT\n+                _xmlTokens.skipEndElement();\n+                return (_currToken = JsonToken.VALUE_STRING);\n+            }\n+            // If not a leaf, need to transform into property...\n+            _parsingContext.setCurrentName(UNNAMED_TEXT_PROPERTY);\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_END:\n+            return (_currToken = null);\n+        }\n+        // should never get here\n+        _throwInternal();\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText() throws IOException, JsonParseException\n+    {\n+        switch (_currToken) {\n+        case FIELD_NAME:\n+            return getCurrentName();\n+        case VALUE_STRING:\n+            return _currText;\n+        }\n+        return (_currToken == null) ? null : _currToken.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? null : text.toCharArray();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? 0 : text.length();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return 0;\n+    }\n+\n+    /**\n+     * XML input actually would offer access to character arrays; but since\n+     * we must coalesce things it cannot really be exposed.\n+     */\n+    @Override\n+    public boolean hasTextCharacters()\n+    {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+        // no way to embed POJOs for now...\n+        return null;\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_binaryValue == null) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+        }        \n+        return _binaryValue;\n+    }\n+    \n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+    \n+        final String str = getText();\n+        int ptr = 0;\n+        int len = str.length();\n+\n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0, null);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1, null);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2, null);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3, null);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+        return builder.toByteArray();\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new JsonParseException(base, JsonLocation.NA);\n+    }\n+\n+    protected void _reportBase64EOF()\n+        throws JsonParseException\n+    {\n+        throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Numeric accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls for stuff from JsonParser\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when an EOF is encountered between tokens.\n+     * If so, it may be a legitimate EOF, but only iff there\n+     * is no open non-root context.\n+     */\n+    @Override\n+    protected void _handleEOF() throws JsonParseException\n+    {\n+        if (!_parsingContext.inRoot()) {\n+            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * parser.\n+     */\n+    protected void _releaseBuffers() throws IOException\n+    {\n+        // anything we can/must release? Underlying parser should do all of it, for now?\n+    }\n+\n+    protected ByteArrayBuilder _getByteArrayBuilder()\n+    {\n+        if (_byteArrayBuilder == null) {\n+            _byteArrayBuilder = new ByteArrayBuilder();\n+        } else {\n+            _byteArrayBuilder.reset();\n+        }\n+        return _byteArrayBuilder;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector;\n+\n+\n+\n+/**\n+ * Alternative {@link org.codehaus.jackson.map.AnnotationIntrospector} implementation that\n+ * builds on introspector from Jackson XC package that uses JAXB annotations,\n+ * not Jackson annotations.\n+ */\n+public class XmlJaxbAnnotationIntrospector\n+    extends JaxbAnnotationIntrospector\n+    implements XmlAnnotationIntrospector\n+{\n+    @Override\n+    public String findNamespace(Annotated ann)\n+    {\n+        String ns = null;\n+\n+        /* 10-Oct-2009, tatus: I suspect following won't work quite\n+         *  as well as it should, wrt. defaulting to package.\n+         *  But it should work well enough to get things started --\n+         *  currently this method is not needed, and when it is,\n+         *  this can be improved.\n+         */\n+        if (ann instanceof AnnotatedClass) {\n+            /* For classes, it must be @XmlRootElement. Also, we do\n+             * want to use defaults from package, base class\n+             */\n+            XmlRootElement elem = findRootElementAnnotation((AnnotatedClass) ann);\n+            if (elem != null) {\n+                ns = elem.namespace();\n+            }\n+        } else {\n+            // For others, XmlElement or XmlAttribute work (anything else?)\n+            XmlElement elem = findAnnotation(XmlElement.class, ann, false, false, false);\n+            if (elem != null) {\n+                ns = elem.namespace();\n+            }\n+            if (ns == null || MARKER_FOR_DEFAULT.equals(ns)) {\n+                XmlAttribute attr = findAnnotation(XmlAttribute.class, ann, false, false, false);\n+                if (attr != null) {\n+                    ns = attr.namespace();\n+                }\n+            }\n+        }\n+        // JAXB uses marker for \"not defined\"\n+        if (MARKER_FOR_DEFAULT.equals(ns)) {\n+            ns = null;\n+        }\n+        return ns;\n+    }\n+\n+    /**\n+     * Here we assume fairly simple logic; if there is <code>XmlAttribute</code> to be found,\n+     * we consider it an attibute; if <code>XmlElement</code>, not-an-attribute; and otherwise\n+     * we will consider there to be no information.\n+     * Caller is likely to default to considering things as elements.\n+     */\n+    @Override\n+    public Boolean isOutputAsAttribute(Annotated ann)\n+    {\n+        XmlAttribute attr = findAnnotation(XmlAttribute.class, ann, false, false, false);\n+        if (attr != null) {\n+            return Boolean.TRUE;\n+        }\n+        XmlElement elem = findAnnotation(XmlElement.class, ann, false, false, false);\n+        if (elem != null) {\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public QName findWrapperElement(Annotated ann)\n+    {\n+        XmlElementWrapper w = findAnnotation(XmlElementWrapper.class, ann, false, false, false);\n+        if (w != null) {\n+            return new QName(handleJaxbDefault(w.namespace()), handleJaxbDefault(w.name()));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public QName findRootElement(Annotated ann)\n+    {\n+        XmlRootElement root = findAnnotation(XmlRootElement.class, ann, false, false, false);\n+        if (root != null) {\n+            return new QName(handleJaxbDefault(root.namespace()), handleJaxbDefault(root.name()));\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Helper methods\n+    /**********************************************************************\n+     */\n+    \n+    private XmlRootElement findRootElementAnnotation(AnnotatedClass ac)\n+    {\n+        // Yes, check package, no class (already included), yes superclasses\n+        return findAnnotation(XmlRootElement.class, ac, true, false, true);\n+    }\n+\n+    private String handleJaxbDefault(String value)\n+    {\n+        return MARKER_FOR_DEFAULT.equals(value) ? \"\" : value;\n+    }\n+\n+    /* NOTE: copied verbatim from Jackson 1.9, since its visibility was\n+     * lowered (accidentally...)\n+     */\n+    protected <A extends Annotation> A findAnnotation(Class<A> annotationClass, Annotated annotated,\n+            boolean includePackage, boolean includeClass, boolean includeSuperclasses)\n+    {\n+        A annotation = annotated.getAnnotation(annotationClass);\n+        if (annotation != null) {\n+            return annotation;\n+        }\n+        Class<?> memberClass = null;\n+        if (annotated instanceof AnnotatedParameter) {\n+            memberClass = ((AnnotatedParameter) annotated).getDeclaringClass();\n+        } else {\n+            AnnotatedElement annType = annotated.getAnnotated();\n+            if (annType instanceof Member) {\n+                memberClass = ((Member) annType).getDeclaringClass();\n+                if (includeClass) {\n+                    annotation = (A) memberClass.getAnnotation(annotationClass);\n+                    if (annotation != null) {\n+                        return annotation;\n+                    }\n+                }\n+            } else if (annType instanceof Class<?>) {\n+                memberClass = (Class<?>) annType;\n+            } else {\n+                throw new IllegalStateException(\"Unsupported annotated member: \" + annotated.getClass().getName());\n+            }\n+        }\n+        if (memberClass != null) {\n+            if (includeSuperclasses) {\n+                Class<?> superclass = memberClass.getSuperclass();\n+                while (superclass != null && superclass != Object.class) {\n+                    annotation = (A) superclass.getAnnotation(annotationClass);\n+                    if (annotation != null) {\n+                        return annotation;\n+                    }\n+                    superclass = superclass.getSuperclass();\n+                }\n+            }\n+            if (includePackage) {\n+                Package pkg = memberClass.getPackage();\n+                if (pkg != null) {\n+                    return memberClass.getPackage().getAnnotation(annotationClass);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/package-info.java\n+/**\n+ * Package that contains XML-based backends which can serialize POJOs\n+ * to and deserialize from XML, using Stax XML parsers and generators\n+ * for XML processing and mostly standard Jackson data binding otherwise.\n+ */\n+package com.fasterxml.jackson.dataformat.xml;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import org.codehaus.stax2.XMLStreamWriter2;\n+import org.codehaus.stax2.ri.Stax2WriterAdapter;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.GeneratorBase;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.json.JsonWriteContext;\n+import com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;\n+import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n+\n+\n+/**\n+ * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n+ * Operation requires calling code (usually either standard Jackson serializers,\n+ * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n+ * additional configuration calls beyond regular {@link JsonGenerator} API,\n+ * mostly to pass namespace information.\n+ */\n+public final class ToXmlGenerator\n+    extends GeneratorBase\n+{\n+    /**\n+     * If we support optional definition of element names, this is the element\n+     * name to use...\n+     */\n+    protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n+    \n+    /**\n+     * Enumeration that defines all togglable extra XML-specific features\n+     */\n+    public enum Feature {\n+        /**\n+         * Feature that controls whether XML declaration should be written before\n+         * when generator is initialized (true) or not (false)\n+         */\n+        WRITE_XML_DECLARATION(false),\n+\n+        /**\n+         * Feature that controls whether output should be done as XML 1.1; if so,\n+         * certain aspects may differ from default (1.0) processing: for example,\n+         * XML declaration will be automatically added (regardless of setting\n+         * <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n+         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n+         * control characters (Ascii codes 0 through 31) as well as additional linefeeds\n+         * and name characters.\n+         */\n+        WRITE_XML_1_1(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    final protected XMLStreamWriter2 _xmlWriter;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link ToXmlGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+\n+    /*\n+    /**********************************************************\n+    /* XML Output state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element or attribute name to use for next output call.\n+     * Assigned by either code that initiates serialization\n+     * or bean serializer.\n+     */\n+    protected QName _nextName = null;\n+\n+    /**\n+     * Marker flag that indicates whether next name to write\n+     * implies an attribute (true) or element (false)\n+     */\n+    protected boolean _nextIsAttribute = false;\n+    \n+    /**\n+     * To support proper serialization of arrays it is necessary to keep\n+     * stack of element names, so that we can \"revert\" to earlier \n+     */\n+    protected LinkedList<QName> _elementNameStack = new LinkedList<QName>();\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator(IOContext ctxt, int genericGeneratorFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamWriter sw)\n+    {\n+        super(genericGeneratorFeatures, codec);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n+    }\n+\n+    /**\n+     * Method called before writing any other output, to optionally\n+     * output XML declaration.\n+     */\n+    public void initGenerator()  throws IOException, JsonGenerationException\n+    {\n+        try {\n+            if ((_xmlFeatures & Feature.WRITE_XML_1_1.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n+            } else if ((_xmlFeatures & Feature.WRITE_XML_DECLARATION.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public ToXmlGenerator disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public ToXmlGenerator configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamWriter getStaxWriter() {\n+        return _xmlWriter;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, passing XML specific settings\n+    /**********************************************************\n+     */\n+\n+    public void setNextIsAttribute(boolean isAttribute)\n+    {\n+        _nextIsAttribute = isAttribute;\n+    }\n+\n+    public final void setNextName(QName name)\n+    {\n+        _nextName = name;\n+    }\n+\n+    /**\n+     * Methdod called when a structured (collection, array, map) is being\n+     * output.\n+     * \n+     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n+     * @param wrappedName Element used around individual content items (can not\n+     *   be null)\n+     */\n+    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+        this.setNextName(wrappedName);\n+    }\n+\n+    /**\n+     * Method called after a structured collection output has completed\n+     */\n+    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        // First: wrapper to close?\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeEndElement();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator method overrides\n+    /**********************************************************\n+     */\n+    \n+    /* Most overrides in this section are just to make methods final,\n+     * to allow better inlining...\n+     */\n+\n+    @Override\n+    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    {\n+        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        // Should this ever get called?\n+        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n+        setNextName(new QName(ns, name));\n+    }\n+    \n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+    }\n+    \n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            _handleStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        _writeContext = _writeContext.getParent();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            _handleEndObject();\n+        }\n+    }\n+\n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleStartObject() throws IOException, JsonGenerationException\n+    {\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // Need to keep track of names to make Lists work correctly\n+        _elementNameStack.addLast(_nextName);\n+        try {\n+            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleEndObject() throws IOException, JsonGenerationException\n+    {\n+        // We may want to repeat same element, so:\n+        _nextName = _elementNameStack.removeLast();\n+        try {\n+            // note: since attributes don't nest, can only have one attribute active, so:\n+            _nextIsAttribute = false;\n+            _xmlWriter.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+    \n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) { // must write attribute name and value with one call\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text);\n+                _xmlWriter.writeEndElement();\n+            } \n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }    \n+    \n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        writeString(text.getValue());\n+    }\n+    \n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, unprocessed (\"raw\")\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException\n+    {\n+        writeRaw(String.valueOf(c));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, base64-encoded binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        if (data == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write Binary value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                // Stax2 API only has 'full buffer' write method:\n+                byte[] fullBuffer = toFullBuffer(data, offset, len);\n+                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBinary(data, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    private byte[] toFullBuffer(byte[] data, int offset, int len)\n+    {\n+        // might already be ok:\n+        if (offset == 0 && len == data.length) {\n+            return data;\n+        }\n+        byte[] result = new byte[len];\n+        if (len > 0) {\n+            System.arraycopy(data, offset, result, 0, len);\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, primitive\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write boolean value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), state);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBoolean(state);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write null value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // !!! TODO: proper use of 'xsd:isNil'\n+        try {\n+            if (_nextIsAttribute) {\n+                /* With attributes, best just leave it out, right? (since there's no way\n+                 * to use 'xsi:nil')\n+                 */\n+            } else {\n+                _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(int i) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInt(i);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(long l) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeLong(l);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(double d) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDouble(d);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(float f) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeFloat(f);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException\n+    {\n+        if (dec == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDecimalAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDecimal(dec);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException\n+    {\n+        if (v == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntegerAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), v);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInteger(v);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException,JsonGenerationException, UnsupportedOperationException\n+    {\n+        writeString(encodedValue);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations, overrides for other methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected final void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeValue();\n+        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n+            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n+        }\n+    }\n+\n+    /**\n+     * Standard JSON indenter does not work well with XML, use\n+     * default XML indenter instead.\n+     */\n+    @Override\n+    public final JsonGenerator useDefaultPrettyPrinter()\n+    {\n+        return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void flush() throws IOException\n+    {\n+        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n+            try {\n+                _xmlWriter.flush();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+//        boolean wasClosed = _closed;\n+        super.close();\n+\n+        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n+         *   scopes.\n+         */\n+        // First: let's see that we still have buffers...\n+        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n+            try {\n+                while (true) {\n+                    JsonStreamContext ctxt = getOutputContext();\n+                    if (ctxt.inArray()) {\n+                        writeEndArray();\n+                    } else if (ctxt.inObject()) {\n+                        writeEndObject();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n+                 *   hit by this as a collateral problem in some cases. Yuck.\n+                 */\n+                throw new JsonGenerationException(e);\n+            }\n+        }\n+        try {\n+            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n+                _xmlWriter.closeCompletely();\n+            } else {\n+                _xmlWriter.close();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void _releaseBuffers() {\n+        // Nothing to do here, as we have no buffers\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected void handleMissingName()\n+    {\n+        throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+\n+/**\n+ * Property writer sub-class used for handling element wrapping needed for serializing\n+ * collection (array, Collection; possibly Map) types.\n+ */\n+public class XmlBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /*\n+    /**********************************************************\n+    /* Config settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element name used as wrapper for collection.\n+     */\n+    protected final QName _wrapperName;\n+\n+    /**\n+     * Element name used for items in the collection\n+     */\n+    protected final QName _wrappedName;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName)\n+    {\n+        super(wrapped);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+    }\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName,\n+            JsonSerializer<Object> serializer)\n+    {\n+        super(wrapped);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+\n+        assignSerializer(serializer);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridden version so that we can wrap output within wrapper element if\n+     * and as necessary.\n+     */\n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        /* Hmmh. Does the default null serialization work ok here? For now let's assume\n+         * it does; can change later if not.\n+         */\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                jgen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, jgen, prov);\n+            }\n+            return;\n+        }\n+\n+        // then find serializer to use\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        // and then see if we must suppress certain values (default, empty)\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n+\n+        // Ok then; addition we want to do is to add wrapper element, and that's what happens here\n+        ToXmlGenerator xmlGen = (ToXmlGenerator) jgen;\n+        xmlGen.startWrappedValue(_wrapperName, _wrappedName);\n+        \n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+        xmlGen.finishWrappedValue(_wrapperName, _wrappedName);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.BeanSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n+\n+\n+/**\n+ * Specific sub-class of {@link BeanSerializer} needed to take care\n+ * of some xml-specific aspects, such as distinction between attributes\n+ * and elements.\n+ */\n+public class XmlBeanSerializer extends BeanSerializer\n+{\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+\n+    /**\n+     * Number of attributes to write; these will have been ordered to be the first\n+     * properties to write.\n+     */\n+    protected final int _attributeCount;\n+\n+    /**\n+     * Array that contains namespace URIs associated with properties, if any;\n+     * null if no namespace definitions have been assigned\n+     */\n+    protected final QName[] _xmlNames;\n+\n+    public XmlBeanSerializer(BeanSerializer src)\n+    {\n+        super(src);\n+\n+        // Ok, first: collect namespace information\n+        _xmlNames = new QName[_props.length];\n+        // First, find namespace information\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _props[i];\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                ns = info.getNamespace();\n+            }\n+            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+        }      \n+        \n+        /* Then make sure attributes are sorted before elements, keep track\n+         * of how many there are altogether\n+         */\n+        int attrCount = 0;\n+        for (BeanPropertyWriter bpw : _props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                attrCount = _orderAttributesFirst(_props, _filteredProps);\n+                break;\n+            }\n+        }\n+        _attributeCount = attrCount;\n+    }\n+    \n+    /*\n+    protected XmlBeanSerializer(XmlBeanSerializer src, BeanPropertyWriter[] filtered)\n+    {\n+        super(src._handledType, src._props, filtered, src._anyGetterWriter, src._propertyFilterId);\n+        _attributeCount = src._attributeCount;\n+        _xmlNames = src._xmlNames;\n+    }\n+    */\n+\n+    protected XmlBeanSerializer(XmlBeanSerializer src, ObjectIdWriter objectIdWriter)\n+    {\n+        super(src, objectIdWriter);\n+        _attributeCount = src._attributeCount;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n+        // 19-Feb-2012, tatu: Should support unwrapping for XML too... but not yet done\n+//        return new UnwrappingBeanSerializer(this, unwrapper);\n+        throw new UnsupportedOperationException(\"Unwrapping serialization not yet supported for XML\");\n+    }\n+\n+    @Override\n+    protected BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+        return new XmlBeanSerializer(this, objectIdWriter);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden serialization methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Main serialization method needs to be overridden to allow XML-specific\n+     * extra handling, such as indication of whether to write attributes or\n+     * elements.\n+     */\n+    @Override\n+    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final ToXmlGenerator jgen = (ToXmlGenerator) jgen0;\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        \n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            jgen.setNextIsAttribute(true);\n+        }\n+        final QName[] xmlNames = _xmlNames;\n+        \n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    jgen.setNextIsAttribute(false);\n+                }\n+                jgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, jgen, provider);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+\n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n+            BeanPropertyWriter[] filteredProperties)\n+    {\n+        int attrCount = 0;\n+\n+        for (int i = 0, len = properties.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = properties[i];\n+            \n+            if (!_isAttribute(bpw)) {\n+                continue;\n+            }\n+            // Swap if attribute and there are preceding elements:\n+            if (attrCount < i) {\n+                properties[i] = properties[attrCount];\n+                properties[attrCount] = bpw;\n+                if (filteredProperties != null) {\n+                    BeanPropertyWriter fbpw = filteredProperties[i];\n+                    filteredProperties[i] = filteredProperties[attrCount];\n+                    filteredProperties[attrCount] = fbpw;\n+                }\n+            }\n+            ++attrCount;\n+        }\n+        return attrCount;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n+\n+\n+/**\n+ * We need a {@link BeanSerializerModifier} to replace default <code>BeanSerializer</code>\n+ * with XML-specific one; mostly to ensure that attribute properties are output\n+ * before element properties.\n+ */\n+public class XmlBeanSerializerModifier extends BeanSerializerModifier\n+{\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First thing to do is to find annotations regarding XML serialization,\n+     * and wrap collection serializers.\n+     */\n+    @Override\n+    public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+            BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        for (int i = 0, len = beanProperties.size(); i < len; ++i) {\n+            BeanPropertyWriter bpw = beanProperties.get(i);\n+            final AnnotatedMember member = bpw.getMember();\n+            String ns = findNamespaceAnnotation(intr, member);\n+            Boolean isAttribute = findIsAttributeAnnotation(intr, member);\n+            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+\n+            // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n+            if (_isContainerType(bpw.getType())) {\n+                String localName = null, wrapperNs = null;\n+\n+                QName wrappedName = new QName(ns, bpw.getName());\n+                QName wrapperName = findWrapperName(intr, member);\n+                if (wrapperName != null) {\n+                    localName = wrapperName.getLocalPart();\n+                    wrapperNs = wrapperName.getNamespaceURI();\n+                }\n+                /* Empty/missing localName means \"use property name as wrapper\"; later on\n+                 * should probably make missing (null) mean \"don't add a wrapper\"\n+                 */\n+                if (localName == null || localName.length() == 0) {\n+                    wrapperName = wrappedName;\n+                } else {\n+                    wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n+                }\n+                beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n+            }\n+        }\n+        return beanProperties;\n+    }\n+    \n+    @Override\n+    public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+            BeanDescription beanDesc, JsonSerializer<?> serializer)\n+    {\n+        /* First things first: we can only handle real BeanSerializers; question\n+         * is, what to do if it's not one: throw exception or bail out?\n+         * For now let's do latter.\n+         */\n+        if (!(serializer instanceof BeanSerializer)) {\n+            return serializer;\n+        }\n+        return new XmlBeanSerializer((BeanSerializer) serializer);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    private static boolean _isContainerType(JavaType type)\n+    {\n+        if (type.isContainerType()) {\n+            Class<?> cls = type.getRawClass();\n+            // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            // (actually, ditto for char[]; thought to be a String)\n+            if (cls == byte[].class || cls == byte[].class) {\n+                return false;\n+            }\n+            // issue#5: also, should not add wrapping for Maps\n+            if (Map.class.isAssignableFrom(cls)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    private static String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n+                if (n != null) {\n+                    return n;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n+\n+\n+/**\n+ * We need to override some parts of {@link org.codehaus.jackson.map.SerializerProvider}\n+ * implementation to handle oddities of XML output, like \"extra\" root element.\n+ */\n+public class XmlSerializerProvider extends DefaultSerializerProvider\n+{\n+    /**\n+     * If all we get to serialize is a null, there's no way to figure out\n+     * expected root name; so let's just default to something like \"<null>\"...\n+     */\n+    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n+    \n+    protected final XmlRootNameLookup _rootNameLookup;\n+    \n+    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n+    {\n+        super();\n+        _rootNameLookup = rootNames;\n+    }\n+\n+    public XmlSerializerProvider(XmlSerializerProvider src,\n+            SerializationConfig config, SerializerFactory f)\n+    {\n+        super(src, config, f);\n+        _rootNameLookup  = src._rootNameLookup;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Overridden methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public DefaultSerializerProvider createInstance(SerializationConfig config,\n+            SerializerFactory jsf)\n+    {\n+        return new XmlSerializerProvider(this, config, jsf);\n+    }\n+    \n+    @Override\n+    public void serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = (value == null) ? ROOT_NAME_FOR_NULL\n+                : _rootNameLookup.findRootName(value.getClass(), _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super.serializeValue(jgen, value);\n+    }\n+\n+    @Override\n+    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = _rootNameLookup.findRootName(rootType, _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super.serializeValue(jgen, value, rootType);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+\n+/**\n+ * Indentation to use with XML is different from JSON, because JSON\n+ * requires use of separator characters and XML just basic whitespace.\n+ */\n+public class DefaultXmlPrettyPrinter\n+    implements PrettyPrinter\n+{\n+    /*\n+    /**********************************************************\n+    /* Root-level values\n+    /**********************************************************\n+     */\n+\n+    //@Override\n+    public void writeRootValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // Not sure if this should ever be applicable; but if multiple roots were allowed, we'd use linefeed\n+        jgen.writeRaw('\\n');\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Array values\n+    /**********************************************************\n+     */\n+    \n+    //@Override\n+    public void beforeArrayValues(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+\n+    //@Override\n+    public void writeStartArray(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+\n+    //@Override\n+    public void writeArrayValueSeparator(JsonGenerator jgen)  throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+\n+    //@Override\n+    public void writeEndArray(JsonGenerator jgen, int nrOfValues) throws IOException, JsonGenerationException {\n+        // anything to do here?\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Object values\n+    /**********************************************************\n+     */\n+    \n+    //@Override\n+    public void beforeObjectEntries(JsonGenerator jg)  throws IOException, JsonGenerationException {\n+        // TODO Auto-generated method stub\n+    }\n+\n+    //@Override\n+    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+        ((ToXmlGenerator) jgen)._handleStartObject();\n+    }\n+\n+    //@Override\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+\n+    //@Override\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n+        // all markup by elements, no separators; nothing to do here\n+    }\n+    \n+    //@Override\n+    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException {\n+        ((ToXmlGenerator) jgen)._handleEndObject();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/StaxUtil.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+import java.io.IOException;\n+\n+import javax.xml.stream.*;\n+\n+public class StaxUtil\n+{\n+    /**\n+     * Adapter method used when only IOExceptions are declared to be thrown, but\n+     * a {@link XMLStreamException} was caught.\n+     *<p>\n+     * Note: dummy type variable is used for convenience, to allow caller to claim\n+     * that this method returns result of any necessary type.\n+     */\n+    public static <T> T throwXmlAsIOException(XMLStreamException e) throws IOException\n+    {\n+        Throwable t = e;\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        if (t instanceof Error) throw (Error) t;\n+        if (t instanceof RuntimeException) throw (RuntimeException) t;\n+        throw new IOException(t);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+/**\n+ * Helper container class used to contain XML specific information\n+ * we need to retain to construct proper bean serializer\n+ */\n+public class XmlInfo\n+{\n+    protected final String _namespace;\n+    protected final boolean _isAttribute;\n+    \n+    public XmlInfo(Boolean isAttribute, String ns)\n+    {\n+        _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n+        _namespace = (ns == null) ? \"\" : ns;\n+    }\n+\n+    public String getNamespace() { return _namespace; }\n+    public boolean isAttribute() { return _isAttribute; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+\n+\n+/**\n+ * Helper class used for efficiently finding root element name used with\n+ * XML serializations.\n+ */\n+public class XmlRootNameLookup\n+{\n+    /**\n+     * For efficient operation, let's try to minimize number of times we\n+     * need to introspect root element name to use.\n+     */\n+    protected final LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n+\n+    public XmlRootNameLookup() { }\n+\n+    public QName findRootName(JavaType rootType, MapperConfig<?> config)\n+    {\n+        return findRootName(rootType.getRawClass(), config);\n+    }\n+\n+    public QName findRootName(Class<?> rootType, MapperConfig<?> config)\n+    {\n+        ClassKey key = new ClassKey(rootType);\n+        QName name;\n+        synchronized (_rootNames) {\n+            name = _rootNames.get(key);\n+            if (name == null) {\n+                BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n+                AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+                AnnotatedClass ac = beanDesc.getClassInfo();\n+                String localName = null;\n+                String ns = null;\n+\n+                QName root = findRootElement(intr, ac);\n+                if (root != null) {\n+                    localName = root.getLocalPart();\n+                    ns = root.getNamespaceURI();\n+                }\n+                if (localName == null || localName.length() == 0) {\n+                    localName = intr.findRootName(ac);\n+                }\n+                \n+                // No answer so far? Let's just default to using simple class name\n+                if (localName == null || localName.length() == 0) {\n+                    // Should we strip out enclosing class tho? For now, nope:\n+                    localName = rootType.getSimpleName();\n+                    name = new QName(\"\", localName);\n+                } else {\n+                    // Otherwise let's see if there's namespace, too (if we are missing it)\n+                    if (ns == null || ns.length() == 0) {\n+                        ns = findNamespace(intr, ac);\n+                    }\n+                }\n+                if (ns == null) { // some QName impls barf on nulls...\n+                    ns = \"\";\n+                }\n+                name = new QName(ns, localName);\n+                _rootNames.put(key, name);\n+            }\n+        }\n+        return name;\n+    }\n+\n+    private String findNamespace(AnnotationIntrospector ai, AnnotatedClass ann)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(ann);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private QName findRootElement(AnnotationIntrospector ai, AnnotatedClass ann)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName elem = ((XmlAnnotationIntrospector) intr).findRootElement(ann);\n+                if (elem != null) {\n+                    return elem;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlTokenStream.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+import java.io.IOException;\n+import javax.xml.stream.*;\n+\n+import org.codehaus.stax2.XMLStreamLocation2;\n+import org.codehaus.stax2.XMLStreamReader2;\n+import org.codehaus.stax2.ri.Stax2ReaderAdapter;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+\n+/**\n+ * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n+ * abstract out all irrelevant details, and to expose equivalent of flat token\n+ * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n+ * content) all of which is just to simplify\n+ * actual higher-level conversion to JSON tokens\n+ * \n+ * @since 1.7\n+ */\n+public class XmlTokenStream\n+{\n+    public final static int XML_START_ELEMENT = 1;\n+    public final static int XML_END_ELEMENT = 2;\n+    public final static int XML_ATTRIBUTE_NAME = 3;\n+    public final static int XML_ATTRIBUTE_VALUE = 4;\n+    public final static int XML_TEXT = 5;\n+    public final static int XML_END = 6;\n+\n+    /*\n+    /**********************************************************************\n+    /* Configuration\n+    /**********************************************************************\n+     */\n+\n+    final protected XMLStreamReader2 _xmlReader;\n+\n+    final protected Object _sourceReference;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Parsing state\n+    /**********************************************************************\n+     */\n+\n+    protected int _currentState;\n+\n+    protected int _attributeCount;\n+    \n+    /**\n+     * Index of the next attribute of the current START_ELEMENT\n+     * to return (as field name and value pair), if any; -1\n+     * when no attributes to return\n+     */\n+    protected int _nextAttributeIndex = 0;\n+\n+    protected String _localName;\n+\n+    protected String _namespaceURI;\n+\n+    protected String _textValue;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Life-cycle\n+    /**********************************************************************\n+     */\n+\n+    public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n+    {\n+        _sourceReference = sourceRef;\n+        // Let's ensure we point to START_ELEMENT...\n+        if (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\n+            throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+                    +XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n+        }\n+        _xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n+        _currentState = XML_START_ELEMENT;\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        _attributeCount = _xmlReader.getAttributeCount();\n+    }\n+\n+    public XMLStreamReader2 getXmlReader() {\n+        return _xmlReader;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Public API\n+    /**********************************************************************\n+     */\n+\n+    public int next() throws IOException \n+    {\n+        try {\n+            return _next();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    public void skipEndElement() throws IOException\n+    {\n+        try {\n+            int type = _next();\n+            if (type != XML_END_ELEMENT) {\n+                throw new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public int getCurrentToken() { return _currentState; }\n+\n+    public String getText() { return _textValue; }\n+    public String getLocalName() { return _localName; }\n+    public String getNamespaceURI() { return _namespaceURI; }\n+    public boolean hasAttributes() {\n+        return (_currentState == XML_START_ELEMENT) && (_attributeCount > 0);\n+    }\n+    \n+    public void closeCompletely() throws IOException\n+    {\n+        try {\n+            _xmlReader.closeCompletely();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public void close() throws IOException\n+    {\n+        try {\n+            _xmlReader.close();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public JsonLocation getCurrentLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getCurrentLocation());\n+    }\n+    public JsonLocation getTokenLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal methods, parsing\n+    /**********************************************************************\n+     */\n+\n+    private final int _next() throws XMLStreamException\n+    {\n+        switch (_currentState) {\n+        case XML_ATTRIBUTE_VALUE:\n+            ++_nextAttributeIndex;\n+            // fall through\n+        case XML_START_ELEMENT: // attributes to return?\n+            if (_nextAttributeIndex < _attributeCount) {\n+                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n+                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n+                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n+                return (_currentState = XML_ATTRIBUTE_NAME);\n+            }\n+            // otherwise need to find START/END_ELEMENT or text\n+            String text = _collectUntilTag();\n+            // If it's START_ELEMENT, ignore any text\n+            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n+                return _initStartElement();\n+            }\n+            // For END_ELEMENT we will return text, if any\n+            if (text != null) {\n+                _textValue = text;\n+                return (_currentState = XML_TEXT);\n+            }\n+            return (_currentState = XML_END_ELEMENT);\n+        case XML_ATTRIBUTE_NAME:\n+            // if we just returned name, will need to just send value next\n+            return (_currentState = XML_ATTRIBUTE_VALUE);\n+        case XML_TEXT:\n+            // text is always followed by END_ELEMENT\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+\n+        // Ok: must be END_ELEMENT; see what tag we get (or end)\n+        switch (_skipUntilTag()) {\n+        case XMLStreamConstants.END_DOCUMENT:\n+            return (_currentState = XML_END);\n+        case XMLStreamConstants.END_ELEMENT:\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+        // START_ELEMENT...\n+        return _initStartElement();\n+    }\n+    \n+    private final String _collectUntilTag() throws XMLStreamException\n+    {\n+        String text = null;\n+        while (true) {\n+            switch (_xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return text;\n+                // note: SPACE is ignorable (and seldom seen), not to be included\n+            case XMLStreamConstants.CHARACTERS:\n+            case XMLStreamConstants.CDATA:\n+                if (text == null) {\n+                    text = _xmlReader.getText();\n+                } else { // can be optimized in future, if need be:\n+                    text += _xmlReader.getText();\n+                }\n+                break;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+\n+    private final int _skipUntilTag() throws XMLStreamException\n+    {\n+        while (true) {\n+            int type;\n+            switch (type = _xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return type;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal methods, other\n+    /**********************************************************************\n+     */\n+    \n+    private final int _initStartElement() throws XMLStreamException\n+    {\n+        _nextAttributeIndex = 0;\n+        _attributeCount = _xmlReader.getAttributeCount();\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        return (_currentState = XML_START_ELEMENT);\n+    }\n+    \n+    private JsonLocation _extractLocation(XMLStreamLocation2 location)\n+    {\n+        if (location == null) { // just for impls that might pass null...\n+            return new JsonLocation(_sourceReference, -1, -1, -1);\n+        }\n+        return new JsonLocation(_sourceReference,\n+                location.getCharacterOffset(),\n+                location.getLineNumber(),\n+                location.getColumnNumber());\n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/xml/TestDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestDeserialization.java\n import java.util.List;\n \n \n-import com.fasterxml.jackson.xml.XmlMapper;\n-import com.fasterxml.jackson.xml.annotate.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlProperty;\n \n public class TestDeserialization extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestEnums.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestEnums.java\n package com.fasterxml.jackson.xml;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n public class TestEnums extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestIndentation.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n-import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestIndentation extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n package com.fasterxml.jackson.xml;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n-import com.fasterxml.jackson.xml.XmlMapper;\n \n public class TestPolymorphic extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestSerialization.java\n import java.util.*;\n \n \n-import com.fasterxml.jackson.xml.XmlMapper;\n-import com.fasterxml.jackson.xml.annotate.JacksonXmlElementWrapper;\n-import com.fasterxml.jackson.xml.annotate.JacksonXmlProperty;\n-import com.fasterxml.jackson.xml.annotate.JacksonXmlRootElement;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlProperty;\n+import com.fasterxml.jackson.dataformat.xml.annotate.JacksonXmlRootElement;\n \n public class TestSerialization extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestVersions.java\n \n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n-import com.fasterxml.jackson.xml.XmlMapper;\n-import com.fasterxml.jackson.xml.XmlFactory;\n \n public class TestVersions extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestViews.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestViews.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n public class TestViews extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXMLFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXMLFormatDetection.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.format.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n \n public class TestXMLFormatDetection extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n package com.fasterxml.jackson.xml;\n \n-import com.fasterxml.jackson.xml.XmlMapper;\n-import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n \n public class TestXmlDeclaration extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n \n import javax.xml.namespace.QName;\n \n-import com.fasterxml.jackson.xml.XmlFactory;\n-import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n \n public class TestXmlGenerator extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-\n-import com.fasterxml.jackson.xml.XmlFactory;\n-import com.fasterxml.jackson.xml.XmlMapper;\n-import com.fasterxml.jackson.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.dataformat.xml.XmlFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n+\n \n public class TestXmlParser extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlTokenStream.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlTokenStream.java\n \n import javax.xml.stream.*;\n \n-import com.fasterxml.jackson.xml.util.XmlTokenStream;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlTokenStream;\n \n public class TestXmlTokenStream extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/failing/TestEnums.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/failing/TestEnums.java\n package com.fasterxml.jackson.xml.failing;\n \n-import com.fasterxml.jackson.xml.XmlMapper;\n import com.fasterxml.jackson.xml.XmlTestBase;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n \n public class TestEnums extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/failing/TestPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/failing/TestPolymorphic.java\n package com.fasterxml.jackson.xml.failing;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.dataformat.xml.*;\n \n-import com.fasterxml.jackson.xml.*;\n+import com.fasterxml.jackson.xml.XmlTestBase;\n \n public class TestPolymorphic extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/jaxb/TestWithJAXBAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/jaxb/TestWithJAXBAnnotations.java\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n-import com.fasterxml.jackson.xml.XmlAnnotationIntrospector;\n-import com.fasterxml.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n import com.fasterxml.jackson.xml.XmlTestBase;\n-import com.fasterxml.jackson.xml.jaxb.XmlJaxbAnnotationIntrospector;\n \n /**\n  * Although XML-backed data binding does not rely (or directly build) on JAXB", "timestamp": 1329717345, "metainfo": ""}