{"sha": "ab84ac9f6fcbd2c88c548bcdfe05a7fd7b11aa6e", "log": "Refactored xml serializer to have a base class for further serialization feature support.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n \n import java.io.IOException;\n \n-import javax.xml.namespace.QName;\n-\n-import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n-import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n-import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n-import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n \n /**\n- * Specific sub-class of {@link BeanSerializer} needed to take care\n- * of some xml-specific aspects, such as distinction between attributes\n- * and elements.\n+ * Variant of {@link BeanSerializer} for Xml handling.\n+ * \n+ * @author Pascal G\u00e9linas\n  */\n-public class XmlBeanSerializer extends BeanSerializer\n-{\n-    /**\n-     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n-     * instances; to mark instances that are to be written out as attributes.\n-     * Created as separate non-interned String to ensure there are no collisions.\n+public class XmlBeanSerializer extends XmlBeanSerializerBase {\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n      */\n-    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n-\n-    /**\n-     * Number of attributes to write; these will have been ordered to be the first\n-     * properties to write.\n-     */\n-    protected final int _attributeCount;\n-\n-    /**\n-     * Index of \"text value\" property we have, if any; can have at most\n-     * one such property.\n-     */\n-    protected final int _textPropertyIndex;\n-\n-    /**\n-     * Array that contains namespace URIs associated with properties, if any;\n-     * null if no namespace definitions have been assigned\n-     */\n-    protected final QName[] _xmlNames;\n-\n     public XmlBeanSerializer(BeanSerializerBase src)\n     {\n         super(src);\n-        \n-        /* Then make sure attributes are sorted before elements, keep track\n-         * of how many there are altogether\n-         */\n-        int attrCount = 0;\n-        for (BeanPropertyWriter bpw : _props) {\n-            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n-                attrCount = _orderAttributesFirst(_props, _filteredProps);\n-                break;\n-            }\n-        }\n-        _attributeCount = attrCount;\n-\n-        // And then collect namespace information\n-        _xmlNames = new QName[_props.length];\n-        int textIndex = -1;\n-        for (int i = 0, len = _props.length; i < len; ++i) {\n-            BeanPropertyWriter bpw = _props[i];\n-            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n-            String ns = null;\n-            if (info != null) {\n-                ns = info.getNamespace();\n-                if (textIndex < 0 && info.isText()) {\n-                    textIndex = i;\n-                }\n-            }\n-            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n-        }\n-        _textPropertyIndex = textIndex;\n     }\n \n-    protected XmlBeanSerializer(XmlBeanSerializer src, ObjectIdWriter objectIdWriter)\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)\n+    {\n+        super(src, objectIdWriter, filterId);\n+    }\n+\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter)\n     {\n         super(src, objectIdWriter);\n-        _attributeCount = src._attributeCount;\n-        _textPropertyIndex = src._textPropertyIndex;\n-        _xmlNames = src._xmlNames;\n+    }\n+\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, String[] toIgnore)\n+    {\n+        super(src, toIgnore);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n+\n     @Override\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n-        // 19-Feb-2012, tatu: Should support unwrapping for XML too... but not yet done\n //        return new UnwrappingBeanSerializer(this, unwrapper);\n         throw new UnsupportedOperationException(\"Unwrapping serialization not yet supported for XML\");\n     }\n-\n+    \n     @Override\n-    public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n-        return new XmlBeanSerializer(this, objectIdWriter);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Overridden serialization methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Main serialization method needs to be overridden to allow XML-specific\n-     * extra handling, such as indication of whether to write attributes or\n-     * elements.\n-     */\n-    @Override\n-    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter)\n     {\n-        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFields(bean, jgen0, provider);\n-            return;\n-        }\n-        \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getActiveView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-\n-        final int attrCount = _attributeCount;\n-        if (attrCount > 0) {\n-            xgen.setNextIsAttribute(true);\n-        }\n-        final int textIndex = _textPropertyIndex;\n-        final QName[] xmlNames = _xmlNames;\n-        int i = 0;\n-\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                if (i == attrCount) {\n-                    xgen.setNextIsAttribute(false);\n-                }\n-                // also: if this is property to write as text (\"unwrap\"), need to:\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(true);\n-                }\n-                xgen.setNextName(xmlNames[i]);\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    prop.serializeAsField(bean, xgen, provider);\n-                }\n-                // Reset to avoid next value being written as unwrapped, \n-                // for example when property is suppressed\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(false);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n+        return new XmlBeanSerializer(this, objectIdWriter, _propertyFilterId);\n     }\n \n     @Override\n-    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen0,\n-            SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected BeanSerializerBase withFilterId(Object filterId)\n     {\n-        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFieldsFiltered(bean, jgen0, provider);\n-            return;\n+        return new XmlBeanSerializer(this, _objectIdWriter, filterId);\n+    }\n+\n+    @Override\n+    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n+    {\n+        return new XmlBeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * Implementation has to check whether as-array serialization\n+     * is possible reliably; if (and only if) so, will construct\n+     * a {@link BeanAsArraySerializer}, otherwise will return this\n+     * serializer as is.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer()\n+    {\n+        /* Can not:\n+         * \n+         * - have Object Id (may be allowed in future)\n+         * - have any getter\n+         * \n+         */\n+        if ((_objectIdWriter == null)\n+                && (_anyGetterWriter == null)\n+                && (_propertyFilterId == null)\n+                ) {\n+            return new BeanAsArraySerializer(this);\n         }\n-        \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n-        \n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getActiveView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n-        // better also allow missing filter actually..\n-        if (filter == null) {\n-            serializeFields(bean, jgen0, provider);\n-            return;\n-        }\n-\n-        final int attrCount = _attributeCount;\n-        if (attrCount > 0) {\n-            xgen.setNextIsAttribute(true);\n-        }\n-        final int textIndex = _textPropertyIndex;\n-        final QName[] xmlNames = _xmlNames;\n-\n-        int i = 0;\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                if (i == attrCount) {\n-                    xgen.setNextIsAttribute(false);\n-                }\n-                // also: if this is property to write as text (\"unwrap\"), need to:\n-                if (i == textIndex) {\n-                    xgen.setNextIsUnwrapped(true);\n-                }\n-                xgen.setNextName(xmlNames[i]);\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    filter.serializeAsField(bean, xgen, provider, prop);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n-    }\n-    \n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n-            return;\n-        }\n-\n-        /* Ok: let's serialize type id as attribute, but if (and only if!)\n-         * we are using AS_PROPERTY\n-         */\n-        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n-            xgen.setNextIsAttribute(true);\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n-            if (_attributeCount == 0) { // if no attributes, need to reset\n-                xgen.setNextIsAttribute(false);\n-            }\n-        } else {\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n-        }\n-    }\n-    \n-    @Override\n-    protected void _serializeObjectId(Object bean,\n-                                      JsonGenerator jgen,\n-                                      SerializerProvider provider,\n-                                      TypeSerializer typeSer,\n-                                      WritableObjectId objectId) throws IOException, JsonProcessingException,\n-            JsonGenerationException {\n-        /* Ok: let's serialize type id as attribute, but if (and only if!)\n-         * we are using AS_PROPERTY\n-         */\n-        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n-            xgen.setNextIsAttribute(true);\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n-            if (_attributeCount == 0) { // if no attributes, need to reset\n-                xgen.setNextIsAttribute(false);\n-            }\n-        } else {\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n-        }\n+        // already is one, so:\n+        return this;\n     }\n \n     /*\n     /**********************************************************\n-    /* Helper methods\n+    /* JsonSerializer implementation that differs between impls\n     /**********************************************************\n      */\n \n-    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    /**\n+     * Main serialization method that will delegate actual output to configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n     {\n-        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n-        return (info != null) && info.isAttribute();\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, true);\n+            return;\n+        }\n+        jgen.writeStartObject();\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n     }\n \n-    /**\n-     * Method for re-sorting lists of bean properties such that attributes are strictly\n-     * written before elements.\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n      */\n-    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n-            BeanPropertyWriter[] filteredProperties)\n+\n+    @Override\n+    public String toString()\n     {\n-        int attrCount = 0;\n-\n-        for (int i = 0, len = properties.length; i < len; ++i) {\n-            BeanPropertyWriter bpw = properties[i];\n-\n-            if (!_isAttribute(bpw)) {\n-                continue;\n-            }\n-\n-            // Move attribute a few places done as necessary\n-            int moveBy = i-attrCount;\n-            if (moveBy > 0) {\n-                System.arraycopy(properties, attrCount, properties, attrCount+1, moveBy);\n-                properties[attrCount] = bpw;\n-                if (filteredProperties != null) {\n-                    BeanPropertyWriter fbpw = filteredProperties[i];\n-                    System.arraycopy(filteredProperties, attrCount, filteredProperties, attrCount+1, moveBy);\n-                    filteredProperties[attrCount] = fbpw;\n-                }\n-            }\n-            ++attrCount;\n-        }\n-        return attrCount;\n+        return \"XmlBeanSerializer for \" + handledType().getName();\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+package com.fasterxml.jackson.dataformat.xml.ser;\n+\n+import java.io.IOException;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n+import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n+\n+/**\n+ * Specific sub-class of {@link BeanSerializerBase} needed to take care\n+ * of some xml-specific aspects, such as distinction between attributes\n+ * and elements.\n+ */\n+public abstract class XmlBeanSerializerBase extends BeanSerializerBase\n+{\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+\n+    /**\n+     * Number of attributes to write; these will have been ordered to be the first\n+     * properties to write.\n+     */\n+    protected final int _attributeCount;\n+\n+    /**\n+     * Index of \"text value\" property we have, if any; can have at most\n+     * one such property.\n+     */\n+    protected final int _textPropertyIndex;\n+\n+    /**\n+     * Array that contains namespace URIs associated with properties, if any;\n+     * null if no namespace definitions have been assigned\n+     */\n+    protected final QName[] _xmlNames;\n+\n+    public XmlBeanSerializerBase(BeanSerializerBase src)\n+    {\n+        super(src);\n+        \n+        /* Then make sure attributes are sorted before elements, keep track\n+         * of how many there are altogether\n+         */\n+        int attrCount = 0;\n+        for (BeanPropertyWriter bpw : _props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                attrCount = _orderAttributesFirst(_props, _filteredProps);\n+                break;\n+            }\n+        }\n+        _attributeCount = attrCount;\n+\n+        // And then collect namespace information\n+        _xmlNames = new QName[_props.length];\n+        int textIndex = -1;\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _props[i];\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                ns = info.getNamespace();\n+                if (textIndex < 0 && info.isText()) {\n+                    textIndex = i;\n+                }\n+            }\n+            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+        }\n+        _textPropertyIndex = textIndex;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter)\n+    {\n+        super(src, objectIdWriter);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)\n+    {\n+        super(src, objectIdWriter, filterId);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n+    {\n+        super(src, toIgnore);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+    \n+    public XmlBeanSerializerBase(XmlBeanSerializerBase src, NameTransformer transformer)\n+    {\n+        super(src, transformer);\n+        _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n+        _xmlNames = src._xmlNames;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden serialization methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serialization method needs to be overridden to allow XML-specific\n+     * extra handling, such as indication of whether to write attributes or\n+     * elements.\n+     */\n+    @Override\n+    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n+        if (!(jgen0 instanceof ToXmlGenerator)) {\n+            super.serializeFields(bean, jgen0, provider);\n+            return;\n+        }\n+        \n+        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        final BeanPropertyWriter[] props;\n+        // !!! TODO: change to use non-deprecated version in 2.3\n+        if (_filteredProps != null && provider.getActiveView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+\n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            xgen.setNextIsAttribute(true);\n+        }\n+        final int textIndex = _textPropertyIndex;\n+        final QName[] xmlNames = _xmlNames;\n+        int i = 0;\n+\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    xgen.setNextIsAttribute(false);\n+                }\n+                // also: if this is property to write as text (\"unwrap\"), need to:\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(true);\n+                }\n+                xgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, xgen, provider);\n+                }\n+                // Reset to avoid next value being written as unwrapped, \n+                // for example when property is suppressed\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(false);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    @Override\n+    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen0,\n+            SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n+        if (!(jgen0 instanceof ToXmlGenerator)) {\n+            super.serializeFieldsFiltered(bean, jgen0, provider);\n+            return;\n+        }\n+        \n+        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        \n+        final BeanPropertyWriter[] props;\n+        // !!! TODO: change to use non-deprecated version in 2.3\n+        if (_filteredProps != null && provider.getActiveView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n+        // better also allow missing filter actually..\n+        if (filter == null) {\n+            serializeFields(bean, jgen0, provider);\n+            return;\n+        }\n+\n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            xgen.setNextIsAttribute(true);\n+        }\n+        final int textIndex = _textPropertyIndex;\n+        final QName[] xmlNames = _xmlNames;\n+\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    xgen.setNextIsAttribute(false);\n+                }\n+                // also: if this is property to write as text (\"unwrap\"), need to:\n+                if (i == textIndex) {\n+                    xgen.setNextIsUnwrapped(true);\n+                }\n+                xgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    filter.serializeAsField(bean, xgen, provider, prop);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+    \n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            return;\n+        }\n+\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+        }\n+    }\n+    \n+    @Override\n+    protected void _serializeObjectId(Object bean,\n+                                      JsonGenerator jgen,\n+                                      SerializerProvider provider,\n+                                      TypeSerializer typeSer,\n+                                      WritableObjectId objectId) throws IOException, JsonProcessingException,\n+            JsonGenerationException {\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+\n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n+            BeanPropertyWriter[] filteredProperties)\n+    {\n+        int attrCount = 0;\n+\n+        for (int i = 0, len = properties.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = properties[i];\n+            \n+            if (!_isAttribute(bpw)) {\n+                continue;\n+            }\n+            \n+            // Move attribute a few places done as necessary\n+            int moveBy = i - attrCount;\n+            if (moveBy > 0) {\n+                System.arraycopy(properties, attrCount, properties, attrCount + 1, moveBy);\n+                properties[attrCount] = bpw;\n+                if (filteredProperties != null) {\n+                    BeanPropertyWriter fbpw = filteredProperties[i];\n+                    System.arraycopy(filteredProperties, attrCount, filteredProperties, attrCount+1, moveBy);\n+                    filteredProperties[attrCount] = fbpw;\n+                }\n+            }\n+            ++attrCount;\n+        }\n+        return attrCount;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             String ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\n             Boolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\n             Boolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\n-            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO,\n+            bpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\n             \t\tnew XmlInfo(isAttribute, ns, isText));\n \n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...", "timestamp": 1391112805, "metainfo": ""}