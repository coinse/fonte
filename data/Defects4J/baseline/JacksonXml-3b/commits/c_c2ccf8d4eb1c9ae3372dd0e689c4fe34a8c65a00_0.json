{"sha": "c2ccf8d4eb1c9ae3372dd0e689c4fe34a8c65a00", "log": "Merge branch '2.6'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.PropertyName;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n-\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n \n /**\n      */\n     public final static boolean DEFAULT_USE_WRAPPER = true;\n \n-    protected final boolean _cfgDefaultUseWrapper;\n+    // non-final from 2.7 on, to allow mapper to change\n+    protected boolean _cfgDefaultUseWrapper;\n     \n     public JacksonXmlAnnotationIntrospector() {\n         this(DEFAULT_USE_WRAPPER);\n         }\n         return null;\n     }\n-    \n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        _cfgDefaultUseWrapper = b;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Overrides for name, property detection\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      */\n     public Boolean isOutputAsCData(Annotated ann);\n \n+    /**\n+     * @since 2.7\n+     */\n+    public void setDefaultUseWrapper(boolean b);\n+    \n     /*\n     /**********************************************************************\n     /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n         public String findNamespace(Annotated ann)\n         {\n             String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.findNamespace(ann);\n             }\n             return value;\n         public Boolean isOutputAsAttribute(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsAttribute(ann);\n             }\n             return value;\n         public Boolean isOutputAsText(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsText(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsText(ann);\n             }\n             return value;\n         @Override\n         public Boolean isOutputAsCData(Annotated ann) {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsCData(ann);\n             }\n             return value;\n+        }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            if (_xmlPrimary != null) {\n+                _xmlPrimary.setDefaultUseWrapper(b);\n+            }\n+            if (_xmlSecondary != null) {\n+                _xmlSecondary.setDefaultUseWrapper(b);\n+            }\n         }\n     }\n \n             //There is no CData annotation in JAXB\n             return null;\n         }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            // not used with JAXB\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n         this(new XmlFactory());\n     }\n \n-    /** @since 2.4 */\n+    /**\n+     * @since 2.4\n+     */\n     public XmlMapper(XMLInputFactory inputF, XMLOutputFactory outF) {\n         this(new XmlFactory(inputF, outF));\n     }\n \n-    /** @since 2.4 */\n+    /**\n+     * @since 2.4\n+     */\n     public XmlMapper(XMLInputFactory inputF) {\n         this(new XmlFactory(inputF));\n     }\n         _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n     }\n \n-    // @since 2.1\n     @Override\n     public XmlMapper copy()\n     {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n \n+    /**\n+     * Since 2.7\n+     */\n+    public XmlMapper setDefaultUseWrapper(boolean state) {\n+        // ser and deser configs should usually have the same introspector, so:\n+        AnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\n+        for (AnnotationIntrospector ai : ai0.allIntrospectors()) {\n+            if (ai instanceof XmlAnnotationIntrospector) {\n+                ((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n+            }\n+        }\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to configuration settings\n     /**********************************************************\n      */\n-\n-    /**\n-     * @deprecated Since 2.1, use {@link #getFactory} instead\n-     */\n-    @Override\n-    @Deprecated\n-    public XmlFactory getJsonFactory() {\n-        return (XmlFactory) _jsonFactory;\n-    }\n \n     @Override\n     public XmlFactory getFactory() {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n      */\n     public void writeEndElement(XMLStreamWriter2 sw, int nrOfEntries) throws XMLStreamException;\n \n+    /**\n+     * Method for trying to write a linefeed to separate entities outside of the\n+     * root element (that is, in prolog or epilog), most often called to separate\n+     * XML declaration from the root element.\n+     *\n+     * @since 2.7\n+     */\n+    public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException;\n+    \n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName, String text, boolean isCData)\n         throws XMLStreamException;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n      * String (\"\").\n      */\n     public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n-    \n+\n     /**\n      * Enumeration that defines all togglable features for XML parsers.\n      * None defined so far (2.6), so just a placeholder.\n      */\n     @Override\n     public boolean requiresCustomCodec() {\n-        return false;\n+        return true;\n     }\n     \n     /*\n      * the current event.\n      */\n     @Override\n-    public String getCurrentName()\n-        throws IOException, JsonParseException\n-    {\n-        // [JACKSON-395]: start markers require information from parent\n+    public String getCurrentName() throws IOException\n+    {\n+        // start markers require information from parent\n         String name;\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n             XmlReadContext parent = _parsingContext.getParent();\n             _parsingContext.convertToArray();\n //System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n             // And just in case a field name was to be returned, wipe it\n-            _nextToken = null;\n+            // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\n+            if (_nextToken == JsonToken.END_OBJECT) {\n+                _nextToken = JsonToken.END_ARRAY;\n+            } else {\n+                _nextToken = null;\n+            }\n             // and last thing, [dataformat-xml#33], better ignore attributes\n             _xmlTokens.skipAttributes();\n             return true;\n     }\n \n     // DEBUGGING\n-    /*\n+/*\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n             }\n         }\n         return t;\n-    } \n-    */\n+    }\n+*/\n \n     @Override\n     public JsonToken nextToken() throws IOException\n             // Simple, except that if this is a leaf, need to suppress end:\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n+                if (_parsingContext.inArray()) {\n+                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n+                    //    expose as empty Object, not null\n+                    _nextToken = JsonToken.END_OBJECT;\n+                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                    return (_currToken = JsonToken.START_OBJECT);\n+                }\n                 return (_currToken = JsonToken.VALUE_NULL);\n             }\n             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n+                /* One more refinement (pronunced like \"hack\") is that if\n+                 * we had an empty String (or all white space), and we are\n+                 * deserializing an array, we better hide the empty text.\n+                 */\n                 // Also: must skip following END_ELEMENT\n                 _xmlTokens.skipEndElement();\n-                /* One more refinement (pronunced like \"hack\") is that if\n-                 * we had an empty String (or all white space), and we are\n-                 * deserializing an array, we better just hide the text\n-                 * altogether.\n-                 */\n                 if (_parsingContext.inArray()) {\n                     if (_isEmpty(_currText)) {\n-                        _currToken = JsonToken.END_ARRAY;\n-                        _parsingContext = _parsingContext.getParent();\n-                        _namesToWrap = _parsingContext.getNamesToWrap();\n-                        return _currToken;\n+                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n+                        //    expose as empty Object, not null (or, worse, as used to\n+                        //    be done, by swallowing the token)\n+                        _nextToken = JsonToken.END_OBJECT;\n+                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                        return (_currToken = JsonToken.START_OBJECT);\n                     }\n                 }\n                 return (_currToken = JsonToken.VALUE_STRING);\n      */\n \n     @Override\n-    public String getText() throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         if (_currToken == null) {\n             return null;\n \n     // @since 2.1\n     @Override\n-    public final String getValueAsString() throws IOException, JsonParseException {\n+    public final String getValueAsString() throws IOException {\n         return getValueAsString(null);\n     }\n \n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n+    public String getValueAsString(String defValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t == null) {\n     }\n     \n     @Override\n-    public char[] getTextCharacters() throws IOException, JsonParseException {\n+    public char[] getTextCharacters() throws IOException {\n         String text = getText();\n         return (text == null)  ? null : text.toCharArray();\n     }\n \n     @Override\n-    public int getTextLength() throws IOException, JsonParseException {\n+    public int getTextLength() throws IOException {\n         String text = getText();\n         return (text == null)  ? 0 : text.length();\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException {\n+    public int getTextOffset() throws IOException {\n         return 0;\n     }\n \n      */\n \n     @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+    public Object getEmbeddedObject() throws IOException {\n         // no way to embed POJOs for now...\n         return null;\n     }\n \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n         }\n         try {\n             String text = _collectUntilTag();\n-            if (text != null && _xmlReader.getEventType() == XMLStreamReader.END_ELEMENT) {\n+            // 23-Dec-2015, tatu: Used to require text not to be null, but as per\n+            //   [dataformat-xml#167], empty tag does count\n+            if (_xmlReader.getEventType() == XMLStreamReader.END_ELEMENT) {\n+                if (text == null) {\n+                    text = \"\";\n+                }\n                 if (_currentWrapper != null) {\n                     _currentWrapper = _currentWrapper.getParent();\n                 }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n  * implementation that\n  * builds on {@link JaxbAnnotationIntrospector}.\n  *<p>\n- * NOTE: since version 2.4, it should NOT be necessary to use this class;\n+ * NOTE: since version 2.4, it may NOT be necessary to use this class;\n  * instead, plain {@link JaxbAnnotationIntrospector} should fully work.\n  * With previous versions some aspects were not fully working and this\n  * class was necessary.\n     extends JaxbAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n-    private static final long serialVersionUID = 6477843393758275877L;\n+    private static final long serialVersionUID = 1L; // since 2.7\n \n     @Deprecated\n     public XmlJaxbAnnotationIntrospector() {\n     /**********************************************************************\n      */\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public String findNamespace(Annotated ann) {\n         return super.findNamespace(ann);\n     }\n \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsAttribute(Annotated ann) {\n         return super.isOutputAsAttribute(ann);\n     }\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n     public Boolean isOutputAsCData(Annotated ann) {\n         //There is no CData annotation in JAXB\n         return null;\n+    }\n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        // nothing to do with JAXB\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n      * {@link ToXmlGenerator.Feature}s\n      * are enabled.\n      */\n-    protected int _xmlFeatures;\n+    protected int _formatFeatures;\n \n     /**\n      * We may need to use XML-specific indentation as well\n     /**********************************************************\n      */\n \n-    public ToXmlGenerator(IOContext ctxt, int genericGeneratorFeatures, int xmlFeatures,\n+    public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\n             ObjectCodec codec, XMLStreamWriter sw)\n     {\n-        super(genericGeneratorFeatures, codec);\n-        _xmlFeatures = xmlFeatures;\n+        super(stdFeatures, codec);\n+        _formatFeatures = xmlFeatures;\n         _ioContext = ctxt;\n         _originalXmlWriter = sw;\n         _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n         }\n         _initialized = true;\n         try {\n-            if ((_xmlFeatures & Feature.WRITE_XML_1_1.getMask()) != 0) {\n+            if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n                 _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n-            } else if ((_xmlFeatures & Feature.WRITE_XML_DECLARATION.getMask()) != 0) {\n+            } else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n                 _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n+            } else {\n+                return;\n+            }\n+            // as per [dataformat-xml#172], try adding indentation\n+            if (_xmlPrettyPrinter != null) {\n+                // ... but only if it is likely to succeed:\n+                if (!_stax2Emulation) {\n+                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n      * default XML indenter instead.\n      *<p>\n      * !!! TODO: same as implementation in core 2.6; override may be\n-     * removed from 2.7\n+     * removed from 2.8\n      */\n     @Override\n     public final JsonGenerator useDefaultPrettyPrinter()\n         return -1;\n     }\n \n+    @Override\n+    public int getFormatFeatures() {\n+        return _formatFeatures;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonGenerator overrideFormatFeatures(int values, int mask)\n+    {\n+        int oldF = _formatFeatures;\n+        int newF = (_formatFeatures & ~mask) | (values & mask);\n+\n+        if (oldF != newF) {\n+            _formatFeatures = newF;\n+        }\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended API, configuration\n      */\n \n     public ToXmlGenerator enable(Feature f) {\n-        _xmlFeatures |= f.getMask();\n+        _formatFeatures |= f.getMask();\n         return this;\n     }\n \n     public ToXmlGenerator disable(Feature f) {\n-        _xmlFeatures &= ~f.getMask();\n+        _formatFeatures &= ~f.getMask();\n         return this;\n     }\n \n     public final boolean isEnabled(Feature f) {\n-        return (_xmlFeatures & f.getMask()) != 0;\n+        return (_formatFeatures & f.getMask()) != 0;\n     }\n \n     public ToXmlGenerator configure(Feature f, boolean state) {\n      */\n \n     @Override\n-    public final void writeFieldName(String name)  throws IOException\n+    public final void writeFieldName(String name) throws IOException\n     {\n         if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n             _reportError(\"Can not write a field name, expecting a value\");\n     {\n         // We may want to repeat same element, so:\n         if (_elementNameStack.isEmpty()) {\n-            throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\");\n+            throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n         }\n         _nextName = _elementNameStack.removeLast();\n         try {\n             // note: since attributes don't nest, can only have one attribute active, so:\n             _nextIsAttribute = false;\n             _xmlWriter.writeEndElement();\n+            // [databind-xml#172]: possibly also need indentation\n+            if (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n+                // ... but only if it is likely to succeed:\n+                if (!_stax2Emulation) {\n+                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n+                }\n+            }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n         }\n     @Override\n     public void writeRaw(String text) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n     @Override\n     public void writeRaw(String text, int offset, int len) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n     @Override\n     public void writeRaw(char[] text, int offset, int len) throws IOException\n     {\n-        // [Issue#39]\n+        // [dataformat-xml#39]\n         if (_stax2Emulation) {\n             _reportUnimplementedStax2(\"writeRaw\");\n         }\n //        boolean wasClosed = _closed;\n         super.close();\n \n-        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n-         *   scopes.\n-         */\n         // First: let's see that we still have buffers...\n         if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n             try {\n                 /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n                  *   hit by this as a collateral problem in some cases. Yuck.\n                  */\n-                throw new JsonGenerationException(e);\n+                throw new JsonGenerationException(e, this);\n             }\n         }\n         try {\n     }\n \n     /**\n-     * Method called \n+     * Method called in case access to native Stax2 API implementation is required.\n      */\n     protected void  _reportUnimplementedStax2(String missingMethod) throws IOException\n     {\n                 +_originalXmlWriter.getClass().getName()\n                 +\") does not implement Stax2 API natively and is missing method '\"\n                 +missingMethod+\"': this breaks functionality such as indentation that relies on it. \"\n-                +\"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\");\n+                +\"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\",\n+                this);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n public class XmlBeanPropertyWriter\n     extends BeanPropertyWriter\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* Config settings\n      * Element name used for items in the collection\n      */\n     protected final QName _wrappedQName;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: construction, configuration\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = JsonMappingException.from(gen0,\n+                    \"Infinite recursion (StackOverflowError)\");\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            JsonMappingException mapE = JsonMappingException.from(gen0, \"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n  */\n public class XmlSerializerProvider extends DefaultSerializerProvider\n {\n-    // As of 2.5\n-    private static final long serialVersionUID = -4138605166320336475L;\n+    // As of 2.7\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * If all we get to serialize is a null, there's no way to figure out\n      * expected root name; so let's just default to something like \"&lt;null>\"...\n      */\n     protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n-    \n+\n     protected final XmlRootNameLookup _rootNameLookup;\n-    \n+\n     public XmlSerializerProvider(XmlRootNameLookup rootNames)\n     {\n         super();\n         super(src, config, f);\n         _rootNameLookup  = src._rootNameLookup;\n     }\n-    \n+\n     /*\n     /**********************************************************************\n     /* Overridden methods\n             SerializerFactory jsf) {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n-    \n+\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final Class<?> cls = value.getClass();\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         // From super-class implementation\n         final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n         } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n     \n     // @since 2.1\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         }\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n         return new QName(ns, name.getSimpleName());\n     }\n \n-    protected ToXmlGenerator _asXmlGenerator(JsonGenerator jgen)\n+    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n         throws JsonMappingException\n     {\n         // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n-        if (!(jgen instanceof ToXmlGenerator)) {\n+        if (!(gen instanceof ToXmlGenerator)) {\n             // but verify\n-            if (!(jgen instanceof TokenBuffer)) {\n-                throw new JsonMappingException(\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"\n-                            +jgen.getClass().getName());\n-                }\n-                return null;\n-        }\n-        return (ToXmlGenerator) jgen;\n+            if (!(gen instanceof TokenBuffer)) {\n+                throw JsonMappingException.from(gen,\n+                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n+            }\n+            return null;\n+        }\n+        return (ToXmlGenerator) gen;\n     }    \n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n      */\n     public interface Indenter\n     {\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException;\n-\n-        public void writeIndentation(XMLStreamWriter2 sw, int level)\n-            throws XMLStreamException;\n-        \n+        public void writeIndentation(JsonGenerator g, int level) throws IOException;\n+\n+        public void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n+\n         /**\n          * @return True if indenter is considered inline (does not add linefeeds),\n          *   false otherwise\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void writeRootValueSeparator(JsonGenerator gen) throws IOException {\n         // Not sure if this should ever be applicable; but if multiple roots were allowed, we'd use linefeed\n-        jgen.writeRaw('\\n');\n+        gen.writeRaw('\\n');\n     }\n     \n     /*\n      */\n     \n     @Override\n-    public void beforeArrayValues(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void beforeArrayValues(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jgen)\n-    \t\tthrows IOException, JsonGenerationException\n-    {\n+    public void writeStartArray(JsonGenerator gen) throws IOException {\n         // anything to do here?\n     }\n \n     @Override\n-    public void writeArrayValueSeparator(JsonGenerator jgen)  throws IOException, JsonGenerationException {\n+    public void writeArrayValueSeparator(JsonGenerator gen)  throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeEndArray(JsonGenerator jgen, int nrOfValues)\n-    \t\tthrows IOException, JsonGenerationException\n-    {\n+    public void writeEndArray(JsonGenerator gen, int nrOfValues) throws IOException {\n         // anything to do here?\n     }\n     \n      */\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jgen)\n+    public void beforeObjectEntries(JsonGenerator gen)\n         throws IOException, JsonGenerationException\n     {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator gen) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             if (_nesting > 0) {\n-                _objectIndenter.writeIndentation(jgen, _nesting);\n+                _objectIndenter.writeIndentation(gen, _nesting);\n             }\n             ++_nesting;\n         }\n         _justHadStartElement = true;\n-        ((ToXmlGenerator) jgen)._handleStartObject();\n-    }\n-\n-    @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jgen)\n-            throws IOException, JsonGenerationException\n-    {\n+        ((ToXmlGenerator) gen)._handleStartObject();\n+    }\n+\n+    @Override\n+    public void writeObjectEntrySeparator(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n \n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+    public void writeObjectFieldValueSeparator(JsonGenerator gen) throws IOException {\n         // never called for ToXmlGenerator\n     }\n     \n     @Override\n-    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator gen, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n         if (_justHadStartElement) {\n             _justHadStartElement = false;\n         } else {\n-            _objectIndenter.writeIndentation(jgen, _nesting);\n-        }\n-        ((ToXmlGenerator) jgen)._handleEndObject();\n+            _objectIndenter.writeIndentation(gen, _nesting);\n+        }\n+        ((ToXmlGenerator) gen)._handleEndObject();\n     }\n     \n     /*\n         sw.writeEmptyElement(nsURI, localName);\n         _justHadStartElement = false;\n     }\n-    \n+\n+    @Override // since 2.7\n+    public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException\n+    {\n+        // 06-Dec-2015, tatu: Alternatively could try calling `writeSpace()`...\n+        sw.writeRaw(Lf2SpacesIndenter.SYSTEM_LINE_SEPARATOR);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper classes\n         }\n         \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator g, int level) throws IOException\n         {\n-            jg.writeRaw(' ');\n+            g.writeRaw(' ');\n         }\n \n         @Override\n         public boolean isInline() { return false; }\n \n         @Override\n-        public void writeIndentation(XMLStreamWriter2 sw, int level)\n-            throws XMLStreamException\n+        public void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException\n         {\n             sw.writeRaw(SYSTEM_LINE_SEPARATOR);\n             level += level; // 2 spaces per level\n         }\n         \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator jg, int level) throws IOException\n         {\n             jg.writeRaw(SYSTEM_LINE_SEPARATOR);\n             level += level; // 2 spaces per level\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n         if (name != null) {\n             return name;\n         }\n-\n-        // 06-Dec-2015, tatu: as per [dataformat-xlm#171], need to actually do\n-        //    bit more of syncing, unfortunately. Jackson 2.7 should resolve\n-        //    the actual problem, but until then...\n         name = _findRootName(rootType, config);\n-\n         synchronized (_rootNames) {\n             _rootNames.put(key, name);\n         }\n         return name;\n     }\n     \n-    protected synchronized QName _findRootName(Class<?> rootType, MapperConfig<?> config)\n+    // NOTE: needed to be synchronized in 2.6.4, but 2.7.0 adds a proper fix\n+    // for annotation introspection hence not needed any more\n+    protected QName _findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/RoundtripContentTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/RoundtripContentTest.java\n \n public class RoundtripContentTest extends XmlTestBase\n {\n+    private final XmlMapper MAPPER = new XmlMapper();\n+\n     public void testRoundtrip() throws Exception\n     {\n-        final XmlMapper MAPPER = new XmlMapper();\n-        \n         MediaItem.Content content = new MediaItem.Content();\n         content.setTitle(\"content\");\n         content.addPerson(\"William\");\n \n         ObjectWriter w = MAPPER.writerFor(MediaItem.class);\n \n-        /*\n-        StringWriter sw = new StringWriter();\n-        try {\n-        w.writeValue(sw, input);\n-        } finally {\n-            System.err.println(\"So far -> [\"+sw+\"]\");\n-        }\n-        */\n-        \n-        String xml = w.writeValueAsString(input);\n+        // two variants; first without indentation\n+        _verifyRoundtrip(w.writeValueAsString(input), input);\n \n-//System.err.println(\"DEBUG: Xml == \"+xml);\n+        // and then with indentation\n+        _verifyRoundtrip(w.withDefaultPrettyPrinter()\n+                .writeValueAsString(input), input);\n+    }\n \n+    private void _verifyRoundtrip(String xml, MediaItem exp) throws Exception\n+    {\n         ObjectReader r = MAPPER.readerFor(MediaItem.class);\n         MediaItem result = r.readValue(xml);\n         assertNotNull(result);\n-        assertEquals(content.getTitle(), result.getContent().getTitle());\n+        assertEquals(exp.getContent().getTitle(), result.getContent().getTitle());\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/VersionInfoTest.java\n     private void assertVersion(Versioned vers)\n     {\n         final Version v = vers.version();\n-        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUnknownVersion());\n         Version exp = PackageVersion.VERSION;\n         assertEquals(exp.toFullString(), v.toFullString());\n         assertEquals(exp, v);\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n     /**********************************************************\n      */\n \n+    protected static String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n+    }\n+\n     protected byte[] utf8Bytes(String str) {\n         try {\n             return str.getBytes(\"UTF-8\");\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestStringValues.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/deser/TestStringValues.java\n             return \"[a=\"+a+\",b=\"+b+\"]\";\n         }\n     }\n-    \n+\n+    static class Issue167Bean {\n+        public String d;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertNotNull(bean);\n         assertEquals(\"text!\", bean.text);\n     }\n-    \n-    public void testEmptyStringElement() throws Exception\n-    {\n-        // then with empty element\n-        StringBean bean = MAPPER.readValue(\"<StringBean><text></text></StringBean>\", StringBean.class);\n-        assertNotNull(bean);\n-        // empty String or null?\n-        // 22-Sep-2012, tatu: Seems to be 'null', but should probably be fixed to \"\"\n-//        assertEquals(\"\", bean.text);\n-        assertNull(bean.text);\n-    }\n-    \n+\n     public void testMissingString() throws Exception\n     {\n         StringBean baseline = new StringBean();\n         assertEquals(\"Bulla\", beans[1].text);\n         assertEquals(\"Good stuff\", beans[2].text);\n     }\n+\n+    public void testEmptyElementToString() throws Exception\n+    {\n+        final String XML =\n+\"<a xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\\n\"+\n+\"<d xsi:nil='true'/>\\n\"+\n+\"</a>\\n\";\n+        Issue167Bean result = MAPPER.readValue(XML, Issue167Bean.class);\n+        assertNotNull(result);\n+        assertEquals(\"\", result.d);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/DeserializePolyList178Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class DeserializePolyList178Test extends XmlTestBase\n+{\n+    static class Company {\n+        public List<Computer> computers;\n+\n+        public Company() {\n+            computers = new ArrayList<Computer>();\n+        }\n+\n+        public Company add(Computer computer) {\n+            if (computers == null) {\n+                computers = new ArrayList<Computer>();\n+            }\n+            computers.add(computer);\n+            return this;\n+        }\n+    }\n+\n+// 02-Jan-2015, tatu: Does not seem to matter; was included in the original reproduction\n+//    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT,\n+            property = \"type\")\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = DesktopComputer.class, name = \"desktop\"),\n+            @JsonSubTypes.Type(value = LaptopComputer.class, name = \"laptop\")\n+    })\n+    static class Computer {\n+        public String id;\n+    }\n+\n+    @JsonTypeName(\"desktop\")\n+    static class DesktopComputer extends Computer {\n+        public String location;\n+\n+        protected DesktopComputer() { }\n+        public DesktopComputer with(String id0, String l) {\n+            id = id0;\n+            location = l;\n+            return this;\n+        }\n+    }\n+\n+    @JsonTypeName(\"laptop\")\n+    static class LaptopComputer extends Computer {\n+        public String vendor;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // for [dataformat-xml#178]\n+    public void testPolyIdList178() throws Exception\n+    {\n+        Company input = new Company();\n+        input.add(new DesktopComputer().with(\"1\", \"http://foo.com\"));\n+        input.add(new DesktopComputer().with(\"2\", \"http://bar.com\"));\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter()\n+                .writeValueAsString(input);\n+//System.out.println(\"XML:\\n\"+xml);\n+\n+        Company result = MAPPER.readValue(xml, Company.class);\n+        assertNotNull(result.computers);\n+        assertEquals(2, result.computers.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestStringValues162.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class TestStringValues162 extends XmlTestBase\n+{\n+    static class Name {\n+        public String first;\n+        public String last;\n+\n+        public Name() { }\n+        public Name(String f, String l) {\n+            first = f;\n+            last = l;\n+        }\n+    }\n+\n+    static class Names {\n+        public List<Name> names = new ArrayList<Name>();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+\n+    public void testEmptyString162() throws Exception\n+    {\n+        Name name = MAPPER.readValue(\"<name><first>Ryan</first><last></last></name>\",\n+                Name.class);\n+        assertNotNull(name);\n+        assertEquals(\"Ryan\", name.first);\n+        assertEquals(\"\", name.last);\n+    }\n+\n+    public void testEmptyStringElement() throws Exception\n+    {\n+        // then with empty element\n+        StringBean bean = MAPPER.readValue(\"<StringBean><text></text></StringBean>\", StringBean.class);\n+        assertNotNull(bean);\n+        // empty String or null?\n+        // As per [dataformat-xml#162], really should be \"\", not null:\n+        assertEquals(\"\", bean.text);\n+//        assertNull(bean.text);\n+    }\n+\n+    public void testStringsInList() throws Exception\n+    {\n+        Names input = new Names();\n+        input.names.add(new Name(\"Bob\", \"Lee\"));\n+        input.names.add(new Name(\"\", \"\"));\n+        input.names.add(new Name(\"Sponge\", \"Bob\"));\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(input);\n+        \n+//System.err.println(\"XML:\\n\"+xml);\n+\n+        Names result = MAPPER.readValue(xml, Names.class);\n+        assertNotNull(result);\n+        assertNotNull(result.names);\n+        assertEquals(3, result.names.size());\n+        assertEquals(\"Bob\", result.names.get(2).last);\n+\n+        // [dataformat-xml#162]: should get empty String, not null\n+        assertEquals(\"\", result.names.get(1).first);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n \n import java.util.Arrays;\n import java.util.List;\n-\n-import org.junit.Test;\n \n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n     public static class Issue86 {\n \n       @JacksonXmlProperty(localName = \"id\", isAttribute = true)\n-      private String id;\n+      public String id;\n \n       @JacksonXmlElementWrapper(useWrapping = false)\n       @JacksonXmlProperty(localName = \"test\")\n-      private List<Issue86> children;\n+      public List<Issue86> children;\n \n       public Issue86() {}\n \n \n       @Override\n       public boolean equals(final Object other) {\n-        if (other == null) {\n-          return false;\n-        }\n+          if (other == this) return true;\n+          if (other == null) return false;\n \n-        if (other == this) {\n-          return true;\n-        }\n+          if (!(other instanceof Issue86)) {\n+              return false;\n+          }\n \n-        if (!(other instanceof Issue86)) {\n-          return false;\n-        }\n-\n-        final Issue86 otherIssue86 = (Issue86) other;\n-        return otherIssue86.id.equals(id) && otherIssue86.children.equals(children);\n+          final Issue86 otherIssue86 = (Issue86) other;\n+          return otherIssue86.id.equals(id) && otherIssue86.children.equals(children);\n       }\n     }\n \n     /***********************************************************************\n      */\n     \n-  @Test\n-  public void deserializeUnwrappedListWhenLocalNameForRootElementAndXmlPropertyMatch() throws Exception {\n-    final String source =\n-        \"<test id=\\\"0\\\">\" +\n-            \"<test id=\\\"0.1\\\">\" +\n-                \"<test id=\\\"0.1.1\\\"/>\" +\n-            \"</test>\" +\n-            \"<test id=\\\"0.2\\\"/>\" +\n-            \"<test id=\\\"0.3\\\">\" +\n-                \"<test id=\\\"0.3.1\\\"/>\" +\n-            \"</test>\" +\n-        \"</test>\";\n-\n-    final Issue86 before = new Issue86(\"0\",\n-        Arrays.asList(new Issue86(\"0.1\",\n-                Arrays.asList(new Issue86(\"0.1.1\", null))),\n-            new Issue86(\"0.2\", null),\n-            new Issue86(\"0.3\",\n-                Arrays.asList(\n-                    new Issue86(\"0.3.1\", null)))));\n-\n-    final XmlMapper mapper = new XmlMapper();\n-    mapper.setSerializationInclusion(Include.NON_NULL);\n-\n-    final String xml = mapper.writeValueAsString(before);\n-    assertEquals(source, xml);\n-\n-    final Issue86 after = mapper.readValue(xml, Issue86.class);\n-    assertEquals(before, after);\n-  }\n+    public void testDeserializeUnwrappedListWhenLocalNameForRootElementAndXmlPropertyMatch() throws Exception\n+    {\n+        final String source =\n+            \"<test id=\\\"0\\\">\" +\n+                \"<test id=\\\"0.1\\\">\" +\n+                    \"<test id=\\\"0.1.1\\\"/>\" +\n+                \"</test>\" +\n+                \"<test id=\\\"0.2\\\"/>\" +\n+                \"<test id=\\\"0.3\\\">\" +\n+                    \"<test id=\\\"0.3.1\\\"/>\" +\n+                \"</test>\" +\n+            \"</test>\";\n+    \n+        final Issue86 before = new Issue86(\"0\",\n+            Arrays.asList(new Issue86(\"0.1\",\n+                    Arrays.asList(new Issue86(\"0.1.1\", null))),\n+                new Issue86(\"0.2\", null),\n+                new Issue86(\"0.3\",\n+                    Arrays.asList(\n+                        new Issue86(\"0.3.1\", null)))));\n+    \n+        final XmlMapper mapper = new XmlMapper();\n+        mapper.setSerializationInclusion(Include.NON_NULL);\n+    \n+        final String xml = mapper.writeValueAsString(before);\n+        assertEquals(source, xml);\n+    \n+        final Issue86 after = mapper.readValue(xml, Issue86.class);\n+        assertEquals(before, after);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/JAXBObjectId170Test.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n+\n+public class JAXBObjectId170Test extends XmlTestBase\n+{\n+    static class Company\n+    {\n+        @XmlElementWrapper(name = \"computers\")\n+        @XmlElement(name = \"computer\")\n+        public List<Computer> computers = new ArrayList<Computer>();\n+\n+        @XmlElementWrapper(name = \"employees\")\n+        @XmlElement(name = \"employee\")\n+        public List<Employee> employees = new ArrayList<Employee>();\n+\n+        public Company() { }\n+\n+        public Company add(Computer computer) {\n+            if (computers == null) {\n+                computers = new ArrayList<Computer>();\n+            }\n+            computers.add(computer);\n+            return this;\n+        }\n+    }\n+\n+    @XmlType(name = \"employee\")\n+    @XmlAccessorType(XmlAccessType.FIELD)\n+    static class Employee {\n+      @XmlAttribute\n+      @XmlID\n+      public String id;\n+\n+      @XmlAttribute\n+      public String name;\n+\n+      @XmlIDREF\n+      public Computer computer;\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT,\n+            property = \"type\")\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = DesktopComputer.class, name = \"desktop\"),\n+            @JsonSubTypes.Type(value = LaptopComputer.class, name = \"laptop\")\n+    })\n+    static class Computer {\n+        public String id;\n+    }\n+\n+    static class DesktopComputer extends Computer {\n+        public String location;\n+\n+        protected DesktopComputer() { }\n+        public DesktopComputer with(String id0, String l) {\n+            id = id0;\n+            location = l;\n+            return this;\n+        }\n+    }\n+\n+    static class LaptopComputer extends Computer {\n+        public String vendor;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // for [dataformat-xml#178]\n+    public void testPolyIdList178() throws Exception\n+    {\n+        final String XML =\n+\"<company>\\n\"+\n+\"<computers>\\n\"+\n+\"    <computers>\\n\"+\n+\"      <desktop id='computer-1'>\\n\"+\n+\"        <location>Bangkok</location>\\n\"+\n+\"      </desktop>\\n\"+\n+\"    </computers>\\n\"+\n+\"    <computers>\\n\"+\n+\"      <desktop id='computer-2'>\\n\"+\n+\"        <location>Pattaya</location>\\n\"+\n+\"      </desktop>\\n\"+\n+\"    </computers>\\n\"+\n+\"    <computers>\\n\"+\n+\"      <laptop id='computer-3'>\\n\"+\n+\"        <vendor>Apple</vendor>\\n\"+\n+\"      </laptop>\\n\"+\n+\"    </computers>\\n\"+\n+\"  </computers>\\n\"+\n+\"  <employees>\\n\"+\n+\"    <employee id='emp-1' name='Robert Patrick'>\\n\"+\n+\"      <computer>computer-3</computer>\\n\"+\n+\"    </employee>\\n\"+\n+\"    <employee id='emp-2' name='Michael Smith'>\\n\"+\n+\"      <computer>computer-2</computer>\\n\"+\n+\"    </employee>\\n\"+\n+\"  </employees>\\n\"+\n+\"</company>\\n\"\n+                ;\n+\n+        XmlMapper mapper = new XmlMapper();\n+        XmlJaxbAnnotationIntrospector xmlIntr = new XmlJaxbAnnotationIntrospector(mapper.getTypeFactory());\n+        xmlIntr.setDefaultUseWrapper(false);\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+                (xmlIntr, new JacksonAnnotationIntrospector());\n+\n+        // should be default but doesn't seem to be?\n+        mapper.setAnnotationIntrospector(intr);\n+\n+        Company result = mapper.readValue(XML, Company.class);\n+        assertNotNull(result);\n+        assertNotNull(result.employees);\n+        assertEquals(2, result.employees.size());\n+        Employee empl2 = result.employees.get(1);\n+        Computer comp2 = empl2.computer;\n+        assertEquals(DesktopComputer.class, comp2.getClass());\n+        assertEquals(\"Pattaya\", ((DesktopComputer) comp2).location);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/EmptyListDeserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/EmptyListDeserTest.java\n                 \"</Config>\\n\",\n                 Config.class);\n         assertNotNull(r);\n+        assertEquals(\"123\", r.id);\n+        assertNotNull(r.entry);\n+        assertEquals(1, r.entry.size());\n+        assertEquals(\"foo\", r.entry.get(0).id);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAnnotationSharingTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAnnotationSharingTest.java\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n \n-// for [Issue#55]\n+// for [dataformat-xml#55]\n public class ListAnnotationSharingTest extends XmlTestBase\n {\n     static class Wrapper {\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAsObjectTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAsObjectTest.java\n         assertEquals(\"d\", values.getValues().get(1).getV());\n     \n         assertEquals(\"array\", values.getType());\n-\n-        // Passes with 2.1.2\n-        /*\n-        assertEquals(2, values.size());\n-        assertEquals(\"c\", values.get(0).getV());\n-        assertEquals(\"d\", values.get(1).getV());\n-        */\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListDeserializationTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListDeserializationTest.java\n         assertEquals(Integer.valueOf(3), bean.values.get(2));\n     }\n \n-    // for [Issue#33]\n+    // for [dataformat-xml#33]\n     public void testWrappedListWithAttribute() throws Exception\n     {\n         ListBeanWrapped bean = MAPPER.readValue(\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListRoundtripTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListRoundtripTest.java\n         public List<Point> points;\n     }\n \n-    // For [Issue#64]\n+    // For [dataformat-xml#64]\n     static class Optional {\n         @JacksonXmlText\n         public String number = \"NOT SET\";\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListSerializationTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListSerializationTest.java\n     {\n         String xml = MAPPER.writeValueAsString(new ListBean(1, 2, 3));\n         xml = removeSjsxpNamespace(xml);\n-        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper...\n         assertEquals(\"<ListBean><values><values>1</values><values>2</values><values>3</values></values></ListBean>\", xml);\n     }\n \n         StringListBean list = new StringListBean(\"a\", \"b\", \"c\");\n         String xml = MAPPER.writeValueAsString(list);\n         xml = removeSjsxpNamespace(xml);\n-        // 06-Dec-2010, tatu: Not completely ok; should default to not using wrapper... but it's what we have now\n         assertEquals(\"<StringListBean><stringList>\"\n                 +\"<strings><text>a</text></strings>\"\n                 +\"<strings><text>b</text></strings>\"\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedLists180Test.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class NestedUnwrappedLists180Test  extends XmlTestBase\n+{\n+    static class Records {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Record> records = new ArrayList<Record>();\n+    }\n+\n+    static class Record {\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<Field> fields = new ArrayList<Field>();\n+    }\n+\n+    static class Field {\n+        @JacksonXmlProperty(isAttribute=true)\n+        public String name;\n+\n+        protected Field() { }\n+        public Field(String n) { name = n; }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+\n+    public void testNestedUnwrappedLists180() throws Exception\n+    {\n+        /*\n+        Records recs = new Records();\n+        recs.records.add(new Record());\n+        recs.records.add(new Record());\n+        recs.records.add(new Record());\n+        recs.records.get(0).fields.add(new Field(\"a\"));\n+        recs.records.get(2).fields.add(new Field(\"b\"));\n+\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n+        */\n+\n+        String xml =\n+\"<Records>\\n\"\n+// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n+//+\"<records>\\n</records>\\n\"\n++\"<records></records>\\n\"\n++\"  <records>\\n\"\n++\"   <fields name='b'/>\\n\"\n++\"  </records>\\n\"\n++\"</Records>\\n\"\n+;\n+        \n+//System.out.println(\"XML: \"+xml);\n+\n+        Records result = MAPPER.readValue(xml, Records.class);\n+        assertNotNull(result.records);\n+        assertEquals(2, result.records.size());\n+        assertNotNull(result.records.get(1));\n+        assertEquals(1, result.records.get(1).fields.size());\n+        assertEquals(\"b\", result.records.get(1).fields.get(0).name);\n+\n+        // also, first one ought not be null should it? Ideally not...\n+        assertNotNull(result.records.get(0));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n \n import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n-import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n \n     public void setUp() throws Exception\n     {\n         super.setUp();\n-        JacksonXmlModule module = new JacksonXmlModule();\n-        module.setDefaultUseWrapper(false);\n-        _xmlMapper = new XmlMapper(module);\n-        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.PascalCaseStrategy());\n+        _xmlMapper = new XmlMapper()\n+            .setDefaultUseWrapper(false);\n+        _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.UpperCamelCaseStrategy());\n         _xmlMapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n     }\n     \n         ServiceDelivery svc = _xmlMapper.readValue(XML, ServiceDelivery.class);\n         assertNotNull(svc);\n         assertNotNull(svc.vehicleMonitoringDelivery);\n-        assertEquals(0, svc.vehicleMonitoringDelivery.size());\n+        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n+        assertEquals(1, svc.vehicleMonitoringDelivery.size());\n     }\n \n     public void testNestedWithEmpty2() throws Exception\n         assertEquals(1, svc.vehicleMonitoringDelivery.size());\n         VehicleMonitoringDelivery del = svc.vehicleMonitoringDelivery.get(0);\n         assertNotNull(del.vehicleActivity);\n-        assertEquals(0, del.vehicleActivity.size());\n+        // 06-Jan-2015, tatu: Really should have one empty entry, not 0\n+        assertEquals(1, del.vehicleActivity.size());\n     }\n     \n     public void testNested1_2b() throws Exception\n         assertNotNull(act);\n         assertEquals(\"2013-09-12T09:29:07.536-04:00\", act.recordedAtTime);\n     }\n-    \n+\n     public void testNested2_1() throws Exception\n     {\n         final String XML =\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/UnwrappedListWithEmptyCData129Test.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/UnwrappedListWithEmptyCData129Test.java\n         MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n     }\n \n-    // for [#129]\n+    // for [dataformat-xml#129]\n     public void testListWithEmptyCData() throws Exception\n     {\n         _testListWithEmptyCData(\" \");\n \n         List<String> values = result.value;\n \n-        assertEquals(3, values.size()); // expecting 3 values, getting only 1\n+        assertEquals(3, values.size()); // expecting 3 values\n         assertEquals(\"A\", values.get(0));\n         assertEquals(cdata, values.get(1)); // expecting empty string in second position\n         assertEquals(\"C\", values.get(2));\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/EmptyPolymorphicTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+// test(s) for [dataformat-xml#111]\n+public class EmptyPolymorphicTest extends XmlTestBase\n+{\n+    static class Data {\n+        public String name;\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+        @JsonSubTypes({ @JsonSubTypes.Type(EmptyProxy.class) })\n+        public Proxy proxy;\n+\n+        public Data() { }\n+        public Data(String n) {\n+            name = n;\n+            proxy = new EmptyProxy();\n+        }\n+    }\n+\n+    static interface Proxy { }\n+\n+    @JsonTypeName(\"empty\")\n+    static class EmptyProxy implements Proxy { }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    protected XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testEmpty() throws Exception\n+    {\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Data(\"Foobar\"));\n+//System.out.println(\"XML:\\n\"+xml);\n+        final Data data = MAPPER.readValue(xml, Data.class);\n+//                \"<data><name>Foobar</name><proxy><empty></empty></proxy></data>\"\n+        assertNotNull(data);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n         public SubTypeWithClassProperty() { }\n         public SubTypeWithClassProperty(String s) { name = s; }\n     }\n-    \n+\n     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n     protected static class BaseTypeWithClassObject { }\n \n         super.setUp();\n         _xmlMapper = new XmlMapper();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassProperty(\"Foobar\"));\n \n         // Type info should be written as an attribute, so:\n-        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n-         *   inclusion, which allows use of attribute over element, so:\n-         */\n         final String exp = \n             \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.dataformat.xml.misc.PolymorphicTypesTest..SubTypeWithClassProperty\\\">\"\n             //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.types.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n     }\n \n     /**\n-     * Test for issue 81\n+     * Test for [dataformat-xml#81]\n      */\n     public void testAsPropertyWithObjectId() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n     {\n         String xml = MAPPER.writeValueAsString(new Simple());\n         assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n-        // [Issue#56]: should work with indentation as well\n+        // [dataformat-xml#56]: should work with indentation as well\n         xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Simple());\n-        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\\n\", xml);\n     }\n \n     public void testDeserializeAsText() throws IOException\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestIndentation.java\n     /**********************************************************\n      */\n \n-    // Verify [JACKSON-444], Issue #1\n+    // Verify [dataformat-xml#1]\n     public void testSimpleStringBean() throws Exception\n     {\n         StringWrapperBean input = new StringWrapperBean(\"abc\");\n     public void testWithAttr() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new AttrBean());\n-        assertEquals(\"<AttrBean count=\\\"3\\\"/>\", xml);\n+        assertEquals(\"<AttrBean count=\\\"3\\\"/>\\n\", xml);\n         String xml2 = _xmlMapper.writeValueAsString(new AttrBean2());\n-        assertEquals(\"<AttrBean2 count=\\\"3\\\">\\n  <value>14</value>\\n</AttrBean2>\", xml2);\n+        assertEquals(\"<AttrBean2 count=\\\"3\\\">\\n  <value>14</value>\\n</AttrBean2>\\n\", xml2);\n     }\n \n     public void testEmptyElem() throws Exception\n     {\n         PojoFor123 simple = new PojoFor123(\"foobar\");\n         String xml = _xmlMapper.writeValueAsString(simple);\n-        assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\", xml);\n+        assertEquals(\"<PojoFor123 name=\\\"foobar\\\"/>\\n\", xml);\n     }\n \n     public void testMultiLevel172() throws Exception\n     {\n         Company root = new Company();\n         root.employee.add(new Employee(\"abc\"));\n-        String xml = _xmlMapper.writeValueAsString(root);\n-        assertEquals(\"<Company>\\n\"\n+        String xml = _xmlMapper.writer()\n+                .with(ToXmlGenerator.Feature.WRITE_XML_DECLARATION)\n+                .writeValueAsString(root);\n+        // unify possible apostrophes to quotes\n+        xml = aposToQuotes(xml);\n+        // with indentation, should get linefeeds in prolog/epilog too\n+        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n+                +\"<Company>\\n\"\n                 +\"  <e>\\n\"\n                 +\"    <employee>\\n\"\n                 +\"      <id>abc</id>\\n\"\n                 +\"      <type>FULL_TIME</type>\\n\"\n                 +\"    </employee>\\n\"\n                 +\"  </e>\\n\"\n-                +\"</Company>\",\n+                +\"</Company>\\n\",\n                 xml);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n \n     public void testSimpleWithEmpty() throws Exception\n     {\n+        // 06-Jan-2015, tatu: Not superbly simple, actually; whether we'll have `null`\n+        //    or `{}` depends on context; if in array context, latter; otherwise former\n         assertEquals(\"{\\\"leaf\\\":null}\",\n                 _readXmlWriteJson(\"<root><leaf /></root>\"));\n     }", "timestamp": 1459827623, "metainfo": ""}