{"sha": "dcff95719ade028cef2fef072bcbff2516e76461", "log": "Minor improvements to type handling; now allows class name use for inner classes.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/JacksonXmlAnnotationIntrospector.java\n \n import javax.xml.namespace.QName;\n \n-import org.codehaus.jackson.annotate.JsonTypeInfo;\n import org.codehaus.jackson.map.introspect.Annotated;\n import org.codehaus.jackson.map.introspect.AnnotatedField;\n import org.codehaus.jackson.map.introspect.AnnotatedMethod;\n import org.codehaus.jackson.map.introspect.AnnotatedParameter;\n import org.codehaus.jackson.map.introspect.JacksonAnnotationIntrospector;\n-import org.codehaus.jackson.map.jsontype.TypeIdResolver;\n import org.codehaus.jackson.map.jsontype.impl.StdTypeResolverBuilder;\n \n import com.fasterxml.jackson.xml.annotate.*;\n     implements XmlAnnotationIntrospector\n {    \n     /*\n-    /**********************************************************\n+    /**********************************************************************\n     /* XmlAnnotationIntrospector\n-    /**********************************************************\n+    /**********************************************************************\n      */\n \n     @Override\n     }\n     \n     /*\n-    /**********************************************************\n+    /**********************************************************************\n     /* Overrides for name, property detection\n-    /**********************************************************\n+    /**********************************************************************\n      */\n     \n     @Override\n     }\n \n     /*\n-    /**********************************************************\n+    /**********************************************************************\n     /* Overrides for non-public helper methods\n-    /**********************************************************\n+    /**********************************************************************\n      */\n \n     /**\n     {\n         return new XmlTypeResolverBuilder();\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Internal helper methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Since XML names can not contain all characters JSON names can, we may\n-     * need to replace characters. Let's start with trivial replacement of\n-     * ASCII characters that can not be included.\n-     */\n-    protected static String sanitizeXmlName(String name)\n-    {\n-        StringBuilder sb = new StringBuilder(name);\n-        int changes = 0;\n-        for (int i = 0, len = name.length(); i < len; ++i) {\n-            char c = name.charAt(i);\n-            if (c > 127) continue;\n-            if (c >= 'a' && c <= 'z') continue;\n-            if (c >= 'A' && c <= 'Z') continue;\n-            if (c >= '0' && c <= '9') continue;\n-            if (c == '_' || c == '.' || c == '-') continue;\n-            // Ok, need to replace\n-            ++changes;\n-            sb.setCharAt(i, '_');\n-        }\n-        if (changes == 0) {\n-            return name;\n-        }\n-        return sb.toString();\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Custom specialization of {@link StdTypeResolverBuilder}; needed so that\n-     * type id property name can be modified as necessary to make it legal\n-     * xml element or attribute name.\n-     */\n-    protected static class XmlTypeResolverBuilder extends StdTypeResolverBuilder\n-    {\n-        @Override\n-        public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n-        {\n-            super.init(idType, idRes);\n-            if (_typeProperty != null) {\n-                _typeProperty = sanitizeXmlName(_typeProperty);\n-            }\n-            return this;\n-        }\n-\n-        @Override\n-        public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n-        {\n-            // ok to have null/empty; will restore to use defaults\n-            if (typeIdPropName == null || typeIdPropName.length() == 0) {\n-                typeIdPropName = _idType.getDefaultPropertyName();\n-            }\n-            _typeProperty = sanitizeXmlName(typeIdPropName);\n-            return this;\n-        }\n-    }\n }\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlTypeResolverBuilder.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.util.Collection;\n+\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import org.codehaus.jackson.map.jsontype.NamedType;\n+import org.codehaus.jackson.map.jsontype.TypeIdResolver;\n+import org.codehaus.jackson.map.jsontype.impl.ClassNameIdResolver;\n+import org.codehaus.jackson.map.jsontype.impl.MinimalClassNameIdResolver;\n+import org.codehaus.jackson.map.jsontype.impl.StdTypeResolverBuilder;\n+import org.codehaus.jackson.map.jsontype.impl.TypeNameIdResolver;\n+import org.codehaus.jackson.type.JavaType;\n+\n+/**\n+ * Custom specialization of {@link StdTypeResolverBuilder}; needed so that\n+ * type id property name can be modified as necessary to make it legal\n+ * xml element or attribute name.\n+ */\n+public class XmlTypeResolverBuilder extends StdTypeResolverBuilder\n+{\n+    @Override\n+    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n+    {\n+        super.init(idType, idRes);\n+        if (_typeProperty != null) {\n+            _typeProperty = sanitizeXmlTypeName(_typeProperty);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n+    {\n+        // ok to have null/empty; will restore to use defaults\n+        if (typeIdPropName == null || typeIdPropName.length() == 0) {\n+            typeIdPropName = _idType.getDefaultPropertyName();\n+        }\n+        _typeProperty = sanitizeXmlTypeName(typeIdPropName);\n+        return this;\n+    }\n+\n+    @Override\n+    protected TypeIdResolver idResolver(JavaType baseType, Collection<NamedType> subtypes,\n+            boolean forSer, boolean forDeser)\n+    {\n+        if (_customIdResolver != null) {\n+            return _customIdResolver;\n+        }\n+        // Only override handlings of class, minimal class; name is good as is\n+        switch (_idType) {\n+        case CLASS:\n+            return new XmlClassNameIdResolver(baseType);\n+        case MINIMAL_CLASS:\n+            return new XmlMinimalClassNameIdResolver(baseType);\n+        }\n+        return super.idResolver(baseType, subtypes, forSer, forDeser);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal helper methods\n+    /**********************************************************************\n+     */\n+    \n+    /**\n+     * Since XML names can not contain all characters JSON names can, we may\n+     * need to replace characters. Let's start with trivial replacement of\n+     * ASCII characters that can not be included.\n+     */\n+    protected static String sanitizeXmlTypeName(String name)\n+    {\n+        StringBuilder sb = new StringBuilder(name);\n+        int changes = 0;\n+        for (int i = 0, len = name.length(); i < len; ++i) {\n+            char c = name.charAt(i);\n+            if (c > 127) continue;\n+            if (c >= 'a' && c <= 'z') continue;\n+            if (c >= 'A' && c <= 'Z') continue;\n+            if (c >= '0' && c <= '9') continue;\n+            if (c == '_' || c == '.' || c == '-') continue;\n+            // Ok, need to replace\n+            ++changes;\n+            sb.setCharAt(i, '_');\n+        }\n+        if (changes == 0) {\n+            return name;\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Helper method for encoding regular Java class name in form that\n+     * can be used as XML element name.\n+     */\n+    protected static String encodeXmlClassName(String className)\n+    {\n+        /* For now, let's just replace '$'s with double dots...\n+         * Perhaps make configurable in future?\n+         */\n+        int ix = className.lastIndexOf('$');\n+        if (ix >= 0) {\n+            StringBuilder sb = new StringBuilder(className);\n+            do {\n+                sb.replace(ix, ix+1, \"..\");\n+                ix = className.lastIndexOf('$', ix-1);\n+            } while (ix >= 0);\n+            className = sb.toString();\n+        }\n+        return className;\n+    }\n+\n+    /**\n+     * Helper method for decoding \"XML safe\" Java class name back into\n+     * actual class name\n+     */\n+    protected static String decodeXmlClassName(String className)\n+    {\n+        int ix = className.lastIndexOf(\"..\");\n+        if (ix >= 0) {\n+            StringBuilder sb = new StringBuilder(className);\n+            do {\n+                sb.replace(ix, ix+2, \"$\");\n+                ix = className.lastIndexOf(\"..\", ix-1);\n+            } while (ix >= 0);\n+            className = sb.toString();\n+        }\n+        return className;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Customized class name handlers\n+    /**********************************************************************\n+     */\n+\n+    protected static class XmlClassNameIdResolver\n+        extends ClassNameIdResolver\n+    {\n+        public XmlClassNameIdResolver(JavaType baseType)\n+        {\n+            super(baseType);\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            return encodeXmlClassName(super.idFromValue(value));\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            return super.typeFromId(decodeXmlClassName(id));\n+        }\n+    }\n+\n+    protected static class XmlMinimalClassNameIdResolver\n+        extends MinimalClassNameIdResolver\n+    {\n+        public XmlMinimalClassNameIdResolver(JavaType baseType)\n+        {\n+            super(baseType);\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            return encodeXmlClassName(super.idFromValue(value));\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            return super.typeFromId(decodeXmlClassName(id));\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n \n import org.codehaus.jackson.JsonGenerationException;\n import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n import org.codehaus.jackson.map.JsonMappingException;\n import org.codehaus.jackson.map.SerializerProvider;\n import org.codehaus.jackson.map.TypeSerializer;\n             TypeSerializer typeSer)\n         throws IOException, JsonGenerationException\n     {\n-        // Ok: let's serialize type id as attribute\n-        ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n-        xgen.setNextIsAttribute(true);\n-        super.serializeWithType(bean, jgen, provider, typeSer);\n-        if (_attributeCount == 0) { // if no attributes, need to reset\n-            xgen.setNextIsAttribute(false);\n+        /* Ok: let's serialize type id as attribute, but if (and only if!)\n+         * we are using AS_PROPERTY\n+         */\n+        if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n+            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            xgen.setNextIsAttribute(true);\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n+            if (_attributeCount == 0) { // if no attributes, need to reset\n+                xgen.setNextIsAttribute(false);\n+            }\n+        } else {\n+            super.serializeWithType(bean, jgen, provider, typeSer);\n         }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n \n         public SubTypeWithClassArray() { }\n         public SubTypeWithClassArray(String s) { name = s; }\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    static class BaseTypeWithClassObject { }\n+\n+    static class SubTypeWithClassObject extends BaseTypeWithClassObject {\n+        public String name;\n+    \n+        public SubTypeWithClassObject() { }\n+        public SubTypeWithClassObject(String s) { name = s; }\n     }\n     \n     /**\n          *   inclusion, which allows use of attribute over element, so:\n          */\n         final String exp = \n-            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty\\\">\"\n-            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty</_class>\"\n+            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.xml.TestPolymorphic..SubTypeWithClassProperty\\\">\"\n+            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n             +\"<name>Foobar</name></SubTypeWithClassProperty>\"\n                 ;\n         assertEquals(exp, xml);\n     public void testAsWrappedClassArray() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new ClassArrayWrapper(\"Foobar\"));\n-System.err.println(\"XML/wrapper-array == \"+xml);\n-        \n         ClassArrayWrapper result = _xmlMapper.readValue(xml, ClassArrayWrapper.class);\n         assertNotNull(result);\n         assertEquals(SubTypeWithClassArray.class, result.wrapped.getClass());\n         assertEquals(\"Foobar\", ((SubTypeWithClassArray) result.wrapped).name);\n     }\n-    /*\n-\n-    */\n         \n     // Only works if NOT an inner class (\"$\" in inner class throws a wrench)...\n     /* 20-Dec-2010, tatu: Idiotic Eclipse-JUNIT tries to run tests on these.\n      *   Better comment out for now.\n      */\n-    /*\n     public void testAsClassObject() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassObject(\"Foobar\"));\n-\n         Object result = _xmlMapper.readValue(xml, BaseTypeWithClassObject.class);\n         assertNotNull(result);\n         assertEquals(SubTypeWithClassObject.class, result.getClass());\n         assertEquals(\"Foobar\", ((SubTypeWithClassObject) result).name);\n     }\n-    */\n }\n-\n-/*\n-@JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n-class BaseTypeWithClassObject {\n-}\n-\n-class SubTypeWithClassObject extends BaseTypeWithClassObject {\n-    public String name;\n-\n-    public SubTypeWithClassObject() { }\n-    public SubTypeWithClassObject(String s) { name = s; }\n-}\n-*/\n+   ", "timestamp": 1294985817, "metainfo": ""}