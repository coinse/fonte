{"sha": "60cc83af7f22fe903edb7d43f4617e779c10909a", "log": "Sort members, classes and methods (but not fields).  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n  */\n public class CSVFormat implements Serializable {\n \n+    /**\n+     * Builds CSVFormat objects.\n+     */\n+    public static class CSVFormatBuilder {\n+\n+        private char delimiter;\n+        private Character quoteChar;\n+        private Quote quotePolicy;\n+        private Character commentStart;\n+        private Character escape;\n+        private boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+        private boolean ignoreEmptyLines;\n+        private String recordSeparator; // for outputs\n+        private String[] header;\n+\n+        /**\n+         * Creates a basic CSVFormatBuilder.\n+         *\n+         * @param delimiter\n+         *            the char used for value separation, must not be a line break character\n+         * @throws IllegalArgumentException if the delimiter is a line break character\n+         */\n+        // package protected to give access without needing a synthetic accessor\n+        CSVFormatBuilder(final char delimiter){\n+            this(delimiter, null, null, null, null, false, false, null, null);\n+        }\n+\n+        /**\n+         * Creates a customized CSV format.\n+         *\n+         * @param delimiter\n+         *            the char used for value separation, must not be a line break character\n+         * @param quoteChar\n+         *            the char used as value encapsulation marker\n+         * @param quotePolicy\n+         *            the quote policy\n+         * @param commentStart\n+         *            the char used for comment identification\n+         * @param escape\n+         *            the char used to escape special characters in values\n+         * @param ignoreSurroundingSpaces\n+         *            <tt>true</tt> when whitespaces enclosing values should be ignored\n+         * @param ignoreEmptyLines\n+         *            <tt>true</tt> when the parser should skip empty lines\n+         * @param recordSeparator\n+         *            the line separator to use for output\n+         * @param header\n+         *            the header\n+         * @throws IllegalArgumentException if the delimiter is a line break character\n+         */\n+        // package protected for use by test code\n+        CSVFormatBuilder(final char delimiter, final Character quoteChar,\n+                final Quote quotePolicy, final Character commentStart,\n+                final Character escape, final boolean ignoreSurroundingSpaces,\n+                final boolean ignoreEmptyLines, final String lineSeparator,\n+                final String[] header) {\n+            if (isLineBreak(delimiter)) {\n+                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n+            }\n+            this.delimiter = delimiter;\n+            this.quoteChar = quoteChar;\n+            this.quotePolicy = quotePolicy;\n+            this.commentStart = commentStart;\n+            this.escape = escape;\n+            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n+            this.ignoreEmptyLines = ignoreEmptyLines;\n+            this.recordSeparator = lineSeparator;\n+            this.header = header;\n+        }\n+\n+        /**\n+         * Creates a CSVFormatBuilder, using the values of the given CSVFormat.\n+         *\n+         * @param format\n+         *            The format to use values from\n+         */\n+        @SuppressWarnings(\"synthetic-access\") // TODO fields could be made package-protected\n+        // package protected to give access without needing a synthetic accessor\n+        CSVFormatBuilder(final CSVFormat format) {\n+            this(format.delimiter, format.quoteChar, format.quotePolicy,\n+                    format.commentStart, format.escape,\n+                    format.ignoreSurroundingSpaces, format.ignoreEmptyLines,\n+                    format.recordSeparator, format.header);\n+        }\n+\n+        /**\n+         * Builds a new CSVFormat configured with the values from this builder.\n+         *\n+         * @return a new CSVFormat\n+         */\n+        public CSVFormat build() {\n+            validate();\n+            return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n+        }\n+\n+        /**\n+         * Parses the specified content. Short-hand for:\n+         * <pre>format.build().parse(in);</pre>\n+         *\n+         * @param in\n+         *            the input stream\n+         * @return a CSVRecord stream\n+         * @throws IOException\n+         *             If an I/O error occurs\n+         */\n+        public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n+            return this.build().parse(in);\n+        }\n+\n+        /**\n+         * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n+         *\n+         * @throws IllegalStateException\n+         */\n+        private void validate() throws IllegalStateException {\n+            if (quoteChar != null && delimiter == quoteChar.charValue()) {\n+                throw new IllegalStateException(\n+                        \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n+            }\n+\n+            if (escape != null && delimiter == escape.charValue()) {\n+                throw new IllegalStateException(\n+                        \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n+            }\n+\n+            if (commentStart != null && delimiter == commentStart.charValue()) {\n+                throw new IllegalStateException(\n+                        \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n+            }\n+\n+            if (quoteChar != null && quoteChar.equals(commentStart)) {\n+                throw new IllegalStateException(\n+                        \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n+            }\n+\n+            if (escape != null && escape.equals(commentStart)) {\n+                throw new IllegalStateException(\n+                        \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n+            }\n+\n+            if (escape == null && quotePolicy == Quote.NONE) {\n+                throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n+            }\n+        }\n+\n+        /**\n+         * Sets the comment start marker of the format to the specified character.\n+         *\n+         * Note that the comment introducer character is only recognised at the start of a line.\n+         *\n+         * @param commentStart\n+         *            the comment start marker\n+         * @return This builder with the specified character as the comment start marker\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withCommentStart(final char commentStart) {\n+            return withCommentStart(Character.valueOf(commentStart));\n+        }\n+\n+        /**\n+         * Sets the comment start marker of the format to the specified character.\n+         *\n+         * Note that the comment introducer character is only recognised at the start of a line.\n+         *\n+         * @param commentStart\n+         *            the comment start marker\n+         * @return This builder with the specified character as the comment start marker\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withCommentStart(final Character commentStart) {\n+            if (isLineBreak(commentStart)) {\n+                throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n+            }\n+            this.commentStart = commentStart;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the delimiter of the format to the specified character.\n+         *\n+         * @param delimiter\n+         *            the delimiter character\n+         * @return This builder with the specified character as delimiter\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withDelimiter(final char delimiter) {\n+            if (isLineBreak(delimiter)) {\n+                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n+            }\n+            this.delimiter = delimiter;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the escape character of the format to the specified character.\n+         *\n+         * @param escape\n+         *            the escape character\n+         * @return This builder with the specified character as the escape character\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withEscape(final char escape) {\n+            return withEscape(Character.valueOf(escape));\n+        }\n+\n+        /**\n+         * Sets the escape character of the format to the specified character.\n+         *\n+         * @param escape\n+         *            the escape character\n+         * @return This builder with the specified character as the escape character\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withEscape(final Character escape) {\n+            if (isLineBreak(escape)) {\n+                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n+            }\n+            this.escape = escape;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the header of the format. The header can either be parsed automatically from the\n+         * input file with:\n+         *\n+         * <pre>\n+         * CSVFormat format = aformat.withHeader();\n+         * </pre>\n+         *\n+         * or specified manually with:\n+         *\n+         * <pre>\n+         * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+         * </pre>\n+         *\n+         * @param header\n+         *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n+         *\n+         * @return This builder with the specified header\n+         */\n+        public CSVFormatBuilder withHeader(final String... header) {\n+            this.header = header;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the empty line skipping behavior of the format.\n+         *\n+         * @param ignoreEmptyLines\n+         *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n+         *            <tt>false</tt> to translate empty lines to empty records.\n+         * @return This builder with the specified empty line skipping behavior.\n+         */\n+        public CSVFormatBuilder withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n+            this.ignoreEmptyLines = ignoreEmptyLines;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the trimming behavior of the format.\n+         *\n+         * @param ignoreSurroundingSpaces\n+         *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n+         *            spaces as is.\n+         * @return This builder with the specified trimming behavior.\n+         */\n+        public CSVFormatBuilder withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n+            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the quoteChar of the format to the specified character.\n+         *\n+         * @param quoteChar\n+         *            the quoteChar character\n+         * @return This builder with the specified character as quoteChar\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withQuoteChar(final char quoteChar) {\n+            return withQuoteChar(Character.valueOf(quoteChar));\n+        }\n+\n+        /**\n+         * Sets the quoteChar of the format to the specified character.\n+         *\n+         * @param quoteChar\n+         *            the quoteChar character\n+         * @return This builder with the specified character as quoteChar\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withQuoteChar(final Character quoteChar) {\n+            if (isLineBreak(quoteChar)) {\n+                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n+            }\n+            this.quoteChar = quoteChar;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the output quote policy of the format to the specified value.\n+         *\n+         * @param quotePolicy\n+         *            the quote policy to use for output.\n+         *\n+         * @return This builder with the specified quote policy\n+         */\n+        public CSVFormatBuilder withQuotePolicy(final Quote quotePolicy) {\n+            this.quotePolicy = quotePolicy;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the record separator of the format to the specified character.\n+         *\n+         * @param recordSeparator\n+         *            the record separator to use for output.\n+         *\n+         * @return This builder with the the specified output record separator\n+         */\n+        public CSVFormatBuilder withRecordSeparator(final char recordSeparator) {\n+            return withRecordSeparator(String.valueOf(recordSeparator));\n+        }\n+\n+        /**\n+         * Sets the record separator of the format to the specified String.\n+         *\n+         * @param recordSeparator\n+         *            the record separator to use for output.\n+         *\n+         * @return This builder with the the specified output record separator\n+         */\n+        public CSVFormatBuilder withRecordSeparator(final String recordSeparator) {\n+            this.recordSeparator = recordSeparator;\n+            return this;\n+        }\n+    }\n+\n     private static final long serialVersionUID = 1L;\n-\n+    /**\n+     * Returns true if the given character is a line break character.\n+     *\n+     * @param c\n+     *            the character to check\n+     *\n+     * @return true if <code>c</code> is a line break character\n+     */\n+    // package protected to give access without needing a synthetic accessor\n+    static boolean isLineBreak(final Character c) {\n+        return c != null && isLineBreak(c.charValue());\n+    }\n+    /**\n+     * Creates a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuoteChar('\"')</li>\n+     * <li>withEmptyLinesIgnored(true)</li>\n+     * <li>withLineSeparator(CRLF)</li>\n+     * </ul>\n+     *\n+     * Shortcut for {@code CSVFormat.newBuilder(CSVFormat.DEFAULT)}\n+     *\n+     * @return a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n+     */\n+    public static CSVFormatBuilder newBuilder() {\n+        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null);\n+    }\n     private final char delimiter;\n     private final Character quoteChar;\n     private final Quote quotePolicy;\n     private final Character commentStart;\n     private final Character escape;\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+\n     private final boolean ignoreEmptyLines;\n+\n     private final String recordSeparator; // for outputs\n+\n     private final String[] header;\n \n     /**\n             .build();\n \n     /**\n+     * Returns true if the given character is a line break character.\n+     *\n+     * @param c\n+     *            the character to check\n+     *\n+     * @return true if <code>c</code> is a line break character\n+     */\n+    // package protected to give access without needing a synthetic accessor\n+    static boolean isLineBreak(final char c) {\n+        return c == LF || c == CR;\n+    }\n+\n+    /**\n      * Creates a new CSV format builder.\n      *\n      * @param delimiter\n      */\n     public static CSVFormatBuilder newBuilder(final CSVFormat format) {\n         return new CSVFormatBuilder(format);\n-    }\n-\n-    /**\n-     * Creates a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n-     * <ul>\n-     * <li>withDelimiter(',')</li>\n-     * <li>withQuoteChar('\"')</li>\n-     * <li>withEmptyLinesIgnored(true)</li>\n-     * <li>withLineSeparator(CRLF)</li>\n-     * </ul>\n-     *\n-     * Shortcut for {@code CSVFormat.newBuilder(CSVFormat.DEFAULT)}\n-     *\n-     * @return a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n-     */\n-    public static CSVFormatBuilder newBuilder() {\n-        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null);\n     }\n \n     /**\n         this.header = header == null ? null : header.clone();\n     }\n \n-    /**\n-     * Returns true if the given character is a line break character.\n-     *\n-     * @param c\n-     *            the character to check\n-     *\n-     * @return true if <code>c</code> is a line break character\n-     */\n-    // package protected to give access without needing a synthetic accessor\n-    static boolean isLineBreak(final Character c) {\n-        return c != null && isLineBreak(c.charValue());\n-    }\n-\n-    /**\n-     * Returns true if the given character is a line break character.\n-     *\n-     * @param c\n-     *            the character to check\n-     *\n-     * @return true if <code>c</code> is a line break character\n-     */\n-    // package protected to give access without needing a synthetic accessor\n-    static boolean isLineBreak(final char c) {\n-        return c == LF || c == CR;\n-    }\n-\n-    /**\n-     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n-     *\n-     * @return the delimiter character\n-     */\n-    public char getDelimiter() {\n-        return delimiter;\n-    }\n-\n-    /**\n-     * Returns the character used to encapsulate values containing special characters.\n-     *\n-     * @return the quoteChar character\n-     */\n-    public Character getQuoteChar() {\n-        return quoteChar;\n-    }\n-\n-    /**\n-     * Returns whether an quoteChar has been defined.\n-     *\n-     * @return {@code true} if an quoteChar is defined\n-     */\n-    public boolean isQuoting() {\n-        return quoteChar != null;\n-    }\n-\n-    /**\n-     * Returns the character marking the start of a line comment.\n-     *\n-     * @return the comment start marker.\n-     */\n-    public Character getCommentStart() {\n-        return commentStart;\n-    }\n-\n-    /**\n-     * Specifies whether comments are supported by this format.\n-     *\n-     * Note that the comment introducer character is only recognised at the start of a line.\n-     *\n-     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n-     */\n-    public boolean isCommentingEnabled() {\n-        return commentStart != null;\n-    }\n-\n-    /**\n-     * Returns the escape character.\n-     *\n-     * @return the escape character\n-     */\n-    public Character getEscape() {\n-        return escape;\n-    }\n-\n-    /**\n-     * Returns whether escape are being processed.\n-     *\n-     * @return {@code true} if escapes are processed\n-     */\n-    public boolean isEscaping() {\n-        return escape != null;\n-    }\n-\n-    /**\n-     * Specifies whether spaces around values are ignored when parsing input.\n-     *\n-     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n-     *         value.\n-     */\n-    public boolean getIgnoreSurroundingSpaces() {\n-        return ignoreSurroundingSpaces;\n-    }\n-\n-    /**\n-     * Specifies whether empty lines between records are ignored when parsing input.\n-     *\n-     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n-     *         records.\n-     */\n-    public boolean getIgnoreEmptyLines() {\n-        return ignoreEmptyLines;\n-    }\n-\n-    /**\n-     * Returns the line separator delimiting output records.\n-     *\n-     * @return the line separator\n-     */\n-    public String getRecordSeparator() {\n-        return recordSeparator;\n-    }\n-\n-    String[] getHeader() {\n-        return header;\n-    }\n-\n-    /**\n-     * Parses the specified content.\n-     *\n-     * @param in\n-     *            the input stream\n-     * @return a stream of CSVRecord\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n-        return new CSVParser(in, this);\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+\n+        final CSVFormat other = (CSVFormat) obj;\n+        if (delimiter != other.delimiter) {\n+            return false;\n+        }\n+        if (quotePolicy != other.quotePolicy) {\n+            return false;\n+        }\n+        if (quoteChar == null) {\n+            if (other.quoteChar != null) {\n+                return false;\n+            }\n+        } else if (!quoteChar.equals(other.quoteChar)) {\n+            return false;\n+        }\n+        if (commentStart == null) {\n+            if (other.commentStart != null) {\n+                return false;\n+            }\n+        } else if (!commentStart.equals(other.commentStart)) {\n+            return false;\n+        }\n+        if (escape == null) {\n+            if (other.escape != null) {\n+                return false;\n+            }\n+        } else if (!escape.equals(other.escape)) {\n+            return false;\n+        }\n+        if (!Arrays.equals(header, other.header)) {\n+            return false;\n+        }\n+        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n+            return false;\n+        }\n+        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n+            return false;\n+        }\n+        if (recordSeparator == null) {\n+            if (other.recordSeparator != null) {\n+                return false;\n+            }\n+        } else if (!recordSeparator.equals(other.recordSeparator)) {\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n         }\n     }\n \n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n-        if (isEscaping()) {\n-            sb.append(' ');\n-            sb.append(\"Escape=<\").append(escape).append('>');\n-        }\n-        if (isQuoting()) {\n-            sb.append(' ');\n-            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n-        }\n-        if (isCommentingEnabled()) {\n-            sb.append(' ');\n-            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n-        }\n-        if (getIgnoreEmptyLines()) {\n-            sb.append(\" EmptyLines:ignored\");\n-        }\n-        if (getIgnoreSurroundingSpaces()) {\n-            sb.append(\" SurroundingSpaces:ignored\");\n-        }\n-        return sb.toString();\n+    /**\n+     * Returns the character marking the start of a line comment.\n+     *\n+     * @return the comment start marker.\n+     */\n+    public Character getCommentStart() {\n+        return commentStart;\n+    }\n+\n+    /**\n+     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n+     *\n+     * @return the delimiter character\n+     */\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    /**\n+     * Returns the escape character.\n+     *\n+     * @return the escape character\n+     */\n+    public Character getEscape() {\n+        return escape;\n+    }\n+\n+    String[] getHeader() {\n+        return header;\n+    }\n+\n+    /**\n+     * Specifies whether empty lines between records are ignored when parsing input.\n+     *\n+     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n+     *         records.\n+     */\n+    public boolean getIgnoreEmptyLines() {\n+        return ignoreEmptyLines;\n+    }\n+\n+    /**\n+     * Specifies whether spaces around values are ignored when parsing input.\n+     *\n+     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n+     *         value.\n+     */\n+    public boolean getIgnoreSurroundingSpaces() {\n+        return ignoreSurroundingSpaces;\n+    }\n+\n+    /**\n+     * Returns the character used to encapsulate values containing special characters.\n+     *\n+     * @return the quoteChar character\n+     */\n+    public Character getQuoteChar() {\n+        return quoteChar;\n     }\n \n     /**\n      */\n     public Quote getQuotePolicy() {\n         return quotePolicy;\n+    }\n+\n+    /**\n+     * Returns the line separator delimiting output records.\n+     *\n+     * @return the line separator\n+     */\n+    public String getRecordSeparator() {\n+        return recordSeparator;\n     }\n \n     @Override\n         return result;\n     }\n \n-    @Override\n-    public boolean equals(final Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-\n-        final CSVFormat other = (CSVFormat) obj;\n-        if (delimiter != other.delimiter) {\n-            return false;\n-        }\n-        if (quotePolicy != other.quotePolicy) {\n-            return false;\n-        }\n-        if (quoteChar == null) {\n-            if (other.quoteChar != null) {\n-                return false;\n-            }\n-        } else if (!quoteChar.equals(other.quoteChar)) {\n-            return false;\n-        }\n-        if (commentStart == null) {\n-            if (other.commentStart != null) {\n-                return false;\n-            }\n-        } else if (!commentStart.equals(other.commentStart)) {\n-            return false;\n-        }\n-        if (escape == null) {\n-            if (other.escape != null) {\n-                return false;\n-            }\n-        } else if (!escape.equals(other.escape)) {\n-            return false;\n-        }\n-        if (!Arrays.equals(header, other.header)) {\n-            return false;\n-        }\n-        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n-            return false;\n-        }\n-        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n-            return false;\n-        }\n-        if (recordSeparator == null) {\n-            if (other.recordSeparator != null) {\n-                return false;\n-            }\n-        } else if (!recordSeparator.equals(other.recordSeparator)) {\n-            return false;\n-        }\n-        return true;\n+    /**\n+     * Specifies whether comments are supported by this format.\n+     *\n+     * Note that the comment introducer character is only recognised at the start of a line.\n+     *\n+     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n+     */\n+    public boolean isCommentingEnabled() {\n+        return commentStart != null;\n+    }\n+\n+    /**\n+     * Returns whether escape are being processed.\n+     *\n+     * @return {@code true} if escapes are processed\n+     */\n+    public boolean isEscaping() {\n+        return escape != null;\n+    }\n+\n+    /**\n+     * Returns whether an quoteChar has been defined.\n+     *\n+     * @return {@code true} if an quoteChar is defined\n+     */\n+    public boolean isQuoting() {\n+        return quoteChar != null;\n+    }\n+\n+    /**\n+     * Parses the specified content.\n+     *\n+     * @param in\n+     *            the input stream\n+     * @return a stream of CSVRecord\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n+        return new CSVParser(in, this);\n     }\n \n     /**\n         return new CSVFormatBuilder(this);\n     }\n \n-    /**\n-     * Builds CSVFormat objects.\n-     */\n-    public static class CSVFormatBuilder {\n-\n-        private char delimiter;\n-        private Character quoteChar;\n-        private Quote quotePolicy;\n-        private Character commentStart;\n-        private Character escape;\n-        private boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n-        private boolean ignoreEmptyLines;\n-        private String recordSeparator; // for outputs\n-        private String[] header;\n-\n-        /**\n-         * Creates a customized CSV format.\n-         *\n-         * @param delimiter\n-         *            the char used for value separation, must not be a line break character\n-         * @param quoteChar\n-         *            the char used as value encapsulation marker\n-         * @param quotePolicy\n-         *            the quote policy\n-         * @param commentStart\n-         *            the char used for comment identification\n-         * @param escape\n-         *            the char used to escape special characters in values\n-         * @param ignoreSurroundingSpaces\n-         *            <tt>true</tt> when whitespaces enclosing values should be ignored\n-         * @param ignoreEmptyLines\n-         *            <tt>true</tt> when the parser should skip empty lines\n-         * @param recordSeparator\n-         *            the line separator to use for output\n-         * @param header\n-         *            the header\n-         * @throws IllegalArgumentException if the delimiter is a line break character\n-         */\n-        // package protected for use by test code\n-        CSVFormatBuilder(final char delimiter, final Character quoteChar,\n-                final Quote quotePolicy, final Character commentStart,\n-                final Character escape, final boolean ignoreSurroundingSpaces,\n-                final boolean ignoreEmptyLines, final String lineSeparator,\n-                final String[] header) {\n-            if (isLineBreak(delimiter)) {\n-                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n-            }\n-            this.delimiter = delimiter;\n-            this.quoteChar = quoteChar;\n-            this.quotePolicy = quotePolicy;\n-            this.commentStart = commentStart;\n-            this.escape = escape;\n-            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n-            this.ignoreEmptyLines = ignoreEmptyLines;\n-            this.recordSeparator = lineSeparator;\n-            this.header = header;\n-        }\n-\n-        /**\n-         * Creates a CSVFormatBuilder, using the values of the given CSVFormat.\n-         *\n-         * @param format\n-         *            The format to use values from\n-         */\n-        @SuppressWarnings(\"synthetic-access\") // TODO fields could be made package-protected\n-        // package protected to give access without needing a synthetic accessor\n-        CSVFormatBuilder(final CSVFormat format) {\n-            this(format.delimiter, format.quoteChar, format.quotePolicy,\n-                    format.commentStart, format.escape,\n-                    format.ignoreSurroundingSpaces, format.ignoreEmptyLines,\n-                    format.recordSeparator, format.header);\n-        }\n-\n-        /**\n-         * Creates a basic CSVFormatBuilder.\n-         *\n-         * @param delimiter\n-         *            the char used for value separation, must not be a line break character\n-         * @throws IllegalArgumentException if the delimiter is a line break character\n-         */\n-        // package protected to give access without needing a synthetic accessor\n-        CSVFormatBuilder(final char delimiter){\n-            this(delimiter, null, null, null, null, false, false, null, null);\n-        }\n-\n-        /**\n-         * Builds a new CSVFormat configured with the values from this builder.\n-         *\n-         * @return a new CSVFormat\n-         */\n-        public CSVFormat build() {\n-            validate();\n-            return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-        }\n-\n-        /**\n-         * Parses the specified content. Short-hand for:\n-         * <pre>format.build().parse(in);</pre>\n-         *\n-         * @param in\n-         *            the input stream\n-         * @return a CSVRecord stream\n-         * @throws IOException\n-         *             If an I/O error occurs\n-         */\n-        public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n-            return this.build().parse(in);\n-        }\n-\n-        /**\n-         * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n-         *\n-         * @throws IllegalStateException\n-         */\n-        private void validate() throws IllegalStateException {\n-            if (quoteChar != null && delimiter == quoteChar.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n-            }\n-\n-            if (escape != null && delimiter == escape.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n-            }\n-\n-            if (commentStart != null && delimiter == commentStart.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (quoteChar != null && quoteChar.equals(commentStart)) {\n-                throw new IllegalStateException(\n-                        \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (escape != null && escape.equals(commentStart)) {\n-                throw new IllegalStateException(\n-                        \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (escape == null && quotePolicy == Quote.NONE) {\n-                throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n-            }\n-        }\n-\n-        /**\n-         * Sets the delimiter of the format to the specified character.\n-         *\n-         * @param delimiter\n-         *            the delimiter character\n-         * @return This builder with the specified character as delimiter\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withDelimiter(final char delimiter) {\n-            if (isLineBreak(delimiter)) {\n-                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n-            }\n-            this.delimiter = delimiter;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the quoteChar of the format to the specified character.\n-         *\n-         * @param quoteChar\n-         *            the quoteChar character\n-         * @return This builder with the specified character as quoteChar\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withQuoteChar(final char quoteChar) {\n-            return withQuoteChar(Character.valueOf(quoteChar));\n-        }\n-\n-        /**\n-         * Sets the quoteChar of the format to the specified character.\n-         *\n-         * @param quoteChar\n-         *            the quoteChar character\n-         * @return This builder with the specified character as quoteChar\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withQuoteChar(final Character quoteChar) {\n-            if (isLineBreak(quoteChar)) {\n-                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n-            }\n-            this.quoteChar = quoteChar;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the comment start marker of the format to the specified character.\n-         *\n-         * Note that the comment introducer character is only recognised at the start of a line.\n-         *\n-         * @param commentStart\n-         *            the comment start marker\n-         * @return This builder with the specified character as the comment start marker\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withCommentStart(final char commentStart) {\n-            return withCommentStart(Character.valueOf(commentStart));\n-        }\n-\n-        /**\n-         * Sets the comment start marker of the format to the specified character.\n-         *\n-         * Note that the comment introducer character is only recognised at the start of a line.\n-         *\n-         * @param commentStart\n-         *            the comment start marker\n-         * @return This builder with the specified character as the comment start marker\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withCommentStart(final Character commentStart) {\n-            if (isLineBreak(commentStart)) {\n-                throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n-            }\n-            this.commentStart = commentStart;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the escape character of the format to the specified character.\n-         *\n-         * @param escape\n-         *            the escape character\n-         * @return This builder with the specified character as the escape character\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withEscape(final char escape) {\n-            return withEscape(Character.valueOf(escape));\n-        }\n-\n-        /**\n-         * Sets the escape character of the format to the specified character.\n-         *\n-         * @param escape\n-         *            the escape character\n-         * @return This builder with the specified character as the escape character\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withEscape(final Character escape) {\n-            if (isLineBreak(escape)) {\n-                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n-            }\n-            this.escape = escape;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the header of the format. The header can either be parsed automatically from the\n-         * input file with:\n-         *\n-         * <pre>\n-         * CSVFormat format = aformat.withHeader();\n-         * </pre>\n-         *\n-         * or specified manually with:\n-         *\n-         * <pre>\n-         * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n-         * </pre>\n-         *\n-         * @param header\n-         *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-         *\n-         * @return This builder with the specified header\n-         */\n-        public CSVFormatBuilder withHeader(final String... header) {\n-            this.header = header;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the trimming behavior of the format.\n-         *\n-         * @param ignoreSurroundingSpaces\n-         *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n-         *            spaces as is.\n-         * @return This builder with the specified trimming behavior.\n-         */\n-        public CSVFormatBuilder withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the empty line skipping behavior of the format.\n-         *\n-         * @param ignoreEmptyLines\n-         *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n-         *            <tt>false</tt> to translate empty lines to empty records.\n-         * @return This builder with the specified empty line skipping behavior.\n-         */\n-        public CSVFormatBuilder withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-            this.ignoreEmptyLines = ignoreEmptyLines;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the record separator of the format to the specified character.\n-         *\n-         * @param recordSeparator\n-         *            the record separator to use for output.\n-         *\n-         * @return This builder with the the specified output record separator\n-         */\n-        public CSVFormatBuilder withRecordSeparator(final char recordSeparator) {\n-            return withRecordSeparator(String.valueOf(recordSeparator));\n-        }\n-\n-        /**\n-         * Sets the record separator of the format to the specified String.\n-         *\n-         * @param recordSeparator\n-         *            the record separator to use for output.\n-         *\n-         * @return This builder with the the specified output record separator\n-         */\n-        public CSVFormatBuilder withRecordSeparator(final String recordSeparator) {\n-            this.recordSeparator = recordSeparator;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the output quote policy of the format to the specified value.\n-         *\n-         * @param quotePolicy\n-         *            the quote policy to use for output.\n-         *\n-         * @return This builder with the specified quote policy\n-         */\n-        public CSVFormatBuilder withQuotePolicy(final Quote quotePolicy) {\n-            this.quotePolicy = quotePolicy;\n-            return this;\n-        }\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n+        if (isEscaping()) {\n+            sb.append(' ');\n+            sb.append(\"Escape=<\").append(escape).append('>');\n+        }\n+        if (isQuoting()) {\n+            sb.append(' ');\n+            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n+        }\n+        if (isCommentingEnabled()) {\n+            sb.append(' ');\n+            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n+        }\n+        if (getIgnoreEmptyLines()) {\n+            sb.append(\" EmptyLines:ignored\");\n+        }\n+        if (getIgnoreSurroundingSpaces()) {\n+            sb.append(\" SurroundingSpaces:ignored\");\n+        }\n+        return sb.toString();\n     }\n }", "timestamp": 1365452637, "metainfo": ""}