{"sha": "5a0894f9e0ee9f4703b8db3f200ff4a507bf043b", "log": "[CSV-93] Allow the handling of NULL values. Use a single property 'nullString' for both input and output processing. No substitutions occur if null. For reading, nullString is used to convert field values to null. For writing, nullString is used to output the given string instead of the empty string.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n         private boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n         private boolean ignoreEmptyLines;\n         private String recordSeparator; // for outputs\n-        private String nullToString; // for outputs\n+        private String nullString;\n         private String[] header;\n \n         /**\n          */\n         // package protected to give access without needing a synthetic accessor\n         CSVFormatBuilder(final char delimiter){\n-            this(delimiter, null, null, null, null, false, false, null, Constants.EMPTY, null);\n+            this(delimiter, null, null, null, null, false, false, null, null, null);\n         }\n \n         /**\n          *            <tt>true</tt> when whitespaces enclosing values should be ignored\n          * @param ignoreEmptyLines\n          *            <tt>true</tt> when the parser should skip empty lines\n-         * @param nullToString TODO\n+         * @param recordSeparator\n+         *            the record separator to use for output\n+         * @param nullString\n+         *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n          * @param header\n          *            the header\n-         * @param recordSeparator\n-         *            the record separator to use for output\n          * @throws IllegalArgumentException if the delimiter is a line break character\n          */\n         // package protected for use by test code\n                 final Quote quotePolicy, final Character commentStart,\n                 final Character escape, final boolean ignoreSurroundingSpaces,\n                 final boolean ignoreEmptyLines, final String recordSeparator,\n-                final String nullToString, final String[] header) {\n+                String nullString, final String[] header) {\n             if (isLineBreak(delimiter)) {\n                 throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n             }\n             this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n             this.ignoreEmptyLines = ignoreEmptyLines;\n             this.recordSeparator = recordSeparator;\n-            this.nullToString = nullToString;\n+            this.nullString = nullString;\n             this.header = header;\n         }\n \n             this(format.delimiter, format.quoteChar, format.quotePolicy,\n                     format.commentStart, format.escape,\n                     format.ignoreSurroundingSpaces, format.ignoreEmptyLines,\n-                    format.recordSeparator, format.nullToString, format.header);\n+                    format.recordSeparator, format.nullString, format.header);\n         }\n \n         /**\n         public CSVFormat build() {\n             validate();\n             return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullToString, header);\n+                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, \n+                                 header);\n         }\n \n         /**\n         }\n \n         /**\n-         * Sets the String to use for null values for output.\n-         *\n-         * @param nullToString\n-         *            the String to use for null values for output.\n-         *\n-         * @return This builder with the the specified output record separator\n-         */\n-        public CSVFormatBuilder withNullToString(final String nullToString) {\n-            this.nullToString = nullToString;\n+         * Performs conversions to and from null for strings on input and output.\n+         * <ul>\n+         * <li>\n+         * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n+         * records.</li>\n+         * <li>\n+         * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n+         * </ul>\n+         * \n+         * @param nullString\n+         *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n+         * \n+         * @return This builder with the the specified null conversion string.\n+         */\n+        public CSVFormatBuilder withNullString(final String nullString) {\n+            this.nullString = nullString;\n             return this;\n         }\n \n      * @return a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n      */\n     public static CSVFormatBuilder newBuilder() {\n-        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, Constants.EMPTY,\n-                null);\n-    }\n+        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null);\n+    }\n+    \n     private final char delimiter;\n     private final Character quoteChar;\n     private final Quote quotePolicy;\n     private final Character escape;\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n     private final boolean ignoreEmptyLines;\n-\n     private final String recordSeparator; // for outputs\n-\n-    private final String nullToString; // for outputs\n-\n+    private final String nullString;\n     private final String[] header;\n \n     /**\n      *            <tt>true</tt> when the parser should skip empty lines\n      * @param recordSeparator\n      *            the line separator to use for output\n-     * @param nullToString\n-     *            the String to use to write <code>null</code> values.\n+     * @param nullString\n+     *            the line separator to use for output\n      * @param header\n      *            the header\n      * @throws IllegalArgumentException if the delimiter is a line break character\n             final Quote quotePolicy, final Character commentStart,\n             final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator,\n-            final String nullToString, final String[] header) {\n+            final String nullString, final String[] header) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         this.recordSeparator = recordSeparator;\n-        this.nullToString = nullToString;\n+        this.nullString = nullString;\n         this.header = header == null ? null : header.clone();\n     }\n \n     }\n \n     /**\n-     * Returns the value to use for writing null values.\n-     *\n-     * @return the value to use for writing null values.\n-     */\n-    public String getNullToString() {\n-        return nullToString;\n+     * Gets the String to convert to and from {@code null}.\n+     * <ul>\n+     * <li>\n+     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n+     * records.\n+     * </li>\n+     * <li>\n+     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n+     * </ul>\n+     * \n+     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n+     */\n+    public String getNullString() {\n+        return nullString;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final Lexer lexer;\n     private final Map<String, Integer> headerMap;\n     private long recordNumber;\n+    private final CSVFormat format;\n \n     // the following objects are shared to reduce garbage\n \n      */\n     public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n-        this.headerMap = initializeHeader(format);\n+        this.format = format;\n+        this.headerMap = initializeHeader();\n     }\n \n     /**\n             lexer.nextToken(reusableToken);\n             switch (reusableToken.type) {\n             case TOKEN:\n-                record.add(reusableToken.content.toString());\n+                this.addRecordValue();\n                 break;\n             case EORECORD:\n-                record.add(reusableToken.content.toString());\n+                this.addRecordValue();\n                 break;\n             case EOF:\n                 if (reusableToken.isReady) {\n-                    record.add(reusableToken.content.toString());\n+                    this.addRecordValue();\n                 }\n                 break;\n             case INVALID:\n         return result;\n     }\n \n+    private void addRecordValue() {\n+        final String input = reusableToken.content.toString();\n+        final String nullString = this.format.getNullString();\n+        if (nullString == null) {\n+            record.add(input);\n+        } else {\n+            record.add(input.equalsIgnoreCase(nullString) ? null : input);\n+        }}\n+\n     /**\n      * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n      * entries.\n     /**\n      * Initializes the name to index mapping if the format defines a header.\n      */\n-    private Map<String, Integer> initializeHeader(final CSVFormat format) throws IOException {\n+    private Map<String, Integer> initializeHeader() throws IOException {\n         Map<String, Integer> hdrMap = null;\n         if (format.getHeader() != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      */\n     public void print(final Object value) throws IOException {\n         // null values are considered empty\n-        final String strValue = value == null ? format.getNullToString() : value.toString();\n-        print(value, strValue, 0, strValue.length());\n+        String strValue;\n+        if (value == null) {\n+            final String nullString = format.getNullString();\n+            strValue = nullString == null ? Constants.EMPTY : nullString;\n+        } else {\n+            strValue = value.toString();\n+        }\n+        this.print(value, strValue, 0, strValue.length());\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n package org.apache.commons.csv;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n \n import java.io.IOException;\n+import java.io.StringReader;\n import java.io.StringWriter;\n import java.sql.Connection;\n import java.sql.DriverManager;\n import java.sql.SQLException;\n import java.sql.Statement;\n import java.util.Arrays;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Random;\n \n     @Test\n     public void testPrintCustomNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.toBuilder().withNullToString(\"NULL\").build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.toBuilder().withNullString(\"NULL\").build());\n         printer.printRecord(\"a\", null, \"b\");\n         assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n         printer.close();\n+    }\n+\n+    @Test\n+    public void testParseCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.toBuilder().withNullString(\"NULL\").build();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        printer.printRecord(\"a\", null, \"b\");\n+        printer.close();\n+        String csvString = sw.toString();\n+        assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n+        final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n+        final Iterator<CSVRecord> iterator = iterable.iterator();\n+        final CSVRecord record = iterator.next();\n+        assertEquals(\"a\", record.get(0));\n+        assertEquals(null, record.get(1));\n+        assertEquals(\"b\", record.get(2));\n+        assertFalse(iterator.hasNext());\n     }\n \n     @Test", "timestamp": 1372043165, "metainfo": ""}