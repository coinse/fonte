{"sha": "fcc0d15c7b541191f14b0861d945cbbeba770d10", "log": "- Remove trailing spaces. - Add missing final keywords.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n public class CSVFormat implements Serializable {\n \n     private static final long serialVersionUID = 1L;\n-    \n+\n     /**\n      * Returns true if the given character is a line break character.\n      *\n     static boolean isLineBreak(final Character c) {\n         return c != null && isLineBreak(c.charValue());\n     }\n-    \n+\n     private final char delimiter;\n     private final Character quoteChar;\n     private final Quote quotePolicy;\n     }\n \n     /**\n-     * Returns a copy of the header array. \n-     * \n+     * Returns a copy of the header array.\n+     *\n      * @return a copy of the header array\n      */\n     public String[] getHeader() {\n      * <li>\n      * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n      * </ul>\n-     * \n+     *\n      * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n      */\n     public String getNullString() {\n \n \t/**\n \t * Parses the specified content.\n-\t * \n+\t *\n \t * <p>\n \t * See also the various static parse methods on {@link CSVParser}.\n \t * </p>\n-\t * \n+\t *\n \t * @param in\n \t *            the input stream\n \t * @return a parser over a stream of {@link #CSVRecord}s.\n         if (escape == null && quotePolicy == Quote.NONE) {\n             throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n         }\n-        \n+\n         if (header != null) {\n-            Set<String> set = new HashSet<String>(header.length);\n+            final Set<String> set = new HashSet<String>(header.length);\n             set.addAll(Arrays.asList(header));\n             if (set.size() != header.length) {\n                 throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n \n     /**\n      * Sets the header of the format. The header can either be parsed automatically from the input file with:\n-     * \n+     *\n      * <pre>\n      * CSVFormat format = aformat.withHeader();</pre>\n-     * \n+     *\n      * or specified manually with:\n-     * \n+     *\n      * <pre>\n      * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n-     * \n+     *\n      * @param header\n      *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-     * \n+     *\n      * @return A new CSVFormat that is equal to this but with the specified header\n      * @see #withSkipHeaderRecord(boolean)\n      */\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n         }\n \n         if (isStartOfLine(lastChar) && isCommentStart(c)) {\n-            String line = in.readLine();\n+            final String line = in.readLine();\n             if (line == null) {\n                 token.type = EOF;\n                 // don't set token.isReady here because no content\n-                return token;                \n+                return token;\n             }\n             final String comment = line.trim();\n             token.content.append(comment);\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n \n /**\n  * Parses CSV files according to the specified configuration.\n- * \n+ *\n  * Because CSV appears in many different dialects, the parser supports many configuration settings by allowing the\n  * specification of a {@link CSVFormat}.\n- * \n+ *\n  * <p>\n  * To parse a CSV input with tabs as separators, '\"' (double-quote) as an optional value encapsulator, and comments\n  * starting with '#', you write:\n  * </p>\n- * \n+ *\n  * <pre>\n  * Reader in = new StringReader(&quot;a\\tb\\nc\\td&quot;);\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.DEFAULT\n  *     ...\n  *  }\n  * </pre>\n- * \n+ *\n  * <p>\n  * To parse CSV input in a given format like Excel, you write:\n  * </p>\n- * \n+ *\n  * <pre>\n  * Reader in = new StringReader(\"a;b\\nc;d\");\n  * Iterable&lt;CSVRecord&gt; parser = CSVFormat.EXCEL.parse(in);\n  * <p>\n  * You may also get a List of records:\n  * </p>\n- * \n+ *\n  * <pre>\n  * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n  * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n  * <p>\n  * Internal parser state is completely covered by the format and the reader-state.\n  * </p>\n- * \n+ *\n  * <p>\n  * see <a href=\"package-summary.html\">package documentation</a> for more details\n  * </p>\n- * \n+ *\n  * @version $Id$\n  */\n public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n     /**\n      * Creates a parser for the given {@link File}.\n-     * \n+     *\n      * @param file\n      *            a CSV file\n      * @param format\n \n     /**\n      * Creates a parser for the given resource.\n-     * \n+     *\n      * <p>\n      * If you do not read all records from the given source, you should call {@link #close()} on the parser.\n      * </p>\n-     * \n+     *\n      * @param resource\n      *            a resource path\n      * @param charset\n      */\n     public static CSVParser parseResource(String resource, Charset charset, ClassLoader classLoader,\n             final CSVFormat format) throws IOException {\n-        URL url = classLoader.getResource(resource);\n+        final URL url = classLoader.getResource(resource);\n         if (url == null) {\n             throw new IllegalArgumentException(\"Resource cannot be found: \" + resource);\n         }\n \n     /**\n      * Creates a parser for the given resource.\n-     * \n+     *\n      * <p>\n      * If you do not read all records from the given source, you should call {@link #close()} on the parser.\n      * </p>\n-     * \n+     *\n      * @param resource\n      *            a resource path\n      * @param charset\n      *             If an I/O error occurs\n      */\n     public static CSVParser parseResource(String resource, Charset charset, final CSVFormat format) throws IOException {\n-        URL url = ClassLoader.getSystemResource(resource);\n+        final URL url = ClassLoader.getSystemResource(resource);\n         if (url == null) {\n             throw new IllegalArgumentException(\"System resource cannot be found: \" + resource);\n         }\n \n     /**\n      * Creates a parser for the given {@link String} using the default format {@link CSVFormat#DEFAULT}.\n-     * \n+     *\n      * @param string\n      *            a CSV string\n      * @return a new parser\n \n     /**\n      * Creates a parser for the given {@link String}.\n-     * \n+     *\n      * @param string\n      *            a CSV string\n      * @param format\n \n     /**\n      * Creates a parser for the given URL.\n-     * \n+     *\n      * <p>\n      * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n      * you close the {@code url}.\n      * </p>\n-     * \n+     *\n      * @param url\n      *            a URL\n      * @param charset\n \n     /**\n      * CSV parser using the default format {@link CSVFormat#DEFAULT}.\n-     * \n+     *\n      * <p>\n      * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n      * unless you close the {@code reader}.\n      * </p>\n-     * \n+     *\n      * @param input\n      *            a Reader containing \"csv-formatted\" input\n      * @throws IllegalArgumentException\n \n     /**\n      * Customized CSV parser using the given {@link CSVFormat}\n-     * \n+     *\n      * <p>\n      * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n      * unless you close the {@code reader}.\n      * </p>\n-     * \n+     *\n      * @param reader\n      *            a Reader containing CSV-formatted input\n      * @param format\n \n     /**\n      * Closes resources.\n-     * \n+     *\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n      * Returns the current line number in the input stream.\n      * <p/>\n      * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n-     * \n+     *\n      * @return current line number\n      */\n     public long getCurrentLineNumber() {\n      * Returns a copy of the header map that iterates in column order.\n      * <p>\n      * The map keys are column names. The map values are 0-based indices.\n-     * \n+     *\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n      * Returns the current record number in the input stream.\n      * <p/>\n      * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n-     * \n+     *\n      * @return current line number\n      */\n     public long getRecordNumber() {\n      * entries.\n      * <p/>\n      * The returned content starts at the current parse-position in the stream.\n-     * \n+     *\n      * @return list of {@link CSVRecord} entries, may be empty\n      * @throws IOException\n      *             on parse error or input read-failure\n      */\n     private Map<String, Integer> initializeHeader() throws IOException {\n         Map<String, Integer> hdrMap = null;\n-        String[] formatHeader = this.format.getHeader();\n+        final String[] formatHeader = this.format.getHeader();\n         if (formatHeader != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n \n \n     /**\n      * Parses the next record from the current point in the stream.\n-     * \n+     *\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n      * @throws IOException\n      *             on parse error or input read-failure\n--- a/src/main/java/org/apache/commons/csv/Constants.java\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n \n     /** According to RFC 4180, line breaks are delimited by CRLF */\n     static final String CRLF = \"\\r\\n\";\n-    \n+\n     /**\n      * Unicode line separator.\n      */\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n \n     /** The count of EOLs (CR/LF/CRLF) seen so far */\n     private long eolCounter = 0;\n-    \n+\n     private boolean closed;\n \n     /**\n \n \t/**\n \t * Closes the stream.\n-\t * \n+\t *\n \t * @throws IOException\n \t *             If an I/O error occurs\n \t */\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     boolean isClosed() {\n     \treturn in.isClosed();\n     }\n-    \n+\n     /**\n      * @return true if the given char is a whitespace character\n      */\n \n     /**\n      * Closes resources.\n-     * \n+     *\n \t * @throws IOException\n \t *             If an I/O error occurs\n      */\n--- a/src/main/java/org/apache/commons/csv/Token.java\n+++ b/src/main/java/org/apache/commons/csv/Token.java\n \n     /**\n      * Eases IDE debugging.\n-     * \n+     *\n      * @return a string helpful for debugging.\n      */\n     @Override\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n \n         // Now parse the file and compare against the expected results\n         // We use a buffered reader internally so no need to create one here.\n-        CSVParser parser = CSVParser.parseFile(new File(BASE, split[0]), format);\n+        final CSVParser parser = CSVParser.parseFile(new File(BASE, split[0]), format);\n         for(final CSVRecord record : parser) {\n             String parsed = record.toString();\n             if (checkComments) {\n         assertEquals(testName + \" Expected format \", line, format.toString());\n \n         // Now parse the file and compare against the expected results\n-        CSVParser parser = CSVParser.parseResource(\"CSVFileParser/\" + split[0], Charset.forName(\"UTF-8\"),\n+        final CSVParser parser = CSVParser.parseResource(\"CSVFileParser/\" + split[0], Charset.forName(\"UTF-8\"),\n                 this.getClass().getClassLoader(), format);\n         for (final CSVRecord record : parser) {\n             String parsed = record.toString();\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testGetHeader() throws Exception {\n-        String[] header = new String[]{\"one\", \"two\", \"three\"};\n-        CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        final String[] header = new String[]{\"one\", \"two\", \"three\"};\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n         // getHeader() makes a copy of the header array.\n-        String[] headerCopy = formatWithHeader.getHeader();\n+        final String[] headerCopy = formatWithHeader.getHeader();\n         headerCopy[0] = \"A\";\n         headerCopy[1] = \"B\";\n         headerCopy[2] = \"C\";\n \n     @Test\n     public void testWithCommentStart() throws Exception {\n-        CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentStart('#');\n+        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentStart('#');\n         assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStart());\n     }\n \n \n     @Test\n     public void testWithDelimiter() throws Exception {\n-        CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\n+        final CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\n         assertEquals('!', formatWithDelimiter.getDelimiter());\n     }\n \n \n     @Test\n     public void testWithEscape() throws Exception {\n-        CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n+        final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n         assertEquals(Character.valueOf('&'), formatWithEscape.getEscape());\n     }\n \n \n     @Test\n     public void testWithHeader() throws Exception {\n-        String[] header = new String[]{\"one\", \"two\", \"three\"};\n+        final String[] header = new String[]{\"one\", \"two\", \"three\"};\n         // withHeader() makes a copy of the header array.\n-        CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        final CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n         assertArrayEquals(header, formatWithHeader.getHeader());\n         assertNotSame(header, formatWithHeader.getHeader());\n         header[0] = \"A\";\n \n     @Test\n     public void testWithNullString() throws Exception {\n-        CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\n+        final CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\n         assertEquals(\"null\", formatWithNullString.getNullString());\n     }\n \n     @Test\n     public void testWithQuoteChar() throws Exception {\n-        CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuoteChar('\"');\n+        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuoteChar('\"');\n         assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteChar());\n     }\n \n \n     @Test\n     public void testWithQuotePolicy() throws Exception {\n-        CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuotePolicy(Quote.ALL);\n+        final CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuotePolicy(Quote.ALL);\n         assertEquals(Quote.ALL, formatWithQuotePolicy.getQuotePolicy());\n     }\n \n     @Test\n     public void testWithRecordSeparator() throws Exception {\n-        CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator('!');\n+        final CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator('!');\n         assertEquals(\"!\", formatWithRecordSeparator.getRecordSeparator());\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n import static org.apache.commons.csv.Token.Type.EOF;\n import static org.apache.commons.csv.Token.Type.EORECORD;\n import static org.apache.commons.csv.Token.Type.TOKEN;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.assertThat;\n import static org.apache.commons.csv.TokenMatchers.hasContent;\n import static org.apache.commons.csv.TokenMatchers.matches;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n \n import java.io.IOException;\n import java.io.StringReader;\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n             iterator.remove();\n             fail(\"expected UnsupportedOperationException\");\n         } catch (final UnsupportedOperationException expected) {\n-            // expected \n+            // expected\n         }\n         assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n         assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n         final CSVPrinter printer = new CSVPrinter(sw, format);\n         printer.printRecord(\"a\", null, \"b\");\n         printer.close();\n-        String csvString = sw.toString();\n+        final String csvString = sw.toString();\n         assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n         final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n         final Iterator<CSVRecord> iterator = iterable.iterator();\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testInvalidFormat() throws Exception {\n-        CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n         new CSVPrinter(null, invalidFormat);\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n import static org.junit.Assert.assertTrue;\n \n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.Map;\n \n import org.junit.Before;\n     @Test\n     public void testIterator() {\n         int i = 0;\n-        for (final Iterator<String> itr = record.iterator(); itr.hasNext();) {\n-            final String value = itr.next();\n+        for (String value : record) {\n             assertEquals(values[i], value);\n             i++;\n         }\n--- a/src/test/java/org/apache/commons/csv/TokenMatchers.java\n+++ b/src/test/java/org/apache/commons/csv/TokenMatchers.java\n  */\n package org.apache.commons.csv;\n \n+import static org.hamcrest.core.AllOf.allOf;\n+\n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n import org.hamcrest.TypeSafeDiagnosingMatcher;\n-import static org.hamcrest.core.AllOf.allOf;\n \n /**\n  * Collection of matchers for asserting the type and content of tokens.", "timestamp": 1375322667, "metainfo": ""}