{"sha": "d89a0f482f6fa06661e4fd15a31b54222224a6df", "log": "Javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n      * The encapsulator itself might be included in the token using a\n      * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n      * Whitespaces before and after an encapsulated token are ignored.\n+     * The token is finished when one of the following conditions become true:\n+     * <ul>\n+     *   <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n+     *   <ul>\n+     *       <li>delimiter (TOKEN)</li>\n+     *       <li>end of line (EORECORD)</li>\n+     *   </ul>\n+     *   <li>end of stream has been reached (EOF)</li>\n+     * </ul>\n      *\n      * @param tkn the current token\n      * @return a valid token object\n-     * @throws IOException on invalid state\n+     * @throws IOException on invalid state: \n+     *  EOF before closing encapsulator or invalid character before delimiter or EOL\n      */\n     private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n-        // save current line\n+        // save current line number in case needed for IOE\n         int startLineNumber = getLineNumber();\n-        // ignore the given delimiter\n-        // assert c == delimiter;\n         int c;\n         while (true) {\n             c = in.read();\n                             tkn.isReady = true; // There is data at EOF\n                             return tkn;\n                         } else if (isEndOfLine(c)) {\n-                            // ok eo token reached\n                             tkn.type = EORECORD;\n                             return tkn;\n                         } else if (!isWhitespace(c)) {", "timestamp": 1333070205, "metainfo": ""}