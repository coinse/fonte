{"sha": "787ab08db9230c67220ef453de211159e317d4e2", "log": "CSV-85 Allow comments to be returned in CSVRecord  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n         }\n \n         if (isStartOfLine(lastChar) && isCommentStart(c)) {\n-            in.readLine();\n+            String comment = in.readLine().trim();\n+            tkn.content.append(comment);\n             tkn.type = COMMENT;\n             return tkn;\n         }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      * @throws IOException on parse error or input read-failure\n      */\n     CSVRecord getRecord() throws IOException {\n-        CSVRecord result = new CSVRecord(null, headerMapping);\n+        CSVRecord result = new CSVRecord(null, headerMapping, null);\n         record.clear();\n+        StringBuilder sb = null;\n         do {\n             reusableToken.reset();\n             lexer.nextToken(reusableToken);\n                 case INVALID:\n                     throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n                 case COMMENT: // Ignored currently\n+                    if (sb == null) { // first comment for this record\n+                        sb = new StringBuilder();\n+                    } else {\n+                        sb.append(\"\\n\");\n+                    }\n+                    sb.append(reusableToken.content);\n                     reusableToken.type = TOKEN; // Read another token\n                     break;\n             }\n         } while (reusableToken.type == TOKEN);\n         \n         if (!record.isEmpty()) {\n-            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping);\n+            result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping, \n+                    sb == null ? null : sb.toString());\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     /** The column name to index mapping. */\n     private final Map<String, Integer> mapping;\n \n-    CSVRecord(String[] values, Map<String, Integer> mapping) {\n+    /** The accumulated comments (if any) */\n+    private final String comment;\n+\n+    CSVRecord(String[] values, Map<String, Integer> mapping, String comment) {\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n+        this.comment = comment;\n     }\n \n     /**\n         return values;\n     }\n \n+    public String getComment() {\n+        return comment;\n+    }\n     /**\n      * Returns the number of values in this record.\n      */\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n          // first line starts with csv data file name\n         BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n         CSVFormat fmt = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\"');\n+        boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n             String[] option_parts = option.split(\"=\",2);\n                 fmt = fmt.withSurroundingSpacesIgnored(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n                 fmt = fmt.withCommentStart(option_parts[1].charAt(0));\n+            } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n+                checkComments = true;\n             } else {\n                 fail(testName+\" unexpected option: \"+option);\n             }\n         // Now parse the file and compare against the expected results\n         for(CSVRecord rec : fmt.parse(csvFile)) {\n             String parsed = rec.toString();\n+            if (checkComments) {\n+                final String comment = rec.getComment().replace(\"\\n\", \"\\\\n\");\n+                if (comment != null) {\n+                    parsed += \"#\" + comment;\n+                }\n+            }\n             int count = rec.size();\n             assertEquals(testName, readTestData(), count+\":\"+parsed);\n         }\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n                 \"a,b x,c#no-comment\\n\"+    // 2\n                 \"\\n\"+\n                 \"\\n\"+\n-                \"#foo\\n\"+                  // 3\n+                \"# foo \\n\"+                // 3\n                 \"\\n\"+                      // 4\n                 \"d,e,#no-comment\\n\"+       // 5\n                 \"\\n\"+\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"b x\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"c#no-comment\", parser.nextToken(new Token())); // 2\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 3\n+        assertTokenEquals(COMMENT, \"foo\", parser.nextToken(new Token()));              // 3\n         // 4 empty line, ignored                                                    // 4\n         assertTokenEquals(TOKEN, \"d\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"e\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"#no-comment\", parser.nextToken(new Token()));  // 5\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 6\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 7\n+        assertTokenEquals(COMMENT, \"penultimate comment\", parser.nextToken(new Token()));              // 6\n+        assertTokenEquals(COMMENT, \"Final comment\", parser.nextToken(new Token()));              // 7\n         assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n         assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"b x\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"c#no-comment\", parser.nextToken(new Token())); // 2\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 3\n+        assertTokenEquals(COMMENT, \"foo\", parser.nextToken(new Token()));           // 3\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 4\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 4b\n         assertTokenEquals(TOKEN, \"d\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"#no-comment\", parser.nextToken(new Token()));  // 5\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 5b\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 5c\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 6\n+        assertTokenEquals(COMMENT, \"penultimate comment\", parser.nextToken(new Token()));              // 6\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 6b\n         assertTokenEquals(EORECORD, \"\", parser.nextToken(new Token()));             // 6c\n-        assertTokenEquals(COMMENT, \"\", parser.nextToken(new Token()));              // 7\n+        assertTokenEquals(COMMENT, \"Final comment\", parser.nextToken(new Token()));              // 7\n         assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n         assertTokenEquals(EOF, \"\", parser.nextToken(new Token()));\n ", "timestamp": 1333036983, "metainfo": ""}