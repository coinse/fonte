{"sha": "a0624779468261996e7e6e5c7a63ba1ce1a3a553", "log": "Use ch instead of c as a character var name.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n      *\n      * @param token\n      *            the current token\n-     * @param c\n+     * @param ch\n      *            the current character\n      * @return the filled token\n      * @throws IOException\n      *             on stream access error\n      */\n-    private Token parseSimpleToken(final Token token, int c) throws IOException {\n+    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n         // Faster to use while(true)+break than while(token.type == INVALID)\n         while (true) {\n-            if (readEndOfLine(c)) {\n+            if (readEndOfLine(ch)) {\n                 token.type = EORECORD;\n                 break;\n-            } else if (isEndOfFile(c)) {\n+            } else if (isEndOfFile(ch)) {\n                 token.type = EOF;\n                 token.isReady = true; // There is data at EOF\n                 break;\n-            } else if (isDelimiter(c)) {\n+            } else if (isDelimiter(ch)) {\n                 token.type = TOKEN;\n                 break;\n-            } else if (isEscape(c)) {\n+            } else if (isEscape(ch)) {\n                 final int unescaped = readEscape();\n                 if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n-                    token.content.append((char) c).append((char) in.getLastChar());\n+                    token.content.append((char) ch).append((char) in.getLastChar());\n                 } else {\n                     token.content.append((char) unescaped);\n                 }\n-                c = in.read(); // continue\n+                ch = in.read(); // continue\n             } else {\n-                token.content.append((char) c);\n-                c = in.read(); // continue\n+                token.content.append((char) ch);\n+                ch = in.read(); // continue\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n      */\n     int readEscape() throws IOException {\n         // the escape char has just been read (normally a backslash)\n-        final int c = in.read();\n-        switch (c) {\n+        final int ch = in.read();\n+        switch (ch) {\n         case 'r':\n             return CR;\n         case 'n':\n         case FF: // TODO is this correct?\n         case TAB: // TODO is this correct? Do tabs need to be escaped?\n         case BACKSPACE: // TODO is this correct?\n-            return c;\n+            return ch;\n         case END_OF_STREAM:\n             throw new IOException(\"EOF whilst processing escape sequence\");\n         default:\n             // Now check for meta-characters\n-            if (isMetaChar(c)) {\n-                return c;\n+            if (isMetaChar(ch)) {\n+                return ch;\n             }\n             // indicate unexpected char - available from in.getLastChar()\n             return END_OF_STREAM;\n      *\n      * @return true if the given or next character is a line-terminator\n      */\n-    boolean readEndOfLine(int c) throws IOException {\n+    boolean readEndOfLine(int ch) throws IOException {\n         // check if we have \\r\\n...\n-        if (c == CR && in.lookAhead() == LF) {\n+        if (ch == CR && in.lookAhead() == LF) {\n             // note: does not change c outside of this method!\n-            c = in.read();\n-        }\n-        return c == LF || c == CR;\n+            ch = in.read();\n+        }\n+        return ch == LF || ch == CR;\n     }\n \n     abstract Token nextToken(Token reusableToken) throws IOException;\n     /**\n      * @return true if the given char is a whitespace character\n      */\n-    boolean isWhitespace(final int c) {\n-        return !isDelimiter(c) && Character.isWhitespace((char) c);\n+    boolean isWhitespace(final int ch) {\n+        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n     }\n \n     /**\n      * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n      *\n-     * @param c the character to check\n+     * @param ch the character to check\n      * @return true if the character is at the start of a line.\n      */\n-    boolean isStartOfLine(final int c) {\n-        return c == LF || c == CR || c == UNDEFINED;\n+    boolean isStartOfLine(final int ch) {\n+        return ch == LF || ch == CR || ch == UNDEFINED;\n     }\n \n     /**\n      * @return true if the given character indicates end of file\n      */\n-    boolean isEndOfFile(final int c) {\n-        return c == END_OF_STREAM;\n-    }\n-\n-    boolean isDelimiter(final int c) {\n-        return c == delimiter;\n-    }\n-\n-    boolean isEscape(final int c) {\n-        return c == escape;\n-    }\n-\n-    boolean isQuoteChar(final int c) {\n-        return c == quoteChar;\n-    }\n-\n-    boolean isCommentStart(final int c) {\n-        return c == commmentStart;\n-    }\n-\n-    private boolean isMetaChar(final int c) {\n-        return c == delimiter ||\n-               c == escape ||\n-               c == quoteChar ||\n-               c == commmentStart;\n+    boolean isEndOfFile(final int ch) {\n+        return ch == END_OF_STREAM;\n+    }\n+\n+    boolean isDelimiter(final int ch) {\n+        return ch == delimiter;\n+    }\n+\n+    boolean isEscape(final int ch) {\n+        return ch == escape;\n+    }\n+\n+    boolean isQuoteChar(final int ch) {\n+        return ch == quoteChar;\n+    }\n+\n+    boolean isCommentStart(final int ch) {\n+        return ch == commmentStart;\n+    }\n+\n+    private boolean isMetaChar(final int ch) {\n+        return ch == delimiter ||\n+               ch == escape ||\n+               ch == quoteChar ||\n+               ch == commmentStart;\n     }\n \n     /**", "timestamp": 1375285565, "metainfo": ""}