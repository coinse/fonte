{"sha": "316a51f5208bc95f22124d1579882131a4f441b2", "log": "- Add some real world CSV files.  - Add a record API to get column values using an Enum. - Throw a better exception when a resource is not found in a class loader for the parser. - Replace some tabs with spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     public static CSVParser parseFile(File file, final CSVFormat format) throws IOException {\n         return new CSVParser(new FileReader(file), format);\n     }\n-    \n+\n     /**\n      * Creates a parser for the given resource.\n      * \n      */\n     public static CSVParser parseResource(String resource, Charset charset, ClassLoader classLoader,\n             final CSVFormat format) throws IOException {\n-        return parseURL(classLoader.getResource(resource), charset, format);\n-    }\n-    \n+        URL url = classLoader.getResource(resource);\n+        if (url == null) {\n+            throw new IllegalArgumentException(\"Resource cannot be found: \" + resource);\n+        }\n+        return parseURL(url, charset, format);\n+    }\n+\n+    /**\n+     * Creates a parser for the given resource.\n+     * \n+     * <p>\n+     * If you do not read all records from the given source, you should call {@link #close()} on the parser.\n+     * </p>\n+     * \n+     * @param resource\n+     *            a resource path\n+     * @param charset\n+     *            the charset for the resource\n+     * @param format\n+     *            the CSVFormat used for CSV parsing\n+     * @return a new parser\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public static CSVParser parseResource(String resource, Charset charset, final CSVFormat format) throws IOException {\n+        URL url = ClassLoader.getSystemResource(resource);\n+        if (url == null) {\n+            throw new IllegalArgumentException(\"System resource cannot be found: \" + resource);\n+        }\n+        return parseURL(url, charset, format);\n+    }\n+\n     /**\n      * Creates a parser for the given {@link String} using the default format {@link CSVFormat#DEFAULT}.\n      * \n \n     /**\n      * CSV parser using the default format {@link CSVFormat#DEFAULT}.\n-     *\n+     * \n      * <p>\n      * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n      * unless you close the {@code reader}.\n             this.record.add(input);\n         } else {\n             this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n-        }}\n+        }\n+    }\n \n     /**\n      * Closes resources.\n      * \n-\t * @throws IOException\n-\t *             If an I/O error occurs\n-     */\n-\tpublic void close() throws IOException {\n-\t\tif (this.lexer != null) {\n-\t\t\tthis.lexer.close();\n-\t\t}\t\t\n-\t}\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void close() throws IOException {\n+        if (this.lexer != null) {\n+            this.lexer.close();\n+        }\n+    }\n \n     /**\n      * Returns the current line number in the input stream.\n      * <p/>\n      * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n-     *\n+     * \n      * @return current line number\n      */\n     public long getCurrentLineNumber() {\n     /**\n      * Returns a copy of the header map that iterates in column order.\n      * <p>\n-     * The map keys are column names.\n-     * The map values are 0-based indices.\n-     *\n+     * The map keys are column names. The map values are 0-based indices.\n+     * \n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n      * Returns the current record number in the input stream.\n      * <p/>\n      * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n-     *\n+     * \n      * @return current line number\n      */\n     public long getRecordNumber() {\n      * entries.\n      * <p/>\n      * The returned content starts at the current parse-position in the stream.\n-     *\n+     * \n      * @return list of {@link CSVRecord} entries, may be empty\n      * @throws IOException\n      *             on parse error or input read-failure\n     }\n \n     public boolean isClosed() {\n-\t\treturn this.lexer.isClosed();\n-\t}\n-\n-\t/**\n+        return this.lexer.isClosed();\n+    }\n+\n+    /**\n      * Returns an iterator on the records. IOExceptions occurring during the iteration are wrapped in a\n      * RuntimeException.\n      */\n             }\n \n             public boolean hasNext() {\n-            \tif (CSVParser.this.isClosed()) {\n-            \t\treturn false;\n-            \t}\n+                if (CSVParser.this.isClosed()) {\n+                    return false;\n+                }\n                 if (this.current == null) {\n                     this.current = this.getNextRecord();\n                 }\n             }\n \n             public CSVRecord next() {\n-            \tif (CSVParser.this.isClosed()) {\n-            \t\treturn null;\n-            \t}\n+                if (CSVParser.this.isClosed()) {\n+                    return null;\n+                }\n                 CSVRecord next = this.current;\n                 this.current = null;\n \n \n     /**\n      * Parses the next record from the current point in the stream.\n-     *\n+     * \n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n      * @throws IOException\n      *             on parse error or input read-failure\n         if (!this.record.isEmpty()) {\n             this.recordNumber++;\n             final String comment = sb == null ? null : sb.toString();\n-            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment, this.recordNumber);\n+            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n+                    this.recordNumber);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n         this.comment = comment;\n+    }\n+\n+    /**\n+     * Returns a value by {@link Enum}.\n+     *\n+     * @param e\n+     *            an enum\n+     * @return the String at the given enum String\n+     */\n+    public String get(Enum<?> e) {\n+        return get(e.toString());\n     }\n \n     /**\n         return Arrays.toString(values);\n     }\n \n+\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/FercGovTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Real world examples from http://www.ferc.gov/docs-filing/eqr/soft-tools/sample-csv.asp\n+ */\n+public class FercGovTest {\n+\n+    private enum ContractColumnNames {\n+        contract_id, seller_company_name, customer_company_name, customer_duns_number, contract_affiliate,\n+        FERC_tariff_reference, contract_service_agreement_id, contract_execution_date, contract_commencement_date,\n+        contract_termination_date, actual_termination_date, extension_provision_description, class_name, term_name,\n+        increment_name, increment_peaking_name, product_type_name, product_name, quantity, units_for_contract, rate,\n+        rate_minimum, rate_maximum, rate_description, units_for_rate, point_of_receipt_control_area,\n+        point_of_receipt_specific_location, point_of_delivery_control_area, point_of_delivery_specific_location,\n+        begin_date, end_date, time_zone;\n+    }\n+\n+    private static final Charset US_ASCII = Charset.forName(\"US-ASCII\");\n+\n+    @Test\n+    public void testContractFile() throws IOException {\n+        final CSVParser parser = CSVParser.parseResource(\"ferc.gov/contract.txt\", US_ASCII,\n+                CSVFormat.DEFAULT.withHeader());\n+        try {\n+            final List<CSVRecord> records = parser.getRecords();\n+            CSVRecord record = records.get(0);\n+            Assert.assertEquals(22, records.size());\n+            // first record\n+            Assert.assertEquals(\"C71\", record.get(ContractColumnNames.contract_id));\n+            Assert.assertEquals(\"The Electric Company\", record.get(ContractColumnNames.seller_company_name));\n+            Assert.assertEquals(\"ES\", record.get(ContractColumnNames.time_zone));\n+            // last record\n+            record = records.get(records.size() - 1);\n+            // first record\n+            Assert.assertEquals(\"C78\", record.get(ContractColumnNames.contract_id));\n+            Assert.assertEquals(\"The Electric Company\", record.get(ContractColumnNames.seller_company_name));\n+            Assert.assertEquals(\"EP\", record.get(ContractColumnNames.time_zone));\n+        } finally {\n+            parser.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testTransactionFile() throws IOException {\n+        final CSVParser parser = CSVParser.parseResource(\"ferc.gov/transaction.txt\", US_ASCII,\n+                CSVFormat.DEFAULT.withHeader());\n+        try {\n+            final List<CSVRecord> records = parser.getRecords();\n+            Assert.assertEquals(24, records.size());\n+            CSVRecord record = records.get(0);\n+            // first record\n+            Assert.assertEquals(\"T1\", record.get(\"transaction_unique_identifier\"));\n+            Assert.assertEquals(\"The Electric Company\", record.get(\"seller_company_name\"));\n+            Assert.assertEquals(\"880386\", record.get(\"transaction_charge\"));\n+            // last record\n+            record = records.get(records.size() - 1);\n+            Assert.assertEquals(\"T15\", record.get(\"transaction_unique_identifier\"));\n+            Assert.assertEquals(\"The Electric Company\", record.get(\"seller_company_name\"));\n+            Assert.assertEquals(\"1800\", record.get(\"transaction_charge\"));\n+        } finally {\n+            parser.close();\n+        }\n+    }\n+}", "timestamp": 1375322613, "metainfo": ""}