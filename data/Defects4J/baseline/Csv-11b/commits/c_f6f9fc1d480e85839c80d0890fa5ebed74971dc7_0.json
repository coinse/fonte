{"sha": "f6f9fc1d480e85839c80d0890fa5ebed74971dc7", "log": "Pulled some static methods into a CSVUtils class, switched CSVPrinter to use a CSVStrategy though it doesn't use it fully yet, added a COMMENTS_DISABLED constant instead of relying on (char) 0.   ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n       type = TT_INVALID;\n       isReady = false;\n     }\n-  }\n-  \n-  // ======================================================\n-  //  static parsers\n-  // ======================================================\n-  \n-  /**\n-   * Parses the given String according to the default CSV strategy.\n-   * \n-   * @param s CSV String to be parsed.\n-   * @return parsed String matrix (which is never null)\n-   * @throws IOException in case of error\n-   * @see #setStrategy()\n-   */\n-  public static String[][] parse(String s) throws IOException {\n-    if (s == null) {\n-      throw new IllegalArgumentException(\"Null argument not allowed.\");\n-    }\n-    String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n-    if (result == null) {\n-      // since CSVStrategy ignores empty lines an empty array is returned\n-      // (i.e. not \"result = new String[][] {{\"\"}};\")\n-      result = new String[0][0];\n-    }\n-    return result;\n-  }\n-  \n-  /**\n-   * Parses the first line only according to the default CSV strategy.\n-   * \n-   * Parsing empty string will be handled as valid records containing zero\n-   * elements, so the following property holds: parseLine(\"\").length == 0.\n-   * \n-   * @param s CSV String to be parsed.\n-   * @return parsed String vector (which is never null)\n-   * @throws IOException in case of error\n-   * @see #setStrategy()\n-   */\n-  public static String[] parseLine(String s) throws IOException {\n-    if (s == null) {\n-      throw new IllegalArgumentException(\"Null argument not allowed.\");\n-    }\n-    // uh,jh: make sure that parseLine(\"\").length == 0\n-    if (s.length() == 0) {\n-      return new String[0];\n-    }\n-    return (new CSVParser(new StringReader(s))).getLine();\n   }\n   \n   // ======================================================\n         eol = isEndOfLine(c);\n       }\n       // ok, start of token reached: comment, encapsulated, or token\n-      if (c == strategy.getCommentStart()) {\n+      if (!strategy.isCommentingDisabled() && c == strategy.getCommentStart()) {\n         // ignore everything till end of line and continue (incr linecount)\n         in.readLine();\n         tkn = nextToken();\n   // ======================================================\n   \n   /**\n-   * @return true if the given char is a whitespache character\n+   * @return true if the given char is a whitespace character\n    */\n   private boolean isWhitespace(int c) {\n     return Character.isWhitespace((char) c);\n--- a/src/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/java/org/apache/commons/csv/CSVPrinter.java\n   /** True if we just began a new line. */\n   protected boolean newLine = true;\n \n-  /** Character used to start comments. (Default is '#') */\n-  protected char commentStart = '#';\n-  \n-  /** Character used to separate entities. (Default is ',') */\n-  protected char separatorChar = ',';\n+  private CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n \n   /**\n    * Create a printer that will print values to the given\n   }\n \n \n-  /**\n-   * Create a printer that will print values to the given\n-   * stream. Character to byte conversion is done using\n-   * the default character encoding.\n-   *\n-   * @param out stream to which to print.\n-   * @param commentStart Character used to start comments.\n-   */\n-  public CSVPrinter(OutputStream out, char commentStart) {\n-    this(out);\n-    this.commentStart = commentStart;\n-  }\n-\n-\n-  /**\n-   * Create a printer that will print values to the given\n-   * stream.\n-   *\n-   * @param out stream to which to print.\n-   * @param commentStart Character used to start comments.\n-   */\n-  public CSVPrinter(Writer out, char commentStart) {\n-    this(out);\n-    this.commentStart = commentStart;\n-  }\n-\n-  /**\n-   * Gets the comment start character.\n+  // ======================================================\n+  //  strategies\n+  // ======================================================\n+  \n+  /**\n+   * Sets the specified CSV Strategy\n+   *\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVPrinter setStrategy(CSVStrategy strategy) {\n+    this.strategy = strategy;\n+    return this;\n+  }\n+  \n+  /**\n+   * Obtain the specified CSV Strategy\n    * \n-   * @return the commentStart character\n-   */\n-  public char getCommentStart() {\n-    return commentStart;\n+   * @return strategy currently being used\n+   */\n+  public CSVStrategy getStrategy() {\n+    return this.strategy;\n   }\n   \n-  /**\n-   * Sets the comment start character.\n-   * \n-   * @param commentStart commentStart character to set.\n-   */\n-  public void setCommentStart(char commentStart) {\n-    this.commentStart = commentStart;\n-  }\n-  \n-  /**\n-   * Gets the separator character.\n-   * \n-   * @return Returns the separatorChar.\n-   */\n-  public char getSeparatorChar() {\n-    return separatorChar;\n-  }\n-  /**\n-   * Sets the separator character.\n-   * \n-   * @param separatorChar The separatorChar to set.\n-   */\n-  public void setSeparatorChar(char separatorChar) {\n-    this.separatorChar = separatorChar;\n-  }\n-  \n+  // ======================================================\n+  //  printing implementation\n+  // ======================================================\n+\n   /**\n    * Print the string as the last value on the line. The value\n    * will be quoted if needed.\n    * @param comment the comment to output\n    */\n   public void printlnComment(String comment) {\n+    if(this.strategy.isCommentingDisabled()) {\n+        return;\n+    }\n     if (!newLine) {\n       out.println();\n     }\n-    out.print(commentStart);\n+    out.print(this.strategy.getCommentStart());\n     out.print(' ');\n     for (int i = 0; i < comment.length(); i++) {\n       char c = comment.charAt(i);\n           // break intentionally excluded.\n         case '\\n' :\n           out.println();\n-          out.print(commentStart);\n+          out.print(this.strategy.getCommentStart());\n           out.print(' ');\n           break;\n         default :\n       }\n       for (int i = 0; i < value.length(); i++) {\n         c = value.charAt(i);\n-        if (c == '\"' || c == separatorChar || c == '\\n' || c == '\\r') {\n+        if (c == '\"' || c == this.strategy.getDelimiter() || c == '\\n' || c == '\\r') {\n           quote = true;\n         }\n       }\n     if (newLine) {\n       newLine = false;\n     } else {\n-      out.print(separatorChar);\n+      out.print(this.strategy.getDelimiter());\n     }\n     if (quote) {\n       out.print(escapeAndQuote(value));\n       out.print(value);\n     }\n     out.flush();\n-  }\n-\n-\n-  /**\n-   * Converts an array of string values into a single CSV line. All\n-   * <code>null</code> values are converted to the string <code>\"null\"</code>,\n-   * all strings equal to <code>\"null\"</code> will additionally get quotes\n-   * around.\n-   *\n-   * @param values the value array\n-   * @return the CSV string, will be an empty string if the length of the\n-   * value array is 0\n-   */\n-  public static String printLine(String[] values) {\n-\n-    // set up a CSVPrinter\n-    StringWriter csvWriter = new StringWriter();\n-    CSVPrinter csvPrinter = new CSVPrinter(csvWriter);\n-\n-    // check for null values an \"null\" as strings and convert them\n-    // into the strings \"null\" and \"\\\"null\\\"\"\n-    for (int i = 0; i < values.length; i++) {\n-      if (values[i] == null) {\n-        values[i] = \"null\";\n-      } else if (values[i].equals(\"null\")) {\n-        values[i] = \"\\\"null\\\"\";\n-      }\n-    }\n-\n-    // convert to CSV\n-    csvPrinter.println(values);\n-\n-    // as the resulting string has \\r\\n at the end, we will trim that away\n-    return csvWriter.toString().trim();\n   }\n \n \n--- a/src/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n     private boolean interpretUnicodeEscapes;\n     private boolean ignoreEmptyLines;\n \n-    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', (char) 0, true,  false, true);\n-    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(';', '\"', (char) 0, false, false, false);\n+    public static char COMMENTS_DISABLED       = (char) 0;\n+\n+    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, true,  false, true);\n+    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(';', '\"', COMMENTS_DISABLED, false, false, false);\n+    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '\"', COMMENTS_DISABLED, true,  false, true);\n \n \n     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n \n     public void setCommentStart(char commentStart) { this.commentStart = commentStart; }\n     public char getCommentStart() { return this.commentStart; }\n+    public boolean isCommentingDisabled() { return this.commentStart == COMMENTS_DISABLED; }\n \n     public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; }\n     public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/CSVUtils.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import java.io.StringWriter;\n+import java.io.StringReader;\n+import java.io.IOException;\n+\n+/**\n+ * Utility methods for dealing with CSV files\n+ */\n+public class CSVUtils {\n+\n+    /**\n+     * <p><code>CSVUtils</code> instances should NOT be constructed in\n+     * standard programming. \n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public CSVUtils() {\n+    }\n+  \n+    /**\n+     * Converts an array of string values into a single CSV line. All\n+     * <code>null</code> values are converted to the string <code>\"null\"</code>,\n+     * all strings equal to <code>\"null\"</code> will additionally get quotes\n+     * around.\n+     *\n+     * @param values the value array\n+     * @return the CSV string, will be an empty string if the length of the\n+     * value array is 0\n+     */\n+    public static String printLine(String[] values) {\n+        // set up a CSVUtils\n+        StringWriter stringWriter = new StringWriter();\n+        CSVPrinter csvPrinter = new CSVPrinter(stringWriter);\n+  \n+        // check for null values an \"null\" as strings and convert them\n+        // into the strings \"null\" and \"\\\"null\\\"\"\n+        for (int i = 0; i < values.length; i++) {\n+            if (values[i] == null) {\n+                values[i] = \"null\";\n+            } else if (values[i].equals(\"null\")) {\n+                values[i] = \"\\\"null\\\"\";\n+            }\n+        }\n+  \n+        // convert to CSV\n+        csvPrinter.println(values);\n+  \n+        // as the resulting string has \\r\\n at the end, we will trim that away\n+        return stringWriter.toString().trim();\n+    }\n+  \n+  // ======================================================\n+  //  static parsers\n+  // ======================================================\n+  \n+  /**\n+   * Parses the given String according to the default CSV strategy.\n+   * \n+   * @param s CSV String to be parsed.\n+   * @return parsed String matrix (which is never null)\n+   * @throws IOException in case of error\n+   * @see #setStrategy()\n+   */\n+  public static String[][] parse(String s) throws IOException {\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Null argument not allowed.\");\n+    }\n+    String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n+    if (result == null) {\n+      // since CSVStrategy ignores empty lines an empty array is returned\n+      // (i.e. not \"result = new String[][] {{\"\"}};\")\n+      result = new String[0][0];\n+    }\n+    return result;\n+  }\n+  \n+  /**\n+   * Parses the first line only according to the default CSV strategy.\n+   * \n+   * Parsing empty string will be handled as valid records containing zero\n+   * elements, so the following property holds: parseLine(\"\").length == 0.\n+   * \n+   * @param s CSV String to be parsed.\n+   * @return parsed String vector (which is never null)\n+   * @throws IOException in case of error\n+   * @see #setStrategy()\n+   */\n+  public static String[] parseLine(String s) throws IOException {\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Null argument not allowed.\");\n+    }\n+    // uh,jh: make sure that parseLine(\"\").length == 0\n+    if (s.length() == 0) {\n+      return new String[0];\n+    }\n+    return (new CSVParser(new StringReader(s))).getLine();\n+  }\n+  \n+}\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n     }\n   }\n   \n-  // ======================================================\n-  //   static parser tests\n-  // ======================================================\n-  public void testParse1() throws IOException {\n-      String[][] data = CSVParser.parse(\"abc\\ndef\");\n-      assertEquals(2, data.length);\n-      assertEquals(1, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\", data[1][0]);\n-    }\n-\n-    public void testParse2() throws IOException {\n-      String[][] data = CSVParser.parse(\"abc,def,\\\"ghi,jkl\\\"\\ndef\");\n-      assertEquals(2, data.length);\n-      assertEquals(3, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\", data[0][1]);\n-      assertEquals(\"ghi,jkl\", data[0][2]);\n-      assertEquals(\"def\", data[1][0]);\n-    }\n-\n-    public void testParse3() throws IOException {\n-      String[][] data = CSVParser.parse(\"abc,\\\"def\\nghi\\\"\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n-    }\n-\n-    public void testParse4() throws IOException {\n-      String[][] data = CSVParser.parse(\"abc,\\\"def\\\\\\\\nghi\\\"\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      // an escape char in quotes only escapes a delimiter, not itself\n-      assertEquals(\"def\\\\\\\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n-    }\n-\n-    public void testParse5() throws IOException {\n-      String[][] data = CSVParser.parse(\"abc,def\\\\nghi\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\\\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n-    }\n-    \n-    public void testParse6() throws IOException {\n-      String[][] data = CSVParser.parse(\"\");\n-      // default strategy is CSV, which ignores empty lines\n-      assertEquals(0, data.length);\n-    }\n-    \n-    public void testParse7() throws IOException {\n-      boolean io = false;\n-      try {\n-        CSVParser.parse(null);\n-      } catch (IllegalArgumentException e) {\n-        io = true;\n-      }\n-      assertTrue(io);\n-    }\n-    \n-    public void testParseLine1() throws IOException {\n-      String[] data = CSVParser.parseLine(\"abc,def,ghi\");\n-      assertEquals(3, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\", data[1]);\n-      assertEquals(\"ghi\", data[2]);\n-    }\n-\n-    public void testParseLine2() throws IOException {\n-      String[] data = CSVParser.parseLine(\"abc,def,ghi\\n\");\n-      assertEquals(3, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\", data[1]);\n-      assertEquals(\"ghi\", data[2]);\n-    }\n-\n-    public void testParseLine3() throws IOException {\n-      String[] data = CSVParser.parseLine(\"abc,\\\"def,ghi\\\"\");\n-      assertEquals(2, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def,ghi\", data[1]);\n-    }\n-\n-    public void testParseLine4() throws IOException {\n-      String[] data = CSVParser.parseLine(\"abc,\\\"def\\nghi\\\"\");\n-      assertEquals(2, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\\nghi\", data[1]);\n-    }\n-    \n-    public void testParseLine5() throws IOException {\n-      String[] data = CSVParser.parseLine(\"\");\n-      assertEquals(0, data.length);\n-      // assertEquals(\"\", data[0]);\n-    }\n-    \n-    public void testParseLine6() throws IOException {\n-      boolean io = false;\n-      try {\n-        CSVParser.parseLine(null);\n-      } catch (IllegalArgumentException e) {\n-        io = true;\n-      }\n-      assertTrue(io);\n-    }\n-    \n-    public void testParseLine7() throws IOException {\n-      String[] res = CSVParser.parseLine(\"\");\n-      assertNotNull(res);\n-      assertEquals(0, res.length);  \n-    }\n-      \n     public void testUnicodeEscape() throws IOException {\n       String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n       CSVParser parser = new CSVParser(new StringReader(code));\n--- a/src/test/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/org/apache/commons/csv/CSVPrinterTest.java\n   public void testExcelPrinter1() {\n     StringWriter sw = new StringWriter();\n     CSVPrinter printer = new CSVPrinter(sw);\n-    printer.setSeparatorChar(';');\n+    printer.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n     String[] line1 = {\"a\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"a;b\" + lineSeparator, sw.toString());\n   public void testExcelPrinter2() {\n     StringWriter sw = new StringWriter();\n     CSVPrinter printer = new CSVPrinter(sw);\n-    printer.setSeparatorChar(';');\n+    printer.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n     String[] line1 = {\"a;b\", \"b\"};\n     printer.println(line1);\n     assertEquals(\"\\\"a;b\\\";b\" + lineSeparator, sw.toString());\n--- /dev/null\n+++ b/src/test/org/apache/commons/csv/CSVUtilsTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * CSVUtilsTest\n+ */\n+public class CSVUtilsTest extends TestCase {\n+  \n+  // ======================================================\n+  //   static parser tests\n+  // ======================================================\n+  public void testParse1() throws IOException {\n+      String[][] data = CSVUtils.parse(\"abc\\ndef\");\n+      assertEquals(2, data.length);\n+      assertEquals(1, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\", data[1][0]);\n+    }\n+\n+    public void testParse2() throws IOException {\n+      String[][] data = CSVUtils.parse(\"abc,def,\\\"ghi,jkl\\\"\\ndef\");\n+      assertEquals(2, data.length);\n+      assertEquals(3, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\", data[0][1]);\n+      assertEquals(\"ghi,jkl\", data[0][2]);\n+      assertEquals(\"def\", data[1][0]);\n+    }\n+\n+    public void testParse3() throws IOException {\n+      String[][] data = CSVUtils.parse(\"abc,\\\"def\\nghi\\\"\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+\n+    public void testParse4() throws IOException {\n+      String[][] data = CSVUtils.parse(\"abc,\\\"def\\\\\\\\nghi\\\"\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      // an escape char in quotes only escapes a delimiter, not itself\n+      assertEquals(\"def\\\\\\\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+\n+    public void testParse5() throws IOException {\n+      String[][] data = CSVUtils.parse(\"abc,def\\\\nghi\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\\\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+    \n+    public void testParse6() throws IOException {\n+      String[][] data = CSVUtils.parse(\"\");\n+      // default strategy is CSV, which ignores empty lines\n+      assertEquals(0, data.length);\n+    }\n+    \n+    public void testParse7() throws IOException {\n+      boolean io = false;\n+      try {\n+        CSVUtils.parse(null);\n+      } catch (IllegalArgumentException e) {\n+        io = true;\n+      }\n+      assertTrue(io);\n+    }\n+    \n+    public void testParseLine1() throws IOException {\n+      String[] data = CSVUtils.parseLine(\"abc,def,ghi\");\n+      assertEquals(3, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\", data[1]);\n+      assertEquals(\"ghi\", data[2]);\n+    }\n+\n+    public void testParseLine2() throws IOException {\n+      String[] data = CSVUtils.parseLine(\"abc,def,ghi\\n\");\n+      assertEquals(3, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\", data[1]);\n+      assertEquals(\"ghi\", data[2]);\n+    }\n+\n+    public void testParseLine3() throws IOException {\n+      String[] data = CSVUtils.parseLine(\"abc,\\\"def,ghi\\\"\");\n+      assertEquals(2, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def,ghi\", data[1]);\n+    }\n+\n+    public void testParseLine4() throws IOException {\n+      String[] data = CSVUtils.parseLine(\"abc,\\\"def\\nghi\\\"\");\n+      assertEquals(2, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\\nghi\", data[1]);\n+    }\n+    \n+    public void testParseLine5() throws IOException {\n+      String[] data = CSVUtils.parseLine(\"\");\n+      assertEquals(0, data.length);\n+      // assertEquals(\"\", data[0]);\n+    }\n+    \n+    public void testParseLine6() throws IOException {\n+      boolean io = false;\n+      try {\n+        CSVUtils.parseLine(null);\n+      } catch (IllegalArgumentException e) {\n+        io = true;\n+      }\n+      assertTrue(io);\n+    }\n+    \n+    public void testParseLine7() throws IOException {\n+      String[] res = CSVUtils.parseLine(\"\");\n+      assertNotNull(res);\n+      assertEquals(0, res.length);  \n+    }\n+      \n+}", "timestamp": 1150722099, "metainfo": ""}