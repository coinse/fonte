{"sha": "c559795b26d975d53a6491770a15eb8f3fbe85fd", "log": "Some clean-up of the jsdoc parser. This is just a lot of code-moving. There should be no functional changes here. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42859670", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n    * @return {@code true} if JSDoc information was correctly parsed,\n    *     {@code false} otherwise\n    */\n-  @SuppressWarnings(\"incomplete-switch\")\n   boolean parse() {\n-    int lineno;\n-    int charno;\n-\n-    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n-    JSTypeExpression type;\n-\n     state = State.SEARCHING_ANNOTATION;\n     skipEOLs();\n \n     }\n \n     // Parse the actual JsDoc.\n-    retry: for (;;) {\n+    while (true) {\n       switch (token) {\n         case ANNOTATION:\n           if (state == State.SEARCHING_ANNOTATION) {\n             state = State.SEARCHING_NEWLINE;\n-            lineno = stream.getLineno();\n-            charno = stream.getCharno();\n-\n-            String annotationName = stream.getString();\n-            Annotation annotation = annotationNames.get(annotationName);\n-            if (annotation == null) {\n-              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n-                  stream.getLineno(), stream.getCharno());\n-            } else {\n-              // Mark the beginning of the annotation.\n-              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n-\n-              switch (annotation) {\n-                case NG_INJECT:\n-                  if (jsdocBuilder.isNgInjectRecorded()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n-                      stream.getLineno(), stream.getCharno());\n-                  } else {\n-                    jsdocBuilder.recordNgInject(true);\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case AUTHOR:\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo authorInfo = extractSingleLineBlock();\n-                    String author = authorInfo.string;\n-\n-                    if (author.length() == 0) {\n-                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      jsdocBuilder.addAuthor(author);\n-                    }\n-                    token = authorInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case CONSISTENTIDGENERATOR:\n-                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case STRUCT:\n-                  if (!jsdocBuilder.recordStruct()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                                          stream.getLineno(),\n-                                          stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DICT:\n-                  if (!jsdocBuilder.recordDict()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                                          stream.getLineno(),\n-                                          stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case CONSTRUCTOR:\n-                  if (!jsdocBuilder.recordConstructor()) {\n-                    if (jsdocBuilder.isInterfaceRecorded()) {\n-                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DEPRECATED:\n-                  if (!jsdocBuilder.recordDeprecated()) {\n-                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  // Find the reason/description, if any.\n-                  ExtractionInfo reasonInfo =\n-                      extractMultilineTextualBlock(token);\n-\n-                  String reason = reasonInfo.string;\n-\n-                  if (reason.length() > 0) {\n-                    jsdocBuilder.recordDeprecationReason(reason);\n-                  }\n-\n-                  token = reasonInfo.token;\n-                  continue retry;\n-\n-                case INTERFACE:\n-                  if (!jsdocBuilder.recordInterface()) {\n-                    if (jsdocBuilder.isConstructorRecorded()) {\n-                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DESC:\n-                  if (jsdocBuilder.isDescriptionRecorded()) {\n-                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                    token = eatTokensUntilEOL();\n-                    continue retry;\n-                  } else {\n-                    ExtractionInfo descriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String description = descriptionInfo.string;\n-\n-                    jsdocBuilder.recordDescription(description);\n-                    token = descriptionInfo.token;\n-                    continue retry;\n-                  }\n-\n-                case FILE_OVERVIEW:\n-                  String fileOverview = \"\";\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo fileOverviewInfo =\n-                        extractMultilineTextualBlock(token,\n-                            WhitespaceOption.TRIM);\n-\n-                    fileOverview = fileOverviewInfo.string;\n-\n-                    token = fileOverviewInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-\n-                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n-                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  continue retry;\n-\n-                case LICENSE:\n-                case PRESERVE:\n-                  ExtractionInfo preserveInfo =\n-                      extractMultilineTextualBlock(token,\n-                                                   WhitespaceOption.PRESERVE);\n-\n-                  String preserve = preserveInfo.string;\n-\n-                  if (preserve.length() > 0) {\n-                    if (fileLevelJsDocBuilder != null) {\n-                      fileLevelJsDocBuilder.append(preserve);\n-                    }\n-                  }\n-\n-                  token = preserveInfo.token;\n-                  continue retry;\n-\n-                case ENUM:\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-\n-                  type = null;\n-                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordTypeNode(token));\n-                  }\n-\n-                  if (type == null) {\n-                    type = createJSTypeExpression(newStringNode(\"number\"));\n-                  }\n-                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.incompat.type\", lineno, charno);\n-                  }\n-                  token = eatTokensUntilEOL(token);\n-                  continue retry;\n-\n-                case EXPORT:\n-                  if (!jsdocBuilder.recordExport()) {\n-                    parser.addParserWarning(\"msg.jsdoc.export\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXPOSE:\n-                  if (!jsdocBuilder.recordExpose()) {\n-                    parser.addParserWarning(\"msg.jsdoc.expose\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXTERNS:\n-                  if (!jsdocBuilder.recordExterns()) {\n-                    parser.addParserWarning(\"msg.jsdoc.externs\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case JAVA_DISPATCH:\n-                  if (!jsdocBuilder.recordJavaDispatch()) {\n-                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXTENDS:\n-                case IMPLEMENTS:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  boolean matchingRc = false;\n-\n-                  if (token == JsDocToken.LC) {\n-                    token = next();\n-                    matchingRc = true;\n-                  }\n-\n-                  if (token == JsDocToken.STRING) {\n-                    Node typeNode = parseAndRecordTypeNameNode(\n-                        token, lineno, charno, matchingRc);\n-\n-                    lineno = stream.getLineno();\n-                    charno = stream.getCharno();\n-\n-                    typeNode = wrapNode(Token.BANG, typeNode);\n-                    type = createJSTypeExpression(typeNode);\n-\n-                    if (annotation == Annotation.EXTENDS) {\n-                      // record the extended type, check later\n-                      extendedTypes.add(new ExtendedTypeInfo(\n-                          type, stream.getLineno(), stream.getCharno()));\n-                    } else {\n-                      Preconditions.checkState(\n-                          annotation == Annotation.IMPLEMENTS);\n-                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n-                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n-                            lineno, charno);\n-                      }\n-                    }\n-                    token = next();\n-                    if (matchingRc) {\n-                      if (token != JsDocToken.RC) {\n-                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n-                            stream.getLineno(), stream.getCharno());\n-                      }\n-                    } else if (token != JsDocToken.EOL &&\n-                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n-                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  } else {\n-                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n-                  }\n-                  token = eatTokensUntilEOL(token);\n-                  continue retry;\n-\n-                case HIDDEN:\n-                  if (!jsdocBuilder.recordHiddenness()) {\n-                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case LENDS:\n-                  skipEOLs();\n-\n-                  matchingRc = false;\n-                  if (match(JsDocToken.LC)) {\n-                    token = next();\n-                    matchingRc = true;\n-                  }\n-\n-                  if (match(JsDocToken.STRING)) {\n-                    token = next();\n-                    if (!jsdocBuilder.recordLends(stream.getString())) {\n-                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  } else {\n-                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  if (matchingRc && !match(JsDocToken.RC)) {\n-                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case MEANING:\n-                  ExtractionInfo meaningInfo =\n-                      extractMultilineTextualBlock(token);\n-                  String meaning = meaningInfo.string;\n-                  token = meaningInfo.token;\n-                  if (!jsdocBuilder.recordMeaning(meaning)) {\n-                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  continue retry;\n-\n-                case NO_ALIAS:\n-                  if (!jsdocBuilder.recordNoAlias()) {\n-                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_COMPILE:\n-                  if (!jsdocBuilder.recordNoCompile()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_TYPE_CHECK:\n-                  if (!jsdocBuilder.recordNoTypeCheck()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NOT_IMPLEMENTED:\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case INHERIT_DOC:\n-                case OVERRIDE:\n-                  if (!jsdocBuilder.recordOverride()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.override\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case THROWS:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  type = null;\n-\n-                  if (token == JsDocToken.LC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordTypeNode(token));\n-\n-                    if (type == null) {\n-                      // parsing error reported during recursive descent\n-                      // recovering parsing\n-                      token = eatTokensUntilEOL();\n-                      continue retry;\n-                    }\n-                  }\n-\n-                  // *Update* the token to that after the type annotation.\n-                  token = current();\n-\n-                  // Save the throw type.\n-                  jsdocBuilder.recordThrowType(type);\n-\n-                  // Find the throw's description (if applicable).\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo descriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String description = descriptionInfo.string;\n-\n-                    if (description.length() > 0) {\n-                      jsdocBuilder.recordThrowDescription(type, description);\n-                    }\n-\n-                    token = descriptionInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case PARAM:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  type = null;\n-\n-                  if (token == JsDocToken.LC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordParamTypeNode(token));\n-\n-                    if (type == null) {\n-                      // parsing error reported during recursive descent\n-                      // recovering parsing\n-                      token = eatTokensUntilEOL();\n-                      continue retry;\n-                    }\n-                    skipEOLs();\n-                    token = next();\n-                    lineno = stream.getLineno();\n-                    charno = stream.getCharno();\n-                  }\n-\n-                  String name = null;\n-                  boolean isBracketedParam = JsDocToken.LB == token;\n-                  if (isBracketedParam) {\n-                    token = next();\n-                  }\n-\n-                  if (JsDocToken.STRING != token) {\n-                    parser.addTypeWarning(\"msg.missing.variable.name\",\n-                        lineno, charno);\n-                  } else {\n-                    name = stream.getString();\n-\n-                    if (isBracketedParam) {\n-                      token = next();\n-\n-                      // Throw out JsDocToolkit's \"default\" parameter\n-                      // annotation.  It makes no sense under our type\n-                      // system.\n-                      if (JsDocToken.EQUALS == token) {\n-                        token = next();\n-                        if (JsDocToken.STRING == token) {\n-                          token = next();\n-                        }\n-                      }\n-\n-                      if (JsDocToken.RB != token) {\n-                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n-                      } else if (type != null) {\n-                        // Make the type expression optional, if it isn't\n-                        // already.\n-                        type = JSTypeExpression.makeOptionalArg(type);\n-                      }\n-                    }\n-\n-                    // If the param name has a DOT in it, just throw it out\n-                    // quietly. We do not handle the JsDocToolkit method\n-                    // for handling properties of params.\n-                    if (name.indexOf('.') > -1) {\n-                      name = null;\n-                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n-                      if (jsdocBuilder.hasParameter(name)) {\n-                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n-                            lineno, charno);\n-                      } else {\n-                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n-                            lineno, charno);\n-                      }\n-                    }\n-                  }\n-\n-                  if (name == null) {\n-                    token = eatTokensUntilEOL(token);\n-                    continue retry;\n-                  }\n-\n-                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n-\n-                  // Find the parameter's description (if applicable).\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo paramDescriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String paramDescription = paramDescriptionInfo.string;\n-\n-                    if (paramDescription.length() > 0) {\n-                      jsdocBuilder.recordParameterDescription(name,\n-                          paramDescription);\n-                    }\n-\n-                    token = paramDescriptionInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case PRESERVE_TRY:\n-                  if (!jsdocBuilder.recordPreserveTry()) {\n-                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_SHADOW:\n-                  if (!jsdocBuilder.recordNoShadow()) {\n-                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_SIDE_EFFECTS:\n-                  if (!jsdocBuilder.recordNoSideEffects()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case MODIFIES:\n-                  token = parseModifiesTag(next());\n-                  continue retry;\n-\n-                case IMPLICIT_CAST:\n-                  if (!jsdocBuilder.recordImplicitCast()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case SEE:\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n-                    String reference = referenceInfo.string;\n-\n-                    if (reference.length() == 0) {\n-                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      jsdocBuilder.addReference(reference);\n-                    }\n-\n-                    token = referenceInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case STABLEIDGENERATOR:\n-                  if (!jsdocBuilder.recordStableIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case SUPPRESS:\n-                  token = parseSuppressTag(next());\n-                  continue retry;\n-\n-                case TEMPLATE: {\n-                  ExtractionInfo templateInfo = extractSingleLineBlock();\n-                  List<String> names = Lists.newArrayList(\n-                      Splitter.on(',')\n-                          .trimResults()\n-                          .split(templateInfo.string));\n-\n-                  if (names.size() == 0 || names.get(0).length() == 0) {\n-                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n-                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  token = templateInfo.token;\n-                  continue retry;\n-                }\n-\n-                case CLASS_TEMPLATE: {\n-                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n-                  List<String> names = Lists.newArrayList(\n-                      Splitter.on(',')\n-                          .trimResults()\n-                          .split(classTemplateInfo.string));\n-\n-                  if (names.size() == 0 || names.get(0).length() == 0) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.classtemplate.missing.type.name\",\n-                        stream.getLineno(), stream.getCharno());\n-                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.classtemplate.at.most.once\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  token = classTemplateInfo.token;\n-                  continue retry;\n-                }\n-\n-                case IDGENERATOR:\n-                  if (!jsdocBuilder.recordIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case VERSION:\n-                  ExtractionInfo versionInfo = extractSingleLineBlock();\n-                  String version = versionInfo.string;\n-\n-                  if (version.length() == 0) {\n-                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                  } else {\n-                    if (!jsdocBuilder.recordVersion(version)) {\n-                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-\n-                  token = versionInfo.token;\n-                  continue retry;\n-\n-                case CONSTANT:\n-                case DEFINE:\n-                case RETURN:\n-                case PRIVATE:\n-                case PROTECTED:\n-                case PUBLIC:\n-                case THIS:\n-                case TYPE:\n-                case TYPEDEF:\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-\n-                  Node typeNode = null;\n-                  boolean hasType = lookAheadForTypeAnnotation();\n-                  boolean isAlternateTypeAnnotation =\n-                      (annotation == Annotation.PRIVATE ||\n-                       annotation == Annotation.PROTECTED ||\n-                       annotation == Annotation.PUBLIC ||\n-                       annotation == Annotation.CONSTANT);\n-                  boolean canSkipTypeAnnotation =\n-                      (isAlternateTypeAnnotation ||\n-                       annotation == Annotation.RETURN);\n-                  type = null;\n-                  if (hasType || !canSkipTypeAnnotation) {\n-                    skipEOLs();\n-                    token = next();\n-                    typeNode = parseAndRecordTypeNode(token);\n-\n-                    if (annotation == Annotation.THIS) {\n-                      typeNode = wrapNode(Token.BANG, typeNode);\n-                    }\n-                    type = createJSTypeExpression(typeNode);\n-                  }\n-\n-                  // The error was reported during recursive descent\n-                  // recovering parsing\n-                  boolean hasError = type == null && !canSkipTypeAnnotation;\n-                  if (!hasError) {\n-                    // Record types for @type.\n-                    // If the @private, @protected, or @public annotations\n-                    // have a type attached, pretend that they actually wrote:\n-                    // @type {type}\\n@private\n-                    // This will have some weird behavior in some cases\n-                    // (for example, @private can now be used as a type-cast),\n-                    // but should be mostly OK.\n-                    if ((type != null && isAlternateTypeAnnotation)\n-                        || annotation == Annotation.TYPE) {\n-                      if (!jsdocBuilder.recordType(type)) {\n-                        parser.addTypeWarning(\n-                            \"msg.jsdoc.incompat.type\", lineno, charno);\n-                      }\n-                    }\n-\n-                    switch (annotation) {\n-                      case CONSTANT:\n-                        if (!jsdocBuilder.recordConstancy()) {\n-                          parser.addParserWarning(\"msg.jsdoc.const\",\n-                              stream.getLineno(), stream.getCharno());\n-                        }\n-                        break;\n-\n-                      case DEFINE:\n-                        if (!jsdocBuilder.recordDefineType(type)) {\n-                          parser.addParserWarning(\"msg.jsdoc.define\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PRIVATE:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.private\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PROTECTED:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.protected\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PUBLIC:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.public\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case RETURN:\n-                        if (type == null) {\n-                          type = createJSTypeExpression(newNode(Token.QMARK));\n-                        }\n-\n-                        if (!jsdocBuilder.recordReturnType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                          break;\n-                        }\n-\n-                        // Find the return's description (if applicable).\n-                        if (jsdocBuilder.shouldParseDocumentation()) {\n-                          ExtractionInfo returnDescriptionInfo =\n-                              extractMultilineTextualBlock(token);\n-\n-                          String returnDescription =\n-                              returnDescriptionInfo.string;\n-\n-                          if (returnDescription.length() > 0) {\n-                            jsdocBuilder.recordReturnDescription(\n-                                returnDescription);\n-                          }\n-\n-                          token = returnDescriptionInfo.token;\n-                        } else {\n-                          token = eatTokensUntilEOL(token);\n-                        }\n-                        continue retry;\n-\n-                      case THIS:\n-                        if (!jsdocBuilder.recordThisType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-\n-                      case TYPEDEF:\n-                        if (!jsdocBuilder.recordTypedef(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-                    }\n-                  }\n-\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-              }\n-            }\n+            token = parseAnnotation(token, extendedTypes);\n+          } else {\n+            token = next();\n           }\n           break;\n \n             state = State.SEARCHING_ANNOTATION;\n           }\n           token = next();\n-          continue retry;\n+          break;\n \n         default:\n           if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n             token = next();\n-            continue retry;\n           } else {\n             state = State.SEARCHING_NEWLINE;\n             token = eatTokensUntilEOL();\n-            continue retry;\n-          }\n-      }\n-\n-      // next token\n-      token = next();\n-    }\n-  }\n+          }\n+          break;\n+      }\n+    }\n+  }\n+\n+  private JsDocToken parseAnnotation(JsDocToken token,\n+      List<ExtendedTypeInfo> extendedTypes) {\n+    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n+    JSTypeExpression type;\n+    int lineno = stream.getLineno();\n+    int charno = stream.getCharno();\n+\n+    String annotationName = stream.getString();\n+    Annotation annotation = annotationNames.get(annotationName);\n+    if (annotation == null) {\n+      parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n+          stream.getLineno(), stream.getCharno());\n+    } else {\n+      // Mark the beginning of the annotation.\n+      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n+\n+      switch (annotation) {\n+        case NG_INJECT:\n+          if (jsdocBuilder.isNgInjectRecorded()) {\n+            parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n+              stream.getLineno(), stream.getCharno());\n+          } else {\n+            jsdocBuilder.recordNgInject(true);\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case AUTHOR:\n+          if (jsdocBuilder.shouldParseDocumentation()) {\n+            ExtractionInfo authorInfo = extractSingleLineBlock();\n+            String author = authorInfo.string;\n+\n+            if (author.length() == 0) {\n+              parser.addParserWarning(\"msg.jsdoc.authormissing\",\n+                  stream.getLineno(), stream.getCharno());\n+            } else {\n+              jsdocBuilder.addAuthor(author);\n+            }\n+            token = authorInfo.token;\n+          } else {\n+            token = eatTokensUntilEOL(token);\n+          }\n+          return token;\n+\n+        case CONSISTENTIDGENERATOR:\n+          if (!jsdocBuilder.recordConsistentIdGenerator()) {\n+            parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n+              stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case STRUCT:\n+          if (!jsdocBuilder.recordStruct()) {\n+            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+                                  stream.getLineno(),\n+                                  stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case DICT:\n+          if (!jsdocBuilder.recordDict()) {\n+            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+                                  stream.getLineno(),\n+                                  stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case CONSTRUCTOR:\n+          if (!jsdocBuilder.recordConstructor()) {\n+            if (jsdocBuilder.isInterfaceRecorded()) {\n+              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n+                  stream.getLineno(), stream.getCharno());\n+            } else {\n+              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+                  stream.getLineno(), stream.getCharno());\n+            }\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case DEPRECATED:\n+          if (!jsdocBuilder.recordDeprecated()) {\n+            parser.addParserWarning(\"msg.jsdoc.deprecated\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n+          // Find the reason/description, if any.\n+          ExtractionInfo reasonInfo =\n+              extractMultilineTextualBlock(token);\n+\n+          String reason = reasonInfo.string;\n+\n+          if (reason.length() > 0) {\n+            jsdocBuilder.recordDeprecationReason(reason);\n+          }\n+\n+          token = reasonInfo.token;\n+          return token;\n+\n+        case INTERFACE:\n+          if (!jsdocBuilder.recordInterface()) {\n+            if (jsdocBuilder.isConstructorRecorded()) {\n+              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n+                  stream.getLineno(), stream.getCharno());\n+            } else {\n+              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+                  stream.getLineno(), stream.getCharno());\n+            }\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case DESC:\n+          if (jsdocBuilder.isDescriptionRecorded()) {\n+            parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n+                stream.getLineno(), stream.getCharno());\n+            return eatTokensUntilEOL();\n+          } else {\n+            ExtractionInfo descriptionInfo =\n+                extractMultilineTextualBlock(token);\n+\n+            String description = descriptionInfo.string;\n+\n+            jsdocBuilder.recordDescription(description);\n+            token = descriptionInfo.token;\n+            return token;\n+          }\n+\n+        case FILE_OVERVIEW:\n+          String fileOverview = \"\";\n+          if (jsdocBuilder.shouldParseDocumentation()) {\n+            ExtractionInfo fileOverviewInfo =\n+                extractMultilineTextualBlock(token,\n+                    WhitespaceOption.TRIM);\n+\n+            fileOverview = fileOverviewInfo.string;\n+\n+            token = fileOverviewInfo.token;\n+          } else {\n+            token = eatTokensUntilEOL(token);\n+          }\n+\n+          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n+            parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return token;\n+\n+        case LICENSE:\n+        case PRESERVE:\n+          ExtractionInfo preserveInfo =\n+              extractMultilineTextualBlock(token,\n+                                           WhitespaceOption.PRESERVE);\n+\n+          String preserve = preserveInfo.string;\n+\n+          if (preserve.length() > 0) {\n+            if (fileLevelJsDocBuilder != null) {\n+              fileLevelJsDocBuilder.append(preserve);\n+            }\n+          }\n+\n+          token = preserveInfo.token;\n+          return token;\n+\n+        case ENUM:\n+          token = next();\n+          lineno = stream.getLineno();\n+          charno = stream.getCharno();\n+\n+          type = null;\n+          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n+            type = createJSTypeExpression(\n+                parseAndRecordTypeNode(token));\n+          }\n+\n+          if (type == null) {\n+            type = createJSTypeExpression(newStringNode(\"number\"));\n+          }\n+          if (!jsdocBuilder.recordEnumParameterType(type)) {\n+            parser.addTypeWarning(\n+                \"msg.jsdoc.incompat.type\", lineno, charno);\n+          }\n+          token = eatTokensUntilEOL(token);\n+          return token;\n+\n+        case EXPORT:\n+          if (!jsdocBuilder.recordExport()) {\n+            parser.addParserWarning(\"msg.jsdoc.export\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case EXPOSE:\n+          if (!jsdocBuilder.recordExpose()) {\n+            parser.addParserWarning(\"msg.jsdoc.expose\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case EXTERNS:\n+          if (!jsdocBuilder.recordExterns()) {\n+            parser.addParserWarning(\"msg.jsdoc.externs\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case JAVA_DISPATCH:\n+          if (!jsdocBuilder.recordJavaDispatch()) {\n+            parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case EXTENDS:\n+        case IMPLEMENTS:\n+          skipEOLs();\n+          token = next();\n+          lineno = stream.getLineno();\n+          charno = stream.getCharno();\n+          boolean matchingRc = false;\n+\n+          if (token == JsDocToken.LC) {\n+            token = next();\n+            matchingRc = true;\n+          }\n+\n+          if (token == JsDocToken.STRING) {\n+            Node typeNode = parseAndRecordTypeNameNode(\n+                token, lineno, charno, matchingRc);\n+\n+            lineno = stream.getLineno();\n+            charno = stream.getCharno();\n+\n+            typeNode = wrapNode(Token.BANG, typeNode);\n+            type = createJSTypeExpression(typeNode);\n+\n+            if (annotation == Annotation.EXTENDS) {\n+              // record the extended type, check later\n+              extendedTypes.add(new ExtendedTypeInfo(\n+                  type, stream.getLineno(), stream.getCharno()));\n+            } else {\n+              Preconditions.checkState(\n+                  annotation == Annotation.IMPLEMENTS);\n+              if (!jsdocBuilder.recordImplementedInterface(type)) {\n+                parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n+                    lineno, charno);\n+              }\n+            }\n+            token = next();\n+            if (matchingRc) {\n+              if (token != JsDocToken.RC) {\n+                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n+                    stream.getLineno(), stream.getCharno());\n+              }\n+            } else if (token != JsDocToken.EOL &&\n+                token != JsDocToken.EOF && token != JsDocToken.EOC) {\n+              parser.addTypeWarning(\"msg.end.annotation.expected\",\n+                  stream.getLineno(), stream.getCharno());\n+            }\n+          } else {\n+            parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n+          }\n+          token = eatTokensUntilEOL(token);\n+          return token;\n+\n+        case HIDDEN:\n+          if (!jsdocBuilder.recordHiddenness()) {\n+            parser.addParserWarning(\"msg.jsdoc.hidden\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case LENDS:\n+          skipEOLs();\n+\n+          matchingRc = false;\n+          if (match(JsDocToken.LC)) {\n+            token = next();\n+            matchingRc = true;\n+          }\n+\n+          if (match(JsDocToken.STRING)) {\n+            token = next();\n+            if (!jsdocBuilder.recordLends(stream.getString())) {\n+              parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n+                  stream.getLineno(), stream.getCharno());\n+            }\n+          } else {\n+            parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n+          if (matchingRc && !match(JsDocToken.RC)) {\n+            parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case MEANING:\n+          ExtractionInfo meaningInfo =\n+              extractMultilineTextualBlock(token);\n+          String meaning = meaningInfo.string;\n+          token = meaningInfo.token;\n+          if (!jsdocBuilder.recordMeaning(meaning)) {\n+            parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return token;\n+\n+        case NO_ALIAS:\n+          if (!jsdocBuilder.recordNoAlias()) {\n+            parser.addParserWarning(\"msg.jsdoc.noalias\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case NO_COMPILE:\n+          if (!jsdocBuilder.recordNoCompile()) {\n+            parser.addParserWarning(\"msg.jsdoc.nocompile\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case NO_TYPE_CHECK:\n+          if (!jsdocBuilder.recordNoTypeCheck()) {\n+            parser.addParserWarning(\"msg.jsdoc.nocheck\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case NOT_IMPLEMENTED:\n+          return eatTokensUntilEOL();\n+\n+        case INHERIT_DOC:\n+        case OVERRIDE:\n+          if (!jsdocBuilder.recordOverride()) {\n+            parser.addTypeWarning(\"msg.jsdoc.override\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case THROWS:\n+          skipEOLs();\n+          token = next();\n+          lineno = stream.getLineno();\n+          charno = stream.getCharno();\n+          type = null;\n+\n+          if (token == JsDocToken.LC) {\n+            type = createJSTypeExpression(\n+                parseAndRecordTypeNode(token));\n+\n+            if (type == null) {\n+              // parsing error reported during recursive descent\n+              // recovering parsing\n+              return eatTokensUntilEOL();\n+            }\n+          }\n+\n+          // *Update* the token to that after the type annotation.\n+          token = current();\n+\n+          // Save the throw type.\n+          jsdocBuilder.recordThrowType(type);\n+\n+          // Find the throw's description (if applicable).\n+          if (jsdocBuilder.shouldParseDocumentation()) {\n+            ExtractionInfo descriptionInfo =\n+                extractMultilineTextualBlock(token);\n+\n+            String description = descriptionInfo.string;\n+\n+            if (description.length() > 0) {\n+              jsdocBuilder.recordThrowDescription(type, description);\n+            }\n+\n+            token = descriptionInfo.token;\n+          } else {\n+            token = eatTokensUntilEOL(token);\n+          }\n+          return token;\n+\n+        case PARAM:\n+          skipEOLs();\n+          token = next();\n+          lineno = stream.getLineno();\n+          charno = stream.getCharno();\n+          type = null;\n+\n+          if (token == JsDocToken.LC) {\n+            type = createJSTypeExpression(\n+                parseAndRecordParamTypeNode(token));\n+\n+            if (type == null) {\n+              // parsing error reported during recursive descent\n+              // recovering parsing\n+              return eatTokensUntilEOL();\n+            }\n+            skipEOLs();\n+            token = next();\n+            lineno = stream.getLineno();\n+            charno = stream.getCharno();\n+          }\n+\n+          String name = null;\n+          boolean isBracketedParam = JsDocToken.LB == token;\n+          if (isBracketedParam) {\n+            token = next();\n+          }\n+\n+          if (JsDocToken.STRING != token) {\n+            parser.addTypeWarning(\"msg.missing.variable.name\",\n+                lineno, charno);\n+          } else {\n+            name = stream.getString();\n+\n+            if (isBracketedParam) {\n+              token = next();\n+\n+              // Throw out JsDocToolkit's \"default\" parameter\n+              // annotation.  It makes no sense under our type\n+              // system.\n+              if (JsDocToken.EQUALS == token) {\n+                token = next();\n+                if (JsDocToken.STRING == token) {\n+                  token = next();\n+                }\n+              }\n+\n+              if (JsDocToken.RB != token) {\n+                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n+              } else if (type != null) {\n+                // Make the type expression optional, if it isn't\n+                // already.\n+                type = JSTypeExpression.makeOptionalArg(type);\n+              }\n+            }\n+\n+            // If the param name has a DOT in it, just throw it out\n+            // quietly. We do not handle the JsDocToolkit method\n+            // for handling properties of params.\n+            if (name.indexOf('.') > -1) {\n+              name = null;\n+            } else if (!jsdocBuilder.recordParameter(name, type)) {\n+              if (jsdocBuilder.hasParameter(name)) {\n+                parser.addTypeWarning(\"msg.dup.variable.name\", name,\n+                    lineno, charno);\n+              } else {\n+                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n+                    lineno, charno);\n+              }\n+            }\n+          }\n+\n+          if (name == null) {\n+            token = eatTokensUntilEOL(token);\n+            return token;\n+          }\n+\n+          jsdocBuilder.markName(name, sourceFile, lineno, charno);\n+\n+          // Find the parameter's description (if applicable).\n+          if (jsdocBuilder.shouldParseDocumentation()) {\n+            ExtractionInfo paramDescriptionInfo =\n+                extractMultilineTextualBlock(token);\n+\n+            String paramDescription = paramDescriptionInfo.string;\n+\n+            if (paramDescription.length() > 0) {\n+              jsdocBuilder.recordParameterDescription(name,\n+                  paramDescription);\n+            }\n+\n+            token = paramDescriptionInfo.token;\n+          } else {\n+            token = eatTokensUntilEOL(token);\n+          }\n+          return token;\n+\n+        case PRESERVE_TRY:\n+          if (!jsdocBuilder.recordPreserveTry()) {\n+            parser.addParserWarning(\"msg.jsdoc.preservertry\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case NO_SHADOW:\n+          if (!jsdocBuilder.recordNoShadow()) {\n+            parser.addParserWarning(\"msg.jsdoc.noshadow\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case NO_SIDE_EFFECTS:\n+          if (!jsdocBuilder.recordNoSideEffects()) {\n+            parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case MODIFIES:\n+          token = parseModifiesTag(next());\n+          return token;\n+\n+        case IMPLICIT_CAST:\n+          if (!jsdocBuilder.recordImplicitCast()) {\n+            parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case SEE:\n+          if (jsdocBuilder.shouldParseDocumentation()) {\n+            ExtractionInfo referenceInfo = extractSingleLineBlock();\n+            String reference = referenceInfo.string;\n+\n+            if (reference.length() == 0) {\n+              parser.addParserWarning(\"msg.jsdoc.seemissing\",\n+                  stream.getLineno(), stream.getCharno());\n+            } else {\n+              jsdocBuilder.addReference(reference);\n+            }\n+\n+            token = referenceInfo.token;\n+          } else {\n+            token = eatTokensUntilEOL(token);\n+          }\n+          return token;\n+\n+        case STABLEIDGENERATOR:\n+          if (!jsdocBuilder.recordStableIdGenerator()) {\n+            parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n+              stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case SUPPRESS:\n+          token = parseSuppressTag(next());\n+          return token;\n+\n+        case TEMPLATE: {\n+          ExtractionInfo templateInfo = extractSingleLineBlock();\n+          List<String> names = Lists.newArrayList(\n+              Splitter.on(',')\n+                  .trimResults()\n+                  .split(templateInfo.string));\n+\n+          if (names.size() == 0 || names.get(0).length() == 0) {\n+            parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n+                  stream.getLineno(), stream.getCharno());\n+          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n+            parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n+          token = templateInfo.token;\n+          return token;\n+        }\n+\n+        case CLASS_TEMPLATE: {\n+          ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n+          List<String> names = Lists.newArrayList(\n+              Splitter.on(',')\n+                  .trimResults()\n+                  .split(classTemplateInfo.string));\n+\n+          if (names.size() == 0 || names.get(0).length() == 0) {\n+            parser.addTypeWarning(\n+                \"msg.jsdoc.classtemplate.missing.type.name\",\n+                stream.getLineno(), stream.getCharno());\n+          } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n+            parser.addTypeWarning(\n+                \"msg.jsdoc.classtemplate.at.most.once\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n+          token = classTemplateInfo.token;\n+          return token;\n+        }\n+\n+        case IDGENERATOR:\n+          if (!jsdocBuilder.recordIdGenerator()) {\n+            parser.addParserWarning(\"msg.jsdoc.idgen\",\n+              stream.getLineno(), stream.getCharno());\n+          }\n+          return eatTokensUntilEOL();\n+\n+        case VERSION:\n+          ExtractionInfo versionInfo = extractSingleLineBlock();\n+          String version = versionInfo.string;\n+\n+          if (version.length() == 0) {\n+            parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n+                  stream.getLineno(), stream.getCharno());\n+          } else {\n+            if (!jsdocBuilder.recordVersion(version)) {\n+               parser.addParserWarning(\"msg.jsdoc.extraversion\",\n+                  stream.getLineno(), stream.getCharno());\n+            }\n+          }\n+\n+          token = versionInfo.token;\n+          return token;\n+\n+        case CONSTANT:\n+        case DEFINE:\n+        case RETURN:\n+        case PRIVATE:\n+        case PROTECTED:\n+        case PUBLIC:\n+        case THIS:\n+        case TYPE:\n+        case TYPEDEF:\n+          lineno = stream.getLineno();\n+          charno = stream.getCharno();\n+\n+          Node typeNode = null;\n+          boolean hasType = lookAheadForTypeAnnotation();\n+          boolean isAlternateTypeAnnotation =\n+              (annotation == Annotation.PRIVATE ||\n+               annotation == Annotation.PROTECTED ||\n+               annotation == Annotation.PUBLIC ||\n+               annotation == Annotation.CONSTANT);\n+          boolean canSkipTypeAnnotation =\n+              (isAlternateTypeAnnotation ||\n+               annotation == Annotation.RETURN);\n+          type = null;\n+          if (hasType || !canSkipTypeAnnotation) {\n+            skipEOLs();\n+            token = next();\n+            typeNode = parseAndRecordTypeNode(token);\n+\n+            if (annotation == Annotation.THIS) {\n+              typeNode = wrapNode(Token.BANG, typeNode);\n+            }\n+            type = createJSTypeExpression(typeNode);\n+          }\n+\n+          // The error was reported during recursive descent\n+          // recovering parsing\n+          boolean hasError = type == null && !canSkipTypeAnnotation;\n+          if (!hasError) {\n+            // Record types for @type.\n+            // If the @private, @protected, or @public annotations\n+            // have a type attached, pretend that they actually wrote:\n+            // @type {type}\\n@private\n+            // This will have some weird behavior in some cases\n+            // (for example, @private can now be used as a type-cast),\n+            // but should be mostly OK.\n+            if ((type != null && isAlternateTypeAnnotation)\n+                || annotation == Annotation.TYPE) {\n+              if (!jsdocBuilder.recordType(type)) {\n+                parser.addTypeWarning(\n+                    \"msg.jsdoc.incompat.type\", lineno, charno);\n+              }\n+            }\n+\n+            switch (annotation) {\n+              case CONSTANT:\n+                if (!jsdocBuilder.recordConstancy()) {\n+                  parser.addParserWarning(\"msg.jsdoc.const\",\n+                      stream.getLineno(), stream.getCharno());\n+                }\n+                break;\n+\n+              case DEFINE:\n+                if (!jsdocBuilder.recordDefineType(type)) {\n+                  parser.addParserWarning(\"msg.jsdoc.define\",\n+                      lineno, charno);\n+                }\n+                break;\n+\n+              case PRIVATE:\n+                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n+                  parser.addParserWarning(\n+                      \"msg.jsdoc.visibility.private\",\n+                      lineno, charno);\n+                }\n+                break;\n+\n+              case PROTECTED:\n+                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n+                  parser.addParserWarning(\n+                      \"msg.jsdoc.visibility.protected\",\n+                      lineno, charno);\n+                }\n+                break;\n+\n+              case PUBLIC:\n+                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n+                  parser.addParserWarning(\n+                      \"msg.jsdoc.visibility.public\",\n+                      lineno, charno);\n+                }\n+                break;\n+\n+              case RETURN:\n+                if (type == null) {\n+                  type = createJSTypeExpression(newNode(Token.QMARK));\n+                }\n+\n+                if (!jsdocBuilder.recordReturnType(type)) {\n+                  parser.addTypeWarning(\n+                      \"msg.jsdoc.incompat.type\", lineno, charno);\n+                  break;\n+                }\n+\n+                // Find the return's description (if applicable).\n+                if (jsdocBuilder.shouldParseDocumentation()) {\n+                  ExtractionInfo returnDescriptionInfo =\n+                      extractMultilineTextualBlock(token);\n+\n+                  String returnDescription =\n+                      returnDescriptionInfo.string;\n+\n+                  if (returnDescription.length() > 0) {\n+                    jsdocBuilder.recordReturnDescription(\n+                        returnDescription);\n+                  }\n+\n+                  token = returnDescriptionInfo.token;\n+                } else {\n+                  token = eatTokensUntilEOL(token);\n+                }\n+                return token;\n+\n+              case THIS:\n+                if (!jsdocBuilder.recordThisType(type)) {\n+                  parser.addTypeWarning(\n+                      \"msg.jsdoc.incompat.type\", lineno, charno);\n+                }\n+                break;\n+\n+              case TYPEDEF:\n+                if (!jsdocBuilder.recordTypedef(type)) {\n+                  parser.addTypeWarning(\n+                      \"msg.jsdoc.incompat.type\", lineno, charno);\n+                }\n+                break;\n+            }\n+          }\n+\n+          return eatTokensUntilEOL();\n+      }\n+    }\n+    return next();\n+  };\n \n   private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n     for (ExtendedTypeInfo typeInfo : extendedTypes) {", "timestamp": 1361486262, "metainfo": ""}