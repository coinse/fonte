{"sha": "bc53a66311b9b22e471dd74860c7df75eebe9837", "log": "Initial submission   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/BasicVariables.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * A basic implementation of the Variables interface that uses a HashMap.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class BasicVariables implements Variables {\n+\n+    private HashMap vars = new HashMap();\n+\n+    /**\n+     * Returns true if the variable has been defined, even if the\n+     * value of the variable is null.\n+     */\n+    public boolean isDeclaredVariable(String varName){\n+        return vars.containsKey(varName);\n+    }\n+\n+    /**\n+     * Returns the value of the variable if it is defined,\n+     * otherwise, throws IllegalArgumentException\n+     */\n+    public Object getVariable(String varName){\n+        // Note that a variable may be defined with a null value\n+\n+        if (vars.containsKey(varName)){\n+            return vars.get(varName);\n+        }\n+\n+        throw new IllegalArgumentException(\"No such variable: '\" + varName + \"'\");\n+    }\n+\n+    /**\n+     * Defines a new variable with the specified value or modifies\n+     * the value of an existing variable.\n+     */\n+    public void declareVariable(String varName, Object value){\n+        vars.put(varName, value);\n+    }\n+\n+    public String toString(){\n+        return vars.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.functions.*;\n+\n+/**\n+ * Extension functions provided by a Java class.\n+ *\n+ * Let's say, we declared a ClassFunction like this:\n+ * <blockquote><pre>\n+ *     new ClassFunctions(Integer.class, \"int\")\n+ * </pre></blockquote>\n+ *\n+ * We can now use XPaths like:\n+ * <dl>\n+ *  <dt><code>\"int:new(3)\"</code></dt>\n+ *  <dd>Equivalent to <code>new Integer(3)</code></dd>\n+ *  <dt><code>\"int:getInteger('foo')\"</code></dt>\n+ *  <dd>Equivalent to <code>Integer.getInteger(\"foo\")</code></dd>\n+ *  <dt><code>\"int:floatValue(int:new(4))\"</code></dt>\n+ *  <dd>Equivalent to <code>new Integer(4).floatValue()</code></dd>\n+ * </dl>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class ClassFunctions implements Functions {\n+    private Class functionClass;\n+    private String namespace;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public ClassFunctions(Class functionClass, String namespace){\n+        this.functionClass = functionClass;\n+        this.namespace = namespace;\n+    }\n+\n+    public Set getUsedNamespaces(){\n+        return Collections.singleton(namespace);\n+    }\n+\n+    /**\n+     * Returns a Function, if any, for the specified namespace,\n+     * name and parameter types.\n+     */\n+    public Function getFunction(String namespace, String name, Object[] parameters){\n+        if (!namespace.equals(this.namespace)){\n+            return null;\n+        }\n+\n+        if (parameters == null){\n+            parameters = EMPTY_ARRAY;\n+        }\n+\n+        if (name.equals(\"new\")){\n+            Constructor constructor = Types.lookupConstructor(functionClass, parameters);\n+            if (constructor != null){\n+                return new ConstructorFunction(constructor);\n+            }\n+        }\n+        else {\n+            Method method = Types.lookupStaticMethod(functionClass, name, parameters);\n+            if (method != null){\n+                return new MethodFunction(method);\n+            }\n+\n+            method = Types.lookupMethod(functionClass, name, parameters);\n+            if (method != null){\n+                return new MethodFunction(method);\n+            }\n+        }\n+\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+/**\n+ * A generic mechanism for accessing collections of name/value pairs.\n+ * Examples of such collections are HashMap, Properties,\n+ * ServletContext.  In order to add support for a new such collection\n+ * type to JXPath, perform the following two steps:\n+ * <ol>\n+ * <li>Build an implementation of the DynamicPropertyHandler interface\n+ * for the desired collection type.</li>\n+ * <li>Invoke static method {@link JXPathIntrospector#registerDynamicClass\n+ * JXPathIntrospector.registerDynamicClass(class, handlerClass)}</li>\n+ * </ol>\n+ * JXPath allows access to dynamic properties using these three formats:\n+ * <ul>\n+ * <li><code>\"myMap/myKey\"</code></li>\n+ * <li><code>\"myMap[@name = 'myKey']\"</code></li>\n+ * <li><code>\"myMap[name(.) = 'myKey']\"</code></li>\n+ * </ul>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface DynamicPropertyHandler {\n+\n+    /**\n+     * Returns a list of dynamic property names for the supplied object.\n+     */\n+    String[] getPropertyNames(Object object);\n+\n+    /**\n+     * Returns the value of the specified dynamic property.\n+     */\n+    Object getProperty(Object object, String propertyName);\n+\n+    /**\n+     * Modifies the value of the specified dynamic property.\n+     */\n+    void setProperty(Object object, String propertyName, Object value);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ExpressionContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ExpressionContext.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import org.w3c.dom.Node;\n+import java.util.*;\n+\n+/**\n+ * If an extenstion function has an argument of type ExpressionContext,\n+ * it can gain access to the current node or all nodes of\n+ * an XPath expression context.\n+ * <p>\n+ * Example:\n+ * <blockquote><pre>\n+ * public class MyExtenstionFunctions {\n+ *    public static String objectType(ExpressionContext context){\n+ *       Object value = context.getContextNodePointer().getValue();\n+ *       if (value == null){\n+ *           return \"null\";\n+ *       }\n+ *       return value.getClass();\n+ *    }\n+ * }\n+ * </pre></blockquote>\n+ *\n+ * You can then register this extension function using a {@link ClassFunctions\n+ * ClassFunctions} object and call it like this:\n+ * <blockquote><pre>\n+ *   \"/descendent-or-self::node()[ns:objectType(.) = 'java.util.Date']\"\n+ * </pre></blockquote>\n+ * This expression will find all nodes of the graph that are dates.\n+ */\n+public interface ExpressionContext\n+{\n+    /**\n+     * Get the current context node.\n+     *\n+     * @return The current context node pointer.\n+     */\n+    public Pointer getContextNodePointer();\n+\n+    /**\n+     * Get the current context node list.  Each element of the list is\n+     * a Pointer.\n+     *\n+     * @return A list representing the current context nodes.\n+     */\n+    public List getContextNodeList();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Function.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * Extension function interface. Extension functions are grouped into\n+ * {@link Functions Functions} objects, which are installed on\n+ * JXPathContexts using the {@link JXPathContext#setFunctions JXPathContext.setFunctions()}\n+ * call.\n+ * <p>\n+ * The Function interface can be implemented directly. However,\n+ * most of the time JXPath's built-in implementations should suffice.\n+ * See {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface Function {\n+\n+    /**\n+     * Computes the value of the function. Each implementation of Function\n+     * is responsible for conversion of supplied parameters to the required\n+     * argument types.\n+     */\n+    Object invoke(Object[] parameters);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/FunctionLibrary.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * An object that aggregates Functions objects into a group Functions object.\n+ * Since JXPathContext can only register a single Functions object,\n+ * FunctionLibrary should always be used to group all Functions objects\n+ * that need to be registered.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class FunctionLibrary implements Functions {\n+    private List allFunctions = new ArrayList();\n+    private HashMap byNamespace = null;\n+\n+    /**\n+     * Add functions to the library\n+     */\n+    public void addFunctions(Functions functions){\n+        allFunctions.add(functions);\n+        byNamespace = null;\n+    }\n+\n+    /**\n+     * Remove functions from the library.\n+     */\n+    public void removeFunctions(Functions functions){\n+        allFunctions.remove(functions);\n+        byNamespace = null;\n+    }\n+\n+    /**\n+     * Returns a set containing all namespaces used by the aggregated\n+     * Functions.\n+     */\n+    public Set getUsedNamespaces(){\n+        if (byNamespace == null){\n+            prepareCache();\n+        }\n+        return byNamespace.keySet();\n+    }\n+\n+    /**\n+     * Returns a Function, if any, for the specified namespace,\n+     * name and parameter types.\n+     */\n+    public Function getFunction(String namespace, String name, Object[] parameters){\n+        if (byNamespace == null){\n+            prepareCache();\n+        }\n+        Object candidates = byNamespace.get(namespace);\n+        if (candidates instanceof Functions){\n+            return ((Functions)candidates).getFunction(namespace, name, parameters);\n+        }\n+        else if (candidates instanceof List){\n+            List list = (List)candidates;\n+            int count = list.size();\n+            for (int i = 0; i < count; i++){\n+                Function function = ((Functions)list.get(i)).getFunction(namespace, name, parameters);\n+                if (function != null){\n+                    return function;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private void prepareCache(){\n+        byNamespace = new HashMap();\n+        int count = allFunctions.size();\n+        for (int i = 0; i < count; i++){\n+            Functions funcs = (Functions)allFunctions.get(i);\n+            Set namespaces = funcs.getUsedNamespaces();\n+            for (Iterator it = namespaces.iterator(); it.hasNext();){\n+                String ns = (String)it.next();\n+                Object candidates = byNamespace.get(ns);\n+                if (candidates == null){\n+                    byNamespace.put(ns, funcs);\n+                }\n+                else if (candidates instanceof Functions){\n+                    List lst = new ArrayList();\n+                    lst.add(candidates);\n+                    lst.add(funcs);\n+                    byNamespace.put(ns, lst);\n+                }\n+                else {\n+                    ((List)candidates).add(funcs);\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/Functions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Functions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * A group of Function objects sharing a common namespace. Use classes\n+ * {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}\n+ * to register extension functions implemented as Java methods.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface Functions {\n+\n+    /**\n+     * Returns all namespaces in which this function collection defines\n+     * functions.\n+     */\n+    Set getUsedNamespaces();\n+\n+    /**\n+     * Returns a Function, if any, for the specified namespace,\n+     * name and parameter types.\n+     */\n+    Function getFunction(String namespace, String name, Object[] parameters);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPath.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Attic/JXPath.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.List;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * This class defines convenience methods for XPath traversal. Each method\n+ * creates a temporary {@link JXPathContext JXPathContext} and forwards the\n+ * request to it. Use JXPathContext APIs instead of JXPath APIs if any of\n+ * the following requirements exist:\n+ * <ul>\n+ * <li>There is a need to evaluate multiple XPaths over the same object graph.\n+ * JXPathContext is optimized for that.\n+ * <li>There is a need for the support of variables.  JXPathContext has a method\n+ * that allows registering of a pool of variables.\n+ * <li>There is a need to use extension functions other than\n+ * Java method calls using the default syntax (see {@link PackageFunctions\n+ * PackageFunctions}\n+ * </ul>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public final class JXPath {\n+\n+    /**\n+     * Traverses the xpath and returns the resulting object. Primitive\n+     * types are wrapped into objects.\n+     */\n+    public static Object getValue(Object bean, String xpath){\n+        return JXPathContext.newContext(bean).getValue(xpath);\n+    }\n+\n+    /**\n+     * Modifies the value of the property described by the supplied xpath.\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>The xpath does not in fact describe an existing property\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    public static void setValue(Object bean, String xpath, Object value){\n+        JXPathContext.newContext(bean).setValue(xpath, value);\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns a List of objects. Even if\n+     * there is only one object that matches the xpath, it will be returned\n+     * as a collection with one element.  If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public static List eval(Object bean, String xpath){\n+        return JXPathContext.newContext(bean).eval(xpath);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import org.w3c.dom.*;\n+import java.beans.*;\n+import java.util.*;\n+\n+/**\n+ * An implementation of JXPathBeanInfo based on JavaBeans' BeanInfo. Properties\n+ * advertised by JXPathBasicBeanInfo are the same as those advertised by\n+ * BeanInfo for the corresponding class.\n+ *\n+ * See java.beans.BeanInfo, java.beans.Introspector\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n+    private boolean atomic = false;\n+    private Class clazz;\n+    private PropertyDescriptor propertyDescriptors[];\n+    private Class dynamicPropertyHandlerClass;\n+\n+    public JXPathBasicBeanInfo(Class clazz){\n+        this.clazz = clazz;\n+    }\n+\n+    public JXPathBasicBeanInfo(Class clazz, boolean atomic){\n+        this.clazz = clazz;\n+        this.atomic = atomic;\n+    }\n+\n+    public JXPathBasicBeanInfo(Class clazz, Class dynamicPropertyHandlerClass){\n+        this.clazz = clazz;\n+        this.atomic = false;\n+        this.dynamicPropertyHandlerClass = dynamicPropertyHandlerClass;\n+    }\n+\n+    /**\n+     * Returns true if objects of this class are treated as atomic\n+     * objects which have no properties of their own.\n+     */\n+    public boolean isAtomic(){\n+        return atomic;\n+    }\n+\n+    /**\n+     * Return true if the corresponding objects have dynamic properties.\n+     */\n+    public boolean isDynamic() {\n+        return dynamicPropertyHandlerClass != null;\n+    }\n+\n+    public PropertyDescriptor[] getPropertyDescriptors() {\n+        if (propertyDescriptors == null){\n+            try {\n+                BeanInfo bi = null;\n+                if (clazz.isInterface()){\n+                    bi = Introspector.getBeanInfo(clazz);\n+                }\n+                else {\n+                    bi = Introspector.getBeanInfo(clazz, Object.class);\n+                }\n+                PropertyDescriptor[] pds = bi.getPropertyDescriptors();\n+                propertyDescriptors = new PropertyDescriptor[pds.length];\n+                System.arraycopy(pds, 0, propertyDescriptors, 0, pds.length);\n+                Arrays.sort(propertyDescriptors, new Comparator(){\n+                    public int compare(Object left, Object right){\n+                        return ((PropertyDescriptor)left).getName().\n+                            compareTo(((PropertyDescriptor)right).getName());\n+                    }\n+                });\n+            }\n+            catch (IntrospectionException ex){\n+                ex.printStackTrace();\n+            }\n+        }\n+        return propertyDescriptors;\n+    }\n+\n+    /**\n+     * For a dynamic class, returns the corresponding DynamicPropertyHandler class.\n+     */\n+    public Class getDynamicPropertyHandlerClass() {\n+        return dynamicPropertyHandlerClass;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"BeanInfo [class = \");\n+        buffer.append(clazz.getName());\n+        buffer.append(\", properties = \");\n+        PropertyDescriptor[] jpds = getPropertyDescriptors();\n+        for (int i = 0; i < jpds.length; i++){\n+            buffer.append(\"\\n    \");\n+            buffer.append(jpds[i].getPropertyType());\n+            buffer.append(\": \");\n+            buffer.append(jpds[i].getName());\n+        }\n+        buffer.append(\"]\");\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * JXPathBeanInfo is similar to java.beans.BeanInfo in that it describes properties\n+ * of a JavaBean class.  By default, JXPathBeanInfo classes are automatically\n+ * generated by {@link JXPathIntrospector JXPathIntrospector} based on the java.beans.BeanInfo.\n+ * As with JavaBeans, the user can supply an alternative\n+ * implementation of JXPathBeanInfo for a custom class.  The alternative implementation\n+ * is located by class name, which is the same as the name of the class it represents\n+ * with the suffix \"XBeanInfo\".  So, for example, if you need to provide an\n+ * alternative JXPathBeanInfo class for class \"com.foo.Bar\", write a class\n+ * \"com.foo.BarXBeanInfo\" and make it implement the JXPathBeanInfo interface.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface JXPathBeanInfo  {\n+\n+    /**\n+     * Returns true if objects of this class are treated as atomic\n+     * objects which have no properties of their own.\n+     * For example, java.lang.String and java.lang.Number are atomic.\n+     */\n+    boolean isAtomic();\n+\n+    /**\n+     * Returns true if the objects of this class have dynamic properties\n+     * (e.g. java.util.Map). If this method returns true, getPropertyDescriptors\n+     * should return null and getDynamicPropertyHandlerClass should return\n+     * a valid class name.  An object cannot have both static and dynamic\n+     * properties at the same time.\n+     */\n+    boolean isDynamic();\n+\n+    /**\n+     * Returns a list of property descriptors for the beans described by this\n+     * bean info object.  Returns null for atomic beans.\n+     */\n+    PropertyDescriptor[] getPropertyDescriptors();\n+\n+    /**\n+     * For dynamic objects, returns the class implementing\n+     * the DynamicPropertyHandler interface. That class can\n+     * be used to access dynamic properties.\n+     */\n+    Class getDynamicPropertyHandlerClass();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.List;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * JXPathContext provides APIs for the traversal of graphs of JavaBeans using\n+ * the XPath syntax.\n+ * Using JXPathContext, you can read and write properties of JavaBeans, arrays, collections\n+ * and maps. JXPathContext uses JavaBeans introspection to enumerate and access JavaBeans\n+ * properties.\n+ * <p>\n+ * JXPathContext allows alternative implementations. This is why instead of\n+ * allocating JXPathContext directly, you should call a static <code>newContext</code>\n+ * method.  This method will utilize the JXPathContextFactory API to locate\n+ * a suitable implementation of JXPath.\n+ * JXPath comes bundled with a default implementation called Reference Implementation.\n+ * </p>\n+ *\n+ * <h2>JXPath Interprets XPath Syntax on Java Object Graphs</h2>\n+ *\n+ * JXPath uses an intuitive interpretation of the xpath syntax in the context\n+ * of Java object graphs. Here are some examples:\n+ *\n+ * <h3>Example 1: JavaBean Property Access</h3>\n+ *\n+ * JXPath can be used to access properties of a JavaBean.\n+ *\n+ * <pre><blockquote>\n+ * public class Employee {\n+ *    public String getFirstName(){\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Employee emp = new Employee();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(emp);\n+ * String fName = (String)context.getValue(\"firstName\");\n+ * </blockquote></pre>\n+ *\n+ * In this example, we are using JXPath to access a property of the <code>emp</code> bean.\n+ * In this simple case the invocation of JXPath is equivalent to invocation of getFirstName()\n+ * on the bean.\n+ *\n+ * <h3>Example 2: Nested Bean Property Access</h3>\n+ * JXPath can traverse object graphs:\n+ *\n+ * <pre><blockquote>\n+ * public class Employee {\n+ *    public Address getHomeAddress(){\n+ *       ...\n+ *    }\n+ * }\n+ * public class Address {\n+ *    public String getStreetNumber(){\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Employee emp = new Employee();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(emp);\n+ * String sNumber = (String)context.getValue(\"homeAddress/streetNumber\");\n+ * </blockquote></pre>\n+ *\n+ * In this case XPath is used to access a property of a nested bean.\n+ * <p>\n+ * A property identified by the xpath does not have to be a \"leaf\" property.\n+ * For instance, we can extract the whole Address object in above example:\n+ *\n+ * <pre><blockquote>\n+ *    Address addr = (Address)context.getValue(\"homeAddress\");\n+ * </blockquote></pre>\n+ * </p>\n+ *\n+ * <h3>Example 3: Collection Subscripts</h3>\n+ * JXPath can extract elements from arrays and collections.\n+ *\n+ * <pre><blockquote>\n+ * public class Integers {\n+ *    public int[] getNumbers(){\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Integers ints = new Integers();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(ints);\n+ * Integer thirdInt = (Integer)context.getValue(\"numbers[3]\");\n+ * </blockquote></pre>\n+ * A collection can be an arbitrary array or an instance of java.util.Collection.\n+ * <p>\n+ * Note: in XPath the first element of a collection has index 1, not 0.<br>\n+ * Note: The root node of the context can be a collection too. If you want\n+ * to follow the standard XPath syntax then instead of using the \".[3]\" syntax\n+ * you should use \"self::node()[3]\".\n+ *\n+ * <h3>Example 4: Map Element Access</h3>\n+ *\n+ * JXPath supports maps. To get a value use its key.\n+ *\n+ * <pre><blockquote>\n+ * public class Employee {\n+ *    public Map getAddresses(){\n+ *       return addressMap;\n+ *    }\n+ *\n+ *    public void addAddress(String key, Address address){\n+ *       addressMap.put(key, address);\n+ *    }\n+ *    ...\n+ * }\n+ *\n+ * Employee emp = new Employee();\n+ * emp.addAddress(\"home\", new Address(...));\n+ * emp.addAddress(\"office\", new Address(...));\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(emp);\n+ * String homeZipCode = (String)context.getValue(\"addresses/home/zipCode\");\n+ * </blockquote></pre>\n+ *\n+ * Often you will need to use the alternative syntax for accessing Map\n+ * elements:\n+ *\n+ * <pre><blockquote>\n+ * String homeZipCode = (String)context.getValue(\"addresses[@name='home']/zipCode\");\n+ * </blockquote></pre>\n+ *\n+ * In this case, the key can be an expression, e.g. a variable.<br>\n+ *\n+ * Note: At this point JXPath only supports Maps that use strings for keys.<br>\n+ * Note: JXPath supports the extended notion of Map: any object with\n+ *       dynamic properties can be handled by JXPath provided that its\n+ *       class is registered with the {@link JXPathIntrospector}.\n+ *\n+ * <h3>Example 5: Retrieving Multiple Results</h3>\n+ *\n+ * JXPath can retrieve multiple objects from a graph. Note that the method\n+ * called in this case is not <code>getValue</code>, but <code>eval</code>.\n+ *\n+ * <pre><blockquote>\n+ * public class Author {\n+ *    public Book[] getBooks(){\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Author auth = new Author();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(auth);\n+ * List threeBooks = (List)context.eval(\"books[position() < 4]\");\n+ * </blockquote></pre>\n+ *\n+ * This returns a list of at most three books from the array of all books\n+ * written by the author.\n+ *\n+ * <h3>Example 6: Setting Properties</h3>\n+ * JXPath can be used to modify property values.\n+ *\n+ * <pre><blockquote>\n+ * public class Employee {\n+ *    public Address getAddress() {\n+ *       ...\n+ *    }\n+ *\n+ *    public void setAddress(Address address) {\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Employee emp = new Employee();\n+ * Address addr = new Address();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(emp);\n+ * context.setValue(\"address\", addr);\n+ * context.setValue(\"address/zipCode\", \"90190\");\n+ *\n+ * </blockquote></pre>\n+ *\n+ * <h3>Example 7: Using Variables</h3>\n+ * JXPath supports the notion of variables. The XPath syntax for accessing\n+ * variables is <i>\"$varName\"</i>.\n+ *\n+ * <pre><blockquote>\n+ * public class Author {\n+ *    public Book[] getBooks(){\n+ *       ...\n+ *    }\n+ * }\n+ *\n+ * Author auth = new Author();\n+ * ...\n+ *\n+ * JXPathContext context = JXPathContext.newContext(auth);\n+ * context.getVariables().declareVariable(\"index\", new Integer(2));\n+ *\n+ * Book secondBook = (Book)context.getValue(\"books[$index]\");\n+ * </blockquote></pre>\n+ *\n+ * You can also set variables using JXPath:\n+ *\n+ * <pre><blockquote>\n+ * context.setValue(\"$index\", new Integer(3));\n+ * </blockquote></pre>\n+ *\n+ * Note: you can only <i>change</i> the value of an existing variable this\n+ * way, you cannot <i>define</i> a new variable.\n+ *\n+ * <p>\n+ * When a variable contains a JavaBean or a collection, you can\n+ * traverse the bean or collection as well:\n+ * <pre><blockquote>\n+ * ...\n+ * context.getVariables().declareVariable(\"book\", myBook);\n+ * String title = (String)context.getValue(\"$book/title);\n+ *\n+ * Book array[] = new Book[]{...};\n+ *\n+ * context.getVariables().declareVariable(\"books\", array);\n+ *\n+ * String title = (String)context.getValue(\"$books[2]/title);\n+ * </blockquote></pre>\n+ *\n+ * <h3>Example 8: Using Nested Contexts</h3>\n+ * If you need to use the same set of variable while interpreting\n+ * XPaths with different beans, it makes sense to put the variables in a separate\n+ * context and specify that context as a parent context every time you\n+ * allocate a new JXPathContext for a JavaBean.\n+ *\n+ * <pre><blockquote>\n+ * JXPathContext varContext = JXPathContext.newContext(null);\n+ * varContext.getVariables().declareVariable(\"title\", \"Java\");\n+ *\n+ * JXPathContext context = JXPathContext.newContext(varContext, auth);\n+ *\n+ * List javaBooks = (List)context.eval(\"books[title = $title]\");\n+ * </blockquote></pre>\n+ *\n+ * <h3>Using Custom Variable Pools</h3>\n+ * By default, JXPathContext creates a HashMap of variables. However,\n+ * you can substitute a custom implementation of the Variables\n+ * interface to make JXPath work with an alternative source of variables.\n+ * For example, you can define implementations of Variables that\n+ * cover a servlet context, HTTP request or any similar structure.\n+ *\n+ * <h3>Example 10: Using Standard Extension Functions</h3>\n+ * Using the standard extension functions, you can call methods on objects,\n+ * static methods on classes and create objects using any constructor.\n+ * The class names should be fully qualified.\n+ * <p>\n+ * Here's how you can create new objects:\n+ * <pre><blockquote>\n+ * Book book = (Book)context.getValue(\"org.apache.commons.jxpath.example.Book.new('John Updike')\");\n+ * </blockquote></pre>\n+ *\n+ * Here's how you can call static methods:\n+ * <pre><blockquote>\n+ * Book book = (Book)context.getValue(\"org.apache.commons.jxpath.example.Book.getBestBook('John Updike')\");\n+ * </blockquote></pre>\n+ *\n+ * Here's how you can call regular methods:\n+ * <pre><blockquote>\n+ * String firstName = (String)context.getValue(\"getAuthorsFirstName($book)\");\n+ * </blockquote></pre>\n+ * As you can see, the target of the method is specified as the first parameter\n+ * of the function.\n+ *\n+ * <h3>Example 10: Using Custom Extension Functions</h3>\n+ * Collections of custom extension functions can be implemented\n+ * as {@link Functions Functions} objects or as Java classes, whose methods\n+ * become extenstion functions.\n+ * <p>\n+ * Let's say the following class implements various formatting operations:\n+ * <pre><blockquote>\n+ * public class Formats {\n+ *    public static String date(Date d, String pattern){\n+ *        return new SimpleDateFormat(pattern).format(d);\n+ *    }\n+ *    ...\n+ * }\n+ * </blockquote></pre>\n+ *\n+ * We can register this class with a JXPathContext:\n+ *\n+ * <pre><blockquote>\n+ * context.setFunctions(new ClassFunctions(Formats.class, \"format\"));\n+ * ...\n+ *\n+ * context.getVariables().declareVariable(\"today\", new Date());\n+ * String today = (String)context.getValue(\"format:date($today, 'MM/dd/yyyy')\");\n+ *\n+ * </blockquote></pre>\n+ * You can also register whole packages of Java classes using PackageFunctions.\n+ * <p>\n+ * Also, see {@link FunctionLibrary FunctionLibrary}, which is a class\n+ * that allows you to register multiple sets of extension functions with\n+ * the same JXPathContext.\n+ *\n+ * <h2>Configuring JXPath</h2>\n+ *\n+ * JXPath uses JavaBeans introspection to discover properties of JavaBeans.\n+ * You can provide alternative property lists by supplying\n+ * custom JXPathBeanInfo classes (see {@link JXPathBeanInfo JXPathBeanInfo}).\n+ *\n+ * <h2>Notes</h2>\n+ * <ul>\n+ * <li>The current version of JXPath does not support DOM attributes. Even though XPaths\n+ *     like \"para[@type='warning']\" are legitimate, they will always produce empty results.\n+ *     This may change in future versions of XPath: the related trade-offs are currently\n+ *     being evaluated.\n+ * <li>The current version of JXPath does not support the <code>id(string)</code>\n+ *     and <code>key(key, value)</code> XPath functions.\n+ * </ul>\n+ *\n+ * See <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public abstract class JXPathContext {\n+    protected JXPathContext parentContext;\n+    protected Object contextBean;\n+    protected Variables vars;\n+    protected Functions functions;\n+\n+    /**\n+     * Creates a new JXPathContext with the specified bean as the root node.\n+     */\n+    public static JXPathContext newContext(Object contextBean){\n+        return JXPathContextFactory.newInstance().newContext(null, contextBean);\n+    }\n+\n+    /**\n+     * Creates a new JXPathContext with the specified bean as the root node and the\n+     * specified parent context. Variables defined in a parent context can be\n+     * referenced in XPaths passed to the child context.\n+     */\n+    public static JXPathContext newContext(JXPathContext parentContext, Object contextBean){\n+        return JXPathContextFactory.newInstance().newContext(parentContext, contextBean);\n+    }\n+\n+    /**\n+     * This constructor should remain protected - it is to be overridden by subclasses,\n+     * but never explicitly invoked by clients.\n+     */\n+    protected JXPathContext(JXPathContext parentContext, Object contextBean){\n+        this.parentContext = parentContext;\n+        this.contextBean = contextBean;\n+    }\n+\n+    /**\n+     * Returns the parent context of this context or null.\n+     */\n+    public JXPathContext getParentContext(){\n+        return parentContext;\n+    }\n+\n+    /**\n+     * Returns the JavaBean associated with this context.\n+     */\n+    public Object getContextBean(){\n+        return contextBean;\n+    }\n+\n+    public void setVariables(Variables vars){\n+        this.vars = vars;\n+    }\n+\n+    /**\n+     * Returns the variable pool associated with the context. If no such\n+     * pool was specified during the construction of the context,\n+     * returns the default implementation of Variables, {@link BasicVariables BasicVariables}.\n+     */\n+    public Variables getVariables(){\n+        if (vars == null){\n+            vars = new BasicVariables();\n+        }\n+        return vars;\n+    }\n+\n+    public void setFunctions(Functions functions){\n+        this.functions = functions;\n+    }\n+\n+    public Functions getFunctions(){\n+        // TBD: default lib\n+        return functions;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns the resulting object. Primitive\n+     * types are wrapped into objects.\n+     */\n+    public abstract Object getValue(String xpath);\n+\n+    /**\n+     * Modifies the value of the property described by the supplied xpath.\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>The xpath does not in fact describe an existing property\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    public abstract void setValue(String xpath, Object value);\n+\n+    /**\n+     * Traverses the xpath and returns a List of objects. Even if\n+     * there is only one object that matches the xpath, it will be returned\n+     * as a collection with one element.  If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public abstract List eval(String xpath);\n+\n+    /**\n+     * Traverses the xpath and returns a Pointer.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public abstract Pointer locateValue(String xpath);\n+\n+    /**\n+     * Traverses the xpath and returns a List of Pointers.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public abstract List locate(String xpath);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactory.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import java.io.*;\n+import javax.xml.transform.TransformerFactory;\n+\n+/**\n+ * Defines a factory API that enables applications to obtain a\n+ * JXPathContext instance.  To acquire a JXPathContext, first call the\n+ * static <code>newInstance()</code> method of JXPathContextFactory.\n+ * This method returns a concrete JXPathContextFactory.\n+ * Then call <code>newContext()</code> on that instance.  You will rarely\n+ * need to perform these steps explicitly: usually you can call one of the\n+ * <code>JXPathContex.newContext</code> methods, which will perform these steps\n+ * for you.\n+ *\n+ * @see JXPathContext#newContext(Object)\n+ * @see JXPathContext#newContext(JXPathContext,Object)\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public abstract class JXPathContextFactory {\n+\n+    /** The default property */\n+    public static final String FACTORY_NAME_PROPERTY =\n+        \"org.apache.commons.jxpath.JXPathContextFactory\";\n+\n+    /** The default factory class */\n+    private static final String defaultClassName =\n+        \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\";\n+\n+    protected JXPathContextFactory () {\n+\n+    }\n+\n+    /**\n+     * Obtain a new instance of a <code>JXPathContextFactory</code>.\n+     * This static method creates a new factory instance.\n+     * This method uses the following ordered lookup procedure to determine\n+     * the <code>JXPathContextFactory</code> implementation class to load:\n+     * <ul>\n+     * <li>\n+     * Use the <code>org.apache.commons.jxpath.JXPathContextFactory</code> system\n+     * property.\n+     * </li>\n+     * <li>\n+     * Alternatively, use the JAVA_HOME (the parent directory where jdk is\n+     * installed)/lib/jxpath.properties for a property file that contains the\n+     * name of the implementation class keyed on\n+     * <code>org.apache.commons.jxpath.JXPathContextFactory</code>.\n+     * </li>\n+     * <li>\n+     * Use the Services API (as detailed in the JAR specification), if\n+     * available, to determine the classname. The Services API will look\n+     * for a classname in the file\n+     * <code>META-INF/services/<i>org.apache.commons.jxpath.JXPathContextFactory</i></code>\n+     * in jars available to the runtime.\n+     * </li>\n+     * <li>\n+     * Platform default <code>JXPathContextFactory</code> instance.\n+     * </li>\n+     * </ul>\n+     *\n+     * Once an application has obtained a reference to a\n+     * <code>JXPathContextFactory</code> it can use the factory to\n+     * obtain JXPathContext instances.\n+     *\n+     * @exception JXPathFactoryConfigurationError if the implementation is not\n+     * available or cannot be instantiated.\n+     */\n+\n+    public static JXPathContextFactory newInstance() {\n+        String factoryImplName = findFactory(FACTORY_NAME_PROPERTY, defaultClassName);\n+\n+        if (factoryImplName == null) {\n+            throw new JXPathContextFactoryConfigurationError(\n+                \"No default implementation found\");\n+        }\n+\n+        JXPathContextFactory factoryImpl;\n+        try {\n+            Class clazz = Class.forName(factoryImplName);\n+            factoryImpl = (JXPathContextFactory)clazz.newInstance();\n+        } catch  (ClassNotFoundException cnfe) {\n+            throw new JXPathContextFactoryConfigurationError(cnfe);\n+        } catch (IllegalAccessException iae) {\n+            throw new JXPathContextFactoryConfigurationError(iae);\n+        } catch (InstantiationException ie) {\n+            throw new JXPathContextFactoryConfigurationError(ie);\n+        }\n+        return factoryImpl;\n+    }\n+\n+    /**\n+     * Creates a new instance of a JXPathContext using the\n+     * currently configured parameters.\n+     *\n+     * @exception JXPathContextFactoryConfigurationError if a JXPathContext\n+     * cannot be created which satisfies the configuration requested\n+     */\n+\n+    public abstract JXPathContext newContext(JXPathContext parentContext, Object contextBean)\n+        throws JXPathContextFactoryConfigurationError;\n+\n+    // -------------------- private methods --------------------\n+    // This code is duplicated in all factories.\n+    // Keep it in sync or move it to a common place\n+    // Because it's small probably it's easier to keep it here\n+    /** Avoid reading all the files when the findFactory\n+        method is called the second time ( cache the result of\n+        finding the default impl )\n+    */\n+    private static String foundFactory=null;\n+\n+    /** Temp debug code - this will be removed after we test everything\n+     */\n+    private static boolean debug=false;\n+    static {\n+    try {\n+        debug=System.getProperty( \"jxpath.debug\" ) != null;\n+    } catch(SecurityException se ) {}\n+    }\n+\n+    /** Private implementation method - will find the implementation\n+        class in the specified order.\n+        @param property    Property name\n+        @param factoryId   Qualified property name\n+        @param defaultFactory Default implementation, if nothing else is found\n+    */\n+    private static String findFactory(String property, String defaultFactory)\n+    {\n+        // Use the system property first\n+        try {\n+            String systemProp = System.getProperty( property );\n+            if( systemProp!=null) {\n+                if( debug )\n+                    System.err.println(\"JXPath: found system property\" +\n+                                       systemProp );\n+                return systemProp;\n+            }\n+\n+        }catch (SecurityException se) {\n+        }\n+\n+        if( foundFactory!=null)\n+            return foundFactory;\n+\n+        // Use the factory ID system property first\n+        try {\n+            String systemProp =\n+                System.getProperty( property );\n+            if( systemProp!=null) {\n+                if( debug )\n+                    System.err.println(\"JXPath: found system property\" +\n+                                       systemProp );\n+                return systemProp;\n+            }\n+\n+        }catch (SecurityException se) {\n+        }\n+\n+        // try to read from $java.home/lib/xml.properties\n+        try {\n+            String javah=System.getProperty( \"java.home\" );\n+            String configFile = javah + File.separator +\n+                \"lib\" + File.separator + \"jxpath.properties\";\n+            File f=new File( configFile );\n+            if( f.exists()) {\n+                Properties props=new Properties();\n+                props.load( new FileInputStream(f));\n+                foundFactory=props.getProperty( property );\n+                if( debug )\n+                    System.err.println(\"JXPath: found java.home property \" +\n+                                       foundFactory );\n+                if(foundFactory!=null )\n+                    return foundFactory;\n+            }\n+        } catch(Exception ex ) {\n+            if( debug ) ex.printStackTrace();\n+        }\n+\n+        String serviceId = \"META-INF/services/\" + property;\n+        // try to find services in CLASSPATH\n+        try {\n+            ClassLoader cl=JXPathContextFactory.class.getClassLoader();\n+            InputStream is=null;\n+            if( cl == null ) {\n+                is=ClassLoader.getSystemResourceAsStream( serviceId );\n+            } else {\n+                is=cl.getResourceAsStream( serviceId );\n+            }\n+\n+            if( is!=null ) {\n+                if( debug )\n+                    System.err.println(\"JXPath: found  \" +\n+                                       serviceId);\n+                BufferedReader rd=new BufferedReader( new\n+                    InputStreamReader(is));\n+\n+                foundFactory=rd.readLine();\n+                rd.close();\n+\n+                if( debug )\n+                    System.err.println(\"JXPath: loaded from services: \" +\n+                                       foundFactory );\n+                if( foundFactory != null &&\n+                    !  \"\".equals( foundFactory) ) {\n+                    return foundFactory;\n+                }\n+            }\n+        } catch( Exception ex ) {\n+            if( debug ) ex.printStackTrace();\n+        }\n+\n+        return defaultFactory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * Thrown when a problem with configuration with the JXPathContextFactories\n+ * exists. This error will typically be thrown when the class of a\n+ * factory specified in the system properties cannot be found\n+ * or instantiated.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+\n+public class JXPathContextFactoryConfigurationError extends Error {\n+\n+    /** @serial */\n+    private Exception exception;\n+\n+    /**\n+     * Create a new <code>JXPathContextFactoryConfigurationError</code> with no\n+     * detail mesage.\n+     */\n+\n+     public JXPathContextFactoryConfigurationError() {\n+         super();\n+         this.exception = null;\n+     }\n+\n+    /**\n+     * Create a new <code>JXPathContextFactoryConfigurationError</code> with\n+     * the <code>String </code> specified as an error message.\n+     *\n+     * @param msg The error message for the exception.\n+     */\n+\n+    public JXPathContextFactoryConfigurationError(String msg) {\n+        super(msg);\n+        this.exception = null;\n+    }\n+\n+\n+    /**\n+     * Create a new <code>JXPathContextFactoryConfigurationError</code> with a\n+     * given <code>Exception</code> base cause of the error.\n+     *\n+     * @param e The exception to be encapsulated in a\n+     * JXPathContextFactoryConfigurationError.\n+     */\n+\n+    public JXPathContextFactoryConfigurationError(Exception e) {\n+        super(e.toString());\n+        this.exception = e;\n+    }\n+\n+    /**\n+     * Create a new <code>JXPathContextFactoryConfigurationError</code> with the\n+     * given <code>Exception</code> base cause and detail message.\n+     *\n+     * @param e The exception to be encapsulated in a\n+     * JXPathContextFactoryConfigurationError\n+     * @param msg The detail message.\n+     * @param e The exception to be wrapped in a JXPathContextFactoryConfigurationError\n+     */\n+\n+    public JXPathContextFactoryConfigurationError(Exception e, String msg) {\n+        super(msg);\n+        this.exception = e;\n+    }\n+\n+\n+    /**\n+     * Return the message (if any) for this error . If there is no\n+     * message for the exception and there is an encapsulated\n+     * exception then the message of that exception will be returned.\n+     *\n+     * @return The error message.\n+     */\n+\n+    public String getMessage () {\n+        String message = super.getMessage ();\n+\n+        if (message == null && exception != null) {\n+            return exception.getMessage();\n+        }\n+\n+        return message;\n+    }\n+\n+    /**\n+     * Return the actual exception (if any) that caused this exception to\n+     * be raised.\n+     *\n+     * @return The encapsulated exception, or null if there is none.\n+     */\n+\n+    public Exception getException () {\n+        return exception;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathIntrospector.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.tree.MapDynamicPropertyHandler;\n+\n+/**\n+ * JXPathIntrospector maintains a registry of {@link JXPathBeanInfo JXPathBeanInfo} objects\n+ * for Java classes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class JXPathIntrospector {\n+\n+    private static HashMap byClass = new HashMap();\n+    static {\n+        registerAtomicClass(Boolean.TYPE);\n+        registerAtomicClass(Boolean.class);\n+        registerAtomicClass(Byte.TYPE);\n+        registerAtomicClass(Byte.class);\n+        registerAtomicClass(Character.TYPE);\n+        registerAtomicClass(Character.class);\n+        registerAtomicClass(Short.TYPE);\n+        registerAtomicClass(Short.class);\n+        registerAtomicClass(Integer.TYPE);\n+        registerAtomicClass(Integer.class);\n+        registerAtomicClass(Long.TYPE);\n+        registerAtomicClass(Long.class);\n+        registerAtomicClass(Float.TYPE);\n+        registerAtomicClass(Float.class);\n+        registerAtomicClass(Double.TYPE);\n+        registerAtomicClass(Double.class);\n+        registerAtomicClass(String.class);\n+        registerAtomicClass(Date.class);\n+        registerAtomicClass(java.sql.Date.class);\n+        registerAtomicClass(java.sql.Time.class);\n+        registerAtomicClass(java.sql.Timestamp.class);\n+\n+        registerDynamicClass(HashMap.class, MapDynamicPropertyHandler.class);\n+        registerDynamicClass(Properties.class, MapDynamicPropertyHandler.class);\n+        registerDynamicClass(WeakHashMap.class, MapDynamicPropertyHandler.class);\n+    }\n+\n+    /**\n+     * Automatically creates and registers a JXPathBeanInfo object\n+     * for the specified class. That object returns true to isAtomic().\n+     */\n+    public static void registerAtomicClass(Class beanClass) {\n+        byClass.put(beanClass, new JXPathBasicBeanInfo(beanClass, true));\n+    }\n+\n+    /**\n+     * Automatically creates and registers a JXPathBeanInfo object\n+     * for the specified class. That object returns true to isDynamic().\n+     */\n+    public static void registerDynamicClass(Class beanClass, Class dynamicPropertyHandlerClass) {\n+        byClass.put(beanClass, new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass));\n+    }\n+\n+    /**\n+     * Creates and registers a JXPathBeanInfo object for the supplied class.\n+     * If the class has already been registered, returns the registered JXPathBeanInfo\n+     * object.\n+     * <p>\n+     * The process of creation of JXPathBeanInfo is as follows:\n+     * <ul>\n+     * <li>If class named <code>&lt;beanClass&gt;XBeanInfo</code> exists,\n+     *     an instance of that class is allocated.\n+     * <li>Otherwise, an instance of {@link JXPathBasicBeanInfo JXPathBasicBeanInfo} is\n+     *     allocated.\n+     * </ul>\n+     */\n+    public static JXPathBeanInfo getBeanInfo(Class beanClass) {\n+        JXPathBeanInfo beanInfo = (JXPathBeanInfo)byClass.get(beanClass);\n+        if (beanInfo == null){\n+            beanInfo = findInformant(beanClass);\n+            if (beanInfo == null){\n+                beanInfo = new JXPathBasicBeanInfo(beanClass);\n+            }\n+            byClass.put(beanClass, beanInfo);\n+        }\n+        return beanInfo;\n+    }\n+\n+    private static synchronized JXPathBeanInfo findInformant(Class beanClass) {\n+        String name = beanClass.getName() + \"XBeanInfo\";\n+        try {\n+            return (JXPathBeanInfo)instantiate(beanClass, name);\n+        } catch (Exception ex) {\n+            // Just drop through\n+        }\n+\n+        // Now try checking if the bean is its own JXPathBeanInfo.\n+        try {\n+            if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) {\n+                return (JXPathBeanInfo)beanClass.newInstance();\n+            }\n+        } catch (Exception ex) {\n+            // Just drop through\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Try to create an instance of a named class.\n+     * First try the classloader of \"sibling\", then try the system\n+     * classloader.\n+     */\n+    private static Object instantiate(Class sibling, String className)\n+                 throws Exception {\n+\n+        // First check with sibling's classloader (if any).\n+        ClassLoader cl = sibling.getClassLoader();\n+        if (cl != null) {\n+            try {\n+                Class cls = cl.loadClass(className);\n+                return cls.newInstance();\n+            } catch (Exception ex) {\n+                // Just drop through and try the system classloader.\n+            }\n+        }\n+\n+        // Now try the bootstrap classloader.\n+        Class cls = Class.forName(className);\n+        return cls.newInstance();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.functions.*;\n+\n+/**\n+ * Extension functions provided by Java classes.  The class prefix specified\n+ * in the constructor is used when a constructor or a static method is called.\n+ * Usually, a class prefix is a package name (hence the name of this class).\n+ *\n+ * Let's say, we declared a PackageFunction like this:\n+ * <blockquote><pre>\n+ *     new PackageFunctions(\"java.util.\", \"util\")\n+ * </pre></blockquote>\n+ *\n+ * We can now use XPaths like:\n+ * <dl>\n+ *  <dt><code>\"util:Date.new()\"</code></dt>\n+ *  <dd>Equivalent to <code>new java.util.Date()</code></dd>\n+ *  <dt><code>\"util:Collections.singleton('foo')\"</code></dt>\n+ *  <dd>Equivalent to <code>java.util.Collections.singleton(\"foo\")</code></dd>\n+ *  <dt><code>\"util:substring('foo', 1, 2)\"</code></dt>\n+ *  <dd>Equivalent to <code>\"foo\".substring(1, 2)</code>.  Note that in\n+ *  this case, the class prefix is not used. JXPath does not check that\n+ *  the first parameter of the function (the method target) is in fact\n+ *  a member of the package described by this PackageFunctions object.</dd>\n+ * </dl>\n+ *\n+ * There is one PackageFunctions object registered by default with each\n+ * JXPathContext.  It does not have a namespace and uses no class prefix.\n+ * The existence of this object allows us to use XPaths like:\n+ * <code>\"java.util.Date.new()\"</code> and <code>\"length('foo')\"</code>\n+ * without the explicit registration of any extension functions.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class PackageFunctions implements Functions {\n+    private String classPrefix;\n+    private String namespace;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public PackageFunctions(String classPrefix, String namespace){\n+        this.classPrefix = classPrefix;\n+        this.namespace = namespace;\n+    }\n+\n+    public Set getUsedNamespaces(){\n+        return Collections.singleton(namespace);\n+    }\n+\n+    /**\n+     * Returns a Function, if any, for the specified namespace,\n+     * name and parameter types.\n+     */\n+    public Function getFunction(String namespace, String name, Object[] parameters){\n+        if ((namespace == null && this.namespace != null) ||\n+                (namespace != null && !namespace.equals(this.namespace))){\n+            return null;\n+        }\n+\n+        if (parameters == null){\n+            parameters = EMPTY_ARRAY;\n+        }\n+\n+        if (parameters.length >= 1){\n+            Object target = parameters[0];\n+            if (target != null){\n+                if (target instanceof ExpressionContext){\n+                    target = ((ExpressionContext)target).getContextNodePointer().getValue();\n+                }\n+            }\n+            if (target != null){\n+                Method method = Types.lookupMethod(Object.class, name, parameters);\n+                if (method != null){\n+                    return new MethodFunction(method);\n+                }\n+            }\n+        }\n+\n+        String fullName = classPrefix + name;\n+        int inx = fullName.lastIndexOf('.');\n+        if (inx == -1){\n+            return null;\n+        }\n+\n+        String className = fullName.substring(0, inx);\n+        String methodName = fullName.substring(inx + 1);\n+\n+        Class functionClass;\n+        try {\n+            functionClass = Class.forName(className);\n+        }\n+        catch (ClassNotFoundException ex){\n+            throw new RuntimeException(\"Class not found: \" + ex);\n+        }\n+\n+        if (methodName.endsWith(\"new\")){\n+            Constructor constructor = Types.lookupConstructor(functionClass, parameters);\n+            if (constructor != null){\n+                return new ConstructorFunction(constructor);\n+            }\n+        }\n+        else {\n+            Method method = Types.lookupStaticMethod(functionClass, methodName, parameters);\n+            if (method != null){\n+                return new MethodFunction(method);\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * Pointers represent locations of objects and their properties\n+ * in Java object graphs. JXPathContext has methods\n+ * ({@link JXPathContext#locate(java.lang.String) locate()}\n+ * and ({@link JXPathContext#locateValue(java.lang.String) locateValue()}\n+ * that, given an XPath, produce Pointers for the objects or properties\n+ * described the the path. For example, <code>ctx.locateValue(\"foo/bar\")</code>\n+ * will produce a Pointer that can get and set the property \"bar\" of\n+ * the object which is the value of the property \"foo\" of the root object.\n+ * The value of <code>ctx.locateValue(\"aMap/aKey[3]\")</code> will be a pointer\n+ * to the 3'rd element of the array, which is the value for the key \"aKey\" of\n+ * the map, which is the value of the property \"aMap\" of the root object.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface Pointer {\n+\n+    /**\n+     * Returns the value of the object, property or collection element\n+     * this pointer represents.\n+     */\n+    Object getValue();\n+\n+    /**\n+     * Modifies the value of the object, property or collection element\n+     * this pointer represents.\n+     */\n+    void setValue(Object value);\n+\n+    /**\n+     * Returns a string that is a proper XPath that corresponds to\n+     * this pointer.  Consider this example:\n+     * <p><code>Pointer ptr = ctx.locateValue(\"//employees[firstName = 'John']\")</code>\n+     * <p>The value of <code>ptr.asPath()</code> will look something like\n+     * <code>\"/departments[2]/employees[3]\"</code>, so, basically, it represents the\n+     * concrete location(s) of the result of a search performed by JXPath.\n+     * If an object in the pointer's path is a Dynamic Property object (like a Map),\n+     * the asPath method generates an XPath that looks like this:\n+     * <code>\"/departments[@name = 'HR']/employees[3]\"</code>.\n+     */\n+    String asPath();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/Variables.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Variables.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * Variables provide access to a global set of values accessible via XPath.\n+ * XPath can reference variables using the \"$varname\" syntax. To use a custom\n+ * implementation of this interface, pass it to a newContext method of\n+ * JXPathContext.\n+ *\n+ * @see JXPathContext#setVariables\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public interface Variables {\n+\n+    /**\n+     * Returns true if the specified variable is declared.\n+     */\n+    boolean isDeclaredVariable(String varName);\n+\n+    /**\n+     * Returns the value of the specified variable.\n+     * Throws IllegalArgumentException if there is no such variable.\n+     */\n+    Object getVariable(String varName);\n+\n+    /**\n+     * Defines a new variable with the specified value or modifies\n+     * the value of an existing variable. May throw UnsupportedOperationException.\n+     */\n+    void declareVariable(String varName, Object value);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.functions;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * An extension function that creates an instance using a constructor.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class ConstructorFunction implements Function {\n+\n+    private Constructor constructor;\n+\n+    public ConstructorFunction(Constructor constructor){\n+        this.constructor = constructor;\n+    }\n+\n+    /**\n+     * Converts parameters to suitable types and invokes the constructor.\n+     */\n+    public Object invoke(Object[] parameters){\n+        try {\n+            Object[] args;\n+            if (parameters == null){\n+                args = null;\n+            }\n+            else {\n+                Class types[] = constructor.getParameterTypes();\n+                args = new Object[parameters.length];\n+                for (int i = 0; i < args.length; i++){\n+                    args[i] = Types.convert(parameters[i], types[i]);\n+                }\n+            }\n+            return constructor.newInstance(args);\n+        }\n+        catch (Exception exception){\n+            // TBD\n+            exception.printStackTrace();\n+            throw new RuntimeException(\"Cannot invoke constructor \" + constructor + \": \" + exception);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.functions;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class MethodFunction implements Function {\n+\n+    private Method method;\n+\n+    public MethodFunction(Method method){\n+        this.method = method;\n+    }\n+\n+    /**\n+     */\n+    public Object invoke(Object[] parameters){\n+        try {\n+            Object target;\n+            Object[] args;\n+            if (Modifier.isStatic(method.getModifiers())){\n+                target = null;\n+                if (parameters == null){\n+                    args = null;\n+                }\n+                else {\n+                    Class types[] = method.getParameterTypes();\n+                    args = new Object[parameters.length];\n+                    for (int i = 0; i < args.length; i++){\n+                        args[i] = Types.convert(parameters[i], types[i]);\n+                    }\n+                }\n+            }\n+            else {\n+                target = Types.convert(parameters[0], method.getDeclaringClass());\n+                Class types[] = method.getParameterTypes();\n+                args = new Object[parameters.length - 1];\n+                for (int i = 0; i < args.length; i++){\n+                    args[i] = Types.convert(parameters[i + 1], types[i]);\n+                }\n+            }\n+\n+            return method.invoke(target, args);\n+        }\n+        catch (Exception exception){\n+            // TBD\n+            throw new RuntimeException(\"Cannot invoke \" + method + \": \" + exception);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/functions/PackageFunctions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/Attic/PackageFunctions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.functions;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class PackageFunctions implements Functions {\n+    private String classPrefix;\n+    private String namespace;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public PackageFunctions(String classPrefix, String namespace){\n+        this.classPrefix = classPrefix;\n+        this.namespace = namespace;\n+    }\n+\n+    public Set getUsedNamespaces(){\n+        return Collections.singleton(namespace);\n+    }\n+\n+    /**\n+     * Returns a Function, if any, for the specified namespace,\n+     * name and parameter types.\n+     */\n+    public Function getFunction(String namespace, String name, Object[] parameters){\n+        if ((namespace == null && this.namespace != null) ||\n+                (namespace != null && !namespace.equals(this.namespace))){\n+            return null;\n+        }\n+\n+        if (parameters == null){\n+            parameters = EMPTY_ARRAY;\n+        }\n+\n+        if (parameters.length >= 1){\n+            Object target = parameters[0];\n+            if (target != null){\n+                if (target instanceof ExpressionContext){\n+                    target = ((ExpressionContext)target).getContextNodePointer().getValue();\n+                }\n+            }\n+            if (target != null){\n+                Method method = Types.lookupMethod(Object.class, name, parameters);\n+                if (method != null){\n+                    return new MethodFunction(method);\n+                }\n+            }\n+        }\n+\n+        String fullName = classPrefix + name;\n+        int inx = fullName.lastIndexOf('.');\n+        if (inx == -1){\n+            return null;\n+        }\n+\n+        String className = fullName.substring(0, inx);\n+        String methodName = fullName.substring(inx + 1);\n+\n+        Class functionClass;\n+        try {\n+            functionClass = Class.forName(className);\n+        }\n+        catch (ClassNotFoundException ex){\n+            throw new RuntimeException(\"Class not found: \" + ex);\n+        }\n+\n+        if (methodName.endsWith(\"new\")){\n+            Constructor constructor = Types.lookupConstructor(functionClass, parameters);\n+            if (constructor != null){\n+                return new ConstructorFunction(constructor);\n+            }\n+        }\n+        else {\n+            Method method = Types.lookupStaticMethod(functionClass, methodName, parameters);\n+            if (method != null){\n+                return new MethodFunction(method);\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/functions/Types.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/Attic/Types.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:58 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.functions;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ */\n+public class Types {\n+\n+    public static final int NO_MATCH = 0;\n+    public static final int APPROXIMATE_MATCH = 1;\n+    public static final int EXACT_MATCH = 2;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Constructor constructor = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                constructor = targetClass.getConstructor(types);\n+                if (constructor != null){\n+                    return constructor;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Constructor[] constructors = targetClass.getConstructors();\n+        for (int i = 0; i < constructors.length; i++){\n+            int match = Types.matchParameterTypes(constructors[i].getParameterTypes(), parameters);\n+            if (match != Types.NO_MATCH){\n+                if (match > currentMatch){\n+                    constructor = constructors[i];\n+                    currentMatch = match;\n+                    ambiguous = false;\n+                }\n+                else if (match == currentMatch){\n+                    ambiguous = true;\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous constructor \" + Arrays.asList(parameters));\n+        }\n+        return constructor;\n+    }\n+\n+    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = Types.matchParameterTypes(methods[i].getParameterTypes(), parameters);\n+                if (match != Types.NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+    }\n+\n+    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n+        if (parameters.length < 1 || parameters[0] == null){\n+            return null;\n+        }\n+\n+        if (Types.matchType(targetClass, parameters[0]) == Types.NO_MATCH){\n+            return null;\n+        }\n+\n+        targetClass = convert(parameters[0], targetClass).getClass();\n+\n+        boolean tryExact = true;\n+        int count = parameters.length - 1;\n+        Class types[] = new Class[count];\n+        Object arguments[] = new Object[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i+1];\n+            arguments[i] = param;\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && !Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (!Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = Types.matchParameterTypes(methods[i].getParameterTypes(), arguments);\n+                if (match != Types.NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+   }\n+    public static int matchParameterTypes(Class types[], Object parameters[]){\n+        if (types.length != parameters.length){\n+            return NO_MATCH;\n+        }\n+        int totalMatch = EXACT_MATCH;\n+        for (int i = 0; i < types.length; i++){\n+            int match = matchType(types[i], parameters[i]);\n+            if (match == NO_MATCH){\n+                return NO_MATCH;\n+            }\n+            if (match < totalMatch){\n+                totalMatch = match;\n+            }\n+        }\n+        return totalMatch;\n+    }\n+\n+    public static int matchType(Class expected, Object object){\n+        if (object == null){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        Class actual = object.getClass();\n+\n+        if (expected.equals(actual)){\n+            return EXACT_MATCH;\n+        }\n+        if (expected.isAssignableFrom(actual)){\n+            return EXACT_MATCH;\n+        }\n+\n+        if (canConvert(object, expected)){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        return NO_MATCH;\n+    }\n+\n+    public static boolean canConvert(Object object, Class toType){\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType)){\n+            return true;\n+        }\n+\n+        if (toType.isAssignableFrom(fromType)){\n+            return true;\n+        }\n+\n+        if (toType == String.class){\n+            return true;\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Number){\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType.isPrimitive()){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+            // TBD: array arguments\n+            Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n+            return canConvert(value, toType);\n+        }\n+\n+        // TBD: date conversion to/from string\n+        return false;\n+    }\n+\n+    public static Object convert(Object object, Class toType){\n+        if (object == null){\n+            return null;\n+        }\n+\n+        if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                List list = ((ExpressionContext)object).getContextNodeList();\n+                Collection result = new ArrayList();\n+                if (toType == List.class || toType == ArrayList.class){\n+                    result = new ArrayList();\n+                }\n+                else if (toType == Vector.class){\n+                    result = new Vector();\n+                }\n+                else if (toType == Set.class || toType == HashSet.class){\n+                    result = new HashSet();\n+                }\n+                int count = list.size();\n+                for (int i = 0; i < count; i++){\n+                    Pointer ptr = (Pointer)list.get(i);\n+                    result.add(ptr.getValue());\n+                }\n+                return result;\n+            }\n+            else {\n+                Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n+                return convert(value, toType);\n+            }\n+        }\n+\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)){\n+            return object;\n+        }\n+\n+        if (toType == String.class){\n+            return object.toString();\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class){\n+                return object;\n+            }\n+            boolean value = ((Boolean)object).booleanValue();\n+            return allocateNumber(toType, value ? 1 : 0);\n+        }\n+        else if (object instanceof Number){\n+            double value = ((Number)object).doubleValue();\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n+            }\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return allocateNumber(toType, value);\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return object;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return new Boolean((String)object);\n+            }\n+            if (toType == char.class || toType == Character.class){\n+                return new Character(((String)object).charAt(0));\n+            }\n+            if (toType == byte.class || toType == Byte.class){\n+                return new Byte((String)object);\n+            }\n+            if (toType == short.class || toType == Short.class){\n+                return new Short((String)object);\n+            }\n+            if (toType == int.class || toType == Integer.class){\n+                return new Integer((String)object);\n+            }\n+            if (toType == long.class || toType == Long.class){\n+                return new Long((String)object);\n+            }\n+            if (toType == float.class || toType == Float.class){\n+                return new Float((String)object);\n+            }\n+            if (toType == double.class || toType == Double.class){\n+                return new Double((String)object);\n+            }\n+        }\n+        return object;\n+    }\n+\n+    private static Number allocateNumber(Class type, double value){\n+        if (type == Byte.class || type == byte.class){\n+            return new Byte((byte)value);\n+        }\n+        if (type == Short.class || type == short.class){\n+            return new Short((short)value);\n+        }\n+        if (type == Integer.class || type == int.class){\n+            return new Integer((int)value);\n+        }\n+        if (type == Long.class || type == long.class){\n+            return new Long((long)value);\n+        }\n+        if (type == Float.class || type == float.class){\n+            return new Float((float)value);\n+        }\n+        if (type == Double.class || type == double.class){\n+            return new Double(value);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/Compiler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Compiler.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import java.util.*;\n+\n+/**\n+ * The Compiler APIs are completely agnostic to the actual types of objects\n+ * produced and consumed by the APIs.  Arguments and return values are\n+ * declared as java.lang.Object.\n+ * <p>\n+ * Since objects returned by Compiler methods are passed as arguments to\n+ * other Compiler methods, the descriptions of these methods use virtual\n+ * types.  There are three virtual object types: EXPRESSION, QNAME and STEP.\n+ * <p>\n+ * The following example illustrates this notion.  This sequence compiles\n+ * the xpath \"foo[round(1 div 2)]/text()\":\n+ * <blockquote><pre>\n+ *      Object qname1 = compiler.qname(null, \"foo\")\n+ *      Object expr1 = compiler.number(\"1\");\n+ *      Object expr2 = compiler.number(\"2\");\n+ *      Object expr3 = compiler.div(expr1, expr2);\n+ *      Object expr4 = compiler.coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});\n+ *      Object step1 = compiler.nodeNameTest(Compiler.AXIS_CHILD, qname1, new Object[]{expr4});\n+ *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, Compiler.NODE_TYPE_TEXT, null);\n+ *      Object expr5 = compiler.locationPath(false, new Object[]{step1, step2});\n+ * </pre></blockquote>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public interface Compiler {\n+\n+    public static final int NODE_TYPE_NODE = 1;\n+    public static final int NODE_TYPE_TEXT = 2;\n+    public static final int NODE_TYPE_COMMENT = 3;\n+    public static final int NODE_TYPE_PI = 4;\n+\n+    public static final int AXIS_SELF = 1;\n+    public static final int AXIS_CHILD = 2;\n+    public static final int AXIS_PARENT = 3;\n+    public static final int AXIS_ANCESTOR = 4;\n+    public static final int AXIS_ATTRIBUTE = 5;\n+    public static final int AXIS_NAMESPACE = 6;\n+    public static final int AXIS_PRECEDING = 7;\n+    public static final int AXIS_FOLLOWING = 8;\n+    public static final int AXIS_DESCENDANT = 9;\n+    public static final int AXIS_ANCESTOR_OR_SELF = 10;\n+    public static final int AXIS_FOLLOWING_SIBLING = 11;\n+    public static final int AXIS_PRECEDING_SIBLING = 12;\n+    public static final int AXIS_DESCENDANT_OR_SELF = 13;\n+\n+    public static final int FUNCTION_LAST = 1;\n+    public static final int FUNCTION_POSITION = 2;\n+    public static final int FUNCTION_COUNT = 3;\n+    public static final int FUNCTION_ID = 4;\n+    public static final int FUNCTION_LOCAL_NAME = 5;\n+    public static final int FUNCTION_NAMESPACE_URI = 6;\n+    public static final int FUNCTION_NAME = 7;\n+    public static final int FUNCTION_STRING = 8;\n+    public static final int FUNCTION_CONCAT = 9;\n+    public static final int FUNCTION_STARTS_WITH = 10;\n+    public static final int FUNCTION_CONTAINS = 11;\n+    public static final int FUNCTION_SUBSTRING_BEFORE = 12;\n+    public static final int FUNCTION_SUBSTRING_AFTER = 13;\n+    public static final int FUNCTION_SUBSTRING = 14;\n+    public static final int FUNCTION_STRING_LENGTH = 15;\n+    public static final int FUNCTION_NORMALIZE_SPACE = 16;\n+    public static final int FUNCTION_TRANSLATE = 17;\n+    public static final int FUNCTION_BOOLEAN = 18;\n+    public static final int FUNCTION_NOT = 19;\n+    public static final int FUNCTION_TRUE = 20;\n+    public static final int FUNCTION_FALSE = 21;\n+    public static final int FUNCTION_LANG = 22;\n+    public static final int FUNCTION_NUMBER = 23;\n+    public static final int FUNCTION_SUM = 24;\n+    public static final int FUNCTION_FLOOR = 25;\n+    public static final int FUNCTION_CEILING = 26;\n+    public static final int FUNCTION_ROUND = 27;\n+//    public static final int FUNCTION_KEY = 28;\n+\n+    /**\n+     * Produces an EXPRESSION object that represents a numeric constant.\n+     */\n+    Object number(String value);\n+\n+    /**\n+     * Produces an EXPRESSION object that represents a string constant.\n+     */\n+    Object literal(String value);\n+\n+    /**\n+     * Produces an QNAME that represents a name with an optional prefix.\n+     */\n+    Object qname(String prefix, String name);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the sum of all argumens\n+     *\n+     * @param arguments are EXPRESSION objects\n+     */\n+    Object sum(Object[] arguments);\n+\n+    /**\n+     * Produces an EXPRESSION object representing <i>left</i> minus <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object minus(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing <i>left</i> multiplied by <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object multiply(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing <i>left</i> divided by <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object divide(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing <i>left</i> modulo <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object mod(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> less than <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object lessThan(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> less than or equal to <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object lessThanOrEqual(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> greater than <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object greaterThan(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> greater than or equal to <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object greaterThanOrEqual(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> equals to <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object equal(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the comparison:\n+     * <i>left</i> is not equal to <i>right</i>\n+     *\n+     * @param left is an EXPRESSION object\n+     * @param right is an EXPRESSION object\n+     */\n+    Object notEqual(Object left, Object right);\n+\n+    /**\n+     * Produces an EXPRESSION object representing unary negation of the argument\n+     *\n+     * @param argument is an EXPRESSION object\n+     */\n+    Object minus(Object argument);\n+\n+    /**\n+     * Produces an EXPRESSION object representing variable reference\n+     *\n+     * @param qname is a QNAME object\n+     */\n+    Object variableReference(Object qName);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the computation of\n+     * a core function with the supplied arguments.\n+     *\n+     * @param code is one of FUNCTION_... constants\n+     * @param args are EXPRESSION objects\n+     */\n+    Object function(int code, Object[] args);\n+\n+    /**\n+     * Produces an EXPRESSION object representing the computation of\n+     * a library function with the supplied arguments.\n+     *\n+     * @param name is a QNAME object (function name)\n+     * @param args are EXPRESSION objects\n+     */\n+    Object function(Object name, Object[] args);\n+\n+    /**\n+     * Produces an EXPRESSION object representing logical conjunction of\n+     * all arguments\n+     *\n+     * @param arguments are EXPRESSION objects\n+     */\n+    Object and(Object arguments[]);\n+\n+    /**\n+     * Produces an EXPRESSION object representing logical disjunction of\n+     * all arguments\n+     *\n+     * @param arguments are EXPRESSION objects\n+     */\n+    Object or(Object arguments[]);\n+\n+    /**\n+     * Produces an EXPRESSION object representing union of all node sets\n+     *\n+     * @param arguments are EXPRESSION objects\n+     */\n+    Object union(Object[] arguments);\n+\n+    /**\n+     * Produces a STEP object that represents a node name test.\n+     *\n+     * @param axis is one of the AXIS_... constants\n+     * @param qname is a QNAME object\n+     * @param predicates are EXPRESSION objects\n+     */\n+    Object nodeNameTest(int axis, Object qname, Object[] predicates);\n+\n+    /**\n+     * Produces a STEP object that represents a node type test.\n+     *\n+     * @param axis is one of the AXIS_... constants\n+     * @param nodeType is one of the NODE_TYPE_... constants\n+     * @param predicates are EXPRESSION objects\n+     */\n+    Object nodeTypeTest(int axis, int nodeType, Object[] predicates);\n+\n+    /**\n+     * Produces a STEP object that represents a processing instruction test.\n+     *\n+     * @param axis is one of the AXIS_... constants\n+     * @param instruction is a processing instruction\n+     * @param predicates are EXPRESSION objects\n+     */\n+    Object processingInstructionTest(int axis, String instruction, Object[] predicates);\n+\n+    /**\n+     * Produces an EXPRESSION object representing a location path\n+     *\n+     * @param absolute indicates whether the path is absolute\n+     * @param steps are STEP objects\n+     */\n+    Object locationPath(boolean absolute, Object[] steps);\n+\n+    /**\n+     * Produces an EXPRESSION object representing a filter expression\n+     *\n+     * @param expression is an EXPRESSION object\n+     * @param predicates are EXPRESSION objects\n+     * @param steps are STEP objects\n+     */\n+    Object expressionPath(Object expression, Object[] predicates, Object[] steps);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.Pointer;\n+import java.util.*;\n+\n+/**\n+ * An XPath evaluation context.\n+ *\n+ * When evaluating a path, a chain of EvalContexts is created, each\n+ * context in the chain representing a step of the path. Subclasses of EvalContext\n+ * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public abstract class EvalContext implements ExpressionContext {\n+    protected EvalContext parentContext;\n+    protected RootContext rootContext;\n+    private HashSet visitedNodes = new HashSet();\n+    protected int position = 0;\n+\n+    public EvalContext(EvalContext parentContext){\n+        this.parentContext = parentContext;\n+    }\n+\n+    /**\n+     * Returns the root context of the path, which provides easy\n+     * access to variables and functions.\n+     */\n+    public RootContext getRootContext(){\n+        if (rootContext == null){\n+            rootContext = parentContext.getRootContext();\n+        }\n+        return rootContext;\n+    }\n+\n+    /**\n+     * Sets current position = 0, which is the pre-iteration state.\n+     */\n+    protected void reset(){\n+        position = 0;\n+    }\n+\n+    public int getCurrentPosition(){\n+        return position;\n+    }\n+\n+    /**\n+     * If the iteration has not started yet, starts the iteration and\n+     * returns the first encountered Pointer that matches the current\n+     * step's criteria.  Otherwise, returns the current pointer.\n+     */\n+    public Pointer getContextNodePointer(){\n+        if (position == 0){\n+            while(nextSet()){\n+                if (next()){\n+                    return getCurrentNodePointer();\n+                }\n+            }\n+            return null;\n+        }\n+        else {\n+            return getCurrentNodePointer();\n+        }\n+    }\n+\n+    /**\n+     * Iterates through the current context collecting\n+     * pointers to all elements.\n+     */\n+    public List getContextNodeList(){\n+        List list = new ArrayList();\n+        while(nextSet()){\n+            while(next()){\n+                list.add(getCurrentNodePointer());\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns the current context node. Undefined before the beginning\n+     * of the iteration.\n+     */\n+    public abstract NodePointer getCurrentNodePointer();\n+\n+    /**\n+     * Returns true if there is another sets of objects to interate over.\n+     * Resets the current position and node.\n+     */\n+    public abstract boolean nextSet();\n+\n+    /**\n+     * Returns true if there is another object in the current set.\n+     * Switches the current position and node to the next object.\n+     */\n+    public boolean next(){\n+        while (nextIgnoreDuplicates()){\n+            NodePointer location = getCurrentNodePointer();\n+            if (!visitedNodes.contains(location)){\n+                visitedNodes.add(location.clone());\n+                position++;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if there is another object in the current set, even\n+     * if that object has already been encountered in the same iteration.\n+     */\n+    protected boolean nextIgnoreDuplicates(){\n+        return false;\n+    }\n+\n+    /**\n+     * Moves the current position to the specified index. Used with integer\n+     * predicates to quickly get to the n'th element of the node set.\n+     * Returns false if the position is out of the node set range.\n+     */\n+    public abstract boolean setPosition(int position);\n+\n+    /**\n+     * Creates an EvalContext with the value of the specified\n+     * variable as its context node.\n+     */\n+    protected EvalContext getVariable(QName variableName){\n+        return getRootContext().getVariableContext(variableName);\n+    }\n+\n+    protected static Double ZERO = new Double(0);\n+    protected static Double ONE = new Double(1);\n+    protected static Double NaN = new Double(Double.NaN);\n+\n+    /**\n+     * Evaluates the expression. If the result is a node set, returns\n+     * the first element of the node set.\n+     */\n+    public Object eval(Expression expression){\n+        return eval(expression, true);\n+    }\n+\n+    /**\n+     * Evaluates the expression. If the result is a node set, returns\n+     * the whole set if firstMatch==false or the first element otherwise.\n+     */\n+    public Object eval(Expression expression, boolean firstMatch){\n+        Object value = null;\n+        switch (expression.getEvaluationMode()){\n+            case Expression.EVALUATION_MODE_ONCE:\n+            case Expression.EVALUATION_MODE_ALWAYS:\n+                value = evalExpression(expression, firstMatch);\n+                break;\n+            case Expression.EVALUATION_MODE_ONCE_AND_SAVE:\n+                RootContext root = getRootContext();\n+                int id = expression.getID();\n+                if (id == -1){\n+                    // evaluate the expression and save the intermediate result\n+                    value = evalExpression(expression, firstMatch);\n+                    id = root.setRegisteredValue(value);\n+                    expression.setID(id);\n+                }\n+                else {\n+                    value = root.getRegisteredValue(id);\n+                }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Evaluates the expression. If the result is a node set, returns\n+     * the whole set if firstMatch==false or the first element otherwise.\n+     */\n+    private Object evalExpression(Expression expression, boolean firstMatch){\n+        int op = expression.getExpressionTypeCode();\n+        switch(op){\n+        case Expression.OP_CONSTANT:\n+            return ((Constant)expression).getValue();\n+\n+        case Expression.OP_UNION:\n+            return union(((CoreOperation)expression).getArg1(),\n+                         ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_UNARY_MINUS:\n+            return minus(((CoreOperation)expression).getArg1());\n+\n+        case Expression.OP_SUM:\n+            return sum(((CoreOperation)expression).getArguments());\n+\n+        case Expression.OP_MINUS:\n+            return minus(((CoreOperation)expression).getArg1(),\n+                         ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_MULT:\n+            return mult(((CoreOperation)expression).getArg1(),\n+                        ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_DIV:\n+            return div(((CoreOperation)expression).getArg1(),\n+                       ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_MOD:\n+            return mod(((CoreOperation)expression).getArg1(),\n+                       ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_LT:\n+            return lt(((CoreOperation)expression).getArg1(),\n+                      ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_GT:\n+            return gt(((CoreOperation)expression).getArg1(),\n+                      ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_LTE:\n+            return lte(((CoreOperation)expression).getArg1(),\n+                       ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_GTE:\n+            return gte(((CoreOperation)expression).getArg1(),\n+                       ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_EQ:\n+            return eq(((CoreOperation)expression).getArg1(),\n+                      ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_NE:\n+            return ne(((CoreOperation)expression).getArg1(),\n+                      ((CoreOperation)expression).getArg2());\n+\n+        case Expression.OP_AND:\n+            return and(((CoreOperation)expression).getArguments());\n+\n+        case Expression.OP_OR:\n+            return or(((CoreOperation)expression).getArguments());\n+\n+        case Expression.OP_VAR:\n+            return getVariable(((VariableReference)expression).getVariableName());\n+\n+        case Expression.OP_CORE_FUNCTION:\n+            return coreFunction((CoreFunction)expression);\n+\n+        case Expression.OP_LOCATION_PATH:\n+            return path((LocationPath)expression, firstMatch);\n+\n+        case Expression.OP_EXPRESSION_PATH:\n+            return expressionPath(((ExpressionPath)expression).getExpression(),\n+                                  ((ExpressionPath)expression).getPredicates(),\n+                                  ((ExpressionPath)expression).getSteps(), firstMatch);\n+\n+        case Expression.OP_FUNCTION:\n+            return function(((ExtensionFunction)expression).getFunctionName(),\n+                            ((ExtensionFunction)expression).getArguments());\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Computes <code>\"left | right\"<code>\n+     */\n+    protected Object union(Expression left, Expression right){\n+        Object l = eval(left, false);\n+        Object r = eval(right, false);\n+        EvalContext lctx;\n+        if (l instanceof EvalContext){\n+            lctx = (EvalContext)l;\n+        }\n+        else {\n+            lctx = getRootContext().getConstantContext(l);\n+        }\n+        EvalContext rctx;\n+        if (r instanceof EvalContext){\n+            rctx = (EvalContext)r;\n+        }\n+        else {\n+            rctx = getRootContext().getConstantContext(r);\n+        }\n+        return new UnionContext(getRootContext(), new EvalContext[]{lctx, rctx});\n+    }\n+\n+    /**\n+     * Computes <code>\"-arg\"<code>\n+     */\n+    protected Object minus(Expression arg){\n+        double a = doubleValue(eval(arg));\n+        return new Double(-a);\n+    }\n+\n+    /**\n+     * Computes <code>\"a + b + c + d\"<code>\n+     */\n+    protected Object sum(Expression[] arguments){\n+        double s = 0.0;\n+        for (int i = 0; i < arguments.length; i++){\n+            s += doubleValue(eval(arguments[i]));\n+        }\n+        return new Double(s);\n+    }\n+\n+    /**\n+     * Computes <code>\"left - right\"<code>\n+     */\n+    protected Object minus(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return new Double(l - r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left div right\"<code>\n+     */\n+    protected Object div(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return new Double(l/r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left * right\"<code>\n+     */\n+    protected Object mult(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return new Double(l*r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left mod right\"<code>\n+     */\n+    protected Object mod(Expression left, Expression right){\n+        long l = (long)doubleValue(eval(left));\n+        long r = (long)doubleValue(eval(right));\n+        return new Double(l%r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left &lt; right\"<code>\n+     */\n+    protected Object lt(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return l < r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &gt; right\"<code>\n+     */\n+    protected Object gt(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return l > r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &lt;= right\"<code>\n+     */\n+    protected Object lte(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &gt;= right\"<code>\n+     */\n+    protected Object gte(Expression left, Expression right){\n+        double l = doubleValue(eval(left));\n+        double r = doubleValue(eval(right));\n+        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left = right\"<code>\n+     */\n+    protected Object eq(Expression left, Expression right){\n+        return equal(left, right) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left != right\"<code>\n+     */\n+    protected Object ne(Expression left, Expression right){\n+        return equal(left, right) ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Compares two values\n+     */\n+    protected boolean equal(Expression left, Expression right){\n+        Object l = eval(left);\n+        Object r = eval(right);\n+        boolean result;\n+        if (l == r){\n+            return true;\n+        }\n+\n+        if (l instanceof EvalContext && r instanceof EvalContext){\n+            Set lset = new HashSet(((EvalContext)l).valueSet());\n+            Set rset = new HashSet(((EvalContext)r).valueSet());\n+            return lset.equals(rset);\n+        }\n+\n+        if (l instanceof EvalContext){\n+            l = ((EvalContext)l).getContextNodePointer();\n+        }\n+        if (r instanceof EvalContext){\n+            r = ((EvalContext)r).getContextNodePointer();\n+        }\n+\n+        if (l instanceof Pointer && r instanceof Pointer){\n+            if (l.equals(r)){\n+                return true;\n+            }\n+        }\n+\n+        if (l instanceof Pointer){\n+            l = ((Pointer)l).getValue();\n+        }\n+        if (r instanceof Pointer){\n+            r = ((Pointer)r).getValue();\n+        }\n+\n+        if (l instanceof Boolean || r instanceof Boolean){\n+            result = (booleanValue(l) == booleanValue(r));\n+        }\n+        else if (l instanceof Number || r instanceof Number){\n+            result = (doubleValue(l) == doubleValue(r));\n+        }\n+        else if (l instanceof String || r instanceof String){\n+            result = (stringValue(l).equals(stringValue(r)));\n+        }\n+        else {\n+            result = l.equals(r);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Extracts all values from a context\n+     */\n+    private Set valueSet(){\n+        HashSet set = new HashSet();\n+        while(nextSet()){\n+            while(next()){\n+                Pointer pointer = getCurrentNodePointer();\n+                set.add(pointer.getValue());\n+            }\n+        }\n+        return set;\n+    }\n+\n+    /**\n+     * Computes <code>\"left and right\"<code>\n+     */\n+    protected Object and(Expression[] arguments){\n+        for (int i = 0; i < arguments.length; i++){\n+            if (!booleanValue(eval(arguments[i]))){\n+                return Boolean.FALSE;\n+            }\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left or right\"<code>\n+     */\n+    protected Object or(Expression[] arguments){\n+        for (int i = 0; i < arguments.length; i++){\n+            if (booleanValue(eval(arguments[i]))){\n+                return Boolean.TRUE;\n+            }\n+        }\n+        return Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Converts the supplied object to String\n+     */\n+    protected String stringValue(Object object){\n+        if (object instanceof String){\n+            return (String)object;\n+        }\n+        else if (object instanceof Number){\n+            return String.valueOf(((Number)object).doubleValue());\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? \"true\" : \"false\";\n+        }\n+        else if (object == null){\n+            return \"\";\n+        }\n+        else if (object instanceof NodePointer){\n+            return stringValue(((NodePointer)object).getValue());\n+        }\n+        else if (object instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)object;\n+            Pointer ptr = ctx.getContextNodePointer();\n+            if (ptr != null){\n+                return stringValue(ptr);\n+            }\n+            return \"\";\n+        }\n+        return String.valueOf(object);\n+    }\n+\n+    /**\n+     * Converts the supplied object to Number\n+     */\n+    protected Number number(Object object){\n+        if (object instanceof Number){\n+            return (Number)object;\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? ONE : ZERO;\n+        }\n+        else if (object instanceof String){\n+            Double value;\n+            try {\n+                value = new Double((String)object);\n+            }\n+            catch (NumberFormatException ex){\n+                value = NaN;\n+            }\n+            return value;\n+        }\n+        else if (object instanceof EvalContext){\n+            return number(stringValue(object));\n+        }\n+        else if (object instanceof NodePointer){\n+            return number(((NodePointer)object).getValue());\n+        }\n+        return ZERO;\n+    }\n+\n+    /**\n+     * Converts the supplied object to double\n+     */\n+    protected double doubleValue(Object object){\n+        if (object instanceof Number){\n+            return ((Number)object).doubleValue();\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? 0.0 : 1.0;\n+        }\n+        else if (object instanceof String){\n+            if (object.equals(\"\")){\n+                return 0.0;\n+            }\n+\n+            double value;\n+            try {\n+                value = Double.parseDouble((String)object);\n+            }\n+            catch (NumberFormatException ex){\n+                value = Double.NaN;\n+            }\n+            return value;\n+        }\n+        else if (object instanceof NodePointer){\n+            return doubleValue(((NodePointer)object).getValue());\n+        }\n+        else if (object instanceof EvalContext){\n+            return doubleValue(stringValue(object));\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Converts the supplied object to boolean\n+     */\n+    protected boolean booleanValue(Object object){\n+        if (object instanceof Number){\n+            double value = ((Number)object).doubleValue();\n+            return value != 0 && value != -0 && !Double.isNaN(value);\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue();\n+        }\n+        else if (object instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)object;\n+            return ctx.nextSet() && ctx.next();\n+        }\n+        else if (object instanceof String){\n+            return ((String)object).length() != 0;\n+        }\n+        else if (object instanceof NodePointer){\n+            return booleanValue(((NodePointer)object).getValue());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Walks a location path\n+     */\n+    protected Object path(LocationPath path, boolean firstMatch){\n+        Step steps[] = path.getSteps();\n+\n+        // Create a chain of contexts\n+        EvalContext rootContext;\n+        if (path.isAbsolute()){\n+            rootContext = getRootContext();\n+        }\n+        else {\n+            rootContext = this;\n+        }\n+        if (firstMatch){\n+            boolean basic = path.getEvaluationHint(LocationPath.BASIC_PATH_HINT) == Boolean.TRUE;\n+            if (basic){\n+//                System.err.println(\"EVALUATING BASIC PATH: \" + path);\n+                Object result = tryBasicPath(rootContext, steps);\n+                if (result != FAILURE){\n+                    return result;\n+                }\n+            }\n+        }\n+        EvalContext aContext = new InitialContext(rootContext);\n+        return evalSteps(aContext, steps, firstMatch);\n+    }\n+\n+\n+    private static final Object FAILURE = new Object();\n+    private Object tryBasicPath(EvalContext context, Step steps[]){\n+        NodePointer pointer = (NodePointer)((NodePointer)context.getContextNodePointer()).clone();\n+        for (int i = 0; i < steps.length; i++){\n+            String propertyName = ((NodeNameTest)steps[i]).getNodeName().getName();\n+            pointer = pointer.getPropertyPointer();\n+            ((PropertyPointer)pointer).setPropertyName(propertyName);\n+\n+            Expression predicates[] = steps[i].getPredicates();\n+            if (predicates != null && predicates.length != 0){\n+                boolean dynamicProperty = false;\n+                Expression expr = (Expression)predicates[0].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+                if (expr != null){\n+                    String prop = stringValue(eval(expr, true));\n+                    pointer = pointer.getPropertyPointer();\n+                    ((PropertyPointer)pointer).setPropertyName(prop);\n+                }\n+                else {\n+                    Object predicate = eval(predicates[0], true);\n+                    if (predicate instanceof EvalContext){\n+                        predicate = ((EvalContext)predicate).getContextNodePointer();\n+                    }\n+                    if (predicate instanceof Pointer){\n+                        predicate = ((Pointer)predicate).getValue();\n+                    }\n+                    if (predicate == null){\n+                        throw new RuntimeException(\"Predicate is null: \" + predicates[0]);\n+                    }\n+                    if (predicate instanceof Number){\n+                        int index = (int)(doubleValue(predicate) + 0.5);\n+                        if (index > 0 && index <= pointer.getLength()){\n+                            pointer.setIndex(index - 1);\n+                        }\n+                        else {\n+                            return null;\n+                        }\n+                    }\n+                    else if (!booleanValue(predicate)){\n+                        return null;\n+                    }\n+                }\n+            }\n+            else {\n+                return FAILURE;\n+            }\n+//            pointer = ptr;\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * Walks an expression path (a path that starts with an expression)\n+     */\n+    protected Object expressionPath(Expression expression, Expression predicates[], Step steps[], boolean firstMatch){\n+        Object value = eval(expression, false);\n+        EvalContext context;\n+        if (value instanceof InitialContext){\n+            // This is an optimization. We can avoid iterating through a collection\n+            // if the context bean is in fact one.\n+            context = (InitialContext)value;\n+        }\n+        else if (value instanceof EvalContext){\n+            // UnionContext will collect all values from the \"value\" context\n+            // and treat the whole thing as a big collection.\n+            context = new UnionContext(this, new EvalContext[]{(EvalContext)value});\n+        }\n+        else {\n+            context = getRootContext().getConstantContext(value);\n+        }\n+        if (predicates != null){\n+            for (int j = 0; j < predicates.length; j++){\n+                context = new PredicateContext(context, predicates[j]);\n+            }\n+        }\n+        return evalSteps(context, steps, firstMatch);\n+    }\n+\n+    /**\n+     * Given a root context, walks a path therefrom\n+     */\n+    private Object evalSteps(EvalContext context, Step steps[], boolean firstMatch){\n+        for (int i = 0; i < steps.length; i++){\n+            context = createContextForStep(context, steps[i]);\n+            Expression predicates[] = steps[i].getPredicates();\n+            if (predicates != null){\n+                for (int j = 0; j < predicates.length; j++){\n+                    context = new PredicateContext(context, predicates[j]);\n+                }\n+            }\n+        }\n+\n+        if (firstMatch){\n+            return context.getContextNodePointer();\n+        }\n+        else {\n+            return context;\n+        }\n+    }\n+\n+    /**\n+     * Different axes are serviced by different contexts. This method\n+     * allocates the right context for the supplied step.\n+     */\n+    protected EvalContext createContextForStep(EvalContext context, Step step){\n+        if (step instanceof NodeNameTest){\n+            QName name = ((NodeNameTest)step).getNodeName();\n+            switch(step.getAxis()){\n+                case Compiler.AXIS_ANCESTOR:\n+                    return new AncestorContext(context, false, name);\n+                case Compiler.AXIS_ANCESTOR_OR_SELF:\n+                    return new AncestorContext(context, true, name);\n+                case Compiler.AXIS_ATTRIBUTE:\n+                    break;\n+                case Compiler.AXIS_CHILD:\n+                    return new ChildContext(context, name, false, false);\n+                case Compiler.AXIS_DESCENDANT:\n+                    return new DescendantContext(context, false, name);\n+                case Compiler.AXIS_DESCENDANT_OR_SELF:\n+                    return new DescendantContext(context, true, name);\n+                case Compiler.AXIS_FOLLOWING:\n+                    return new PrecedingOrFollowingContext(context, name, false);\n+                case Compiler.AXIS_FOLLOWING_SIBLING:\n+                    return new ChildContext(context, name, true, false);\n+                case Compiler.AXIS_NAMESPACE:\n+                    break;\n+                case Compiler.AXIS_PARENT:\n+                    return new ParentContext(context, name);\n+                case Compiler.AXIS_PRECEDING:\n+                    return new PrecedingOrFollowingContext(context, name, true);\n+                case Compiler.AXIS_PRECEDING_SIBLING:\n+                    return new ChildContext(context, name, true, true);\n+                case Compiler.AXIS_SELF:\n+                    return new SelfContext(context, name);\n+            }\n+        }\n+        else if (step instanceof NodeTypeTest){\n+            switch (step.getAxis()){\n+                case Compiler.AXIS_ANCESTOR:\n+                    return new AncestorContext(context, false, null);\n+                case Compiler.AXIS_ANCESTOR_OR_SELF:\n+                    return new AncestorContext(context, true, null);\n+                case Compiler.AXIS_ATTRIBUTE:\n+                    break;\n+                case Compiler.AXIS_CHILD:\n+                    return new ChildContext(context, null, false, false);\n+                case Compiler.AXIS_DESCENDANT:\n+                    return new DescendantContext(context, false, null);\n+                case Compiler.AXIS_DESCENDANT_OR_SELF:\n+                    return new DescendantContext(context, true, null);\n+                case Compiler.AXIS_FOLLOWING:\n+                    return new PrecedingOrFollowingContext(context, null, false);\n+                case Compiler.AXIS_FOLLOWING_SIBLING:\n+                    return new ChildContext(context, null, true, false);\n+                case Compiler.AXIS_NAMESPACE:\n+                    break;\n+                case Compiler.AXIS_PARENT:\n+                    return new ParentContext(context, null);\n+                case Compiler.AXIS_PRECEDING:\n+                    return new PrecedingOrFollowingContext(context, null, true);\n+                case Compiler.AXIS_PRECEDING_SIBLING:\n+                    return new ChildContext(context, null, true, true);\n+                case Compiler.AXIS_SELF:\n+                    return context;\n+            }\n+        }\n+        throw new RuntimeException(\"Cannot create context for step: \" + step);\n+    }\n+\n+    /**\n+     * Computes an extension function\n+     */\n+    protected Object function(QName functionName, Expression[] arguments){\n+        Object[] parameters = null;\n+        if (arguments != null){\n+            parameters = new Object[arguments.length];\n+            for (int i = 0; i < arguments.length; i++){\n+                parameters[i] = eval(arguments[i]);\n+            }\n+        }\n+        Function function = getRootContext().getFunction(functionName, parameters);\n+        if (function == null){\n+            throw new RuntimeException(\"No such function: \" + functionName.asString() +\n+                 Arrays.asList(parameters));\n+        }\n+\n+        return function.invoke(parameters);\n+    }\n+\n+    /**\n+     * Computes a built-in function\n+     */\n+    protected Object coreFunction(CoreFunction function){\n+        int code = function.getFunctionCode();\n+        switch(code){\n+            case Compiler.FUNCTION_LAST:                return functionLast(function);\n+            case Compiler.FUNCTION_POSITION:            return functionPosition(function);\n+            case Compiler.FUNCTION_COUNT:               return functionCount(function);\n+\n+            case Compiler.FUNCTION_LANG:\n+            case Compiler.FUNCTION_ID:\n+            case Compiler.FUNCTION_LOCAL_NAME:\n+            case Compiler.FUNCTION_NAMESPACE_URI:{\n+                System.err.println(\"UNIMPLEMENTED: \" + function);\n+                return null;\n+            }\n+\n+            case Compiler.FUNCTION_NAME:                return functionName(function);\n+            case Compiler.FUNCTION_STRING:              return functionString(function);\n+            case Compiler.FUNCTION_CONCAT:              return functionConcat(function);\n+            case Compiler.FUNCTION_STARTS_WITH:         return functionStartsWith(function);\n+            case Compiler.FUNCTION_CONTAINS:            return functionContains(function);\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE:    return functionSubstringBefore(function);\n+            case Compiler.FUNCTION_SUBSTRING_AFTER:     return functionSubstringAfter(function);\n+            case Compiler.FUNCTION_SUBSTRING:           return functionSubstring(function);\n+            case Compiler.FUNCTION_STRING_LENGTH:       return functionStringLength(function);\n+            case Compiler.FUNCTION_NORMALIZE_SPACE:     return functionNormalizeSpace(function);\n+            case Compiler.FUNCTION_TRANSLATE:           return functionTranslate(function);\n+            case Compiler.FUNCTION_BOOLEAN:             return functionBoolean(function);\n+            case Compiler.FUNCTION_NOT:                 return functionNot(function);\n+            case Compiler.FUNCTION_TRUE:                return functionTrue(function);\n+            case Compiler.FUNCTION_FALSE:               return functionFalse(function);\n+            case Compiler.FUNCTION_NUMBER:              return functionNumber(function);\n+            case Compiler.FUNCTION_SUM:                 return functionSum(function);\n+            case Compiler.FUNCTION_FLOOR:               return functionFloor(function);\n+            case Compiler.FUNCTION_CEILING:             return functionCeiling(function);\n+            case Compiler.FUNCTION_ROUND:               return functionRound(function);\n+//            case Compiler.FUNCTION_KEY:\n+//                System.err.println(\"UNIMPLEMENTED: \" + function);\n+        }\n+        return null;\n+    }\n+\n+    protected Object functionLast(CoreFunction function){\n+        assertArgCount(function, 0);\n+        // Move the position to the beginning and iterate through\n+        // the context to count nodes.\n+        int old = getCurrentPosition();\n+        int count = 0;\n+        if (setPosition(1)){\n+            count = 1;\n+            while (next()){\n+                count++;\n+            }\n+        }\n+        // Restore the current position.\n+        if (old != 0){\n+            setPosition(old);\n+        }\n+        return new Integer(count);\n+    }\n+\n+    protected Object functionPosition(CoreFunction function){\n+        assertArgCount(function, 0);\n+        return new Integer(getCurrentPosition());\n+    }\n+\n+    protected Object functionCount(CoreFunction function){\n+        assertArgCount(function, 1);\n+        Expression arg1 = function.getArg1();\n+        int count = 0;\n+        Object value = eval(arg1, false);\n+        if (value instanceof Pointer){\n+            value = ((Pointer)value).getValue();\n+        }\n+        if (value instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)value;\n+            while(ctx.nextSet()){\n+                while(ctx.next()){\n+                    count++;\n+                }\n+            }\n+        }\n+        else if (value instanceof Collection){\n+            count = ((Collection)value).size();\n+        }\n+        else if (value == null){\n+            count = 0;\n+        }\n+        else {\n+            count = 1;\n+        }\n+        return new Double(count);\n+    }\n+\n+    protected Object functionName(CoreFunction function){\n+        if (function.getArgumentCount() == 0){\n+            return getCurrentNodePointer();\n+        }\n+        assertArgCount(function, 1);\n+        Object set = eval(function.getArg1(), false);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.nextSet() && ctx.next()){\n+                return ctx.getCurrentNodePointer().getName().asString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionString(CoreFunction function){\n+        if (function.getArgumentCount() == 0){\n+            return stringValue(getCurrentNodePointer());\n+        }\n+        assertArgCount(function, 1);\n+        return stringValue(eval(function.getArg1()));\n+    }\n+\n+    protected Object functionConcat(CoreFunction function){\n+        if (function.getArgumentCount() < 2){\n+            assertArgCount(function, 2);\n+        }\n+        StringBuffer buffer = new StringBuffer();\n+        Expression args[] = function.getArguments();\n+        for (int i = 0; i < args.length; i++){\n+            buffer.append(stringValue(eval(args[i])));\n+        }\n+        return buffer.toString();\n+    }\n+\n+    protected Object functionStartsWith(CoreFunction function){\n+        assertArgCount(function, 2);\n+        String s1 = stringValue(eval(function.getArg1()));\n+        String s2 = stringValue(eval(function.getArg2()));\n+        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionContains(CoreFunction function){\n+        assertArgCount(function, 2);\n+        String s1 = stringValue(eval(function.getArg1()));\n+        String s2 = stringValue(eval(function.getArg2()));\n+        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionSubstringBefore(CoreFunction function){\n+        assertArgCount(function, 2);\n+        String s1 = stringValue(eval(function.getArg1()));\n+        String s2 = stringValue(eval(function.getArg2()));\n+        int index = s1.indexOf(s2);\n+        if (index == -1){\n+            return \"\";\n+        }\n+        return s1.substring(0, index);\n+    }\n+\n+    protected Object functionSubstringAfter(CoreFunction function){\n+        assertArgCount(function, 2);\n+        String s1 = stringValue(eval(function.getArg1()));\n+        String s2 = stringValue(eval(function.getArg2()));\n+        int index = s1.indexOf(s2);\n+        if (index == -1){\n+            return \"\";\n+        }\n+        return s1.substring(index + s2.length());\n+    }\n+\n+    protected Object functionSubstring(CoreFunction function){\n+        int ac = function.getArgumentCount();\n+        if (ac != 2 && ac != 3){\n+            assertArgCount(function, 2);\n+        }\n+\n+        String s1 = stringValue(eval(function.getArg1()));\n+        double from = doubleValue(eval(function.getArg2()));\n+        if (Double.isNaN(from)){\n+            return \"\";\n+        }\n+\n+        from = Math.round(from);\n+        if (ac == 2){\n+            if (from < 1){\n+                from = 1;\n+            }\n+            return s1.substring((int)from - 1);\n+        }\n+        else {\n+            double length = doubleValue(eval(function.getArg3()));\n+            length = Math.round(length);\n+            if (length < 0){\n+                return \"\";\n+            }\n+\n+            double to = from + length;\n+            if (to < 1){\n+                return \"\";\n+            }\n+\n+            if (to > s1.length() + 1){\n+                if (from < 1){\n+                    from = 1;\n+                }\n+                return s1.substring((int)from - 1);\n+            }\n+\n+            if (from < 1){\n+                from = 1;\n+            }\n+            return s1.substring((int)from - 1, (int)(to - 1));\n+        }\n+    }\n+\n+    protected Object functionStringLength(CoreFunction function){\n+        String s;\n+        if (function.getArgumentCount() == 0){\n+            s = stringValue(getCurrentNodePointer());\n+        }\n+        else {\n+            assertArgCount(function, 1);\n+            s = stringValue(eval(function.getArg1()));\n+        }\n+        return new Double(s.length());\n+    }\n+\n+    protected Object functionNormalizeSpace(CoreFunction function){\n+        assertArgCount(function, 1);\n+        String s = stringValue(eval(function.getArg1()));\n+        char chars[] = s.toCharArray();\n+        int out = 0;\n+        int phase = 0;\n+        for (int in = 0; in < chars.length; in++){\n+            switch(chars[in]){\n+                case 0x20:\n+                case 0x9:\n+                case 0xD:\n+                case 0xA:\n+                    if (phase == 0){      // beginning\n+                        ;\n+                    }\n+                    else if (phase == 1){ // non-space\n+                        phase = 2;\n+                        chars[out++] = ' ';\n+                    }\n+                    break;\n+                default:\n+                    chars[out++] = chars[in];\n+                    phase = 1;\n+            }\n+        }\n+        if (phase == 2){ // trailing-space\n+            out--;\n+        }\n+        return new String(chars, 0, out);\n+    }\n+\n+    protected Object functionTranslate(CoreFunction function){\n+        assertArgCount(function, 3);\n+        String s1 = stringValue(eval(function.getArg1()));\n+        String s2 = stringValue(eval(function.getArg2()));\n+        String s3 = stringValue(eval(function.getArg3()));\n+        char chars[] = s1.toCharArray();\n+        int out = 0;\n+        for (int in = 0; in < chars.length; in++){\n+            char c = chars[in];\n+            int inx = s2.indexOf(c);\n+            if (inx != -1){\n+                if (inx < s3.length()){\n+                    chars[out++] = s3.charAt(inx);\n+                }\n+            }\n+            else {\n+                chars[out++] = c;\n+            }\n+        }\n+        return new String(chars, 0, out);\n+    }\n+\n+    protected Object functionBoolean(CoreFunction function){\n+        assertArgCount(function, 1);\n+        return booleanValue(eval(function.getArg1())) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionNot(CoreFunction function){\n+        assertArgCount(function, 1);\n+        return booleanValue(eval(function.getArg1())) ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n+    protected Object functionTrue(CoreFunction function){\n+        assertArgCount(function, 0);\n+        return Boolean.TRUE;\n+    }\n+\n+    protected Object functionFalse(CoreFunction function){\n+        assertArgCount(function, 0);\n+        return Boolean.FALSE;\n+    }\n+\n+    protected Object functionNumber(CoreFunction function){\n+        if (function.getArgumentCount() == 0){\n+            return number(getCurrentNodePointer());\n+        }\n+        assertArgCount(function, 1);\n+        return number(eval(function.getArg1()));\n+    }\n+\n+    protected Object functionSum(CoreFunction function){\n+        assertArgCount(function, 1);\n+        Object v = eval(function.getArg1(), false);\n+        if (v == null){\n+            return ZERO;\n+        }\n+        else if (v instanceof EvalContext){\n+            double sum = 0.0;\n+            EvalContext ctx = (EvalContext)v;\n+            while (ctx.nextSet()){\n+                while (ctx.next()){\n+                    sum += doubleValue(ctx.getCurrentNodePointer());\n+                }\n+            }\n+            return new Double(sum);\n+        }\n+        throw new RuntimeException(\"Invalid argument type for 'sum': \" + v.getClass().getName());\n+    }\n+\n+    protected Object functionFloor(CoreFunction function){\n+        assertArgCount(function, 1);\n+        double v = doubleValue(eval(function.getArg1()));\n+        return new Double(Math.floor(v));\n+    }\n+\n+    protected Object functionCeiling(CoreFunction function){\n+        assertArgCount(function, 1);\n+        double v = doubleValue(eval(function.getArg1()));\n+        return new Double(Math.ceil(v));\n+    }\n+\n+    protected Object functionRound(CoreFunction function){\n+        assertArgCount(function, 1);\n+        double v = doubleValue(eval(function.getArg1()));\n+        return new Double(Math.round(v));\n+    }\n+\n+    private void assertArgCount(CoreFunction function, int count){\n+        if (function.getArgumentCount() != count){\n+            throw new RuntimeException(\"Incorrect number of argument: \" + function);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import org.apache.commons.jxpath.JXPathContextFactory;\n+import org.apache.commons.jxpath.JXPathContextFactoryConfigurationError;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Variables;\n+\n+/**\n+ * Default implementation of JXPathContextFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class JXPathContextFactoryReferenceImpl extends JXPathContextFactory {\n+\n+    public JXPathContextFactoryReferenceImpl(){\n+    }\n+\n+    public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError {\n+        return new JXPathContextReferenceImpl(parentContext, contextBean);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.Variables;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.Functions;\n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.PackageFunctions;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import java.lang.ref.SoftReference;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class JXPathContextReferenceImpl extends JXPathContext\n+{\n+    private static final Compiler compiler = new TreeCompiler();\n+    private static final Map compiled = new HashMap();\n+    private static final PackageFunctions genericFunctions = new PackageFunctions(\"\", null);\n+    private static boolean useSoftCache = true;\n+    private static int cleanupCount = 0;\n+\n+    // The frequency of the cache cleanup\n+    private static final int CLEANUP_THRESHOLD = 500;\n+\n+    protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean){\n+        super(parentContext, contextBean);\n+    }\n+\n+    private static Expression compile(String xpath){\n+        Expression expr;\n+        if (useSoftCache){\n+            expr = null;\n+            SoftReference ref = (SoftReference)compiled.get(xpath);\n+            if (ref != null){\n+                expr = (Expression)ref.get();\n+            }\n+            if (expr == null){\n+                expr = (Expression)Parser.parseExpression(xpath, compiler);\n+                expr.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                compiled.put(xpath, new SoftReference(expr));\n+                if (cleanupCount++ >= CLEANUP_THRESHOLD){\n+                    cleanupCache();\n+                }\n+            }\n+        }\n+        else {\n+            expr = (Expression)compiled.get(xpath);\n+            if (expr == null){\n+                expr = (Expression)Parser.parseExpression(xpath, compiler);\n+                expr.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                compiled.put(xpath, expr);\n+            }\n+        }\n+//        }\n+        return expr;\n+    }\n+\n+    private static void cleanupCache(){\n+        System.gc();\n+        Iterator it = compiled.entrySet().iterator();\n+        while (it.hasNext()){\n+            Map.Entry me = (Map.Entry)it.next();\n+            if (((SoftReference)me.getValue()).get() == null){\n+                it.remove();\n+            }\n+        }\n+        cleanupCount = 0;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns the resulting object. Primitive\n+     * types are wrapped into objects.\n+     */\n+    public Object getValue(String xpath){\n+        Object result = eval(xpath, true);\n+        if (result instanceof NodePointer){\n+            result = ((NodePointer)result).getValue();\n+        }\n+        else if (result instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)result;\n+            while(ctx.nextSet()){\n+                if (ctx.next()){\n+                    result = ctx.getCurrentNodePointer().getValue();\n+                    break;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns a List of objects. Even if\n+     * there is only one object that matches the xpath, it will be returned\n+     * as a collection with one element.  If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public List eval(String xpath){\n+        Object result = eval(xpath, false);\n+        List list = new ArrayList();\n+        if (result instanceof EvalContext){\n+            EvalContext context = (EvalContext)result;\n+            while(context.nextSet()){\n+                while(context.next()){\n+                    Pointer pointer = context.getCurrentNodePointer();\n+                    list.add(pointer.getValue());\n+                }\n+            }\n+        }\n+        else if (result instanceof Pointer){\n+            list.add(((Pointer)result).getValue());\n+        }\n+        else {\n+            list.add(result);\n+        }\n+        return list;\n+    }\n+\n+    public Pointer locateValue(String xpath){\n+        Object result = eval(xpath, true);\n+        if (result instanceof Pointer){\n+            return (Pointer)result;\n+        }\n+        else {\n+            return NodePointer.createNodePointer(null, result);\n+        }\n+    }\n+\n+    /**\n+     */\n+    public void setValue(String xpath, Object value){\n+        Object result = eval(xpath, true);\n+        if (result instanceof Pointer){\n+            ((Pointer)result).setValue(value);\n+        }\n+        else if (result instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)result;\n+            while(ctx.nextSet()){\n+                if (ctx.next()){\n+                    ctx.getCurrentNodePointer().setValue(value);\n+                    return;\n+                }\n+            }\n+            throw new RuntimeException(\"Cannot set value for xpath: \" + xpath + \": no such property\");\n+        }\n+        else {\n+            System.err.println(\"RESULT: \" + result);\n+            throw new RuntimeException(\"Cannot set value for xpath: \" + xpath);\n+        }\n+    }\n+\n+    public List locate(String xpath){\n+        Object result = eval(xpath, false);\n+        List list = new ArrayList();\n+        if (result instanceof EvalContext){\n+            EvalContext context = (EvalContext)result;\n+            while(context.nextSet()){\n+                while(context.next()){\n+                    Pointer pointer = context.getCurrentNodePointer();\n+                    list.add(pointer);\n+                }\n+            }\n+        }\n+        else if (result instanceof Pointer){\n+            list.add((Pointer)result);\n+        }\n+        else {\n+            list.add(NodePointer.createNodePointer(null, result));\n+        }\n+        return list;\n+    }\n+\n+    private Object eval(String xpath, boolean firstMatchLookup) {\n+        Expression expr = compile(xpath);\n+        NodePointer pointer = NodePointer.createNodePointer(new QName(null, \"root\"), getContextBean());\n+        EvalContext ctx = new RootContext(this, pointer);\n+//        System.err.println(\"XPATH = \" + xpath);\n+        return ctx.eval(expr, firstMatchLookup);\n+    }\n+\n+    private List resolveNodeSet(List list){\n+        List result = new ArrayList();\n+        for (int i = 0; i < list.size(); i++){\n+            Object element = list.get(i);\n+            if (element instanceof NodePointer){\n+                element = ((NodePointer)element).getValue();\n+            }\n+            result.add(element);\n+        }\n+        return result;\n+    }\n+\n+    public NodePointer getVariablePointer(QName name){\n+        String varName = name.asString();\n+        JXPathContext varCtx = this;\n+        Variables vars = null;\n+        while (varCtx != null){\n+            vars = varCtx.getVariables();\n+            if (vars.isDeclaredVariable(varName)){\n+                break;\n+            }\n+            varCtx = varCtx.getParentContext();\n+            vars = null;\n+        }\n+        if (vars != null){\n+            return new VariablePointer(vars, name);\n+        }\n+        else {\n+            throw new RuntimeException(\"Undefined variable: \" + varName);\n+        }\n+    }\n+\n+    public Function getFunction(QName functionName, Object[] parameters){\n+        String namespace = functionName.getPrefix();\n+        String name = functionName.getName();\n+        JXPathContext funcCtx = this;\n+        Function func = null;\n+        Functions funcs;\n+        while (funcCtx != null){\n+            funcs = funcCtx.getFunctions();\n+            func = funcs.getFunction(namespace, name, parameters);\n+            if (func != null){\n+                return func;\n+            }\n+\n+            funcCtx = funcCtx.getParentContext();\n+        }\n+        func = genericFunctions.getFunction(namespace, name, parameters);\n+        if (func != null){\n+            return func;\n+        }\n+        throw new RuntimeException(\"Undefined function: \" + functionName.asString());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Parser.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.parser.XPathParser;\n+import org.apache.commons.jxpath.ri.parser.ParseException;\n+import java.util.*;\n+import java.io.StringReader;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class Parser {\n+\n+    private static XPathParser parser;\n+\n+    public static Object parseExpression(String expression, Compiler compiler){\n+        if (parser == null){\n+            parser = new XPathParser(new StringReader(\"\"));\n+        }\n+\n+        parser.setCompiler(compiler);\n+        parser.ReInit(new StringReader(expression));\n+\n+        Object expr = null;\n+        try {\n+            expr = parser.parseExpression();\n+        }\n+        catch (ParseException e) {\n+            System.err.println(\"Failed: \" + expression );\n+            e.printStackTrace();\n+        }\n+        return expr;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+\n+import java.util.*;\n+\n+/**\n+ * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class AncestorContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean setStarted = false;\n+    private boolean started = false;\n+    private NodePointer currentNodePointer;\n+    private boolean includeSelf;\n+\n+    /**\n+     * @param parentContext represents the previous step on the path\n+     * @param includeSelf differentiates between \"ancestor::\" and \"ancestor-or-self::\" axes\n+     * @param nameTest is the name of the element(s) we are looking for\n+     */\n+    public AncestorContext(EvalContext parentContext, boolean includeSelf, QName nameTest){\n+        super(parentContext);\n+        this.includeSelf = includeSelf;\n+        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n+            this.nameTest = nameTest;\n+        }\n+        reset();\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (position < this.position){\n+            reset();\n+        }\n+\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean nextSet(){\n+        reset();\n+\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean nextIgnoreDuplicates(){\n+        if (!setStarted){\n+            setStarted = true;\n+            currentNodePointer = (NodePointer)parentContext.getContextNodePointer();\n+            if (includeSelf){\n+                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        currentNodePointer = currentNodePointer.getParent();\n+        if (currentNodePointer == null){\n+            return false;\n+        }\n+\n+        if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Back to position=0\n+     */\n+    protected void reset(){\n+        super.reset();\n+        setStarted = false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * EvalContext that can walk the \"child::\", \"following-sibling::\" and\n+ * \"preceding-sibling::\" axes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class ChildContext extends EvalContext {\n+    private boolean started = false;\n+    private QName property;\n+    boolean startFromParentLocation;\n+    boolean reverse;\n+    private PropertyIterator iterator;\n+\n+    public ChildContext(EvalContext parentContext, QName property, boolean startFromParentLocation, boolean reverse){\n+        super(parentContext);\n+        this.property = property;\n+        this.startFromParentLocation = startFromParentLocation;\n+        this.reverse = reverse;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return iterator.getCurrentNodePointer();\n+    }\n+\n+    /**\n+     * This method is called on the last context on the path when only\n+     * one value is needed.  Note that this will return the whole property,\n+     * even if it is a collection. It will not extract the first element\n+     * of the collection.  For example, \"books\" will return the collection\n+     * of books rather than the first book from that collection.\n+     */\n+    public Pointer getContextNodePointer(){\n+        if (iterator == null){\n+            boolean ok = false;\n+            while(parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    ok = true;\n+                    break;\n+                }\n+            }\n+            if (!ok){\n+                return null;\n+            }\n+            prepare();\n+        }\n+        return iterator.getFirstNodePointer();\n+    }\n+\n+    public boolean next(){\n+        if (iterator == null){\n+            prepare();\n+        }\n+        return iterator.next();\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (iterator == null){\n+            prepare();\n+        }\n+        return iterator.setPosition(position);\n+    }\n+\n+    public int getCurrentPosition(){\n+        return iterator.getCurrentPosition();\n+    }\n+\n+    public boolean nextSet(){\n+        iterator = null;\n+\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Allocates a PropertyIterator.\n+     */\n+    private void prepare(){\n+        String name;\n+        if (property == null || property.getName().equals(\"*\")){\n+            name = null;\n+        }\n+        else {\n+            name = property.getName();\n+        }\n+        if (startFromParentLocation){\n+            // TBD: check type\n+            PropertyPointer parent = (PropertyPointer)parentContext.getCurrentNodePointer();\n+            iterator = PropertyIterator.iteratorStartingAt(parent, name, reverse);\n+        }\n+        else {\n+            iterator = PropertyIterator.iterator(parentContext.getCurrentNodePointer(), name, reverse);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import java.util.*;\n+\n+/**\n+ * An EvalContext that walks the \"descendant::\" and \"descendant-or-self::\"\n+ * axes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class DescendantContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean setStarted = false;\n+    private boolean started = false;\n+    private Stack stack;\n+    private NodePointer currentNodePointer;\n+    private boolean includeSelf;\n+\n+    public DescendantContext(EvalContext parentContext, boolean includeSelf, QName nameTest){\n+        super(parentContext);\n+        this.includeSelf = includeSelf;\n+        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n+            this.nameTest = nameTest;\n+        }\n+        reset();\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (position < this.position){\n+            reset();\n+        }\n+\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean nextSet(){\n+        reset();\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean next(){\n+        if (!setStarted){\n+            setStarted = true;\n+            currentNodePointer = parentContext.getCurrentNodePointer();\n+            if (!currentNodePointer.isAtomic()){\n+                stack.push(PropertyIterator.iterator(currentNodePointer, null, false));\n+            }\n+            if (includeSelf){\n+                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                    position++;\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        while (!stack.isEmpty()){\n+            PropertyIterator it = (PropertyIterator)stack.peek();\n+            if (it.next()){\n+                currentNodePointer = it.getCurrentNodePointer();\n+                if (!currentNodePointer.isAtomic()){\n+                    stack.push(PropertyIterator.iterator(currentNodePointer, null, false));\n+                }\n+                if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                    position++;\n+                    return true;\n+                }\n+            }\n+            else {\n+                // We get here only if the name test failed and the iterator ended\n+                stack.pop();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected void reset(){\n+        super.reset();\n+        stack = new Stack();\n+        setStarted = false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class InitialContext extends EvalContext {\n+    private boolean startedSet = false;\n+    private boolean started = false;\n+    private boolean collection;\n+    private NodePointer nodePointer;\n+\n+    public InitialContext(EvalContext parentContext){\n+        super(parentContext);\n+        nodePointer = (NodePointer)parentContext.getCurrentNodePointer().clone();\n+        position = 0;\n+        collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return nodePointer;\n+    }\n+\n+    public boolean next(){\n+        return setPosition(position + 1);\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        if (collection){\n+            if (position >= 1 && position <= nodePointer.getLength()){\n+                nodePointer.setIndex(position - 1);\n+                return true;\n+            }\n+            return false;\n+        }\n+        else {\n+            return position == 1;\n+        }\n+    }\n+\n+    public boolean nextSet(){\n+        if (started){\n+            return false;\n+        }\n+        started = true;\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class ParentContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean setStarted = false;\n+    private boolean started = false;\n+    private NodePointer currentNodePointer;\n+    private HashSet visitedNodes = new HashSet();\n+\n+    public ParentContext(EvalContext parentContext, QName nameTest){\n+        super(parentContext);\n+        if (nameTest != null && nameTest.getName() != \"*\"){\n+            this.nameTest = nameTest;\n+        }\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public int getCurrentPosition(){\n+        return 1;\n+    }\n+\n+    public boolean setPosition(int position){\n+        return position == 1;\n+    }\n+\n+    public boolean nextSet(){\n+        setStarted = false;\n+\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (nextParent()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (nextParent()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (nextParent()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean nextParent(){\n+        while (parentContext.next()){\n+            NodePointer thisLocation = parentContext.getCurrentNodePointer();\n+            currentNodePointer = thisLocation.getParent();\n+            if (currentNodePointer != null && !visitedNodes.contains(currentNodePointer)){\n+                if (nameTest == null || currentNodePointer.getName().equals(nameTest)){\n+                    visitedNodes.add(currentNodePointer.clone());\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean next(){\n+        // Each set contains exactly one node: the parent\n+        if (setStarted){\n+            return false;\n+        }\n+        setStarted = true;\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class PrecedingOrFollowingContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean setStarted = false;\n+    private boolean started = false;\n+    private Stack stack;\n+    private Stack nameStack;\n+    private NodePointer currentNodePointer;\n+    private NodePointer currentRootLocation;\n+    private boolean includeSelf;\n+    private boolean reverse;\n+\n+    public PrecedingOrFollowingContext(EvalContext parentContext, QName nameTest, boolean reverse){\n+        super(parentContext);\n+        this.includeSelf = includeSelf;\n+        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n+            this.nameTest = nameTest;\n+        }\n+        this.reverse = reverse;\n+        reset();\n+    }\n+\n+    protected void reset(){\n+        super.reset();\n+        stack = new Stack();\n+        setStarted = false;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (position < this.position){\n+            reset();\n+        }\n+\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean nextSet(){\n+        reset();\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean next(){\n+        if (!setStarted){\n+            setStarted = true;\n+            currentRootLocation = parentContext.getCurrentNodePointer();\n+            // TBD: check type\n+            stack.push(PropertyIterator.iteratorStartingAt((PropertyPointer)currentRootLocation, null, reverse));\n+        }\n+\n+        while (true){\n+            if (stack.isEmpty()){\n+                currentRootLocation = currentRootLocation.getParent();\n+                if (currentRootLocation == null || currentRootLocation.isRoot()){\n+                    break;\n+                }\n+//                System.err.println(\"PUSHING: \" + currentRootLocation);\n+                // TBD: check type\n+                stack.push(PropertyIterator.iteratorStartingAt((PropertyPointer)currentRootLocation, null, reverse));\n+            }\n+\n+            while (!stack.isEmpty()){\n+                if (!reverse){\n+                    PropertyIterator it = (PropertyIterator)stack.peek();\n+                    if (it.next()){\n+                        currentNodePointer = it.getCurrentNodePointer();\n+                        if (!currentNodePointer.isAtomic()){\n+                            stack.push(PropertyIterator.iterator(currentNodePointer, null, reverse));\n+                        }\n+                        if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                            position++;\n+                            return true;\n+                        }\n+                    }\n+                    else {\n+                        // We get here only if the name test failed and the iterator ended\n+                        stack.pop();\n+                    }\n+                }\n+                else {\n+                    PropertyIterator it = (PropertyIterator)stack.peek();\n+                    if (it.next()){\n+                        currentNodePointer = it.getCurrentNodePointer();\n+                        if (!currentNodePointer.isAtomic()){\n+                            stack.push(PropertyIterator.iterator(currentNodePointer, null, reverse));\n+                        }\n+                        else if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                            position++;\n+                            return true;\n+                        }\n+                    }\n+                    else {\n+                        stack.pop();\n+                        if (!stack.isEmpty()){\n+                            it = (PropertyIterator)stack.peek();\n+                            currentNodePointer = it.getCurrentNodePointer();\n+                            if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n+                                position++;\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class PredicateContext extends EvalContext {\n+    private Expression expression;\n+    private boolean done = false;\n+    private Expression dynamicPropertyNameExpression;\n+    private PropertyPointer dynamicPropertyPointer;\n+\n+    public PredicateContext(EvalContext parentContext, Expression expression){\n+        super(parentContext);\n+        this.expression = expression;\n+        dynamicPropertyNameExpression = (Expression)expression.\n+            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+    }\n+\n+    public int getCurrentPosition(){\n+        return position;\n+    }\n+\n+    public boolean next(){\n+        if (done){\n+            return false;\n+        }\n+        while (parentContext.next()){\n+            if (dynamicPropertyNameExpression != null){\n+                dynamicPropertyPointer = parentContext.getCurrentNodePointer().getPropertyPointer();\n+                Object pred = parentContext.eval(dynamicPropertyNameExpression);\n+                if (pred instanceof NodePointer){\n+                    pred = ((NodePointer)pred).getValue();\n+                }\n+                dynamicPropertyPointer.setPropertyName(String.valueOf(pred));\n+                done = true;\n+                return true;\n+            }\n+            else {\n+                Object pred = parentContext.eval(expression);\n+                if (pred instanceof NodePointer){\n+                    pred = ((NodePointer)pred).getValue();\n+                }\n+                if (pred instanceof Number){\n+                    int pos = (int)doubleValue(pred);\n+                    position++;\n+                    done = true;\n+                    return parentContext.setPosition(pos);\n+                }\n+                else if (booleanValue(pred)){\n+                    position++;\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        if (dynamicPropertyPointer != null){\n+            return dynamicPropertyPointer;\n+        }\n+        else {\n+            return parentContext.getCurrentNodePointer();\n+        }\n+    }\n+\n+    public boolean nextSet(){\n+        position = 0;\n+        done = false;\n+        return parentContext.nextSet();\n+    }\n+\n+    public boolean setPosition(int position){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PropertyIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/Attic/PropertyIterator.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class PropertyIterator {\n+    boolean empty = false;\n+    private boolean reverse;\n+    private String name;\n+    private int startIndex = 0;\n+    private boolean targetReady = false;\n+    private int position = 0;\n+    private PropertyPointer propertyNodePointer;\n+    private int startPropertyIndex;\n+\n+    private boolean ready = false;\n+    private boolean includeStart = false;\n+\n+    public static PropertyIterator iterator(NodePointer parentLocation, String name, boolean reverse){\n+        return new PropertyIterator(parentLocation, name, reverse);\n+    }\n+\n+    public static PropertyIterator iteratorStartingAt(PropertyPointer startLocation, String name, boolean reverse){\n+        return new PropertyIterator(name, reverse, startLocation);\n+    }\n+\n+    protected PropertyIterator(NodePointer parent, String name, boolean reverse){\n+        propertyNodePointer = parent.getPropertyPointer();\n+        this.name = name;\n+        this.reverse = reverse;\n+        this.includeStart = true;\n+        if (reverse){\n+            this.startPropertyIndex = -1;\n+            this.startIndex = -1;\n+        }\n+    }\n+\n+    protected PropertyIterator(String name, boolean reverse, PropertyPointer startLocation){\n+        this.propertyNodePointer = startLocation.copy();\n+        this.name = name;\n+        this.reverse = reverse;\n+        this.startPropertyIndex = startLocation.getPropertyIndex();\n+        this.startIndex = startLocation.getIndex();\n+        this.includeStart = false;\n+        if (reverse && startIndex == -1){\n+            this.includeStart = true;\n+        }\n+    }\n+\n+    public void reset(){\n+        position = 0;\n+        targetReady = false;\n+    }\n+\n+    public PropertyPointer getCurrentNodePointer(){\n+        return propertyNodePointer.copy();\n+    }\n+\n+    public NodePointer getFirstNodePointer(){\n+        if (name != null){\n+            if (!targetReady){\n+                prepare();\n+            }\n+            // If there is no such property - return null\n+            if (empty){\n+                return null;\n+            }\n+        }\n+        else {\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n+        return getCurrentNodePointer();\n+    }\n+\n+    public int getCurrentPosition(){\n+        return position;\n+    }\n+\n+    public boolean next(){\n+        return setPosition(position + 1);\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (name != null){\n+            return setPositionIndividual(position);\n+        }\n+        else {\n+            return setPositionMultiple(position);\n+        }\n+    }\n+\n+    private boolean setPositionIndividual(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        if (!targetReady){\n+            prepare();\n+        }\n+\n+        if (empty){\n+            return false;\n+        }\n+\n+        int length = propertyNodePointer.getLength();\n+        int index;\n+        if (!reverse){\n+            index = position + startIndex;\n+            if (!includeStart){\n+                index++;\n+            }\n+            if (index > length){\n+                return false;\n+            }\n+        }\n+        else {\n+            int end = startIndex;\n+            if (end == -1){\n+                end = length - 1;\n+            }\n+            index = end - position + 2;\n+            if (!includeStart){\n+                index--;\n+            }\n+            if (index < 1){\n+                return false;\n+            }\n+        }\n+        propertyNodePointer.setIndex(index - 1);\n+        return true;\n+    }\n+\n+    private boolean setPositionMultiple(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        int offset;\n+        int count = propertyNodePointer.getPropertyCount();\n+        if (!reverse){\n+            int index = 1;\n+            for (int i = startPropertyIndex; i < count; i++){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    length -= startIndex;\n+                    if (!includeStart){\n+                        length--;\n+                    }\n+                    offset = startIndex + position - index;\n+                    if (!includeStart){\n+                        offset++;\n+                    }\n+                }\n+                else {\n+                    offset = position - index;\n+                }\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        else {\n+            int index = 1;\n+            int start = startPropertyIndex;\n+            if (start == -1){\n+                start = count - 1;\n+            }\n+            for (int i = start; i >= 0; i--){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    int end = startIndex;\n+                    if (end == -1){\n+                        end = length - 1;\n+                    }\n+                    length = end + 1;\n+                    offset = end - position + 1;\n+                    if (!includeStart){\n+                        offset--;\n+                        length--;\n+                    }\n+                }\n+                else {\n+                    offset = length - (position - index) - 1;\n+                }\n+\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void prepare(){\n+        targetReady = true;\n+        empty = true;\n+        if (propertyNodePointer instanceof DynamicPropertyPointer){\n+            propertyNodePointer.setPropertyName(name);\n+        }\n+\n+        String names[] = propertyNodePointer.getPropertyNames();\n+        if (!reverse){\n+            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == NodePointer.UNSPECIFIED){\n+                startPropertyIndex = 0;\n+            }\n+            if (propertyNodePointer.getIndex() == NodePointer.WHOLE_COLLECTION){\n+                startIndex = 0;\n+            }\n+            for (int i = startPropertyIndex; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = 0;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+        else {\n+            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == NodePointer.UNSPECIFIED){\n+                startPropertyIndex = names.length - 1;\n+            }\n+            if (propertyNodePointer.getIndex() == NodePointer.WHOLE_COLLECTION){\n+                startIndex = -1;\n+            }\n+            for (int i = startPropertyIndex; i >= 0; i--){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = -1;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n+import org.apache.commons.jxpath.Function;\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class RootContext extends EvalContext {\n+    private boolean startedSet = false;\n+    private boolean started = false;\n+    private JXPathContextReferenceImpl parent;\n+    private NodePointer pointer;\n+    private Object registers[];\n+    private int availableRegister = 0;\n+    public static final Object UNKNOWN_VALUE = new Object();\n+    private static final int MAX_REGISTER = 4;\n+\n+    public RootContext(JXPathContextReferenceImpl parent, NodePointer pointer){\n+        super(null);\n+        this.parent = parent;\n+        this.pointer = pointer;\n+    }\n+\n+    public RootContext getRootContext(){\n+        return this;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return pointer;\n+    }\n+\n+    public int getCurrentPosition(){\n+        return 1;\n+    }\n+\n+    public boolean next(){\n+        if (started){\n+            return false;\n+        }\n+        started = true;\n+        return true;\n+    }\n+\n+    public boolean nextSet(){\n+        if (startedSet){\n+            return false;\n+        }\n+        startedSet = true;\n+        return true;\n+    }\n+\n+    public boolean setPosition(int position){\n+        return position == 1;\n+    }\n+\n+    public EvalContext getConstantContext(Object constant){\n+        NodePointer pointer = NodePointer.createNodePointer(new QName(null, \"\"), constant);\n+        return new InitialContext(new RootContext(parent, pointer));\n+    }\n+\n+    public EvalContext getVariableContext(QName variableName){\n+        return new InitialContext(new RootContext(parent, parent.getVariablePointer(variableName)));\n+    }\n+\n+    public Function getFunction(QName functionName, Object[] parameters){\n+        return parent.getFunction(functionName, parameters);\n+    }\n+\n+    public Object getRegisteredValue(int id){\n+        if (registers == null || id >= MAX_REGISTER || id == -1){\n+            return UNKNOWN_VALUE;\n+        }\n+        return registers[id];\n+    }\n+\n+    public int setRegisteredValue(Object value){\n+        if (registers == null){\n+            registers = new Object[MAX_REGISTER];\n+            for (int i = 0; i < MAX_REGISTER; i++){\n+                registers[i] = UNKNOWN_VALUE;\n+            }\n+        }\n+        if (availableRegister >= MAX_REGISTER){\n+            return -1;\n+        }\n+        registers[availableRegister] = value;\n+        availableRegister++;\n+        return availableRegister-1;\n+    }\n+\n+    public String toString(){\n+        return super.toString() + \":\" + pointer.asPath();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class SelfContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean startedSet = false;\n+    private boolean started = false;\n+\n+    public SelfContext(EvalContext parentContext, QName nameTest){\n+        super(parentContext);\n+        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n+            this.nameTest = nameTest;\n+        }\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return parentContext.getCurrentNodePointer();\n+    }\n+\n+    public int getCurrentPosition(){\n+        return 1;\n+    }\n+\n+    public boolean setPosition(int position){\n+        return position == 1;\n+    }\n+\n+    public boolean nextSet(){\n+        startedSet = false;\n+\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public boolean next(){\n+        if (startedSet){\n+            return false;\n+        }\n+\n+        startedSet = true;\n+\n+        if (nameTest != null){\n+            return nameTest.equals(getCurrentNodePointer().getName());\n+        }\n+\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import java.util.*;\n+\n+/**\n+ * EvalContext that represents a union between other contexts - result\n+ * of a union operation like (a | b)\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class UnionContext extends EvalContext {\n+    private boolean startedSet = false;\n+    private EvalContext contexts[];\n+    private List list;\n+\n+    public UnionContext(EvalContext parentContext, EvalContext contexts[]){\n+        super(parentContext);\n+        this.contexts = contexts;\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return (NodePointer)list.get(position - 1);\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        if (list == null){\n+            prepareList();\n+        }\n+        return position >= 1 && position <= list.size();\n+    }\n+\n+    public boolean nextSet(){\n+        if (startedSet){\n+            return false;\n+        }\n+        startedSet = true;\n+        return true;\n+    }\n+\n+    public boolean next(){\n+        return setPosition(position + 1);\n+    }\n+\n+    private void prepareList(){\n+        list = new ArrayList();\n+        HashSet set = new HashSet();\n+        for (int i = 0; i < contexts.length; i++){\n+            EvalContext ctx = (EvalContext)contexts[i];\n+            while (ctx.nextSet()){\n+                while (ctx.next()){\n+                    NodePointer ptr = ctx.getCurrentNodePointer();\n+                    if (!set.contains(ptr)){\n+                        ptr = (NodePointer)ptr.clone();\n+                        list.add(ptr);\n+                        set.add(ptr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * A compile tree element containing a constant number or string.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class Constant extends Expression {\n+\n+    private Object value;\n+\n+    public Constant(Number number){\n+        super(Expression.OP_CONSTANT);\n+        this.value = number;\n+    }\n+\n+    public Constant(String string){\n+        super(Expression.OP_CONSTANT);\n+        this.value = string;\n+    }\n+\n+    /**\n+     * Returns the value of the constant.\n+     */\n+    public Object getValue(){\n+        return value;\n+    }\n+\n+    /**\n+     * Returns false\n+     */\n+    public boolean isContextDependent(){\n+        return false;\n+    }\n+\n+    /**\n+     * Returns false\n+     */\n+    public boolean computeContextDependent(){\n+        return false;\n+    }\n+\n+    /**\n+     * Ignores the argument, sets the evaluation mode to EVALUATION_MODE_ALWAYS.\n+     * There is no reason to store the constant value in a temporary register\n+     */\n+    public void setEvaluationMode(int evalMode){\n+        super.setEvaluationMode(EVALUATION_MODE_ALWAYS);\n+    }\n+\n+    public String toString(){\n+        return \"(CONST \" + value + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * An element of the compile tree representing one of built-in functions\n+ * like \"position()\" or \"number()\".\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class CoreFunction extends Operation {\n+\n+    private int functionCode;\n+\n+    public CoreFunction(int functionCode, Expression args[]){\n+        super(Expression.OP_CORE_FUNCTION, args);\n+        this.functionCode = functionCode;\n+    }\n+\n+    public int getFunctionCode(){\n+        return functionCode;\n+    }\n+\n+    public Expression getArg1(){\n+        return args[0];\n+    }\n+\n+    public Expression getArg2(){\n+        return args[1];\n+    }\n+\n+    public Expression getArg3(){\n+        return args[2];\n+    }\n+\n+    public int getArgumentCount(){\n+        if (args == null){\n+            return 0;\n+        }\n+        return args.length;\n+    }\n+\n+    /**\n+     * Returns true if any argument is context dependent or if\n+     * the function is last(), position(), boolean(), local-name(),\n+     * name(), string(), lang(), number().\n+     */\n+    public boolean computeContextDependent(){\n+        if (super.computeContextDependent()){\n+            return true;\n+        }\n+\n+        switch(functionCode){\n+            case Compiler.FUNCTION_LAST:\n+            case Compiler.FUNCTION_POSITION:\n+                return true;\n+\n+            case Compiler.FUNCTION_BOOLEAN:\n+            case Compiler.FUNCTION_LOCAL_NAME:\n+            case Compiler.FUNCTION_NAME:\n+            case Compiler.FUNCTION_NAMESPACE_URI:\n+            case Compiler.FUNCTION_STRING:\n+            case Compiler.FUNCTION_LANG:\n+            case Compiler.FUNCTION_NUMBER:\n+                return args.length == 0;\n+\n+            case Compiler.FUNCTION_COUNT:\n+            case Compiler.FUNCTION_ID:\n+            case Compiler.FUNCTION_CONCAT:\n+            case Compiler.FUNCTION_STARTS_WITH:\n+            case Compiler.FUNCTION_CONTAINS:\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE:\n+            case Compiler.FUNCTION_SUBSTRING_AFTER:\n+            case Compiler.FUNCTION_SUBSTRING:\n+            case Compiler.FUNCTION_STRING_LENGTH:\n+            case Compiler.FUNCTION_NORMALIZE_SPACE:\n+            case Compiler.FUNCTION_TRANSLATE:\n+            case Compiler.FUNCTION_NOT:\n+            case Compiler.FUNCTION_TRUE:\n+            case Compiler.FUNCTION_FALSE:\n+            case Compiler.FUNCTION_SUM:\n+            case Compiler.FUNCTION_FLOOR:\n+            case Compiler.FUNCTION_CEILING:\n+            case Compiler.FUNCTION_ROUND:\n+                return false;\n+        }\n+\n+        return false;\n+    }\n+\n+    protected String opCodeToString(){\n+        String function = null;\n+        switch(functionCode){\n+            case Compiler.FUNCTION_LAST:             function = \"last\"; break;\n+            case Compiler.FUNCTION_POSITION:         function = \"position\"; break;\n+            case Compiler.FUNCTION_COUNT:            function = \"count\"; break;\n+            case Compiler.FUNCTION_ID:               function = \"id\"; break;\n+            case Compiler.FUNCTION_LOCAL_NAME:       function = \"local-name\"; break;\n+            case Compiler.FUNCTION_NAMESPACE_URI:    function = \"namespace-uri\"; break;\n+            case Compiler.FUNCTION_NAME:             function = \"name\"; break;\n+            case Compiler.FUNCTION_STRING:           function = \"string\"; break;\n+            case Compiler.FUNCTION_CONCAT:           function = \"concat\"; break;\n+            case Compiler.FUNCTION_STARTS_WITH:      function = \"starts-with\"; break;\n+            case Compiler.FUNCTION_CONTAINS:         function = \"contains\"; break;\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE: function = \"substring-before\"; break;\n+            case Compiler.FUNCTION_SUBSTRING_AFTER:  function = \"substring-after\"; break;\n+            case Compiler.FUNCTION_SUBSTRING:        function = \"substring\"; break;\n+            case Compiler.FUNCTION_STRING_LENGTH:    function = \"string-length\"; break;\n+            case Compiler.FUNCTION_NORMALIZE_SPACE:  function = \"normalize-space\"; break;\n+            case Compiler.FUNCTION_TRANSLATE:        function = \"translate\"; break;\n+            case Compiler.FUNCTION_BOOLEAN:          function = \"boolean\"; break;\n+            case Compiler.FUNCTION_NOT:              function = \"not\"; break;\n+            case Compiler.FUNCTION_TRUE:             function = \"true\"; break;\n+            case Compiler.FUNCTION_FALSE:            function = \"false\"; break;\n+            case Compiler.FUNCTION_LANG:             function = \"lang\"; break;\n+            case Compiler.FUNCTION_NUMBER:           function = \"number\"; break;\n+            case Compiler.FUNCTION_SUM:              function = \"sum\"; break;\n+            case Compiler.FUNCTION_FLOOR:            function = \"floor\"; break;\n+            case Compiler.FUNCTION_CEILING:          function = \"ceiling\"; break;\n+            case Compiler.FUNCTION_ROUND:            function = \"round\"; break;\n+//            case Compiler.FUNCTION_KEY:            function = \"key\"; break;\n+        }\n+        return super.opCodeToString() + ':' + function;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * A compile tree element representing one of the core operations like \"+\",\n+ * \"-\", \"*\" etc.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class CoreOperation extends Operation {\n+\n+    private Object dynamicPropertyAccessHint;\n+    public static final String DYNAMIC_PROPERTY_ACCESS_HINT = \"dynamicPropertyAccessHint\";\n+    private static final Object NO_HINT = new Object();\n+    private static QName QNAME_NAME = new QName(null, \"name\");\n+\n+    public CoreOperation(int code, Expression args[]){\n+        super(code, args);\n+    }\n+\n+    public CoreOperation(int code, Expression arg){\n+        super(code, new Expression[]{arg});\n+    }\n+\n+    public CoreOperation(int code, Expression arg1, Expression arg2){\n+        super(code, new Expression[]{arg1, arg2});\n+    }\n+\n+    public Expression getArg1(){\n+        return args[0];\n+    }\n+\n+    public Expression getArg2(){\n+        return args[1];\n+    }\n+\n+    /**\n+     * Recognized predicated formatted as <code>[@name = <i>expr</i>]</code>\n+     */\n+    public Object getEvaluationHint(String hint){\n+        if (getExpressionTypeCode() != OP_EQ ||\n+                !hint.equals(DYNAMIC_PROPERTY_ACCESS_HINT)){\n+            return null;\n+        }\n+\n+        if (dynamicPropertyAccessHint == null){\n+            dynamicPropertyAccessHint = NO_HINT;\n+\n+            Expression arg1 = getArg1();\n+            if (arg1.getExpressionTypeCode() == Expression.OP_LOCATION_PATH){\n+                Step[] steps = ((LocationPath)arg1).getSteps();\n+                if (steps.length == 1 &&\n+                        steps[0].getAxis() == Compiler.AXIS_ATTRIBUTE &&\n+                        steps[0] instanceof NodeNameTest &&\n+                        ((NodeNameTest)steps[0]).getNodeName().equals(QNAME_NAME)){\n+                    dynamicPropertyAccessHint = getArg2();\n+                }\n+            }\n+        }\n+        if (dynamicPropertyAccessHint == NO_HINT){\n+            return null;\n+        }\n+        return dynamicPropertyAccessHint;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * Common superclass for several types of nodes in the parse tree. Provides\n+ * APIs for optimization of evaluation of expressions.  Specifically, an\n+ * expression only needs to executed once during the evaluation of an xpath\n+ * if that expression is context-independent.  Expression.isContextDependent()\n+ * provides that hint.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public abstract class Expression {\n+\n+    public static final int OP_SUM = 1;\n+    public static final int OP_MINUS = 2;\n+    public static final int OP_MULT = 3;\n+    public static final int OP_DIV = 4;\n+\n+    public static final int OP_CONSTANT = 5;\n+    public static final int OP_STEP = 6;\n+\n+    public static final int OP_AND = 7;\n+    public static final int OP_OR = 8;\n+\n+    public static final int OP_UNARY_MINUS = 9;\n+    public static final int OP_MOD = 10;\n+\n+    public static final int OP_LT = 11;\n+    public static final int OP_GT = 12;\n+    public static final int OP_LTE = 13;\n+    public static final int OP_GTE = 14;\n+    public static final int OP_EQ = 15;\n+    public static final int OP_NE = 16;\n+\n+    public static final int OP_VAR = 17;\n+\n+    public static final int OP_FUNCTION = 18;\n+\n+    public static final int OP_UNION = 19;\n+    public static final int OP_LOCATION_PATH = 20;\n+    public static final int OP_EXPRESSION_PATH = 21;\n+\n+    public static final int OP_CORE_FUNCTION = 22;\n+\n+    private int typeCode;\n+\n+    private boolean contextDependencyKnown = false;\n+    private boolean contextDependent;\n+\n+    public static final int EVALUATION_MODE_ONCE = 0;\n+    public static final int EVALUATION_MODE_ONCE_AND_SAVE = 1;\n+    public static final int EVALUATION_MODE_ALWAYS = 2;\n+    private int evaluationMode;\n+\n+    private int id = -1;\n+\n+    protected Expression(int typeCode){\n+        this.typeCode = typeCode;\n+    }\n+\n+    /**\n+     * Expression IDs are used with context-independent expressions\n+     * for identifying the register holding the intermediate result of\n+     * this expression evaluation.\n+     */\n+    public void setID(int id){\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @see #setID\n+     */\n+    public int getID(){\n+        return id;\n+    }\n+\n+    public int getExpressionTypeCode(){\n+        return typeCode;\n+    }\n+\n+    protected Expression[] getArguments(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns true if this expression should be re-evaluated\n+     * each time the current position in the context changes.\n+     */\n+    public boolean isContextDependent(){\n+        if (!contextDependencyKnown){\n+            contextDependent = computeContextDependent();\n+            contextDependencyKnown = true;\n+        }\n+        return contextDependent;\n+    }\n+\n+    /**\n+     * Implemented by subclasses and result is cached by isContextDependent()\n+     */\n+    public abstract boolean computeContextDependent();\n+\n+    /**\n+     * Evaluation mode can be EVALUATION_MODE_ONCE, EVALUATION_MODE_ONCE_AND_SAVE\n+     * or EVALUATION_MODE_ALWAYS, depending on whether or not this expression\n+     * is context-dependent.  The compiler calls setEvaluationMode(EVALUATION_MODE_ONCE)\n+     * on the root Expression.  That expression recursively computes\n+     * the evaluation mode for its children and calls setEvaluationMode on\n+     * each of them.\n+     */\n+    public void setEvaluationMode(int mode){\n+        this.evaluationMode = mode;\n+    }\n+\n+    /**\n+     * @see #setEvaluationMode\n+     */\n+    public int getEvaluationMode(){\n+        return evaluationMode;\n+    }\n+\n+    /**\n+     * Some expressions return optimization hints that\n+     * help the interpreter choose between alternative\n+     * evaluation algorithms.\n+     */\n+    public Object getEvaluationHint(String hint){\n+        return null;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append('(');\n+        buffer.append(opCodeToString());\n+        Expression args[] = getArguments();\n+        if (args != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < args.length; i++){\n+                if (i > 0){\n+                    buffer.append(\", \");\n+                }\n+                buffer.append(args[i]);\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+\n+    protected String opCodeToString(){\n+        switch(typeCode){\n+            case OP_CONSTANT: return \"CONST\";\n+            case OP_STEP: return \"STEP\";\n+            case OP_SUM: return \"SUM\";\n+            case OP_UNION: return \"UNION\";\n+            case OP_MINUS: return \"MINUS\";\n+            case OP_UNARY_MINUS: return \"UNARY_MINUS\";\n+            case OP_MULT: return \"MULT\";\n+            case OP_DIV: return \"DIV\";\n+            case OP_MOD: return \"MOD\";\n+            case OP_AND: return \"AND\";\n+            case OP_OR: return \"OR\";\n+            case OP_LT: return \"LT\";\n+            case OP_GT: return \"GT\";\n+            case OP_LTE: return \"LTE\";\n+            case OP_GTE: return \"GTE\";\n+            case OP_EQ: return \"EQ\";\n+            case OP_NE: return \"NE\";\n+            case OP_VAR: return \"VAR\";\n+            case OP_FUNCTION: return \"FUNCTION\";\n+            case OP_LOCATION_PATH: return \"LOCATION_PATH\";\n+            case OP_EXPRESSION_PATH: return \"EXPRESSION_PATH\";\n+            case OP_CORE_FUNCTION: return \"CORE_FUNCTION\";\n+        }\n+        return \"UNKNOWN\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * An element of the parse tree that represents an expression path, which is\n+ * a path that starts with an expression like a function call: <code>getFoo(.)/bar</code>.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class ExpressionPath extends Path {\n+\n+    private Expression expression;\n+    private Expression predicates[];\n+\n+    public ExpressionPath(Expression expression, Expression[] predicates, Step[] steps){\n+        super(Expression.OP_EXPRESSION_PATH, steps);\n+        this.expression = expression;\n+        this.predicates = predicates;\n+    }\n+\n+    public Expression getExpression(){\n+        return expression;\n+    }\n+\n+    /**\n+     * Predicates are the expressions in brackets that may follow\n+     * the root expression of the path.\n+     */\n+    public Expression[] getPredicates(){\n+        return predicates;\n+    }\n+\n+    /**\n+     * Returns true if the root expression or any of the\n+     * predicates or the path steps are context dependent.\n+     */\n+    public boolean computeContextDependent(){\n+        if (expression.isContextDependent()){\n+            return true;\n+        }\n+        if (predicates != null){\n+            for (int i = 0; i < predicates.length; i++){\n+                if (predicates[i].isContextDependent()){\n+                    return true;\n+                }\n+            }\n+        }\n+        return super.computeContextDependent();\n+    }\n+\n+    /**\n+     * Based on the supplied argument computes the evaluation mode\n+     * for the base expression, predicates and steps.\n+     */\n+    public void setEvaluationMode(int mode){\n+        super.setEvaluationMode(mode);\n+\n+        switch(mode){\n+            case EVALUATION_MODE_ALWAYS:\n+                if (expression.isContextDependent()){\n+                    expression.setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n+                }\n+                else {\n+                    expression.setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n+                }\n+                break;\n+            case EVALUATION_MODE_ONCE:\n+            case EVALUATION_MODE_ONCE_AND_SAVE:\n+                expression.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                break;\n+        }\n+\n+        if (predicates != null){\n+            for (int i = 0; i < predicates.length; i++){\n+                switch(mode){\n+                    case EVALUATION_MODE_ALWAYS:\n+                        if (predicates[i].isContextDependent()){\n+                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n+                        }\n+                        else {\n+                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n+                        }\n+                        break;\n+                    case EVALUATION_MODE_ONCE:\n+                    case EVALUATION_MODE_ONCE_AND_SAVE:\n+                        predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(EXPRESSION-PATH \");\n+        buffer.append(expression);\n+\n+        if (predicates != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < predicates.length; i++){\n+                buffer.append('[');\n+                buffer.append(predicates[i]);\n+                buffer.append(']');\n+            }\n+        }\n+\n+        Step steps[] = getSteps();\n+        if (steps != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < steps.length; i++){\n+                if (i > 0){\n+                    buffer.append(\", \");\n+                }\n+                buffer.append(steps[i]);\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * Represents an element of the parse tree representing an extension function call.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class ExtensionFunction extends Operation {\n+\n+    private QName functionName;\n+\n+    public ExtensionFunction(QName functionName, Expression args[]){\n+        super(Expression.OP_FUNCTION, args);\n+        this.functionName = functionName;\n+    }\n+\n+    public QName getFunctionName(){\n+        return functionName;\n+    }\n+\n+    public String opCodeToString(){\n+        return super.opCodeToString() + ':' + functionName;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class LocationPath extends Path {\n+\n+    private boolean absolute;\n+    public static final String BASIC_PATH_HINT = \"basicPathHint\";\n+    private boolean basicKnown = false;\n+    private boolean basic;\n+\n+    public LocationPath(boolean absolute, Step[] steps){\n+        super(Expression.OP_LOCATION_PATH, steps);\n+        this.absolute = absolute;\n+    }\n+\n+    public boolean isAbsolute(){\n+        return absolute;\n+    }\n+\n+    public boolean computeContextDependent(){\n+        if (!absolute){\n+            return true;\n+        }\n+\n+        return super.computeContextDependent();\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(PATH\");\n+        if (absolute){\n+            buffer.append(\"[absolute] \");\n+        }\n+        else{\n+            buffer.append(\"[relative] \");\n+        }\n+        Step args[] = getSteps();\n+        if (args != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < args.length; i++){\n+                if (i > 0){\n+                    buffer.append(\", \");\n+                }\n+                buffer.append(args[i]);\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Recognized predicated formatted as <code>[@name = <i>expr</i>]</code>\n+     */\n+    public Object getEvaluationHint(String hint){\n+        if (!hint.equals(BASIC_PATH_HINT)){\n+            return null;\n+        }\n+\n+        if (!basicKnown){\n+            basicKnown = true;\n+            basic = true;\n+            Step[] steps = getSteps();\n+            for (int i = 0; i < steps.length; i++){\n+                if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n+                        !(steps[i] instanceof NodeNameTest) ||\n+                        ((NodeNameTest)steps[i]).getNodeName().getName().equals(\"*\")){\n+                    basic = false;\n+                    break;\n+                }\n+                Expression predicates[] = steps[i].getPredicates();\n+                if (predicates != null && predicates.length != 0){\n+                    if (predicates.length != 1){\n+                        basic = false;\n+                        break;\n+                    }\n+                    if (predicates[0].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null &&\n+                            predicates[0].isContextDependent()){\n+                        basic = false;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return basic ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class NodeNameTest extends Step {\n+    private QName qname;\n+\n+    public NodeNameTest(int axis, QName qname, Expression predicates[]){\n+        super(axis, predicates);\n+        this.qname = qname;\n+    }\n+\n+    public QName getNodeName(){\n+        return qname;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(NODE_NAME_TEST \");\n+        buffer.append(axisToString(getAxis()));\n+        buffer.append(\" \");\n+        buffer.append(qname);\n+        Expression[] predicates = getPredicates();\n+        if (predicates != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < predicates.length; i++){\n+                buffer.append('[');\n+                buffer.append(predicates[i]);\n+                buffer.append(']');\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class NodeTypeTest extends Step {\n+    private int nodeType;\n+\n+    public NodeTypeTest(int axis, int nodeType, Expression predicates[]){\n+        super(axis, predicates);\n+        this.nodeType = nodeType;\n+    }\n+\n+    public int getNodeType(){\n+        return nodeType;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(NODE_TYPE_TEST \");\n+        buffer.append(axisToString(getAxis()));\n+        buffer.append(\" \");\n+        buffer.append(nodeTypeToString(nodeType));\n+        Expression predicates[] = getPredicates();\n+        if (predicates != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < predicates.length; i++){\n+                buffer.append('[');\n+                buffer.append(predicates[i]);\n+                buffer.append(']');\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+\n+    public static String nodeTypeToString(int code){\n+        switch(code){\n+            case Compiler.NODE_TYPE_NODE: return \"node\";\n+            case Compiler.NODE_TYPE_TEXT: return \"text\";\n+            case Compiler.NODE_TYPE_COMMENT: return \"comment\";\n+            case Compiler.NODE_TYPE_PI: return \"processing-instruction\";\n+        }\n+        return \"UNKNOWN\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class Operation extends Expression {\n+\n+    protected Expression args[];\n+\n+    public Operation(int code, Expression args[]){\n+        super(code);\n+        this.args = args;\n+    }\n+\n+    public Expression[] getArguments(){\n+        return args;\n+    }\n+\n+    public boolean computeContextDependent(){\n+        if (args != null){\n+            for (int i = 0; i < args.length; i++){\n+                if (args[i].isContextDependent()){\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void setEvaluationMode(int mode){\n+        super.setEvaluationMode(mode);\n+        if (args != null){\n+            for (int i = 0; i < args.length; i++){\n+                switch(mode){\n+                    case EVALUATION_MODE_ALWAYS:\n+                        if (args[i].isContextDependent()){\n+                            args[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n+                        }\n+                        else {\n+                            args[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n+                        }\n+                        break;\n+                    case EVALUATION_MODE_ONCE:\n+                    case EVALUATION_MODE_ONCE_AND_SAVE:\n+                        args[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class Path extends Expression {\n+\n+    private Step[] steps;\n+\n+    public Path(int typeCode, Step[] steps){\n+        super(typeCode);\n+        this.steps = steps;\n+    }\n+\n+    public Step[] getSteps(){\n+        return steps;\n+    }\n+\n+    public boolean computeContextDependent(){\n+        if (steps != null){\n+            for (int i = 0; i < steps.length; i++){\n+                if (steps[i].isContextDependent()){\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public void setEvaluationMode(int mode){\n+        super.setEvaluationMode(mode);\n+        if (steps != null){\n+            for (int i = 0; i < steps.length; i++){\n+                if (steps[i].isContextDependent()){\n+                    steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n+                }\n+                else {\n+                    switch(mode){\n+                        case EVALUATION_MODE_ALWAYS:\n+                        case EVALUATION_MODE_ONCE_AND_SAVE:\n+                                steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n+                            break;\n+                        case EVALUATION_MODE_ONCE:\n+                            steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class ProcessingInstructionTest extends Step {\n+    private String instruction;\n+\n+    public ProcessingInstructionTest(int axis, String instruction, Expression predicates[]){\n+        super(axis, predicates);\n+        this.instruction = instruction;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(PROCESSING-INSTRUCTION \");\n+        buffer.append(axisToString(getAxis()));\n+        buffer.append(\" \");\n+        buffer.append(instruction);\n+        Expression predicates[] = getPredicates();\n+        if (predicates != null){\n+            buffer.append(' ');\n+            for (int i = 0; i < predicates.length; i++){\n+                buffer.append('[');\n+                buffer.append(predicates[i]);\n+                buffer.append(']');\n+            }\n+        }\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/QName.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Attic/QName.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class QName {\n+    private String prefix;\n+    private String name;\n+\n+    public QName(String prefix, String name){\n+        this.prefix = prefix;\n+        this.name = name;\n+    }\n+\n+    public String getPrefix(){\n+        return prefix;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public String asString(){\n+        if (prefix != null){\n+            return prefix + ':' + name;\n+        }\n+        return name;\n+    }\n+\n+    public int hashCode(){\n+        return name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (!(object instanceof QName)){\n+            return false;\n+        }\n+        if (this == object){\n+            return true;\n+        }\n+        QName that = (QName)object;\n+        if (!this.name.equals(that.name)){\n+            return false;\n+        }\n+\n+        if ((this.prefix == null && that.prefix != null) ||\n+            (this.prefix != null && !this.prefix.equals(that.prefix))){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"(QNAME \");\n+        buffer.append(asString());\n+        buffer.append(')');\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public abstract class Step {\n+    private int axis;\n+    private Expression[] predicates;\n+\n+    protected Step(int axis, Expression[] predicates){\n+        this.axis = axis;\n+        this.predicates = predicates;\n+    }\n+\n+    public int getAxis(){\n+        return axis;\n+    }\n+\n+    public Expression[] getPredicates(){\n+        return predicates;\n+    }\n+\n+    public boolean isContextDependent(){\n+        if (predicates != null){\n+            for (int i = 0; i < predicates.length; i++){\n+                if (predicates[i].isContextDependent()){\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void setEvaluationMode(int mode){\n+        if (predicates != null){\n+            for (int i = 0; i < predicates.length; i++){\n+                switch(mode){\n+                    case Expression.EVALUATION_MODE_ALWAYS:\n+                        if (predicates[i].isContextDependent()){\n+                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n+                        }\n+                        else {\n+                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n+                        }\n+                        break;\n+                    case Expression.EVALUATION_MODE_ONCE:\n+                    case Expression.EVALUATION_MODE_ONCE_AND_SAVE:\n+                        predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    public static String axisToString(int axis){\n+        switch (axis){\n+            case Compiler.AXIS_SELF:                 return \"self\";\n+            case Compiler.AXIS_CHILD:                return \"child\";\n+            case Compiler.AXIS_PARENT:               return \"parent\";\n+            case Compiler.AXIS_ANCESTOR:             return \"ancestor\";\n+            case Compiler.AXIS_ATTRIBUTE:            return \"attribute\";\n+            case Compiler.AXIS_NAMESPACE:            return \"namespace\";\n+            case Compiler.AXIS_PRECEDING:            return \"preceding\";\n+            case Compiler.AXIS_FOLLOWING:            return \"following\";\n+            case Compiler.AXIS_DESCENDANT:           return \"descendant\";\n+            case Compiler.AXIS_ANCESTOR_OR_SELF:     return \"ancestor-or-self\";\n+            case Compiler.AXIS_FOLLOWING_SIBLING:    return \"following-sibling\";\n+            case Compiler.AXIS_PRECEDING_SIBLING:    return \"preceding-sibling\";\n+            case Compiler.AXIS_DESCENDANT_OR_SELF:   return \"descendant-or-self\";\n+        }\n+        return \"UNKNOWN\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class TreeCompiler implements Compiler {\n+\n+    public Object number(String value){\n+        return new Constant(new Double(value));\n+    }\n+\n+    public Object literal(String value){\n+        return new Constant(value);\n+    }\n+\n+    public Object qname(String prefix, String name){\n+        return new QName(prefix, name);\n+    }\n+\n+    /*\n+    public Object nodeTypeTest(int nodeType){\n+        return new NodeTypeTest(nodeType);\n+    }\n+\n+    public Object processingInstructionTest(String value){\n+        return new ProcessingInstructionTest(value);\n+    }\n+\n+    public Object traverse(boolean recursive, int axis, Object nodeTest, Object[] predicates){\n+        return new Step(recursive, axis, (NodeTest)nodeTest, toExpressionArray(predicates));\n+    }\n+*/\n+    public Object sum(Object[] arguments){\n+        return new CoreOperation(Expression.OP_SUM, toExpressionArray(arguments));\n+    }\n+\n+    public Object minus(Object left, Object right){\n+        return new CoreOperation(Expression.OP_MINUS, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object multiply(Object left, Object right){\n+        return new CoreOperation(Expression.OP_MULT, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object divide(Object left, Object right){\n+        return new CoreOperation(Expression.OP_DIV, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object mod(Object left, Object right){\n+        return new CoreOperation(Expression.OP_MOD, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object lessThan(Object left, Object right){\n+        return new CoreOperation(Expression.OP_LT, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object lessThanOrEqual(Object left, Object right){\n+        return new CoreOperation(Expression.OP_LTE, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object greaterThan(Object left, Object right){\n+        return new CoreOperation(Expression.OP_GT, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object greaterThanOrEqual(Object left, Object right){\n+        return new CoreOperation(Expression.OP_GTE, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object equal(Object left, Object right){\n+        return new CoreOperation(Expression.OP_EQ, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object notEqual(Object left, Object right){\n+        return new CoreOperation(Expression.OP_NE, (Expression)left, (Expression)right);\n+    }\n+\n+    public Object minus(Object argument){\n+        return new CoreOperation(Expression.OP_UNARY_MINUS, (Expression)argument);\n+    }\n+\n+    public Object variableReference(Object qName){\n+        return new VariableReference((QName)qName);\n+    }\n+\n+    public Object function(int code, Object[] args){\n+        return new CoreFunction(code, toExpressionArray(args));\n+    }\n+\n+    public Object function(Object name, Object[] args){\n+        return new ExtensionFunction((QName)name, toExpressionArray(args));\n+    }\n+\n+    public Object and(Object arguments[]){\n+        return new CoreOperation(Expression.OP_AND, toExpressionArray(arguments));\n+    }\n+\n+    public Object or(Object arguments[]){\n+        return new CoreOperation(Expression.OP_OR, toExpressionArray(arguments));\n+    }\n+\n+    public Object union(Object[] arguments){\n+        return new CoreOperation(Expression.OP_UNION, toExpressionArray(arguments));\n+    }\n+\n+    public Object locationPath(boolean absolute, Object[] steps){\n+        return new LocationPath(absolute, toStepArray(steps));\n+    }\n+\n+    public Object expressionPath(Object expression, Object[] predicates, Object[] steps){\n+        return new ExpressionPath((Expression)expression, toExpressionArray(predicates), toStepArray(steps));\n+    }\n+\n+    public Object nodeNameTest(int axis, Object qname, Object[] predicates){\n+        return new NodeNameTest(axis, (QName)qname, toExpressionArray(predicates));\n+    }\n+\n+    public Object nodeTypeTest(int axis, int nodeType, Object[] predicates){\n+        return new NodeTypeTest(axis, nodeType, toExpressionArray(predicates));\n+    }\n+\n+    public Object processingInstructionTest(int axis, String instruction, Object[] predicates){\n+        return new ProcessingInstructionTest(axis, instruction, toExpressionArray(predicates));\n+    }\n+\n+    private Expression[] toExpressionArray(Object[] array){\n+        Expression expArray[] = null;\n+        if (array != null){\n+            expArray = new Expression[array.length];\n+            for (int i = 0; i < expArray.length; i++){\n+                expArray[i] = (Expression)array[i];\n+            }\n+        }\n+        return expArray;\n+    }\n+\n+    private Step[] toStepArray(Object[] array){\n+        Step stepArray[] = null;\n+        if (array != null){\n+            stepArray = new Step[array.length];\n+            for (int i = 0; i < stepArray.length; i++){\n+                stepArray[i] = (Step)array[i];\n+            }\n+        }\n+        return stepArray;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:46:59 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import java.util.*;\n+\n+/**\n+ * An element of the compile tree holding a variable reference.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ */\n+public class VariableReference extends Expression {\n+\n+    private QName varName;\n+\n+    public VariableReference(QName varName){\n+        super(Expression.OP_VAR);\n+        this.varName = varName;\n+    }\n+\n+    public QName getVariableName(){\n+        return varName;\n+    }\n+\n+    public String toString(){\n+        return \"(VAR \" + varName + \")\";\n+    }\n+\n+    public boolean isContextDependent(){\n+        return false;\n+    }\n+\n+    public boolean computeContextDependent(){\n+        return false;\n+    }\n+\n+    public void setEvaluationMode(int evalMode){\n+        if (evalMode == EVALUATION_MODE_ALWAYS){\n+            super.setEvaluationMode(EVALUATION_MODE_ONCE_AND_SAVE);\n+        }\n+        else {\n+            super.setEvaluationMode(evalMode);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/ASCII_UCodeESC_CharStream.java\n+/* Generated By:JavaCC: Do not edit this line. ASCII_UCodeESC_CharStream.java Version 0.7pre6 */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+/**\n+ * An implementation of interface CharStream, where the stream is assumed to\n+ * contain only ASCII characters (with java-like unicode escape processing).\n+ */\n+\n+public final class ASCII_UCodeESC_CharStream\n+{\n+  public static final boolean staticFlag = false;\n+  static final int hexval(char c) throws java.io.IOException {\n+    switch(c)\n+    {\n+       case '0' :\n+          return 0;\n+       case '1' :\n+          return 1;\n+       case '2' :\n+          return 2;\n+       case '3' :\n+          return 3;\n+       case '4' :\n+          return 4;\n+       case '5' :\n+          return 5;\n+       case '6' :\n+          return 6;\n+       case '7' :\n+          return 7;\n+       case '8' :\n+          return 8;\n+       case '9' :\n+          return 9;\n+\n+       case 'a' :\n+       case 'A' :\n+          return 10;\n+       case 'b' :\n+       case 'B' :\n+          return 11;\n+       case 'c' :\n+       case 'C' :\n+          return 12;\n+       case 'd' :\n+       case 'D' :\n+          return 13;\n+       case 'e' :\n+       case 'E' :\n+          return 14;\n+       case 'f' :\n+       case 'F' :\n+          return 15;\n+    }\n+\n+    throw new java.io.IOException(); // Should never come here\n+  }\n+\n+  public int bufpos = -1;\n+  int bufsize;\n+  int available;\n+  int tokenBegin;\n+  private int bufline[];\n+  private int bufcolumn[];\n+\n+  private int column = 0;\n+  private int line = 1;\n+\n+  private java.io.Reader inputStream;\n+\n+  private boolean prevCharIsCR = false;\n+  private boolean prevCharIsLF = false;\n+\n+  private char[] nextCharBuf;\n+  private char[] buffer;\n+  private int maxNextCharInd = 0;\n+  private int nextCharInd = -1;\n+  private int inBuf = 0;\n+\n+  private final void ExpandBuff(boolean wrapAround)\n+  {\n+     char[] newbuffer = new char[bufsize + 2048];\n+     int newbufline[] = new int[bufsize + 2048];\n+     int newbufcolumn[] = new int[bufsize + 2048];\n+\n+     try\n+     {\n+        if (wrapAround)\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           System.arraycopy(buffer, 0, newbuffer,\n+                                             bufsize - tokenBegin, bufpos);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n+           bufcolumn = newbufcolumn;\n+\n+           bufpos += (bufsize - tokenBegin);\n+        }\n+        else\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           bufcolumn = newbufcolumn;\n+\n+           bufpos -= tokenBegin;\n+        }\n+     }\n+     catch (Throwable t)\n+     {\n+        throw new Error(t.getMessage());\n+     }\n+\n+     available = (bufsize += 2048);\n+     tokenBegin = 0;\n+  }\n+\n+  private final void FillBuff() throws java.io.IOException\n+  {\n+     int i;\n+     if (maxNextCharInd == 4096)\n+        maxNextCharInd = nextCharInd = 0;\n+\n+     try {\n+        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,\n+                                            4096 - maxNextCharInd)) == -1)\n+        {\n+           inputStream.close();\n+           throw new java.io.IOException();\n+        }\n+        else\n+           maxNextCharInd += i;\n+        return;\n+     }\n+     catch(java.io.IOException e) {\n+        if (bufpos != 0)\n+        {\n+           --bufpos;\n+           backup(0);\n+        }\n+        else\n+        {\n+           bufline[bufpos] = line;\n+           bufcolumn[bufpos] = column;\n+        }\n+        throw e;\n+     }\n+  }\n+\n+  private final char ReadByte() throws java.io.IOException\n+  {\n+     if (++nextCharInd >= maxNextCharInd)\n+        FillBuff();\n+\n+     return nextCharBuf[nextCharInd];\n+  }\n+\n+  public final char BeginToken() throws java.io.IOException\n+  {     \n+     if (inBuf > 0)\n+     {\n+        --inBuf;\n+        return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0)\n+                                                           : ++bufpos];\n+     }\n+\n+     tokenBegin = 0;\n+     bufpos = -1;\n+\n+     return readChar();\n+  }     \n+\n+  private final void AdjustBuffSize()\n+  {\n+     if (available == bufsize)\n+     {\n+        if (tokenBegin > 2048)\n+        {\n+           bufpos = 0;\n+           available = tokenBegin;\n+        }\n+        else\n+           ExpandBuff(false);\n+     }\n+     else if (available > tokenBegin)\n+        available = bufsize;\n+     else if ((tokenBegin - available) < 2048)\n+        ExpandBuff(true);\n+     else\n+        available = tokenBegin;\n+  }\n+\n+  private final void UpdateLineColumn(char c)\n+  {\n+     column++;\n+\n+     if (prevCharIsLF)\n+     {\n+        prevCharIsLF = false;\n+        line += (column = 1);\n+     }\n+     else if (prevCharIsCR)\n+     {\n+        prevCharIsCR = false;\n+        if (c == '\\n')\n+        {\n+           prevCharIsLF = true;\n+        }\n+        else\n+           line += (column = 1);\n+     }\n+\n+     switch (c)\n+     {\n+        case '\\r' :\n+           prevCharIsCR = true;\n+           break;\n+        case '\\n' :\n+           prevCharIsLF = true;\n+           break;\n+        case '\\t' :\n+           column--;\n+           column += (8 - (column & 07));\n+           break;\n+        default :\n+           break;\n+     }\n+\n+     bufline[bufpos] = line;\n+     bufcolumn[bufpos] = column;\n+  }\n+\n+  public final char readChar() throws java.io.IOException\n+  {\n+     if (inBuf > 0)\n+     {\n+        --inBuf;\n+        return buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];\n+     }\n+\n+     char c;\n+\n+     if (++bufpos == available)\n+        AdjustBuffSize();\n+\n+     if (((buffer[bufpos] = c = (char)((char)0xff & ReadByte())) == '\\\\'))\n+     {\n+        UpdateLineColumn(c);\n+\n+        int backSlashCnt = 1;\n+\n+        for (;;) // Read all the backslashes\n+        {\n+           if (++bufpos == available)\n+              AdjustBuffSize();\n+\n+           try\n+           {\n+              if ((buffer[bufpos] = c = (char)((char)0xff & ReadByte())) != '\\\\')\n+              {\n+                 UpdateLineColumn(c);\n+                 // found a non-backslash char.\n+                 if ((c == 'u') && ((backSlashCnt & 1) == 1))\n+                 {\n+                    if (--bufpos < 0)\n+                       bufpos = bufsize - 1;\n+\n+                    break;\n+                 }\n+\n+                 backup(backSlashCnt);\n+                 return '\\\\';\n+              }\n+           }\n+           catch(java.io.IOException e)\n+           {\n+              if (backSlashCnt > 1)\n+                 backup(backSlashCnt);\n+\n+              return '\\\\';\n+           }\n+\n+           UpdateLineColumn(c);\n+           backSlashCnt++;\n+        }\n+\n+        // Here, we have seen an odd number of backslash's followed by a 'u'\n+        try\n+        {\n+           while ((c = (char)((char)0xff & ReadByte())) == 'u')\n+              ++column;\n+\n+           buffer[bufpos] = c = (char)(hexval(c) << 12 |\n+                                       hexval((char)((char)0xff & ReadByte())) << 8 |\n+                                       hexval((char)((char)0xff & ReadByte())) << 4 |\n+                                       hexval((char)((char)0xff & ReadByte())));\n+\n+           column += 4;\n+        }\n+        catch(java.io.IOException e)\n+        {\n+           throw new Error(\"Invalid escape character at line \" + line +\n+                                         \" column \" + column + \".\");\n+        }\n+\n+        if (backSlashCnt == 1)\n+           return c;\n+        else\n+        {\n+           backup(backSlashCnt - 1);\n+           return '\\\\';\n+        }\n+     }\n+     else\n+     {\n+        UpdateLineColumn(c);\n+        return (c);\n+     }\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndColumn\n+   */\n+\n+  public final int getColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndLine\n+   */\n+\n+  public final int getLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public final int getEndColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  public final int getEndLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public final int getBeginColumn() {\n+     return bufcolumn[tokenBegin];\n+  }\n+\n+  public final int getBeginLine() {\n+     return bufline[tokenBegin];\n+  }\n+\n+  public final void backup(int amount) {\n+\n+    inBuf += amount;\n+    if ((bufpos -= amount) < 0)\n+       bufpos += bufsize;\n+  }\n+\n+  public ASCII_UCodeESC_CharStream(java.io.Reader dstream,\n+                 int startline, int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    available = bufsize = buffersize;\n+    buffer = new char[buffersize];\n+    bufline = new int[buffersize];\n+    bufcolumn = new int[buffersize];\n+    nextCharBuf = new char[4096];\n+  }\n+\n+  public ASCII_UCodeESC_CharStream(java.io.Reader dstream,\n+                                        int startline, int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+  public void ReInit(java.io.Reader dstream,\n+                 int startline, int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    if (buffer == null || buffersize != buffer.length)\n+    {\n+      available = bufsize = buffersize;\n+      buffer = new char[buffersize];\n+      bufline = new int[buffersize];\n+      bufcolumn = new int[buffersize];\n+      nextCharBuf = new char[4096];\n+    }\n+    prevCharIsLF = prevCharIsCR = false;\n+    tokenBegin = inBuf = maxNextCharInd = 0;\n+    nextCharInd = bufpos = -1;\n+  }\n+\n+  public void ReInit(java.io.Reader dstream,\n+                                        int startline, int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+  public ASCII_UCodeESC_CharStream(java.io.InputStream dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n+  }\n+\n+  public ASCII_UCodeESC_CharStream(java.io.InputStream dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n+  }\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public final String GetImage()\n+  {\n+     if (bufpos >= tokenBegin)\n+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n+     else\n+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n+                              new String(buffer, 0, bufpos + 1);\n+  }\n+\n+  public final char[] GetSuffix(int len)\n+  {\n+     char[] ret = new char[len];\n+\n+     if ((bufpos + 1) >= len)\n+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n+     else\n+     {\n+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n+                                                          len - bufpos - 1);\n+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n+     }\n+\n+     return ret;\n+  }\n+\n+  public void Done()\n+  {\n+     nextCharBuf = null;\n+     buffer = null;\n+     bufline = null;\n+     bufcolumn = null;\n+  }\n+\n+  /**\n+   * Method to adjust line and column numbers for the start of a token.<BR>\n+   */\n+  public void adjustBeginLineColumn(int newLine, int newCol)\n+  {\n+     int start = tokenBegin;\n+     int len;\n+\n+     if (bufpos >= tokenBegin)\n+     {\n+        len = bufpos - tokenBegin + inBuf + 1;\n+     }\n+     else\n+     {\n+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n+     }\n+\n+     int i = 0, j = 0, k = 0;\n+     int nextColDiff = 0, columnDiff = 0;\n+\n+     while (i < len &&\n+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n+     {\n+        bufline[j] = newLine;\n+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n+        bufcolumn[j] = newCol + columnDiff;\n+        columnDiff = nextColDiff;\n+        i++;\n+     } \n+\n+     if (i < len)\n+     {\n+        bufline[j] = newLine++;\n+        bufcolumn[j] = newCol + columnDiff;\n+\n+        while (i++ < len)\n+        {\n+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n+              bufline[j] = newLine++;\n+           else\n+              bufline[j] = newLine;\n+        }\n+     }\n+\n+     line = bufline[j];\n+     column = bufcolumn[j];\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/ParseException.java\n+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 0.7pre6 */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+/**\n+ * This exception is thrown when parse errors are encountered.\n+ * You can explicitly create objects of this exception type by\n+ * calling the method generateParseException in the generated\n+ * parser.\n+ *\n+ * You can modify this class to customize your error reporting\n+ * mechanisms so long as you retain the public fields.\n+ */\n+public class ParseException extends Exception {\n+\n+  /**\n+   * This constructor is used by the method \"generateParseException\"\n+   * in the generated parser.  Calling this constructor generates\n+   * a new object of this type with the fields \"currentToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" set.  The boolean\n+   * flag \"specialConstructor\" is also set to true to indicate that\n+   * this constructor was used to create this object.\n+   * This constructor calls its super class with the empty string\n+   * to force the \"toString\" method of parent class \"Throwable\" to\n+   * print the error message in the form:\n+   *     ParseException: <result of getMessage>\n+   */\n+  public ParseException(Token currentTokenVal,\n+                        int[][] expectedTokenSequencesVal,\n+                        String[] tokenImageVal\n+                       )\n+  {\n+    super(\"\");\n+    specialConstructor = true;\n+    currentToken = currentTokenVal;\n+    expectedTokenSequences = expectedTokenSequencesVal;\n+    tokenImage = tokenImageVal;\n+  }\n+\n+  /**\n+   * The following constructors are for use by you for whatever\n+   * purpose you can think of.  Constructing the exception in this\n+   * manner makes the exception behave in the normal way - i.e., as\n+   * documented in the class \"Throwable\".  The fields \"errorToken\",\n+   * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n+   * relevant information.  The JavaCC generated code does not use\n+   * these constructors.\n+   */\n+\n+  public ParseException() {\n+    super();\n+    specialConstructor = false;\n+  }\n+\n+  public ParseException(String message) {\n+    super(message);\n+    specialConstructor = false;\n+  }\n+\n+  /**\n+   * This variable determines which constructor was used to create\n+   * this object and thereby affects the semantics of the\n+   * \"getMessage\" method (see below).\n+   */\n+  protected boolean specialConstructor;\n+\n+  /**\n+   * This is the last token that has been consumed successfully.  If\n+   * this object has been created due to a parse error, the token\n+   * followng this token will (therefore) be the first error token.\n+   */\n+  public Token currentToken;\n+\n+  /**\n+   * Each entry in this array is an array of integers.  Each array\n+   * of integers represents a sequence of tokens (by their ordinal\n+   * values) that is expected at this point of the parse.\n+   */\n+  public int[][] expectedTokenSequences;\n+\n+  /**\n+   * This is a reference to the \"tokenImage\" array of the generated\n+   * parser within which the parse error occurred.  This array is\n+   * defined in the generated ...Constants interface.\n+   */\n+  public String[] tokenImage;\n+\n+  /**\n+   * This method has the standard behavior when this object has been\n+   * created using the standard constructors.  Otherwise, it uses\n+   * \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n+   * error message and returns it.  If this object has been created\n+   * due to a parse error, and you do not catch it (it gets thrown\n+   * from the parser), then this method is called during the printing\n+   * of the final stack trace, and hence the correct error message\n+   * gets displayed.\n+   */\n+  public String getMessage() {\n+    if (!specialConstructor) {\n+      return super.getMessage();\n+    }\n+    String expected = \"\";\n+    int maxSize = 0;\n+    for (int i = 0; i < expectedTokenSequences.length; i++) {\n+      if (maxSize < expectedTokenSequences[i].length) {\n+        maxSize = expectedTokenSequences[i].length;\n+      }\n+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n+        expected += tokenImage[expectedTokenSequences[i][j]] + \" \";\n+      }\n+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n+        expected += \"...\";\n+      }\n+      expected += eol + \"    \";\n+    }\n+    String retval = \"Encountered \\\"\";\n+    Token tok = currentToken.next;\n+    for (int i = 0; i < maxSize; i++) {\n+      if (i != 0) retval += \" \";\n+      if (tok.kind == 0) {\n+        retval += tokenImage[0];\n+        break;\n+      }\n+      retval += add_escapes(tok.image);\n+      tok = tok.next; \n+    }\n+    retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn + \".\" + eol;\n+    if (expectedTokenSequences.length == 1) {\n+      retval += \"Was expecting:\" + eol + \"    \";\n+    } else {\n+      retval += \"Was expecting one of:\" + eol + \"    \";\n+    }\n+    retval += expected;\n+    return retval;\n+  }\n+\n+  /**\n+   * The end of line string for this machine.\n+   */\n+  protected String eol = System.getProperty(\"line.separator\", \"\\n\");\n+ \n+  /**\n+   * Used to convert raw characters to their escaped version\n+   * when these raw version cannot be used as part of an ASCII\n+   * string literal.\n+   */\n+  protected String add_escapes(String str) {\n+      StringBuffer retval = new StringBuffer();\n+      char ch;\n+      for (int i = 0; i < str.length(); i++) {\n+        switch (str.charAt(i))\n+        {\n+           case 0 :\n+              continue;\n+           case '\\b':\n+              retval.append(\"\\\\b\");\n+              continue;\n+           case '\\t':\n+              retval.append(\"\\\\t\");\n+              continue;\n+           case '\\n':\n+              retval.append(\"\\\\n\");\n+              continue;\n+           case '\\f':\n+              retval.append(\"\\\\f\");\n+              continue;\n+           case '\\r':\n+              retval.append(\"\\\\r\");\n+              continue;\n+           case '\\\"':\n+              retval.append(\"\\\\\\\"\");\n+              continue;\n+           case '\\'':\n+              retval.append(\"\\\\\\'\");\n+              continue;\n+           case '\\\\':\n+              retval.append(\"\\\\\\\\\");\n+              continue;\n+           default:\n+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                 String s = \"0000\" + Integer.toString(ch, 16);\n+                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+              } else {\n+                 retval.append(ch);\n+              }\n+              continue;\n+        }\n+      }\n+      return retval.toString();\n+   }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/Token.java\n+/* Generated By:JavaCC: Do not edit this line. Token.java Version 0.7pre3 */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+/**\n+ * Describes the input token stream.\n+ */\n+\n+public class Token {\n+\n+  /**\n+   * An integer that describes the kind of this token.  This numbering\n+   * system is determined by JavaCCParser, and a table of these numbers is\n+   * stored in the file ...Constants.java.\n+   */\n+  public int kind;\n+\n+  /**\n+   * beginLine and beginColumn describe the position of the first character\n+   * of this token; endLine and endColumn describe the position of the\n+   * last character of this token.\n+   */\n+  public int beginLine, beginColumn, endLine, endColumn;\n+\n+  /**\n+   * The string image of the token.\n+   */\n+  public String image;\n+\n+  /**\n+   * A reference to the next regular (non-special) token from the input\n+   * stream.  If this is the last token from the input stream, or if the\n+   * token manager has not read tokens beyond this one, this field is\n+   * set to null.  This is true only if this token is also a regular\n+   * token.  Otherwise, see below for a description of the contents of\n+   * this field.\n+   */\n+  public Token next;\n+\n+  /**\n+   * This field is used to access special tokens that occur prior to this\n+   * token, but after the immediately preceding regular (non-special) token.\n+   * If there are no such special tokens, this field is set to null.\n+   * When there are more than one such special token, this field refers\n+   * to the last of these special tokens, which in turn refers to the next\n+   * previous special token through its specialToken field, and so on\n+   * until the first special token (whose specialToken field is null).\n+   * The next fields of special tokens refer to other special tokens that\n+   * immediately follow it (without an intervening regular token).  If there\n+   * is no such token, this field is null.\n+   */\n+  public Token specialToken;\n+\n+  /**\n+   * Returns the image.\n+   */\n+  public final String toString()\n+  {\n+     return image;\n+  }\n+\n+  /**\n+   * Returns a new Token object, by default. However, if you want, you\n+   * can create and return subclass objects based on the value of ofKind.\n+   * Simply add the cases to the switch for all those special cases.\n+   * For example, if you have a subclass of Token called IDToken that\n+   * you want to create if ofKind is ID, simlpy add something like :\n+   *\n+   *    case MyParserConstants.ID : return new IDToken();\n+   *\n+   * to the following switch statement. Then you can cast matchedToken\n+   * variable to the appropriate type and use it in your lexical actions.\n+   */\n+  public static final Token newToken(int ofKind)\n+  {\n+     switch(ofKind)\n+     {\n+       default : return new Token();\n+     }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/TokenMgrError.java\n+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 0.7pre2 */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+public class TokenMgrError extends Error\n+{\n+   /*\n+    * Ordinals for various reasons why an Error of this type can be thrown.\n+    */\n+\n+   /**\n+    * Lexical error occured.\n+    */\n+   static final int LEXICAL_ERROR = 0;\n+\n+   /**\n+    * An attempt wass made to create a second instance of a static token manager.\n+    */\n+   static final int STATIC_LEXER_ERROR = 1;\n+\n+   /**\n+    * Tried to change to an invalid lexical state.\n+    */\n+   static final int INVALID_LEXICAL_STATE = 2;\n+\n+   /**\n+    * Detected (and bailed out of) an infinite loop in the token manager.\n+    */\n+   static final int LOOP_DETECTED = 3;\n+\n+   /**\n+    * Indicates the reason why the exception is thrown. It will have\n+    * one of the above 4 values.\n+    */\n+   int errorCode;\n+\n+   /**\n+    * Replaces unprintable characters by their espaced (or unicode escaped)\n+    * equivalents in the given string\n+    */\n+   protected static final String addEscapes(String str) {\n+      StringBuffer retval = new StringBuffer();\n+      char ch;\n+      for (int i = 0; i < str.length(); i++) {\n+        switch (str.charAt(i))\n+        {\n+           case 0 :\n+              continue;\n+           case '\\b':\n+              retval.append(\"\\\\b\");\n+              continue;\n+           case '\\t':\n+              retval.append(\"\\\\t\");\n+              continue;\n+           case '\\n':\n+              retval.append(\"\\\\n\");\n+              continue;\n+           case '\\f':\n+              retval.append(\"\\\\f\");\n+              continue;\n+           case '\\r':\n+              retval.append(\"\\\\r\");\n+              continue;\n+           case '\\\"':\n+              retval.append(\"\\\\\\\"\");\n+              continue;\n+           case '\\'':\n+              retval.append(\"\\\\\\'\");\n+              continue;\n+           case '\\\\':\n+              retval.append(\"\\\\\\\\\");\n+              continue;\n+           default:\n+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                 String s = \"0000\" + Integer.toString(ch, 16);\n+                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n+              } else {\n+                 retval.append(ch);\n+              }\n+              continue;\n+        }\n+      }\n+      return retval.toString();\n+   }\n+\n+   /**\n+    * Returns a detailed message for the Error when it is thrown by the\n+    * token manager to indicate a lexical error.\n+    * Parameters : \n+    *    EOFSeen     : indicates if EOF caused the lexicl error\n+    *    curLexState : lexical state in which this error occured\n+    *    errorLine   : line number when the error occured\n+    *    errorColumn : column number when the error occured\n+    *    errorAfter  : prefix that was seen before this error occured\n+    *    curchar     : the offending character\n+    * Note: You can customize the lexical error message by modifying this method.\n+    */\n+   private static final String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n+      return(\"Lexical error at line \" +\n+           errorLine + \", column \" +\n+           errorColumn + \".  Encountered: \" +\n+           (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") +\n+           \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n+   }\n+\n+   /**\n+    * You can also modify the body of this method to customize your error messages.\n+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n+    * of end-users concern, so you can return something like : \n+    *\n+    *     \"Internal Error : Please file a bug report .... \"\n+    *\n+    * from this method for such cases in the release version of your parser.\n+    */\n+   public String getMessage() {\n+      return super.getMessage();\n+   }\n+\n+   /*\n+    * Constructors of various flavors follow.\n+    */\n+\n+   public TokenMgrError() {\n+   }\n+\n+   public TokenMgrError(String message, int reason) {\n+      super(message);\n+      errorCode = reason;\n+   }\n+\n+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {\n+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n+   }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParser.java\n+/* Generated By:JavaCC: Do not edit this line. XPathParser.java */\n+    package org.apache.commons.jxpath.ri.parser;\n+\n+    import org.apache.commons.jxpath.ri.Compiler;\n+    import java.util.ArrayList;\n+\n+    public class XPathParser implements XPathParserConstants {\n+        private Compiler compiler;\n+\n+        public void setCompiler(Compiler compiler){\n+            this.compiler = compiler;\n+        }\n+\n+        private String unescape(String string){\n+            int index = string.indexOf(\"&apos;\");\n+            while (index != -1){\n+                string = string.substring(0, index) + \"\\'\" + string.substring(index + 6);\n+                index = string.indexOf(\"&apos;\");\n+            }\n+            index = string.indexOf(\"&quot;\");\n+            while (index != -1){\n+                string = string.substring(0, index) + \"\\\"\" + string.substring(index + 6);\n+                index = string.indexOf(\"&quot;\");\n+            }\n+            return string;\n+        }\n+\n+// Note: XPath does not have reserved words, so we have to include all these terminals\n+  final public String NCName() throws ParseException {\n+    switch (jj_nt.kind) {\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NCName:\n+      NCName_Without_CoreFunctions();\n+      break;\n+    case NODE:\n+      jj_consume_token(NODE);\n+      break;\n+    case TEXT:\n+      jj_consume_token(TEXT);\n+      break;\n+    case COMMENT:\n+      jj_consume_token(COMMENT);\n+      break;\n+    case PI:\n+      jj_consume_token(PI);\n+      break;\n+    case FUNCTION_LAST:\n+      jj_consume_token(FUNCTION_LAST);\n+      break;\n+    case FUNCTION_POSITION:\n+      jj_consume_token(FUNCTION_POSITION);\n+      break;\n+    case FUNCTION_COUNT:\n+      jj_consume_token(FUNCTION_COUNT);\n+      break;\n+    case FUNCTION_ID:\n+      jj_consume_token(FUNCTION_ID);\n+      break;\n+    case FUNCTION_LOCAL_NAME:\n+      jj_consume_token(FUNCTION_LOCAL_NAME);\n+      break;\n+    case FUNCTION_NAMESPACE_URI:\n+      jj_consume_token(FUNCTION_NAMESPACE_URI);\n+      break;\n+    case FUNCTION_NAME:\n+      jj_consume_token(FUNCTION_NAME);\n+      break;\n+    case FUNCTION_STRING:\n+      jj_consume_token(FUNCTION_STRING);\n+      break;\n+    case FUNCTION_CONCAT:\n+      jj_consume_token(FUNCTION_CONCAT);\n+      break;\n+    case FUNCTION_STARTS_WITH:\n+      jj_consume_token(FUNCTION_STARTS_WITH);\n+      break;\n+    case FUNCTION_CONTAINS:\n+      jj_consume_token(FUNCTION_CONTAINS);\n+      break;\n+    case FUNCTION_SUBSTRING_BEFORE:\n+      jj_consume_token(FUNCTION_SUBSTRING_BEFORE);\n+      break;\n+    case FUNCTION_SUBSTRING_AFTER:\n+      jj_consume_token(FUNCTION_SUBSTRING_AFTER);\n+      break;\n+    case FUNCTION_SUBSTRING:\n+      jj_consume_token(FUNCTION_SUBSTRING);\n+      break;\n+    case FUNCTION_STRING_LENGTH:\n+      jj_consume_token(FUNCTION_STRING_LENGTH);\n+      break;\n+    case FUNCTION_NORMALIZE_SPACE:\n+      jj_consume_token(FUNCTION_NORMALIZE_SPACE);\n+      break;\n+    case FUNCTION_TRANSLATE:\n+      jj_consume_token(FUNCTION_TRANSLATE);\n+      break;\n+    case FUNCTION_BOOLEAN:\n+      jj_consume_token(FUNCTION_BOOLEAN);\n+      break;\n+    case FUNCTION_NOT:\n+      jj_consume_token(FUNCTION_NOT);\n+      break;\n+    case FUNCTION_TRUE:\n+      jj_consume_token(FUNCTION_TRUE);\n+      break;\n+    case FUNCTION_FALSE:\n+      jj_consume_token(FUNCTION_FALSE);\n+      break;\n+    case FUNCTION_LANG:\n+      jj_consume_token(FUNCTION_LANG);\n+      break;\n+    case FUNCTION_NUMBER:\n+      jj_consume_token(FUNCTION_NUMBER);\n+      break;\n+    case FUNCTION_SUM:\n+      jj_consume_token(FUNCTION_SUM);\n+      break;\n+    case FUNCTION_FLOOR:\n+      jj_consume_token(FUNCTION_FLOOR);\n+      break;\n+    case FUNCTION_CEILING:\n+      jj_consume_token(FUNCTION_CEILING);\n+      break;\n+    case FUNCTION_ROUND:\n+      jj_consume_token(FUNCTION_ROUND);\n+      break;\n+    default:\n+      jj_la1[0] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return token.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public String NCName_Without_CoreFunctions() throws ParseException {\n+    switch (jj_nt.kind) {\n+    case NCName:\n+      jj_consume_token(NCName);\n+      break;\n+    case OR:\n+      jj_consume_token(OR);\n+      break;\n+    case AND:\n+      jj_consume_token(AND);\n+      break;\n+    case MOD:\n+      jj_consume_token(MOD);\n+      break;\n+    case DIV:\n+      jj_consume_token(DIV);\n+      break;\n+    default:\n+      jj_la1[1] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return token.image;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public int CoreFunctionName() throws ParseException {\n+    int code;\n+    switch (jj_nt.kind) {\n+    case FUNCTION_LAST:\n+      jj_consume_token(FUNCTION_LAST);\n+                                      code = Compiler.FUNCTION_LAST;\n+      break;\n+    case FUNCTION_POSITION:\n+      jj_consume_token(FUNCTION_POSITION);\n+                                      code = Compiler.FUNCTION_POSITION;\n+      break;\n+    case FUNCTION_COUNT:\n+      jj_consume_token(FUNCTION_COUNT);\n+                                      code = Compiler.FUNCTION_COUNT;\n+      break;\n+    case FUNCTION_ID:\n+      jj_consume_token(FUNCTION_ID);\n+                                      code = Compiler.FUNCTION_ID;\n+      break;\n+    case FUNCTION_LOCAL_NAME:\n+      jj_consume_token(FUNCTION_LOCAL_NAME);\n+                                      code = Compiler.FUNCTION_LOCAL_NAME;\n+      break;\n+    case FUNCTION_NAMESPACE_URI:\n+      jj_consume_token(FUNCTION_NAMESPACE_URI);\n+                                      code = Compiler.FUNCTION_NAMESPACE_URI;\n+      break;\n+    case FUNCTION_NAME:\n+      jj_consume_token(FUNCTION_NAME);\n+                                      code = Compiler.FUNCTION_NAME;\n+      break;\n+    case FUNCTION_STRING:\n+      jj_consume_token(FUNCTION_STRING);\n+                                      code = Compiler.FUNCTION_STRING;\n+      break;\n+    case FUNCTION_CONCAT:\n+      jj_consume_token(FUNCTION_CONCAT);\n+                                      code = Compiler.FUNCTION_CONCAT;\n+      break;\n+    case FUNCTION_STARTS_WITH:\n+      jj_consume_token(FUNCTION_STARTS_WITH);\n+                                      code = Compiler.FUNCTION_STARTS_WITH;\n+      break;\n+    case FUNCTION_CONTAINS:\n+      jj_consume_token(FUNCTION_CONTAINS);\n+                                      code = Compiler.FUNCTION_CONTAINS;\n+      break;\n+    case FUNCTION_SUBSTRING_BEFORE:\n+      jj_consume_token(FUNCTION_SUBSTRING_BEFORE);\n+                                      code = Compiler.FUNCTION_SUBSTRING_BEFORE;\n+      break;\n+    case FUNCTION_SUBSTRING_AFTER:\n+      jj_consume_token(FUNCTION_SUBSTRING_AFTER);\n+                                      code = Compiler.FUNCTION_SUBSTRING_AFTER;\n+      break;\n+    case FUNCTION_SUBSTRING:\n+      jj_consume_token(FUNCTION_SUBSTRING);\n+                                      code = Compiler.FUNCTION_SUBSTRING;\n+      break;\n+    case FUNCTION_STRING_LENGTH:\n+      jj_consume_token(FUNCTION_STRING_LENGTH);\n+                                      code = Compiler.FUNCTION_STRING_LENGTH;\n+      break;\n+    case FUNCTION_NORMALIZE_SPACE:\n+      jj_consume_token(FUNCTION_NORMALIZE_SPACE);\n+                                      code = Compiler.FUNCTION_NORMALIZE_SPACE;\n+      break;\n+    case FUNCTION_TRANSLATE:\n+      jj_consume_token(FUNCTION_TRANSLATE);\n+                                      code = Compiler.FUNCTION_TRANSLATE;\n+      break;\n+    case FUNCTION_BOOLEAN:\n+      jj_consume_token(FUNCTION_BOOLEAN);\n+                                      code = Compiler.FUNCTION_BOOLEAN;\n+      break;\n+    case FUNCTION_NOT:\n+      jj_consume_token(FUNCTION_NOT);\n+                                      code = Compiler.FUNCTION_NOT;\n+      break;\n+    case FUNCTION_TRUE:\n+      jj_consume_token(FUNCTION_TRUE);\n+                                      code = Compiler.FUNCTION_TRUE;\n+      break;\n+    case FUNCTION_FALSE:\n+      jj_consume_token(FUNCTION_FALSE);\n+                                      code = Compiler.FUNCTION_FALSE;\n+      break;\n+    case FUNCTION_LANG:\n+      jj_consume_token(FUNCTION_LANG);\n+                                      code = Compiler.FUNCTION_LANG;\n+      break;\n+    case FUNCTION_NUMBER:\n+      jj_consume_token(FUNCTION_NUMBER);\n+                                      code = Compiler.FUNCTION_NUMBER;\n+      break;\n+    case FUNCTION_SUM:\n+      jj_consume_token(FUNCTION_SUM);\n+                                      code = Compiler.FUNCTION_SUM;\n+      break;\n+    case FUNCTION_FLOOR:\n+      jj_consume_token(FUNCTION_FLOOR);\n+                                      code = Compiler.FUNCTION_FLOOR;\n+      break;\n+    case FUNCTION_CEILING:\n+      jj_consume_token(FUNCTION_CEILING);\n+                                      code = Compiler.FUNCTION_CEILING;\n+      break;\n+    case FUNCTION_ROUND:\n+      jj_consume_token(FUNCTION_ROUND);\n+                                      code = Compiler.FUNCTION_ROUND;\n+      break;\n+    default:\n+      jj_la1[2] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return code;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public Object QName() throws ParseException {\n+ String nc1, nc2 = null;\n+    nc1 = NCName();\n+    switch (jj_nt.kind) {\n+    case 72:\n+      jj_consume_token(72);\n+      nc2 = NCName();\n+      break;\n+    default:\n+      jj_la1[3] = jj_gen;\n+      ;\n+    }\n+        if (nc2 == null){\n+            {if (true) return compiler.qname(null, nc1);}\n+        }\n+        else {\n+            {if (true) return compiler.qname(nc1, nc2);}\n+        }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public Object QName_Without_CoreFunctions() throws ParseException {\n+    String nc1, nc2 = null;\n+    if (jj_2_1(2147483647)) {\n+      nc1 = NCName();\n+      jj_consume_token(72);\n+      nc2 = NCName();\n+    } else {\n+      switch (jj_nt.kind) {\n+      case OR:\n+      case AND:\n+      case MOD:\n+      case DIV:\n+      case NCName:\n+        nc1 = NCName_Without_CoreFunctions();\n+        break;\n+      default:\n+        jj_la1[4] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        if (nc2 == null){\n+            {if (true) return compiler.qname(null, nc1);}\n+        }\n+        else {\n+            {if (true) return compiler.qname(nc1, nc2);}\n+        }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public Object parseExpression() throws ParseException {\n+    Object ex;\n+    ex = Expression();\n+    jj_consume_token(0);\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* ################################################################################### */\n+/* XSLT Patterns (http://www.w3.org/1999/08/WD-xslt-19990813)                          */\n+/* ################################################################################### */\n+\n+/* [XSLT1] Pattern ::= LocationPathPattern | Pattern '|' LocationPathPattern  */\n+\n+//void Pattern() :\n+//{}\n+//{\n+//        LocationPathPattern() ( <UNION> LocationPathPattern() )* <EOF>\n+//}\n+//\n+//\n+///* [XSLT2] LocationPathPattern ::=\n+//   '/' RelativePathPattern? | IdKeyPattern (('/' | '//' RelativePathPattern)? | '//'? RelativePathPattern\n+//*/\n+//\n+//void LocationPathPattern() :\n+//{}\n+//{\n+//        <SLASH> ( RelativePathPattern() )?\n+//    |    (\n+//        LOOKAHEAD(IdKeyPattern())\n+//            IdKeyPattern() ( ( <SLASH> | <SLASHSLASH>) RelativePathPattern() )?\n+//        |    ( <SLASHSLASH> )? RelativePathPattern()\n+//        )\n+//}\n+//\n+//\n+//\n+///* [XSLT3] IdKeyPattern    ::=    'id' '(' Literal ')' | 'key' '(' Literal ',' Literal ')'  */\n+//\n+//void IdKeyPattern() :\n+//{}\n+//{\n+//        <ID> \"(\" <Literal> \")\"\n+//    |    <KEY>  \"(\" <Literal> \",\" <Literal> \")\"\n+//}\n+//\n+//\n+///* [XSLT4] RelativePathPattern    ::=    StepPattern | RelativePathPattern '/' StepPattern\n+//                           | RelativePathPattern '//' StepPattern\n+//*/\n+//void RelativePathPattern() :\n+//{}\n+//{\n+//        StepPattern() ( ( <SLASH>| <SLASHSLASH> ) StepPattern()    )*\n+//}\n+//\n+//\n+///* [XSLT5]    StepPattern    ::=    AbbreviatedAxisSpecifier NodeTest Predicate*   */\n+//void StepPattern() :\n+//{}\n+//{\n+//        AbbreviatedAxisSpecifier() NodeTest() (Predicate())*\n+//}\n+\n+\n+\n+// See XPath Syntax (http://www.w3.org/TR/xpath )\n+\n+\n+//void XPath() :\n+//{}\n+//{\n+//    LocationPath()\n+//    <EOF>\n+//}\n+\n+\n+/* [1] LocationPath ::= RelativeLocationPath | AbsoluteLocationPath  */\n+  final public Object LocationPath() throws ParseException {\n+ Object ex = null;\n+    switch (jj_nt.kind) {\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NODE:\n+    case TEXT:\n+    case COMMENT:\n+    case PI:\n+    case AXIS_SELF:\n+    case AXIS_CHILD:\n+    case AXIS_PARENT:\n+    case AXIS_ANCESTOR:\n+    case AXIS_ATTRIBUTE:\n+    case AXIS_NAMESPACE:\n+    case AXIS_PRECEDING:\n+    case AXIS_FOLLOWING:\n+    case AXIS_DESCENDANT:\n+    case AXIS_ANCESTOR_OR_SELF:\n+    case AXIS_FOLLOWING_SIBLING:\n+    case AXIS_PRECEDING_SIBLING:\n+    case AXIS_DESCENDANT_OR_SELF:\n+    case FUNCTION_LAST:\n+    case FUNCTION_POSITION:\n+    case FUNCTION_COUNT:\n+    case FUNCTION_ID:\n+    case FUNCTION_LOCAL_NAME:\n+    case FUNCTION_NAMESPACE_URI:\n+    case FUNCTION_NAME:\n+    case FUNCTION_STRING:\n+    case FUNCTION_CONCAT:\n+    case FUNCTION_STARTS_WITH:\n+    case FUNCTION_CONTAINS:\n+    case FUNCTION_SUBSTRING_BEFORE:\n+    case FUNCTION_SUBSTRING_AFTER:\n+    case FUNCTION_SUBSTRING:\n+    case FUNCTION_STRING_LENGTH:\n+    case FUNCTION_NORMALIZE_SPACE:\n+    case FUNCTION_TRANSLATE:\n+    case FUNCTION_BOOLEAN:\n+    case FUNCTION_NOT:\n+    case FUNCTION_TRUE:\n+    case FUNCTION_FALSE:\n+    case FUNCTION_LANG:\n+    case FUNCTION_NUMBER:\n+    case FUNCTION_SUM:\n+    case FUNCTION_FLOOR:\n+    case FUNCTION_CEILING:\n+    case FUNCTION_ROUND:\n+    case NCName:\n+    case 75:\n+    case 76:\n+    case 79:\n+    case 81:\n+      ex = RelativeLocationPath();\n+      break;\n+    case SLASH:\n+    case SLASHSLASH:\n+      ex = AbsoluteLocationPath();\n+      break;\n+    default:\n+      jj_la1[5] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [2] AbsoluteLocationPath ::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath  */\n+/* [10]    AbbreviatedAbsoluteLocationPath    ::=    '//' RelativeLocationPath  */\n+  final public Object AbsoluteLocationPath() throws ParseException {\n+    ArrayList steps = new ArrayList();\n+    if (jj_2_2(2147483647)) {\n+      LocationStep(steps);\n+      label_1:\n+      while (true) {\n+        switch (jj_nt.kind) {\n+        case SLASH:\n+        case SLASHSLASH:\n+          ;\n+          break;\n+        default:\n+          jj_la1[6] = jj_gen;\n+          break label_1;\n+        }\n+        LocationStep(steps);\n+      }\n+    } else {\n+      switch (jj_nt.kind) {\n+      case SLASH:\n+        jj_consume_token(SLASH);\n+        break;\n+      default:\n+        jj_la1[7] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        {if (true) return compiler.locationPath(true, steps.toArray());}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [3] RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | AbbreviatedRelativeLocationPath */\n+  final public Object RelativeLocationPath() throws ParseException {\n+    ArrayList steps = new ArrayList();\n+    NodeTest(steps);\n+    label_2:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case SLASH:\n+      case SLASHSLASH:\n+        ;\n+        break;\n+      default:\n+        jj_la1[8] = jj_gen;\n+        break label_2;\n+      }\n+      LocationStep(steps);\n+    }\n+        {if (true) return compiler.locationPath(false, steps.toArray());}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [3] RelativeLocationPath ::= Step | RelativeLocationPath '/' Step | AbbreviatedRelativeLocationPath */\n+/* [11]    AbbreviatedRelativeLocationPath    ::=    RelativeLocationPath '//' Step  */\n+\n+\n+/*--------------------*/\n+/* 2.1 Location Steps */\n+/*--------------------*/\n+\n+/* [4] Step ::= AxisSpecifier NodeTest Predicate*   | AbbreviatedStep  */\n+  final public void LocationStep(ArrayList steps) throws ParseException {\n+    Object s;\n+    switch (jj_nt.kind) {\n+    case SLASH:\n+      jj_consume_token(SLASH);\n+      break;\n+    case SLASHSLASH:\n+      jj_consume_token(SLASHSLASH);\n+            // Abbreviated step: descendant-or-self::node()\n+            steps.add(compiler.nodeTypeTest(Compiler.AXIS_DESCENDANT_OR_SELF, Compiler.NODE_TYPE_NODE, null));\n+      break;\n+    default:\n+      jj_la1[9] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    NodeTest(steps);\n+  }\n+\n+/* [7] NodeTest ::= WildcardName | NodeType '(' ')' | 'processing-instruction' '(' Literal ')' */\n+  final public void NodeTest(ArrayList steps) throws ParseException {\n+    int axis;\n+    int type = -1;\n+    String instruction = null;\n+    Object name = null;\n+    Object s;\n+    Object p;\n+    ArrayList ps = new ArrayList();\n+    switch (jj_nt.kind) {\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NODE:\n+    case TEXT:\n+    case COMMENT:\n+    case PI:\n+    case AXIS_SELF:\n+    case AXIS_CHILD:\n+    case AXIS_PARENT:\n+    case AXIS_ANCESTOR:\n+    case AXIS_ATTRIBUTE:\n+    case AXIS_NAMESPACE:\n+    case AXIS_PRECEDING:\n+    case AXIS_FOLLOWING:\n+    case AXIS_DESCENDANT:\n+    case AXIS_ANCESTOR_OR_SELF:\n+    case AXIS_FOLLOWING_SIBLING:\n+    case AXIS_PRECEDING_SIBLING:\n+    case AXIS_DESCENDANT_OR_SELF:\n+    case FUNCTION_LAST:\n+    case FUNCTION_POSITION:\n+    case FUNCTION_COUNT:\n+    case FUNCTION_ID:\n+    case FUNCTION_LOCAL_NAME:\n+    case FUNCTION_NAMESPACE_URI:\n+    case FUNCTION_NAME:\n+    case FUNCTION_STRING:\n+    case FUNCTION_CONCAT:\n+    case FUNCTION_STARTS_WITH:\n+    case FUNCTION_CONTAINS:\n+    case FUNCTION_SUBSTRING_BEFORE:\n+    case FUNCTION_SUBSTRING_AFTER:\n+    case FUNCTION_SUBSTRING:\n+    case FUNCTION_STRING_LENGTH:\n+    case FUNCTION_NORMALIZE_SPACE:\n+    case FUNCTION_TRANSLATE:\n+    case FUNCTION_BOOLEAN:\n+    case FUNCTION_NOT:\n+    case FUNCTION_TRUE:\n+    case FUNCTION_FALSE:\n+    case FUNCTION_LANG:\n+    case FUNCTION_NUMBER:\n+    case FUNCTION_SUM:\n+    case FUNCTION_FLOOR:\n+    case FUNCTION_CEILING:\n+    case FUNCTION_ROUND:\n+    case NCName:\n+    case 79:\n+    case 81:\n+      axis = AxisSpecifier();\n+      if (jj_2_3(2147483647)) {\n+        type = NodeType();\n+        jj_consume_token(73);\n+        jj_consume_token(74);\n+      } else if (jj_2_4(2147483647)) {\n+        jj_consume_token(PI);\n+        jj_consume_token(73);\n+        jj_consume_token(Literal);\n+                                                    instruction = token.image;\n+        jj_consume_token(74);\n+      } else {\n+        switch (jj_nt.kind) {\n+        case OR:\n+        case AND:\n+        case MOD:\n+        case DIV:\n+        case NODE:\n+        case TEXT:\n+        case COMMENT:\n+        case PI:\n+        case FUNCTION_LAST:\n+        case FUNCTION_POSITION:\n+        case FUNCTION_COUNT:\n+        case FUNCTION_ID:\n+        case FUNCTION_LOCAL_NAME:\n+        case FUNCTION_NAMESPACE_URI:\n+        case FUNCTION_NAME:\n+        case FUNCTION_STRING:\n+        case FUNCTION_CONCAT:\n+        case FUNCTION_STARTS_WITH:\n+        case FUNCTION_CONTAINS:\n+        case FUNCTION_SUBSTRING_BEFORE:\n+        case FUNCTION_SUBSTRING_AFTER:\n+        case FUNCTION_SUBSTRING:\n+        case FUNCTION_STRING_LENGTH:\n+        case FUNCTION_NORMALIZE_SPACE:\n+        case FUNCTION_TRANSLATE:\n+        case FUNCTION_BOOLEAN:\n+        case FUNCTION_NOT:\n+        case FUNCTION_TRUE:\n+        case FUNCTION_FALSE:\n+        case FUNCTION_LANG:\n+        case FUNCTION_NUMBER:\n+        case FUNCTION_SUM:\n+        case FUNCTION_FLOOR:\n+        case FUNCTION_CEILING:\n+        case FUNCTION_ROUND:\n+        case NCName:\n+        case 81:\n+          name = WildcardName();\n+          break;\n+        default:\n+          jj_la1[10] = jj_gen;\n+          jj_consume_token(-1);\n+          throw new ParseException();\n+        }\n+      }\n+      break;\n+    case 75:\n+      jj_consume_token(75);\n+                    axis = Compiler.AXIS_SELF;\n+                    type = Compiler.NODE_TYPE_NODE;\n+      break;\n+    case 76:\n+      jj_consume_token(76);\n+                    axis = Compiler.AXIS_PARENT;\n+                    type = Compiler.NODE_TYPE_NODE;\n+      break;\n+    default:\n+      jj_la1[11] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    label_3:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case 77:\n+        ;\n+        break;\n+      default:\n+        jj_la1[12] = jj_gen;\n+        break label_3;\n+      }\n+      p = Predicate();\n+                ps.add(p);\n+    }\n+        if (name != null){\n+            s = compiler.nodeNameTest(axis, name, ps.toArray());\n+        }\n+        else if (instruction != null){\n+            s = compiler.processingInstructionTest(axis, instruction, ps.toArray());\n+        }\n+        else {\n+            s = compiler.nodeTypeTest(axis, type, ps.toArray());\n+        }\n+        steps.add(s);\n+  }\n+\n+/* [5] AxisSpecifier ::=    AxisName '::' | AbbreviatedAxisSpecifier  */\n+  final public int AxisSpecifier() throws ParseException {\n+    int axis;\n+    switch (jj_nt.kind) {\n+    case AXIS_SELF:\n+    case AXIS_CHILD:\n+    case AXIS_PARENT:\n+    case AXIS_ANCESTOR:\n+    case AXIS_ATTRIBUTE:\n+    case AXIS_NAMESPACE:\n+    case AXIS_PRECEDING:\n+    case AXIS_FOLLOWING:\n+    case AXIS_DESCENDANT:\n+    case AXIS_ANCESTOR_OR_SELF:\n+    case AXIS_FOLLOWING_SIBLING:\n+    case AXIS_PRECEDING_SIBLING:\n+    case AXIS_DESCENDANT_OR_SELF:\n+      axis = AxisName();\n+      break;\n+    default:\n+      jj_la1[13] = jj_gen;\n+      axis = AbbreviatedAxisSpecifier();\n+    }\n+        {if (true) return axis;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*----------*/\n+/* 2.2 Axes */\n+/*----------*/\n+\n+/* [6] AxisName ::= 'ancestor' | 'ancestor-or-self' | 'attribute'  | 'child' | 'descendant'\n+                    | 'descendant-or-self' | 'following' | 'following-sibling' | 'namespace'\n+                       | 'parent' | 'preceding' | 'preceding-sibling' | 'self'\n+*/\n+  final public int AxisName() throws ParseException {\n+    int axis = 0;\n+    switch (jj_nt.kind) {\n+    case AXIS_SELF:\n+      jj_consume_token(AXIS_SELF);\n+                                          axis = Compiler.AXIS_SELF;\n+      break;\n+    case AXIS_CHILD:\n+      jj_consume_token(AXIS_CHILD);\n+                                          axis = Compiler.AXIS_CHILD;\n+      break;\n+    case AXIS_PARENT:\n+      jj_consume_token(AXIS_PARENT);\n+                                          axis = Compiler.AXIS_PARENT;\n+      break;\n+    case AXIS_ANCESTOR:\n+      jj_consume_token(AXIS_ANCESTOR);\n+                                          axis = Compiler.AXIS_ANCESTOR;\n+      break;\n+    case AXIS_ATTRIBUTE:\n+      jj_consume_token(AXIS_ATTRIBUTE);\n+                                          axis = Compiler.AXIS_ATTRIBUTE;\n+      break;\n+    case AXIS_NAMESPACE:\n+      jj_consume_token(AXIS_NAMESPACE);\n+                                          axis = Compiler.AXIS_NAMESPACE;\n+      break;\n+    case AXIS_PRECEDING:\n+      jj_consume_token(AXIS_PRECEDING);\n+                                          axis = Compiler.AXIS_PRECEDING;\n+      break;\n+    case AXIS_FOLLOWING:\n+      jj_consume_token(AXIS_FOLLOWING);\n+                                          axis = Compiler.AXIS_FOLLOWING;\n+      break;\n+    case AXIS_DESCENDANT:\n+      jj_consume_token(AXIS_DESCENDANT);\n+                                          axis = Compiler.AXIS_DESCENDANT;\n+      break;\n+    case AXIS_ANCESTOR_OR_SELF:\n+      jj_consume_token(AXIS_ANCESTOR_OR_SELF);\n+                                          axis = Compiler.AXIS_ANCESTOR_OR_SELF;\n+      break;\n+    case AXIS_FOLLOWING_SIBLING:\n+      jj_consume_token(AXIS_FOLLOWING_SIBLING);\n+                                          axis = Compiler.AXIS_FOLLOWING_SIBLING;\n+      break;\n+    case AXIS_PRECEDING_SIBLING:\n+      jj_consume_token(AXIS_PRECEDING_SIBLING);\n+                                          axis = Compiler.AXIS_PRECEDING_SIBLING;\n+      break;\n+    case AXIS_DESCENDANT_OR_SELF:\n+      jj_consume_token(AXIS_DESCENDANT_OR_SELF);\n+                                          axis = Compiler.AXIS_DESCENDANT_OR_SELF;\n+      break;\n+    default:\n+      jj_la1[14] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return axis;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*----------------*/\n+/* 2.3 Node Tests */\n+/*----------------*/\n+\n+/*----------------*/\n+/* 2.4 Predicates */\n+/*----------------*/\n+\n+/* [8] Predicate ::= '[' PredicateExpr ']'  */\n+/* [9] PredicateExpr ::=  Expr  */\n+  final public Object Predicate() throws ParseException {\n+    Object ex;\n+    jj_consume_token(77);\n+    ex = Expression();\n+    jj_consume_token(78);\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [12]    AbbreviatedStep    ::=    '.'  | '..'  */\n+\n+/* [13]    AbbreviatedAxisSpecifier    ::=    '@'? */\n+  final public int AbbreviatedAxisSpecifier() throws ParseException {\n+    int axis = Compiler.AXIS_CHILD;\n+    switch (jj_nt.kind) {\n+    case 79:\n+      jj_consume_token(79);\n+           axis = Compiler.AXIS_ATTRIBUTE;\n+      break;\n+    default:\n+      jj_la1[15] = jj_gen;\n+      ;\n+    }\n+        {if (true) return axis;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*---------------*/\n+/* 3 Expressions */\n+/*---------------*/\n+\n+/*------------*/\n+/* 3.1 Basics */\n+/*------------*/\n+\n+/*\n+The effect of the grammar is that the order of precedence is (lowest precedence first):\n+    or\n+    and\n+    =, !=\n+    <=, <, >=, >\n+and all operators are left associative.\n+For example, 3 > 2 > 1 is equivalent to (3 > 2) > 1, which evaluates to false.\n+*/\n+\n+/* [14] Expr ::= OrExpr */\n+  final public Object Expression() throws ParseException {\n+ Object ex;\n+    ex = OrExpr();\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [15] PrimaryExpr ::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall */\n+  final public Object PrimaryExpr() throws ParseException {\n+    Object ex = null;\n+    switch (jj_nt.kind) {\n+    case VARIABLE:\n+      ex = VariableReference();\n+      break;\n+    case 73:\n+      jj_consume_token(73);\n+      ex = Expression();\n+      jj_consume_token(74);\n+      break;\n+    case Literal:\n+      jj_consume_token(Literal);\n+                      ex = compiler.literal(unescape(token.image.substring(1, token.image.length() - 1)));\n+      break;\n+    case Number:\n+      jj_consume_token(Number);\n+                      ex = compiler.number(token.image);\n+      break;\n+    default:\n+      jj_la1[16] = jj_gen;\n+      if (jj_2_5(2147483647)) {\n+        ex = CoreFunctionCall();\n+      } else {\n+        switch (jj_nt.kind) {\n+        case OR:\n+        case AND:\n+        case MOD:\n+        case DIV:\n+        case NODE:\n+        case TEXT:\n+        case COMMENT:\n+        case PI:\n+        case FUNCTION_LAST:\n+        case FUNCTION_POSITION:\n+        case FUNCTION_COUNT:\n+        case FUNCTION_ID:\n+        case FUNCTION_LOCAL_NAME:\n+        case FUNCTION_NAMESPACE_URI:\n+        case FUNCTION_NAME:\n+        case FUNCTION_STRING:\n+        case FUNCTION_CONCAT:\n+        case FUNCTION_STARTS_WITH:\n+        case FUNCTION_CONTAINS:\n+        case FUNCTION_SUBSTRING_BEFORE:\n+        case FUNCTION_SUBSTRING_AFTER:\n+        case FUNCTION_SUBSTRING:\n+        case FUNCTION_STRING_LENGTH:\n+        case FUNCTION_NORMALIZE_SPACE:\n+        case FUNCTION_TRANSLATE:\n+        case FUNCTION_BOOLEAN:\n+        case FUNCTION_NOT:\n+        case FUNCTION_TRUE:\n+        case FUNCTION_FALSE:\n+        case FUNCTION_LANG:\n+        case FUNCTION_NUMBER:\n+        case FUNCTION_SUM:\n+        case FUNCTION_FLOOR:\n+        case FUNCTION_CEILING:\n+        case FUNCTION_ROUND:\n+        case NCName:\n+          ex = FunctionCall();\n+          break;\n+        default:\n+          jj_la1[17] = jj_gen;\n+          jj_consume_token(-1);\n+          throw new ParseException();\n+        }\n+      }\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*--------------------*/\n+/* 3.2 Function Calls */\n+/*--------------------*/\n+\n+/* [16]    FunctionCall    ::=    FunctionName '(' ( Argument ( ',' Argument)*)? ')'  */\n+  final public Object FunctionCall() throws ParseException {\n+    Object name;\n+    ArrayList args;\n+    name = FunctionName();\n+    args = ArgumentList();\n+        if (args == null){\n+            {if (true) return compiler.function(name, null);}\n+        }\n+        else {\n+            {if (true) return compiler.function(name, args.toArray());}\n+        }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public Object CoreFunctionCall() throws ParseException {\n+    int code = 0;\n+    ArrayList args;\n+    code = CoreFunctionName();\n+    args = ArgumentList();\n+        if (args == null){\n+            {if (true) return compiler.function(code, null);}\n+        }\n+        else {\n+            {if (true) return compiler.function(code, args.toArray());}\n+        }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public ArrayList ArgumentList() throws ParseException {\n+    ArrayList args = null;\n+    Object arg;\n+    jj_consume_token(73);\n+    switch (jj_nt.kind) {\n+    case SLASH:\n+    case SLASHSLASH:\n+    case MINUS:\n+    case VARIABLE:\n+    case Literal:\n+    case Number:\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NODE:\n+    case TEXT:\n+    case COMMENT:\n+    case PI:\n+    case AXIS_SELF:\n+    case AXIS_CHILD:\n+    case AXIS_PARENT:\n+    case AXIS_ANCESTOR:\n+    case AXIS_ATTRIBUTE:\n+    case AXIS_NAMESPACE:\n+    case AXIS_PRECEDING:\n+    case AXIS_FOLLOWING:\n+    case AXIS_DESCENDANT:\n+    case AXIS_ANCESTOR_OR_SELF:\n+    case AXIS_FOLLOWING_SIBLING:\n+    case AXIS_PRECEDING_SIBLING:\n+    case AXIS_DESCENDANT_OR_SELF:\n+    case FUNCTION_LAST:\n+    case FUNCTION_POSITION:\n+    case FUNCTION_COUNT:\n+    case FUNCTION_ID:\n+    case FUNCTION_LOCAL_NAME:\n+    case FUNCTION_NAMESPACE_URI:\n+    case FUNCTION_NAME:\n+    case FUNCTION_STRING:\n+    case FUNCTION_CONCAT:\n+    case FUNCTION_STARTS_WITH:\n+    case FUNCTION_CONTAINS:\n+    case FUNCTION_SUBSTRING_BEFORE:\n+    case FUNCTION_SUBSTRING_AFTER:\n+    case FUNCTION_SUBSTRING:\n+    case FUNCTION_STRING_LENGTH:\n+    case FUNCTION_NORMALIZE_SPACE:\n+    case FUNCTION_TRANSLATE:\n+    case FUNCTION_BOOLEAN:\n+    case FUNCTION_NOT:\n+    case FUNCTION_TRUE:\n+    case FUNCTION_FALSE:\n+    case FUNCTION_LANG:\n+    case FUNCTION_NUMBER:\n+    case FUNCTION_SUM:\n+    case FUNCTION_FLOOR:\n+    case FUNCTION_CEILING:\n+    case FUNCTION_ROUND:\n+    case NCName:\n+    case 73:\n+    case 75:\n+    case 76:\n+    case 79:\n+    case 81:\n+      arg = Argument();\n+                                args = new ArrayList(); args.add(arg);\n+      label_4:\n+      while (true) {\n+        switch (jj_nt.kind) {\n+        case 80:\n+          ;\n+          break;\n+        default:\n+          jj_la1[18] = jj_gen;\n+          break label_4;\n+        }\n+        jj_consume_token(80);\n+        arg = Argument();\n+                                       args.add(arg);\n+      }\n+      break;\n+    default:\n+      jj_la1[19] = jj_gen;\n+      ;\n+    }\n+    jj_consume_token(74);\n+        {if (true) return args;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [17]    Argument    ::=    Expr */\n+  final public Object Argument() throws ParseException {\n+    Object ex;\n+    ex = Expression();\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*---------------*/\n+/* 3.3 Node-sets */\n+/*---------------*/\n+\n+/* [18] UnionExpr    ::=    PathExpr | UnionExpr '|' PathExpr */\n+  final public Object UnionExpr() throws ParseException {\n+    Object ex, r;\n+    ArrayList list = null;\n+    ex = PathExpr();\n+    label_5:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case UNION:\n+        ;\n+        break;\n+      default:\n+        jj_la1[20] = jj_gen;\n+        break label_5;\n+      }\n+      jj_consume_token(UNION);\n+      r = PathExpr();\n+                if (list == null){\n+                    list = new ArrayList();\n+                    list.add(ex);\n+                }\n+                list.add(r);\n+    }\n+        if (list != null){\n+            ex = compiler.union(list.toArray());\n+        }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [19] PathExpr ::= LocationPath | FilterExpr | FilterExpr '/' RelativeLocationPath | FilterExpr '//' RelativeLocationPath  */\n+  final public Object PathExpr() throws ParseException {\n+    Object ex = null;\n+    Object[] steps;\n+    if (jj_2_6(2147483647)) {\n+      ex = FilterExpr();\n+    } else {\n+      switch (jj_nt.kind) {\n+      case SLASH:\n+      case SLASHSLASH:\n+      case OR:\n+      case AND:\n+      case MOD:\n+      case DIV:\n+      case NODE:\n+      case TEXT:\n+      case COMMENT:\n+      case PI:\n+      case AXIS_SELF:\n+      case AXIS_CHILD:\n+      case AXIS_PARENT:\n+      case AXIS_ANCESTOR:\n+      case AXIS_ATTRIBUTE:\n+      case AXIS_NAMESPACE:\n+      case AXIS_PRECEDING:\n+      case AXIS_FOLLOWING:\n+      case AXIS_DESCENDANT:\n+      case AXIS_ANCESTOR_OR_SELF:\n+      case AXIS_FOLLOWING_SIBLING:\n+      case AXIS_PRECEDING_SIBLING:\n+      case AXIS_DESCENDANT_OR_SELF:\n+      case FUNCTION_LAST:\n+      case FUNCTION_POSITION:\n+      case FUNCTION_COUNT:\n+      case FUNCTION_ID:\n+      case FUNCTION_LOCAL_NAME:\n+      case FUNCTION_NAMESPACE_URI:\n+      case FUNCTION_NAME:\n+      case FUNCTION_STRING:\n+      case FUNCTION_CONCAT:\n+      case FUNCTION_STARTS_WITH:\n+      case FUNCTION_CONTAINS:\n+      case FUNCTION_SUBSTRING_BEFORE:\n+      case FUNCTION_SUBSTRING_AFTER:\n+      case FUNCTION_SUBSTRING:\n+      case FUNCTION_STRING_LENGTH:\n+      case FUNCTION_NORMALIZE_SPACE:\n+      case FUNCTION_TRANSLATE:\n+      case FUNCTION_BOOLEAN:\n+      case FUNCTION_NOT:\n+      case FUNCTION_TRUE:\n+      case FUNCTION_FALSE:\n+      case FUNCTION_LANG:\n+      case FUNCTION_NUMBER:\n+      case FUNCTION_SUM:\n+      case FUNCTION_FLOOR:\n+      case FUNCTION_CEILING:\n+      case FUNCTION_ROUND:\n+      case NCName:\n+      case 75:\n+      case 76:\n+      case 79:\n+      case 81:\n+        ex = LocationPath();\n+        break;\n+      default:\n+        jj_la1[21] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [20]    FilterExpr    ::=    PrimaryExpr    | FilterExpr Predicate */\n+  final public Object FilterExpr() throws ParseException {\n+    Object ex, p;\n+    ArrayList ps = new ArrayList();\n+    boolean path = false;\n+    ArrayList steps = new ArrayList();\n+    ex = PrimaryExpr();\n+    label_6:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case 77:\n+        ;\n+        break;\n+      default:\n+        jj_la1[22] = jj_gen;\n+        break label_6;\n+      }\n+      p = Predicate();\n+                path = true;\n+                ps.add(p);\n+    }\n+    label_7:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case SLASH:\n+      case SLASHSLASH:\n+        ;\n+        break;\n+      default:\n+        jj_la1[23] = jj_gen;\n+        break label_7;\n+      }\n+      LocationStep(steps);\n+                path = true;\n+    }\n+        if (path){\n+            {if (true) return compiler.expressionPath(ex, ps.toArray(), steps.toArray());}\n+        }\n+        else {\n+            {if (true) return ex;}\n+        }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*--------------*/\n+/* 3.4 Booleans */\n+/*--------------*/\n+\n+/* [21] OrExpr    ::=    AndExpr | OrExpr 'or' AndExpr */\n+  final public Object OrExpr() throws ParseException {\n+    Object ex, r;\n+    ArrayList list = null;\n+    ex = AndExpr();\n+    label_8:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case OR:\n+        ;\n+        break;\n+      default:\n+        jj_la1[24] = jj_gen;\n+        break label_8;\n+      }\n+      jj_consume_token(OR);\n+      r = AndExpr();\n+                if (list == null){\n+                    list = new ArrayList();\n+                    list.add(ex);\n+                }\n+                list.add(r);\n+    }\n+        if (list != null){\n+            ex = compiler.or(list.toArray());\n+        }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [22] AndExpr    ::=    EqualityExpr  | AndExpr 'and' EqualityExpr  */\n+  final public Object AndExpr() throws ParseException {\n+    Object ex, r;\n+    ArrayList list = null;\n+    ex = EqualityExpr();\n+    label_9:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case AND:\n+        ;\n+        break;\n+      default:\n+        jj_la1[25] = jj_gen;\n+        break label_9;\n+      }\n+      jj_consume_token(AND);\n+      r = EqualityExpr();\n+                if (list == null){\n+                    list = new ArrayList();\n+                    list.add(ex);\n+                }\n+                list.add(r);\n+    }\n+        if (list != null){\n+            ex = compiler.and(list.toArray());\n+        }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [23] EqualityExpr    ::=    RelationalExpr | EqualityExpr '=' RelationalExpr | EqualityExpr '!=' RelationalExpr */\n+  final public Object EqualityExpr() throws ParseException {\n+ Object ex, r;\n+    ex = RelationalExpr();\n+    label_10:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case EQ:\n+      case NEQ:\n+        ;\n+        break;\n+      default:\n+        jj_la1[26] = jj_gen;\n+        break label_10;\n+      }\n+      switch (jj_nt.kind) {\n+      case EQ:\n+        jj_consume_token(EQ);\n+        r = RelationalExpr();\n+                                          ex = compiler.equal(ex, r);\n+        break;\n+      case NEQ:\n+        jj_consume_token(NEQ);\n+        r = RelationalExpr();\n+                                          ex = compiler.notEqual(ex, r);\n+        break;\n+      default:\n+        jj_la1[27] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [24] RelationalExpr    ::=    AdditiveExpr | RelationalExpr '<' AdditiveExpr | RelationalExpr '>' AdditiveExpr\n+                       | RelationalExpr '<=' AdditiveExpr  | RelationalExpr '>=' AdditiveExpr */\n+  final public Object RelationalExpr() throws ParseException {\n+ Object ex, r;\n+    ex = AdditiveExpr();\n+    label_11:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case LT:\n+      case LTE:\n+      case GT:\n+      case GTE:\n+        ;\n+        break;\n+      default:\n+        jj_la1[28] = jj_gen;\n+        break label_11;\n+      }\n+      switch (jj_nt.kind) {\n+      case LT:\n+        jj_consume_token(LT);\n+        r = AdditiveExpr();\n+                                        ex = compiler.lessThan(ex, r);\n+        break;\n+      case GT:\n+        jj_consume_token(GT);\n+        r = AdditiveExpr();\n+                                        ex = compiler.greaterThan(ex, r);\n+        break;\n+      case LTE:\n+        jj_consume_token(LTE);\n+        r = AdditiveExpr();\n+                                        ex = compiler.lessThanOrEqual(ex, r);\n+        break;\n+      case GTE:\n+        jj_consume_token(GTE);\n+        r = AdditiveExpr();\n+                                        ex = compiler.greaterThanOrEqual(ex, r);\n+        break;\n+      default:\n+        jj_la1[29] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*-------------*/\n+/* 3.5 Numbers */\n+/*-------------*/\n+\n+/* [25] AdditiveExpr ::= MultiplicativeExpr  | AdditiveExpr '+' MultiplicativeExpr  | AdditiveExpr '-' MultiplicativeExpr  */\n+  final public Object AdditiveExpr() throws ParseException {\n+    Object ex, r;\n+    ArrayList list = null;\n+    ex = SubtractiveExpr();\n+    label_12:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case PLUS:\n+        ;\n+        break;\n+      default:\n+        jj_la1[30] = jj_gen;\n+        break label_12;\n+      }\n+      jj_consume_token(PLUS);\n+      r = SubtractiveExpr();\n+                if (list == null){\n+                    list = new ArrayList();\n+                    list.add(ex);\n+                }\n+                list.add(r);\n+    }\n+        if (list != null){\n+            ex = compiler.sum(list.toArray());\n+        }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final public Object SubtractiveExpr() throws ParseException {\n+    Object ex, r = null;\n+    ex = MultiplicativeExpr();\n+    label_13:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case MINUS:\n+        ;\n+        break;\n+      default:\n+        jj_la1[31] = jj_gen;\n+        break label_13;\n+      }\n+      jj_consume_token(MINUS);\n+      r = MultiplicativeExpr();\n+                                               ex = compiler.minus(ex, r);\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [26] MultiplicativeExpr ::= UnaryExpr | MultiplicativeExpr MultiplyOperator UnaryExpr\n+            | MultiplicativeExpr 'div' UnaryExpr | MultiplicativeExpr 'mod' UnaryExpr  */\n+  final public Object MultiplicativeExpr() throws ParseException {\n+    Object ex, r;\n+    ex = UnaryExpr();\n+    label_14:\n+    while (true) {\n+      switch (jj_nt.kind) {\n+      case MOD:\n+      case DIV:\n+      case 81:\n+        ;\n+        break;\n+      default:\n+        jj_la1[32] = jj_gen;\n+        break label_14;\n+      }\n+      switch (jj_nt.kind) {\n+      case 81:\n+        jj_consume_token(81);\n+        r = UnaryExpr();\n+                                    ex = compiler.multiply(ex, r);\n+        break;\n+      case DIV:\n+        jj_consume_token(DIV);\n+        r = UnaryExpr();\n+                                    ex = compiler.divide(ex, r);\n+        break;\n+      case MOD:\n+        jj_consume_token(MOD);\n+        r = UnaryExpr();\n+                                    ex = compiler.mod(ex, r);\n+        break;\n+      default:\n+        jj_la1[33] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [27]    UnaryExpr    ::=    UnionExpr  | '-' UnaryExpr  */\n+  final public Object UnaryExpr() throws ParseException {\n+    Object ex;\n+    switch (jj_nt.kind) {\n+    case SLASH:\n+    case SLASHSLASH:\n+    case VARIABLE:\n+    case Literal:\n+    case Number:\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NODE:\n+    case TEXT:\n+    case COMMENT:\n+    case PI:\n+    case AXIS_SELF:\n+    case AXIS_CHILD:\n+    case AXIS_PARENT:\n+    case AXIS_ANCESTOR:\n+    case AXIS_ATTRIBUTE:\n+    case AXIS_NAMESPACE:\n+    case AXIS_PRECEDING:\n+    case AXIS_FOLLOWING:\n+    case AXIS_DESCENDANT:\n+    case AXIS_ANCESTOR_OR_SELF:\n+    case AXIS_FOLLOWING_SIBLING:\n+    case AXIS_PRECEDING_SIBLING:\n+    case AXIS_DESCENDANT_OR_SELF:\n+    case FUNCTION_LAST:\n+    case FUNCTION_POSITION:\n+    case FUNCTION_COUNT:\n+    case FUNCTION_ID:\n+    case FUNCTION_LOCAL_NAME:\n+    case FUNCTION_NAMESPACE_URI:\n+    case FUNCTION_NAME:\n+    case FUNCTION_STRING:\n+    case FUNCTION_CONCAT:\n+    case FUNCTION_STARTS_WITH:\n+    case FUNCTION_CONTAINS:\n+    case FUNCTION_SUBSTRING_BEFORE:\n+    case FUNCTION_SUBSTRING_AFTER:\n+    case FUNCTION_SUBSTRING:\n+    case FUNCTION_STRING_LENGTH:\n+    case FUNCTION_NORMALIZE_SPACE:\n+    case FUNCTION_TRANSLATE:\n+    case FUNCTION_BOOLEAN:\n+    case FUNCTION_NOT:\n+    case FUNCTION_TRUE:\n+    case FUNCTION_FALSE:\n+    case FUNCTION_LANG:\n+    case FUNCTION_NUMBER:\n+    case FUNCTION_SUM:\n+    case FUNCTION_FLOOR:\n+    case FUNCTION_CEILING:\n+    case FUNCTION_ROUND:\n+    case NCName:\n+    case 73:\n+    case 75:\n+    case 76:\n+    case 79:\n+    case 81:\n+      ex = UnionExpr();\n+      break;\n+    case MINUS:\n+      jj_consume_token(MINUS);\n+      ex = UnaryExpr();\n+                                    ex = compiler.minus(ex);\n+      break;\n+    default:\n+      jj_la1[34] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return ex;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/*-------------*/\n+/* 3.6 Strings */\n+/*-------------*/\n+\n+/*----------------------------------*/\n+/* 3.7 Expression Lexical Structure */\n+/*----------------------------------*/\n+/*\n+The following special tokenization rules must be applied in the order\n+specified to disambiguate the grammar:\n+\n+1. If there is a preceding token and the preceding token is not one of\n+   @, ::, (, [, , or an Operator,\n+   then a * must be recognized as a MultiplyOperator and an NCName must\n+   be recognized as an OperatorName.\n+\n+2. If the character following an NCName (possibly after intervening ExprWhitespace)\n+   is (, then the token must be recognized as a NodeType or a FunctionName.\n+\n+3. If the two characters following an NCName (possibly after intervening ExprWhitespace)\n+   are ::, then the token must be recognized as an AxisName.\n+\n+4. Otherwise, the token must not be recognized as a MultiplyOperator, an OperatorName,\n+   a NodeType, a FunctionName, or an AxisName.\n+*/\n+\n+/*\n+[28]    ExprToken    ::=    '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n+   | WildcardName  | NodeType  | Operator  | FunctionName  | AxisName  | Literal\n+   | Number  | VariableReference\n+*/\n+/* [34]    MultiplyOperator    ::=    '*'  */\n+\n+/* [35]    FunctionName    ::=    QName - NodeType   */\n+  final public Object FunctionName() throws ParseException {\n+    Object qname;\n+    qname = QName_Without_CoreFunctions();\n+        {if (true) return qname;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [36]    VariableReference    ::=    '$' QName  */\n+  final public Object VariableReference() throws ParseException {\n+    Object ex;\n+    jj_consume_token(VARIABLE);\n+    ex = QName();\n+        {if (true) return compiler.variableReference(ex);}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [37]    WildcardName    ::=    '*'     | NCName ':' '*'     | QName  */\n+  final public Object WildcardName() throws ParseException {\n+    Object qn;\n+    String nc1, nc2 = null;\n+    switch (jj_nt.kind) {\n+    case 81:\n+      jj_consume_token(81);\n+      break;\n+    case OR:\n+    case AND:\n+    case MOD:\n+    case DIV:\n+    case NODE:\n+    case TEXT:\n+    case COMMENT:\n+    case PI:\n+    case FUNCTION_LAST:\n+    case FUNCTION_POSITION:\n+    case FUNCTION_COUNT:\n+    case FUNCTION_ID:\n+    case FUNCTION_LOCAL_NAME:\n+    case FUNCTION_NAMESPACE_URI:\n+    case FUNCTION_NAME:\n+    case FUNCTION_STRING:\n+    case FUNCTION_CONCAT:\n+    case FUNCTION_STARTS_WITH:\n+    case FUNCTION_CONTAINS:\n+    case FUNCTION_SUBSTRING_BEFORE:\n+    case FUNCTION_SUBSTRING_AFTER:\n+    case FUNCTION_SUBSTRING:\n+    case FUNCTION_STRING_LENGTH:\n+    case FUNCTION_NORMALIZE_SPACE:\n+    case FUNCTION_TRANSLATE:\n+    case FUNCTION_BOOLEAN:\n+    case FUNCTION_NOT:\n+    case FUNCTION_TRUE:\n+    case FUNCTION_FALSE:\n+    case FUNCTION_LANG:\n+    case FUNCTION_NUMBER:\n+    case FUNCTION_SUM:\n+    case FUNCTION_FLOOR:\n+    case FUNCTION_CEILING:\n+    case FUNCTION_ROUND:\n+    case NCName:\n+      NCName();\n+      break;\n+    default:\n+      jj_la1[35] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+                           nc1 = token.image;\n+    switch (jj_nt.kind) {\n+    case 72:\n+      jj_consume_token(72);\n+      switch (jj_nt.kind) {\n+      case 81:\n+        jj_consume_token(81);\n+        break;\n+      case OR:\n+      case AND:\n+      case MOD:\n+      case DIV:\n+      case NODE:\n+      case TEXT:\n+      case COMMENT:\n+      case PI:\n+      case FUNCTION_LAST:\n+      case FUNCTION_POSITION:\n+      case FUNCTION_COUNT:\n+      case FUNCTION_ID:\n+      case FUNCTION_LOCAL_NAME:\n+      case FUNCTION_NAMESPACE_URI:\n+      case FUNCTION_NAME:\n+      case FUNCTION_STRING:\n+      case FUNCTION_CONCAT:\n+      case FUNCTION_STARTS_WITH:\n+      case FUNCTION_CONTAINS:\n+      case FUNCTION_SUBSTRING_BEFORE:\n+      case FUNCTION_SUBSTRING_AFTER:\n+      case FUNCTION_SUBSTRING:\n+      case FUNCTION_STRING_LENGTH:\n+      case FUNCTION_NORMALIZE_SPACE:\n+      case FUNCTION_TRANSLATE:\n+      case FUNCTION_BOOLEAN:\n+      case FUNCTION_NOT:\n+      case FUNCTION_TRUE:\n+      case FUNCTION_FALSE:\n+      case FUNCTION_LANG:\n+      case FUNCTION_NUMBER:\n+      case FUNCTION_SUM:\n+      case FUNCTION_FLOOR:\n+      case FUNCTION_CEILING:\n+      case FUNCTION_ROUND:\n+      case NCName:\n+        NCName();\n+        break;\n+      default:\n+        jj_la1[36] = jj_gen;\n+        jj_consume_token(-1);\n+        throw new ParseException();\n+      }\n+                               nc2 = token.image;\n+      break;\n+    default:\n+      jj_la1[37] = jj_gen;\n+      ;\n+    }\n+        if (nc2 != null){\n+            qn = compiler.qname(nc1, nc2);\n+        }\n+        else {\n+            qn = compiler.qname(null, nc1);\n+        }\n+        {if (true) return qn;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+/* [38]    NodeType    ::=    'comment' | 'text'  | 'processing-instruction'  | 'node'  */\n+  final public int NodeType() throws ParseException {\n+    int type;\n+    switch (jj_nt.kind) {\n+    case TEXT:\n+      jj_consume_token(TEXT);\n+                      type = Compiler.NODE_TYPE_TEXT;\n+      break;\n+    case NODE:\n+      jj_consume_token(NODE);\n+                      type = Compiler.NODE_TYPE_NODE;\n+      break;\n+    case COMMENT:\n+      jj_consume_token(COMMENT);\n+                      type = Compiler.NODE_TYPE_COMMENT;\n+      break;\n+    case PI:\n+      jj_consume_token(PI);\n+                      type = Compiler.NODE_TYPE_PI;\n+      break;\n+    default:\n+      jj_la1[38] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+        {if (true) return type;}\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private boolean jj_2_1(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_1();\n+    jj_save(0, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_2_2(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_2();\n+    jj_save(1, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_2_3(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_3();\n+    jj_save(2, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_2_4(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_4();\n+    jj_save(3, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_2_5(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_5();\n+    jj_save(4, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_2_6(int xla) {\n+    jj_la = xla; jj_lastpos = jj_scanpos = token;\n+    boolean retval = !jj_3_6();\n+    jj_save(5, xla);\n+    return retval;\n+  }\n+\n+  final private boolean jj_3R_64() {\n+    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_63() {\n+    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_62() {\n+    if (jj_scan_token(FUNCTION_ID)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_61() {\n+    if (jj_scan_token(FUNCTION_COUNT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_60() {\n+    if (jj_scan_token(FUNCTION_POSITION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_59() {\n+    if (jj_scan_token(FUNCTION_LAST)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_98() {\n+    if (jj_3R_112()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_18() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_59()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_60()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_61()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_62()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_63()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_64()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_65()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_66()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_67()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_68()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_69()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_70()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_71()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_72()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_73()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_74()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_75()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_76()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_77()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_78()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_79()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_80()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_81()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_82()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_83()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_84()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_85()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_105() {\n+    if (jj_scan_token(DIV)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_104() {\n+    if (jj_scan_token(MOD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_103() {\n+    if (jj_scan_token(AND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_102() {\n+    if (jj_scan_token(OR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_101() {\n+    if (jj_scan_token(NCName)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_92() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_101()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_102()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_103()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_104()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_105()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_167() {\n+    if (jj_scan_token(MINUS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_164()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_165() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_168()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_169()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_170()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_51() {\n+    if (jj_scan_token(FUNCTION_ROUND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_166() {\n+    if (jj_3R_171()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_50() {\n+    if (jj_scan_token(FUNCTION_CEILING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_49() {\n+    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_147() {\n+    if (jj_scan_token(79)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_48() {\n+    if (jj_scan_token(FUNCTION_SUM)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_47() {\n+    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_124() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_147()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_46() {\n+    if (jj_scan_token(FUNCTION_LANG)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_164() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_166()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_167()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_45() {\n+    if (jj_scan_token(FUNCTION_FALSE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_44() {\n+    if (jj_scan_token(FUNCTION_TRUE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_43() {\n+    if (jj_scan_token(FUNCTION_NOT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_42() {\n+    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_41() {\n+    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_40() {\n+    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_170() {\n+    if (jj_scan_token(MOD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_164()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_39() {\n+    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_169() {\n+    if (jj_scan_token(DIV)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_164()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_38() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_168() {\n+    if (jj_scan_token(81)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_164()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_37() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_36() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_35() {\n+    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_34() {\n+    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_33() {\n+    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_110() {\n+    if (jj_scan_token(77)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_98()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(78)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_32() {\n+    if (jj_scan_token(FUNCTION_STRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_31() {\n+    if (jj_scan_token(FUNCTION_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_30() {\n+    if (jj_scan_token(FUNCTION_NAMESPACE_URI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_29() {\n+    if (jj_scan_token(FUNCTION_LOCAL_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_28() {\n+    if (jj_scan_token(FUNCTION_ID)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_162() {\n+    if (jj_3R_164()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_165()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_27() {\n+    if (jj_scan_token(FUNCTION_COUNT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_26() {\n+    if (jj_scan_token(FUNCTION_POSITION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_25() {\n+    if (jj_scan_token(FUNCTION_LAST)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_24() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_23() {\n+    if (jj_scan_token(COMMENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_22() {\n+    if (jj_scan_token(TEXT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_21() {\n+    if (jj_scan_token(NODE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_163() {\n+    if (jj_scan_token(MINUS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_162()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_20() {\n+    if (jj_3R_92()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_146() {\n+    if (jj_scan_token(AXIS_DESCENDANT_OR_SELF)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_145() {\n+    if (jj_scan_token(AXIS_PRECEDING_SIBLING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_144() {\n+    if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_15() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_20()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_21()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_22()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_23()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_24()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_25()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_26()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_27()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_28()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_29()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_30()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_31()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_32()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_33()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_34()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_35()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_36()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_37()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_38()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_39()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_40()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_41()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_42()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_43()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_44()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_45()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_46()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_47()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_48()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_49()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_50()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_51()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_143() {\n+    if (jj_scan_token(AXIS_ANCESTOR_OR_SELF)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_157() {\n+    if (jj_scan_token(PLUS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_156()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_142() {\n+    if (jj_scan_token(AXIS_DESCENDANT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_141() {\n+    if (jj_scan_token(AXIS_FOLLOWING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_140() {\n+    if (jj_scan_token(AXIS_PRECEDING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_139() {\n+    if (jj_scan_token(AXIS_NAMESPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_156() {\n+    if (jj_3R_162()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_163()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_138() {\n+    if (jj_scan_token(AXIS_ATTRIBUTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_137() {\n+    if (jj_scan_token(AXIS_ANCESTOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_136() {\n+    if (jj_scan_token(AXIS_PARENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_135() {\n+    if (jj_scan_token(AXIS_CHILD)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_134() {\n+    if (jj_scan_token(AXIS_SELF)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_123() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_134()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_135()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_136()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_137()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_138()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_139()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_140()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_141()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_142()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_143()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_144()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_145()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_146()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_153() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_158()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_159()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_160()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_161()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_152() {\n+    if (jj_3R_156()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_157()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_116() {\n+    if (jj_3R_124()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_115() {\n+    if (jj_3R_123()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_161() {\n+    if (jj_scan_token(GTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_152()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_106() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_115()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_116()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_160() {\n+    if (jj_scan_token(LTE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_152()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_159() {\n+    if (jj_scan_token(GT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_152()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_151() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_154()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_155()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_158() {\n+    if (jj_scan_token(LT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_152()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_150() {\n+    if (jj_3R_152()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_153()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_155() {\n+    if (jj_scan_token(NEQ)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_150()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_154() {\n+    if (jj_scan_token(EQ)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_150()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_96() {\n+    if (jj_3R_110()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_4() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_3() {\n+    if (jj_3R_17()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_95() {\n+    if (jj_scan_token(76)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_94() {\n+    if (jj_scan_token(75)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_109() {\n+    if (jj_3R_117()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_108() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(Literal)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_128() {\n+    if (jj_3R_150()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_151()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_107() {\n+    if (jj_3R_17()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_93() {\n+    if (jj_3R_106()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_107()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_108()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_109()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_129() {\n+    if (jj_scan_token(AND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_128()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_54() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_93()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_94()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_95()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_96()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_187() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_119() {\n+    if (jj_3R_128()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_129()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_53() {\n+    if (jj_scan_token(SLASHSLASH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_52() {\n+    if (jj_scan_token(SLASH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_184() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_16() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_52()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_53()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_54()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_120() {\n+    if (jj_scan_token(OR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_119()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_112() {\n+    if (jj_3R_119()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_120()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_182() {\n+    if (jj_3R_54()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_184()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3_2() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_179() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_186() {\n+    if (jj_scan_token(SLASH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_185() {\n+    if (jj_3R_16()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_187()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_178() {\n+    if (jj_3R_110()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_183() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_185()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_186()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_176() {\n+    if (jj_3R_19()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_178()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_179()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_181() {\n+    if (jj_3R_183()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_180() {\n+    if (jj_3R_182()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_6() {\n+    if (jj_3R_19()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_177() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_180()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_181()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_175() {\n+    if (jj_3R_177()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_174() {\n+    if (jj_3R_176()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_172() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_174()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_175()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_173() {\n+    if (jj_scan_token(UNION)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_172()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_171() {\n+    if (jj_3R_172()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_173()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_130() {\n+    if (jj_3R_98()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_131() {\n+    if (jj_scan_token(80)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_130()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_121() {\n+    if (jj_3R_130()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    while (true) {\n+      xsp = jj_scanpos;\n+      if (jj_3R_131()) { jj_scanpos = xsp; break; }\n+      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    }\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_113() {\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_121()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_58() {\n+    if (jj_scan_token(PI)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_57() {\n+    if (jj_scan_token(COMMENT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_1() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(72)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_56() {\n+    if (jj_scan_token(NODE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_55() {\n+    if (jj_scan_token(TEXT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_17() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_55()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_56()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_57()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_58()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_133() {\n+    if (jj_3R_92()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_132() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(72)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_149() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_126() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_148() {\n+    if (jj_scan_token(81)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_118() {\n+    if (jj_scan_token(72)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_99() {\n+    if (jj_3R_18()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_113()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_122() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_132()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_133()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_127() {\n+    if (jj_scan_token(72)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_148()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_149()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_125() {\n+    if (jj_scan_token(81)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_117() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_125()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_126()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    xsp = jj_scanpos;\n+    if (jj_3R_127()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_111() {\n+    if (jj_3R_15()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_118()) jj_scanpos = xsp;\n+    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_100() {\n+    if (jj_3R_114()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_113()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3_5() {\n+    if (jj_3R_18()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_85() {\n+    if (jj_scan_token(FUNCTION_ROUND)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_97() {\n+    if (jj_scan_token(VARIABLE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_111()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_84() {\n+    if (jj_scan_token(FUNCTION_CEILING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_83() {\n+    if (jj_scan_token(FUNCTION_FLOOR)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_82() {\n+    if (jj_scan_token(FUNCTION_SUM)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_81() {\n+    if (jj_scan_token(FUNCTION_NUMBER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_80() {\n+    if (jj_scan_token(FUNCTION_LANG)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_79() {\n+    if (jj_scan_token(FUNCTION_FALSE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_91() {\n+    if (jj_3R_100()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_78() {\n+    if (jj_scan_token(FUNCTION_TRUE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_90() {\n+    if (jj_3R_99()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_77() {\n+    if (jj_scan_token(FUNCTION_NOT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_89() {\n+    if (jj_scan_token(Number)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_76() {\n+    if (jj_scan_token(FUNCTION_BOOLEAN)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_88() {\n+    if (jj_scan_token(Literal)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_75() {\n+    if (jj_scan_token(FUNCTION_TRANSLATE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_87() {\n+    if (jj_scan_token(73)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_3R_98()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    if (jj_scan_token(74)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_74() {\n+    if (jj_scan_token(FUNCTION_NORMALIZE_SPACE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_86() {\n+    if (jj_3R_97()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_73() {\n+    if (jj_scan_token(FUNCTION_STRING_LENGTH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_72() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_114() {\n+    if (jj_3R_122()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_71() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_AFTER)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_70() {\n+    if (jj_scan_token(FUNCTION_SUBSTRING_BEFORE)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_69() {\n+    if (jj_scan_token(FUNCTION_CONTAINS)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_68() {\n+    if (jj_scan_token(FUNCTION_STARTS_WITH)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_19() {\n+    Token xsp;\n+    xsp = jj_scanpos;\n+    if (jj_3R_86()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_87()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_88()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_89()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_90()) {\n+    jj_scanpos = xsp;\n+    if (jj_3R_91()) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_67() {\n+    if (jj_scan_token(FUNCTION_CONCAT)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_66() {\n+    if (jj_scan_token(FUNCTION_STRING)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  final private boolean jj_3R_65() {\n+    if (jj_scan_token(FUNCTION_NAME)) return true;\n+    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;\n+    return false;\n+  }\n+\n+  public XPathParserTokenManager token_source;\n+  ASCII_UCodeESC_CharStream jj_input_stream;\n+  public Token token, jj_nt;\n+  private Token jj_scanpos, jj_lastpos;\n+  private int jj_la;\n+  public boolean lookingAhead = false;\n+  private boolean jj_semLA;\n+  private int jj_gen;\n+  final private int[] jj_la1 = new int[39];\n+  final private int[] jj_la1_0 = {0x7f800000,0x7800000,0x0,0x0,0x7800000,0xff80000c,0xc,0x4,0xc,0xc,0x7f800000,0xff800000,0x0,0x80000000,0x80000000,0x0,0x16000,0x7f800000,0x0,0xff81604c,0x10,0xff80000c,0x0,0xc,0x800000,0x1000000,0x180,0x180,0x1e00,0x1e00,0x20,0x40,0x6000000,0x6000000,0xff81604c,0x7f800000,0x7f800000,0x0,0x78000000,};\n+  final private int[] jj_la1_1 = {0xfffff000,0x0,0xfffff000,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xfffff000,0xffffffff,0x0,0xfff,0xfff,0x0,0x0,0xfffff000,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xfffff000,0xfffff000,0x0,0x0,};\n+  final private int[] jj_la1_2 = {0xff,0x80,0x7f,0x100,0x80,0x298ff,0x0,0x0,0x0,0x0,0x200ff,0x298ff,0x2000,0x0,0x0,0x8000,0x200,0xff,0x10000,0x29aff,0x0,0x298ff,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x29aff,0x200ff,0x200ff,0x100,0x0,};\n+  final private JJCalls[] jj_2_rtns = new JJCalls[6];\n+  private boolean jj_rescan = false;\n+  private int jj_gc = 0;\n+\n+  public XPathParser(java.io.InputStream stream) {\n+    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\n+    token_source = new XPathParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(java.io.InputStream stream) {\n+    jj_input_stream.ReInit(stream, 1, 1);\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public XPathParser(java.io.Reader stream) {\n+    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);\n+    token_source = new XPathParserTokenManager(jj_input_stream);\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(java.io.Reader stream) {\n+    jj_input_stream.ReInit(stream, 1, 1);\n+    token_source.ReInit(jj_input_stream);\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public XPathParser(XPathParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  public void ReInit(XPathParserTokenManager tm) {\n+    token_source = tm;\n+    token = new Token();\n+    token.next = jj_nt = token_source.getNextToken();\n+    jj_gen = 0;\n+    for (int i = 0; i < 39; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n+  }\n+\n+  final private Token jj_consume_token(int kind) throws ParseException {\n+    Token oldToken = token;\n+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;\n+    else jj_nt = jj_nt.next = token_source.getNextToken();\n+    if (token.kind == kind) {\n+      jj_gen++;\n+      if (++jj_gc > 100) {\n+        jj_gc = 0;\n+        for (int i = 0; i < jj_2_rtns.length; i++) {\n+          JJCalls c = jj_2_rtns[i];\n+          while (c != null) {\n+            if (c.gen < jj_gen) c.first = null;\n+            c = c.next;\n+          }\n+        }\n+      }\n+      return token;\n+    }\n+    jj_nt = token;\n+    token = oldToken;\n+    jj_kind = kind;\n+    throw generateParseException();\n+  }\n+\n+  final private boolean jj_scan_token(int kind) {\n+    if (jj_scanpos == jj_lastpos) {\n+      jj_la--;\n+      if (jj_scanpos.next == null) {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n+      } else {\n+        jj_lastpos = jj_scanpos = jj_scanpos.next;\n+      }\n+    } else {\n+      jj_scanpos = jj_scanpos.next;\n+    }\n+    if (jj_rescan) {\n+      int i = 0; Token tok = token;\n+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n+      if (tok != null) jj_add_error_token(kind, i);\n+    }\n+    return (jj_scanpos.kind != kind);\n+  }\n+\n+  final public Token getNextToken() {\n+    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;\n+    else jj_nt = jj_nt.next = token_source.getNextToken();\n+    jj_gen++;\n+    return token;\n+  }\n+\n+  final public Token getToken(int index) {\n+    Token t = lookingAhead ? jj_scanpos : token;\n+    for (int i = 0; i < index; i++) {\n+      if (t.next != null) t = t.next;\n+      else t = t.next = token_source.getNextToken();\n+    }\n+    return t;\n+  }\n+\n+  private java.util.Vector jj_expentries = new java.util.Vector();\n+  private int[] jj_expentry;\n+  private int jj_kind = -1;\n+  private int[] jj_lasttokens = new int[100];\n+  private int jj_endpos;\n+\n+  private void jj_add_error_token(int kind, int pos) {\n+    if (pos >= 100) return;\n+    if (pos == jj_endpos + 1) {\n+      jj_lasttokens[jj_endpos++] = kind;\n+    } else if (jj_endpos != 0) {\n+      jj_expentry = new int[jj_endpos];\n+      for (int i = 0; i < jj_endpos; i++) {\n+        jj_expentry[i] = jj_lasttokens[i];\n+      }\n+      boolean exists = false;\n+      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {\n+        int[] oldentry = (int[])(enum.nextElement());\n+        if (oldentry.length == jj_expentry.length) {\n+          exists = true;\n+          for (int i = 0; i < jj_expentry.length; i++) {\n+            if (oldentry[i] != jj_expentry[i]) {\n+              exists = false;\n+              break;\n+            }\n+          }\n+          if (exists) break;\n+        }\n+      }\n+      if (!exists) jj_expentries.addElement(jj_expentry);\n+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n+    }\n+  }\n+\n+  final public ParseException generateParseException() {\n+    jj_expentries.removeAllElements();\n+    boolean[] la1tokens = new boolean[82];\n+    for (int i = 0; i < 82; i++) {\n+      la1tokens[i] = false;\n+    }\n+    if (jj_kind >= 0) {\n+      la1tokens[jj_kind] = true;\n+      jj_kind = -1;\n+    }\n+    for (int i = 0; i < 39; i++) {\n+      if (jj_la1[i] == jj_gen) {\n+        for (int j = 0; j < 32; j++) {\n+          if ((jj_la1_0[i] & (1<<j)) != 0) {\n+            la1tokens[j] = true;\n+          }\n+          if ((jj_la1_1[i] & (1<<j)) != 0) {\n+            la1tokens[32+j] = true;\n+          }\n+          if ((jj_la1_2[i] & (1<<j)) != 0) {\n+            la1tokens[64+j] = true;\n+          }\n+        }\n+      }\n+    }\n+    for (int i = 0; i < 82; i++) {\n+      if (la1tokens[i]) {\n+        jj_expentry = new int[1];\n+        jj_expentry[0] = i;\n+        jj_expentries.addElement(jj_expentry);\n+      }\n+    }\n+    jj_endpos = 0;\n+    jj_rescan_token();\n+    jj_add_error_token(0, 0);\n+    int[][] exptokseq = new int[jj_expentries.size()][];\n+    for (int i = 0; i < jj_expentries.size(); i++) {\n+      exptokseq[i] = (int[])jj_expentries.elementAt(i);\n+    }\n+    return new ParseException(token, exptokseq, tokenImage);\n+  }\n+\n+  final public void enable_tracing() {\n+  }\n+\n+  final public void disable_tracing() {\n+  }\n+\n+  final private void jj_rescan_token() {\n+    jj_rescan = true;\n+    for (int i = 0; i < 6; i++) {\n+      JJCalls p = jj_2_rtns[i];\n+      do {\n+        if (p.gen > jj_gen) {\n+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n+          switch (i) {\n+            case 0: jj_3_1(); break;\n+            case 1: jj_3_2(); break;\n+            case 2: jj_3_3(); break;\n+            case 3: jj_3_4(); break;\n+            case 4: jj_3_5(); break;\n+            case 5: jj_3_6(); break;\n+          }\n+        }\n+        p = p.next;\n+      } while (p != null);\n+    }\n+    jj_rescan = false;\n+  }\n+\n+  final private void jj_save(int index, int xla) {\n+    JJCalls p = jj_2_rtns[index];\n+    while (p.gen > jj_gen) {\n+      if (p.next == null) { p = p.next = new JJCalls(); break; }\n+      p = p.next;\n+    }\n+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;\n+  }\n+\n+  static final class JJCalls {\n+    int gen;\n+    Token first;\n+    int arg;\n+    JJCalls next;\n+  }\n+\n+    }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserConstants.java\n+/* Generated By:JavaCC: Do not edit this line. XPathParserConstants.java */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+public interface XPathParserConstants {\n+\n+  int EOF = 0;\n+  int S = 1;\n+  int SLASH = 2;\n+  int SLASHSLASH = 3;\n+  int UNION = 4;\n+  int PLUS = 5;\n+  int MINUS = 6;\n+  int EQ = 7;\n+  int NEQ = 8;\n+  int LT = 9;\n+  int LTE = 10;\n+  int GT = 11;\n+  int GTE = 12;\n+  int VARIABLE = 13;\n+  int Literal = 14;\n+  int Digit = 15;\n+  int Number = 16;\n+  int Letter = 17;\n+  int BaseChar = 18;\n+  int Ideographic = 19;\n+  int CombiningChar = 20;\n+  int UnicodeDigit = 21;\n+  int Extender = 22;\n+  int OR = 23;\n+  int AND = 24;\n+  int MOD = 25;\n+  int DIV = 26;\n+  int NODE = 27;\n+  int TEXT = 28;\n+  int COMMENT = 29;\n+  int PI = 30;\n+  int AXIS_SELF = 31;\n+  int AXIS_CHILD = 32;\n+  int AXIS_PARENT = 33;\n+  int AXIS_ANCESTOR = 34;\n+  int AXIS_ATTRIBUTE = 35;\n+  int AXIS_NAMESPACE = 36;\n+  int AXIS_PRECEDING = 37;\n+  int AXIS_FOLLOWING = 38;\n+  int AXIS_DESCENDANT = 39;\n+  int AXIS_ANCESTOR_OR_SELF = 40;\n+  int AXIS_FOLLOWING_SIBLING = 41;\n+  int AXIS_PRECEDING_SIBLING = 42;\n+  int AXIS_DESCENDANT_OR_SELF = 43;\n+  int FUNCTION_LAST = 44;\n+  int FUNCTION_POSITION = 45;\n+  int FUNCTION_COUNT = 46;\n+  int FUNCTION_ID = 47;\n+  int FUNCTION_LOCAL_NAME = 48;\n+  int FUNCTION_NAMESPACE_URI = 49;\n+  int FUNCTION_NAME = 50;\n+  int FUNCTION_STRING = 51;\n+  int FUNCTION_CONCAT = 52;\n+  int FUNCTION_STARTS_WITH = 53;\n+  int FUNCTION_CONTAINS = 54;\n+  int FUNCTION_SUBSTRING_BEFORE = 55;\n+  int FUNCTION_SUBSTRING_AFTER = 56;\n+  int FUNCTION_SUBSTRING = 57;\n+  int FUNCTION_STRING_LENGTH = 58;\n+  int FUNCTION_NORMALIZE_SPACE = 59;\n+  int FUNCTION_TRANSLATE = 60;\n+  int FUNCTION_BOOLEAN = 61;\n+  int FUNCTION_NOT = 62;\n+  int FUNCTION_TRUE = 63;\n+  int FUNCTION_FALSE = 64;\n+  int FUNCTION_LANG = 65;\n+  int FUNCTION_NUMBER = 66;\n+  int FUNCTION_SUM = 67;\n+  int FUNCTION_FLOOR = 68;\n+  int FUNCTION_CEILING = 69;\n+  int FUNCTION_ROUND = 70;\n+  int NCName = 71;\n+\n+  int DEFAULT = 0;\n+\n+  String[] tokenImage = {\n+    \"<EOF>\",\n+    \"<S>\",\n+    \"\\\"/\\\"\",\n+    \"\\\"//\\\"\",\n+    \"\\\"|\\\"\",\n+    \"\\\"+\\\"\",\n+    \"\\\"-\\\"\",\n+    \"\\\"=\\\"\",\n+    \"\\\"!=\\\"\",\n+    \"\\\"<\\\"\",\n+    \"\\\"<=\\\"\",\n+    \"\\\">\\\"\",\n+    \"\\\">=\\\"\",\n+    \"\\\"$\\\"\",\n+    \"<Literal>\",\n+    \"<Digit>\",\n+    \"<Number>\",\n+    \"<Letter>\",\n+    \"<BaseChar>\",\n+    \"<Ideographic>\",\n+    \"<CombiningChar>\",\n+    \"<UnicodeDigit>\",\n+    \"<Extender>\",\n+    \"\\\"or\\\"\",\n+    \"\\\"and\\\"\",\n+    \"\\\"mod\\\"\",\n+    \"\\\"div\\\"\",\n+    \"\\\"node\\\"\",\n+    \"\\\"text\\\"\",\n+    \"\\\"comment\\\"\",\n+    \"\\\"processing-instruction\\\"\",\n+    \"\\\"self::\\\"\",\n+    \"\\\"child::\\\"\",\n+    \"\\\"parent::\\\"\",\n+    \"\\\"ancestor::\\\"\",\n+    \"\\\"attribute::\\\"\",\n+    \"\\\"namespace::\\\"\",\n+    \"\\\"preceding::\\\"\",\n+    \"\\\"following::\\\"\",\n+    \"\\\"descendant::\\\"\",\n+    \"\\\"ancestor-or-self::\\\"\",\n+    \"\\\"following-sibling::\\\"\",\n+    \"\\\"preceding-sibling::\\\"\",\n+    \"\\\"descendant-or-self::\\\"\",\n+    \"\\\"last\\\"\",\n+    \"\\\"position\\\"\",\n+    \"\\\"count\\\"\",\n+    \"\\\"id\\\"\",\n+    \"\\\"local-name\\\"\",\n+    \"\\\"namespace-uri\\\"\",\n+    \"\\\"name\\\"\",\n+    \"\\\"string\\\"\",\n+    \"\\\"concat\\\"\",\n+    \"\\\"starts-with\\\"\",\n+    \"\\\"contains\\\"\",\n+    \"\\\"substring-before\\\"\",\n+    \"\\\"substring-after\\\"\",\n+    \"\\\"substring\\\"\",\n+    \"\\\"string-length\\\"\",\n+    \"\\\"normalize-space\\\"\",\n+    \"\\\"translate\\\"\",\n+    \"\\\"boolean\\\"\",\n+    \"\\\"not\\\"\",\n+    \"\\\"true\\\"\",\n+    \"\\\"false\\\"\",\n+    \"\\\"lang\\\"\",\n+    \"\\\"number\\\"\",\n+    \"\\\"sum\\\"\",\n+    \"\\\"floor\\\"\",\n+    \"\\\"ceiling\\\"\",\n+    \"\\\"round\\\"\",\n+    \"<NCName>\",\n+    \"\\\":\\\"\",\n+    \"\\\"(\\\"\",\n+    \"\\\")\\\"\",\n+    \"\\\".\\\"\",\n+    \"\\\"..\\\"\",\n+    \"\\\"[\\\"\",\n+    \"\\\"]\\\"\",\n+    \"\\\"@\\\"\",\n+    \"\\\",\\\"\",\n+    \"\\\"*\\\"\",\n+  };\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n+/* Generated By:JavaCC: Do not edit this line. XPathParserTokenManager.java */\n+package org.apache.commons.jxpath.ri.parser;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import java.util.ArrayList;\n+\n+public class XPathParserTokenManager implements XPathParserConstants\n+{\n+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)\n+{\n+   switch (pos)\n+   {\n+      case 0:\n+         if ((active1 & 0x1800L) != 0L)\n+            return 11;\n+         if ((active0 & 0xffffffffff800000L) != 0L || (active1 & 0x7fL) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            return 13;\n+         }\n+         return -1;\n+      case 1:\n+         if ((active0 & 0x800000800000L) != 0L)\n+            return 13;\n+         if ((active0 & 0xffff7fffff000000L) != 0L || (active1 & 0x7fL) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 1;\n+            return 13;\n+         }\n+         return -1;\n+      case 2:\n+         if ((active0 & 0xbfff7ffff8000000L) != 0L || (active1 & 0x77L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 2;\n+            return 13;\n+         }\n+         if ((active0 & 0x4000000007000000L) != 0L || (active1 & 0x8L) != 0L)\n+            return 13;\n+         return -1;\n+      case 3:\n+         if ((active0 & 0x3ff96fefe0000000L) != 0L || (active1 & 0x75L) != 0L)\n+         {\n+            if (jjmatchedPos != 3)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 3;\n+            }\n+            return 13;\n+         }\n+         if ((active0 & 0x8006101018000000L) != 0L || (active1 & 0x2L) != 0L)\n+            return 13;\n+         return -1;\n+      case 4:\n+         if ((active0 & 0x80000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 3)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 3;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x400000000000L) != 0L || (active1 & 0x51L) != 0L)\n+            return 13;\n+         if ((active0 & 0x3ffb2fff60000000L) != 0L || (active1 & 0x24L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 4;\n+            return 13;\n+         }\n+         return -1;\n+      case 5:\n+         if ((active0 & 0x3be32ffe60000000L) != 0L || (active1 & 0x20L) != 0L)\n+         {\n+            if (jjmatchedPos != 5)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 5;\n+            }\n+            return 13;\n+         }\n+         if ((active0 & 0x100000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 4)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 4;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x80000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 3)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 3;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x418000000000000L) != 0L || (active1 & 0x4L) != 0L)\n+            return 13;\n+         return -1;\n+      case 6:\n+         if ((active0 & 0x200000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 5)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 5;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x100000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 4)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 4;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x1fe32ffc40000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 6;\n+            return 13;\n+         }\n+         if ((active0 & 0x2000000020000000L) != 0L || (active1 & 0x20L) != 0L)\n+            return 13;\n+         return -1;\n+      case 7:\n+         if ((active0 & 0x200000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 5)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 5;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x40200000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0x1fa30ffc40000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 7;\n+            return 13;\n+         }\n+         return -1;\n+      case 8:\n+         if ((active0 & 0xc230ff840000000L) != 0L)\n+         {\n+            if (jjmatchedPos != 8)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 8;\n+            }\n+            return 13;\n+         }\n+         if ((active0 & 0x400000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 7)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 7;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x1380000000000000L) != 0L)\n+            return 13;\n+         return -1;\n+      case 9:\n+         if ((active0 & 0x7800000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 8)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 8;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x400000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 7)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 7;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0xda20f8040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 9;\n+            return 13;\n+         }\n+         if ((active0 & 0x1000000000000L) != 0L)\n+            return 13;\n+         return -1;\n+      case 10:\n+         if ((active0 & 0x8000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 9)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 9;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x7800000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 8)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 8;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0xd820f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 10;\n+            return 13;\n+         }\n+         if ((active0 & 0x20000000000000L) != 0L)\n+            return 13;\n+         return -1;\n+      case 11:\n+         if ((active0 & 0x8000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 9)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 9;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0xd820f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 11;\n+            return 13;\n+         }\n+         return -1;\n+      case 12:\n+         if ((active0 & 0x9800f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 12;\n+            return 13;\n+         }\n+         if ((active0 & 0x402000000000000L) != 0L)\n+            return 13;\n+         return -1;\n+      case 13:\n+         if ((active0 & 0x9800f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 13;\n+            return 13;\n+         }\n+         return -1;\n+      case 14:\n+         if ((active0 & 0x900000000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0x800f0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 14;\n+            return 13;\n+         }\n+         return -1;\n+      case 15:\n+         if ((active0 & 0x80000000000000L) != 0L)\n+            return 13;\n+         if ((active0 & 0xf0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 15;\n+            return 13;\n+         }\n+         return -1;\n+      case 16:\n+         if ((active0 & 0x10000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 15)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 15;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0xe0040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 16;\n+            return 13;\n+         }\n+         return -1;\n+      case 17:\n+         if ((active0 & 0x60000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 16)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 16;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x10000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 15)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 15;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x80040000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 17;\n+            return 13;\n+         }\n+         return -1;\n+      case 18:\n+         if ((active0 & 0x80000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 17)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 17;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x60000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 16)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 16;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x40000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 18;\n+            return 13;\n+         }\n+         return -1;\n+      case 19:\n+         if ((active0 & 0x80000000000L) != 0L)\n+         {\n+            if (jjmatchedPos < 17)\n+            {\n+               jjmatchedKind = 71;\n+               jjmatchedPos = 17;\n+            }\n+            return -1;\n+         }\n+         if ((active0 & 0x40000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 19;\n+            return 13;\n+         }\n+         return -1;\n+      case 20:\n+         if ((active0 & 0x40000000L) != 0L)\n+         {\n+            jjmatchedKind = 71;\n+            jjmatchedPos = 20;\n+            return 13;\n+         }\n+         return -1;\n+      default :\n+         return -1;\n+   }\n+}\n+private final int jjStartNfa_0(int pos, long active0, long active1)\n+{\n+   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);\n+}\n+private final int jjStopAtPos(int pos, int kind)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   return pos + 1;\n+}\n+private final int jjStartNfaWithStates_0(int pos, int kind, int state)\n+{\n+   jjmatchedKind = kind;\n+   jjmatchedPos = pos;\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) { return pos + 1; }\n+   return jjMoveNfa_0(state, pos + 1);\n+}\n+private final int jjMoveStringLiteralDfa0_0()\n+{\n+   switch(curChar)\n+   {\n+      case 33:\n+         return jjMoveStringLiteralDfa1_0(0x100L, 0x0L);\n+      case 36:\n+         return jjStopAtPos(0, 13);\n+      case 40:\n+         return jjStopAtPos(0, 73);\n+      case 41:\n+         return jjStopAtPos(0, 74);\n+      case 42:\n+         return jjStopAtPos(0, 81);\n+      case 43:\n+         return jjStopAtPos(0, 5);\n+      case 44:\n+         return jjStopAtPos(0, 80);\n+      case 45:\n+         return jjStopAtPos(0, 6);\n+      case 46:\n+         jjmatchedKind = 75;\n+         return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L);\n+      case 47:\n+         jjmatchedKind = 2;\n+         return jjMoveStringLiteralDfa1_0(0x8L, 0x0L);\n+      case 58:\n+         return jjStopAtPos(0, 72);\n+      case 60:\n+         jjmatchedKind = 9;\n+         return jjMoveStringLiteralDfa1_0(0x400L, 0x0L);\n+      case 61:\n+         return jjStopAtPos(0, 7);\n+      case 62:\n+         jjmatchedKind = 11;\n+         return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L);\n+      case 64:\n+         return jjStopAtPos(0, 79);\n+      case 91:\n+         return jjStopAtPos(0, 77);\n+      case 93:\n+         return jjStopAtPos(0, 78);\n+      case 97:\n+         return jjMoveStringLiteralDfa1_0(0x10c01000000L, 0x0L);\n+      case 98:\n+         return jjMoveStringLiteralDfa1_0(0x2000000000000000L, 0x0L);\n+      case 99:\n+         return jjMoveStringLiteralDfa1_0(0x50400120000000L, 0x20L);\n+      case 100:\n+         return jjMoveStringLiteralDfa1_0(0x88004000000L, 0x0L);\n+      case 102:\n+         return jjMoveStringLiteralDfa1_0(0x24000000000L, 0x11L);\n+      case 105:\n+         return jjMoveStringLiteralDfa1_0(0x800000000000L, 0x0L);\n+      case 108:\n+         return jjMoveStringLiteralDfa1_0(0x1100000000000L, 0x2L);\n+      case 109:\n+         return jjMoveStringLiteralDfa1_0(0x2000000L, 0x0L);\n+      case 110:\n+         return jjMoveStringLiteralDfa1_0(0x4806001008000000L, 0x4L);\n+      case 111:\n+         return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);\n+      case 112:\n+         return jjMoveStringLiteralDfa1_0(0x242240000000L, 0x0L);\n+      case 114:\n+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40L);\n+      case 115:\n+         return jjMoveStringLiteralDfa1_0(0x7a8000080000000L, 0x8L);\n+      case 116:\n+         return jjMoveStringLiteralDfa1_0(0x9000000010000000L, 0x0L);\n+      case 124:\n+         return jjStopAtPos(0, 4);\n+      default :\n+         return jjMoveNfa_0(1, 0);\n+   }\n+}\n+private final int jjMoveStringLiteralDfa1_0(long active0, long active1)\n+{\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(0, active0, active1);\n+      return 1;\n+   }\n+   switch(curChar)\n+   {\n+      case 46:\n+         if ((active1 & 0x1000L) != 0L)\n+            return jjStopAtPos(1, 76);\n+         break;\n+      case 47:\n+         if ((active0 & 0x8L) != 0L)\n+            return jjStopAtPos(1, 3);\n+         break;\n+      case 61:\n+         if ((active0 & 0x100L) != 0L)\n+            return jjStopAtPos(1, 8);\n+         else if ((active0 & 0x400L) != 0L)\n+            return jjStopAtPos(1, 10);\n+         else if ((active0 & 0x1000L) != 0L)\n+            return jjStopAtPos(1, 12);\n+         break;\n+      case 97:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x6101200000000L, active1, 0x3L);\n+      case 100:\n+         if ((active0 & 0x800000000000L) != 0L)\n+            return jjStartNfaWithStates_0(1, 47, 13);\n+         break;\n+      case 101:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x88090000000L, active1, 0x20L);\n+      case 104:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x100000000L, active1, 0L);\n+      case 105:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x4000000L, active1, 0L);\n+      case 108:\n+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10L);\n+      case 110:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x10401000000L, active1, 0L);\n+      case 111:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x685162402a000000L, active1, 0x40L);\n+      case 114:\n+         if ((active0 & 0x800000L) != 0L)\n+            return jjStartNfaWithStates_0(1, 23, 13);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x9000042040000000L, active1, 0L);\n+      case 116:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x428000800000000L, active1, 0L);\n+      case 117:\n+         return jjMoveStringLiteralDfa2_0(active0, 0x380000000000000L, active1, 0xcL);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(0, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(0, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(1, active0, active1);\n+      return 2;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x1020000000000000L, active1, 0L);\n+      case 98:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x380000000000000L, active1, 0L);\n+      case 99:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x1010400000000L, active1, 0L);\n+      case 100:\n+         if ((active0 & 0x1000000L) != 0L)\n+            return jjStartNfaWithStates_0(2, 24, 13);\n+         else if ((active0 & 0x2000000L) != 0L)\n+            return jjStartNfaWithStates_0(2, 25, 13);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);\n+      case 101:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x42000000000L, active1, 0L);\n+      case 105:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0x20L);\n+      case 108:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x24080000000L, active1, 0x1L);\n+      case 109:\n+         if ((active1 & 0x8L) != 0L)\n+            return jjStartNfaWithStates_0(2, 67, 13);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x6001020000000L, active1, 0x4L);\n+      case 110:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x50000000000000L, active1, 0x2L);\n+      case 111:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x2000000040000000L, active1, 0x10L);\n+      case 114:\n+         return jjMoveStringLiteralDfa3_0(active0, 0xc08000200000000L, active1, 0L);\n+      case 115:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x388000000000L, active1, 0L);\n+      case 116:\n+         if ((active0 & 0x4000000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(2, 62, 13);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x800000000L, active1, 0L);\n+      case 117:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x8000400000000000L, active1, 0x40L);\n+      case 118:\n+         if ((active0 & 0x4000000L) != 0L)\n+            return jjStartNfaWithStates_0(2, 26, 13);\n+         break;\n+      case 120:\n+         return jjMoveStringLiteralDfa3_0(active0, 0x10000000L, active1, 0L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(1, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(1, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(2, active0, active1);\n+      return 3;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000L, active1, 0L);\n+      case 98:\n+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4L);\n+      case 99:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x100ca040000000L, active1, 0L);\n+      case 101:\n+         if ((active0 & 0x8000000L) != 0L)\n+            return jjStartNfaWithStates_0(3, 27, 13);\n+         else if ((active0 & 0x4000000000000L) != 0L)\n+         {\n+            jjmatchedKind = 50;\n+            jjmatchedPos = 3;\n+         }\n+         else if ((active0 & 0x8000000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(3, 63, 13);\n+         return jjMoveStringLiteralDfa4_0(active0, 0x2011600000000L, active1, 0L);\n+      case 102:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000L, active1, 0L);\n+      case 103:\n+         if ((active1 & 0x2L) != 0L)\n+            return jjStartNfaWithStates_0(3, 65, 13);\n+         break;\n+      case 105:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x408200000000000L, active1, 0L);\n+      case 108:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x2000024100000000L, active1, 0x20L);\n+      case 109:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x800000020000000L, active1, 0L);\n+      case 110:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x1000400000000000L, active1, 0x40L);\n+      case 111:\n+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x10L);\n+      case 114:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x20000800000000L, active1, 0L);\n+      case 115:\n+         return jjMoveStringLiteralDfa4_0(active0, 0x380000000000000L, active1, 0x1L);\n+      case 116:\n+         if ((active0 & 0x10000000L) != 0L)\n+            return jjStartNfaWithStates_0(3, 28, 13);\n+         else if ((active0 & 0x100000000000L) != 0L)\n+            return jjStartNfaWithStates_0(3, 44, 13);\n+         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000000L, active1, 0L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(2, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(2, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(3, active0, active1);\n+      return 4;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000L, active1, 0L);\n+      case 97:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x850000000000000L, active1, 0L);\n+      case 100:\n+         if ((active1 & 0x40L) != 0L)\n+            return jjStartNfaWithStates_0(4, 70, 13);\n+         return jjMoveStringLiteralDfa5_0(active0, 0x100000000L, active1, 0L);\n+      case 101:\n+         if ((active1 & 0x1L) != 0L)\n+            return jjStartNfaWithStates_0(4, 64, 13);\n+         return jjMoveStringLiteralDfa5_0(active0, 0x20000ca060000000L, active1, 0x4L);\n+      case 105:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0x20L);\n+      case 108:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x1000000000000L, active1, 0L);\n+      case 110:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x408000200000000L, active1, 0L);\n+      case 111:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x24000000000L, active1, 0L);\n+      case 114:\n+         if ((active1 & 0x10L) != 0L)\n+            return jjStartNfaWithStates_0(4, 68, 13);\n+         break;\n+      case 115:\n+         return jjMoveStringLiteralDfa5_0(active0, 0x1002011400000000L, active1, 0L);\n+      case 116:\n+         if ((active0 & 0x400000000000L) != 0L)\n+            return jjStartNfaWithStates_0(4, 46, 13);\n+         return jjMoveStringLiteralDfa5_0(active0, 0x3a0200000000000L, active1, 0L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(3, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(3, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(4, active0, active1);\n+      return 5;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x1000000000000L, active1, 0L);\n+      case 58:\n+         if ((active0 & 0x80000000L) != 0L)\n+            return jjStopAtPos(5, 31);\n+         return jjMoveStringLiteralDfa6_0(active0, 0x100000000L, active1, 0L);\n+      case 97:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000000000L, active1, 0L);\n+      case 98:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x800000000L, active1, 0L);\n+      case 100:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x42000000000L, active1, 0L);\n+      case 103:\n+         if ((active0 & 0x8000000000000L) != 0L)\n+         {\n+            jjmatchedKind = 51;\n+            jjmatchedPos = 5;\n+         }\n+         return jjMoveStringLiteralDfa6_0(active0, 0x400000000000000L, active1, 0L);\n+      case 105:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x40200000000000L, active1, 0L);\n+      case 108:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x1800000000000000L, active1, 0L);\n+      case 110:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x88020000000L, active1, 0x20L);\n+      case 112:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x2001000000000L, active1, 0L);\n+      case 114:\n+         if ((active1 & 0x4L) != 0L)\n+            return jjStartNfaWithStates_0(5, 66, 13);\n+         return jjMoveStringLiteralDfa6_0(active0, 0x380000000000000L, active1, 0L);\n+      case 115:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x20000040000000L, active1, 0L);\n+      case 116:\n+         if ((active0 & 0x10000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(5, 52, 13);\n+         return jjMoveStringLiteralDfa6_0(active0, 0x10600000000L, active1, 0L);\n+      case 119:\n+         return jjMoveStringLiteralDfa6_0(active0, 0x24000000000L, active1, 0L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(4, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(4, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(5, active0, active1);\n+      return 6;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x420000000000000L, active1, 0L);\n+      case 58:\n+         if ((active0 & 0x100000000L) != 0L)\n+            return jjStopAtPos(6, 32);\n+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000L, active1, 0L);\n+      case 97:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x1002001000000000L, active1, 0L);\n+      case 100:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x88000000000L, active1, 0L);\n+      case 103:\n+         if ((active1 & 0x20L) != 0L)\n+            return jjStartNfaWithStates_0(6, 69, 13);\n+         break;\n+      case 105:\n+         return jjMoveStringLiteralDfa7_0(active0, 0xb80066000000000L, active1, 0L);\n+      case 110:\n+         if ((active0 & 0x2000000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(6, 61, 13);\n+         return jjMoveStringLiteralDfa7_0(active0, 0x41000000000000L, active1, 0L);\n+      case 111:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x210400000000L, active1, 0L);\n+      case 115:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x40000000L, active1, 0L);\n+      case 116:\n+         if ((active0 & 0x20000000L) != 0L)\n+            return jjStartNfaWithStates_0(6, 29, 13);\n+         break;\n+      case 117:\n+         return jjMoveStringLiteralDfa7_0(active0, 0x800000000L, active1, 0L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(5, active0, active1);\n+}\n+private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1)\n+{\n+   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n+      return jjStartNfa_0(5, old0, old1); \n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(6, active0, 0L);\n+      return 7;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         if ((active0 & 0x200000000L) != 0L)\n+            return jjStopAtPos(7, 33);\n+         break;\n+      case 97:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x1088000000000L);\n+      case 99:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x2001000000000L);\n+      case 105:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000L);\n+      case 108:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L);\n+      case 110:\n+         if ((active0 & 0x200000000000L) != 0L)\n+            return jjStartNfaWithStates_0(7, 45, 13);\n+         return jjMoveStringLiteralDfa8_0(active0, 0x380066000000000L);\n+      case 114:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x10400000000L);\n+      case 115:\n+         if ((active0 & 0x40000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(7, 54, 13);\n+         break;\n+      case 116:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x1000000800000000L);\n+      case 119:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x20000000000000L);\n+      case 122:\n+         return jjMoveStringLiteralDfa8_0(active0, 0x800000000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(6, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa8_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(6, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(7, active0, 0L);\n+      return 8;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x10000000000L);\n+      case 58:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x400000000L);\n+      case 101:\n+         if ((active0 & 0x1000000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(8, 60, 13);\n+         return jjMoveStringLiteralDfa9_0(active0, 0xc02001800000000L);\n+      case 103:\n+         if ((active0 & 0x200000000000000L) != 0L)\n+         {\n+            jjmatchedKind = 57;\n+            jjmatchedPos = 8;\n+         }\n+         return jjMoveStringLiteralDfa9_0(active0, 0x180066000000000L);\n+      case 105:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L);\n+      case 109:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x1000000000000L);\n+      case 110:\n+         return jjMoveStringLiteralDfa9_0(active0, 0x88040000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(7, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa9_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(7, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(8, active0, 0L);\n+      return 9;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x982060000000000L);\n+      case 58:\n+         if ((active0 & 0x400000000L) != 0L)\n+            return jjStopAtPos(9, 34);\n+         return jjMoveStringLiteralDfa10_0(active0, 0x7800000000L);\n+      case 101:\n+         if ((active0 & 0x1000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(9, 48, 13);\n+         break;\n+      case 103:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x40000000L);\n+      case 110:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x400000000000000L);\n+      case 111:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x10000000000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa10_0(active0, 0x20088000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(8, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa10_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(8, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(9, active0, 0L);\n+      return 10;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x80040000000L);\n+      case 58:\n+         if ((active0 & 0x800000000L) != 0L)\n+            return jjStopAtPos(10, 35);\n+         else if ((active0 & 0x1000000000L) != 0L)\n+            return jjStopAtPos(10, 36);\n+         else if ((active0 & 0x2000000000L) != 0L)\n+            return jjStopAtPos(10, 37);\n+         else if ((active0 & 0x4000000000L) != 0L)\n+            return jjStopAtPos(10, 38);\n+         return jjMoveStringLiteralDfa11_0(active0, 0x8000000000L);\n+      case 97:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x100000000000000L);\n+      case 98:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x80000000000000L);\n+      case 103:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x400000000000000L);\n+      case 104:\n+         if ((active0 & 0x20000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(10, 53, 13);\n+         break;\n+      case 114:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x10000000000L);\n+      case 115:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x800060000000000L);\n+      case 117:\n+         return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(9, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa11_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(9, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(10, active0, 0L);\n+      return 11;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x10000000000L);\n+      case 58:\n+         if ((active0 & 0x8000000000L) != 0L)\n+            return jjStopAtPos(11, 39);\n+         break;\n+      case 101:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x80000000000000L);\n+      case 102:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x100000000000000L);\n+      case 105:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x60040000000L);\n+      case 111:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x80000000000L);\n+      case 112:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x800000000000000L);\n+      case 114:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa12_0(active0, 0x400000000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(10, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa12_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(10, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(11, active0, 0L);\n+      return 12;\n+   }\n+   switch(curChar)\n+   {\n+      case 97:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x800000000000000L);\n+      case 98:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x60000000000L);\n+      case 102:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x80000000000000L);\n+      case 104:\n+         if ((active0 & 0x400000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(12, 58, 13);\n+         break;\n+      case 105:\n+         if ((active0 & 0x2000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(12, 49, 13);\n+         break;\n+      case 110:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x40000000L);\n+      case 114:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x80000000000L);\n+      case 115:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x10000000000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa13_0(active0, 0x100000000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(11, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa13_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(11, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(12, active0, 0L);\n+      return 13;\n+   }\n+   switch(curChar)\n+   {\n+      case 45:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x80000000000L);\n+      case 99:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x800000000000000L);\n+      case 101:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x100010000000000L);\n+      case 108:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x60000000000L);\n+      case 111:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x80000000000000L);\n+      case 115:\n+         return jjMoveStringLiteralDfa14_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(12, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa14_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(12, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(13, active0, 0L);\n+      return 14;\n+   }\n+   switch(curChar)\n+   {\n+      case 101:\n+         if ((active0 & 0x800000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(14, 59, 13);\n+         break;\n+      case 105:\n+         return jjMoveStringLiteralDfa15_0(active0, 0x60000000000L);\n+      case 108:\n+         return jjMoveStringLiteralDfa15_0(active0, 0x10000000000L);\n+      case 114:\n+         if ((active0 & 0x100000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(14, 56, 13);\n+         return jjMoveStringLiteralDfa15_0(active0, 0x80000000000000L);\n+      case 115:\n+         return jjMoveStringLiteralDfa15_0(active0, 0x80000000000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa15_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(13, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa15_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(13, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(14, active0, 0L);\n+      return 15;\n+   }\n+   switch(curChar)\n+   {\n+      case 101:\n+         if ((active0 & 0x80000000000000L) != 0L)\n+            return jjStartNfaWithStates_0(15, 55, 13);\n+         return jjMoveStringLiteralDfa16_0(active0, 0x80000000000L);\n+      case 102:\n+         return jjMoveStringLiteralDfa16_0(active0, 0x10000000000L);\n+      case 110:\n+         return jjMoveStringLiteralDfa16_0(active0, 0x60000000000L);\n+      case 114:\n+         return jjMoveStringLiteralDfa16_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(14, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa16_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(14, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(15, active0, 0L);\n+      return 16;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         return jjMoveStringLiteralDfa17_0(active0, 0x10000000000L);\n+      case 103:\n+         return jjMoveStringLiteralDfa17_0(active0, 0x60000000000L);\n+      case 108:\n+         return jjMoveStringLiteralDfa17_0(active0, 0x80000000000L);\n+      case 117:\n+         return jjMoveStringLiteralDfa17_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(15, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa17_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(15, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(16, active0, 0L);\n+      return 17;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         if ((active0 & 0x10000000000L) != 0L)\n+            return jjStopAtPos(17, 40);\n+         return jjMoveStringLiteralDfa18_0(active0, 0x60000000000L);\n+      case 99:\n+         return jjMoveStringLiteralDfa18_0(active0, 0x40000000L);\n+      case 102:\n+         return jjMoveStringLiteralDfa18_0(active0, 0x80000000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(16, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa18_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(16, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(17, active0, 0L);\n+      return 18;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         if ((active0 & 0x20000000000L) != 0L)\n+            return jjStopAtPos(18, 41);\n+         else if ((active0 & 0x40000000000L) != 0L)\n+            return jjStopAtPos(18, 42);\n+         return jjMoveStringLiteralDfa19_0(active0, 0x80000000000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa19_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(17, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa19_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(17, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(18, active0, 0L);\n+      return 19;\n+   }\n+   switch(curChar)\n+   {\n+      case 58:\n+         if ((active0 & 0x80000000000L) != 0L)\n+            return jjStopAtPos(19, 43);\n+         break;\n+      case 105:\n+         return jjMoveStringLiteralDfa20_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(18, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa20_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(18, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(19, active0, 0L);\n+      return 20;\n+   }\n+   switch(curChar)\n+   {\n+      case 111:\n+         return jjMoveStringLiteralDfa21_0(active0, 0x40000000L);\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(19, active0, 0L);\n+}\n+private final int jjMoveStringLiteralDfa21_0(long old0, long active0)\n+{\n+   if (((active0 &= old0)) == 0L)\n+      return jjStartNfa_0(19, old0, 0L);\n+   try { curChar = input_stream.readChar(); }\n+   catch(java.io.IOException e) {\n+      jjStopStringLiteralDfa_0(20, active0, 0L);\n+      return 21;\n+   }\n+   switch(curChar)\n+   {\n+      case 110:\n+         if ((active0 & 0x40000000L) != 0L)\n+            return jjStartNfaWithStates_0(21, 30, 13);\n+         break;\n+      default :\n+         break;\n+   }\n+   return jjStartNfa_0(20, active0, 0L);\n+}\n+private final void jjCheckNAdd(int state)\n+{\n+   if (jjrounds[state] != jjround)\n+   {\n+      jjstateSet[jjnewStateCnt++] = state;\n+      jjrounds[state] = jjround;\n+   }\n+}\n+private final void jjAddStates(int start, int end)\n+{\n+   do {\n+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddTwoStates(int state1, int state2)\n+{\n+   jjCheckNAdd(state1);\n+   jjCheckNAdd(state2);\n+}\n+private final void jjCheckNAddStates(int start, int end)\n+{\n+   do {\n+      jjCheckNAdd(jjnextStates[start]);\n+   } while (start++ != end);\n+}\n+private final void jjCheckNAddStates(int start)\n+{\n+   jjCheckNAdd(jjnextStates[start]);\n+   jjCheckNAdd(jjnextStates[start + 1]);\n+}\n+static final long[] jjbitVec0 = {\n+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+static final long[] jjbitVec2 = {\n+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+static final long[] jjbitVec3 = {\n+   0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL\n+};\n+static final long[] jjbitVec4 = {\n+   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL\n+};\n+static final long[] jjbitVec5 = {\n+   0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL\n+};\n+static final long[] jjbitVec6 = {\n+   0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L\n+};\n+static final long[] jjbitVec7 = {\n+   0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL\n+};\n+static final long[] jjbitVec8 = {\n+   0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL\n+};\n+static final long[] jjbitVec9 = {\n+   0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L\n+};\n+static final long[] jjbitVec10 = {\n+   0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL\n+};\n+static final long[] jjbitVec11 = {\n+   0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L\n+};\n+static final long[] jjbitVec12 = {\n+   0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L\n+};\n+static final long[] jjbitVec13 = {\n+   0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L\n+};\n+static final long[] jjbitVec14 = {\n+   0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L\n+};\n+static final long[] jjbitVec15 = {\n+   0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L\n+};\n+static final long[] jjbitVec16 = {\n+   0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL\n+};\n+static final long[] jjbitVec17 = {\n+   0x0L, 0x3fffffffeffL, 0x0L, 0x0L\n+};\n+static final long[] jjbitVec18 = {\n+   0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL\n+};\n+static final long[] jjbitVec19 = {\n+   0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L\n+};\n+static final long[] jjbitVec20 = {\n+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL\n+};\n+static final long[] jjbitVec21 = {\n+   0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL\n+};\n+static final long[] jjbitVec22 = {\n+   0x4c4000000000L, 0x0L, 0x7L, 0x0L\n+};\n+static final long[] jjbitVec23 = {\n+   0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL\n+};\n+static final long[] jjbitVec24 = {\n+   0x1fffffffffe0L, 0x0L, 0x0L, 0x0L\n+};\n+static final long[] jjbitVec25 = {\n+   0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L\n+};\n+static final long[] jjbitVec26 = {\n+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L\n+};\n+static final long[] jjbitVec27 = {\n+   0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL\n+};\n+static final long[] jjbitVec28 = {\n+   0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L\n+};\n+static final long[] jjbitVec29 = {\n+   0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL\n+};\n+static final long[] jjbitVec30 = {\n+   0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL\n+};\n+static final long[] jjbitVec31 = {\n+   0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L\n+};\n+static final long[] jjbitVec32 = {\n+   0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL\n+};\n+static final long[] jjbitVec33 = {\n+   0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL\n+};\n+static final long[] jjbitVec34 = {\n+   0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL\n+};\n+static final long[] jjbitVec35 = {\n+   0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L\n+};\n+static final long[] jjbitVec36 = {\n+   0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL\n+};\n+static final long[] jjbitVec37 = {\n+   0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L\n+};\n+static final long[] jjbitVec38 = {\n+   0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL\n+};\n+static final long[] jjbitVec39 = {\n+   0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L\n+};\n+static final long[] jjbitVec40 = {\n+   0x0L, 0x0L, 0x0L, 0x21fff0000L\n+};\n+static final long[] jjbitVec41 = {\n+   0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL\n+};\n+private final int jjMoveNfa_0(int startState, int curPos)\n+{\n+   int[] nextStates;\n+   int startsAt = 0;\n+   jjnewStateCnt = 14;\n+   int i = 1;\n+   jjstateSet[0] = startState;\n+   int j, kind = 0x7fffffff;\n+   for (;;)\n+   {\n+      if (++jjround == 0x7fffffff)\n+         ReInitRounds();\n+      if (curChar < 64)\n+      {\n+         long l = 1L << curChar;\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 1:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                  {\n+                     if (kind > 16)\n+                        kind = 16;\n+                     jjCheckNAddTwoStates(7, 8);\n+                  }\n+                  else if ((0x100002600L & l) != 0L)\n+                  {\n+                     if (kind > 1)\n+                        kind = 1;\n+                     jjCheckNAdd(0);\n+                  }\n+                  else if (curChar == 46)\n+                     jjCheckNAdd(11);\n+                  else if (curChar == 39)\n+                     jjCheckNAddTwoStates(5, 6);\n+                  else if (curChar == 34)\n+                     jjCheckNAddTwoStates(2, 3);\n+                  break;\n+               case 0:\n+                  if ((0x100002600L & l) == 0L)\n+                     break;\n+                  if (kind > 1)\n+                     kind = 1;\n+                  jjCheckNAdd(0);\n+                  break;\n+               case 2:\n+                  if ((0xfffffffbffffffffL & l) != 0L)\n+                     jjCheckNAddTwoStates(2, 3);\n+                  break;\n+               case 3:\n+                  if (curChar == 34 && kind > 14)\n+                     kind = 14;\n+                  break;\n+               case 4:\n+                  if (curChar == 39)\n+                     jjCheckNAddTwoStates(5, 6);\n+                  break;\n+               case 5:\n+                  if ((0xffffff7fffffffffL & l) != 0L)\n+                     jjCheckNAddTwoStates(5, 6);\n+                  break;\n+               case 6:\n+                  if (curChar == 39 && kind > 14)\n+                     kind = 14;\n+                  break;\n+               case 7:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 16)\n+                     kind = 16;\n+                  jjCheckNAddTwoStates(7, 8);\n+                  break;\n+               case 8:\n+                  if (curChar != 46)\n+                     break;\n+                  if (kind > 16)\n+                     kind = 16;\n+                  jjCheckNAdd(9);\n+                  break;\n+               case 9:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 16)\n+                     kind = 16;\n+                  jjCheckNAdd(9);\n+                  break;\n+               case 10:\n+                  if (curChar == 46)\n+                     jjCheckNAdd(11);\n+                  break;\n+               case 11:\n+                  if ((0x3ff000000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 16)\n+                     kind = 16;\n+                  jjCheckNAdd(11);\n+                  break;\n+               case 13:\n+                  if ((0x3ff600000000000L & l) == 0L)\n+                     break;\n+                  if (kind > 71)\n+                     kind = 71;\n+                  jjstateSet[jjnewStateCnt++] = 13;\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else if (curChar < 128)\n+      {\n+         long l = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 1:\n+               case 13:\n+                  if ((0x7fffffe87fffffeL & l) == 0L)\n+                     break;\n+                  if (kind > 71)\n+                     kind = 71;\n+                  jjCheckNAdd(13);\n+                  break;\n+               case 2:\n+                  jjAddStates(0, 1);\n+                  break;\n+               case 5:\n+                  jjAddStates(2, 3);\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      else\n+      {\n+         int hiByte = (int)(curChar >> 8);\n+         int i1 = hiByte >> 6;\n+         long l1 = 1L << (hiByte & 077);\n+         int i2 = (curChar & 0xff) >> 6;\n+         long l2 = 1L << (curChar & 077);\n+         MatchLoop: do\n+         {\n+            switch(jjstateSet[--i])\n+            {\n+               case 1:\n+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n+                     break;\n+                  if (kind > 71)\n+                     kind = 71;\n+                  jjCheckNAdd(13);\n+                  break;\n+               case 2:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjAddStates(0, 1);\n+                  break;\n+               case 5:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjAddStates(2, 3);\n+                  break;\n+               case 13:\n+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))\n+                     break;\n+                  if (kind > 71)\n+                     kind = 71;\n+                  jjCheckNAdd(13);\n+                  break;\n+               default : break;\n+            }\n+         } while(i != startsAt);\n+      }\n+      if (kind != 0x7fffffff)\n+      {\n+         jjmatchedKind = kind;\n+         jjmatchedPos = curPos;\n+         kind = 0x7fffffff;\n+      }\n+      ++curPos;\n+      if ((i = jjnewStateCnt) == (startsAt = 14 - (jjnewStateCnt = startsAt)))\n+         return curPos;\n+      try { curChar = input_stream.readChar(); }\n+      catch(java.io.IOException e) { return curPos; }\n+   }\n+}\n+static final int[] jjnextStates = {\n+   2, 3, 5, 6, \n+};\n+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec2[i2] & l2) != 0L);\n+      default : \n+         if ((jjbitVec0[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec4[i2] & l2) != 0L);\n+      case 1:\n+         return ((jjbitVec5[i2] & l2) != 0L);\n+      case 2:\n+         return ((jjbitVec6[i2] & l2) != 0L);\n+      case 3:\n+         return ((jjbitVec7[i2] & l2) != 0L);\n+      case 4:\n+         return ((jjbitVec8[i2] & l2) != 0L);\n+      case 5:\n+         return ((jjbitVec9[i2] & l2) != 0L);\n+      case 6:\n+         return ((jjbitVec10[i2] & l2) != 0L);\n+      case 9:\n+         return ((jjbitVec11[i2] & l2) != 0L);\n+      case 10:\n+         return ((jjbitVec12[i2] & l2) != 0L);\n+      case 11:\n+         return ((jjbitVec13[i2] & l2) != 0L);\n+      case 12:\n+         return ((jjbitVec14[i2] & l2) != 0L);\n+      case 13:\n+         return ((jjbitVec15[i2] & l2) != 0L);\n+      case 14:\n+         return ((jjbitVec16[i2] & l2) != 0L);\n+      case 15:\n+         return ((jjbitVec17[i2] & l2) != 0L);\n+      case 16:\n+         return ((jjbitVec18[i2] & l2) != 0L);\n+      case 17:\n+         return ((jjbitVec19[i2] & l2) != 0L);\n+      case 30:\n+         return ((jjbitVec20[i2] & l2) != 0L);\n+      case 31:\n+         return ((jjbitVec21[i2] & l2) != 0L);\n+      case 33:\n+         return ((jjbitVec22[i2] & l2) != 0L);\n+      case 48:\n+         return ((jjbitVec23[i2] & l2) != 0L);\n+      case 49:\n+         return ((jjbitVec24[i2] & l2) != 0L);\n+      case 159:\n+         return ((jjbitVec25[i2] & l2) != 0L);\n+      case 215:\n+         return ((jjbitVec26[i2] & l2) != 0L);\n+      default : \n+         if ((jjbitVec3[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)\n+{\n+   switch(hiByte)\n+   {\n+      case 0:\n+         return ((jjbitVec27[i2] & l2) != 0L);\n+      case 1:\n+         return ((jjbitVec5[i2] & l2) != 0L);\n+      case 2:\n+         return ((jjbitVec28[i2] & l2) != 0L);\n+      case 3:\n+         return ((jjbitVec29[i2] & l2) != 0L);\n+      case 4:\n+         return ((jjbitVec30[i2] & l2) != 0L);\n+      case 5:\n+         return ((jjbitVec31[i2] & l2) != 0L);\n+      case 6:\n+         return ((jjbitVec32[i2] & l2) != 0L);\n+      case 9:\n+         return ((jjbitVec33[i2] & l2) != 0L);\n+      case 10:\n+         return ((jjbitVec34[i2] & l2) != 0L);\n+      case 11:\n+         return ((jjbitVec35[i2] & l2) != 0L);\n+      case 12:\n+         return ((jjbitVec36[i2] & l2) != 0L);\n+      case 13:\n+         return ((jjbitVec37[i2] & l2) != 0L);\n+      case 14:\n+         return ((jjbitVec38[i2] & l2) != 0L);\n+      case 15:\n+         return ((jjbitVec39[i2] & l2) != 0L);\n+      case 16:\n+         return ((jjbitVec18[i2] & l2) != 0L);\n+      case 17:\n+         return ((jjbitVec19[i2] & l2) != 0L);\n+      case 30:\n+         return ((jjbitVec20[i2] & l2) != 0L);\n+      case 31:\n+         return ((jjbitVec21[i2] & l2) != 0L);\n+      case 32:\n+         return ((jjbitVec40[i2] & l2) != 0L);\n+      case 33:\n+         return ((jjbitVec22[i2] & l2) != 0L);\n+      case 48:\n+         return ((jjbitVec41[i2] & l2) != 0L);\n+      case 49:\n+         return ((jjbitVec24[i2] & l2) != 0L);\n+      case 159:\n+         return ((jjbitVec25[i2] & l2) != 0L);\n+      case 215:\n+         return ((jjbitVec26[i2] & l2) != 0L);\n+      default : \n+         if ((jjbitVec3[i1] & l1) != 0L)\n+            return true;\n+         return false;\n+   }\n+}\n+public static final String[] jjstrLiteralImages = {\n+\"\", null, \"\\57\", \"\\57\\57\", \"\\174\", \"\\53\", \"\\55\", \"\\75\", \"\\41\\75\", \"\\74\", \n+\"\\74\\75\", \"\\76\", \"\\76\\75\", \"\\44\", null, null, null, null, null, null, null, null, null, \n+\"\\157\\162\", \"\\141\\156\\144\", \"\\155\\157\\144\", \"\\144\\151\\166\", \"\\156\\157\\144\\145\", \n+\"\\164\\145\\170\\164\", \"\\143\\157\\155\\155\\145\\156\\164\", \n+\"\\160\\162\\157\\143\\145\\163\\163\\151\\156\\147\\55\\151\\156\\163\\164\\162\\165\\143\\164\\151\\157\\156\", \"\\163\\145\\154\\146\\72\\72\", \"\\143\\150\\151\\154\\144\\72\\72\", \n+\"\\160\\141\\162\\145\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\72\\72\", \n+\"\\141\\164\\164\\162\\151\\142\\165\\164\\145\\72\\72\", \"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\72\\72\", \n+\"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\72\\72\", \"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\72\\72\", \n+\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\", \n+\"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\", \"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\", \n+\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\", \"\\154\\141\\163\\164\", \"\\160\\157\\163\\151\\164\\151\\157\\156\", \n+\"\\143\\157\\165\\156\\164\", \"\\151\\144\", \"\\154\\157\\143\\141\\154\\55\\156\\141\\155\\145\", \n+\"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\55\\165\\162\\151\", \"\\156\\141\\155\\145\", \"\\163\\164\\162\\151\\156\\147\", \"\\143\\157\\156\\143\\141\\164\", \n+\"\\163\\164\\141\\162\\164\\163\\55\\167\\151\\164\\150\", \"\\143\\157\\156\\164\\141\\151\\156\\163\", \n+\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\142\\145\\146\\157\\162\\145\", \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\141\\146\\164\\145\\162\", \n+\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\", \"\\163\\164\\162\\151\\156\\147\\55\\154\\145\\156\\147\\164\\150\", \n+\"\\156\\157\\162\\155\\141\\154\\151\\172\\145\\55\\163\\160\\141\\143\\145\", \"\\164\\162\\141\\156\\163\\154\\141\\164\\145\", \"\\142\\157\\157\\154\\145\\141\\156\", \n+\"\\156\\157\\164\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\154\\141\\156\\147\", \n+\"\\156\\165\\155\\142\\145\\162\", \"\\163\\165\\155\", \"\\146\\154\\157\\157\\162\", \"\\143\\145\\151\\154\\151\\156\\147\", \n+\"\\162\\157\\165\\156\\144\", null, \"\\72\", \"\\50\", \"\\51\", \"\\56\", \"\\56\\56\", \"\\133\", \"\\135\", \"\\100\", \"\\54\", \n+\"\\52\", };\n+public static final String[] lexStateNames = {\n+   \"DEFAULT\", \n+};\n+static final long[] jjtoToken = {\n+   0xffffffffff817ffdL, 0x3ffffL, \n+};\n+static final long[] jjtoSkip = {\n+   0x2L, 0x0L, \n+};\n+static final long[] jjtoSpecial = {\n+   0x2L, 0x0L, \n+};\n+private ASCII_UCodeESC_CharStream input_stream;\n+private final int[] jjrounds = new int[14];\n+private final int[] jjstateSet = new int[28];\n+protected char curChar;\n+public XPathParserTokenManager(ASCII_UCodeESC_CharStream stream)\n+{\n+   if (ASCII_UCodeESC_CharStream.staticFlag)\n+      throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n+   input_stream = stream;\n+}\n+public XPathParserTokenManager(ASCII_UCodeESC_CharStream stream, int lexState)\n+{\n+   this(stream);\n+   SwitchTo(lexState);\n+}\n+public void ReInit(ASCII_UCodeESC_CharStream stream)\n+{\n+   jjmatchedPos = jjnewStateCnt = 0;\n+   curLexState = defaultLexState;\n+   input_stream = stream;\n+   ReInitRounds();\n+}\n+private final void ReInitRounds()\n+{\n+   int i;\n+   jjround = 0x80000001;\n+   for (i = 14; i-- > 0;)\n+      jjrounds[i] = 0x80000000;\n+}\n+public void ReInit(ASCII_UCodeESC_CharStream stream, int lexState)\n+{\n+   ReInit(stream);\n+   SwitchTo(lexState);\n+}\n+public void SwitchTo(int lexState)\n+{\n+   if (lexState >= 1 || lexState < 0)\n+      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n+   else\n+      curLexState = lexState;\n+}\n+\n+private final Token jjFillToken()\n+{\n+   Token t = Token.newToken(jjmatchedKind);\n+   t.kind = jjmatchedKind;\n+   String im = jjstrLiteralImages[jjmatchedKind];\n+   t.image = (im == null) ? input_stream.GetImage() : im;\n+   t.beginLine = input_stream.getBeginLine();\n+   t.beginColumn = input_stream.getBeginColumn();\n+   t.endLine = input_stream.getEndLine();\n+   t.endColumn = input_stream.getEndColumn();\n+   return t;\n+}\n+\n+int curLexState = 0;\n+int defaultLexState = 0;\n+int jjnewStateCnt;\n+int jjround;\n+int jjmatchedPos;\n+int jjmatchedKind;\n+\n+public final Token getNextToken() \n+{\n+  int kind;\n+  Token specialToken = null;\n+  Token matchedToken;\n+  int curPos = 0;\n+\n+  EOFLoop :\n+  for (;;)\n+  {   \n+   try   \n+   {     \n+      curChar = input_stream.BeginToken();\n+   }     \n+   catch(java.io.IOException e)\n+   {        \n+      jjmatchedKind = 0;\n+      matchedToken = jjFillToken();\n+      matchedToken.specialToken = specialToken;\n+      return matchedToken;\n+   }\n+\n+   jjmatchedKind = 0x7fffffff;\n+   jjmatchedPos = 0;\n+   curPos = jjMoveStringLiteralDfa0_0();\n+   if (jjmatchedKind != 0x7fffffff)\n+   {\n+      if (jjmatchedPos + 1 < curPos)\n+         input_stream.backup(curPos - jjmatchedPos - 1);\n+      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+      {\n+         matchedToken = jjFillToken();\n+         matchedToken.specialToken = specialToken;\n+         return matchedToken;\n+      }\n+      else\n+      {\n+         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n+         {\n+            matchedToken = jjFillToken();\n+            if (specialToken == null)\n+               specialToken = matchedToken;\n+            else\n+            {\n+               matchedToken.specialToken = specialToken;\n+               specialToken = (specialToken.next = matchedToken);\n+            }\n+         }\n+         continue EOFLoop;\n+      }\n+   }\n+   int error_line = input_stream.getEndLine();\n+   int error_column = input_stream.getEndColumn();\n+   String error_after = null;\n+   boolean EOFSeen = false;\n+   try { input_stream.readChar(); input_stream.backup(1); }\n+   catch (java.io.IOException e1) {\n+      EOFSeen = true;\n+      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+      if (curChar == '\\n' || curChar == '\\r') {\n+         error_line++;\n+         error_column = 0;\n+      }\n+      else\n+         error_column++;\n+   }\n+   if (!EOFSeen) {\n+      input_stream.backup(1);\n+      error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n+   }\n+   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n+  }\n+}\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * A Pointer that points to a JavaBean or a collection. It is the first element of\n+ * a path, following elements will by of type PropertyPointer.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class BeanPointer extends NodePointer {\n+    private QName name;\n+    private Object bean;\n+    private JXPathBeanInfo beanInfo;\n+    private PropertyDescriptor propertyDescriptors[];\n+    private String[] names;\n+\n+    /**\n+     * @param name is the name given to the first node\n+     */\n+    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo){\n+        super(null);\n+        this.name = name;\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the bean itself\n+     */\n+    public Object getPropertyValue(){\n+        return bean;\n+    }\n+\n+    /**\n+     * Throws an exception - you cannot change the root element.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+    }\n+\n+    /**\n+     * If the bean is a collection, returns the length of that collection,\n+     * otherwise returns 1.\n+     */\n+    public int getLength(){\n+        return PropertyAccessHelper.getLength(getPropertyValue());\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(bean) + name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof BeanPointer)){\n+            return false;\n+        }\n+\n+        BeanPointer other = (BeanPointer)object;\n+        return bean == other.bean &&\n+                name.equals(other.name);\n+    }\n+\n+    /**\n+     * Empty string\n+     */\n+    public String asPath(){\n+        return \"\";\n+    }\n+\n+    public String toString(){\n+        return bean.getClass().getName() + \"@\" + System.identityHashCode(bean) +\n+            \"(\" + name + \")\";\n+    }\n+\n+    public Object clone(){\n+        BeanPointer pointer = new BeanPointer(name, bean, beanInfo);\n+        pointer.index = index;\n+        pointer.value = value;\n+        pointer.propertyDescriptors = propertyDescriptors;\n+        pointer.names = names;\n+        return pointer;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Pointer pointing to a property of a JavaBean.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class BeanPropertyPointer extends PropertyPointer {\n+    private JXPathBeanInfo beanInfo;\n+    private PropertyDescriptor propertyDescriptors[];\n+    private PropertyDescriptor propertyDescriptor;\n+    private String[] names;\n+\n+    public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo){\n+        super(parent);\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    /**\n+     * Number of the bean's properties.\n+     */\n+    public int getPropertyCount(){\n+        return getPropertyDescriptors().length;\n+    }\n+\n+    /**\n+     * Names of all properties, sorted alphabetically\n+     */\n+    public String[] getPropertyNames(){\n+        if (names == null){\n+            PropertyDescriptor pds[] = getPropertyDescriptors();\n+            names = new String[pds.length];\n+            for (int i = 0; i < names.length; i++){\n+                names[i] = pds[i].getName();\n+            }\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Select a property by name\n+     */\n+    public void setPropertyName(String propertyName){\n+        setPropertyIndex(UNSPECIFIED);\n+        String[] names = getPropertyNames();\n+        for (int i = 0; i < names.length; i++){\n+            if (names[i].equals(propertyName)){\n+                propertyIndex = i;\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Selects a property by its offset in the alphabetically sorted list.\n+     */\n+    public void setPropertyIndex(int index){\n+        if (propertyIndex != index){\n+            super.setPropertyIndex(index);\n+            propertyDescriptor = null;\n+            value = UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * If the property contains a collection, then the length of that\n+     * collection, otherwise - 1.\n+     */\n+    public int getLength(){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            return 0;\n+        }\n+        return PropertyAccessHelper.getLength(getBean(), pd);\n+    }\n+\n+    /**\n+     * The value of the currently selected property.\n+     */\n+    public Object getPropertyValue(){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            return null;\n+        }\n+        return PropertyAccessHelper.getValue(getBean(), pd);\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, the value of the property, otherwise\n+     * the value of the index'th element of the collection represented by the\n+     * property. If the property is not a collection, index should be zero\n+     * and the value will be the property itself.\n+     */\n+    public Object getValue(){\n+        if (value == UNKNOWN){\n+            PropertyDescriptor pd = getPropertyDescriptor();\n+            if (pd == null){\n+                value = null;\n+            }\n+            else {\n+                if (index == WHOLE_COLLECTION){\n+                    value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor());\n+                }\n+                else {\n+                    value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor(), index);\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n+     * change the value of the index'th element of the collection\n+     * represented by the property.\n+     */\n+    public void setValue(Object value){\n+        this.value = value;\n+        if (index == WHOLE_COLLECTION){\n+            PropertyAccessHelper.setValue(getBean(), getPropertyDescriptor(), value);\n+        }\n+        else {\n+            PropertyAccessHelper.setValue(getBean(), getPropertyDescriptor(), index, value);\n+        }\n+    }\n+\n+    /**\n+     * Name of the currently selected property.\n+     */\n+    public String getPropertyName(){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            return \"*\";\n+        }\n+        return pd.getName();\n+    }\n+\n+    public PropertyPointer copy(){\n+        BeanPropertyPointer newHolder = new BeanPropertyPointer(getParent(), beanInfo);\n+        newHolder.propertyIndex = propertyIndex;\n+        newHolder.propertyDescriptors = propertyDescriptors;\n+        newHolder.propertyDescriptor = propertyDescriptor;\n+        newHolder.names = names;\n+        newHolder.bean = bean;\n+        newHolder.value = value;\n+        newHolder.index = index;\n+        return newHolder;\n+    }\n+\n+    public Object clone(){\n+        return copy();\n+    }\n+\n+    /**\n+     * Finds the property descriptor corresponding to the current property index.\n+     */\n+    private PropertyDescriptor getPropertyDescriptor(){\n+        if (propertyDescriptor == null){\n+            int inx = getPropertyIndex();\n+            PropertyDescriptor propertyDescriptors[] = getPropertyDescriptors();\n+            if (inx >=0 && inx < propertyDescriptors.length){\n+                propertyDescriptor = propertyDescriptors[inx];\n+            }\n+            else {\n+                propertyDescriptor = null;\n+            }\n+        }\n+        return propertyDescriptor;\n+    }\n+\n+    protected PropertyDescriptor[] getPropertyDescriptors(){\n+        if (propertyDescriptors == null){\n+            propertyDescriptors = beanInfo.getPropertyDescriptors();\n+        }\n+        return propertyDescriptors;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * A Pointer that points to an object with Dynamic Properties. It is used\n+ * for the first element of a path; following elements will by of type PropertyPointer.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class DynamicPointer extends NodePointer {\n+    private QName name;\n+    private Object bean;\n+    private DynamicPropertyHandler handler;\n+    private String[] names;\n+\n+    public DynamicPointer(QName name, Object bean, DynamicPropertyHandler handler){\n+        super(null);\n+        this.name = name;\n+        this.bean = bean;\n+        this.handler = handler;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the DP object iself.\n+     */\n+    public Object getPropertyValue(){\n+        return bean;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot replace the root object\");\n+    }\n+\n+    /**\n+     * If the bean is a collection, returns the length of that collection,\n+     * otherwise returns 1.\n+     */\n+    public int getLength(){\n+        return PropertyAccessHelper.getLength(getPropertyValue());\n+    }\n+\n+    /**\n+     * Empty string\n+     */\n+    public String asPath(){\n+        return \"\";\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(bean) + name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DynamicPointer)){\n+            return false;\n+        }\n+\n+        DynamicPointer other = (DynamicPointer)object;\n+        return bean == other.bean && name.equals(other.name);\n+    }\n+\n+    public String toString(){\n+        return bean.getClass().getName() + \"@\" + System.identityHashCode(bean) +\n+            \"(\" + name + \")\";\n+    }\n+\n+    public Object clone(){\n+        DynamicPointer pointer = new DynamicPointer(name, bean, handler);\n+        pointer.index = index;\n+        pointer.value = value;\n+        pointer.names = names;\n+        return pointer;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Pointer pointing to a property of an object with dynamic properties.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class DynamicPropertyPointer extends PropertyPointer {\n+    private DynamicPropertyHandler handler;\n+    private String name;\n+    private String[] names;\n+    private String requiredPropertyName;\n+\n+    public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler){\n+        super(parent);\n+        this.handler = handler;\n+    }\n+\n+    /**\n+     * Number of the DP object's properties.\n+     */\n+    public int getPropertyCount(){\n+        return getPropertyNames().length;\n+    }\n+\n+    /**\n+     * Names of all properties, sorted alphabetically\n+     */\n+    public String[] getPropertyNames(){\n+        if (names == null){\n+            String allNames[] = handler.getPropertyNames(getBean());\n+            names = new String[allNames.length];\n+            for (int i = 0; i < names.length; i++){\n+                names[i] = allNames[i];\n+            }\n+            Arrays.sort(names);\n+            if (requiredPropertyName != null){\n+                int inx = Arrays.binarySearch(names, requiredPropertyName);\n+                if (inx < 0){\n+                    allNames = names;\n+                    names = new String[allNames.length + 1];\n+                    names[0] = requiredPropertyName;\n+                    System.arraycopy(allNames, 0, names, 1, allNames.length);\n+                    Arrays.sort(names);\n+                }\n+            }\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Returns the name of the currently selected property or \"*\"\n+     * if none has been selected.\n+     */\n+    public String getPropertyName(){\n+        if (name == null){\n+            String names[] = getPropertyNames();\n+            if (propertyIndex >=0 && propertyIndex < names.length){\n+                name = names[propertyIndex];\n+            }\n+            else {\n+                name = \"*\";\n+            }\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Select a property by name.  If the supplied name is\n+     * not one of the object's existing properties, it implicitly\n+     * adds this name to the object's property name list. It does not\n+     * set the property value though. In order to set the property\n+     * value, call setValue().\n+     */\n+    public void setPropertyName(String propertyName){\n+        setPropertyIndex(UNSPECIFIED);\n+        this.name = propertyName;\n+        requiredPropertyName = propertyName;\n+        if (names != null && Arrays.binarySearch(names, propertyName) < 0){\n+            names = null;\n+        }\n+    }\n+\n+    /**\n+     * Index of the currently selected property in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public int getPropertyIndex(){\n+        if (propertyIndex == UNSPECIFIED){\n+            String names[] = getPropertyNames();\n+            for (int i = 0; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    setPropertyIndex(i);\n+                    break;\n+                }\n+            }\n+        }\n+        return super.getPropertyIndex();\n+    }\n+\n+    /**\n+     * Index a property by its index in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public void setPropertyIndex(int index){\n+        if (propertyIndex != index){\n+            super.setPropertyIndex(index);\n+            name = null;\n+            value = UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * If the property contains a collection, then the length of that\n+     * collection, otherwise - 1.\n+     */\n+    public int getLength(){\n+        return PropertyAccessHelper.getLength(getValue());\n+    }\n+\n+    /**\n+     * Returns the value of the property, not an element of the collection\n+     * represented by the property, if any.\n+     */\n+    public Object getPropertyValue(){\n+        return handler.getProperty(getBean(), getPropertyName());\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, the value of the property, otherwise\n+     * the value of the index'th element of the collection represented by the\n+     * property. If the property is not a collection, index should be zero\n+     * and the value will be the property itself.\n+     */\n+    public Object getValue(){\n+        if (value == UNKNOWN){\n+            if (index == WHOLE_COLLECTION){\n+                value = handler.getProperty(getBean(), getPropertyName());\n+            }\n+            else {\n+                value = PropertyAccessHelper.getValue(handler.getProperty(getBean(), getPropertyName()), index);\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n+     * change the value of the index'th element of the collection\n+     * represented by the property.\n+     */\n+    public void setValue(Object value){\n+        this.value = value;\n+        if (index == WHOLE_COLLECTION){\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            PropertyAccessHelper.setValue(handler.getProperty(getBean(), getPropertyName()), index, value);\n+        }\n+    }\n+\n+    public PropertyPointer copy(){\n+        DynamicPropertyPointer newHolder = new DynamicPropertyPointer(getParent(), handler);\n+        newHolder.propertyIndex = propertyIndex;\n+        newHolder.name = name;\n+        newHolder.names = names;\n+        newHolder.bean = bean;\n+        newHolder.value = value;\n+        newHolder.index = index;\n+        return newHolder;\n+    }\n+\n+    public Object clone(){\n+        return copy();\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getParent().asPath());\n+        buffer.append(\"[@name='\");\n+        buffer.append(escape(getPropertyName()));\n+        buffer.append(\"']\");\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public abstract class NodePointer implements Pointer, Cloneable {\n+\n+    public static NodePointer createNodePointer(QName name, Object bean){\n+        if (bean == null){\n+            return new NullPointer(name);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(name, bean, handler);\n+        }\n+        else {\n+            return new BeanPointer(name, bean, bi);\n+        }\n+    }\n+\n+    public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n+    public static int UNSPECIFIED = Integer.MIN_VALUE;\n+    protected static Object UNKNOWN = new Object();\n+\n+    protected NodePointer parent;\n+    protected int index = WHOLE_COLLECTION;\n+    protected Object value = UNKNOWN;\n+\n+    protected NodePointer(NodePointer parent){\n+        this.parent = parent;\n+    }\n+\n+    public NodePointer getParent(){\n+        return parent;\n+    }\n+\n+    public int getIndex(){\n+        return index;\n+    }\n+\n+    public void setIndex(int index){\n+        this.index = index;\n+        this.value = UNKNOWN;\n+    }\n+\n+    public boolean isRoot(){\n+        return parent == null;\n+    }\n+\n+    public boolean isAtomic(){\n+        Object value = getValue();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+    }\n+\n+    public boolean isDynamic(){\n+        Object value = getValue();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isDynamic();\n+    }\n+\n+    public boolean isCollection(){\n+        Object value = getPropertyValue();\n+        return value != null && PropertyAccessHelper.isCollection(value);\n+    }\n+\n+    public Object getValue(){\n+        if (value == UNKNOWN){\n+            if (index == WHOLE_COLLECTION){\n+                value = getPropertyValue();\n+            }\n+            else {\n+                value = PropertyAccessHelper.getValue(getPropertyValue(), index);\n+            }\n+        }\n+        return value;\n+    }\n+\n+    public abstract QName getName();\n+    public abstract void setValue(Object value);\n+    public abstract String asPath();\n+    public abstract Object clone();\n+\n+    public PropertyPointer getPropertyPointer(){\n+        Object value = getValue();\n+        if (value == null){\n+            return new NullPropertyPointer(this);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(value.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPropertyPointer(this, handler);\n+        }\n+        else {\n+            return new BeanPropertyPointer(this, bi);\n+        }\n+    }\n+\n+    public abstract Object getPropertyValue();\n+    public abstract int getLength();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class NullPointer extends NodePointer {\n+    private QName name;\n+\n+    /**\n+     * Used for the root node\n+     */\n+    public NullPointer(QName name){\n+        super(null);\n+        this.name = name;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    public Object getPropertyValue(){\n+        return null;\n+    }\n+\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+    }\n+\n+    public int hashCode(){\n+        return name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NullPointer)){\n+            return false;\n+        }\n+\n+        NullPointer other = (NullPointer)object;\n+        return name.equals(other.name);\n+    }\n+\n+    public String toString(){\n+        return \"null(\" + name + \")\";\n+    }\n+\n+    public String asPath(){\n+        System.err.println(\"NULL POINTER\");\n+        return \"\";\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+\n+    public Object clone(){\n+        return new NullPointer(name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class NullPropertyPointer extends PropertyPointer {\n+\n+    private String propertyName = \"*\";\n+\n+    /**\n+     */\n+    public NullPropertyPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public void setPropertyIndex(int index){\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+\n+    public Object getPropertyValue(){\n+        return null;\n+    }\n+\n+    public Object getValue(){\n+        return null;\n+    }\n+\n+    public void setValue(Object value){\n+        throw new RuntimeException(\"Cannot set property \" + asPath() +\n+            \", the target object is null\");\n+    }\n+\n+    public String getPropertyName(){\n+        return propertyName;\n+    }\n+\n+    public void setPropertyName(String propertyName){\n+        this.propertyName = propertyName;\n+    }\n+\n+    public int getPropertyCount(){\n+        return 0;\n+    }\n+\n+    public String[] getPropertyNames(){\n+        return new String[0];\n+    }\n+\n+    public PropertyPointer copy(){\n+        NullPropertyPointer newHolder = new NullPropertyPointer(getParent());\n+        newHolder.propertyName = propertyName;\n+        return newHolder;\n+    }\n+\n+    public Object clone(){\n+        return copy();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyAccessHelper.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyAccessHelper.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class PropertyAccessHelper {\n+    private static Map dynamicPropertyHandlerMap = new HashMap();\n+\n+    public static boolean isCollection(PropertyDescriptor propertyDescriptor){\n+        return false;\n+    }\n+\n+    public static boolean isCollection(PropertyDescriptor propertyDescriptor, Object value){\n+        return isCollection(value);\n+    }\n+\n+    public static boolean isCollection(Object value){\n+        if (value == null){\n+            return false;\n+        }\n+        else if (value.getClass().isArray()){\n+            return true;\n+        }\n+        else if (value instanceof Collection){\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static int getLength(Object bean, PropertyDescriptor propertyDescriptor){\n+        Object obj = getValue(bean, propertyDescriptor);\n+        return getLength(obj);\n+    }\n+\n+    public static int getLength(Object collection){\n+        if (collection == null){\n+            return 0;\n+        }\n+        else if (collection.getClass().isArray()){\n+            return Array.getLength(collection);\n+        }\n+        else if (collection instanceof Collection){\n+            return ((Collection)collection).size();\n+        }\n+        else {\n+            return 1;\n+        }\n+    }\n+\n+    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index){\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+            Object value;\n+            try {\n+                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                Method method = ipd.getIndexedReadMethod();\n+                if (method != null){\n+                    return method.invoke(bean, new Object[]{new Integer(index)});\n+                }\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                    \", \" + ex.getMessage());\n+            }\n+        }\n+        // We will fall through if there is no indexed read\n+\n+        return getValue(getValue(bean, propertyDescriptor), index);\n+    }\n+\n+    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value){\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+            try {\n+                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                Method method = ipd.getIndexedWriteMethod();\n+                if (method != null){\n+                    method.invoke(bean, new Object[]{new Integer(index), value});\n+                    return;\n+                }\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                    \", \" + ex.getMessage());\n+            }\n+        }\n+        // We will fall through if there is no indexed read\n+        setValue(getValue(bean, propertyDescriptor), index, value);\n+    }\n+\n+    public static Object getValue(Object collection, int index){\n+        Object value = collection;\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                value = Array.get(collection, index);\n+            }\n+            else if (collection instanceof List){\n+                value = ((List)collection).get(index);\n+            }\n+            else if (collection instanceof Collection){\n+                Iterator it = ((Collection)collection).iterator();\n+                for (int i = 0; i <= index; i++){\n+                    value = it.next();\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    public static void setValue(Object collection, int index, Object value){\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                Array.set(collection, index, value);\n+            }\n+            else if (collection instanceof List){\n+                ((List)collection).set(index, value);\n+            }\n+            else if (collection instanceof Collection){\n+                throw new UnsupportedOperationException(\"Cannot set value of an element of a \" +\n+                        collection.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor){\n+        Object value;\n+        try {\n+            Method method = propertyDescriptor.getReadMethod();\n+            if (method == null){\n+                throw new RuntimeException(\"No read method\");\n+            }\n+            value = method.invoke(bean, new Object[0]);\n+        }\n+        catch (Exception ex){\n+            throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                \", \" + ex.getMessage());\n+        }\n+        return value;\n+    }\n+\n+    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value){\n+        try {\n+            Method method = propertyDescriptor.getWriteMethod();\n+            if (method == null){\n+                throw new RuntimeException(\"No write method\");\n+            }\n+            value = method.invoke(bean, new Object[]{value});\n+        }\n+        catch (Exception ex){\n+            throw new RuntimeException(\"Cannot modify property: \" + propertyDescriptor.getName() +\n+                \", \" + ex);\n+        }\n+    }\n+\n+    /**\n+     * Returns a shared instance of the dynamic property handler class\n+     * returned by <code>getDynamicPropertyHandlerClass()</code>.\n+     */\n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) {\n+        DynamicPropertyHandler handler = (DynamicPropertyHandler)dynamicPropertyHandlerMap.get(clazz);\n+        if (handler == null){\n+            try {\n+                handler = (DynamicPropertyHandler)clazz.newInstance();\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot allocate dynamic property handler \" +\n+                    \" of class \" + clazz + \".\\n\" + ex);\n+            }\n+            dynamicPropertyHandlerMap.put(clazz, handler);\n+        }\n+        return handler;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public abstract class PropertyPointer extends NodePointer {\n+    protected int propertyIndex = UNSPECIFIED;\n+    protected Object bean;\n+\n+    /**\n+     * Takes a javabean, a descriptor of a property of that object and\n+     * an offset within that property (starting with 0).\n+     */\n+    public PropertyPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public int getPropertyIndex(){\n+        return propertyIndex;\n+    }\n+\n+    public void setPropertyIndex(int index){\n+        propertyIndex = index;\n+        index = WHOLE_COLLECTION;\n+    }\n+\n+    public Object getBean(){\n+        if (bean == null){\n+            bean = getParent().getValue();\n+        }\n+        return bean;\n+    }\n+\n+    public QName getName(){\n+        return new QName(null, getPropertyName());\n+    }\n+\n+    public abstract String getPropertyName();\n+\n+    public abstract void setPropertyName(String propertyName);\n+\n+    public abstract int getPropertyCount();\n+\n+    public abstract String[] getPropertyNames();\n+\n+    public abstract PropertyPointer copy();\n+\n+    public Object clone(){\n+        return copy();\n+    }\n+\n+    public int hashCode(){\n+        return getParent().hashCode() + propertyIndex + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof PropertyPointer)){\n+            return false;\n+        }\n+\n+        PropertyPointer other = (PropertyPointer)object;\n+        return getParent() == other.getParent() &&\n+                propertyIndex == other.propertyIndex &&\n+                index == other.index;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getBean().getClass().getName());\n+        buffer.append('@');\n+        buffer.append(System.identityHashCode(getBean()));\n+        buffer.append('.');\n+        buffer.append(getPropertyName());\n+        if (index != WHOLE_COLLECTION){\n+            buffer.append('[').append(index).append(']');\n+        }\n+        buffer.append(\" = \").append(getValue());\n+        return buffer.toString();\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (getParent() != null){\n+            buffer.append(getParent().asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append(getPropertyName());\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ */\n+public class VariablePointer extends NodePointer {\n+    private Variables variables;\n+    private QName name;\n+\n+    /**\n+     * Used for the root node\n+     */\n+    public VariablePointer(Variables variables, QName name){\n+        super(null);\n+        this.variables = variables;\n+        this.name = name;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    public Object getPropertyValue(){\n+        return variables.getVariable(name.getName());\n+    }\n+\n+    public void setValue(Object value){\n+        variables.declareVariable(name.getName(), value);\n+    }\n+\n+    public int getLength(){\n+        Object value = getPropertyValue();\n+        if (value == null){\n+            return 1;\n+        }\n+        return PropertyAccessHelper.getLength(value);\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(variables) + name.hashCode() + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof VariablePointer)){\n+            return false;\n+        }\n+\n+        VariablePointer other = (VariablePointer)object;\n+        return variables == other.variables &&\n+                name.equals(other.name) &&\n+                index == other.index;\n+    }\n+\n+    public String toString(){\n+        return asPath();\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append('$');\n+        buffer.append(name.asString());\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    public Object clone(){\n+        VariablePointer pointer = new VariablePointer(variables, name);\n+        pointer.index = index;\n+        pointer.value = value;\n+        return pointer;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/AbstractBeanElement.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/AbstractBeanElement.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * Common superclass for light-weight read-only DOM elements. An AbstractBeanElement\n+ * is initialized with a NodeSequencer, which lets the element navigate\n+ * to its neighbours in a NodeList or NodeSequence containing the element.\n+ * By virtue of inheritance from ValueHandle, an AbstractBeanElement is associated\n+ * with a named value or a property of a JavaBean.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public abstract class AbstractBeanElement extends AbstractBeanNode implements Element {\n+\n+    protected AbstractBeanElement(Node parent, NodeSequencer sequencer, int index, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(parent, sequencer, index, bean, propertyDescriptor);\n+    }\n+\n+    protected AbstractBeanElement(Node parent, NodeSequencer sequencer, int index, Object bean, String name){\n+        super(parent, sequencer, index, bean, name);\n+    }\n+\n+    /**\n+     * Returns the value name.\n+     */\n+    public String getTagName() {\n+        return getValueName();\n+    }\n+\n+    /**\n+     * Returns the value name.\n+     */\n+    public String getNodeName() {\n+        return getValueName();\n+    }\n+\n+    /**\n+     * Returns ELEMENT_NODE\n+     */\n+    public short getNodeType() {\n+        return Node.ELEMENT_NODE;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public String getAttribute(String name) {\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void setAttribute(String name, String value) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void removeAttribute(String name) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Attr getAttributeNode(String name) {\n+        return null;\n+    }\n+\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr removeAttributeNode(Attr oldAttr) throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * TBD\n+     */\n+    public NodeList getElementsByTagName(String name){\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public String getAttributeNS(String namespaceURI, String localName){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void setAttributeNS(String namespaceURI,  String qualifiedName,\n+                               String value) throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void removeAttributeNS(String namespaceURI, String localName) throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr getAttributeNodeNS(String namespaceURI, String localName){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr setAttributeNodeNS(Attr newAttr) throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public NodeList getElementsByTagNameNS(String namespaceURI, String localName){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported. Returns false.\n+     */\n+    public boolean hasAttribute(String name){\n+        return false;\n+    }\n+\n+    /**\n+     * Returns false.\n+     */\n+    public boolean hasAttributeNS(String namespaceURI, String localName){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/AbstractBeanNode.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/AbstractBeanNode.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * Superclass of JXPath DOM Nodes.  It is associated with a NodeSequencer, which\n+ * traverses lists of nodes.  This association makes it possible for AbstractBeanNodes to\n+ * be hosted either directly by ElementLists or by NodeSequences, which represent\n+ * sublists of ElementLists.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public abstract class AbstractBeanNode extends ValueHandle implements Node {\n+    private Node parent;\n+    private NodeSequencer sequencer;\n+    private int index;\n+    private Document owner;\n+\n+    /**\n+     * @param parent is the parent Node\n+     * @param sequencer is the parent NodeSequencer. It can be either an ElementList\n+     *        or a NodeSequence\n+     * @param index is the index of this node within its parent sequencer. Note that\n+     *        if the parent sequencer is a NodeSequence, the index identifies the node\n+     *        in that sequence, not the overall NodeList.\n+     * @param bean is the JavaBean whose property is represented by this node\n+     * @param propertyDescriptor maps to a property of that JavaBean\n+     */\n+    protected AbstractBeanNode(Node parent, NodeSequencer sequencer, int index, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(bean, propertyDescriptor);\n+        this.parent = parent;\n+        this.sequencer = sequencer;\n+        this.index = index;\n+    }\n+\n+    /**\n+     * @param bean is the property value associated with this node\n+     * @param name is the name of that property\n+     */\n+    protected AbstractBeanNode(Node parent, NodeSequencer sequencer, int index, Object value, String name){\n+        super(value, name);\n+        this.parent = parent;\n+        this.sequencer = sequencer;\n+        this.index = index;\n+    }\n+\n+    /**\n+     * A <code>NodeList</code> that contains all children of this node. If\n+     * there are no children, this is a <code>NodeList</code> containing no\n+     * nodes.\n+     */\n+    public abstract NodeList getChildNodes();\n+\n+    public abstract short getNodeType();\n+\n+    /**\n+     * The name of this node, depending on its type.\n+     */\n+    public abstract String getNodeName();\n+\n+    /**\n+     * Returns the position of this Node in the parent NodeSequencer.\n+     */\n+    public int getIndex(){\n+        return index;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public String getNodeValue() throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void setNodeValue(String nodeValue) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Returns the parent Node of this Node.\n+     */\n+    public Node getParentNode() {\n+        return parent;\n+    }\n+\n+    /**\n+     * Returns true if this Node has child nodes.\n+     */\n+    public boolean hasChildNodes() {\n+        return getFirstChild() != null;\n+    }\n+\n+    /**\n+     * The first child of this node. If there is no such node, this returns\n+     * <code>null</code>.\n+     */\n+    public Node getFirstChild() {\n+        if (getValue() == null){\n+            return null;\n+        }\n+\n+        NodeList list = getChildNodes();\n+        if (list instanceof NodeSequencer){\n+            return ((NodeSequencer)list).getFirstNode();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * The last child of this node. If there is no such node, this returns\n+     * <code>null</code>.\n+     */\n+    public Node getLastChild() {\n+        if (getValue() == null){\n+            return null;\n+        }\n+\n+        NodeList list = getChildNodes();\n+        if (list instanceof NodeSequencer){\n+            return ((NodeSequencer)list).getLastNode();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * The node immediately preceding this node. If there is no such node,\n+     * this returns <code>null</code>.\n+     */\n+    public Node getPreviousSibling() {\n+        if (sequencer != null){\n+            return sequencer.getPreviousNode(this);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * The node immediately following this node. If there is no such node,\n+     * this returns <code>null</code>.\n+     */\n+    public Node getNextSibling() {\n+        if (sequencer != null){\n+            return sequencer.getNextNode(this);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * A <code>NamedNodeMap</code> containing the attributes of this node (if\n+     * it is an <code>Element</code>) or <code>null</code> otherwise.\n+     */\n+    public NamedNodeMap getAttributes() {\n+        return null;\n+    }\n+\n+    /**\n+     * Always returns null\n+     */\n+    public Document getOwnerDocument() {\n+        if (parent != null){\n+            return parent.getOwnerDocument();\n+        }\n+        else {\n+            if (owner == null){\n+                owner = new BeanDocument((Element)this);\n+            }\n+            return owner;\n+        }\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node insertBefore(Node newChild, Node refChild) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node replaceChild(Node newChild, Node oldChild) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node removeChild(Node oldChild) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node appendChild(Node newChild) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node cloneNode(boolean deep) {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Does nothing\n+     */\n+    public void normalize() {\n+    }\n+\n+    /**\n+     * Tests whether the DOM implementation implements a specific feature and\n+     * that feature is supported by this node.\n+     * @return Returns <code>false</code> for all features.\n+     */\n+    public boolean isSupported(String feature, String version) {\n+        return false;\n+    }\n+\n+    /**\n+     * The namespace URI is unspecified.\n+     */\n+    public String getNamespaceURI() {\n+        return null;\n+    }\n+\n+    /**\n+     * The namespace prefix is unspecified.\n+     */\n+    public String getPrefix() {\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void setPrefix(String prefix) throws DOMException {\n+        JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public String getLocalName() {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns whether this node (if it is an element) has any attributes.\n+     * @return <code>true</code> if this node has any attributes,\n+     *   <code>false</code> otherwise.\n+     * @since DOM Level 2\n+     */\n+    public boolean hasAttributes() {\n+        return false;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr setAttributeNode(org.w3c.dom.Attr attr){\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    public String toString(){\n+        return getNodeName();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ArrayNodeSequence.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ArrayNodeSequence.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * A NodeSequence that is used to represent an array.\n+ *\n+ * @see NodeSequence\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class ArrayNodeSequence extends NodeSequence\n+{\n+    public ArrayNodeSequence(ElementList elementList, int seqID, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(elementList, seqID, bean, propertyDescriptor);\n+    }\n+\n+    public ArrayNodeSequence(ElementList elementList, int seqID, Object value, String name){\n+        super(elementList, seqID, value, name);\n+    }\n+\n+    /**\n+     * Returns the length of the array\n+     */\n+    protected int computeLength(){\n+        return Array.getLength(getValue());\n+    }\n+\n+    /**\n+     * Returns the index'th element of the array. If the array contains values\n+     * of a primary type, the value is wrapped into an object.\n+     */\n+    protected Node computeItem(int index){\n+        Object value = Array.get(getValue(), index);\n+        String name = getValueName();\n+        return BeanNodeFactory.allocateNode(parent, this, index, value, name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanDocument.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanDocument.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.*;\n+import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * BeanDocument is a DOM Document for a JXPath tree. Since the JXPath tree is\n+ * unmodifiable, most methods of this class throw DOMException (unsupported or\n+ * umodifiable).\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanDocument implements Document {\n+    private Element documentElement;\n+\n+    public BeanDocument(Element docElement){\n+        this.documentElement = docElement;\n+    }\n+\n+    /**\n+     * Returns null.\n+     */\n+    public DocumentType getDoctype(){\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public DOMImplementation getImplementation(){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Returns the root element\n+     */\n+    public Element getDocumentElement(){\n+        return documentElement;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Element createElement(String tagName) throws DOMException{\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public DocumentFragment createDocumentFragment(){\n+        throw JXPathException.unsupported();\n+    }\n+\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Text createTextNode(String data){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Comment createComment(String data){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public CDATASection createCDATASection(String data) throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public ProcessingInstruction createProcessingInstruction(String target, String data)\n+                                                             throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr createAttribute(String name)\n+                                throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public EntityReference createEntityReference(String name)\n+                                                 throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public NodeList getElementsByTagName(String tagname) {\n+        throw JXPathException.unsupported();\n+    }\n+\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node importNode(Node importedNode, boolean deep)\n+                           throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Element createElementNS(String namespaceURI,\n+                                   String qualifiedName)\n+                                   throws DOMException{\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Attr createAttributeNS(String namespaceURI,\n+                                  String qualifiedName)\n+                                  throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     */\n+    public NodeList getElementsByTagNameNS(String namespaceURI, String localName){\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Returns null (for now).\n+     */\n+    public Element getElementById(String elementId){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public String getNodeName(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null.\n+     */\n+    public String getNodeValue()\n+                                 throws DOMException{\n+        return null;\n+    }\n+    public void setNodeValue(String nodeValue)\n+                                 throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Returns DOCUMENT_NODE\n+     */\n+    public short getNodeType(){\n+        return Node.DOCUMENT_NODE;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Node getParentNode(){\n+        return null;\n+    }\n+\n+    /**\n+     * TBD\n+     */\n+    public NodeList getChildNodes(){\n+        return null;\n+    }\n+\n+    /**\n+     * TBD\n+     */\n+    public Node getFirstChild(){\n+        return null;\n+    }\n+\n+    /**\n+     * TBD\n+     */\n+    public Node getLastChild(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Node getPreviousSibling(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Node getNextSibling(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public NamedNodeMap getAttributes(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Document getOwnerDocument(){\n+        return null;\n+    }\n+\n+    /**\n+     * Unmodifiable\n+     */\n+    public Node insertBefore(Node newChild, Node refChild)\n+                             throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unmodifiable\n+     */\n+    public Node replaceChild(Node newChild,\n+                             Node oldChild)\n+                             throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unmodifiable\n+     */\n+    public Node removeChild(Node oldChild)\n+                            throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unmodifiable\n+     */\n+    public Node appendChild(Node newChild)\n+                            throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Returns true\n+     */\n+    public boolean hasChildNodes(){\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <b>this</b>\n+     */\n+    public Node cloneNode(boolean deep){\n+        return this;\n+    }\n+\n+    /**\n+     * No-op\n+     */\n+    public void normalize(){\n+    }\n+\n+    /**\n+     * Returns false\n+     */\n+    public boolean isSupported(String feature, String version){\n+        return false;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public String getNamespaceURI(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public String getPrefix(){\n+        return null;\n+    }\n+    public void setPrefix(String prefix)\n+                               throws DOMException{\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public String getLocalName(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns false\n+     */\n+    public boolean hasAttributes(){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanElement.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanElement.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.*;\n+import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * BeanElement is a DOM Element that is associated with a JavaBean. Its child\n+ * nodes represent properties of the JavaBean.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanElement extends AbstractBeanElement {\n+    private NodeList children;\n+\n+    /**\n+     * @param parent is the parent Node\n+     * @param sequencer is the parent sequencer: BeanElements are linked together\n+     *        by NodeSequencers like BeanElementList and NodeSequence\n+     * @param index is the position of the element within it parent seqencer. It\n+     *        is not the position of the element within the parent's child node list.\n+     * @param value is the value this element represents\n+     * @param name is the name of that value\n+     */\n+    public BeanElement(Node parent, NodeSequencer sequencer, int index, Object value, String name){\n+        super(parent, sequencer, index, value, name);\n+    }\n+\n+    /**\n+     * Used for nested JavaBeans. This BeanElement represents a property of the parent JavaBean.\n+     * @param bean is the JavaBean whose property this bean represents\n+     * @param propertyDescriptor describes the property this bean represents\n+     */\n+    public BeanElement(Node parent, NodeSequencer sequencer, int index, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(parent, sequencer, index, bean, propertyDescriptor);\n+    }\n+\n+    /**\n+     * A <code>NodeList</code> that contains all children of this node. Depending on\n+     * the type of the value associated with this element, the class of the NodeList\n+     * will be ValueNodeList (for an atomic value), BeanElementList (for a JavaBean)\n+     * or MapNodeList (for a map).\n+     */\n+    public NodeList getChildNodes() {\n+        if (children == null){\n+            PropertyDescriptor pd = getPropertyDescriptor();\n+            if (pd != null){\n+                Class type = pd.getPropertyType();\n+                ProcessedBeanInfo beanInfo = ProcessingIntrospector.getProcessedBeanInfo(type);\n+                if (beanInfo.isAtomic()){\n+                    children = new ValueNodeList(this, getBean(), pd);\n+                }\n+                else if (beanInfo.isDynamic()){\n+                    children = new DynamicPropertyElementList(this, getValue(), beanInfo.getDynamicPropertyHandler());\n+                }\n+            }\n+            if (children == null){\n+                Object value = getValue();\n+                if (value == null){\n+                    children = new ValueNodeList(this, null, getValueName());\n+                }\n+                else {\n+                    Class type = value.getClass();\n+                    ProcessedBeanInfo beanInfo = ProcessingIntrospector.getProcessedBeanInfo(type);\n+                    if (beanInfo.isAtomic()){\n+                        if (pd != null){\n+                            children = new ValueNodeList(this, getBean(), pd);\n+                        }\n+                        else {\n+                            children = new ValueNodeList(this, value, getValueName());\n+                        }\n+                    }\n+                    else if (beanInfo.isDynamic()){\n+                        children = new DynamicPropertyElementList(this, value, beanInfo.getDynamicPropertyHandler());\n+                    }\n+                    else {\n+                        children = new BeanElementList(this, value, beanInfo);\n+                    }\n+                }\n+            }\n+        }\n+        return children;\n+    }\n+\n+    /**\n+     * Attributes are not supported.\n+     */\n+    public NamedNodeMap getAttributes() {\n+        return new BeanNamedNodeMap(null, null);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanElementList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanElementList.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * A NodeList that contains Elements representing properties of a JavaBean.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanElementList extends ElementList {\n+    private Object bean;\n+    private ProcessedBeanInfo beanInfo;\n+\n+    /**\n+     * @param parent is the parent Node of this list\n+     * @param bean is the JavaBean represented by the list\n+     * @param beanInfo describes properties of that JavaBean\n+     */\n+    public BeanElementList(Node parent, Object bean, ProcessedBeanInfo beanInfo){\n+        super(parent);\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+\n+        setSingularChildCount(beanInfo.getSingularPropertyDescriptors().length);\n+        setChildSequenceCount(beanInfo.getCollectionPropertyDescriptors().length);\n+    }\n+\n+    /**\n+     * Invokes BeanNodeFactory to allocate a node for the identified property\n+     */\n+    protected Node allocateSingularNode(int index){\n+        PropertyDescriptor pd = beanInfo.getSingularPropertyDescriptors()[index];\n+        return BeanNodeFactory.allocateNode(parent, this, index, bean, pd);\n+    }\n+\n+    /**\n+     * Invokes BeanNodeFactory to allocate a node sequence for the identified property\n+     */\n+    protected NodeSequence allocateNodeSequence(int index){\n+        PropertyDescriptor propertyDescriptor = beanInfo.getCollectionPropertyDescriptors()[index];\n+        return BeanNodeFactory.allocateNodeSequence(this, index, bean, propertyDescriptor);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanNamedNodeMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanNamedNodeMap.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.apache.commons.jxpath.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * Attributes are not supported in this release of JXPath. Therefore,\n+ * this class is a placeholder.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanNamedNodeMap implements NamedNodeMap {\n+    public Object bean;\n+    public JXPathBeanInfo beanInfo;\n+\n+    public BeanNamedNodeMap(Object bean, JXPathBeanInfo beanInfo){\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node getNamedItem(String name){\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node setNamedItem(Node arg) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node removeNamedItem(String name) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Node item(int index){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns 0\n+     */\n+    public int getLength() {\n+        return 0;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node getNamedItemNS(String namespaceURI, String localName){\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node setNamedItemNS(Node arg) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported.\n+     */\n+    public Node removeNamedItemNS(String namespaceURI,String localName)\n+                                  throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanNodeFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanNodeFactory.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * BeanNodeFactory is used whenever a Node or a NodeSequence needs to be allocated to\n+ * represent a stand-alone value or a JavaBean property. BeanNodeFactory takes into\n+ * consideration the type of the property.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanNodeFactory  {\n+\n+    /**\n+     * Allocates a BeanElement.\n+     *\n+     * @see BeanElement\n+     */\n+    public static Node allocateNode(Node parent, NodeSequencer sequencer, int index, Object value, String name){\n+        return new BeanElement(parent, sequencer, index, value, name);\n+    }\n+\n+    /**\n+     * Allocates a BeanElement.\n+     *\n+     * @see BeanElement\n+     */\n+    public static Node allocateNode(Node parent, NodeSequencer sequencer, int index, Object bean, PropertyDescriptor propertyDescriptor){\n+        return new BeanElement(parent, sequencer, index, bean, propertyDescriptor);\n+    }\n+\n+    /**\n+     * Allocates a BeanElementList with a single NodeSequence representing the\n+     * specified collection (which can be either a collection or an array).\n+     *\n+     * @see BeanElement\n+     */\n+    public static NodeList allocateNodeList(Object collection, String tagName){\n+        return new BeanNodeList(collection, tagName);\n+    }\n+\n+    /**\n+     * Returns true if the specified type requires a NodeSequence, false if it\n+     * needs a simple Node.\n+     *\n+     * Properties types requiring a NodeSequence are:\n+     * <ul>\n+     * <li>Array\n+     * <li>java.util.Collection\n+     * <li>Any interface, except java.util.Map\n+     * <li>java.lang.Object\n+     * </ul>\n+     *\n+     * @see BeanElement\n+     */\n+    public static boolean isMultiElement(Class type){\n+        if (type.isArray()){\n+            return true;\n+        }\n+        else if (Collection.class.isAssignableFrom(type)){\n+            return true;\n+        }\n+        else if (type.isInterface() && !Map.class.isAssignableFrom(type)){\n+            return true;\n+        }\n+        else if (type.getName().equals(\"java.lang.Object\")){\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Allocates a NodeSequence according to the type of the property.\n+     * It allocates an {@link ArrayNodeSequence ArrayNodeSequence} for any array,\n+     * a {@link CollectionNodeSequence CollectionNodeSequence} for java.util.Collection,\n+     * a {@link ValueNodeSequence ValueNodeSequence} for a scalar type.\n+     * The ValueNodeSequence alternative is used when the property is declared\n+     * as java.lang.Object or an interface. Since we don't know upfront if the actual\n+     * instance will be a scalar object or a collection, we assume that it might\n+     * be a collection and require a NodeSequence for it.  If later the instance\n+     * turns out to be scalar, we use ValueNodeSequence, which is a collection\n+     * of one Node.\n+     */\n+    public static NodeSequence allocateNodeSequence(ElementList elementList, int seqID, Object bean, PropertyDescriptor propertyDescriptor){\n+        Class type = propertyDescriptor.getPropertyType();\n+        if (type.isArray()){\n+            return new ArrayNodeSequence(elementList, seqID, bean, propertyDescriptor);\n+        }\n+        else if (Collection.class.isAssignableFrom(type)){\n+            return new CollectionNodeSequence(elementList, seqID, bean, propertyDescriptor);\n+        }\n+        else {\n+            // Unknown type: could be a collection, could be a singular object\n+            // We will first try to treat it as a singular object\n+            ValueNodeSequence seq = new ValueNodeSequence(elementList, seqID, bean, propertyDescriptor);\n+            Object value = seq.getValue();\n+            if (value == null || !isMultiElement(value.getClass())){\n+                return seq;\n+            }\n+            else {\n+                // If it turned out to be a collection - forward to the method\n+                // that allocates a multi-element sequence\n+                return allocateNodeSequence(elementList, seqID, value, seq.getValueName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Allocates a named NodeSequence to represent a stand-alone collection.\n+     * It is used in the cases where the collection is not a property value\n+     * (for example, if it an element of a Map).\n+     */\n+    public static NodeSequence allocateNodeSequence(ElementList elementList, int seqID, Object value, String name){\n+        Class type = value.getClass();\n+        if (type.isArray()){\n+            return new ArrayNodeSequence(elementList, seqID, value, name);\n+        }\n+        else if (Collection.class.isAssignableFrom(type)){\n+            return new CollectionNodeSequence(elementList, seqID, value, name);\n+        }\n+        else {\n+            return new ValueNodeSequence(elementList, seqID, value, name);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/BeanNodeList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/BeanNodeList.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * A BeanNodeList is used to represent top-level collections (arrays and\n+ * java.util.Collections etc). It is used when the interpreted XPath has\n+ * something like \"$a[3]\" and variable \"a\" is an array or collection.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class BeanNodeList extends ElementList\n+{\n+    private Object collection;\n+    private String name;\n+\n+    public BeanNodeList(Object collection, String name){\n+        super(null);\n+        setChildSequenceCount(1);\n+        this.collection = collection;\n+        this.name = name;\n+    }\n+\n+    public Object getCollection(){\n+        return collection;\n+    }\n+\n+    /**\n+     * Unimplemented.\n+     */\n+    protected Node allocateSingularNode(int index){\n+        return null;\n+    }\n+\n+    /**\n+     * Implemented by a subclass to produce a node sequence.\n+     */\n+    protected NodeSequence allocateNodeSequence(int index){\n+        return BeanNodeFactory.allocateNodeSequence(this, 0, collection, name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/CollectionNodeSequence.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/CollectionNodeSequence.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * A NodeSequence that is represents a java.util.Collection (like a Set or a List).\n+ *\n+ * @see NodeSequence\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class CollectionNodeSequence extends NodeSequence\n+{\n+    private Iterator iterator;\n+    private int currentIteratorIndex;\n+\n+    public CollectionNodeSequence(ElementList elementList, int seqID, Object bean, PropertyDescriptor propertyDescriptor){\n+         super(elementList, seqID, bean, propertyDescriptor);\n+    }\n+\n+    public CollectionNodeSequence(ElementList elementList, int seqID, Object value, String name){\n+         super(elementList, seqID, value, name);\n+    }\n+\n+    /**\n+     * Returns the size of the collection\n+     */\n+    protected int computeLength(){\n+        return ((Collection)getValue()).size();\n+    }\n+\n+    /**\n+     * Returns the index'th element of the collection. Attempts to\n+     * use a cached iterator if the collection is not a list.\n+     * Invokes BeanNodeFactory to allocate a node for the value.\n+     */\n+    protected Node computeItem(int index){\n+        Object value = null;\n+        if (iterator != null && currentIteratorIndex == index - 1){\n+            value = iterator.next();\n+            currentIteratorIndex++;\n+        }\n+        else {\n+            Object col = getValue();\n+            if (col instanceof List){\n+                value = ((List)getValue()).get(index);\n+            }\n+            else {\n+                iterator = ((Collection)col).iterator();\n+                for (int i = 0; i <= index; i++){\n+                    value = iterator.next();\n+                }\n+                currentIteratorIndex = index;\n+            }\n+        }\n+        String name = getValueName();\n+        return BeanNodeFactory.allocateNode(parent, this, index, value, name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/DOMWrapper.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/DOMWrapper.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.List;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.apache.commons.jxpath.tree.BeanNodeFactory;\n+\n+/**\n+ * DOMWrapper creates a light-weight DOM tree modeled\n+ * after a JavaBean object graph.  That DOM tree can be obtained by calling\n+ * {@link DOMWrapper#createNode DOMWrapper.createNode}\n+ * and used as a reqular read-only DOM tree, for example in XSLT transformations.\n+ * In the following example we use JXPath and XSLT to produce a nice printout of\n+ * a JavaBean in the XML format.\n+ *\n+ * <pre><blockquote>\n+ * Employee emp = new Employee();\n+ * </blockquote></pre>\n+ *\n+ * Allocate a JXPath DOM tree:\n+ *\n+ * <pre><blockquote>\n+ * Node dom = DOMWrapper.createNode(emp, \"employee\");\n+ * </blockquote></pre>\n+ *\n+ * And print it using XSLT:\n+ *\n+ * <pre><blockquote>\n+ * Transformer trans = TransformerFactory.newInstance().newTransformer();\n+ * trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+ * trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n+ * trans.transform(new DOMSource(dom), new StreamResult(System.err));\n+ * </blockquote></pre>\n+ *\n+ * The printout produced by this code looks like this:\n+ * <pre><blockquote>\n+ *    &lt;employee&gt;\n+ *       &lt;firstName&gt;John&lt;/firstName&gt;\n+ *       &lt;homeAddress&gt;\n+ *           &lt;streetNumber&gt;123 Main Drive&lt;/streetNumber&gt;\n+ *           ...\n+ *       &lt;/homeAddress&gt;\n+ *       ...\n+ *   &lt;/employee&gt;\n+ * </blockquote></pre>\n+ *\n+ * <h2>Performance</h2>\n+ *\n+ *     The DOM tree created by DOMWrapper is optimized. The JXPath implementation\n+ *     follows these performance related rules:\n+ *     <ol>\n+ *     <li>It only allocates the parts of the tree (Nodes and NodeLists) as they\n+ *         are requested, so parts of the tree that are never asked for never get\n+ *         allocated.\n+ *     <li>Once a part of the tree is created, it is cached - so if the same\n+ *         parts of the tree are traversed multiple times, the allocation of the\n+ *         Nodes and NodeLists is only done once.\n+ *     <li>Property values are only retrieved when they are requested.\n+ *         Most of the time XPath only needs the\n+ *         property name - DOMWrapper produces those without retrieving the\n+ *         corresponding values.\n+ *     <li>Xalan XPath relies on linear searches over the DOM structures.\n+ *         JXPath tree structure is optimized to reduce the average\n+ *         length of those searches.\n+ *     </ol>\n+ *\n+ * <h2>Notes</h2>\n+ * <ul>\n+ * <li>The current version of DOMWrapper does not support DOM attributes. Even though XPaths\n+ *     like \"para[@type='warning']\" are legitimate, they will always produce empty results.\n+ *     This may change in future versions of JXPath: the related trade-offs are currently\n+ *     being evaluated.\n+ * <li>The current version of JXPath does not support the <code>id(string)</code> and\n+ *     <code>key(key, value)</code> XPath functions.\n+ * </ul>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public final class DOMWrapper {\n+\n+    /**\n+     * Creates a DOM tree that can be used with different xpaths\n+     * as long as the data represented by the tree remains unchanged.\n+     */\n+    public static Node createNode(Object bean, String rootNodeName){\n+        if (bean instanceof Node){\n+            return (Node)bean;\n+        }\n+        return BeanNodeFactory.allocateNode(null, null, 0, bean, rootNodeName);\n+    }\n+\n+    /**\n+     * Creates a DOM NodeList for a collection or an array. The node list\n+     * contains elements with the tag name specified as the elementName parameter.\n+     */\n+    public static NodeList createNodeList(Object collection, String elementName){\n+        if (collection instanceof NodeList){\n+            return (NodeList)collection;\n+        }\n+        return BeanNodeFactory.allocateNodeList(collection, elementName);\n+    }\n+\n+    /**\n+     * Returns true if the object cannot be wrapped into a single-root DOM tree.\n+     * You can use createNodeList() with collections, but not createNode().\n+     */\n+    public static boolean isCollection(Object object){\n+        return BeanNodeFactory.isMultiElement(object.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/DynamicPropertyElementList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/DynamicPropertyElementList.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * A NodeList that contains Elements representing names and values\n+ * of dynamic properties of an object.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class DynamicPropertyElementList extends ElementList {\n+    private DynamicPropertyHandler handler;\n+    private Object target;\n+    private ArrayList singularNames;\n+    private ArrayList collectionNames;\n+\n+    public DynamicPropertyElementList(Node parent, Object target, DynamicPropertyHandler handler){\n+        super(parent);\n+        this.handler = handler;\n+        this.target = target;\n+\n+        String names[] = handler.getPropertyNames(target);\n+        singularNames = new ArrayList();\n+        collectionNames = new ArrayList();\n+        for (int i = 0; i < names.length; i++){\n+            String property = names[i];\n+            Object value = handler.getProperty(target, property);\n+            if (value == null){\n+                singularNames.add(property);\n+            }\n+            else {\n+                if (BeanNodeFactory.isMultiElement(value.getClass())){\n+                    collectionNames.add(property);\n+                }\n+                else {\n+                    singularNames.add(property);\n+                }\n+            }\n+        }\n+\n+        setSingularChildCount(singularNames.size());\n+        setChildSequenceCount(collectionNames.size());\n+    }\n+\n+    /**\n+     * Invokes BeanNodeFactory to allocate a node for a key-value pair\n+     */\n+    protected Node allocateSingularNode(int index){\n+        String name = (String)singularNames.get(index);\n+        Object value = handler.getProperty(target, name);\n+        return BeanNodeFactory.allocateNode(parent, this, index, value, String.valueOf(name));\n+    }\n+\n+    /**\n+     * Invokes BeanNodeFactory to allocate a NodeSequence for a key-value pair where\n+     * the value is an array or a collection.\n+     */\n+    protected NodeSequence allocateNodeSequence(int index){\n+        String name = (String)collectionNames.get(index);\n+        Object value = handler.getProperty(target, name);\n+        return BeanNodeFactory.allocateNodeSequence(this, index, value, String.valueOf(name));\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ElementList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ElementList.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * Common superclass for NodeLists containing singular elements as well as\n+ * sequences of elements representing collections.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public abstract class ElementList\n+            implements NodeList, NodeSequencer {\n+    protected Node parent;\n+    private Node singularChildren[] = null;\n+    private int singularChildCount;\n+    private NodeSequence childSequences[] = null;\n+    private int childSequenceCount;\n+    private int length = -1;\n+\n+    public ElementList(Node parent){\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Returns the parent node of this element list.\n+     */\n+    public Node getParentNode(){\n+        return parent;\n+    }\n+\n+    /**\n+     * Called by a subclass to establish the number of singular Nodes in the list.\n+     */\n+    protected void setSingularChildCount(int count){\n+        this.singularChildCount = count;\n+    }\n+\n+    /**\n+     * Called by a subclass to establish the number of Nodes sequences in the list.\n+     */\n+    protected void setChildSequenceCount(int count){\n+        this.childSequenceCount = count;\n+    }\n+\n+    /**\n+     * Implemented by a subclass to produce a singular node.\n+     */\n+    protected abstract Node allocateSingularNode(int index);\n+\n+    /**\n+     * Implemented by a subclass to produce a node sequence.\n+     */\n+    protected abstract NodeSequence allocateNodeSequence(int index);\n+\n+    /**\n+     * Returns the <code>index</code>'th item in the NodeList.\n+     */\n+    public Node item(int index){\n+        if (index < singularChildCount){\n+            if (singularChildren == null){\n+                singularChildren = new Node[singularChildCount];\n+            }\n+            Node node = singularChildren[index];\n+            if (node == null){\n+                node = allocateSingularNode(index);\n+                singularChildren[index] = node;\n+            }\n+            return node;\n+        }\n+        else {\n+            int offset = index - singularChildCount;\n+            for (int j = 0; j < childSequenceCount; j++){\n+                NodeSequence list = getNodeSequence(j);\n+                int l = list.getLength();\n+                if (offset < l){\n+                    return list.item(offset);\n+                }\n+                offset -= l;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * The number of nodes in the list. The range of valid child node indices\n+     * is 0 to <code>length-1</code> inclusive.\n+     */\n+    public int getLength(){\n+        if (length == -1){\n+            length = singularChildCount;\n+            for (int i = 0; i < childSequenceCount; i++){\n+                length += getNodeSequence(i).getLength();\n+            }\n+        }\n+\n+        return length;\n+    }\n+\n+    /**\n+     * Returns a NodeSequence for the specified index, optionally\n+     * allocating the sequence.\n+     */\n+    private NodeSequence getNodeSequence(int index){\n+        if (childSequences == null){\n+            childSequences = new NodeSequence[childSequenceCount];\n+        }\n+\n+        NodeSequence list = childSequences[index];\n+        if (list == null){\n+            list = allocateNodeSequence(index);\n+            childSequences[index] = list;\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns the first node of the list or null if the list is empty.\n+     */\n+    public Node getFirstNode(){\n+        if (singularChildCount > 0){\n+            return item(0);\n+        }\n+        if (childSequenceCount > 0){\n+            return getNodeSequence(0).getFirstNode();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the node following the supplied node or null the supplied node\n+     * is the last one.\n+     */\n+    public Node getNextNode(Node node){\n+        BeanElement element = (BeanElement)node;\n+        int index = element.getIndex();\n+        if (index == singularChildCount){\n+            if (childSequenceCount > 0){\n+                return getNodeSequence(0).getFirstNode();\n+            }\n+        }\n+        else {\n+            return item(index + 1);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Node that logically follows the last Node of the\n+     * supplied NodeSequence.\n+     */\n+    public Node getNextNode(NodeSequence list){\n+        int seqID = list.getSequenceID();\n+        if (seqID + 1 < childSequenceCount){\n+            return getNodeSequence(seqID + 1).getFirstNode();\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the last Node in the list, or null if the list is empty.\n+     */\n+    public Node getLastNode(){\n+        if (childSequenceCount > 0){\n+            return getNodeSequence(childSequenceCount - 1).getLastNode();\n+        }\n+        if (singularChildCount > 0){\n+            return item(singularChildCount - 1);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Node immediately preceeding the supplied one or null\n+     * if the supplied node is the first one in the list.\n+     */\n+    public Node getPreviousNode(Node node){\n+        BeanElement element = (BeanElement)node;\n+        int index = element.getIndex();\n+        if (index > 0){\n+            return item(index - 1);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Node logically preceeding the first node of the\n+     * supplied NodeSequence.\n+     */\n+    public Node getPreviousNode(NodeSequence list){\n+        int seqID = list.getSequenceID();\n+        if (seqID > 0){\n+            return getNodeSequence(seqID - 1).getLastNode();\n+        }\n+        else if (singularChildCount > 0){\n+            return item(singularChildCount - 1);\n+        }\n+\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/JXPathException.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/JXPathException.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+\n+/**\n+ * A DOM Exception used by JXPath.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+class JXPathException extends DOMException {\n+    public JXPathException(short code, String message){\n+        super(code, message);\n+    }\n+\n+    /**\n+     * Returns a DOMException with the NO_MODIFICATION_ALLOWED_ERR code\n+     */\n+    public static DOMException unmodifiable() {\n+        return new JXPathException(DOMException.NO_MODIFICATION_ALLOWED_ERR, \"Operation is not supported by JXPath\");\n+    }\n+\n+    /**\n+     * Returns a DOMException with the NOT_SUPPORTED_ERR code\n+     */\n+    public static DOMException unsupported() {\n+        return new JXPathException(DOMException.NOT_SUPPORTED_ERR, \"Operation is not supported by JXPath\");\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/MapDynamicPropertyHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/MapDynamicPropertyHandler.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.apache.commons.jxpath.DynamicPropertyHandler;\n+\n+/**\n+ * Implements the DynamicPropertyHandler interface for java.util.Map.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class MapDynamicPropertyHandler implements DynamicPropertyHandler {\n+\n+    private static final String[] STRING_ARRAY = new String[0];\n+\n+    /**\n+     * Returns string representations of all keys in the map.\n+     */\n+    public String[] getPropertyNames(Object object){\n+        Map map = (Map)object;\n+        String names[] = new String[map.size()];\n+        Iterator it = map.keySet().iterator();\n+        for (int i = 0; i < names.length; i++){\n+            names[i] = String.valueOf(it.next());\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Returns the value for the specified key.\n+     */\n+    public Object getProperty(Object object, String propertyName){\n+        return ((Map)object).get(propertyName);\n+    }\n+\n+    /**\n+     * Sets the specified key value.\n+     */\n+    public void setProperty(Object object, String propertyName, Object value){\n+        ((Map)object).put(propertyName, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/NodeSequence.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/NodeSequence.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * An abstract subclass for classes that represent collections of Nodes\n+ * wrapping collections of objects (arrays, java.util.Collections, etc).\n+ * NodeSequences are used by ElementLists to represent properties of JavaBeans\n+ * whose values are collections.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public abstract class NodeSequence extends ValueHandle\n+        implements NodeSequencer\n+{\n+    protected ElementList elementList;\n+    protected Node parent;\n+    protected int seqID;\n+    private int length = -1;\n+    private Node nodes[];\n+\n+    /**\n+     * @param elementList is the NodeList that contains this sequence\n+     * @param seqID is an integer that is assigned to the sequence by the parent\n+     *          element list and is used by it to identify the sequence\n+     * @param bean is the JavaBean whose property is associated with this sequence\n+     * @param propertyDescriptor identifies a property of that bean\n+     */\n+    public NodeSequence(ElementList elementList, int seqID, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(bean, propertyDescriptor);\n+        this.elementList = elementList;\n+        this.parent = elementList.getParentNode();\n+        this.seqID = seqID;\n+    }\n+\n+    /**\n+     * @param elementList is the NodeList that contains this sequence\n+     * @param seqID is an integer that is assigned to the sequence by the parent\n+     *          element list and is used by it to identify the sequence\n+     * @param value is the collection associated with this sequence\n+     * @param name is the name of the collection\n+     */\n+    public NodeSequence(ElementList elementList, int seqID, Object value, String name){\n+        super(value, name);\n+        this.elementList = elementList;\n+        this.parent = elementList.getParentNode();\n+        this.seqID = seqID;\n+    }\n+\n+    /**\n+     * Returns the sequence ID passed to the object in the constructor - it is the identifier\n+     * of the sequence within the scope of the parent element list.\n+     */\n+    public int getSequenceID(){\n+        return seqID;\n+    }\n+\n+    /**\n+     * Should be implemented by the subclasses to compute the collection length. NodeSequence\n+     * will cache the result.\n+     */\n+    protected abstract int computeLength();\n+\n+    /**\n+     * Should be implemented by the subclasses to extract the index'th item of the sequence.\n+     * NodeSequence will cache the result.\n+     */\n+    protected abstract Node computeItem(int index);\n+\n+    /**\n+     * Returns the length of the sequence.  It is computed only once and then cached.\n+     */\n+    public int getLength(){\n+        if (length == -1){\n+            length = computeLength();\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Returns the index'th item of the sequence. Each item is computed no\n+     * more than once and then cached.\n+     */\n+    public Node item(int index){\n+        if (nodes == null){\n+            nodes = new Node[getLength()];\n+        }\n+\n+        Node node = nodes[index];\n+        if (node == null){\n+            node = computeItem(index);\n+            nodes[index] = node;\n+        }\n+        return node;\n+    }\n+\n+    /**\n+     * Returns the first node of the sequence\n+     */\n+    public Node getFirstNode(){\n+        if (getLength() > 0){\n+            return item(0);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the node following the supplied one or null.\n+     */\n+    public Node getNextNode(Node node){\n+        int index = ((AbstractBeanNode)node).getIndex();\n+        int length = getLength();\n+\n+        if (index + 1 < length){\n+            return item(index + 1);\n+        }\n+\n+        return elementList.getNextNode(this);\n+    }\n+\n+    /**\n+     * Returns the last node in the sequence.\n+     */\n+    public Node getLastNode(){\n+        int length = getLength();\n+        if (length > 0){\n+            return item(length - 1);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the node preceeding the supplied one in the sequence or null.\n+     */\n+    public Node getPreviousNode(Node node){\n+        int index = ((AbstractBeanNode)node).getIndex();\n+        int length = getLength();\n+\n+        if (index > 0){\n+            return item(index - 1);\n+        }\n+\n+        return elementList.getPreviousNode(this);\n+   }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/NodeSequencer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/NodeSequencer.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * NodeSequencer is an object that maintains an ordered collection\n+ * of Nodes.  It used for NodeLists and sublists of those.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public interface NodeSequencer\n+{\n+    /**\n+     * Returns the first Node in the collection or null if the collection\n+     * is empty.\n+     */\n+    public Node getFirstNode();\n+\n+    /**\n+     * Returns the Node that followes the specified node in the collection.\n+     * Returns null if the supplied Node is the last one in the collection.\n+     */\n+    public Node getNextNode(Node node);\n+\n+    /**\n+     * Returns the last Node in the collection or null if the collection\n+     * is empty.\n+     */\n+    public Node getLastNode();\n+\n+    /**\n+     * Returns the node that preceeds the supplied one in the collection or\n+     * null if the supplied node is the first one.\n+     */\n+    public Node getPreviousNode(Node node);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ProcessedBeanInfo.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ProcessedBeanInfo.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import org.apache.commons.jxpath.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * An optimized version of JXPathBeanInfo. Properties are grouped into two\n+ * categories: those representing singular values and those representing\n+ * collections.\n+ * <p>\n+ * The idea of the optimization is that if we scan singular\n+ * properties first, and only then iterate through collection, we would\n+ * find property values quicker, statistically speaking.\n+ *\n+ * @see org.apache.commons.jxpath.JXPathBeanInfo\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class ProcessedBeanInfo implements JXPathBeanInfo {\n+    private JXPathBeanInfo beanInfo;\n+    private PropertyDescriptor[] singularPropertyDescriptors;\n+    private PropertyDescriptor[] sequencePropertyDescriptors;\n+    private boolean processed = false;\n+    private DynamicPropertyHandler dynamicPropertyHandler;\n+\n+    private static final PropertyDescriptor[] EMPTY_ARRAY = new PropertyDescriptor[0];\n+\n+    public ProcessedBeanInfo(JXPathBeanInfo beanInfo){\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    /**\n+     * Returns the same value as the corresponding JXPathBeanInfo\n+     */\n+    public boolean isAtomic(){\n+        return beanInfo.isAtomic();\n+    }\n+\n+    /**\n+     * Returns the same value as the corresponding JXPathBeanInfo\n+     */\n+    public boolean isDynamic(){\n+        return beanInfo.isDynamic();\n+    }\n+\n+    /**\n+     * Returns the same value as the corresponding JXPathBeanInfo\n+     */\n+    public Class getDynamicPropertyHandlerClass() {\n+        return beanInfo.getDynamicPropertyHandlerClass();\n+    }\n+\n+    /**\n+     * Returns a shared instance of the dynamic property handler class\n+     * returned by <code>getDynamicPropertyHandlerClass()</code>.\n+     */\n+    public DynamicPropertyHandler getDynamicPropertyHandler() {\n+        if (dynamicPropertyHandler == null){\n+            try {\n+                dynamicPropertyHandler =\n+                  (DynamicPropertyHandler)getDynamicPropertyHandlerClass().newInstance();\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot allocate dynamic property handler \" +\n+                    \" of class \" + getDynamicPropertyHandlerClass() + \".\\n\" + ex);\n+            }\n+        }\n+        return dynamicPropertyHandler;\n+    }\n+\n+    /**\n+     * Returns the same value as the corresponding JXPathBeanInfo\n+     */\n+    public PropertyDescriptor[] getPropertyDescriptors(){\n+        return beanInfo.getPropertyDescriptors();\n+    }\n+\n+    /**\n+     * Returns property descriptors that represent singular values.\n+     * Consults BeanNodeFactory to determine whether a property is a collection.\n+     *\n+     * @see BeanNodeFactory#isMultiElement\n+     */\n+    public PropertyDescriptor[] getSingularPropertyDescriptors(){\n+        if (!processed){\n+            process();\n+        }\n+        return singularPropertyDescriptors;\n+    }\n+\n+    /**\n+     * Returns property descriptors that represent collections.\n+     * Consults BeanNodeFactory to determine whether a property is a collection.\n+     *\n+     * @see BeanNodeFactory#isMultiElement\n+     */\n+    public PropertyDescriptor[] getCollectionPropertyDescriptors(){\n+        if (!processed){\n+            process();\n+        }\n+        return sequencePropertyDescriptors;\n+    }\n+\n+    private void process(){\n+        processed = true;\n+\n+        PropertyDescriptor pds[] = getPropertyDescriptors();\n+\n+        int sCount = 0;\n+        int cCount = 0;\n+        for (int i = 0; i < pds.length; i++){\n+            if (BeanNodeFactory.isMultiElement(pds[i].getPropertyType())){\n+                cCount ++;\n+            }\n+            else {\n+                sCount ++;\n+            }\n+        }\n+\n+        if (sCount != 0){\n+            singularPropertyDescriptors = new PropertyDescriptor[sCount];\n+        }\n+        else {\n+            singularPropertyDescriptors = EMPTY_ARRAY;\n+        }\n+\n+        if (cCount != 0){\n+            sequencePropertyDescriptors = new PropertyDescriptor[cCount];\n+        }\n+        else {\n+            sequencePropertyDescriptors = EMPTY_ARRAY;\n+        }\n+\n+        int sIndex = 0;\n+        int cIndex = 0;\n+        for (int i = 0; i < pds.length; i++){\n+            Class type = pds[i].getPropertyType();\n+            if (BeanNodeFactory.isMultiElement(type)){\n+                sequencePropertyDescriptors[cIndex++] = pds[i];\n+            }\n+            else {\n+                singularPropertyDescriptors[sIndex++] = pds[i];\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ProcessingIntrospector.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ProcessingIntrospector.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * A wrapper for JXPathIntrospector that performs some processing of JXPathBeanInfo\n+ * objects for optimization purposes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+\n+public class ProcessingIntrospector  {\n+    private static HashMap byClass = new HashMap();\n+\n+    /**\n+     * Manages a cache of ProcessedBeanInfo objects.\n+     */\n+    public static ProcessedBeanInfo getProcessedBeanInfo(Class beanClass) {\n+        ProcessedBeanInfo beanInfo = (ProcessedBeanInfo)byClass.get(beanClass);\n+        if (beanInfo == null){\n+            beanInfo = new ProcessedBeanInfo(JXPathIntrospector.getBeanInfo(beanClass));\n+            byClass.put(beanClass, beanInfo);\n+        }\n+        return beanInfo;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ValueHandle.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ValueHandle.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * A ValueHandle maintains a named value.  There are two ways the name-value\n+ * pair can be specified:\n+ * <ul>\n+ * <li>Object and its name.\n+ * <li>A JavaBean and a PropertyDescriptor from that bean's BeanInfo.  In this\n+ *     case the value logically associated with the node is the value of the\n+ *     corresponding property of the specified bean.\n+ * </ul>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public abstract class ValueHandle\n+{\n+    private Object bean;\n+    private String name;\n+    private PropertyDescriptor propertyDescriptor;\n+    private boolean valueRetrieved = false;\n+    private Object value;\n+\n+    /**\n+     * Associates the ValueHandle with a property of a JavaBean.\n+     */\n+    public ValueHandle(Object bean, PropertyDescriptor propertyDescriptor){\n+        this.bean = bean;\n+        this.propertyDescriptor = propertyDescriptor;\n+    }\n+\n+    /**\n+     * Associates the ValueHandle with an named bean.\n+     */\n+    public ValueHandle(Object bean, String name){\n+        this(bean);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Associates the ValueHandle with an unnamed bean.\n+     */\n+    public ValueHandle(Object bean){\n+        this.bean = bean;\n+        value = bean;\n+        valueRetrieved = true;\n+    }\n+\n+    /**\n+     * Returns the bean associated with the ValueHandle. If the handle\n+     * is configured with a PropertyDescriptor, this method returns\n+     * the parent JavaBean, not a property thereof.\n+     */\n+    public Object getBean() {\n+        return bean;\n+    }\n+\n+    /**\n+     * Returns the PropertyDescriptor this handle is associated with.\n+     */\n+    public PropertyDescriptor getPropertyDescriptor() {\n+        return propertyDescriptor;\n+    }\n+\n+    /**\n+     * Returns the name of the value. If the handle was configured\n+     * with a PropertyDescriptor, the method returns the name of the\n+     * property.\n+     */\n+    public String getValueName() {\n+        if (propertyDescriptor != null){\n+            return propertyDescriptor.getName();\n+        }\n+        else {\n+            return name;\n+        }\n+    }\n+\n+    /**\n+     * Returns the bean this handle is associated with or a property\n+     * of the bean if a PropertyDescriptor was specified.\n+     * <p>\n+     * @throws RuntimeException if the property cannot be accessed\n+     */\n+    public Object getValue() {\n+        if (!valueRetrieved){\n+            valueRetrieved = true;\n+            Method method = propertyDescriptor.getReadMethod();\n+            try {\n+                if (method == null){\n+                    throw new RuntimeException(\"No read method\");\n+                }\n+                value = method.invoke(bean, null);\n+            }\n+            catch (Exception e){\n+                throw new RuntimeException(\"Cannot access property \" +\n+                    bean.getClass().getName() + '.' + propertyDescriptor.getName() + \"\\n\" +\n+                    e.getMessage());\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Equivalent to getValue(), except that any cached value is ignored.\n+     */\n+    public Object getFreshValue() {\n+        if (propertyDescriptor != null){\n+            valueRetrieved = false;\n+        }\n+        return getValue();\n+    }\n+\n+    /**\n+     * Modifies the property described by the PropertyDescriptor associated with\n+     * this handle.  Throws a RuntimeException if the handle is not associated\n+     * with a property descriptor or if the property is not writable.\n+     */\n+    public void setValue(Object value){\n+//        System.err.println(\"SETTING VALUE: \" + bean + \".\" + propertyDescriptor + \" = \" + value);\n+        try {\n+            if (propertyDescriptor == null){\n+                throw new RuntimeException(\"Not a property\");\n+            }\n+\n+            Method method = propertyDescriptor.getWriteMethod();\n+            if (method == null){\n+                throw new RuntimeException(\"No write method\");\n+            }\n+            method.invoke(bean, new Object[]{value});\n+        }\n+        catch (Exception e){\n+            throw new RuntimeException(\"Cannot modify property \" +\n+                bean.getClass().getName() + '.' + propertyDescriptor.getName() + \"\\n\" +\n+                e.getMessage());\n+        }\n+        valueRetrieved = false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ValueNode.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ValueNode.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * A TEXT node associated with a value.  The textual representation of this\n+ * node is the result of conversion of that value to String.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class ValueNode extends AbstractBeanNode implements Text {\n+\n+    /**\n+     * @param parent is the parent Node\n+     * @param value is a value to be associated with the node. It can be null.\n+     */\n+    public ValueNode(Node parent, Object value, String name){\n+        super(parent, null, 0, value, name);\n+    }\n+\n+    /**\n+     * @param parent is the parent Node\n+     * @param bean is a bean whose property is associated with the node.\n+     */\n+    public ValueNode(Node parent, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(parent, null, 0, bean, propertyDescriptor);\n+    }\n+\n+    /**\n+     * This node does not have any children.\n+     */\n+    public NodeList getChildNodes() {\n+        return EMPTY_LIST;\n+    }\n+\n+    /**\n+     * This is a TEXT node.\n+     */\n+    public short getNodeType() {\n+        return Node.TEXT_NODE;\n+    }\n+\n+    /**\n+     * This node does not have a name.\n+     */\n+    public String getNodeName() {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the result of conversion of the node's value to string.\n+     */\n+    public String getNodeValue() throws DOMException {\n+        return String.valueOf(getValue());\n+    }\n+\n+    /**\n+     * Returns <code>null</code>.\n+     */\n+    public Node getPreviousSibling() {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns <code>null</code>.\n+     */\n+    public Node getNextSibling() {\n+        return null;\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public Text splitText(int i) {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * The character data of the node that implements this interface. The DOM\n+     * implementation may not put arbitrary limits on the amount of data\n+     * that may be stored in a <code>CharacterData</code> node. However,\n+     * implementation limits may mean that the entirety of a node's data may\n+     * not fit into a single <code>DOMString</code>. In such cases, the user\n+     * may call <code>substringData</code> to retrieve the data in\n+     * appropriately sized pieces.\n+     * @exception DOMException\n+     *   NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.\n+     * @exception DOMException\n+     *   DOMSTRING_SIZE_ERR: Raised when it would return more characters than\n+     *   fit in a <code>DOMString</code> variable on the implementation\n+     *   platform.\n+     */\n+    public String getData() throws DOMException {\n+        return String.valueOf(getValue());\n+    }\n+\n+    public void setData(String data) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * The number of 16-bit units that are available through <code>data</code>\n+     * and the <code>substringData</code> method below. This may have the\n+     * value zero, i.e., <code>CharacterData</code> nodes may be empty.\n+     */\n+    public int getLength() {\n+        return 0;\n+    }\n+\n+    /**\n+     *  Unsupported\n+     */\n+    public String substringData(int offset, int count) throws DOMException {\n+        throw JXPathException.unsupported();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void appendData(String arg) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void insertData(int offset, String arg) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void deleteData(int offset, int count) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public void replaceData(int offset, int count, String arg) throws DOMException {\n+        throw JXPathException.unmodifiable();\n+    }\n+\n+    /**\n+     * Implementation of an empty Node List.\n+     */\n+    private static final NodeList EMPTY_LIST = new NodeList (){\n+        public int getLength(){ return 0; }\n+        public Node item(int i) { return null; }\n+    };\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ValueNodeList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ValueNodeList.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+ package org.apache.commons.jxpath.tree;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * A NodeList that contains a single leaf Node of type TEXT. That\n+ * node is associated with a value.  JXPath uses XPath to find this node\n+ * and then extracts the value from it.\n+ *\n+ * @see ValueNode\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class ValueNodeList extends ValueHandle\n+        implements NodeList, NodeSequencer\n+{\n+    Node parent;\n+    private Node child = null;\n+\n+    /**\n+     * @param parent is the parent node of this node list\n+     * @param bean is a bean whose property is associated with the node contained\n+     *        by this list\n+     */\n+    public ValueNodeList(Node parent, Object value, PropertyDescriptor propertyDescriptor){\n+        super(value, propertyDescriptor);\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * @param parent is the parent node of this node list\n+     * @param value is the value that JXPath can extract from the\n+     *      single node contained by this list\n+     */\n+    public ValueNodeList(Node parent, Object value, String name){\n+        super(value, name);\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Returns the single element of the collection if <code>index</code> is 0.\n+     * Otherwise - returns null.\n+     */\n+    public Node item(int index){\n+        if (index == 0){\n+            if (child == null) {\n+                PropertyDescriptor pd = getPropertyDescriptor();\n+                if (pd != null){\n+                    child = new ValueNode(parent, getBean(), pd);\n+                }\n+                else {\n+                    child = new ValueNode(parent, getValue(), getValueName());\n+                }\n+            }\n+            return child;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns 1.\n+     */\n+    public int getLength(){\n+        return 1;\n+    }\n+\n+    /**\n+     * Returns the node.\n+     */\n+    public Node getFirstNode(){\n+        return item(0);\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Node getNextNode(Node node){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the node.\n+     */\n+    public Node getLastNode(){\n+        return item(0);\n+    }\n+\n+    /**\n+     * Returns null\n+     */\n+    public Node getPreviousNode(Node node){\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/tree/ValueNodeSequence.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/tree/Attic/ValueNodeSequence.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.tree;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+\n+/**\n+ * ValueNodeSequence is a sequence of Nodes containing one node only.\n+ * When we <i>know</i> a property is a collection, we use a NodeSequence instead of\n+ * a reqular Node. When we <i>suspect</i> a property may be a collection, we have to\n+ * use a NodeSequence as well. If in reality the property value turns out to be\n+ * scalar, we use ValueNodeSequence: a scalar in disguise of a sequence.\n+ * <p>\n+ * For example, if a property is declared as \"java.lang.Object\",\n+ * we cannot tell whether the actual value is a string, an array, a List or a JavaBean\n+ * by simply looking at the property type.  Therefore we need to be prepared to\n+ * deal with any of these possibilities. Since ValueNodeSequence is more expensive\n+ * than a regular Node, it is only used in such ambiguous situations.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class ValueNodeSequence extends NodeSequence\n+{\n+    public ValueNodeSequence(ElementList elementList, int seqID, Object bean, PropertyDescriptor propertyDescriptor){\n+        super(elementList, seqID, bean, propertyDescriptor);\n+    }\n+\n+    public ValueNodeSequence(ElementList elementList, int seqID, Object value, String name){\n+        super(elementList, seqID, value, name);\n+    }\n+\n+    protected int computeLength(){\n+        return 1;\n+    }\n+\n+    protected Node computeItem(int index){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd != null){\n+            return BeanNodeFactory.allocateNode(parent, this, index, getBean(), pd);\n+        }\n+        else {\n+            return BeanNodeFactory.allocateNode(parent, this, index, getValue(), getValueName());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/xalan/JXPathContextFactoryXalanImpl.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xalan/Attic/JXPathContextFactoryXalanImpl.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.xalan;\n+\n+import org.apache.commons.jxpath.JXPathContextFactory;\n+import org.apache.commons.jxpath.JXPathContextFactoryConfigurationError;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Variables;\n+\n+/**\n+ * <a href=\"http://xml.apache.org/xalan\">Xalan</a>-specific implementation\n+ * of JXPathContextFactory.\n+ * Xalan is included in the standard distribution of\n+ * <a href=\"http://www.java.sun.com/xml/download.html\">JAXP</a>.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class JXPathContextFactoryXalanImpl extends JXPathContextFactory {\n+\n+    public JXPathContextFactoryXalanImpl(){\n+    }\n+\n+    public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError {\n+        return new JXPathContextXalanImpl(parentContext, contextBean);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/xalan/JXPathContextXalanImpl.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xalan/Attic/JXPathContextXalanImpl.java,v 1.1 2001/08/23 00:47:01 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:01 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.xalan;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javax.xml.transform.TransformerException;\n+import org.w3c.dom.Node;\n+//import org.w3c.dom.Node;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.DocumentFragment;\n+import org.w3c.dom.traversal.NodeIterator;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.tree.DOMWrapper;\n+import org.apache.commons.jxpath.tree.BeanNodeFactory;\n+import org.apache.commons.jxpath.tree.BeanNodeList;\n+import org.apache.commons.jxpath.tree.ValueHandle;\n+import org.apache.commons.jxpath.Variables;\n+import org.apache.xpath.NodeSet;\n+import org.apache.xpath.objects.XObject;\n+import org.apache.xpath.objects.XNull;\n+\n+import org.apache.xpath.XPathContext;\n+import org.apache.xpath.XPath;\n+import org.apache.xpath.compiler.XPathParser;\n+import org.apache.xpath.XPathContext;\n+import org.apache.xml.utils.PrefixResolverDefault;\n+import org.apache.xml.utils.PrefixResolver;\n+import org.apache.xml.utils.QName;\n+import org.apache.xpath.objects.XObject;\n+\n+/**\n+ * <a href=\"http://xml.apache.org/xalan\">Xalan</a>-specific implementation\n+ * of JXPathContext.\n+ * <p>\n+ * Instances of JXPathContextXalanImpl are allocated by {@link JXPathContextFactoryXalanImpl}.\n+ * </p>\n+ * <p>\n+ * Xalan is included in the standard distribution of\n+ * <a href=\"http://www.java.sun.com/xml/download.html\">JAXP</a>.\n+ * </p>\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:01 $\n+ */\n+public class JXPathContextXalanImpl extends JXPathContext {\n+\n+    private Node wrapper;\n+    private HashMap varWrappers = new HashMap();\n+    private static final XObject NULL = new XNull();\n+\n+    protected JXPathContextXalanImpl(JXPathContext parentContext, Object contextBean){\n+        super(parentContext, contextBean);\n+    }\n+\n+    /**\n+     * Returns (and caches) a DOMWrapper for the context's context bean\n+     */\n+    private Node getWrapper(){\n+        if (wrapper == null){\n+            wrapper = DOMWrapper.createNode(contextBean, \"jxpath\");\n+        }\n+        return wrapper;\n+    }\n+\n+    /**\n+     * Maintains a cache of Nodes/NodeLists for variable values. Creates a new\n+     * node or node list using DOMWrapper if there is no node for the specified variable\n+     * or if the value of the variable has changed.\n+     */\n+    private Object getWrapper(String variable, Object value){\n+        Object w = varWrappers.get(variable);\n+        if (DOMWrapper.isCollection(value)){\n+            if (w == null || !(w instanceof BeanNodeList) || (((BeanNodeList)w).getCollection() != value)){\n+                w = new NodeSet(DOMWrapper.createNodeList(value, variable));\n+                varWrappers.put(variable, w);\n+            }\n+        }\n+        else {\n+            if (w == null || !(w instanceof ValueHandle) || (((ValueHandle)w).getBean() != value)){\n+                w = DOMWrapper.createNode(value, variable);\n+                varWrappers.put(variable, w);\n+            }\n+        }\n+        return w;\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns the resulting object. Primitive\n+     * types are wrapped into objects.\n+     */\n+    public Object getValue(String xpath){\n+        return evalNode(getWrapper(), xpath, true);\n+    }\n+\n+    /**\n+     * Traverses the xpath and returns a List of objects. Even if\n+     * there is only one object that matches the xpath, it will be returned\n+     * as a collection with one element.  If the xpath matches no properties\n+     * in the graph, the List will be empty.\n+     */\n+    public List eval(String xpath){\n+        return (List)evalNode(getWrapper(), xpath, false);\n+    }\n+\n+    public Pointer locateValue(String xpath){\n+        throw new UnsupportedOperationException(\"locateValue\");\n+    }\n+\n+    public List locate(String xpath){\n+        throw new UnsupportedOperationException(\"locate\");\n+    }\n+\n+\n+    /**\n+     * Passes the node and the xpath to Xalan XPath.  If needed, the results are\n+     * unwrapped from ValueHandles and/or wrapped into Lists.\n+     */\n+    private Object evalNode(Node node, String xpath, boolean singleValue) {\n+        Object result = null;\n+        try {\n+            XObject o = eval(node, xpath);\n+            switch (o.getType()){\n+                case XObject.CLASS_NODESET:\n+                    NodeIterator set = o.nodeset();\n+                    Node n = set.nextNode();\n+                    if (singleValue){\n+                        if (n != null){\n+                            if (n instanceof ValueHandle){\n+                                result = ((ValueHandle)n).getValue();\n+                            }\n+                            else {\n+                                result = n;\n+                            }\n+                        }\n+                    }\n+                    else {\n+                        ArrayList list = new ArrayList();\n+                        while (n != null){\n+                            if (n instanceof ValueHandle){\n+                                list.add(((ValueHandle)n).getValue());\n+                            }\n+                            else {\n+                                list.add(n);\n+                            }\n+                            n = set.nextNode();\n+                        }\n+                        result = list;\n+                    }\n+                    set.detach();\n+                    break;\n+                case XObject.CLASS_BOOLEAN:\n+                    result = o.bool() ? Boolean.TRUE : Boolean.FALSE;\n+                    break;\n+                case XObject.CLASS_NULL:\n+                    result = null;\n+                    break;\n+                case XObject.CLASS_NUMBER:\n+                    result = new Double(o.num());\n+                    break;\n+                case XObject.CLASS_STRING:\n+                    result = o.str();\n+                    break;\n+                case XObject.CLASS_RTREEFRAG:\n+                case XObject.CLASS_UNKNOWN:\n+                case XObject.CLASS_UNRESOLVEDVARIABLE:\n+                    result = null;\n+                    break;\n+            }\n+        }\n+        catch (javax.xml.transform.TransformerException ex){\n+//            ex.printStackTrace();\n+            throw new RuntimeException(\"Cannot traverse xpath \\\"\" + xpath + \"\\\": \" + ex.getMessage());\n+        }\n+\n+        if (!singleValue && !(result instanceof List)){\n+            if (result == null){\n+                result = Collections.EMPTY_LIST;\n+            }\n+            else {\n+                ArrayList list = new ArrayList();\n+                list.add(result);\n+                result = list;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Modifies the value of the property or variable described by the supplied xpath.\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>The xpath does not in fact describe an existing property or variable\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    public void setValue(String xpath, Object value){\n+        try {\n+            Node node = getWrapper();\n+            xpath = xpath.trim();\n+            if (xpath.startsWith(\"$\")){\n+                // See if we have a simple variable assignment\n+                boolean isVar = true;\n+                char chars[] = xpath.toCharArray();\n+                for (int i = 1; i < chars.length; i++){\n+                    // Should do a more precise test\n+                    if (!Character.isUnicodeIdentifierPart(chars[i])){\n+                        isVar = false;\n+                        break;\n+                    }\n+                }\n+                if (isVar){\n+                    setVariableValue(xpath.substring(1), value);\n+                    return;\n+                }\n+            }\n+\n+            XObject o = eval(node, xpath);\n+            if (o.getType() != XObject.CLASS_NODESET){\n+                throw new RuntimeException(\"Xpath does not represent a singular property\");\n+            }\n+\n+            NodeIterator set = o.nodeset();\n+            Node n = set.nextNode();\n+            if (n == null){\n+                throw new RuntimeException(\"Xpath does not represent a singular property\");\n+            }\n+            if (!(n instanceof ValueHandle)){\n+                throw new RuntimeException(\"Attempt to use setProperty() with a non-JXPath DOM tree\");\n+            }\n+\n+            ((ValueHandle)n).setValue(value);\n+        }\n+        catch (Exception ex){\n+            throw new RuntimeException(\"Cannot set property value with xpath \\\"\" + xpath + \"\\\": \" + ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Invokes Xalan to traverse the supplied xpath\n+     */\n+    private XObject eval(Node node, String xpath) throws TransformerException {\n+        Node namespaceNode = node;\n+        Node contextNode = node;\n+\n+        XPathContext xpathSupport = new JXalanPathContext();\n+\n+        PrefixResolverDefault prefixResolver = new PrefixResolverDefault(\n+          (namespaceNode.getNodeType() == Node.DOCUMENT_NODE)\n+          ? ((Document) namespaceNode).getDocumentElement() : namespaceNode);\n+\n+        XPath xp = new XPath(xpath, null, prefixResolver, XPath.SELECT, null);\n+        return xp.execute(xpathSupport, contextNode, prefixResolver);\n+    }\n+\n+    /**\n+     * Finds the context where the variable is defined and changes its value.\n+     */\n+    private void setVariableValue(String varName, Object value) throws TransformerException {\n+        JXPathContext varCtx = JXPathContextXalanImpl.this;\n+        Variables vars = null;\n+        while (varCtx != null){\n+            vars = varCtx.getVariables();\n+            if (vars.isDeclaredVariable(varName)){\n+                break;\n+            }\n+            varCtx = varCtx.getParentContext();\n+            vars = null;\n+        }\n+\n+        if (vars != null){\n+            vars.declareVariable(varName, value);\n+        }\n+        else {\n+            throw new TransformerException(\"Undefined variable: \" + varName);\n+        }\n+    }\n+\n+    /**\n+     * Finds the context where the variable is defined and returns its value\n+     */\n+    private XObject getVariableValue(String varName) throws TransformerException {\n+        XObject xo = null;\n+        JXPathContext varCtx = JXPathContextXalanImpl.this;\n+        Variables vars = null;\n+        while (varCtx != null){\n+            vars = varCtx.getVariables();\n+            if (vars.isDeclaredVariable(varName)){\n+                break;\n+            }\n+            varCtx = varCtx.getParentContext();\n+            vars = null;\n+        }\n+\n+        if (vars != null){\n+            Object value = vars.getVariable(varName);\n+            if (value == null){\n+                xo = NULL;\n+            }\n+            else if (value instanceof String ||\n+                     value instanceof Boolean ||\n+                     value instanceof Double ||\n+                     value instanceof DocumentFragment ||\n+                     value instanceof Node ||\n+                     value instanceof NodeIterator){\n+                xo = XObject.create(value);\n+            }\n+            else if (value instanceof Number){\n+                xo = XObject.create(new Double(((Number)value).doubleValue()));\n+            }\n+            else {\n+                // If the parent context is a context of that can produce a wrapper,\n+                // we should store the wrapper in the cache of that context, not\n+                // the current one.  Chances are the parent context is reused\n+                // with multiple child contexts.\n+\n+                Object wrapper = null;\n+                if (varCtx instanceof JXPathContextXalanImpl){\n+                    wrapper = ((JXPathContextXalanImpl)varCtx).getWrapper(varName, value);\n+                }\n+                else {\n+                    wrapper = getWrapper(varName, value);\n+                }\n+                xo = XObject.create(wrapper);\n+            }\n+        }\n+        else {\n+            throw new TransformerException(\"Undefined variable: \" + varName);\n+        }\n+        return xo;\n+    }\n+\n+    /**\n+     * Custom subclass of XPathContext that provides access to JXPath\n+     * Variables pools.\n+     */\n+    private class JXalanPathContext extends XPathContext {\n+        public XObject getVariable(QName qname) throws TransformerException {\n+            XObject xo = null;\n+            try {\n+                xo = super.getVariable(qname);\n+            }\n+            catch (Exception te){\n+            }\n+\n+            if (xo == null){\n+                try {\n+                    xo = getVariableValue(qname.toString());\n+                }\n+                catch (TransformerException te){\n+                    throw te;\n+                }\n+                catch (Exception ex){\n+                    throw new TransformerException(\"Undefined variable: \" + qname, ex);\n+                }\n+            }\n+            return xo;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.w3c.dom.Node;\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.parser.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.tree.DOMWrapper;\n+import java.beans.*;\n+\n+\n+/**\n+ * <p>\n+ *  Test Case for the JXPath class.  The majority of these tests use\n+ *  instances of the TestBean class, so be sure to update the tests if you\n+ *  change the characteristics of that class.\n+ * </p>\n+ *\n+ * <p>\n+ *   Note that the tests are dependant upon the static aspects\n+ *   (such as array sizes...) of the TestBean.java class, so ensure\n+ *   than all changes to TestBean are reflected here.\n+ * </p>\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+\n+public class JXPathTestCase extends TestCase\n+{\n+    private boolean enabled = true;\n+\n+    /**\n+     * Exercises this test case only\n+     */\n+    public static void main(String args[]) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    // ---------------------------------------------------- Instance Variables\n+\n+    /**\n+     * The test bean for each test.\n+     */\n+    protected TestBean bean = null;\n+\n+\n+    // ---------------------------------------------------------- Constructors\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public JXPathTestCase(String name)\n+    {\n+        super(name);\n+    }\n+\n+\n+    // -------------------------------------------------- Overall Test Methods\n+\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp()\n+    {\n+        bean = new TestBean();\n+    }\n+\n+\n+    /**\n+     * Return the tests included in this test suite.\n+     */\n+    public static Test suite()\n+    {\n+        return (new TestSuite(JXPathTestCase.class));\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown()\n+    {\n+        bean = null;\n+    }\n+\n+\n+    // ------------------------------------------------ Individual Test Methods\n+\n+    /**\n+     * Test property iterators, the core of the graph traversal engine\n+     */\n+    public void testIndividualIterators(){\n+        if (enabled){\n+//        testIndividual(0, 0, true, false, 3);\n+            testIndividual(+1, 0, true, false, 0);\n+            testIndividual(-1, 0, true, false, 4);\n+\n+            testIndividual(0, -1, true, true, 4);\n+            testIndividual(+1, -1, true, true, 4);\n+            testIndividual(-1, -1, true, true, 0);\n+\n+            testIndividual(0, 1, true, false, 2);\n+            testIndividual(0, 1, true, true, 1);\n+\n+            testIndividual(0, 0, false, false, 4);\n+            testIndividual(0, 0, false, true, 4);\n+        }\n+    }\n+\n+    private void testIndividual(int relativePropertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n+        NodePointer root = NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n+        PropertyIterator it;\n+\n+        if (useStartLocation){\n+            PropertyPointer holder = root.getPropertyPointer();\n+            holder.setPropertyIndex(relativeProperty(holder, relativePropertyIndex));\n+            holder.setIndex(offset);\n+            it = PropertyIterator.iteratorStartingAt(holder, \"integers\", reverse);\n+        }\n+        else {\n+            it = PropertyIterator.iterator(root, \"integers\", reverse);\n+        }\n+\n+        int size = 0;\n+        while(it.next()){\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Individual, relativePropertyIndex=\" + relativePropertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    public void testMultipleIterators(){\n+        if (enabled){\n+            testMultiple(0, 0, true, false, 20);\n+\n+            testMultiple(3, 0, true, false, 16);\n+            testMultiple(3, -1, true, true, 8);\n+            testMultiple(3, 0, true, true, 4);\n+            testMultiple(0, 0, false, false, 21);\n+            testMultiple(0, 0, false, true, 21);\n+\n+            testMultiple(3, 1, true, false, 15);\n+            testMultiple(3, 3, true, false, 13);\n+        }\n+    }\n+\n+    private void testMultiple(int propertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n+        NodePointer root = NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n+        PropertyIterator it;\n+\n+        if (useStartLocation){\n+            PropertyPointer holder = root.getPropertyPointer();\n+            holder.setPropertyIndex(propertyIndex);\n+            holder.setIndex(offset);\n+            it = PropertyIterator.iteratorStartingAt(holder, null, reverse);\n+        }\n+        else {\n+            it = PropertyIterator.iterator(root, null, reverse);\n+        }\n+\n+        int size = 0;\n+        while(it.next()){\n+//            System.err.println(\"LOC: \" + it.getCurrentNodePointer());\n+            size++;\n+        }\n+        assertEquals(\"ITERATIONS: Multiple, propertyIndex=\" + propertyIndex +\n+            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n+            \", reverse=\" + reverse, expected, size);\n+    }\n+\n+    private int relativeProperty(PropertyPointer holder, int offset){\n+        String[] names = holder.getPropertyNames();\n+        for (int i = 0; i < names.length; i++){\n+            if (names[i].equals(\"integers\")){\n+                return i + offset;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with various arguments\n+     */\n+    public void testGetValue(){\n+        if (enabled){\n+            JXPathContext context = JXPathContext.newContext(bean);\n+            testGetValue(context, \"2+2\",                     new Double(4.0));\n+            testGetValue(context, \"boolean\",                 Boolean.FALSE);\n+            testGetValue(context, \"substring(boolean, 1,2)\", \"fa\"); // 'fa'lse\n+            testGetValue(context, \"int*2\",                   new Double(2.0));\n+            testGetValue(context, \"integers[1]\",             new Integer(1));\n+            testGetValue(context, \"nestedBean\",              bean.getNestedBean());\n+            testGetValue(context, \"nestedBean/boolean\",      Boolean.FALSE);\n+            testGetValue(context, \"object/name\",             \"Name 5\");\n+            testGetValue(context, \"objects[1]\",              new Integer(1));\n+            testGetValue(context, \"map/Key1\",                \"Value 1\");\n+            testGetValue(context, \"beans[name = 'Name 1']\",  bean.getBeans()[0]);\n+            testGetValue(context, \".[1]/int\",                new Integer(1));\n+//        testGetValue(context, \"id('foo')\",               new Integer(1));\n+//        testGetValue(context, \"key('foo', 'bar')\",               new Integer(1));\n+        }\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with variables\n+     */\n+    public void testVariables(){\n+        if (enabled){\n+            JXPathContext context = JXPathContext.newContext(bean.getBeans());\n+            context.getVariables().declareVariable(\"x\", new Double(7.0));\n+            context.getVariables().declareVariable(\"y\", null);\n+            context.getVariables().declareVariable(\"z\", bean);\n+            context.getVariables().declareVariable(\"t\", new String[]{\"a\", \"b\"});\n+            context.getVariables().declareVariable(\"m\", bean.getMap());\n+\n+            testGetValue(context, \"$x + 3\",  new Double(10.0));\n+            testGetValue(context, \"$y\",  null);\n+            testGetValue(context, \"$y + 1\",  new Double(1.0));\n+            boolean exception = false;\n+            try {\n+                testGetValue(context, \"$none\",  null);\n+            }\n+            catch (Exception ex){\n+                exception = true;\n+            }\n+            assert(\"Evaluating '$none', expected exception - did not get it\", exception);\n+\n+            testGetValue(context, \"$z/int\",  new Integer(1));\n+            testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n+\n+            testGetValue(context, \".[2]/name\",  \"Name 2\");\n+            testGetValue(context, \"$t[2]\",  \"b\");\n+            testGetValue(context, \"$m/Key1\",  \"Value 1\");\n+//          testGetValue(context, \"[1]\",  new Integer(2));\n+        }\n+    }\n+\n+    private void testGetValue(JXPathContext context, String xpath, Object expected) {\n+        Object actual = context.getValue(xpath);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    /**\n+     * Test JXPath.eval() with various arguments\n+     */\n+    public void testEval(){\n+        if (enabled){\n+            JXPathContext context = JXPathContext.newContext(bean);\n+            testEval(context, \"integers[position()<3]\",\n+                    Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}));\n+        }\n+    }\n+\n+    private void testEval(JXPathContext context, String xpath, Object expected) {\n+        Object actual = context.eval(xpath);\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n+    }\n+\n+    public void testContextDependency(){\n+        if (enabled){\n+            testContextDependency(\"1\", false);\n+            testContextDependency(\"$x\", false);\n+            testContextDependency(\"/foo\", false);\n+            testContextDependency(\"foo\", true);\n+            testContextDependency(\"/foo[3]\", false);\n+            testContextDependency(\"/foo[$x]\", false);\n+            testContextDependency(\"/foo[bar]\", true);\n+            testContextDependency(\"3 + 5\", false);\n+            testContextDependency(\"test:func(3, 5)\", false);\n+            testContextDependency(\"test:func(3, foo)\", true);\n+        }\n+    }\n+\n+    public void testContextDependency(String xpath, boolean expected){\n+        Expression expr = (Expression)Parser.parseExpression(xpath, new TreeCompiler());\n+        assertEquals(\"Evaluating <\" + xpath + \">\", expected, expr.isContextDependent());\n+    }\n+\n+    /**\n+     * Test JXPath.setValue() with various arguments\n+     */\n+    public void testSetValue(){\n+        if (enabled){\n+            TestBean tBean = new TestBean();\n+            JXPathContext context = JXPathContext.newContext(tBean);\n+            context.getVariables().declareVariable(\"x\", null);\n+\n+            context.setValue(\"$x\", new Integer(1));\n+            assertEquals(\"Modified <\" + \"$x\" + \">\", new Integer(1), context.getValue(\"$x\"));\n+\n+            boolean exception = false;\n+            try {\n+                context.setValue(\"$y\", new Integer(1));\n+            }\n+            catch (Exception ex){\n+                exception = true;\n+            }\n+            assert(\"Setting '$y = 1', expected exception - did not get it\", exception);\n+\n+            context.setValue(\"int\", new Integer(3));\n+            assertEquals(\"Modified <\" + \"int\" + \">\", new Integer(3), context.getValue(\"int\"));\n+\n+            context.setValue(\"integers[2]\", new Integer(5));\n+            assertEquals(\"Modified <\" + \"integers[2]\" + \">\", new Integer(5), context.getValue(\"integers[2]\"));\n+\n+            NestedTestBean nBean = new NestedTestBean(\"Name 9\");\n+            tBean.getBeans()[1] = null;\n+            context.setValue(\"beans[2]\", nBean);\n+            assertEquals(\"Modified <\" + \"beans[2]\" + \">\", nBean, context.getValue(\"beans[2]\"));\n+\n+            context.setValue(\"map/Key1\", new Integer(6));\n+            assertEquals(\"Modified <\" + \"map/Key1\" + \">\", new Integer(6), context.getValue(\"map/Key1\"));\n+\n+            context.setValue(\"map/Key1\", new Integer[]{new Integer(7), new Integer(8)});\n+            context.setValue(\"map/Key1[1]\", new Integer(9));\n+            assertEquals(\"Modified <\" + \"map/Key1[1]\" + \">\", new Integer(9), context.getValue(\"map/Key1[1]\"));\n+\n+            context.setValue(\"map/Key4\", new Integer(7));\n+            assertEquals(\"Modified <\" + \"map/Key4\" + \">\", new Integer(7), context.getValue(\"map/Key4\"));\n+        }\n+    }\n+\n+    public void testNull(){\n+        if (enabled){\n+            JXPathContext context = JXPathContext.newContext(new TestNull());\n+            testGetValue(context, \"nothing\", null);\n+            testGetValue(context, \"child/nothing\", null);\n+            testGetValue(context, \"nothing/something\", null);\n+            testGetValue(context, \"array[2]\", null);\n+            testGetValue(context, \"array[2]/something\", null);\n+        }\n+    }\n+\n+    /**\n+     * Test JXPath.getValue() with nested contexts\n+     */\n+    public void testNestedContext(){\n+        if (enabled){\n+            JXPathContext pcontext = JXPathContext.newContext(null);\n+            pcontext.getVariables().declareVariable(\"x\", bean);\n+\n+            JXPathContext context = JXPathContext.newContext(pcontext, bean);\n+\n+            testGetValue(context, \"integers[$x/int]\",  new Integer(1));\n+        }\n+    }\n+\n+    public void testFunctions(){\n+        if (enabled){\n+            Object[] args;\n+            Function func;\n+\n+            TestFunctions test = new TestFunctions();\n+            Functions funcs = new ClassFunctions(TestFunctions.class, \"test\");\n+\n+            args = new Object[]{new Integer(1), \"x\"};\n+            func = funcs.getFunction(\"test\", \"new\", args);\n+            assertEquals(\"test:new(1, x)\", func.invoke(args).toString(), \"foo=1; bar=x\");\n+\n+            args = new Object[]{new Integer(1), \"x\"};\n+            func = funcs.getFunction(\"test\", \"build\", args);\n+            assertEquals(\"test:build(1, x)\", func.invoke(args).toString(), \"foo=1; bar=x\");\n+\n+            args = new Object[]{\"7\", new Integer(1)};\n+            func = funcs.getFunction(\"test\", \"build\", args);\n+            assertEquals(\"test:build('7', 1)\", func.invoke(args).toString(), \"foo=7; bar=1\");\n+\n+            args = new Object[]{test};\n+            func = funcs.getFunction(\"test\", \"getFoo\", args);\n+            assertEquals(\"test:getFoo($test, 1, x)\", func.invoke(args).toString(), \"0\");\n+        }\n+    }\n+\n+    /*\n+     * Remove the underscore from the method name if you want to see the output\n+     */\n+    public void _testXSLT(){\n+        Node node = DOMWrapper.createNode(bean, \"test\");\n+        printXML(node, System.err);\n+    }\n+\n+    private static void printXML(Node node, java.io.OutputStream outputStream){\n+        try {\n+            javax.xml.transform.dom.DOMSource source = new javax.xml.transform.dom.DOMSource(node);\n+            javax.xml.transform.stream.StreamResult result = new javax.xml.transform.stream.StreamResult(outputStream);\n+            javax.xml.transform.Transformer trans = javax.xml.transform.TransformerFactory.newInstance().newTransformer();\n+            trans.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, \"yes\");\n+            trans.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n+            trans.transform(source, result);\n+        }\n+        catch (Exception ex){\n+            // We don't care about this. The method is only for debugging\n+            ex.printStackTrace();\n+        }\n+   }\n+\n+   // Fails most tests. Remove \"_\" and run to see them.\n+    public void _testParserXalan(){\n+        System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n+                \"org.apache.commons.jxpath.xalan.JXPathContextFactoryXalanImpl\");\n+        testParser(JXPathContextFactory.newInstance().newContext(null, bean), true);\n+    }\n+\n+    public void testParserReferenceImpl(){\n+        System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n+                \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n+        testParser(JXPathContextFactory.newInstance().newContext(null, bean), false);\n+    }\n+\n+    public void testParser(JXPathContext ctx, boolean ignorePath){\n+        ctx.getVariables().declareVariable(\"a\", new Double(1));\n+        ctx.getVariables().declareVariable(\"b\", new Double(1));\n+        ctx.getVariables().declareVariable(\"nan\", new Double(Double.NaN));\n+        ctx.getVariables().declareVariable(\"test\", new TestFunctions(4, \"test\"));\n+        ctx.getVariables().declareVariable(\"testnull\", new TestNull());\n+        FunctionLibrary lib = new FunctionLibrary();\n+        lib.addFunctions(new ClassFunctions(TestFunctions.class, \"test\"));\n+        lib.addFunctions(new ClassFunctions(TestFunctions2.class, \"test\"));\n+        lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n+        lib.addFunctions(new PackageFunctions(\"org.apache.commons.jxpath.\", \"jxpathtest\"));\n+        ctx.setFunctions(lib);\n+\n+        for  (int i=0; i < xpath_tests.length; i++) {\n+            try {\n+                Object actual;\n+//                System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n+                if (xpath_tests[i].path){\n+                    if (ignorePath){\n+                        actual = xpath_tests[i].expected;\n+                    }\n+                    else {\n+                        if (xpath_tests[i].eval){\n+                            List list = ctx.locate(xpath_tests[i].xpath);\n+                            List paths = new ArrayList();\n+                            for (Iterator it = list.iterator(); it.hasNext();){\n+                                paths.add(((Pointer)it.next()).asPath());\n+                            }\n+                            actual = paths;\n+                        }\n+                        else {\n+                            actual = ctx.locateValue(xpath_tests[i].xpath).asPath();\n+                        }\n+                    }\n+                }\n+                else {\n+                    if (xpath_tests[i].eval){\n+                        actual = ctx.eval(xpath_tests[i].xpath);\n+                    }\n+                    else {\n+                        actual = ctx.getValue(xpath_tests[i].xpath);\n+                    }\n+                }\n+                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\", xpath_tests[i].expected, actual);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during <\" + xpath_tests[i].xpath + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    private static class XP {\n+        public String xpath;\n+        public Object expected;\n+        public boolean eval;\n+        public boolean path;\n+\n+        public XP(String xpath,  Object expected, boolean eval, boolean path){\n+            this.xpath = xpath;\n+            this.expected = expected;\n+            this.eval = eval;\n+            this.path = path;\n+        }\n+    }\n+\n+    private static XP test(String xpath, Object expected){\n+        return new XP(xpath, expected, false, false);\n+    }\n+\n+    private static XP testEval(String xpath, Object expected){\n+        return new XP(xpath, expected, true, false);\n+    }\n+\n+    private static XP testPath(String xpath, Object expected){\n+        return new XP(xpath, expected, false, true);\n+    }\n+\n+    private static XP testEvalPath(String xpath, Object expected){\n+        return new XP(xpath, expected, true, true);\n+    }\n+\n+    static final XP[] xpath_tests = new XP[]{\n+        // Numbers\n+        test(\"1\", new Double(1.0)),\n+        testEval(\"1\", list(new Double(1.0))),\n+        test(\"-1\", new Double(-1.0)),\n+        test(\"2 + 2\", new Double(4.0)),\n+        test(\"3 - 2\", new Double(1.0)),\n+        test(\"1 + 2 + 3 - 4 + 5\", new Double(7.0)),\n+        test(\"3 * 2\", new Double(3.0*2.0)),\n+        test(\"3 div 2\", new Double(3.0/2.0)),\n+        test(\"5 mod 2\", new Double(1.0)),\n+        test(\"5.9 mod 2.1\", new Double(1.0)),     // Error in Xalan?\n+        test(\"5 mod -2\", new Double(1.0)),\n+        test(\"-5 mod 2\", new Double(-1.0)),\n+        test(\"-5 mod -2\", new Double(-1.0)),\n+        test(\"1 < 2\", Boolean.TRUE),\n+        test(\"1 > 2\", Boolean.FALSE),\n+        test(\"1 <= 1\", Boolean.TRUE),\n+        test(\"1 >= 2\", Boolean.FALSE),\n+        test(\"3 > 2 > 1\", Boolean.FALSE),\n+        test(\"3 > 2 and 2 > 1\", Boolean.TRUE),\n+        test(\"3 > 2 and 2 < 1\", Boolean.FALSE),\n+        test(\"3 < 2 or 2 > 1\", Boolean.TRUE),\n+        test(\"3 < 2 or 2 < 1\", Boolean.FALSE),\n+        test(\"1 = 1\", Boolean.TRUE),\n+        test(\"1 = '1'\", Boolean.TRUE),\n+        test(\"1 > 2 = 2 > 3\", Boolean.TRUE),\n+        test(\"1 > 2 = 0\", Boolean.TRUE),\n+        test(\"1 = 2\", Boolean.FALSE),\n+\n+        // Variables\n+        test(\"$a\", new Double(1)),\n+        test(\"$a = $b\", Boolean.TRUE),\n+        test(\"$a = $test\", Boolean.FALSE),\n+\n+        // Traversal\n+        // ancestor::\n+        test(\"int/ancestor::root = /\", Boolean.TRUE),\n+        test(\"count(beans/name/ancestor-or-self::node())\", new Double(5)),\n+        test(\"beans/name/ancestor-or-self::node()[3] = /\", Boolean.TRUE),\n+\n+        // child::\n+        test(\"count(set)\", new Double(3)),\n+        test(\"boolean\", Boolean.FALSE),\n+        testPath(\"boolean\", \"/boolean\"),\n+        testEvalPath(\"boolean\", list(\"/boolean\")),\n+        test(\"nestedBean/name\", \"Name 0\"),\n+        testPath(\"nestedBean/name\", \"/nestedBean/name\"),\n+        testEvalPath(\"nestedBean/name\", list(\"/nestedBean/name\")),\n+        testEval(\"integers\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n+        testPath(\"integers\", \"/integers\"),\n+        testEvalPath(\"integers\", list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\")),\n+        test(\"integers[2]\", new Integer(2)),\n+        testPath(\"integers[2]\", \"/integers[2]\"),\n+        testEvalPath(\"integers[2]\", list(\"/integers[2]\")),\n+        test(\"beans[1]/name\", \"Name 1\"),\n+        testPath(\"beans[1]/name\", \"/beans[1]/name\"),\n+        testEval(\"beans[1]/strings\", list(\"String 1\", \"String 2\", \"String 3\")),\n+        testEval(\"beans/strings[2]\", list(\"String 2\", \"String 2\")),\n+        test(\"beans/strings[2]\", \"String 2\"),\n+        test(\"(beans/strings[2])[1]\", \"String 2\"),\n+        test(\"count(*)\", new Double(21)),\n+        test(\"count(child::node())\", new Double(21)),\n+\n+        // descendant::\n+        test(\"count(descendant::node())\", new Double(65)),\n+        test(\"count(descendant::root)\", new Double(0)),\n+        test(\"count(descendant::name)\", new Double(7)),\n+\n+        // descendant-or-self::\n+        testEval(\"//name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        testEval(\"//self::node()[name = 'Name 0']/name\", list(\"Name 0\")),\n+        testEval(\"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n+                list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"count(//self::beans)\", new Double(2)),\n+        test(\"count(nestedBean//.)\", new Double(7)),\n+        testEval(\"descendant-or-self::name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"count(descendant-or-self::root)\", new Double(1)),\n+        test(\"count(descendant-or-self::node())\", new Double(66)),\n+\n+        // following::\n+        test(\"count(nestedBean/strings[2]/following::node())\", new Double(21)),\n+        test(\"count(nestedBean/strings[2]/following::strings)\", new Double(7)),\n+\n+        // following-sibling::\n+        test(\"count(/nestedBean/following-sibling::node())\", new Double(8)),\n+        test(\"count(/nestedBean/following-sibling::object)\", new Double(1)),\n+        test(\"count(/nestedBean/boolean/../following-sibling::node())\", new Double(8)),\n+        test(\"count(/nestedBean/boolean/../following-sibling::object)\", new Double(1)),\n+        test(\"count(/descendant::boolean/following-sibling::node())\", new Double(53)),\n+        test(\"count(/descendant::boolean/following-sibling::name)\", new Double(7)),\n+\n+\n+        // parent::\n+        test(\"count(/beans/..)\", new Double(1)),\n+        test(\"count(//..)\", new Double(9)),\n+        test(\"count(//../..)\", new Double(2)),\n+        testEval(\"//parent::beans/name\", list(\"Name 1\", \"Name 2\")),\n+\n+        // preceding::\n+        test(\"count(beans[2]/int/preceding::node())\", new Double(8)),\n+        test(\"count(beans[2]/int/preceding::boolean)\", new Double(2)),\n+\n+        // preceding-sibling::\n+        test(\"count(/boolean/preceding-sibling::node())\", new Double(2)),\n+        test(\"count(/nestedBean/int/../preceding-sibling::node())\", new Double(12)),\n+        test(\"count(/descendant::int/preceding-sibling::node())\", new Double(10)),\n+\n+        // self::\n+        test(\"self::node() = /\", Boolean.TRUE),\n+        test(\"self::root = /\", Boolean.TRUE),\n+\n+        // Union\n+        testEval(\"integers | beans[1]/strings\",\n+            list(new Integer(1), new Integer(2), new Integer(3), new Integer(4), \"String 1\", \"String 2\", \"String 3\")),\n+\n+        test(\"count((integers | beans[1]/strings)[contains(., '1')])\", new Double(2)),\n+        test(\"count((integers | beans[1]/strings)[name(.) = 'strings'])\", new Double(3)),\n+\n+        // Note that the following is different from \"integer[2]\" - it is a filter expression\n+        test(\"(integers)[2]\", new Integer(2)),\n+\n+        // Core functions\n+        test(\"integers[last()]\", new Integer(4)),\n+        test(\"integers[position() = last() - 1]\", new Integer(3)),\n+        testEval(\"integers[position() < 3]\", list(new Integer(1), new Integer(2))),\n+        test(\"count(beans/strings)\", new Double(6)),\n+//        test(\"integers[string() = '2.0']\", new Integer(2)),  // Incorrect -- TBD\n+\n+        test(\"name(integers)\", \"integers\"),\n+        testEval(\"*[name(.) = 'integers']\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n+\n+        // Dynamic properties\n+        test(\"nestedBean[@name = 'int']\", new Integer(1)),    // Not implemented in Xalan\n+        testPath(\"nestedBean[@name = 'int']\", \"/nestedBean/int\"),\n+        test(\"map[@name = 'Key1']\", \"Value 1\"),               // Not implemented in Xalan\n+        testPath(\"map[@name = 'Key1']\", \"/map[@name='Key1']\"),\n+        test(\"map/Key1\", \"Value 1\"),\n+        testPath(\"map/Key1\", \"/map[@name='Key1']\"),\n+        testPath(\"map[@name = 'Key&quot;&apos;&quot;&apos;1']\", \"/map[@name='Key&quot;&apos;&quot;&apos;1']\"),\n+\n+        // Standard functions\n+        test(\"string(2)\", \"2.0\"),\n+        test(\"string($nan)\", \"NaN\"),\n+        test(\"string(-$nan)\", \"NaN\"),\n+        test(\"string(-2 div 0)\", \"-Infinity\"),\n+        test(\"string(2 div 0)\", \"Infinity\"),\n+        test(\"concat('a', 'b', 'c')\", \"abc\"),\n+        test(\"starts-with('abc', 'ab')\", Boolean.TRUE),\n+        test(\"starts-with('xabc', 'ab')\", Boolean.FALSE),\n+        test(\"contains('xabc', 'ab')\", Boolean.TRUE),\n+        test(\"contains('xabc', 'ba')\", Boolean.FALSE),\n+        test(\"substring-before('1999/04/01', '/')\", \"1999\"),\n+        test(\"substring-after('1999/04/01', '/')\", \"04/01\"),\n+        test(\"substring('12345', 2, 3)\", \"234\"),\n+        test(\"substring('12345', 2)\", \"2345\"),\n+        test(\"substring('12345', 1.5, 2.6)\", \"234\"),\n+        test(\"substring('12345', 0, 3)\", \"12\"),\n+        test(\"substring('12345', 0 div 0, 3)\", \"\"),\n+        test(\"substring('12345', 1, 0 div 0)\", \"\"),\n+        test(\"substring('12345', -42, 1 div 0)\", \"12345\"),\n+        test(\"substring('12345', -1 div 0, 1 div 0)\", \"\"),\n+        test(\"string-length('12345')\", new Double(5)),\n+        testEval(\"beans[1]/strings[string-length() = 8]\", list(\"String 1\", \"String 2\", \"String 3\")),\n+        test(\"normalize-space(' abc  def  ')\", \"abc def\"),\n+        test(\"normalize-space('abc def')\", \"abc def\"),\n+        test(\"normalize-space('   ')\", \"\"),\n+        test(\"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\"),\n+        test(\"boolean(1)\", Boolean.TRUE),\n+        test(\"boolean(0)\", Boolean.FALSE),\n+        test(\"boolean('x')\", Boolean.TRUE),\n+        test(\"boolean('')\", Boolean.FALSE),\n+        test(\"boolean(boolean)\", Boolean.FALSE),\n+        test(\"boolean(integers[position() < 3])\", Boolean.TRUE),\n+        test(\"boolean(integers[position() > 4])\", Boolean.FALSE),\n+        test(\"true()\", Boolean.TRUE),\n+        test(\"false()\", Boolean.FALSE),\n+        test(\"not(false())\", Boolean.TRUE),\n+        test(\"not(true())\", Boolean.FALSE),\n+        test(\"number('1')\", new Double(1)),\n+        test(\"sum(integers)\", new Double(10)),\n+        test(\"floor(1.5)\", new Double(1)),\n+        test(\"floor(-1.5)\", new Double(-2)),\n+        test(\"ceiling(1.5)\", new Double(2)),\n+        test(\"ceiling(-1.5)\", new Double(-1)),\n+        test(\"round(1.5)\", new Double(2)),\n+        test(\"round(-1.5)\", new Double(-1)),\n+\n+        // Extension functions\n+        test(\"string(test:new())\", \"foo=0; bar=null\"),\n+        test(\"string(jxpathtest:TestFunctions.new())\", \"foo=0; bar=null\"),\n+        test(\"string(\" + TestFunctions.class.getName() + \".new())\", \"foo=0; bar=null\"),\n+        test(\"string(test:new(3, 'baz'))\", \"foo=3; bar=baz\"),\n+        test(\"string(test:new('3', 4))\", \"foo=3; bar=4.0\"),\n+        test(\"string(test:getFoo($test))\", \"4.0\"),\n+        test(\"string(call:getFoo($test))\", \"4.0\"),\n+        test(\"string(getFoo($test))\", \"4.0\"),\n+        test(\"string(test:setFooAndBar($test, 7, 'biz'))\", \"foo=7; bar=biz\"),\n+        test(\"string(test:build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(jxpathtest:TestFunctions.build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(\" + TestFunctions.class.getName() + \".build(8, 'goober'))\", \"foo=8; bar=goober\"),\n+        test(\"string(test:increment(8))\", \"9.0\"),\n+        test(\"length('foo')\", new Integer(3)),\n+        test(\"call:substring('foo', 1, 2)\", \"o\"),\n+\n+\n+        // null\n+        testPath(\"$testnull/nothing\", \"$testnull/nothing\"),\n+        testEval(\"$testnull/nothing[1]\", Collections.EMPTY_LIST),\n+    };\n+\n+    private static List list(Object o1){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        return list;\n+    }\n+\n+    private static List list(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6, Object o7){\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        list.add(o5);\n+        list.add(o6);\n+        list.add(o7);\n+        return list;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/NestedTestBean.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/NestedTestBean.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import org.w3c.dom.*;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.*;\n+\n+/**\n+ * A general purpose JavaBean for JUnit tests for the \"jxpath\" component.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+public class NestedTestBean {\n+    private String name = \"Name 0\";\n+\n+    public NestedTestBean(){\n+    }\n+\n+    public NestedTestBean(String name){\n+        this.name = name;\n+    }\n+\n+    /**\n+     * A read-only boolean property\n+     */\n+    public boolean isBoolean(){\n+        return false;\n+    }\n+\n+    /**\n+     * A read-only int property\n+     */\n+    public int getInt(){\n+        return 1;\n+    }\n+\n+    /**\n+     * A read-only String property\n+     */\n+    public String getName(){\n+        return name;\n+    }\n+\n+    private String[] strings = new String[]{\"String 1\", \"String 2\", \"String 3\"};\n+\n+    public String[] getStrings(){\n+        return strings;\n+    }\n+\n+    public String toString(){\n+        return \"Nested: \" + name;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestBean.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * General purpose test bean for JUnit tests for the \"jxpath\" component.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+public class TestBean {\n+\n+    // ------------------------------------------------------------- Properties\n+\n+\n+    /**\n+     * An array of nested java beans.\n+     */\n+    private NestedTestBean[] beans;\n+    public NestedTestBean[] getBeans(){\n+        if (beans == null){\n+            beans = new NestedTestBean[2];\n+            beans[0] = new NestedTestBean(\"Name 1\");\n+            beans[1] = new NestedTestBean(\"Name 2\");\n+        }\n+        return beans;\n+    }\n+\n+    /**\n+     * A boolean property.\n+     */\n+    private boolean bool = false;\n+    public boolean getBoolean(){\n+        return bool;\n+    }\n+\n+    public void setBoolean(boolean bool){\n+        this.bool = bool;\n+    }\n+\n+    private int integer = 1;\n+    /**\n+     * A read-only integer property\n+     */\n+    public int getInt(){\n+        return integer;\n+    }\n+\n+    public void setInt(int integer){\n+        this.integer = integer;\n+    }\n+\n+    /**\n+     * A read-only array of integers\n+     */\n+    private int[] array = {1, 2, 3, 4};\n+    public int[] getIntegers(){\n+        return array;\n+    }\n+\n+    public int getIntegers(int index){\n+        return array[index];\n+    }\n+\n+    public void setIntegers(int index, int value){\n+        array[index] = value;\n+    }\n+\n+    /**\n+     * A heterogeneous list: String, Integer, NestedTestBean\n+     */\n+    private ArrayList list;\n+    public List getList(){\n+        if (list == null){\n+            list = new ArrayList();\n+            list.add(\"String 3\");\n+            list.add(new Integer(3));\n+            list.add(new NestedTestBean(\"Name 3\"));\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * A Map\n+     */\n+    private HashMap map;\n+    public Map getMap(){\n+        if (map == null){\n+            map = new HashMap();\n+            map.put(\"Key1\", \"Value 1\");\n+            map.put(\"Key2\", new NestedTestBean(\"Name 6\"));\n+//            map.put(\"Key3\", null);\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * A nested read-only java bean\n+     */\n+    private NestedTestBean nestedBean = new NestedTestBean(\"Name 0\");\n+    public NestedTestBean getNestedBean(){\n+        return nestedBean;\n+    }\n+\n+    private NestedTestBean object = new NestedTestBean(\"Name 5\");\n+\n+    /**\n+     * Returns a NestedTestBean: testing recognition of generic objects\n+     */\n+    public Object getObject(){\n+        return object;\n+    }\n+\n+    /**\n+     * Returns an array of ints: testing recognition of generic objects\n+     */\n+    public Object getObjects(){\n+        return getIntegers();\n+    }\n+\n+    /**\n+     * A heterogeneous set: String, Integer, NestedTestBean\n+     */\n+    private HashSet set;\n+    public Set getSet(){\n+        if (set == null){\n+            set = new HashSet();\n+            set.add(\"String 4\");\n+            set.add(new Integer(4));\n+            set.add(new NestedTestBean(\"Name 4\"));\n+        }\n+        return set;\n+    }\n+\n+    public String toString(){\n+        return \"ROOT\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestFunctions.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFunctions.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+public class TestFunctions {\n+\n+    private int foo;\n+    private String bar;\n+\n+    public TestFunctions(){\n+    }\n+\n+    public TestFunctions(int foo, String bar){\n+        this.foo = foo;\n+        this.bar = bar;\n+    }\n+\n+    public int getFoo(){\n+        return foo;\n+    }\n+\n+    public String getBar(){\n+        return bar;\n+    }\n+\n+    public void doit(){\n+    }\n+\n+    public TestFunctions setFooAndBar(int foo, String bar){\n+        this.foo = foo;\n+        this.bar = bar;\n+        return this;\n+    }\n+\n+    public static TestFunctions build(int foo, String bar){\n+        return new TestFunctions(foo, bar);\n+    }\n+\n+    public String toString(){\n+        return \"foo=\" + foo + \"; bar=\" + bar;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestFunctions2.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFunctions2.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+public class TestFunctions2 {\n+\n+    public static int increment(int i){\n+        return i + 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestNull.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestNull.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/08/23 00:47:02 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * General purpose test bean for JUnit tests for the \"jxpath\" component.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ */\n+public class TestNull {\n+\n+    private Object nothing = null;\n+    public Object getNothing(){\n+        return nothing;\n+    }\n+\n+    public void setNothing(Object something){\n+        this.nothing = something;\n+    }\n+\n+    /**\n+     */\n+    private static String[] array = {\"a\", null, \"b\"};\n+    public String[] getArray(){\n+        return array;\n+    }\n+\n+    private TestNull child;\n+\n+    public TestNull getChild(){\n+        if (child == null){\n+            child = new TestNull();\n+        }\n+        return child;\n+    }\n+}", "timestamp": 998527622, "metainfo": ""}