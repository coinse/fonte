{"sha": "4ab5b9e453d0e0ef51fc1d36a5e21aaf21b44c81", "log": "Improved handling of collections as arguments of extension functions   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/NodeSet.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.List;\n+\n+/**\n+ * NodeSet interface can be used as the type of an argument of an extension\n+ * function.  Alternatively, the function can declare the argument as\n+ * a Collection (or List or Set), in which case it will be given a collection\n+ * of <i>values</i> matching the path.\n+ * \n+ * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n+ * @version $Id: NodeSet.java,v 1.1 2003/02/07 00:51:40 dmitri Exp $\n+ */\n+public interface NodeSet {\n+\n+    /**\n+     * Returns a list of nodes.\n+     */\n+    List getNodes();\n+    \n+    /**\n+     * Returns a list of pointers for all nodes in the set.\n+     */\n+    List getPointers();\n+    \n+    /**\n+     * Returns a list of values of all contained pointers.\n+     */\n+    List getValues();\n+    \n+}\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.8 2003/01/29 17:55:00 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2003/01/29 17:55:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.9 2003/02/07 00:51:40 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/02/07 00:51:40 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n-import java.util.*;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.Set;\n \n import org.apache.commons.jxpath.functions.ConstructorFunction;\n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2003/01/29 17:55:00 $\n+ * @version $Revision: 1.9 $ $Date: 2003/02/07 00:51:40 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n         if (parameters.length >= 1) {\n             Object target = parameters[0];\n             if (target != null) {\n+                Method method =\n+                    MethodLookupUtils.lookupMethod(\n+                        target.getClass(),\n+                        name,\n+                        parameters);\n+                if (method != null) {\n+                    return new MethodFunction(method);\n+                }\n+                    \n+                if (target instanceof NodeSet) {\n+                    target = ((NodeSet) target).getPointers();\n+                }\n+                \n+                method =\n+                    MethodLookupUtils.lookupMethod(\n+                        target.getClass(),\n+                        name,\n+                        parameters);\n+                if (method != null) {\n+                    return new MethodFunction(method);\n+                }\n+                \n                 if (target instanceof Collection) {\n                     Iterator iter = ((Collection) target).iterator();\n                     if (iter.hasNext()) {\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.8 2003/02/07 00:51:41 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/02/07 00:51:41 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.functions;\n \n import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Function;\n  * An extension function that creates an instance using a constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.8 $ $Date: 2003/02/07 00:51:41 $\n  */\n public class ConstructorFunction implements Function {\n \n             }\n             return constructor.newInstance(args);\n         }\n-        catch (Exception exception) {\n+        catch (Throwable ex) {\n+            if (ex instanceof InvocationTargetException) {\n+                ex = ((InvocationTargetException) ex).getTargetException();\n+            }\n             throw new JXPathException(\n                 \"Cannot invoke constructor \" + constructor,\n-                exception);\n+                ex);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.8 2003/02/07 00:51:41 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/02/07 00:51:41 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.functions;\n \n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n \n import org.apache.commons.jxpath.Function;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.util.TypeUtils;\n+import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * An XPath extension function implemented as an individual Java method.\n  * \n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.8 $ $Date: 2003/02/07 00:51:41 $\n  */\n public class MethodFunction implements Function {\n \n     private static final Object EMPTY_ARRAY[] = new Object[0];\n \n     public MethodFunction(Method method) {\n-        this.method = method;\n+        this.method = ValueUtils.getAccessibleMethod(method);\n     }\n \n     public Object invoke(ExpressionContext context, Object[] parameters) {\n \n             return method.invoke(target, args);\n         }\n-        catch (Exception exception) {\n-            throw new JXPathException(\"Cannot invoke \" + method, exception);\n+        catch (Throwable ex) {\n+            if (ex instanceof InvocationTargetException) {\n+                ex = ((InvocationTargetException) ex).getTargetException();\n+            }\n+            throw new JXPathException(\"Cannot invoke \" + method, ex);\n         }\n     }\n+    \n+    public String toString() {\n+        return method.toString();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.21 2003/01/29 17:55:00 dmitri Exp $\n- * $Revision: 1.21 $\n- * $Date: 2003/01/29 17:55:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.22 2003/02/07 00:51:41 dmitri Exp $\n+ * $Revision: 1.22 $\n+ * $Date: 2003/02/07 00:51:41 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.List;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.axes.RootContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.21 $ $Date: 2003/01/29 17:55:00 $\n+ * @version $Revision: 1.22 $ $Date: 2003/02/07 00:51:41 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n      * of the parent contexts.  If there was an ongoing iteration over\n      * this context, the method should not be called.\n      */\n-    public List getPointerList() {\n+    public NodeSet getNodeSet() {\n         if (position != 0) {\n             throw new JXPathException(\n                 \"Simultaneous operations: \"\n                     + \"iterating over an EvalContext\");\n         }\n         \n-        List list = new ArrayList();\n-        while (nextSet()) {\n-            while (nextNode()) {\n-                list.add(getCurrentNodePointer());\n-            }\n-        }\n-        return list;\n+        return new SimpleNodeSet();\n     }\n \n     public String toString() {\n         this.position = position;\n         return true;\n     }\n+    \n+    class SimpleNodeSet implements NodeSet {\n+        private List pointers;\n+        private List nodes;\n+        private List values;\n+\n+        public SimpleNodeSet() {\n+            pointers = new ArrayList();\n+            while (nextSet()) {\n+                while (nextNode()) {\n+                    pointers.add(getCurrentNodePointer());\n+                }\n+            }\n+        }\n+\n+        public List getPointers() {\n+            return Collections.unmodifiableList(pointers);\n+        }\n+\n+        public List getNodes() {\n+            if (nodes == null) {\n+                List pointers = getPointers();\n+                nodes = new ArrayList();\n+                for (int i = 0; i < pointers.size(); i++) {\n+                    Pointer pointer = (Pointer) pointers.get(i);\n+                    nodes.add(pointer.getValue());\n+                }\n+                nodes = Collections.unmodifiableList(nodes);\n+            }\n+            return nodes;\n+        }\n+\n+        public List getValues() {\n+            if (values == null) {\n+                List pointers = getPointers();\n+                values = new ArrayList();\n+                for (int i = 0; i < pointers.size(); i++) {\n+                    Pointer pointer = (Pointer) pointers.get(i);\n+                    values.add(pointer.getValue());\n+                }\n+                values = Collections.unmodifiableList(values);\n+            }\n+            return values;\n+        }\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.8 2003/01/29 17:55:00 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2003/01/29 17:55:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.9 2003/02/07 00:51:41 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/02/07 00:51:41 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import java.util.Arrays;\n+\n import org.apache.commons.jxpath.Function;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.EvalContext;\n-\n-import java.util.Arrays;\n-import java.util.List;\n \n /**\n  * Represents  an element of the parse tree representing an extension function\n  * call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2003/01/29 17:55:00 $\n+ * @version $Revision: 1.9 $ $Date: 2003/02/07 00:51:41 $\n  */\n public class ExtensionFunction extends Operation {\n \n                 parameters[i] = convert(args[i].compute(context));\n             }\n         }\n+\n         Function function =\n             context.getRootContext().getFunction(functionName, parameters);\n         if (function == null) {\n     \n     private Object convert(Object object) {\n         if (object instanceof EvalContext) {\n-            return ((EvalContext) object).getPointerList();\n+            return ((EvalContext) object).getNodeSet();\n         }\n         return object;\n-    }\n-    \n-    \n+    }  \n }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.4 2003/01/29 17:55:01 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/29 17:55:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.5 2003/02/07 00:51:40 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/02/07 00:51:40 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Modifier;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.NodeSet;\n \n /**\n  * The default implementation of TypeConverter.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/29 17:55:01 $\n+ * @version $Revision: 1.5 $ $Date: 2003/02/07 00:51:40 $\n  */\n public class BasicTypeConverter implements TypeConverter {\n \n                 return canConvert(value, toType);\n             }\n         }\n+        else if (object instanceof NodeSet) {\n+            return canConvert(((NodeSet) object).getValues(), toType);\n+        }\n         else if (object instanceof Pointer) {\n             return canConvert(((Pointer) object).getValue(), toType);\n         }\n                 for (int i = 0; i < length; i++) {\n                     collection.add(Array.get(object, i));\n                 }\n-                return collection;\n+                return unmodifiableCollection(collection);\n             }\n             else if (length == 1) {\n                 Object value = Array.get(object, 0);\n             else if (Collection.class.isAssignableFrom(toType)) {\n                 Collection collection = allocateCollection(toType);\n                 collection.addAll((Collection) object);\n-                return collection;\n+                return unmodifiableCollection(collection);\n             }\n             else if (length == 1) {\n                 Object value;\n                         + \" elements\");\n             }\n         }\n+        else if (object instanceof NodeSet) {\n+            return convert(((NodeSet) object).getValues(), toType);\n+        }\n         else if (object instanceof Pointer) {\n             return convert(((Pointer) object).getValue(), toType);\n         }\n         }\n         throw new RuntimeException(\"Cannot create collection of type: \" + type);\n     }\n+    \n+    private Collection unmodifiableCollection(Collection collection) {\n+        if (collection instanceof List) {\n+            return Collections.unmodifiableList((List) collection);\n+        }\n+        else if (collection instanceof Set) {\n+            return Collections.unmodifiableSet((Set) collection);\n+        }\n+        // Cannot wrap it into a proper unmodifiable collection, \n+        // so we just return the original collection itself\n+        return collection;\n+    }\n+    \n+    static class ValueNodeSet implements NodeSet {\n+        private List values;\n+        private List pointers;\n+\n+        public ValueNodeSet(List values) {\n+           this.values = values;\n+        }\n+        \n+        public List getValues() {\n+            return Collections.unmodifiableList(values);\n+        }\n+        \n+        public List getNodes() {\n+            return Collections.unmodifiableList(values);\n+        }\n+        \n+        public List getPointers() {\n+            if (pointers == null) {\n+                pointers = new ArrayList();\n+                for (int i = 0; i < values.size(); i++) {\n+                    pointers.add(new ValuePointer(values.get(i)));\n+                }\n+                pointers = Collections.unmodifiableList(pointers);\n+            }\n+            return pointers;\n+        }\n+    }\n+    \n+    static final class ValuePointer implements Pointer {\n+        private Object bean;\n+\n+        public ValuePointer(Object object) {\n+            this.bean = object;\n+        }\n+        \n+        public Object getValue() {\n+            return bean;\n+        }\n+        \n+        public Object getNode() {\n+            return bean;\n+        }\n+        public void setValue(Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public String asPath() {\n+            if (bean == null) {\n+                return \"null()\";\n+            }\n+            else if (bean instanceof Number) {\n+                String string = bean.toString();\n+                if (string.endsWith(\".0\")) {\n+                    string = string.substring(0, string.length() - 2);\n+                }\n+                return string;\n+            }\n+            else if (bean instanceof Boolean) {\n+                return ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n+            }\n+            else if (bean instanceof String) {\n+                return \"'\" + bean + \"'\";\n+            }\n+            return \"{object of type \" + bean.getClass().getName() + \"}\";\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.13 2003/01/17 02:02:57 dmitri Exp $\n- * $Revision: 1.13 $\n- * $Date: 2003/01/17 02:02:57 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.14 2003/02/07 00:51:40 dmitri Exp $\n+ * $Revision: 1.14 $\n+ * $Date: 2003/02/07 00:51:40 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Collection and property access utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.13 $ $Date: 2003/01/17 02:02:57 $\n+ * @version $Revision: 1.14 $ $Date: 2003/02/07 00:51:40 $\n  */\n public class ValueUtils {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n      *\n      * @param method The method that we wish to call\n      */\n-    private static Method getAccessibleMethod(Method method) {\n+    public static Method getAccessibleMethod(Method method) {\n \n         // Make sure we have a method to check\n         if (method == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.5 2003/01/29 17:55:00 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/01/29 17:55:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.6 2003/02/07 00:51:40 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/02/07 00:51:40 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.compiler;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Locale;\n \n  * Test extension functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2003/01/29 17:55:00 $\n+ * @version $Revision: 1.6 $ $Date: 2003/02/07 00:51:40 $\n  */\n \n public class ExtensionFunctionTest extends JXPathTestCase {\n             \"string(test:setFooAndBar($test, 7, 'biz'))\",\n             \"foo=7; bar=biz\");\n     }\n+    \n+    public void testCollectionMethodCall() {\n+        \n+        List list = new ArrayList();\n+        list.add(\"foo\");\n+        context.getVariables().declareVariable(\"myList\", list);\n+\n+        assertXPathValue(\n+            context, \n+            \"size($myList)\", \n+            new Integer(1));\n+    \n+        assertXPathValue(\n+            context, \n+            \"size(beans)\", \n+            new Integer(2));\n+            \n+        boolean exception = false;\n+        try {\n+            assertXPathValue(context, \"add($myList, 'hello')\", Boolean.TRUE);\n+        }\n+        catch (Exception ex) {\n+            exception = true;\n+        }\n+        assertTrue(\n+            \"Exception trying to add to an unmodifiable list\",\n+            exception);\n+    }\n \n     public void testStaticMethodCall() {\n \n             \"//.[test:isMap()]/Key1\", \n             \"Value 1\");\n \n-        // The function uses ExpressionContext to get to all\n-        // nodes in the context that is passed to it.\n+        // The function gets all\n+        // nodes in the context that match the pattern.\n         assertXPathValue(\n             context,\n             \"count(//.[test:count(strings) = 3])\",\n             new Double(7));\n \n-        // Another example of the same            \n+        // The function receives a collection of strings\n+        // and checks their type for testing purposes            \n         assertXPathValue(\n             context,\n             \"test:count(//strings)\",\n             new Integer(21));\n \n+        \n+        // The function receives a collection of pointers\n+        // and checks their type for testing purposes            \n+        assertXPathValue(\n+            context,\n+            \"test:countPointers(//strings)\",\n+            new Integer(21));\n+            \n         // The function uses ExpressionContext to get to the current\n         // pointer and returns its path.\n         assertXPathValue(\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.3 2003/01/20 00:00:27 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/01/20 00:00:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.4 2003/02/07 00:51:40 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/02/07 00:51:40 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Map;\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.NodeSet;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/02/07 00:51:40 $\n  */\n public class TestFunctions {\n \n      * the first argument.\n      */\n     public static int count(ExpressionContext context, Collection col) {\n+        for (Iterator iter = col.iterator(); iter.hasNext();) {\n+            Object element = iter.next();\n+            if (!(element instanceof String)) {\n+                throw new RuntimeException(\"Invalid argument\");\n+            }\n+        };\n         return col.size();\n     }\n+    \n+    public static int countPointers(NodeSet nodeSet) {\n+        return nodeSet.getPointers().size();\n+    }\n }", "timestamp": 1044579101, "metainfo": ""}