{"sha": "348acabaadc57e04f25de5c79c72bc34a4e41723", "log": "Fixed type conversion issues with extension functions   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.8 2003/01/29 17:55:00 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/29 17:55:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Set;\n \n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/29 17:55:00 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n         if (parameters.length >= 1) {\n             Object target = parameters[0];\n             if (target != null) {\n-                if (target instanceof ExpressionContext) {\n-                    Pointer pointer =\n-                        ((ExpressionContext) target).getContextNodePointer();\n-                    if (pointer != null) {\n-                        target = pointer.getValue();\n+                if (target instanceof Collection) {\n+                    Iterator iter = ((Collection) target).iterator();\n+                    if (iter.hasNext()) {\n+                        target = iter.next();\n+                        if (target instanceof Pointer) {\n+                            target = ((Pointer) target).getValue();\n+                        }\n                     }\n                     else {\n                         target = null;\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.20 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.20 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.21 2003/01/29 17:55:00 dmitri Exp $\n+ * $Revision: 1.21 $\n+ * $Date: 2003/01/29 17:55:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.List;\n import java.util.NoSuchElementException;\n \n+import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.Pointer;\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.20 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.21 $ $Date: 2003/01/29 17:55:00 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n \n     /**\n      * Returns the list of all Pointers in this context for all positions\n-     * of the parent contexts.\n+     * of the parent contexts.  If there was an ongoing iteration over\n+     * this context, the method should not be called.\n      */\n     public List getPointerList() {\n-        int pos = position;\n-        if (pos != 0) {\n-            reset();\n-        }\n+        if (position != 0) {\n+            throw new JXPathException(\n+                \"Simultaneous operations: \"\n+                    + \"should not request pointer list while \"\n+                    + \"iterating over an EvalContext\");\n+        }\n+        \n         List list = new ArrayList();\n         while (nextSet()) {\n             while (nextNode()) {\n                 list.add(getCurrentNodePointer());\n             }\n-        }\n-        if (pos != 0) {\n-            setPosition(pos);\n-        }\n-        else {\n-            reset();\n         }\n         return list;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.7 2003/01/19 23:59:24 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/19 23:59:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.8 2003/01/29 17:55:00 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/29 17:55:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.Function;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.EvalContext;\n \n import java.util.Arrays;\n+import java.util.List;\n \n /**\n  * Represents  an element of the parse tree representing an extension function\n  * call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/19 23:59:24 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/29 17:55:00 $\n  */\n public class ExtensionFunction extends Operation {\n \n         if (args != null) {\n             parameters = new Object[args.length];\n             for (int i = 0; i < args.length; i++) {\n-                Object param = args[i].compute(context);\n-                parameters[i] = param;\n+                parameters[i] = convert(args[i].compute(context));\n             }\n         }\n         Function function =\n \n         return function.invoke(context, parameters);\n     }\n+    \n+    private Object convert(Object object) {\n+        if (object instanceof EvalContext) {\n+            return ((EvalContext) object).getPointerList();\n+        }\n+        return object;\n+    }\n+    \n+    \n }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.4 2003/01/29 17:55:01 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/29 17:55:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Vector;\n-\n-import org.apache.commons.jxpath.ExpressionContext;\n+import java.util.*;\n+\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.Pointer;\n \n  * The default implementation of TypeConverter.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/29 17:55:01 $\n  */\n public class BasicTypeConverter implements TypeConverter {\n \n                 || toType == Float.class\n                 || toType == Double.class) {\n                 return true;\n-            }\n-        }\n-        else if (object instanceof ExpressionContext) {\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                return true;\n-            }\n-            Pointer pointer =\n-                ((ExpressionContext) object).getContextNodePointer();\n-            if (pointer != null) {\n-                Object value = pointer.getValue();\n-                return canConvert(value, toType);\n             }\n         }\n         else if (fromType.isArray()) {\n                 return canConvert(value, toType);\n             }\n         }\n+        else if (object instanceof Pointer) {\n+            return canConvert(((Pointer) object).getValue(), toType);\n+        }\n         return false;\n     }\n     /**\n             return object;\n         }\n \n-        if (object instanceof ExpressionContext) {\n-            if (Collection.class.isAssignableFrom(toType)) {\n-                List list = ((ExpressionContext) object).getContextNodeList();\n-                Collection result = new ArrayList();\n-                if (toType == List.class || toType == ArrayList.class) {\n-                    result = new ArrayList();\n-                }\n-                else if (toType == Vector.class) {\n-                    result = new Vector();\n-                }\n-                else if (toType == Set.class || toType == HashSet.class) {\n-                    result = new HashSet();\n-                }\n-                int count = list.size();\n-                for (int i = 0; i < count; i++) {\n-                    Pointer ptr = (Pointer) list.get(i);\n-                    result.add(ptr.getValue());\n-                }\n-                return result;\n-            }\n-            else {\n-                Object value =\n-                    ((ExpressionContext) object)\n-                        .getContextNodePointer()\n-                        .getValue();\n-                return convert(value, toType);\n-            }\n-        }\n-\n         Class fromType = object.getClass();\n         if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n             return object;\n                 }\n                 return convert(value, toType);\n             }\n-        }\n+            else {\n+                throw new RuntimeException(\n+                    \"Cannot convert collection to \"\n+                        + toType\n+                        + \", it contains \"\n+                        + length\n+                        + \" elements\");\n+            }\n+        }\n+        else if (object instanceof Pointer) {\n+            return convert(((Pointer) object).getValue(), toType);\n+        }\n+        \n         throw new RuntimeException(\n             \"Cannot convert \" + object.getClass() + \" to \" + toType);\n     }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.4 2003/01/20 00:00:27 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/20 00:00:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.5 2003/01/29 17:55:00 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/29 17:55:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test extension functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/20 00:00:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/29 17:55:00 $\n  */\n \n public class ExtensionFunctionTest extends JXPathTestCase {\n \n         // Invoke a function implemented as a regular method\n         assertXPathValue(context, \"string(test:getFoo($test))\", \"4\");\n-\n+        \n         // Note that the prefix is ignored anyway, we are just calling a method\n         assertXPathValue(context, \"string(call:getFoo($test))\", \"4\");\n \n         // Execute an extension function for each node while searching\n         // The function uses ExpressionContext to get to the current\n         // node.\n-        assertXPathValue(context, \"//.[test:isMap()]/Key1\", \"Value 1\");\n+        assertXPathValue(\n+            context, \n+            \"//.[test:isMap()]/Key1\", \n+            \"Value 1\");\n \n         // The function uses ExpressionContext to get to all\n         // nodes in the context that is passed to it.\n             context,\n             \"count(//.[test:count(strings) = 3])\",\n             new Double(7));\n+\n+        // Another example of the same            \n+        assertXPathValue(\n+            context,\n+            \"test:count(//strings)\",\n+            new Integer(21));\n \n         // The function uses ExpressionContext to get to the current\n         // pointer and returns its path.", "timestamp": 1043862901, "metainfo": ""}