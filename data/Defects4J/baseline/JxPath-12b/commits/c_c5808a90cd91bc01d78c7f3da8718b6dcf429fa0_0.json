{"sha": "c5808a90cd91bc01d78c7f3da8718b6dcf429fa0", "log": "Introduced specialized exceptions  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathException.java\n  */\n \n public class JXPathException extends RuntimeException {\n-\n+    private static final long serialVersionUID = 4306409701468017766L;\n+    \n     /** @serial */\n     private Throwable exception;\n \n     public Throwable getException() {\n         return exception;\n     }\n+\n+    /**\n+     * Same as {@link #getException() getException()}\n+     */\n+    public Throwable getCause() {\n+        return exception;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Function;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n             if (ex instanceof InvocationTargetException) {\n                 ex = ((InvocationTargetException) ex).getTargetException();\n             }\n-            throw new JXPathException(\n+            throw new JXPathInvalidAccessException(\n                 \"Cannot invoke constructor \" + constructor,\n                 ex);\n         }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Function;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.util.TypeUtils;\n import org.apache.commons.jxpath.util.ValueUtils;\n \n             if (ex instanceof InvocationTargetException) {\n                 ex = ((InvocationTargetException) ex).getTargetException();\n             }\n-            throw new JXPathException(\"Cannot invoke \" + method, ex);\n+            throw new JXPathInvalidAccessException(\"Cannot invoke \" + method,\n+                    ex);\n         }\n     }\n     \n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n import org.apache.commons.jxpath.Functions;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathFunctionNotFoundException;\n+import org.apache.commons.jxpath.JXPathInvalidSyntaxException;\n+import org.apache.commons.jxpath.JXPathNotFoundException;\n+import org.apache.commons.jxpath.JXPathTypeConversionException;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.Variables;\n import org.apache.commons.jxpath.ri.axes.InitialContext;\n         if (result == null) {\n             if (expr instanceof Path) {\n                 if (!isLenient()) {\n-                    throw new JXPathException(\"No value for xpath: \" + xpath);\n+                    throw new JXPathNotFoundException(\"No value for xpath: \"\n+                            + xpath);\n                 }\n             }\n             return null;\n             EvalContext ctx = (EvalContext) result;\n             result = ctx.getSingleNodePointer();\n             if (!isLenient() && result == null) {\n-                throw new JXPathException(\"No value for xpath: \" + xpath);\n+                throw new JXPathNotFoundException(\"No value for xpath: \"\n+                        + xpath);\n             }\n         }\n         if (result instanceof NodePointer) {\n                 if (parent == null\n                     || !parent.isContainer()\n                     || !parent.isActual()) {\n-                    throw new JXPathException(\"No value for xpath: \" + xpath);\n+                    throw new JXPathNotFoundException(\"No value for xpath: \"\n+                            + xpath);\n                 }\n             }\n             result = ((NodePointer) result).getValue();\n         Object value = getValue(xpath, expr);\n         if (value != null && requiredType != null) {\n             if (!TypeUtils.canConvert(value, requiredType)) {\n-                throw new JXPathException(\n+                throw new JXPathTypeConversionException(\n                     \"Invalid expression type. '\"\n                         + xpath\n                         + \"' returns \"\n         }\n         if (result instanceof Pointer) {\n             if (!isLenient() && !((NodePointer) result).isActual()) {\n-                throw new JXPathException(\"No pointer for xpath: \" + xpath);\n+                throw new JXPathNotFoundException(\"No pointer for xpath: \"\n+                        + xpath);\n             }\n             return (Pointer) result;\n         }\n     private void checkSimplePath(Expression expr) {\n         if (!(expr instanceof LocationPath)\n             || !((LocationPath) expr).isSimplePath()) {\n-            throw new JXPathException(\n+            throw new JXPathInvalidSyntaxException(\n                 \"JXPath can only create a path if it uses exclusively \"\n                     + \"the child:: and attribute:: axes and has \"\n                     + \"no context-dependent predicates\");\n             }\n             funcCtx = funcCtx.getParentContext();\n         }\n-        throw new JXPathException(\n+        throw new JXPathFunctionNotFoundException(\n             \"Undefined function: \" + functionName.toString());\n     }\n     \n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n \n import java.io.StringReader;\n \n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidSyntaxException;\n import org.apache.commons.jxpath.ri.parser.ParseException;\n import org.apache.commons.jxpath.ri.parser.TokenMgrError;\n import org.apache.commons.jxpath.ri.parser.XPathParser;\n                 expr = parser.parseExpression();\n             }\n             catch (TokenMgrError e) {\n-                throw new JXPathException(\n+                throw new JXPathInvalidSyntaxException(\n                     \"Invalid XPath: '\"\n                         + addEscapes(expression)\n                         + \"'. Invalid symbol '\"\n                         + describePosition(expression, e.getPosition()));\n             }\n             catch (ParseException e) {\n-                throw new JXPathException(\n+                throw new JXPathInvalidSyntaxException(\n                     \"Invalid XPath: '\"\n                         + addEscapes(expression)\n                         + \"'. Syntax error \"\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n             value = ((NodePointer) value).getValue();\n         }\n         if (value == null) {\n-            throw new JXPathException(\"Predicate value is null\");\n+            throw new JXPathException(\"Predicate value is null: \" + predicate);\n         }\n \n         if (value instanceof Number) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n \n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidSyntaxException;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n     private void assertArgCount(int count) {\n         if (getArgumentCount() != count) {\n-            throw new JXPathException(\"Incorrect number of argument: \" + this);\n+            throw new JXPathInvalidSyntaxException(\n+                    \"Incorrect number of argument: \" + this);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n import java.util.Arrays;\n \n import org.apache.commons.jxpath.Function;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathFunctionNotFoundException;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.QName;\n \n         Function function =\n             context.getRootContext().getFunction(functionName, parameters);\n         if (function == null) {\n-            throw new JXPathException(\n-                \"No such function: \"\n-                    + functionName\n-                    + Arrays.asList(parameters));\n+            throw new JXPathFunctionNotFoundException(\"No such function: \"\n+                    + functionName + Arrays.asList(parameters));\n         }\n \n         return function.invoke(context, parameters);\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n         int index,\n         Object value) \n     {\n-        throw new JXPathException(\n-            \"Cannot create an object for path \"\n-                + asPath()\n-                + \"/\"\n-                + name\n-                + \"[\"\n-                + (index + 1)\n-                + \"]\"\n+        throw new JXPathException(\"Cannot create an object for path \"\n+                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n \n     /**\n-     * Called by a child pointer when it needs to create a parent object\n-     * for a non-existent collection element.  It may have to expand the\n-     * collection, then create an element object and return a new pointer\n-     * describing the newly created element.\n-     */\n-    public NodePointer createChild(\n-        JXPathContext context,\n-        QName name,\n-        int index) \n+     * Called by a child pointer when it needs to create a parent object for a\n+     * non-existent collection element. It may have to expand the collection,\n+     * then create an element object and return a new pointer describing the\n+     * newly created element.\n+     */\n+    public NodePointer createChild(JXPathContext context, QName name, int index)\n     {\n-        throw new JXPathException(\n-            \"Cannot create an object for path \"\n-                + asPath()\n-                + \"/\"\n-                + name\n-                + \"[\"\n-                + (index + 1)\n-                + \"]\"\n+        throw new JXPathException(\"Cannot create an object for path \"\n+                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n     \n      * Called to create a non-existing attribute\n      */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n-        throw new JXPathException(\n-            \"Cannot create an attribute for path \"\n+        throw new JXPathException(\"Cannot create an attribute for path \"\n                 + asPath() + \"/@\" + name\n                 + \", operation is not allowed for this type of node\");\n     }\n \n     /**\n-     * If the Pointer has a parent, returns the parent's locale;\n-     * otherwise returns the locale specified when this Pointer\n-     * was created.\n+     * If the Pointer has a parent, returns the parent's locale; otherwise\n+     * returns the locale specified when this Pointer was created.\n      */\n     public Locale getLocale() {\n         if (locale == null) {\n \n         if (depth1 == 1) {\n             throw new JXPathException(\n-                \"Cannot compare pointers that do not belong to the same tree: '\"\n-                    + p1\n-                    + \"' and '\"\n-                    + p2\n-                    + \"'\");\n+                    \"Cannot compare pointers that do not belong to the same tree: '\"\n+                            + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r =\n             compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n package org.apache.commons.jxpath.ri.model;\n \n import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.JXPathIntrospector;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.Variables;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n         if (!actual) {\n             AbstractFactory factory = getAbstractFactory(context);\n             if (!factory.declareVariable(context, name.toString())) {\n-                throw new JXPathException(\n-                    \"Factory cannot define variable '\"\n-                        + name\n-                        + \"' for path: \"\n-                        + asPath());\n+                throw new JXPathAbstractFactoryException(\n+                        \"Factory cannot define variable '\" + name\n+                                + \"' for path: \" + asPath());\n             }\n             findVariables(context);\n             // Assert: actual == true\n                     getName().toString(),\n                     index);\n             if (!success) {\n-                throw new JXPathException(\n-                    \"Factory could not create object path: \" + asPath());\n+                throw new JXPathAbstractFactoryException(\n+                        \"Factory could not create object path: \" + asPath());\n             }\n             NodePointer cln = (NodePointer) clone();\n             cln.setIndex(index);\n \n         Object collection = getBaseValue();\n         if (collection == null) {\n-            throw new JXPathException(\n+            throw new JXPathAbstractFactoryException(\n                 \"Factory did not assign a collection to variable '\"\n                     + name\n                     + \"' for path: \"\n             index = 0;\n         }\n         else if (index < 0) {\n-            throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            throw new JXPathInvalidAccessException(\"Index is less than 1: \"\n+                    + asPath());\n         }\n \n         if (index >= getLength()) {\n             }\n             else {\n                 if (index < 0) {\n-                    throw new JXPathException(\n+                    throw new JXPathInvalidAccessException(\n                         \"Index is less than 1: \" + asPath());\n                 }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n \n import org.apache.commons.jxpath.JXPathBeanInfo;\n import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n \n     public void setValue(Object value) {\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null) {\n-            throw new JXPathException(\n+            throw new JXPathInvalidAccessException(\n                 \"Cannot set property: \" + asPath() + \" - no such property\");\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n package org.apache.commons.jxpath.ri.model.beans;\n \n import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n \n     public void setValue(Object value) {\n         if (parent == null || parent.isContainer()) {\n-            throw new JXPathException(\n+            throw new JXPathInvalidAccessException(\n                 \"Cannot set property \"\n                     + asPath()\n                     + \", the target object is null\");\n             propertyPointer.setValue(value);\n         }\n         else {\n-            throw new JXPathException(\n+            throw new JXPathInvalidAccessException(\n                 \"Cannot set property \"\n                     + asPath()\n                     + \", path does not match a changeable location\");\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n \n import java.util.Locale;\n \n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n                         + \"some other object's property\");\n             }\n             else {\n-                throw new JXPathException(\n+                throw new JXPathInvalidAccessException(\n                     \"The specified collection element does not exist: \" + this);\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n package org.apache.commons.jxpath.ri.model.beans;\n \n import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.JXPathIntrospector;\n                     getPropertyName(),\n                     inx);\n             if (!success) {\n-                throw new JXPathException(\n-                    \"Factory \"\n-                        + factory\n-                        + \" could not create an object for path: \"\n-                        + asPath());\n+                throw new JXPathAbstractFactoryException(\"Factory \" + factory\n+                        + \" could not create an object for path: \" + asPath());\n             }\n         }\n         return this;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n import java.util.Map;\n \n import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.Pointer;\n                 return it.getNodePointer();\n             }\n         }\n-        throw new JXPathException(\n-            \"Factory could not create a child node for path: \"\n-                + asPath()\n-                + \"/\"\n-                + name\n-                + \"[\"\n-                + (index + 1)\n-                + \"]\");\n+        throw new JXPathAbstractFactoryException(\n+                \"Factory could not create a child node for path: \" + asPath()\n+                        + \"/\" + name + \"[\" + (index + 1) + \"]\");\n     }\n \n     public NodePointer createChild(JXPathContext context, \n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n import org.apache.commons.beanutils.DynaBean;\n import org.apache.commons.beanutils.DynaClass;\n import org.apache.commons.beanutils.DynaProperty;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathTypeConversionException;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n import org.apache.commons.jxpath.util.TypeUtils;\n             return TypeUtils.convert(value, type);\n         }\n         catch (Exception ex) {\n-            throw new JXPathException(\n-                \"Cannot convert value of class \"\n-                    + (value == null ? \"null\" : value.getClass().getName())\n-                    + \" to type \"\n-                    + type,\n-                ex);\n+            String string = value == null ? \"null\" : value.getClass().getName();\n+            throw new JXPathTypeConversionException(\n+                    \"Cannot convert value of class \" + string + \" to type \"\n+                            + type, ex);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n \n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.DynamicPropertyHandler;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n  * @version $Revision$ $Date$\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n+\n+    private static final long serialVersionUID = -5720585681149150822L;\n+    \n     private DynamicPropertyHandler handler;\n     private String name;\n     private String[] names;\n                     getPropertyName(),\n                     0);\n             if (!success) {\n-                throw new JXPathException(\n+                throw new JXPathAbstractFactoryException(\n                     \"Factory could not create an object for path: \" + asPath());\n             }\n             collection = getBaseValue();\n \n         if (index != WHOLE_COLLECTION) {\n             if (index < 0) {\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-    \n+                throw new JXPathInvalidAccessException(\"Index is less than 1: \"\n+                        + asPath());\n+            }\n+\n             if (index >= getLength()) {\n                 collection = ValueUtils.expandCollection(collection, index + 1);\n                 handler.setProperty(getBean(), getPropertyName(), collection);\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n import java.util.Locale;\n \n import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n                 return it.getNodePointer();\n             }\n         }\n-        throw new JXPathException(\n-            \"Factory could not create \"\n-                + \"a child node for path: \"\n-                + asPath()\n-                + \"/\"\n-                + name\n-                + \"[\"\n-                + (index + 1)\n-                + \"]\");\n+        throw new JXPathAbstractFactoryException(\"Factory could not create \"\n+                + \"a child node for path: \" + asPath() + \"/\" + name + \"[\"\n+                + (index + 1) + \"]\");\n     }\n \n     public NodePointer createChild(\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n \n import org.apache.commons.beanutils.ConvertUtils;\n import org.apache.commons.beanutils.Converter;\n-import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.JXPathInvalidAccessException;\n+import org.apache.commons.jxpath.JXPathTypeConversionException;\n import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.Pointer;\n \n             return converter.convert(toType, object);\n         }\n \n-        throw new RuntimeException(\n-            \"Cannot convert \" + object.getClass() + \" to \" + toType);\n+        throw new JXPathTypeConversionException(\"Cannot convert \"\n+                + object.getClass() + \" to \" + toType);\n     }\n \n     protected Object convertNullToPrimitive(Class toType) {\n                 return (Collection) type.newInstance();\n             }\n             catch (Exception ex) {\n-                throw new JXPathException(\n-                    \"Cannot create collection of type: \" + type,\n-                    ex);\n+                throw new JXPathInvalidAccessException(\n+                        \"Cannot create collection of type: \" + type, ex);\n             }\n         }\n \n         if (type == Set.class) {\n             return new HashSet();\n         }\n-        throw new RuntimeException(\"Cannot create collection of type: \" + type);\n+        throw new JXPathInvalidAccessException(\n+                \"Cannot create collection of type: \" + type);\n     }\n     \n     protected Collection unmodifiableCollection(Collection collection) {", "timestamp": 1130620039, "metainfo": ""}