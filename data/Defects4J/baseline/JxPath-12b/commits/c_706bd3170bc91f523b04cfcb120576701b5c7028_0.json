{"sha": "706bd3170bc91f523b04cfcb120576701b5c7028", "log": "Added createPath without value, renamed createPath to createPathAndSetValue, added removePath   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/CompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/CompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/CompiledExpression.java,v 1.1 2002/04/28 04:37:01 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/28 04:37:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/CompiledExpression.java,v 1.2 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * <p>\n  * Use CompiledExpression only when there is a need to evaluate the\n  * same expression multiple times and the CompiledExpression can be\n- * conveniently cached.  \n+ * conveniently cached.\n  * <p>\n  * To acqure a CompiledExpression, call {@link JXPathContext#compile\n  * JXPathContext.compile}\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/28 04:37:01 $\n+ * @version $Revision: 1.2 $ $Date: 2002/05/08 23:05:05 $\n  */\n public interface CompiledExpression {\n-    \n+\n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n      */\n+    Pointer createPathAndSetValue(JXPathContext context, Object value);\n+\n+    /**\n+     * @deprecated switch to createPathAndSetValue\n+     */\n     void createPath(JXPathContext context, Object value);\n \n     /**\n      * in the graph, the pointer will be null.\n      */\n     Pointer getPointer(JXPathContext context, String xpath);\n-    \n+\n     /**\n      * Traverses the xpath and returns an Iterator of Pointers.\n      * A Pointer provides easy access to a property.\n      * in the graph, the Iterator be empty, but not null.\n      */\n     Iterator iteratePointers(JXPathContext context);\n+\n+    /**\n+     * Remove the graph element described by this expression\n+     */\n+    void removePath(JXPathContext context);\n+\n+    /**\n+     * Remove all graph elements described by this expression\n+     */\n+    void removeAll(JXPathContext context);\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.7 2002/04/28 04:37:01 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/04/28 04:37:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.8 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/04/28 04:37:01 $\n+ * @version $Revision: 1.8 $ $Date: 2002/05/08 23:05:05 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n      * between invocations.\n      */\n     public abstract CompiledExpression compile(String xpath);\n-    \n+\n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n      */\n     public abstract void setValue(String xpath, Object value);\n \n+\n+    /**\n+     * Creates missing elements of the path by invoking an AbstractFactory,\n+     * which should first be installed on the context by calling \"setFactory\".\n+     * <p>\n+     * Will throw an exception if the AbstractFactory fails to create\n+     * an instance for a path element.\n+     */\n+    public abstract Pointer createPath(String xpath);\n+\n     /**\n      * The same as setValue, except it creates intermediate elements of\n      * the path by invoking an AbstractFactory, which should first be\n      * <p>\n      * Will throw an exception if one of the following conditions occurs:\n      * <ul>\n-     * <li>Elements of the xpath aleady exist, by the path does not in\n+     * <li>Elements of the xpath aleady exist, but the path does not in\n      *  fact describe an existing property\n      * <li>The AbstractFactory fails to create an instance for an intermediate\n      * element.\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n      */\n-    public abstract void createPath(String xpath, Object value);\n+    public abstract Pointer createPathAndSetValue(String xpath, Object value);\n+\n+    /**\n+     * Removes the element of the object graph described by the xpath.\n+     */\n+    public abstract void removePath(String xpath);\n+\n+    /**\n+     * Removes all elements of the object graph described by the xpath.\n+     */\n+    public abstract void removeAll(String xpath);\n+\n+    /**\n+     * @deprecated please use createPathAndSetValue(xpath, value)\n+     */\n+    public void createPath(String xpath, Object value){\n+        createPathAndSetValue(xpath, value);\n+    }\n \n     /**\n      * @deprecated Please use iterate\n      * in the graph, the pointer will be null.\n      */\n     public abstract Pointer getPointer(String xpath);\n-    \n+\n     /**\n      * @deprecated Please use iteratePointers\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.1 2002/04/28 04:37:01 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/28 04:37:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.2 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Pointer;\n \n /**\n- * \n+ *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/28 04:37:01 $\n+ * @version $Revision: 1.2 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class JXPathCompiledExpression implements CompiledExpression {\n \n     private String xpath;\n     private Expression expression;\n-    \n+\n     public JXPathCompiledExpression(String xpath, Expression expression){\n         this.xpath = xpath;\n         this.expression = expression;\n     }\n-    \n+\n     /**\n      * @see CompiledExpression#getValue(JXPathContext)\n      */\n     /**\n      * @see CompiledExpression#createPath(JXPathContext, Object)\n      */\n+    public Pointer createPathAndSetValue(JXPathContext context, Object value) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    createPathAndSetValue(xpath, expression, value);\n+    }\n+\n+    /**\n+     * @deprecated use createPathAndSetValue\n+     */\n     public void createPath(JXPathContext context, Object value) {\n-        ((JXPathContextReferenceImpl)context).\n-                    createPath(xpath, expression, value);\n+        createPathAndSetValue(context, value);\n     }\n \n     /**\n         return ((JXPathContextReferenceImpl)context).\n                     iteratePointers(xpath, expression);\n     }\n+\n+    /**\n+     * @see CompiledExpression#remove(JXPathContext)\n+     */\n+    public void removePath(JXPathContext context){\n+        ((JXPathContextReferenceImpl)context).removePath(xpath, expression);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#removeAll(JXPathContext)\n+     */\n+    public void removeAll(JXPathContext context){\n+        ((JXPathContextReferenceImpl)context).removeAll(xpath, expression);\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.15 2002/05/08 00:40:00 dmitri Exp $\n- * $Revision: 1.15 $\n- * $Date: 2002/05/08 00:40:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.16 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2002/05/08 00:40:00 $\n+ * @version $Revision: 1.16 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n         }\n     }\n \n-    public void createPath(String xpath, Object value){\n-        createPath(xpath, compileExpression(xpath), value);\n-    }\n-\n-    public void createPath(String xpath, Expression expr, Object value){\n+    public Pointer createPath(String xpath){\n+        return createPath(xpath, compileExpression(xpath));\n+    }\n+\n+    public Pointer createPath(String xpath, Expression expr){\n         try {\n-            setValue(xpath, expr, value, true);\n+            Object result = expr.computeValue(getRootContext());\n+            Pointer pointer = null;\n+\n+            if (result instanceof Pointer){\n+                pointer = (Pointer)result;\n+            }\n+            else if (result instanceof EvalContext){\n+                EvalContext ctx = (EvalContext)result;\n+                pointer = ctx.getSingleNodePointer();\n+            }\n+            else {\n+                // This should never happen\n+                throw new JXPathException(\"Expression is not a path:\" + xpath);\n+            }\n+            return ((NodePointer)pointer).createPath(this);\n         }\n         catch (Throwable ex){\n             throw new JXPathException(\n         }\n     }\n \n-    private void setValue(String xpath, Expression expr, Object value, boolean create){\n+    public Pointer createPathAndSetValue(String xpath, Object value){\n+        return createPathAndSetValue(xpath, compileExpression(xpath), value);\n+    }\n+\n+    public Pointer createPathAndSetValue(String xpath, Expression expr, Object value){\n+        try {\n+            return setValue(xpath, expr, value, true);\n+        }\n+        catch (Throwable ex){\n+            throw new JXPathException(\n+                \"Exception trying to create xpath \" + xpath, ex);\n+        }\n+    }\n+\n+    private Pointer setValue(String xpath, Expression expr, Object value, boolean create){\n         Object result = expr.computeValue(getRootContext());\n //        System.err.println(\"RESULT: \" + result);\n         Pointer pointer = null;\n             throw new JXPathException(\"Cannot set value for xpath: \" + xpath);\n         }\n         if (create){\n-            ((NodePointer)pointer).createPath(this, value);\n+            pointer = ((NodePointer)pointer).createPath(this, value);\n         }\n         else {\n             pointer.setValue(value);\n         }\n+        return pointer;\n     }\n \n     /**\n         return expr.iteratePointers(getRootContext());\n     }\n \n-    private void printPointer(NodePointer pointer){\n-        Pointer p = pointer;\n-        while (p != null){\n-            System.err.println((p == pointer ? \"POINTER: \" : \" PARENT: \")\n-                + p.getClass() + \" \" + p.asPath());\n-            if (p instanceof NodePointer){\n-                p = ((NodePointer)p).getParent();\n-            }\n+    public void removePath(String xpath){\n+        removePath(xpath, compileExpression(xpath));\n+    }\n+\n+    public void removePath(String xpath, Expression expr){\n+        try {\n+            NodePointer pointer = (NodePointer)getPointer(xpath, expr);\n+            if (pointer != null){\n+                ((NodePointer)pointer).remove();\n+            }\n+        }\n+        catch (Throwable ex){\n+            throw new JXPathException(\n+                \"Exception trying to remove xpath \" + xpath, ex);\n+        }\n+    }\n+\n+    public void removeAll(String xpath){\n+        removeAll(xpath, compileExpression(xpath));\n+    }\n+\n+    public void removeAll(String xpath, Expression expr){\n+        try {\n+            ArrayList list = new ArrayList();\n+            Iterator it = expr.iterate(getRootContext());\n+            while (it.hasNext()){\n+                list.add(it.next());\n+            }\n+            Collections.sort(list);\n+            for (int i = list.size() - 1; i >= 0; i--){\n+                NodePointer pointer = (NodePointer)list.get(i);\n+                pointer.remove();\n+            }\n+        }\n+        catch (Throwable ex){\n+            throw new JXPathException(\n+                \"Exception trying to remove all for xpath \" + xpath, ex);\n         }\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.4 2002/04/26 03:28:36 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.5 2002/05/08 23:05:04 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:04 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:36 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:04 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n \n      *  Called directly by JXPathContext. Must create path and\n      *  set value.\n      */\n-    public void createPath(JXPathContext context, Object value) {\n+    public NodePointer createPath(JXPathContext context, Object value) {\n         setValue(value);\n+        return this;\n+    }\n+\n+    /**\n+     * Remove the node of the object graph this pointer points to.\n+     */\n+    public void remove(){\n+        // It is a no-op\n+\n+//        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n+//        printPointerChain();\n     }\n \n     /**\n      * node. This method must may have to expand the collection in order to\n      * assign the element.\n      */\n-    public void createChild(JXPathContext context, QName name,\n+    public NodePointer createChild(JXPathContext context, QName name,\n                             int index, Object value) {\n         throw new JXPathException(\n             \"Cannot create an object for path \"\n \n         return p1.parent.compareChildNodePointers(p1, p2);\n     }\n+\n+    public void printPointerChain(){\n+        Pointer p = this;\n+        while (p != null){\n+            System.err.println((p == this ? \"POINTER: \" : \" PARENT: \")\n+                + p.getClass() + \" \" + p.asPath());\n+            if (p instanceof NodePointer){\n+                p = ((NodePointer)p).getParent();\n+            }\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.4 2002/04/26 03:28:36 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.5 2002/05/08 23:05:04 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:04 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:36 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:04 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n         return 0;\n     }\n \n-    public void createPath(JXPathContext context, Object value){\n+    public NodePointer createPath(JXPathContext context, Object value){\n         if (actual){\n             setValue(value);\n-            return;\n-        }\n-        createPath(context).setValue(value);\n+            return this;\n+        }\n+        NodePointer ptr = createPath(context);\n+        ptr.setValue(value);\n+        return ptr;\n     }\n \n     public NodePointer createPath(JXPathContext context){\n \n     /**\n      */\n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         Object collection = createCollection(context, index);\n         ValueUtils.setValue(collection, index, value);\n+        NodePointer cl = (NodePointer)clone();\n+        cl.setIndex(index);\n+        return cl;\n     }\n \n     private Object createCollection(JXPathContext context, int index){\n         }\n \n         return collection;\n+    }\n+\n+    public void remove(){\n+        if (actual){\n+            if (index == WHOLE_COLLECTION){\n+                variables.undeclareVariable(name.toString());\n+            }\n+            else {\n+                if (index < 0){\n+                    throw new JXPathException(\"Index is less than 1: \" + asPath());\n+                }\n+\n+                Object collection = getBaseValue();\n+                if (collection != null && index < getLength()){\n+                    collection = ValueUtils.remove(collection, index);\n+                    variables.declareVariable(name.toString(), collection);\n+                }\n+            }\n+        }\n     }\n \n     protected void findVariables(JXPathContext context){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.2 2002/04/24 04:06:46 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:06:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.3 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a path, following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:06:46 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n      * Throws an exception if you try to change the root element.\n      */\n     public void setValue(Object value){\n+        super.setValue(value);\n         if (parent instanceof PropertyPointer){\n             parent.setValue(value);\n         }\n         else {\n             throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+        }\n+    }\n+\n+    public void remove(){\n+        super.setValue(null);\n+        if (parent != null){\n+            parent.remove();\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\n+                \"Cannot remove an object that is not \" +\n+                \"some other object's property or a collection element\");\n         }\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private String propertyName;\n     public void setValue(Object value){\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null){\n-            throw new JXPathException(\"Cannot set property: \" + asPath() + \" - no such property\");\n+            throw new JXPathException(\"Cannot set property: \" + asPath() +\n+                    \" - no such property\");\n         }\n \n         if (index == WHOLE_COLLECTION){\n         if (getNodeValue() == null){\n             AbstractFactory factory = getAbstractFactory(context);\n             int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n-                throw new JXPathException(\"Factory could not create an object for path: \" + asPath());\n+            if (!factory.createObject(context, this, getBean(),\n+                    getPropertyName(), inx)){\n+                throw new JXPathException(\n+                    \"Factory could not create an object for path: \" + asPath());\n             }\n             baseValue = UNINITIALIZED;\n             value = UNINITIALIZED;\n         return this;\n     }\n \n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n-        return createPath(context).getValuePointer().createChild(context, name, index);\n-//        NodePointer pointer = setIndexExpandingCollection(context, name, index);\n-//        return pointer.createPath(context);\n-    }\n-\n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n-        createPath(context).getValuePointer().createChild(context, name, index, value);\n-//        NodePointer pointer = setIndexExpandingCollection(context, name, index);\n-//        pointer.createPath(context, value);\n-    }\n-\n-    private BeanPropertyPointer setIndexExpandingCollection(JXPathContext context, QName name, int index){\n+    public NodePointer createChild(JXPathContext context,\n+            QName name, int index){\n+        return createPath(context).getValuePointer().\n+                createChild(context, name, index);\n+    }\n+\n+    public NodePointer createChild(JXPathContext context,\n+            QName name, int index, Object value){\n+        return createPath(context).getValuePointer().\n+                createChild(context, name, index, value);\n+    }\n+\n+    private BeanPropertyPointer setIndexExpandingCollection(\n+            JXPathContext context, QName name, int index){\n         // Ignore the name passed to us, use our own information\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null){\n \n         if (index >= getLength()){\n             AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory.createObject(context, this, getBean(), getPropertyName(), index)){\n-                throw new JXPathException(\"Factory could not create path \" + asPath());\n+            if (!factory.createObject(context, this, getBean(),\n+                    getPropertyName(), index)){\n+                throw new JXPathException(\"Factory could not create path \" +\n+                        asPath());\n             }\n         }\n         BeanPropertyPointer clone = (BeanPropertyPointer)this.clone();\n         return clone;\n     }\n \n+    public void remove(){\n+        if (index == WHOLE_COLLECTION){\n+            setValue(null);\n+        }\n+        else if (isCollection()){\n+            Object collection = ValueUtils.remove(getBaseValue(), index);\n+            ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection);\n+        }\n+        else if (index == 0){\n+            index = WHOLE_COLLECTION;\n+            setValue(null);\n+        }\n+    }\n+\n     /**\n      * Name of the currently selected property.\n      */\n     }\n \n     /**\n-     * Finds the property descriptor corresponding to the current property index.\n+     * Finds the property descriptor corresponding to the current property\n+     * index.\n      */\n     private PropertyDescriptor getPropertyDescriptor(){\n         if (propertyDescriptor == null){\n             int inx = getPropertyIndex();\n             if (inx == UNSPECIFIED_PROPERTY){\n-                propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName);\n+                propertyDescriptor = beanInfo.\n+                        getPropertyDescriptor(propertyName);\n             }\n             else {\n-                PropertyDescriptor propertyDescriptors[] = getPropertyDescriptors();\n+                PropertyDescriptor propertyDescriptors[] =\n+                        getPropertyDescriptors();\n                 if (inx >=0 && inx < propertyDescriptors.length){\n                     propertyDescriptor = propertyDescriptors[inx];\n                 }\n     private AbstractFactory getAbstractFactory(JXPathContext context){\n         AbstractFactory factory = context.getFactory();\n         if (factory == null){\n-            throw new JXPathException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+            throw new JXPathException(\"Factory is not set on the \" +\n+                \"JXPathContext - cannot create path: \" + asPath());\n         }\n         return factory;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/26 01:00:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.4 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n         return valuePointer;\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         if (parent instanceof PropertyPointer){\n-            parent.createChild(context, name, index, value);\n+            return parent.createChild(context, name, index, value);\n         }\n         else {\n             Object collection = getBaseValue();\n                 ValueUtils.expandCollection(getNodeValue(), index + 1);\n             }\n             ValueUtils.setValue(collection, index, value);\n+            NodePointer ptr = (NodePointer)clone();\n+            ptr.setIndex(index);\n+            return ptr;\n         }\n     }\n \n     public boolean testNode(NodeTest nodeTest){\n         return getValuePointer().testNode(nodeTest);\n     }\n-    \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){        \n+\n+    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n         }\n     }\n \n-    public void createPath(JXPathContext context, Object value){\n-        createChild(context, getName(), index, value);\n-    }\n-\n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createPath(JXPathContext context, Object value){\n+        return createChild(context, getName(), index, value);\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         // Ignore the name passed to us, use our own data\n         if (index == WHOLE_COLLECTION){\n             handler.setProperty(getBean(), getPropertyName(), value);\n \n             ValueUtils.setValue(collection, index, value);\n         }\n+        NodePointer ptr = (NodePointer)clone();\n+        ptr.setIndex(index);\n+        return ptr;\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index){\n             }\n         }\n         return this;\n+    }\n+\n+    public void remove(){\n+        if (index == WHOLE_COLLECTION){\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n+        else if (isCollection()){\n+            Object collection = ValueUtils.remove(getBaseValue(), index);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+        else if (index == 0){\n+            handler.setProperty(getBean(), getPropertyName(), null);\n+        }\n     }\n \n     public String asPath(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * as the parent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class NullElementPointer extends PropertyOwnerPointer {\n \n     }\n \n     public void setValue(Object value){\n+        super.setValue(value);\n         if (parent instanceof PropertyPointer){\n             parent.setValue(value);\n         }\n         return false;\n     }\n \n-    public void createPath(JXPathContext context, Object value){\n+    public NodePointer createPath(JXPathContext context, Object value){\n         if (parent instanceof PropertyPointer){\n-            parent.getParent().createChild(context, parent.getName(), index, value);\n+            return parent.getParent().createChild(context, parent.getName(), index, value);\n         }\n         else {\n-            parent.createChild(context, null, index, value);\n+            return parent.createChild(context, null, index, value);\n         }\n     }\n \n         }\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         if (index != 0 && index != WHOLE_COLLECTION){\n             throw new JXPathException(\"Internal error. \" +\n                 \"Indexed passed to NullElementPointer.createChild() is not 0: \" + index);\n         }\n         if (parent instanceof PropertyPointer){\n-            parent.getParent().createChild(context, parent.getName(), getIndex(), value);\n+            return parent.getParent().createChild(context, parent.getName(), getIndex(), value);\n         }\n         else {\n-            parent.createChild(context, name, getIndex(), value);\n+            return parent.createChild(context, name, getIndex(), value);\n         }\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java,v 1.3 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class NullPointer extends PropertyOwnerPointer {\n     private QName name;\n     }\n \n     public void setValue(Object value){\n+        super.setValue(value);\n         if (parent instanceof PropertyPointer){\n             parent.setValue(value);\n         }\n         return new NullPropertyPointer(this);\n     }\n \n-    public void createPath(JXPathContext context, Object value){\n+    public NodePointer createPath(JXPathContext context, Object value){\n         if (parent != null){\n             if (parent instanceof PropertyPointer){\n-                parent.createPath(context, value);\n+                return parent.createPath(context, value);\n             }\n             else {\n-                parent.createChild(context, getName(), 0, value);\n+                return parent.createChild(context, getName(), 0, value);\n             }\n         }\n         else {\n         throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         if (parent != null){\n             NodePointer pointer = createPath(context);\n             if (pointer != null){\n-                pointer.getValuePointer().createChild(context, name, index, value);\n-                return;\n+                pointer = pointer.getValuePointer().createChild(context, name, index, value);\n+                return pointer;\n             }\n         }\n         throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n         return parent.createChild(context, getName(), getIndex());\n     }\n \n-    public void createPath(JXPathContext context, Object value){\n-        parent.createChild(context, getName(), getIndex(), value);\n+    public NodePointer createPath(JXPathContext context, Object value){\n+        return parent.createChild(context, getName(), getIndex(), value);\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n-        createPath(context).createChild(context, name, index, value);\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n+        return createPath(context).createChild(context, name, index, value);\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.3 2002/04/26 01:00:37 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/26 01:00:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.4 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:37 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 23:05:05 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n     }\n \n     public abstract QName getName();\n-    public abstract void setValue(Object value);\n+    public void setValue(Object value){\n+        this.value = value;\n+    }\n \n     public abstract PropertyPointer getPropertyPointer();\n \n         return NodePointer.newChildNodePointer(this, getName(), getNodeValue());\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n         PropertyPointer prop = getPropertyPointer();\n         prop.setPropertyName(name.getName());\n         prop.setIndex(index);\n-        prop.createPath(context, value);\n+        return prop.createPath(context, value);\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index){\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.4 2002/05/08 00:40:00 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/08 00:40:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/05/08 00:40:00 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n         attr.setValue((String)TypeUtils.convert(value, String.class));\n     }\n \n+    public void remove(){\n+        attr.getOwnerElement().removeAttributeNode(attr);\n+    }\n+\n     /**\n      */\n     public String asPath(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.5 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n         return it.getNodePointer();\n     }\n \n-    public void createChild(JXPathContext context, QName name, int index, Object value){\n-        createChild(context, name, index).setValue(value);\n+    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n+        NodePointer ptr = createChild(context, name, index);\n+        ptr.setValue(value);\n+        return ptr;\n+    }\n+\n+    public void remove(){\n+        Node parent = node.getParentNode();\n+        if (parent == null){\n+            throw new JXPathException(\"Cannot remove root DOM node\");\n+        }\n+        parent.removeChild(node);\n     }\n \n     public String asPath(){\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.17 2002/05/08 00:40:52 dmitri Exp $\n- * $Revision: 1.17 $\n- * $Date: 2002/05/08 00:40:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.18 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.18 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.17 $ $Date: 2002/05/08 00:40:52 $\n+ * @version $Revision: 1.18 $ $Date: 2002/05/08 23:05:05 $\n  */\n \n public class JXPathTestCase extends TestCase\n     }\n \n     /**\n-     * Test JXPath.createPath() with various arguments\n+     * Test JXPathContext.createPath() with various arguments\n      */\n     public void testCreatePath(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBeanWithDOM tBean = createTestBeanWithDOM();\n+        tBean.setNestedBean(null);\n+        tBean.setBeans(null);\n+        tBean.setMap(null);\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+        context.setFactory(new TestFactory());\n+\n+        // Calls factory.declareVariable(\"string\")\n+        testCreatePath(context, \"$string\", null);    // Declare and set to null\n+\n+        assertTrue(\"Variable created\",\n+                context.getVariables().isDeclaredVariable(\"string\"));\n+\n+        // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n+        testCreatePath(context, \"$stringArray[2]\", \"\");\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n+\n+        context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        testCreatePath(context, \"$array[2]\", \"\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n+\n+        // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n+        testCreatePath(context, \"$test/boolean\", Boolean.FALSE);\n+\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and put it in the collection\n+        // at index 1.\n+        testCreatePath(context, \"$testArray[2]/boolean\", Boolean.FALSE);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        testCreatePath(context, \"/nestedBean/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        testCreatePath(context, \"/beans[2]/int\", new Integer(1));\n+\n+        // Another, but the collection already exists\n+        testCreatePath(context, \"/beans[3]/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // sets the value\n+        testCreatePath(context, \"/nestedBean/strings[2]\", \"String 2\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        testCreatePath(context, \"/map[@name='TestKey1']\", \"\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        testCreatePath(context, \"/map[@name='TestKey2']/int\", new Integer(1));\n+\n+        testCreatePath(context, \"/map/TestKey3[2]\", null,\n+                \"/map[@name='TestKey3'][2]\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"/map[@name='TestKey3'][3]\", null);\n+\n+        // Create an element of a dynamic map element, which is a collection\n+        testCreatePath(context, \"/map/TestKey4[1]/int\", new Integer(1),\n+                \"/map[@name='TestKey4'][1]/int\");\n+\n+        tBean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"/map[@name='TestKey4'][1]/int\", new Integer(1));\n+\n+        // Create a DOM element\n+        testCreatePath(context, \"/vendor/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePath(context, \"/vendor/location[3]/address/street\", \"\",\n+                \"/vendor/location[3]/address[1]/street[1]\");\n+\n+        // Comprehensive tests: map & bean\n+        tBean.setMap(null);\n+        testCreatePath(context, \"/map[@name='TestKey5']/nestedBean/int\", new Integer(1));\n+        tBean.setMap(null);\n+        testCreatePath(context, \"/map[@name='TestKey5']/beans[2]/int\", new Integer(1));\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path, Object value){\n+        testCreatePath(context, path, value, path);\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path,\n+                Object value, String expectedPath){\n+        Pointer ptr = context.createPath(path);\n+        assertEquals(\"Pointer <\" + path + \">\", expectedPath, ptr.asPath());\n+        assertEquals(\"Created <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+\n+    /**\n+     * Test JXPath.createPathAndSetValue() with various arguments\n+     */\n+    public void testCreatePathAndSetValue(){\n         if (!enabled){\n             return;\n         }\n         context.setFactory(new TestFactory());\n \n         // Calls factory.declareVariable(\"string\")\n-        testCreatePath(context, \"$string\", \"Value\");\n+        testCreatePathAndSetValue(context, \"$string\", \"Value\");\n \n         // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n-        testCreatePath(context, \"$stringArray[2]\", \"Value2\");\n+        testCreatePathAndSetValue(context, \"$stringArray[2]\", \"Value2\");\n         assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n \n         context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n \n         // Does not involve factory at all - just expands the collection\n-        testCreatePath(context, \"$array[2]\", \"Value2\");\n+        testCreatePathAndSetValue(context, \"$array[2]\", \"Value2\");\n \n         // Make sure it is still the same array\n         assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n \n         // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n-        testCreatePath(context, \"$test/boolean\", Boolean.TRUE);\n+        testCreatePathAndSetValue(context, \"$test/boolean\", Boolean.TRUE);\n \n         // Calls factory.declareVariable(\"testArray\").\n         // The factory should create a collection of TestBeans.\n         // Then calls factory.createObject(..., collection, \"testArray\", 1).\n         // That one should produce an instance of TestBean and put it in the collection\n         // at index 1.\n-        testCreatePath(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n+        testCreatePathAndSetValue(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-        testCreatePath(context, \"nestedBean/int\", new Integer(1));\n+        testCreatePathAndSetValue(context, \"nestedBean/int\", new Integer(1));\n \n         // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n         // factory.createObject(..., testBean, \"beans\", 2)\n-        testCreatePath(context, \"beans[2]/int\", new Integer(2));\n+        testCreatePathAndSetValue(context, \"beans[2]/int\", new Integer(2));\n \n         // Another, but the collection already exists\n-        testCreatePath(context, \"beans[3]/int\", new Integer(3));\n+        testCreatePathAndSetValue(context, \"beans[3]/int\", new Integer(3));\n \n         // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n         // sets the value\n-        testCreatePath(context, \"nestedBean/strings[2]\", \"Test\");\n+        testCreatePathAndSetValue(context, \"nestedBean/strings[2]\", \"Test\");\n \n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // sets the value\n-        testCreatePath(context, \"map[@name = 'TestKey1']\", \"Test\");\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey1']\", \"Test\");\n \n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // then factory.createObject(..., map, \"TestKey2\"), then\n         // sets the value\n-        testCreatePath(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n \n         // Calls factory.expandCollection(..., map, \"TestKey3\", 2)\n-        testCreatePath(context, \"map/TestKey3[2]\", \"Test\");\n+        testCreatePathAndSetValue(context, \"map/TestKey3[2]\", \"Test\");\n \n         // Should be the same as the one before\n-        testCreatePath(context, \"map[@name='TestKey3'][3]\", \"Test\");\n+        testCreatePathAndSetValue(context, \"map[@name='TestKey3'][3]\", \"Test\");\n \n         // Create an element of a dynamic map element, which is a collection\n-        testCreatePath(context, \"map/TestKey4[1]/int\", new Integer(5));\n+        testCreatePathAndSetValue(context, \"map/TestKey4[1]/int\", new Integer(5));\n \n         tBean.getMap().remove(\"TestKey4\");\n \n         // Should be the same as the one before\n-        testCreatePath(context, \"map[@name = 'TestKey4'][1]/int\", new Integer(5));\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey4'][1]/int\", new Integer(5));\n \n         // Create a DOM element\n-        testCreatePath(context, \"vendor/location[3]\", \"\");\n+        testCreatePathAndSetValue(context, \"vendor/location[3]\", \"\");\n \n         // Create a DOM element with contents\n-        testCreatePath(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n+        testCreatePathAndSetValue(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n \n         // Comprehensive tests: map & bean\n         tBean.setMap(null);\n-        testCreatePath(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(6));\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(6));\n         tBean.setMap(null);\n-        testCreatePath(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(7));\n-    }\n-\n-    private void testCreatePath(JXPathContext context, String path, Object value){\n-        context.createPath(path, value);\n+        testCreatePathAndSetValue(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(7));\n+    }\n+\n+    private void testCreatePathAndSetValue(JXPathContext context, String path, Object value){\n+        Pointer ptr = context.createPathAndSetValue(path, value);\n+        assertTrue(\"Pointer <\" + path + \">\", ptr != null);\n         assertEquals(\"Created <\" + path + \">\", value, context.getValue(path));\n+        assertEquals(\"Pointer value <\" + path + \">\", value, ptr.getValue());\n+    }\n+\n+    /**\n+     * Test JXPathContext.removePath() with various arguments\n+     */\n+    public void testRemovePath(){\n+        if (!enabled){\n+            return;\n+        }\n+        TestBeanWithDOM tBean = createTestBeanWithDOM();\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+\n+        // Undeclare variable\n+        context.getVariables().declareVariable(\"temp\", \"temp\");\n+        context.removePath(\"$temp\");\n+        assertTrue(\"Undeclare variable\",\n+                !context.getVariables().isDeclaredVariable(\"temp\"));\n+\n+        // Remove array element\n+        context.getVariables().\n+                declareVariable(\"temp\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove array element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+\n+        // Remove list element\n+        context.getVariables().\n+                declareVariable(\"temp\", list(\"temp1\", \"temp2\"));\n+        context.removePath(\"$temp[1]\");\n+        assertEquals(\"Remove collection element\", \"temp2\",\n+                    context.getValue(\"$temp[1]\"));\n+\n+        // Remove property value\n+        context.removePath(\"nestedBean/int\");\n+        assertEquals(\"Remove property value\", new Integer(0),\n+                    context.getValue(\"nestedBean/int\"));\n+\n+        // Remove property value\n+        context.removePath(\"nestedBean/strings[1]\");\n+        assertEquals(\"Remove property value\", \"String 2\",\n+                    context.getValue(\"nestedBean/strings[1]\"));\n+\n+        context.removePath(\"nestedBean\");\n+        assertEquals(\"Remove property value\", null,\n+                    context.getValue(\"nestedBean\"));\n+\n+        tBean.getMap().put(\"TestKey1\", \"test\");\n+\n+        // Remove dynamic property\n+        context.removePath(\"map[@name = 'TestKey1']\");\n+        assertEquals(\"Remove dynamic property value\", null,\n+                    context.getValue(\"map[@name = 'TestKey1']\"));\n+\n+        tBean.getMap().put(\"TestKey2\", new String[]{\"temp1\", \"temp2\"});\n+        context.removePath(\"map[@name = 'TestKey2'][1]\");\n+        assertEquals(\"Remove dynamic property collection element\", \"temp2\",\n+                    context.getValue(\"map[@name = 'TestKey2'][1]\"));\n+\n+        // Remove DOM nodes\n+        context.removePath(\"vendor/location[@id = '101']//street/text()\");\n+        assertEquals(\"Remove DOM text\", \"\",\n+                    context.getValue(\"vendor/location[@id = '101']//street\"));\n+\n+        context.removePath(\"vendor/location[@id = '101']//street\");\n+        assertEquals(\"Remove DOM element\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '101']//street)\"));\n+\n+        context.removePath(\"vendor/location[@id = '100']/@name\");\n+        assertEquals(\"Remove DOM attribute\", new Double(0),\n+                    context.getValue(\"count(vendor/location[@id = '100']/@name)\"));\n     }\n \n     public void testNull(){\n--- a/src/test/org/apache/commons/jxpath/TestFactory.java\n+++ b/src/test/org/apache/commons/jxpath/TestFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.2 2002/04/21 21:52:34 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/21 21:52:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.3 2002/05/08 23:05:05 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 23:05:05 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:34 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 23:05:05 $\n  */\n public class TestFactory extends AbstractFactory {\n \n     public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n         if (name.equals(\"testArray\")){\n             ((TestBean[])parent)[index] = new TestBean();\n+            return true;\n+        }\n+        else if (name.equals(\"stringArray\")){\n+            ((String[])parent)[index] = \"\";\n+            return true;\n+        }\n+        else if (name.equals(\"array\")){\n+            ((String[])parent)[index] = \"\";\n             return true;\n         }\n         else if (name.equals(\"strings\")){\n         }\n         else if (name.equals(\"map\")){\n             ((TestBean)parent).setMap(new HashMap());\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey1\")){\n+            ((Map)parent).put(name, \"\");\n             return true;\n         }\n         else if (name.equals(\"TestKey2\")){\n     }\n \n     private void addElement(Node parent, int index, String tag){\n-        boolean repeat = true;\n-        while(repeat){\n-            Node child = parent.getFirstChild();\n-            int count = 0;\n-            while (child != null){\n-                if (child.getNodeName().equals(tag)){\n-                    if (count == index){\n-                        repeat = false;\n-                        break;\n-                    }\n-                    count++;\n-                }\n-                child = child.getNextSibling();\n+        Node child = parent.getFirstChild();\n+        int count = 0;\n+        while (child != null){\n+            if (child.getNodeName().equals(tag)){\n+                count++;\n             }\n-            if (child != null){\n-                child = child.getNextSibling();\n-            }\n+            child = child.getNextSibling();\n+        }\n+\n+        // Keep inserting new elements until we have index + 1 of them\n+        while (count <= index){\n             Node newElement = parent.getOwnerDocument().createElement(tag);\n-            if (child != null){\n-                parent.insertBefore(newElement, child);\n-            }\n-            else {\n-                parent.appendChild(newElement);\n-            }\n+            parent.appendChild(newElement);\n+            count++;\n         }\n     }\n ", "timestamp": 1020899105, "metainfo": ""}