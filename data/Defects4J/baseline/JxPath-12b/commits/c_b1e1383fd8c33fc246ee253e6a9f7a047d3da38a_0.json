{"sha": "b1e1383fd8c33fc246ee253e6a9f7a047d3da38a", "log": "Introduced prefix registration with JXPathContext Fixed a number or problems with namespace matching   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.22 $ $Date: 2004/02/29 14:17:42 $\n+ * @version $Revision: 1.23 $ $Date: 2004/04/01 02:55:31 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n     protected IdentityManager idManager;\n     protected KeyManager keyManager;\n     protected HashMap decimalFormats;\n-//    protected NamespaceManager namespaceManager;\n \n     private static JXPathContextFactory contextFactory;\n     private static JXPathContext compilationContext;\n         }\n     }\n \n-// TODO: either remove these methods or complete the functionality\n-//    /**\n-//     * Install a namespace manager that will be used by the context\n-//     * to look up namespace URI's for prefixes.\n-//     */\n-//    public void setNamespaceManager(NamespaceManager namespaceManager) {\n-//        this.namespaceManager = namespaceManager;\n-//    }\n-//\n-//    /**\n-//     * Returns this context's namespace manager. If none has been installed,\n-//     * returns the key manager of the parent context, or the default\n-//     * namespace manager.\n-//     */\n-//    public NamespaceManager getNamespaceManager() {\n-//        if (keyManager == null && parentContext != null) {\n-//            return parentContext.getNamespaceManager();\n-//        }\n-//        if (namespaceManager == null) {\n-//            namespaceManager = new BasicNamespaceManager();\n-//        }\n-//        return namespaceManager;\n-//    }\n-\n+    /**\n+     * Registers a namespace prefix.\n+     * \n+     * @param prefix A namespace prefix\n+     * @param namespaceURI A URI for that prefix\n+     */\n+    public void registerNamespace(String prefix, String namespaceURI) {\n+        throw new UnsupportedOperationException(\n+                \"Namespace registration is not implemented by \" + getClass());\n+    }\n+    \n+    /**\n+     * Given a prefix, returns a registered namespace URI. If the requested\n+     * prefix was not defined explicitly using the registerNamespace method,\n+     * JXPathContext will then check the context node to see if the prefix is\n+     * defined there. See\n+     * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer}.\n+     * \n+     * @param prefix The namespace prefix to look up\n+     * @return namespace URI or null if the prefix is undefined.\n+     */\n+    public String getNamespaceURI(String prefix) {\n+        throw new UnsupportedOperationException(\n+                \"Namespace registration is not implemented by \" + getClass());\n+    }\n+    \n+    /**\n+     * Namespace prefixes can be defined implicitly by specifying a pointer to a\n+     * context where the namespaces are defined. By default,\n+     * NamespaceContextPointer is the same as the Context Pointer, see\n+     * {@link #getContextPointer() getContextPointer()}\n+     * \n+     * @param contextPointer The pointer to the context where prefixes used in\n+     *        XPath expressions should be resolved.\n+     */\n+    public void setNamespaceContextPointer(Pointer namespaceContextPointer) {\n+        throw new UnsupportedOperationException(\n+                \"Namespace registration is not implemented by \" + getClass());\n+    }\n+    \n+    /**\n+     * Returns the namespace context pointer set with\n+     * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer()}\n+     * or, if none has been specified, the context pointer otherwise.\n+     * \n+     * @return The namespace context pointer.\n+     */\n+    public Pointer getNamespaceContextPointer() {\n+        throw new UnsupportedOperationException(\n+                \"Namespace registration is not implemented by \" + getClass());\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.40 $ $Date: 2004/03/25 03:49:50 $\n+ * @version $Revision: 1.41 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext {\n     \n \n     private Pointer rootPointer;\n     private Pointer contextPointer;\n+    \n+    protected NamespaceResolver namespaceResolver;\n \n     // The frequency of the cache cleanup\n     private static final int CLEANUP_THRESHOLD = 500;\n                     getLocale());\n             this.rootPointer = this.contextPointer;\n         }\n+        \n+        namespaceResolver = new NamespaceResolver();\n+        namespaceResolver\n+                .setNamespaceContextPointer((NodePointer) this.contextPointer);\n     }\n \n     private static void createNodeFactoryArray() {\n     }\n \n     private EvalContext getEvalContext() {\n-        return new InitialContext(\n-            new RootContext(this, (NodePointer) getContextPointer()));\n+        return new InitialContext(new RootContext(this,\n+                (NodePointer) getContextPointer()));\n     }\n \n     public EvalContext getAbsoluteRootContext() {\n-        return new InitialContext(\n-            new RootContext(this, getAbsoluteRootPointer()));\n+        return new InitialContext(new RootContext(this,\n+                getAbsoluteRootPointer()));\n     }\n \n     public NodePointer getVariablePointer(QName name) {\n         throw new JXPathException(\n             \"Undefined function: \" + functionName.toString());\n     }\n-\n-    /**\n-     * Checks if existenceCheckClass exists on the class path. If so,\n-     * allocates an instance of the specified class, otherwise\n-     * returns null.\n+    \n+    public void registerNamespace(String prefix, String namespaceURI) {\n+        if (namespaceResolver.isSealed()) {            \n+            namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n+        }\n+        namespaceResolver.registerNamespace(prefix, namespaceURI);\n+    }\n+    \n+    public String getNamespaceURI(String prefix) {\n+        return namespaceResolver.getNamespaceURI(prefix);\n+    }\n+    \n+    public void setNamespaceContextPointer(Pointer pointer) {\n+        if (namespaceResolver.isSealed()) {\n+            namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n+        }\n+        namespaceResolver.setNamespaceContextPointer((NodePointer) pointer);\n+    }\n+    \n+    public Pointer getNamespaceContextPointer() {\n+        return namespaceResolver.getNamespaceContextPointer();\n+    }\n+\n+    public NamespaceResolver getNamespaceResolver() {\n+        namespaceResolver.seal();\n+        return namespaceResolver;\n+    }\n+    \n+    /**\n+     * Checks if existenceCheckClass exists on the class path. If so, allocates\n+     * an instance of the specified class, otherwise returns null.\n      */\n     public static Object allocateConditionally(\n             String className,\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+/*\n+ * Copyright 1999-2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * The reference implementation of JXPathContext.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2004/04/01 02:55:32 $\n+ */\n+public class NamespaceResolver implements Cloneable {\n+    \n+    protected HashMap namespaceMap = new HashMap();\n+    protected HashMap reverseMap;\n+    protected NodePointer pointer;\n+    private boolean sealed;\n+    \n+    /**\n+     * Registers a namespace prefix.\n+     * \n+     * @param prefix A namespace prefix\n+     * @param namespaceURI A URI for that prefix\n+     */\n+    public void registerNamespace(String prefix, String namespaceURI) {\n+        namespaceMap.put(prefix, namespaceURI);\n+    }\n+    \n+    /**\n+     * Register a namespace for the expression context.\n+     */\n+    public void setNamespaceContextPointer(NodePointer pointer) {\n+        this.pointer = pointer;\n+    }\n+    \n+    public Pointer getNamespaceContextPointer() {\n+        return pointer;\n+    }\n+    \n+    /**\n+     * Given a prefix, returns a registered namespace URI. If the requested\n+     * prefix was not defined explicitly using the registerNamespace method,\n+     * JXPathContext will then check the context node to see if the prefix is\n+     * defined there. See\n+     * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer}.\n+     * \n+     * @param prefix The namespace prefix to look up\n+     * @return namespace URI or null if the prefix is undefined.\n+     */\n+    public String getNamespaceURI(String prefix) {\n+        String uri = (String) namespaceMap.get(prefix);\n+        if (uri == null && pointer != null) {\n+            uri = pointer.getNamespaceURI(prefix);\n+        }\n+//        System.err.println(\"For prefix \" + prefix + \" URI=\" + uri);\n+        return uri;\n+    }\n+    \n+    public String getPrefix(String namespaceURI) {\n+        if (reverseMap == null) {\n+            reverseMap = new HashMap();\n+            NodeIterator ni = pointer.namespaceIterator();\n+            if (ni != null) {\n+                for (int position = 1; ni.setPosition(position); position++) {\n+                    NodePointer nsPointer = ni.getNodePointer();\n+                    QName qname = nsPointer.getName();\n+                    reverseMap.put(qname.getPrefix(), qname.getName());\n+                }\n+            }\n+            Iterator it = namespaceMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                reverseMap.put(entry.getValue(), entry.getKey());\n+            }\n+        }\n+        String prefix = (String) reverseMap.get(namespaceURI);\n+        return prefix;\n+    }\n+    \n+    public boolean isSealed() {\n+        return sealed;\n+    }\n+    \n+    public void seal() {\n+        sealed = true;\n+    }\n+    \n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        }\n+        catch (CloneNotSupportedException e) {\n+            // Of course, it's supported.\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n import org.apache.commons.jxpath.NodeSet;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n+import org.apache.commons.jxpath.ri.NamespaceResolver;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n  * EvalContext that is used to hold the root node for the path traversal.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.17 $ $Date: 2004/03/25 05:42:01 $\n+ * @version $Revision: 1.18 $ $Date: 2004/04/01 02:55:31 $\n  */\n public class RootContext extends EvalContext {\n     private JXPathContextReferenceImpl jxpathContext;\n     private NodePointer pointer;\n     private Object registers[];\n     private int availableRegister = 0;\n+    private NamespaceResolver namespaceResolver;\n     public static final Object UNKNOWN_VALUE = new Object();\n     private static final int MAX_REGISTER = 4;\n \n         super(null);\n         this.jxpathContext = jxpathContext;\n         this.pointer = pointer;\n+        if (pointer != null) {\n+            pointer.setNamespaceResolver(jxpathContext.getNamespaceResolver());\n+        }\n     }\n \n     public JXPathContext getJXPathContext() {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import org.apache.commons.jxpath.ri.compiler.NameAttributeTest;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n import org.apache.commons.jxpath.ri.compiler.Step;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n         int bestQuality = 0;\n         NodePointer bestMatch = null;\n-        NodeIterator it = getNodeIterator(parentPointer, step);\n+        NodeIterator it = getNodeIterator(context, parentPointer, step);\n         if (it != null) {\n             for (int i = 1; it.setPosition(i); i++) {\n                 NodePointer childPointer = it.getNodePointer();\n         // It is a very common use case, so it deserves individual\n         // attention\n         if (predicates.length == 1) {\n-            NodeIterator it = getNodeIterator(parent, step);\n+            NodeIterator it = getNodeIterator(context, parent, step);\n             NodePointer pointer = null;\n             if (it != null) {\n                 if (predicate instanceof NameAttributeTest) { // [@name = key]\n             }\n         }\n         else {\n-            NodeIterator it = getNodeIterator(parent, step);\n+            NodeIterator it = getNodeIterator(context, parent, step);\n             if (it != null) {\n                 List list = new ArrayList();\n                 for (int i = 1; it.setPosition(i); i++) {\n     }\n \n     private static NodeIterator getNodeIterator(\n+        EvalContext context,\n         NodePointer pointer,\n         Step step) \n     {\n         if (step.getAxis() == Compiler.AXIS_CHILD) {\n-            return pointer.childIterator(step.getNodeTest(), false, null);\n+            NodeTest nodeTest = step.getNodeTest();\n+            QName qname = ((NodeNameTest) nodeTest).getNodeName();\n+            String prefix = qname.getPrefix();\n+            if (prefix != null) {\n+                String namespaceURI = context.getJXPathContext()\n+                        .getNamespaceURI(prefix);\n+                nodeTest = new NodeNameTest(qname, namespaceURI);\n+\n+            }\n+            return pointer.childIterator(nodeTest, false, null);\n         }\n         else { // Compiler.AXIS_ATTRIBUTE\n             if (!(step.getNodeTest() instanceof NodeNameTest)) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2004/03/25 05:41:29 $\n+ * @version $Revision: 1.11 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class NodeNameTest extends NodeTest {\n     private QName qname;\n+    private String namespaceURI;\n \n     public NodeNameTest(QName qname) {\n         this.qname = qname;\n     }\n+    \n+    public NodeNameTest(QName qname, String namespaceURI) {\n+        this.qname = qname;\n+        this.namespaceURI = namespaceURI;\n+    }\n \n     public QName getNodeName() {\n         return qname;\n+    }\n+    \n+    public String getNamespaceURI() {\n+        return namespaceURI;\n     }\n     \n     public boolean isWildcard() {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.axes.AncestorContext;\n import org.apache.commons.jxpath.ri.axes.AttributeContext;\n import org.apache.commons.jxpath.ri.axes.ChildContext;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.13 $ $Date: 2004/03/25 05:41:29 $\n+ * @version $Revision: 1.14 $ $Date: 2004/04/01 02:55:32 $\n  */\n public abstract class Path extends Expression {\n \n         int axis,\n         NodeTest nodeTest) \n     {\n+        if (nodeTest instanceof NodeNameTest) {\n+            QName qname = ((NodeNameTest) nodeTest).getNodeName();\n+            String prefix = qname.getPrefix();\n+            if (prefix != null) {\n+                String namespaceURI = context.getJXPathContext()\n+                        .getNamespaceURI(prefix);\n+                nodeTest = new NodeNameTest(qname, namespaceURI);\n+            }\n+        }\n+        \n         switch (axis) {\n         case Compiler.AXIS_ANCESTOR :\n             return new AncestorContext(context, false, nodeTest);\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n+import org.apache.commons.jxpath.ri.NamespaceResolver;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n  * attribute and only simple, context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.24 $ $Date: 2004/03/25 05:41:29 $\n+ * @version $Revision: 1.25 $ $Date: 2004/04/01 02:55:32 $\n  */\n public abstract class NodePointer implements Pointer {\n \n     public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n     private boolean attribute = false;\n     private transient Object rootNode;\n-\n+    private NamespaceResolver namespaceResolver;\n+    \n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n         this.locale = locale;\n     }\n \n+    public NamespaceResolver getNamespaceResolver() {\n+        if (namespaceResolver == null && parent != null) {\n+            namespaceResolver = parent.getNamespaceResolver();\n+        }\n+        return namespaceResolver;\n+    }\n+    \n+    public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n+        this.namespaceResolver = namespaceResolver;\n+    }\n+    \n     public NodePointer getParent() {\n         NodePointer pointer = parent;\n         while (pointer != null && pointer.isContainer()) {\n     }\n \n     /**\n-     * Returns a name that consists of the namespaceURI and the local name\n-     * of the node.  For non-XML pointers, returns the Pointer's qualified name.\n-     */\n-    public QName getExpandedName() {\n-        return getName();\n-    }\n-\n-    /**\n      * Locates a node by ID.\n      */\n     public Pointer getPointerByID(JXPathContext context, String id) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n  * of the attribute is based on the locale supplied to it in the constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2004/02/29 14:17:41 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class LangAttributePointer extends NodePointer {\n     public LangAttributePointer(NodePointer parent) {\n \n     public QName getName() {\n         return new QName(\"xml\", \"lang\");\n-    }\n-\n-    public QName getExpandedName() {\n-        return getName();\n     }\n \n     public String getNamespaceURI() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2004/02/29 14:17:45 $\n+ * @version $Revision: 1.12 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n     {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n-\n+    \n+    public String getNamespaceURI(String prefix) {\n+        return getValuePointer().getNamespaceURI(prefix);\n+    }\n+    \n     public String asPath() {\n         if (parent != null) {\n             return parent.asPath();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2004/02/29 14:17:44 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n         return new QName(\n             DOMNodePointer.getPrefix(attr),\n             DOMNodePointer.getLocalName(attr));\n-    }\n-\n-    public QName getExpandedName() {\n-        return new QName(getNamespaceURI(),  DOMNodePointer.getLocalName(attr));\n     }\n \n     public String getNamespaceURI() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n import org.w3c.dom.NamedNodeMap;\n import org.w3c.dom.Node;\n \n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2004/02/29 14:17:44 $\n+ * @version $Revision: 1.9 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class DOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n         Node parent = node.getParentNode();\n         if (parent != null) {\n             collectNamespaces(attributes, parent);\n+        }\n+        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n+            node = ((Document) node).getDocumentElement();\n         }\n         if (node.getNodeType() == Node.ELEMENT_NODE) {\n             NamedNodeMap map = node.getAttributes();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n  * An iterator of children of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2004/02/29 14:17:44 $\n+ * @version $Revision: 1.11 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class DOMNodeIterator implements NodeIterator {\n     private NodePointer parent;\n     private NodeTest nodeTest;\n-    private String namespaceURI;\n     private Node node;\n     private Node child = null;\n     private boolean reverse;\n     }\n \n     private boolean testChild() {\n-        return DOMNodePointer.testNode(parent, child, nodeTest);\n+        return DOMNodePointer.testNode(child, nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.22 $ $Date: 2004/03/25 05:41:29 $\n+ * @version $Revision: 1.23 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n         super(parent);\n         this.node = node;\n     }\n-\n+    \n     public boolean testNode(NodeTest test) {\n-        return testNode(this, node, test);\n-    }\n-\n-    public static boolean testNode(\n-            NodePointer pointer, Node node, NodeTest test)\n-    {\n+        return testNode(node, test);\n+    }\n+\n+    public static boolean testNode(Node node, NodeTest test) {\n         if (test == null) {\n             return true;\n         }\n \n             NodeNameTest nodeNameTest = (NodeNameTest) test;\n             QName testName = nodeNameTest.getNodeName();\n+            String namespaceURI = nodeNameTest.getNamespaceURI();\n             boolean wildcard = nodeNameTest.isWildcard();\n             String testPrefix = testName.getPrefix();\n             if (wildcard && testPrefix == null) {\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n-                String nodePrefix = DOMNodePointer.getPrefix(node);\n-                if (equalStrings(testPrefix, nodePrefix)) {\n-                    return true;\n-                }\n-\n-                String testNS = pointer.getNamespaceURI(testPrefix);\n-                String nodeNS = pointer.getNamespaceURI(nodePrefix);\n-                return equalStrings(testNS, nodeNS);\n+                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n+                return equalStrings(namespaceURI, nodeNS);\n             }\n         }\n         else if (test instanceof NodeTypeTest) {\n     }\n \n     public String getNamespaceURI() {\n-        if (node.getNodeType() == Node.ELEMENT_NODE) {\n-            return getNamespaceURI(getName().getPrefix());\n-        }\n-        return null;\n-    }\n-\n-    public QName getExpandedName() {\n-        return new QName(getNamespaceURI(), getName().getName());\n+        return getNamespaceURI(node);\n     }\n \n     public NodeIterator childIterator(\n         if (namespace == null) {\n             String qname = \"xmlns:\" + prefix;\n             Node aNode = node;\n+            if (aNode instanceof Document) {\n+                aNode = ((Document)aNode).getDocumentElement();\n+            }\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                 }\n                 aNode = aNode.getParentNode();\n             }\n-//            if (namespace == null) {\n-//                NamespaceManager manager = getNamespaceManager();\n-//                if (manager != null) {\n-//                    namespace = manager.getNamespaceURI(prefix, this);\n-//                }\n-//            }\n             if (namespace == null || namespace.equals(\"\")) {\n                 namespace = NodePointer.UNKNOWN_NAMESPACE;\n             }\n \n         namespaces.put(prefix, namespace);\n         // TBD: We are supposed to resolve relative URIs to absolute ones.\n+        return namespace;\n+    }\n+\n+    private String getNamespaceURI(String prefix, String namespace) {\n+        String qname = \"xmlns:\" + prefix;\n+        Node aNode = node;\n+        if (aNode instanceof Document) {\n+            aNode = ((Document)aNode).getDocumentElement();\n+        }\n+        while (aNode != null) {\n+            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n+                Attr attr = ((Element) aNode).getAttributeNode(qname);\n+                if (attr != null) {\n+                    namespace = attr.getValue();\n+                    break;\n+                }\n+            }\n+            aNode = aNode.getParentNode();\n+        }\n         return namespace;\n     }\n \n                 // of the path\n                 if (parent instanceof DOMNodePointer) {\n                     if (buffer.length() == 0\n-                        || buffer.charAt(buffer.length() - 1) != '/') {\n+                            || buffer.charAt(buffer.length() - 1) != '/') {\n                         buffer.append('/');\n                     }\n-                    buffer.append(getName());\n-                    buffer.append('[');\n-                    buffer.append(getRelativePositionByName()).append(']');\n-                }\n-                break;\n+                    String nsURI = getNamespaceURI();\n+                    String ln = DOMNodePointer.getLocalName(node);\n+                    \n+                    if (nsURI == null) {\n+                        buffer.append(ln);\n+                        buffer.append('[');\n+                        buffer.append(getRelativePositionByName()).append(']');\n+                    }\n+                    else {\n+                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n+                        if (prefix != null) {\n+                            buffer.append(prefix);\n+                            buffer.append(':');\n+                            buffer.append(ln);\n+                            buffer.append('[');\n+                            buffer.append(getRelativePositionByName());\n+                            buffer.append(']');\n+                        }\n+                        else {\n+                            buffer.append(\"node()\");\n+                            buffer.append('[');\n+                            buffer.append(getRelativePositionOfElement());\n+                            buffer.append(']');\n+                        }\n+                    }\n+                }\n+            break;\n             case Node.TEXT_NODE :\n             case Node.CDATA_SECTION_NODE :\n                 buffer.append(\"/text()\");\n         }\n         return count;\n     }\n+    \n+    private int getRelativePositionOfElement() {\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null) {\n+            if (n.getNodeType() == Node.ELEMENT_NODE) {\n+                count++;\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n \n     private int getRelativePositionOfTextNode() {\n         int count = 1;\n \n         return name.substring(index + 1);\n     }\n+    \n+    public static String getNamespaceURI(Node node) {\n+        if (node instanceof Document) {\n+            node = ((Document) node).getDocumentElement();\n+        }\n+\n+        Element element = (Element) node;\n+\n+        String uri = element.getNamespaceURI();\n+        if (uri != null) {\n+            return uri;\n+        }\n+\n+        String qname;\n+        String prefix = getPrefix(node);\n+        if (prefix == null) {\n+            qname = \"xmlns\";\n+        }\n+        else {\n+            qname = \"xmlns:\" + prefix;\n+        }\n+\n+        Node aNode = node;\n+        while (aNode != null) {\n+            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n+                Attr attr = ((Element) aNode).getAttributeNode(qname);\n+                if (attr != null) {\n+                    return attr.getValue();\n+                }\n+            }\n+            aNode = aNode.getParentNode();\n+        }\n+        return null;\n+    }\n \n     public Object getValue() {\n         return stringValue(node);\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2004/02/29 14:17:44 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/01 02:55:32 $\n  */\n public class NamespacePointer extends NodePointer {\n     private String prefix;\n     }\n \n     public QName getName() {\n-        return new QName(getNamespaceURI(), prefix);\n+        return new QName(prefix);\n     }\n \n     public Object getBaseValue() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2004/02/29 14:17:40 $\n+ * @version $Revision: 1.10 $ $Date: 2004/04/01 02:55:31 $\n  */\n public class JDOMAttributePointer extends NodePointer {\n     private Attribute attr;\n         return new QName(\n             JDOMNodePointer.getPrefix(attr),\n             JDOMNodePointer.getLocalName(attr));\n-    }\n-\n-    public QName getExpandedName() {\n-        return new QName(getNamespaceURI(),  attr.getName());\n     }\n \n     public String getNamespaceURI() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n \n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.jdom.Document;\n import org.jdom.Element;\n import org.jdom.Namespace;\n \n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2004/03/04 01:01:27 $\n+ * @version $Revision: 1.9 $ $Date: 2004/04/01 02:55:31 $\n  */\n public class JDOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n     public JDOMNamespaceIterator(NodePointer parent) {\n         this.parent = parent;\n         Object node = parent.getNode();\n+        if (node instanceof Document) {\n+            node = ((Document)node).getRootElement();\n+        }\n         if (node instanceof Element) {\n             namespaces = new ArrayList();\n             prefixes = new HashSet();\n-            collectNamespaces((Element) parent.getNode());\n+            collectNamespaces((Element) node);\n         }\n     }\n \n     }\n \n     public boolean setPosition(int position) {\n+        if (namespaces == null) {\n+            return false;\n+        }\n         this.position = position;\n         return position >= 1 && position <= namespaces.size();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2004/02/29 14:17:40 $\n+ * @version $Revision: 1.9 $ $Date: 2004/04/01 02:55:31 $\n  */\n public class JDOMNamespacePointer extends NodePointer {\n     private String prefix;\n     }\n \n     public QName getName() {\n-        return new QName(getNamespaceURI(), prefix);\n+        return new QName(prefix);\n     }\n \n     public Object getBaseValue() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2004/03/25 05:41:29 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/01 02:55:31 $\n  */\n public class JDOMNodePointer extends NodePointer {\n     private Object node;\n     }\n \n     public String getNamespaceURI() {\n+        return getNamespaceURI(node);\n+    }\n+    \n+    private static String getNamespaceURI(Object node) {\n         if (node instanceof Element) {\n             Element element = (Element) node;\n             String ns = element.getNamespaceURI();\n     }\n \n     public String getNamespaceURI(String prefix) {\n-        if (node instanceof Element) {\n+        if (node instanceof Document) {\n+            Element element = ((Document)node).getRootElement(); \n+            Namespace ns = element.getNamespace(prefix);\n+            if (ns != null) {\n+                return ns.getURI();\n+            }\n+        }        \n+        else if (node instanceof Element) {\n             Element element = (Element) node;\n             Namespace ns = element.getNamespace(prefix);\n-            if (ns == null) {\n-//                NamespaceManager manager = getNamespaceManager();\n-//                if (manager != null) {\n-//                    return manager.getNamespaceURI(prefix, this);\n-//                }\n-\n-                return null;\n-            }\n-            return ns.getURI();\n+            if (ns != null) {\n+                return ns.getURI();\n+            }\n         }\n         return null;\n     }\n         return new QName(ns, ln);\n     }\n \n-    public QName getExpandedName() {\n-        return new QName(getNamespaceURI(), getName().getName());\n-    }\n-\n     /**\n      * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n      */\n \n             NodeNameTest nodeNameTest = (NodeNameTest) test;\n             QName testName = nodeNameTest.getNodeName();\n+            String namespaceURI = nodeNameTest.getNamespaceURI();\n             boolean wildcard = nodeNameTest.isWildcard();\n-            if (wildcard && testName.getPrefix() == null) {\n+            String testPrefix = testName.getPrefix();\n+            if (wildcard && testPrefix == null) {\n                 return true;\n             }\n \n             if (wildcard\n-                || testName.getName().equals(\n-                    JDOMNodePointer.getLocalName((Element) node))) {\n-                String testPrefix = testName.getPrefix();\n-                String nodePrefix = JDOMNodePointer.getPrefix((Element) node);\n-                if (equalStrings(testPrefix, nodePrefix)) {\n-                    return true;\n-                }\n-\n-                String testNS = pointer.getNamespaceURI(testPrefix);\n-                if (testNS == null) {\n-                    return false;\n-                }\n-                String nodeNS = pointer.getNamespaceURI(nodePrefix);\n-                return equalStrings(testNS, nodeNS);\n-            }\n+                || testName.getName()\n+                        .equals(JDOMNodePointer.getLocalName(node))) {\n+                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n+                return equalStrings(namespaceURI, nodeNS);\n+            }\n+\n         }\n         else if (test instanceof NodeTypeTest) {\n             switch (((NodeTypeTest) test).getNodeType()) {\n                     || buffer.charAt(buffer.length() - 1) != '/') {\n                     buffer.append('/');\n                 }\n-                buffer.append(getName());\n-                buffer.append('[');\n-                buffer.append(getRelativePositionByName());\n-                buffer.append(']');\n+                String nsURI = getNamespaceURI();\n+                String ln = JDOMNodePointer.getLocalName(node);\n+                \n+                if (nsURI == null) {\n+                    buffer.append(ln);\n+                    buffer.append('[');\n+                    buffer.append(getRelativePositionByName()).append(']');\n+                }\n+                else {\n+                    String prefix = getNamespaceResolver().getPrefix(nsURI);\n+                    if (prefix != null) {\n+                        buffer.append(prefix);\n+                        buffer.append(':');\n+                        buffer.append(ln);\n+                        buffer.append('[');\n+                        buffer.append(getRelativePositionByName());\n+                        buffer.append(']');\n+                    }\n+                    else {\n+                        buffer.append(\"node()\");\n+                        buffer.append('[');\n+                        buffer.append(getRelativePositionOfElement());\n+                        buffer.append(']');\n+                    }\n+                }\n+\n             }\n         }\n         else if (node instanceof Text || node instanceof CDATA) {\n         }\n         return 1;\n     }\n+    \n+    private int getRelativePositionOfElement() {\n+        Element parent = (Element) ((Element) node).getParent();\n+        if (parent == null) {\n+            return 1;\n+        }\n+        List children = parent.getContent();\n+        int count = 0;\n+        for (int i = 0; i < children.size(); i++) {\n+            Object child = children.get(i);\n+            if (child instanceof Element) {\n+                count++;\n+            }\n+            if (child == node) {\n+                break;\n+            }\n+        }\n+        return count;\n+    }\n \n     private int getRelativePositionOfTextNode() {\n         Element parent;\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.20 $ $Date: 2004/03/02 01:32:20 $\n+ * @version $Revision: 1.21 $ $Date: 2004/04/01 02:55:32 $\n  */\n \n public abstract class XMLModelTestCase extends JXPathTestCase {\n         JXPathContext context =\n             JXPathContext.newContext(createDocumentContainer());\n         context.setFactory(getAbstractFactory());\n+        context.registerNamespace(\"product\", \"productNS\");\n         return context;\n     }\n \n         \n         assertXPathCreatePathAndSetValue(\n             context,\n-            \"vendor/product/name/attribute::price:language\",\n+            \"vendor/product/product:name/attribute::price:language\",\n             \"English\",\n-            \"/vendor[1]/product[1]/name[1]/@price:language\");\n+            \"/vendor[1]/product[1]/product:name[1]/@price:language\");\n     }\n \n     /**\n         assertXPathValue(\n             context,\n             \"name(vendor/product/price:amount)\",\n-            \"priceNS:amount\");\n+            \"value:amount\");\n \n         // name (non-qualified)\n         assertXPathValue(\n             \"count(vendor/product/price:*)\",\n             new Double(2));\n \n-        // child:: with a namespace and wildcard\n-        assertXPathValue(\n-            context,\n-            \"count(vendor/product/value:*)\",\n-            new Double(2));\n-\n         // child:: with the default namespace\n         assertXPathValue(context, \"count(vendor/product/*)\", new Double(4));\n \n             context,\n             \"vendor/product/price:amount/@price:discount\",\n             \"10%\");\n-        assertXPathValue(\n-            context,\n-            \"vendor/product/value:amount/@value:discount\",\n-            \"10%\");\n-\n+        \n         // namespace uri for an attribute\n         assertXPathValue(\n             context,\n         assertXPathValue(\n             context,\n             \"name(vendor/product/price:amount/@price:discount)\",\n-            \"priceNS:discount\");\n+            \"price:discount\");\n \n         // attribute:: with the default namespace\n         assertXPathValue(\n         assertXPathValue(\n             context,\n             \"name(vendor/product/prix/namespace::price)\",\n-            \"priceNS:price\");\n+            \"price\");\n \n         // local name of namespace\n         assertXPathValue(\n                 \"/vendor[1]/location[2]\");\n     }\n \n-// TODO: either complete the external namespace functionality, or get rid of\n-// this test.\n-//\n-//    public void testExternalNamespace() {\n+    public void testNamespaceMapping() {\n+        context.registerNamespace(\"rate\", \"priceNS\");\n+        context.registerNamespace(\"goods\", \"productNS\");\n+\n+        assertEquals(\"Context node namespace resolution\", \n+                \"priceNS\", \n+                context.getNamespaceURI(\"price\"));        \n+        \n+        assertEquals(\"Registered namespace resolution\", \n+                \"priceNS\", \n+                context.getNamespaceURI(\"rate\"));\n+\n+        // child:: with a namespace and wildcard\n+        assertXPathValue(context, \n+                \"count(vendor/product/rate:*)\", \n+                new Double(2));\n+\n+        // Preference for externally registered namespace prefix\n+        assertXPathValueAndPointer(context,\n+                \"//product:name\",\n+                \"Box of oranges\",\n+                \"/vendor[1]/product[1]/goods:name[1]\");\n+        \n //        if (isExternalNamespaceSupported()) {\n //             DocumentContainer container = new DocumentContainer(\n //                    XMLModelTestCase.class.getResource(\"ExternalNamespaceTest.xml\"),\n //                    \"namespace-uri(vendor/product/value:price)\",\n //                    \"priceNS\");\n //        }\n-//    }\n+    }\n }", "timestamp": 1080788132, "metainfo": ""}