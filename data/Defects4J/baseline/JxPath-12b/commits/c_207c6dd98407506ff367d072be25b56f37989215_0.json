{"sha": "207c6dd98407506ff367d072be25b56f37989215", "log": "Moved PropertyIterator to ...pointers, added support for DOM objects, added support for Containers, fixed some bugs   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/Container.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Container.java,v 1.1 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * A Container is an object implementing an indirection\n+ * mechanism transparent to JXPath.  For example, if property\n+ * \"foo\" of the context node has a Container as its value,\n+ * the XPath \"foo\" will produce the contents of that Container,\n+ * not the container itself.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:30 $\n+ */\n+public interface Container {\n+\n+    /**\n+     * Returns the contained value.\n+     */\n+    Object getValue();\n+\n+    /**\n+     * Modifies the value contained by this container.  May throw\n+     * UnsupportedOperationException.\n+     */\n+    void setValue(Object value);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.1 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.transform.dom.DOMResult;\n+import java.net.URL;\n+import org.w3c.dom.*;\n+import java.io.InputStream;\n+\n+/**\n+ * An XML document container reads and parses XML only when it is\n+ * accessed.  JXPath traverses Containers transparently -\n+ * you use the same paths to access objects in containers as you\n+ * do to access those objects directly.  You can create\n+ * XMLDocumentContainers for various XML documents that may or\n+ * may not be accessed by XPaths.  If they are, they will be automatically\n+ * read, parsed and traversed. If they are not - they won't be\n+ * read at all.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:30 $\n+ */\n+public class XMLDocumentContainer implements Container {\n+\n+    private Node document;\n+    private URL xmlURL;\n+    private Source source;\n+\n+    public XMLDocumentContainer(URL xmlURL){\n+        this.xmlURL = xmlURL;\n+    }\n+\n+    public XMLDocumentContainer(Source source){\n+        this.source = source;\n+    }\n+\n+    public Object getValue(){\n+        if (document == null){\n+            try {\n+                InputStream stream = null;\n+                try {\n+                    if (xmlURL != null){\n+                        stream = xmlURL.openStream();\n+                        source = new StreamSource(stream);\n+                    }\n+                    DOMResult result = new DOMResult();\n+                    Transformer trans = TransformerFactory.newInstance().newTransformer();\n+                    trans.transform(source, result);\n+                    document = (Document)result.getNode();\n+                }\n+                finally {\n+                    if (stream != null){\n+                        stream.close();\n+                    }\n+                }\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot read XML from: \" +\n+                    (xmlURL != null ? xmlURL.toString() : source.getSystemId()) + \"\\n\" + ex);\n+            }\n+        }\n+        return document;\n+    }\n+\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException();\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Pointer;\n import java.util.*;\n+import org.w3c.dom.*;\n \n /**\n  * An XPath evaluation context.\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public abstract class EvalContext implements ExpressionContext {\n     protected EvalContext parentContext;\n     /**\n      * Converts the supplied object to String\n      */\n-    protected String stringValue(Object object){\n+    public static String stringValue(Object object){\n         if (object instanceof String){\n             return (String)object;\n         }\n         }\n         else if (object == null){\n             return \"\";\n+        }\n+        else if (object instanceof Node){\n+            NodeList list = ((Node)object).getChildNodes();\n+            StringBuffer buf = new StringBuffer(16);\n+            for(int i = 0; i < list.getLength();i++) {\n+                Node child = list.item(i);\n+                if (child.getNodeType() == Node.TEXT_NODE){\n+                    buf.append(child.getNodeValue());\n+                }\n+                else {\n+                    buf.append(stringValue(child));\n+                }\n+            }\n+            return buf.toString().trim();\n         }\n         else if (object instanceof NodePointer){\n             return stringValue(((NodePointer)object).getValue());\n             }\n             return value;\n         }\n+        else if (object instanceof Node){\n+            return number(stringValue(object));\n+        }\n         else if (object instanceof EvalContext){\n             return number(stringValue(object));\n         }\n     /**\n      * Converts the supplied object to double\n      */\n-    protected double doubleValue(Object object){\n+    public static double doubleValue(Object object){\n         if (object instanceof Number){\n             return ((Number)object).doubleValue();\n         }\n             }\n             return value;\n         }\n+        else if (object instanceof Node){\n+            return doubleValue(stringValue(object));\n+        }\n         else if (object instanceof NodePointer){\n             return doubleValue(((NodePointer)object).getValue());\n         }\n     /**\n      * Converts the supplied object to boolean\n      */\n-    protected boolean booleanValue(Object object){\n+    public static boolean booleanValue(Object object){\n         if (object instanceof Number){\n             double value = ((Number)object).doubleValue();\n             return value != 0 && value != -0 && !Double.isNaN(value);\n         }\n         else if (object instanceof String){\n             return ((String)object).length() != 0;\n+        }\n+        else if (object instanceof Node){\n+            return stringValue(object).length() != 0;\n         }\n         else if (object instanceof NodePointer){\n             return booleanValue(((NodePointer)object).getValue());\n         if (firstMatch){\n             boolean basic = path.getEvaluationHint(LocationPath.BASIC_PATH_HINT) == Boolean.TRUE;\n             if (basic){\n-//                System.err.println(\"EVALUATING BASIC PATH: \" + path);\n-                Object result = tryBasicPath(rootContext, steps);\n+                Object result = tryBasicPath(new InitialContext(rootContext), steps);\n                 if (result != FAILURE){\n                     return result;\n                 }\n \n \n     private static final Object FAILURE = new Object();\n+\n+    /**\n+     * Attempts to evaluate a simple path without traversing contexts -\n+     * straight from a NodePointer to a NodePointer. This only works\n+     * in some cases though. Specifically, it works with JavaBeans\n+     * and objects with Dynamic Properties, but does not work with\n+     * DOM objects.\n+     */\n     private Object tryBasicPath(EvalContext context, Step steps[]){\n-        NodePointer pointer = (NodePointer)((NodePointer)context.getContextNodePointer()).clone();\n+        NodePointer ptr = (NodePointer)context.getContextNodePointer();\n+        if (ptr == null || !(ptr instanceof PropertyOwnerPointer)){\n+            return FAILURE;\n+        }\n+        PropertyOwnerPointer pointer = (PropertyOwnerPointer)ptr.clone();\n         for (int i = 0; i < steps.length; i++){\n             String propertyName = ((NodeNameTest)steps[i]).getNodeName().getName();\n             pointer = pointer.getPropertyPointer();\n             else {\n                 return FAILURE;\n             }\n-//            pointer = ptr;\n         }\n         return pointer;\n     }\n                 case Compiler.AXIS_ANCESTOR_OR_SELF:\n                     return new AncestorContext(context, true, name);\n                 case Compiler.AXIS_ATTRIBUTE:\n-                    break;\n+                    return new AttributeContext(context, name);\n                 case Compiler.AXIS_CHILD:\n                     return new ChildContext(context, name, false, false);\n                 case Compiler.AXIS_DESCENDANT:\n                 case Compiler.AXIS_ANCESTOR_OR_SELF:\n                     return new AncestorContext(context, true, null);\n                 case Compiler.AXIS_ATTRIBUTE:\n-                    break;\n+                    return new AttributeContext(context, null);\n                 case Compiler.AXIS_CHILD:\n                     return new ChildContext(context, null, false, false);\n                 case Compiler.AXIS_DESCENDANT:\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.axes.*;\n import java.lang.ref.SoftReference;\n+import org.w3c.dom.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n                     break;\n                 }\n             }\n+        }\n+        if (result instanceof Node){\n+            result = EvalContext.stringValue((Node)result);\n         }\n         return result;\n     }\n         Functions funcs;\n         while (funcCtx != null){\n             funcs = funcCtx.getFunctions();\n-            func = funcs.getFunction(namespace, name, parameters);\n-            if (func != null){\n-                return func;\n-            }\n-\n-            funcCtx = funcCtx.getParentContext();\n+            if (funcs != null){\n+                func = funcs.getFunction(namespace, name, parameters);\n+                if (func != null){\n+                    return func;\n+                }\n+\n+                funcCtx = funcCtx.getParentContext();\n+            }\n+            else {\n+                break;\n+            }\n         }\n         func = genericFunctions.getFunction(namespace, name, parameters);\n         if (func != null){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class AncestorContext extends EvalContext {\n     private QName nameTest;\n     public boolean nextIgnoreDuplicates(){\n         if (!setStarted){\n             setStarted = true;\n-            currentNodePointer = (NodePointer)parentContext.getContextNodePointer();\n+            currentNodePointer = parentContext.getCurrentNodePointer();\n             if (includeSelf){\n                 if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n                     return true;\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.1 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:30 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.axes;\n+\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.pointers.*;\n+\n+import java.util.*;\n+\n+/**\n+ * EvalContext that walks the \"attribute::\" axis.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:30 $\n+ */\n+public class AttributeContext extends EvalContext {\n+    private QName nameTest;\n+    private boolean setStarted = false;\n+    private boolean started = false;\n+    private DOMAttributeIterator iterator;\n+    private NodePointer currentNodePointer;\n+\n+    /**\n+     * @param parentContext represents the previous step on the path\n+     * @param nameTest is the name of the attribute we are looking for\n+     */\n+    public AttributeContext(EvalContext parentContext, QName nameTest){\n+        super(parentContext);\n+        if (nameTest != null && !nameTest.getName().equals(\"*\")){\n+            this.nameTest = nameTest;\n+        }\n+        reset();\n+    }\n+\n+    public NodePointer getCurrentNodePointer(){\n+        return currentNodePointer;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (position < this.position){\n+            reset();\n+        }\n+\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean nextSet(){\n+        reset();\n+\n+        // First time this method is called, we should look for\n+        // the first parent set that contains at least one node.\n+        if (!started){\n+            started = true;\n+            while (parentContext.nextSet()){\n+                if (parentContext.next()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        // In subsequent calls, we see if the parent context\n+        // has any nodes left in the current set\n+        if (parentContext.next()){\n+            return true;\n+        }\n+\n+        // If not, we look for the next set that contains\n+        // at least one node\n+        while (parentContext.nextSet()){\n+            if (parentContext.next()){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean next(){\n+        if (!setStarted){\n+            setStarted = true;\n+            if (nameTest != null){\n+                currentNodePointer = parentContext.getCurrentNodePointer().attributePointer(nameTest);\n+                return currentNodePointer != null;\n+            }\n+            else {\n+                iterator = new DOMAttributeIterator(parentContext.getCurrentNodePointer());\n+            }\n+        }\n+\n+        if (iterator == null){\n+            return false;\n+        }\n+        if (!iterator.setPosition(iterator.getPosition() + 1)){\n+            return false;\n+        }\n+        currentNodePointer = iterator.getNodePointer();\n+        return true;\n+    }\n+\n+    /**\n+     * Back to position=0\n+     */\n+    protected void reset(){\n+        super.reset();\n+        setStarted = false;\n+        iterator = null;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class ChildContext extends EvalContext {\n     private boolean started = false;\n     private QName property;\n-    boolean startFromParentLocation;\n-    boolean reverse;\n-    private PropertyIterator iterator;\n+    private boolean startFromParentLocation;\n+    private boolean reverse;\n+    private NodeIterator iterator;\n+    private boolean firstIteration = true;\n+    private int parentCount;\n+    private NodePointer singleParentPointer;\n \n     public ChildContext(EvalContext parentContext, QName property, boolean startFromParentLocation, boolean reverse){\n         super(parentContext);\n     }\n \n     public NodePointer getCurrentNodePointer(){\n-        return iterator.getCurrentNodePointer();\n+        return iterator.getNodePointer();\n     }\n \n     /**\n      * of books rather than the first book from that collection.\n      */\n     public Pointer getContextNodePointer(){\n-        if (iterator == null){\n-            boolean ok = false;\n-            while(parentContext.nextSet()){\n-                if (parentContext.next()){\n-                    ok = true;\n-                    break;\n-                }\n+        Pointer ptr = super.getContextNodePointer();\n+        if (parentCount != 1){\n+            return ptr;\n+        }\n+        else {\n+            if (startFromParentLocation){\n+                // TBD: check type\n+                iterator = singleParentPointer.siblingIterator(property, reverse);\n             }\n-            if (!ok){\n-                return null;\n+            else {\n+                iterator = singleParentPointer.childIterator(property, reverse);\n             }\n-            prepare();\n+            return iterator.getNodePointer();\n         }\n-        return iterator.getFirstNodePointer();\n     }\n \n     public boolean next(){\n         if (iterator == null){\n             prepare();\n         }\n-        return iterator.next();\n+        return iterator.setPosition(iterator.getPosition() + 1);\n     }\n \n     public boolean setPosition(int position){\n     }\n \n     public int getCurrentPosition(){\n-        return iterator.getCurrentPosition();\n+        return iterator.getPosition();\n     }\n \n     public boolean nextSet(){\n             started = true;\n             while (parentContext.nextSet()){\n                 if (parentContext.next()){\n+                    parentCount++;\n+                    singleParentPointer = parentContext.getCurrentNodePointer();\n                     return true;\n                 }\n             }\n         // In subsequent calls, we see if the parent context\n         // has any nodes left in the current set\n         if (parentContext.next()){\n+                    parentCount++;\n+                    singleParentPointer = parentContext.getCurrentNodePointer();\n             return true;\n         }\n \n         // at least one node\n         while (parentContext.nextSet()){\n             if (parentContext.next()){\n+                    parentCount++;\n+                    singleParentPointer = parentContext.getCurrentNodePointer();\n                 return true;\n             }\n         }\n      * Allocates a PropertyIterator.\n      */\n     private void prepare(){\n-        String name;\n-        if (property == null || property.getName().equals(\"*\")){\n-            name = null;\n+        NodePointer parent = parentContext.getCurrentNodePointer();\n+        if (startFromParentLocation){\n+            // TBD: check type\n+            iterator = parent.siblingIterator(property, reverse);\n         }\n         else {\n-            name = property.getName();\n-        }\n-        if (startFromParentLocation){\n-            // TBD: check type\n-            PropertyPointer parent = (PropertyPointer)parentContext.getCurrentNodePointer();\n-            iterator = PropertyIterator.iteratorStartingAt(parent, name, reverse);\n-        }\n-        else {\n-            iterator = PropertyIterator.iterator(parentContext.getCurrentNodePointer(), name, reverse);\n+            iterator = parent.childIterator(property, reverse);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class DescendantContext extends EvalContext {\n     private QName nameTest;\n         if (!setStarted){\n             setStarted = true;\n             currentNodePointer = parentContext.getCurrentNodePointer();\n-            if (!currentNodePointer.isAtomic()){\n-                stack.push(PropertyIterator.iterator(currentNodePointer, null, false));\n+            if (!currentNodePointer.isLeaf()){\n+                stack.push(currentNodePointer.childIterator(null, false));\n             }\n             if (includeSelf){\n                 if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n         }\n \n         while (!stack.isEmpty()){\n-            PropertyIterator it = (PropertyIterator)stack.peek();\n-            if (it.next()){\n-                currentNodePointer = it.getCurrentNodePointer();\n-                if (!currentNodePointer.isAtomic()){\n-                    stack.push(PropertyIterator.iterator(currentNodePointer, null, false));\n+            NodeIterator it = (NodeIterator)stack.peek();\n+            if (it.setPosition(it.getPosition() + 1)){\n+                currentNodePointer = it.getNodePointer();\n+                if (!currentNodePointer.isLeaf()){\n+                    stack.push(currentNodePointer.childIterator(null, false));\n                 }\n                 if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n                     position++;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private QName nameTest;\n             setStarted = true;\n             currentRootLocation = parentContext.getCurrentNodePointer();\n             // TBD: check type\n-            stack.push(PropertyIterator.iteratorStartingAt((PropertyPointer)currentRootLocation, null, reverse));\n+            stack.push(currentRootLocation.siblingIterator(null, reverse));\n         }\n \n         while (true){\n                 }\n //                System.err.println(\"PUSHING: \" + currentRootLocation);\n                 // TBD: check type\n-                stack.push(PropertyIterator.iteratorStartingAt((PropertyPointer)currentRootLocation, null, reverse));\n+                stack.push(currentRootLocation.siblingIterator(null, reverse));\n             }\n \n             while (!stack.isEmpty()){\n                 if (!reverse){\n                     PropertyIterator it = (PropertyIterator)stack.peek();\n-                    if (it.next()){\n-                        currentNodePointer = it.getCurrentNodePointer();\n-                        if (!currentNodePointer.isAtomic()){\n-                            stack.push(PropertyIterator.iterator(currentNodePointer, null, reverse));\n+                    if (it.setPosition(it.getPosition() + 1)){\n+                        currentNodePointer = it.getNodePointer();\n+                        if (!currentNodePointer.isLeaf()){\n+                            stack.push(currentNodePointer.childIterator(null, reverse));\n                         }\n                         if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n                             position++;\n                 }\n                 else {\n                     PropertyIterator it = (PropertyIterator)stack.peek();\n-                    if (it.next()){\n-                        currentNodePointer = it.getCurrentNodePointer();\n-                        if (!currentNodePointer.isAtomic()){\n-                            stack.push(PropertyIterator.iterator(currentNodePointer, null, reverse));\n+                    if (it.setPosition(it.getPosition() + 1)){\n+                        currentNodePointer = it.getNodePointer();\n+                        if (!currentNodePointer.isLeaf()){\n+                            stack.push(currentNodePointer.childIterator(null, reverse));\n                         }\n                         else if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n                             position++;\n                         stack.pop();\n                         if (!stack.isEmpty()){\n                             it = (PropertyIterator)stack.peek();\n-                            currentNodePointer = it.getCurrentNodePointer();\n+                            currentNodePointer = it.getNodePointer();\n                             if (nameTest == null || nameTest.equals(currentNodePointer.getName())){\n                                 position++;\n                                 return true;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.2 2001/09/03 01:22:30 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:30 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:30 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n             return false;\n         }\n         while (parentContext.next()){\n-            if (dynamicPropertyNameExpression != null){\n-                dynamicPropertyPointer = parentContext.getCurrentNodePointer().getPropertyPointer();\n+            if (setupDynamicPropertyPointer()){\n                 Object pred = parentContext.eval(dynamicPropertyNameExpression);\n                 if (pred instanceof NodePointer){\n                     pred = ((NodePointer)pred).getValue();\n         return false;\n     }\n \n+    /**\n+     * Used for an optimized access to dynamic properties using the\n+     * \"map[@name = 'name']\" syntax\n+     */\n+    private boolean setupDynamicPropertyPointer(){\n+        if (dynamicPropertyNameExpression == null){\n+            return false;\n+        }\n+\n+        NodePointer parent = parentContext.getCurrentNodePointer();\n+        if (!(parent instanceof PropertyOwnerPointer)){\n+            return false;\n+        }\n+        dynamicPropertyPointer = ((PropertyOwnerPointer)parentContext.getCurrentNodePointer()).getPropertyPointer();\n+        return true;\n+    }\n+\n     public NodePointer getCurrentNodePointer(){\n         if (dynamicPropertyPointer != null){\n             return dynamicPropertyPointer;\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a path, following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n-public class BeanPointer extends NodePointer {\n+public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     private Object bean;\n     private JXPathBeanInfo beanInfo;\n     private PropertyDescriptor propertyDescriptors[];\n     private String[] names;\n \n+    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo){\n+        this(null, name, bean, beanInfo);\n+    }\n+\n     /**\n      * @param name is the name given to the first node\n      */\n-    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo){\n-        super(null);\n+    public BeanPointer(NodePointer parent, QName name, Object bean, JXPathBeanInfo beanInfo){\n+        super(parent);\n         this.name = name;\n         this.bean = bean;\n         this.beanInfo = beanInfo;\n     /**\n      * Returns the bean itself\n      */\n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return bean;\n     }\n \n      * otherwise returns 1.\n      */\n     public int getLength(){\n-        return PropertyAccessHelper.getLength(getPropertyValue());\n+        return PropertyAccessHelper.getLength(getBaseValue());\n     }\n \n     public int hashCode(){\n      * Empty string\n      */\n     public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n         return \"\";\n     }\n \n     public Object clone(){\n         BeanPointer pointer = new BeanPointer(name, bean, beanInfo);\n         pointer.index = index;\n-        pointer.value = value;\n+//        pointer.value = value;\n         pointer.propertyDescriptors = propertyDescriptors;\n         pointer.names = names;\n         return pointer;\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private JXPathBeanInfo beanInfo;\n      * Select a property by name\n      */\n     public void setPropertyName(String propertyName){\n-        setPropertyIndex(UNSPECIFIED);\n+        setPropertyIndex(UNSPECIFIED_PROPERTY);\n         String[] names = getPropertyNames();\n         for (int i = 0; i < names.length; i++){\n             if (names[i].equals(propertyName)){\n         if (propertyIndex != index){\n             super.setPropertyIndex(index);\n             propertyDescriptor = null;\n-            value = UNKNOWN;\n         }\n     }\n \n     /**\n      * The value of the currently selected property.\n      */\n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null){\n             return null;\n      * and the value will be the property itself.\n      */\n     public Object getValue(){\n-        if (value == UNKNOWN){\n-            PropertyDescriptor pd = getPropertyDescriptor();\n-            if (pd == null){\n-                value = null;\n+        Object value;\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            value = null;\n+        }\n+        else {\n+            if (index == WHOLE_COLLECTION){\n+                value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor());\n             }\n             else {\n-                if (index == WHOLE_COLLECTION){\n-                    value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor());\n-                }\n-                else {\n-                    value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor(), index);\n-                }\n+                value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor(), index);\n             }\n         }\n         return value;\n      * represented by the property.\n      */\n     public void setValue(Object value){\n-        this.value = value;\n         if (index == WHOLE_COLLECTION){\n             PropertyAccessHelper.setValue(getBean(), getPropertyDescriptor(), value);\n         }\n         return pd.getName();\n     }\n \n-    public PropertyPointer copy(){\n+    public Object clone(){\n         BeanPropertyPointer newHolder = new BeanPropertyPointer(getParent(), beanInfo);\n         newHolder.propertyIndex = propertyIndex;\n         newHolder.propertyDescriptors = propertyDescriptors;\n         newHolder.propertyDescriptor = propertyDescriptor;\n         newHolder.names = names;\n         newHolder.bean = bean;\n-        newHolder.value = value;\n         newHolder.index = index;\n         return newHolder;\n-    }\n-\n-    public Object clone(){\n-        return copy();\n     }\n \n     /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Transparent pointer to a Container. The getValue() method\n+ * returns the contents of the container, rather than the container\n+ * itself.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class ContainerPointer extends NodePointer {\n+    private Container container;\n+    private NodePointer valuePointer;\n+\n+    public ContainerPointer(Container container){\n+        this(null, container);\n+    }\n+\n+    public ContainerPointer(NodePointer parent, Container container){\n+        super(parent);\n+        this.container = container;\n+    }\n+\n+    public QName getName(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return container.getValue();\n+    }\n+\n+    public Object getValue(){\n+        Object value = getBaseValue();\n+        if (index != WHOLE_COLLECTION){\n+            return PropertyAccessHelper.getValue(value, index);\n+        }\n+        return value;\n+    }\n+\n+    public void setValue(Object value){\n+        container.setValue(value);\n+    }\n+\n+    private NodePointer getValuePointer(){\n+        if (valuePointer == null){\n+            Object value = getValue();\n+            valuePointer = NodePointer.createNodePointer(this, null, value);\n+        }\n+        return valuePointer;\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(container) + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof ContainerPointer)){\n+            return false;\n+        }\n+\n+        ContainerPointer other = (ContainerPointer)object;\n+        return container == other.container &&\n+                index == other.index;\n+    }\n+\n+    public String toString(){\n+        return asPath();\n+    }\n+\n+    public Object clone(){\n+        ContainerPointer pointer = new ContainerPointer(parent, container);\n+        return pointer;\n+    }\n+\n+    public NodeIterator childIterator(QName name, boolean reverse){\n+        return getValuePointer().childIterator(name, reverse);\n+    }\n+\n+    public NodeIterator siblingIterator(QName name, boolean reverse){\n+        return getValuePointer().siblingIterator(name, reverse);\n+    }\n+\n+    public NodeIterator attributeIterator(){\n+        return getValuePointer().attributeIterator();\n+    }\n+\n+    public NodePointer attributePointer(QName name){\n+        return getValuePointer().attributePointer(name);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of children of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class DOMAttributeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private NamedNodeMap attributes;\n+    private int position = 0;\n+\n+    public DOMAttributeIterator(NodePointer parent){\n+        this.parent = parent;\n+        attributes = ((Node)parent.getValue()).getAttributes();\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        return new DOMAttributePointer(parent, (Attr)attributes.item(index));\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position >= 1 && position <= attributes.getLength();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributePointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class DOMAttributePointer extends NodePointer {\n+    private Attr attr;\n+\n+    public DOMAttributePointer(NodePointer parent, Attr attr){\n+        super(parent);\n+        this.attr = attr;\n+    }\n+\n+    public QName getName(){\n+        return new QName(attr.getNamespaceURI(), attr.getNodeName());\n+    }\n+\n+    public NodeIterator childIterator(QName name, boolean reverse){\n+        return null;\n+    }\n+\n+    public NodeIterator siblingIterator(QName name, boolean reverse){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return attr;\n+    }\n+\n+    public Object getValue(){\n+        String value = attr.getValue();\n+        if (value == null){\n+            return null;\n+        }\n+        if (value.equals(\"\") && !attr.getSpecified()){\n+            return null;\n+        }\n+        return value;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n+    }\n+\n+    /**\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append('@');\n+        buffer.append(getName().asString());\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(attr);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DOMAttributePointer)){\n+            return false;\n+        }\n+\n+        DOMAttributePointer other = (DOMAttributePointer)object;\n+        return attr == other.attr;\n+    }\n+\n+    public String toString(){\n+        return attr.toString();\n+    }\n+\n+    public Object clone(){\n+        DOMAttributePointer pointer = new DOMAttributePointer(parent, attr);\n+        return pointer;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of children of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class DOMNodeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private QName name;\n+    private Node node;\n+    private Node child = null;\n+    private boolean children;\n+    private boolean reverse;\n+    private int position = 0;\n+\n+    public DOMNodeIterator(NodePointer parent, boolean children, QName name, boolean reverse){\n+        this.parent = parent;\n+        this.children = children;\n+        this.node = (Node)parent.getValue();\n+        this.name = name;\n+        this.reverse = reverse;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (child == null){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+\n+        if (children){\n+            return new DOMNodePointer(parent, child);\n+        }\n+        else {\n+            return new DOMNodePointer(parent.getParent(), child);\n+        }\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        while (this.position > position){\n+            if (!previous()){\n+                return false;\n+            }\n+        }\n+//        System.err.println(getNodePointer().asPath() + \" SET POSITION: \" + position);\n+        return true;\n+    }\n+\n+    private boolean previous(){\n+        position--;\n+        if (!reverse){\n+            child = child.getPreviousSibling();\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        else {\n+            child = child.getNextSibling();\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean next(){\n+        position++;\n+        if (!reverse){\n+            if (position == 1){\n+                if (children){\n+                    child = node.getFirstChild();\n+                }\n+                else {\n+                    child = node.getNextSibling();\n+                }\n+            }\n+            else {\n+                child = child.getNextSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        else {\n+            if (position == 1){\n+                if (children){\n+                    child = node.getLastChild();\n+                }\n+                else {\n+                    child = node.getPreviousSibling();\n+                }\n+            }\n+            else {\n+                child = child.getPreviousSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean testChild(){\n+        if (name == null){\n+            return true;\n+        }\n+        String ns = child.getNamespaceURI();\n+        String nodeName = child.getNodeName();\n+        if (nodeName != null && nodeName.equals(name.getName())){\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodePointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class DOMNodePointer extends NodePointer {\n+    private Node node;\n+\n+    public DOMNodePointer(Node node){\n+        super(null);\n+        this.node = node;\n+    }\n+\n+    public DOMNodePointer(NodePointer parent, Node node){\n+        super(parent);\n+        this.node = node;\n+    }\n+\n+    public QName getName(){\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            return new QName(node.getNamespaceURI(), node.getNodeName());\n+        }\n+        return null;\n+    }\n+\n+    public NodeIterator childIterator(QName name, boolean reverse){\n+        return new DOMNodeIterator(this, true, name, reverse);\n+    }\n+\n+    public NodeIterator siblingIterator(QName name, boolean reverse){\n+        return new DOMNodeIterator(this, false, name, reverse);\n+    }\n+\n+    public NodePointer attributePointer(QName name){\n+        NamedNodeMap map = node.getAttributes();\n+        Node attr;\n+        if (name.getPrefix() == null){\n+            attr = map.getNamedItem(name.getName());\n+        }\n+        else {\n+            attr = map.getNamedItemNS(name.getPrefix(), name.getName());\n+        }\n+        if (attr == null){\n+            return null;\n+        }\n+        else {\n+            return new DOMAttributePointer(this, (Attr)attr);\n+        }\n+    }\n+\n+    public Object getBaseValue(){\n+        return node;\n+    }\n+\n+    public Object getValue(){\n+        return node;\n+    }\n+\n+    public boolean isLeaf(){\n+        return !node.hasChildNodes();\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n+    }\n+\n+    /**\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+        }\n+        switch(node.getNodeType()){\n+            case Node.ELEMENT_NODE:\n+                buffer.append('/');\n+                buffer.append(getName().asString());\n+                buffer.append('[').append(getRelativePositionByName()).append(']');\n+                break;\n+            case Node.TEXT_NODE:\n+            case Node.CDATA_SECTION_NODE:\n+                // TBD: position\n+                buffer.append(\"/self::text()\");\n+                break;\n+            case Node.PROCESSING_INSTRUCTION_NODE:\n+                // TBD: position\n+                String target = ((ProcessingInstruction)node).getTarget();\n+                buffer.append(\"/self::processing-instruction(\").append(target).append(')');\n+                break;\n+            case Node.DOCUMENT_NODE:\n+                // That'll be empty\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private int getRelativePositionByName(){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.ELEMENT_NODE){\n+                String ns = n.getNamespaceURI();\n+                String nm = n.getNodeName();\n+                if ((ns != null && ns.equals(node.getNamespaceURI())) ||\n+                    (ns == null && node.getNamespaceURI() == null)){\n+                    if ((nm != null && nm.equals(node.getNodeName())) ||\n+                        (nm == null && node.getNodeName() == null)){\n+                        count ++;\n+                    }\n+                }\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(node);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DOMNodePointer)){\n+            return false;\n+        }\n+\n+        DOMNodePointer other = (DOMNodePointer)object;\n+        return node == other.node;\n+    }\n+\n+    public String toString(){\n+        return node.toString();\n+    }\n+\n+    public Object clone(){\n+        DOMNodePointer pointer = new DOMNodePointer(parent, node);\n+        return pointer;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * for the first element of a path; following elements will by of type PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n-public class DynamicPointer extends NodePointer {\n+public class DynamicPointer extends PropertyOwnerPointer {\n     private QName name;\n     private Object bean;\n     private DynamicPropertyHandler handler;\n     private String[] names;\n \n     public DynamicPointer(QName name, Object bean, DynamicPropertyHandler handler){\n-        super(null);\n+        this(null, name, bean, handler);\n+    }\n+\n+    public DynamicPointer(NodePointer parent, QName name, Object bean, DynamicPropertyHandler handler){\n+        super(parent);\n         this.name = name;\n         this.bean = bean;\n         this.handler = handler;\n     /**\n      * Returns the DP object iself.\n      */\n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return bean;\n     }\n \n      * otherwise returns 1.\n      */\n     public int getLength(){\n-        return PropertyAccessHelper.getLength(getPropertyValue());\n+        return PropertyAccessHelper.getLength(getBaseValue());\n     }\n \n     /**\n      * Empty string\n      */\n     public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n         return \"\";\n     }\n \n     public Object clone(){\n         DynamicPointer pointer = new DynamicPointer(name, bean, handler);\n         pointer.index = index;\n-        pointer.value = value;\n         pointer.names = names;\n         return pointer;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n      * value, call setValue().\n      */\n     public void setPropertyName(String propertyName){\n-        setPropertyIndex(UNSPECIFIED);\n+        setPropertyIndex(UNSPECIFIED_PROPERTY);\n         this.name = propertyName;\n         requiredPropertyName = propertyName;\n         if (names != null && Arrays.binarySearch(names, propertyName) < 0){\n      * properties sorted alphabetically.\n      */\n     public int getPropertyIndex(){\n-        if (propertyIndex == UNSPECIFIED){\n+        if (propertyIndex == UNSPECIFIED_PROPERTY){\n             String names[] = getPropertyNames();\n             for (int i = 0; i < names.length; i++){\n                 if (names[i].equals(name)){\n         if (propertyIndex != index){\n             super.setPropertyIndex(index);\n             name = null;\n-            value = UNKNOWN;\n         }\n     }\n \n      * Returns the value of the property, not an element of the collection\n      * represented by the property, if any.\n      */\n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return handler.getProperty(getBean(), getPropertyName());\n     }\n \n      * and the value will be the property itself.\n      */\n     public Object getValue(){\n-        if (value == UNKNOWN){\n-            if (index == WHOLE_COLLECTION){\n-                value = handler.getProperty(getBean(), getPropertyName());\n-            }\n-            else {\n-                value = PropertyAccessHelper.getValue(handler.getProperty(getBean(), getPropertyName()), index);\n-            }\n+        Object value;\n+        if (index == WHOLE_COLLECTION){\n+            value = handler.getProperty(getBean(), getPropertyName());\n+        }\n+        else {\n+            value = PropertyAccessHelper.getValue(handler.getProperty(getBean(), getPropertyName()), index);\n         }\n         return value;\n     }\n      * represented by the property.\n      */\n     public void setValue(Object value){\n-        this.value = value;\n         if (index == WHOLE_COLLECTION){\n             handler.setProperty(getBean(), getPropertyName(), value);\n         }\n         }\n     }\n \n-    public PropertyPointer copy(){\n+    public Object clone(){\n         DynamicPropertyPointer newHolder = new DynamicPropertyPointer(getParent(), handler);\n         newHolder.propertyIndex = propertyIndex;\n         newHolder.name = name;\n         newHolder.names = names;\n         newHolder.bean = bean;\n-        newHolder.value = value;\n         newHolder.index = index;\n         return newHolder;\n-    }\n-\n-    public Object clone(){\n-        return copy();\n     }\n \n     public String asPath(){\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodeIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+/**\n+ * Definition for an iterator for all kinds of Nodes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public interface NodeIterator {\n+\n+    int getPosition();\n+\n+    /**\n+     * Sets the new current position and returns true if there a node\n+     * at that position.\n+     */\n+    boolean setPosition(int position);\n+\n+    NodePointer getNodePointer();\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.*;\n import java.util.*;\n import java.beans.*;\n+import org.w3c.dom.Node;\n \n /**\n+ * Common superclass for Poitners of all kinds.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable {\n+\n+    public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n+    protected int index = WHOLE_COLLECTION;\n \n     public static NodePointer createNodePointer(QName name, Object bean){\n         if (bean == null){\n             return new NullPointer(name);\n+        }\n+        if (bean instanceof Node){\n+            return new DOMNodePointer((Node)bean);\n+        }\n+        if (bean instanceof Container){\n+            return new ContainerPointer((Container)bean);\n         }\n \n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         }\n     }\n \n-    public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n-    public static int UNSPECIFIED = Integer.MIN_VALUE;\n-    protected static Object UNKNOWN = new Object();\n+    public static NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean == null){\n+            return new NullPointer(parent, name);\n+        }\n+        if (bean instanceof Node){\n+            return new DOMNodePointer(parent, (Node)bean);\n+        }\n+        if (bean instanceof Container){\n+            return new ContainerPointer(parent, (Container)bean);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(parent, name, bean, handler);\n+        }\n+        else {\n+            return new BeanPointer(parent, name, bean, bi);\n+        }\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all children or all children\n+     * with the given name.\n+     */\n+    public abstract NodeIterator childIterator(QName name, boolean reverse);\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all siblings or all siblings\n+     * with the given name starting with this pointer and excluding the value\n+     * currently pointed at.\n+     */\n+    public abstract NodeIterator siblingIterator(QName name, boolean reverse);\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all attributes of the value\n+     * currently pointed at.\n+     * May return null if the object does not support the attributes.\n+     */\n+    public NodeIterator attributeIterator(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodePointer for the specified attribute. May return null\n+     * if attributes are not supported or if there is no such attribute.\n+     */\n+    public NodePointer attributePointer(QName attribute){\n+        return null;\n+    }\n \n     protected NodePointer parent;\n-    protected int index = WHOLE_COLLECTION;\n-    protected Object value = UNKNOWN;\n \n     protected NodePointer(NodePointer parent){\n         this.parent = parent;\n         return parent;\n     }\n \n+    public boolean isRoot(){\n+        return parent == null;\n+    }\n+\n+    /**\n+     * If true, this node does not have children\n+     */\n+    public boolean isLeaf(){\n+        Object value = getValue();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+    }\n+\n     public int getIndex(){\n         return index;\n     }\n \n     public void setIndex(int index){\n         this.index = index;\n-        this.value = UNKNOWN;\n-    }\n-\n-    public boolean isRoot(){\n-        return parent == null;\n-    }\n-\n-    public boolean isAtomic(){\n-        Object value = getValue();\n-        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n-    }\n-\n-    public boolean isDynamic(){\n-        Object value = getValue();\n-        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isDynamic();\n     }\n \n     public boolean isCollection(){\n-        Object value = getPropertyValue();\n+        Object value = getBaseValue();\n         return value != null && PropertyAccessHelper.isCollection(value);\n     }\n \n-    public Object getValue(){\n-        if (value == UNKNOWN){\n-            if (index == WHOLE_COLLECTION){\n-                value = getPropertyValue();\n+    public int getLength(){\n+        Object value = getBaseValue();\n+        if (value == null){\n+            return 1;\n+        }\n+        return PropertyAccessHelper.getLength(value);\n+    }\n+\n+    public abstract QName getName();\n+    public abstract Object getBaseValue();\n+    public abstract void setValue(Object value);\n+    public abstract Object clone();\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (getParent() != null){\n+            buffer.append(getParent().asPath());\n+        }\n+        QName name = getName();\n+        if (name != null){\n+            if (getParent() != null){\n+                buffer.append('/');\n             }\n-            else {\n-                value = PropertyAccessHelper.getValue(getPropertyValue(), index);\n-            }\n-        }\n-        return value;\n-    }\n-\n-    public abstract QName getName();\n-    public abstract void setValue(Object value);\n-    public abstract String asPath();\n-    public abstract Object clone();\n-\n-    public PropertyPointer getPropertyPointer(){\n-        Object value = getValue();\n-        if (value == null){\n-            return new NullPropertyPointer(this);\n-        }\n-\n-        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(value.getClass());\n-        if (bi.isDynamic()){\n-            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n-            return new DynamicPropertyPointer(this, handler);\n-        }\n-        else {\n-            return new BeanPropertyPointer(this, bi);\n-        }\n-    }\n-\n-    public abstract Object getPropertyValue();\n-    public abstract int getLength();\n+            buffer.append(name.asString());\n+        }\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n-public class NullPointer extends NodePointer {\n+public class NullPointer extends PropertyOwnerPointer {\n     private QName name;\n+\n+    public NullPointer(QName name){\n+        this(null, name);\n+    }\n \n     /**\n      * Used for the root node\n      */\n-    public NullPointer(QName name){\n-        super(null);\n+    public NullPointer(NodePointer parent, QName name){\n+        super(parent);\n         this.name = name;\n     }\n \n         return name;\n     }\n \n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return null;\n     }\n \n     }\n \n     public String asPath(){\n-        System.err.println(\"NULL POINTER\");\n+        if (parent != null){\n+            return super.asPath();\n+        }\n         return \"\";\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n         return 0;\n     }\n \n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return null;\n     }\n \n         return new String[0];\n     }\n \n-    public PropertyPointer copy(){\n+    public Object clone(){\n         NullPropertyPointer newHolder = new NullPropertyPointer(getParent());\n         newHolder.propertyName = propertyName;\n         return newHolder;\n     }\n-\n-    public Object clone(){\n-        return copy();\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyIterator.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+/**\n+ * Iterates property values of an object pointed at with a PropertyOwnerPointer.\n+ * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class PropertyIterator implements NodeIterator {\n+    boolean empty = false;\n+    private boolean reverse;\n+    private String name;\n+    private int startIndex = 0;\n+    private boolean targetReady = false;\n+    private int position = 0;\n+    private PropertyPointer propertyNodePointer;\n+    private int startPropertyIndex;\n+    private boolean firstIteration = true;\n+\n+    private boolean ready = false;\n+    private boolean includeStart = false;\n+\n+    public PropertyIterator(PropertyOwnerPointer pointer, boolean children, String name, boolean reverse){\n+        if (children){\n+            propertyNodePointer = pointer.getPropertyPointer();\n+            this.name = name;\n+            this.reverse = reverse;\n+            this.includeStart = true;\n+            if (reverse){\n+                this.startPropertyIndex = -1;\n+                this.startIndex = -1;\n+            }\n+        }\n+        else {\n+            this.propertyNodePointer = (PropertyPointer)pointer.clone();\n+            this.name = name;\n+            this.reverse = reverse;\n+            this.startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            this.startIndex = propertyNodePointer.getIndex();\n+            this.includeStart = false;\n+            if (reverse && startIndex == -1){\n+                this.includeStart = true;\n+            }\n+        }\n+    }\n+\n+    public void reset(){\n+        position = 0;\n+        targetReady = false;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (firstIteration){\n+            firstIteration = false;\n+            if (name != null){\n+                if (!targetReady){\n+                    prepare();\n+                }\n+                // If there is no such property - return null\n+                if (empty){\n+                    return null;\n+                }\n+            }\n+            else {\n+                if (!setPosition(1)){\n+                    return null;\n+                }\n+                reset();\n+            }\n+        }\n+        return propertyNodePointer.childNodePointer();\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        firstIteration = false;\n+        if (name != null){\n+            return setPositionIndividual(position);\n+        }\n+        else {\n+            return setPositionMultiple(position);\n+        }\n+    }\n+\n+    private boolean setPositionIndividual(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        if (!targetReady){\n+            prepare();\n+        }\n+\n+        if (empty){\n+            return false;\n+        }\n+\n+        int length = propertyNodePointer.getLength();\n+        int index;\n+        if (!reverse){\n+            index = position + startIndex;\n+            if (!includeStart){\n+                index++;\n+            }\n+            if (index > length){\n+                return false;\n+            }\n+        }\n+        else {\n+            int end = startIndex;\n+            if (end == -1){\n+                end = length - 1;\n+            }\n+            index = end - position + 2;\n+            if (!includeStart){\n+                index--;\n+            }\n+            if (index < 1){\n+                return false;\n+            }\n+        }\n+        propertyNodePointer.setIndex(index - 1);\n+        return true;\n+    }\n+\n+    private boolean setPositionMultiple(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        int offset;\n+        int count = propertyNodePointer.getPropertyCount();\n+        if (!reverse){\n+            int index = 1;\n+            for (int i = startPropertyIndex; i < count; i++){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    length -= startIndex;\n+                    if (!includeStart){\n+                        length--;\n+                    }\n+                    offset = startIndex + position - index;\n+                    if (!includeStart){\n+                        offset++;\n+                    }\n+                }\n+                else {\n+                    offset = position - index;\n+                }\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        else {\n+            int index = 1;\n+            int start = startPropertyIndex;\n+            if (start == -1){\n+                start = count - 1;\n+            }\n+            for (int i = start; i >= 0; i--){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    int end = startIndex;\n+                    if (end == -1){\n+                        end = length - 1;\n+                    }\n+                    length = end + 1;\n+                    offset = end - position + 1;\n+                    if (!includeStart){\n+                        offset--;\n+                        length--;\n+                    }\n+                }\n+                else {\n+                    offset = length - (position - index) - 1;\n+                }\n+\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void prepare(){\n+        targetReady = true;\n+        empty = true;\n+        if (propertyNodePointer instanceof DynamicPropertyPointer){\n+            propertyNodePointer.setPropertyName(name);\n+        }\n+\n+        String names[] = propertyNodePointer.getPropertyNames();\n+        if (!reverse){\n+            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == PropertyOwnerPointer.UNSPECIFIED_PROPERTY){\n+                startPropertyIndex = 0;\n+            }\n+            if (propertyNodePointer.getIndex() == NodePointer.WHOLE_COLLECTION){\n+                startIndex = 0;\n+            }\n+            for (int i = startPropertyIndex; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = 0;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+        else {\n+            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == PropertyOwnerPointer.UNSPECIFIED_PROPERTY){\n+                startPropertyIndex = names.length - 1;\n+            }\n+            if (propertyNodePointer.getIndex() == NodePointer.WHOLE_COLLECTION){\n+                startIndex = -1;\n+            }\n+            for (int i = startPropertyIndex; i >= 0; i--){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = -1;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyOwnerPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyOwnerPointer.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * A pointer describing a node that has properties, each of which could be\n+ * a collection.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public abstract class PropertyOwnerPointer extends NodePointer {\n+\n+    public NodeIterator childIterator(QName name, boolean reverse){\n+        String property;\n+        if (name == null || name.getName().equals(\"*\")){\n+            property = null;\n+        }\n+        else {\n+            property = name.getName();\n+        }\n+        // TBD: qname\n+        return new PropertyIterator(this, true, property, reverse);\n+    }\n+\n+    public NodeIterator siblingIterator(QName name, boolean reverse){\n+        String property;\n+        if (name == null || name.getName().equals(\"*\")){\n+            property = null;\n+        }\n+        else {\n+            property = name.getName();\n+        }\n+        // TBD: qname\n+        return new PropertyIterator(this, false, property, reverse);\n+    }\n+\n+\n+    public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n+\n+    protected PropertyOwnerPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public boolean isCollection(){\n+        Object value = getBaseValue();\n+        return value != null && PropertyAccessHelper.isCollection(value);\n+    }\n+\n+    public Object getValue(){\n+        Object value;\n+        if (index == WHOLE_COLLECTION){\n+            value = getBaseValue();\n+        }\n+        else {\n+            value = PropertyAccessHelper.getValue(getBaseValue(), index);\n+        }\n+        return value;\n+    }\n+\n+    public abstract QName getName();\n+    public abstract void setValue(Object value);\n+    public abstract Object clone();\n+\n+    public PropertyPointer getPropertyPointer(){\n+        Object value = getValue();\n+        if (value == null){\n+            return new NullPropertyPointer(this);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(value.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPropertyPointer(this, handler);\n+        }\n+        else {\n+            return new BeanPropertyPointer(this, bi);\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.*;\n import java.util.*;\n import java.beans.*;\n+import org.w3c.dom.Node;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n-public abstract class PropertyPointer extends NodePointer {\n-    protected int propertyIndex = UNSPECIFIED;\n+public abstract class PropertyPointer extends PropertyOwnerPointer {\n+    protected int propertyIndex = UNSPECIFIED_PROPERTY;\n     protected Object bean;\n \n     /**\n \n     public abstract String[] getPropertyNames();\n \n-    public abstract PropertyPointer copy();\n+    /**\n+     * Returns a NodePointer that can be used to access the currently\n+     * selected property value.\n+     */\n+    public NodePointer childNodePointer(){\n+        Object bean = getValue();\n \n-    public Object clone(){\n-        return copy();\n+        if (bean instanceof Node){\n+            return new DOMNodePointer(this, (Node)bean);\n+        }\n+        else if (bean instanceof Container){\n+            return new ContainerPointer(this, (Container)bean);\n+        }\n+\n+        return (NodePointer)clone();\n     }\n \n     public int hashCode(){\n         buffer.append(\" = \").append(getValue());\n         return buffer.toString();\n     }\n-\n-    public String asPath(){\n-        StringBuffer buffer = new StringBuffer();\n-        if (getParent() != null){\n-            buffer.append(getParent().asPath());\n-            buffer.append('/');\n-        }\n-        buffer.append(getPropertyName());\n-        if (index != WHOLE_COLLECTION && isCollection()){\n-            buffer.append('[').append(index + 1).append(']');\n-        }\n-        return buffer.toString();\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.1 2001/08/23 00:47:00 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.2 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.*;\n import java.util.*;\n import java.beans.*;\n+import org.w3c.dom.Node;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:00 $\n+ * @version $Revision: 1.2 $ $Date: 2001/09/03 01:22:31 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n     private QName name;\n+    private NodePointer valuePointer;\n \n     /**\n      * Used for the root node\n         return name;\n     }\n \n-    public Object getPropertyValue(){\n+    public Object getBaseValue(){\n         return variables.getVariable(name.getName());\n     }\n \n+    public Object getValue(){\n+        Object value = getBaseValue();\n+        if (index != WHOLE_COLLECTION){\n+            return PropertyAccessHelper.getValue(value, index);\n+        }\n+        return value;\n+    }\n+\n     public void setValue(Object value){\n+        valuePointer = null;\n         variables.declareVariable(name.getName(), value);\n     }\n \n-    public int getLength(){\n-        Object value = getPropertyValue();\n-        if (value == null){\n-            return 1;\n+    private NodePointer getValuePointer(){\n+        if (valuePointer == null){\n+            Object value = getValue();\n+            valuePointer = NodePointer.createNodePointer(this, null, value);\n         }\n-        return PropertyAccessHelper.getLength(value);\n+        return valuePointer;\n     }\n \n     public int hashCode(){\n     public Object clone(){\n         VariablePointer pointer = new VariablePointer(variables, name);\n         pointer.index = index;\n-        pointer.value = value;\n         return pointer;\n     }\n+\n+//    private\n+\n+    public NodeIterator childIterator(QName name, boolean reverse){\n+        return getValuePointer().childIterator(name, reverse);\n+    }\n+\n+    public NodeIterator siblingIterator(QName name, boolean reverse){\n+        return getValuePointer().siblingIterator(name, reverse);\n+    }\n+\n+    public NodeIterator attributeIterator(){\n+        return getValuePointer().attributeIterator();\n+    }\n+\n+    public NodePointer attributePointer(QName name){\n+        return getValuePointer().attributePointer(name);\n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.2 2001/08/23 03:38:00 craigmcc Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/08/23 03:38:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.3 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/09/03 01:22:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.w3c.dom.Node;\n+import org.w3c.dom.*;\n import java.util.*;\n \n import org.apache.commons.jxpath.ri.*;\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/08/23 03:38:00 $\n+ * @version $Revision: 1.3 $ $Date: 2001/09/03 01:22:31 $\n  */\n \n public class JXPathTestCase extends TestCase\n     }\n \n     private void testIndividual(int relativePropertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n-        NodePointer root = NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n-        PropertyIterator it;\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n+        NodeIterator it;\n \n         if (useStartLocation){\n             PropertyPointer holder = root.getPropertyPointer();\n             holder.setPropertyIndex(relativeProperty(holder, relativePropertyIndex));\n             holder.setIndex(offset);\n-            it = PropertyIterator.iteratorStartingAt(holder, \"integers\", reverse);\n+            it = holder.siblingIterator(new QName(null, \"integers\"), reverse);\n         }\n         else {\n-            it = PropertyIterator.iterator(root, \"integers\", reverse);\n+//            it = PropertyIterator.iterator(root, \"integers\", reverse);\n+            it = root.childIterator(new QName(null, \"integers\"), reverse);\n         }\n \n         int size = 0;\n-        while(it.next()){\n+        while(it.setPosition(it.getPosition() + 1)){\n             size++;\n         }\n         assertEquals(\"ITERATIONS: Individual, relativePropertyIndex=\" + relativePropertyIndex +\n     }\n \n     private void testMultiple(int propertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n-        NodePointer root = NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n-        PropertyIterator it;\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.createNodePointer(new QName(null, \"root\"), bean);\n+        NodeIterator it;\n \n         if (useStartLocation){\n             PropertyPointer holder = root.getPropertyPointer();\n             holder.setPropertyIndex(propertyIndex);\n             holder.setIndex(offset);\n-            it = PropertyIterator.iteratorStartingAt(holder, null, reverse);\n+            it = holder.siblingIterator(null, reverse);\n         }\n         else {\n-            it = PropertyIterator.iterator(root, null, reverse);\n+            it = root.childIterator(null, reverse);\n         }\n \n         int size = 0;\n-        while(it.next()){\n+        while(it.setPosition(it.getPosition() + 1)){\n //            System.err.println(\"LOC: \" + it.getCurrentNodePointer());\n             size++;\n         }\n         lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n         lib.addFunctions(new PackageFunctions(\"org.apache.commons.jxpath.\", \"jxpathtest\"));\n         ctx.setFunctions(lib);\n-\n+        testXPaths(ctx, xpath_tests, ignorePath);\n+    }\n+\n+    private void testXPaths(JXPathContext ctx, XP xpath_tests[], boolean ignorePath){\n         for  (int i=0; i < xpath_tests.length; i++) {\n             try {\n                 Object actual;\n         // Traversal\n         // ancestor::\n         test(\"int/ancestor::root = /\", Boolean.TRUE),\n+//        testEval(\"beans/name/ancestor-or-self::node()\", new Double(5)),\n         test(\"count(beans/name/ancestor-or-self::node())\", new Double(5)),\n         test(\"beans/name/ancestor-or-self::node()[3] = /\", Boolean.TRUE),\n \n \n         // descendant-or-self::\n         testEval(\"//name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n+        test(\"//Key1\", \"Value 1\"),\n         testEval(\"//self::node()[name = 'Name 0']/name\", list(\"Name 0\")),\n         testEval(\"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n                 list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n         list.add(o7);\n         return list;\n     }\n+\n+    public void testDOM(){\n+        System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n+                \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n+        try {\n+            XMLDocumentContainer docCtr = new XMLDocumentContainer(getClass().getResource(\"Test.properties\"));\n+            Document doc = (Document)docCtr.getValue();\n+            JXPathContext ctx = JXPathContextFactory.newInstance().newContext(null, doc);\n+            ctx.getVariables().declareVariable(\"dom\", doc);\n+            ctx.getVariables().declareVariable(\"object\", docCtr);\n+            TestBeanWithDOM tbwdom = new TestBeanWithDOM();\n+            tbwdom.setVendor(doc.getDocumentElement());\n+            tbwdom.setObject(docCtr);\n+            ctx.getVariables().declareVariable(\"test\", tbwdom);\n+            testXPaths(ctx, dom_tests, false);\n+        }\n+        catch (Exception ex){\n+            ex.printStackTrace();\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static final XP[] dom_tests = new XP[]{\n+        // Numbers\n+        test(\"vendor/location/address/street\", \"Some street\"),\n+        test(\"vendor/location[2]/address/street\", \"Other street\"),\n+        test(\"//street\", \"Some street\"),\n+        test(\"name(//street/..)\", \"address\"),\n+        test(\"number(vendor/location/employeeCount)\", new Double(10)),\n+        test(\"vendor/location/employeeCount + 1\", new Double(11)),\n+        test(\"vendor/location/employeeCount and true()\", Boolean.TRUE),\n+        test(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\", \"Other street\"),\n+        testPath(\"vendor/location[.//employeeCount = 10]/following-sibling::location//street\",\n+                \"/vendor[1]/location[2]/address[1]/street[1]\"),\n+        testPath(\"//location[2]/preceding-sibling::location//street\",\n+                \"/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"vendor/location/@id\", \"100\"),\n+        testPath(\"vendor/location/@id\", \"/vendor[1]/location[1]/@id\"),\n+        testEval(\"vendor/location/@id\", list(\"100\", \"101\")),\n+        test(\"vendor/location/@blank\", \"\"),\n+        test(\"vendor/location/@missing\", null),\n+        test(\"count(vendor/location[1]/@*)\", new Double(3)),\n+        test(\"vendor/location[@id='101']//street\", \"Other street\"),\n+        test(\"$test/int\", new Integer(1)),\n+        test(\"$test/vendor/location[1]//street\", \"Some street\"),\n+        test(\"$dom/vendor//street\", \"Some street\"),\n+        test(\"$test/object/vendor/location[1]//street\", \"Some street\"),\n+        testPath(\"$test/object/vendor/location[1]//street\", \"$test/object/vendor[1]/location[1]/address[1]/street[1]\"),\n+        test(\"$object//street\", \"Some street\"),\n+        testPath(\"$object//street\", \"$object/vendor[1]/location[1]/address[1]/street[1]\"),\n+    };\n }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestBeanWithDOM.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestBeanWithDOM.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/09/03 01:22:31 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * General purpose test bean for JUnit tests for the \"jxpath\" component.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ */\n+public class TestBeanWithDOM extends TestBean {\n+    private Node node;\n+    private Object object;\n+\n+    public Node getVendor(){\n+        return node;\n+    }\n+\n+    public void setVendor(Node node){\n+        this.node = node;\n+    }\n+\n+    public Object getObject(){\n+        return object;\n+    }\n+\n+    public void setObject(Object object){\n+        this.object = object;\n+    }\n+\n+}", "timestamp": 999480151, "metainfo": ""}