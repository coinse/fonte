{"sha": "323e8b214459b3977973c01a048a979dc778f100", "log": "Refactoring   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.5 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.6 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An extension function that creates an instance using a constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.6 $ $Date: 2002/05/08 00:40:00 $\n  */\n public class ConstructorFunction implements Function {\n \n                 args[0] = context;\n             }\n             for (int i = 0; i < parameters.length; i++){\n-                args[i + pi] = TypeUtils.convert(parameters[i], types[i]);\n+                args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);\n             }\n             return constructor.newInstance(args);\n         }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.5 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.6 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.6 $ $Date: 2002/05/08 00:40:00 $\n  */\n public class MethodFunction implements Function {\n \n             else {\n                 int pi = 0;\n                 Class types[] = method.getParameterTypes();\n-                if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+                if (types.length >= 1 &&\n+                        ExpressionContext.class.isAssignableFrom(types[0])){\n                     pi = 1;\n                 }\n-                target = TypeUtils.convert(parameters[0], method.getDeclaringClass());\n+                target = TypeUtils.\n+                        convert(parameters[0], method.getDeclaringClass());\n                 args = new Object[parameters.length - 1 + pi];\n                 if (pi == 1){\n                     args[0] = context;\n                 }\n                 for (int i = 1; i < parameters.length; i++){\n-                    args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i - 1]);\n+                    args[pi + i - 1] =\n+                            TypeUtils.convert(parameters[i], types[i + pi - 1]);\n                 }\n             }\n \n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.13 2002/04/28 04:36:27 dmitri Exp $\n- * $Revision: 1.13 $\n- * $Date: 2002/04/28 04:36:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.14 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.14 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.13 $ $Date: 2002/04/28 04:36:27 $\n+ * @version $Revision: 1.14 $ $Date: 2002/05/08 00:40:00 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Returns the next node pointer in the context\n      */\n         throw new UnsupportedOperationException(\n             \"JXPath iterators cannot remove nodes\");\n     }\n-    \n+\n     /**\n      * Returns the list of all Pointers in this context\n      */\n         }\n         return false;\n     }\n+\n     /**\n      * Returns true if there is another object in the current set.\n      * Switches the current position and node to the next object.\n         this.position = position;\n         return true;\n     }\n-\n-    /**\n-     * Creates an EvalContext with the value of the specified\n-     * variable as its context node.\n-     */\n-    protected EvalContext getVariable(QName variableName){\n-        return getRootContext().getVariableContext(variableName);\n-    }\n-\n-    protected static Double ZERO = new Double(0);\n-    protected static Double ONE = new Double(1);\n-    protected static Double NaN = new Double(Double.NaN);\n-\n-    /**\n-     * Evaluates the expression. If the result is a node set, returns\n-     * the first element of the node set.\n-     */\n-    public Object eval(Expression expression){\n-        return eval(expression, true);\n-    }\n-    \n-    public Iterator iterate(Expression expression){\n-        Object result = eval(expression, false);\n-        if (result instanceof EvalContext){\n-            return new ValueIterator((EvalContext)result);\n-        }\n-        return ValueUtils.iterate(result);\n-    }\n-    \n-    public Iterator iteratePointers(Expression expression){\n-        Object result = eval(expression, false);\n-        if (result == null){\n-            return Collections.EMPTY_LIST.iterator();\n-        }\n-        if (result instanceof EvalContext){\n-            return (EvalContext)result;\n-        }\n-        return new PointerIterator(ValueUtils.iterate(result), \n-                    new QName(null, \"value\"), \n-                    getRootContext().getCurrentNodePointer().getLocale());\n-    }\n-    \n-    /**\n-     * Evaluates the expression. If the result is a node set, returns\n-     * the whole set if firstMatch==false or the first element otherwise.\n-     */\n-    private Object eval(Expression expression, boolean firstMatch){\n-        Object value = null;\n-        switch (expression.getEvaluationMode()){\n-            case Expression.EVALUATION_MODE_ONCE:\n-            case Expression.EVALUATION_MODE_ALWAYS:\n-                value = evalExpression(expression, firstMatch);\n-                break;\n-            case Expression.EVALUATION_MODE_ONCE_AND_SAVE:\n-                RootContext root = getRootContext();\n-                int id = expression.getID();\n-                if (id == -1){\n-                    // evaluate the expression and save the intermediate result\n-                    value = evalExpression(expression, firstMatch);\n-                    id = root.setRegisteredValue(value);\n-                    expression.setID(id);\n-                }\n-                else {\n-                    value = root.getRegisteredValue(id);\n-                }\n-        }\n-        return value;\n-    }\n-\n-    /**\n-     * Evaluates the expression. If the result is a node set, returns\n-     * the whole set if firstMatch==false or the first element otherwise.\n-     */\n-    private Object evalExpression(Expression expression, boolean firstMatch){\n-        int op = expression.getExpressionTypeCode();\n-        switch(op){\n-        case Expression.OP_CONSTANT:\n-            return ((Constant)expression).getValue();\n-\n-        case Expression.OP_UNION:\n-            return union(((CoreOperation)expression).getArg1(),\n-                         ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_UNARY_MINUS:\n-            return minus(((CoreOperation)expression).getArg1());\n-\n-        case Expression.OP_SUM:\n-            return sum(((CoreOperation)expression).getArguments());\n-\n-        case Expression.OP_MINUS:\n-            return minus(((CoreOperation)expression).getArg1(),\n-                         ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_MULT:\n-            return mult(((CoreOperation)expression).getArg1(),\n-                        ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_DIV:\n-            return div(((CoreOperation)expression).getArg1(),\n-                       ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_MOD:\n-            return mod(((CoreOperation)expression).getArg1(),\n-                       ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_LT:\n-            return lt(((CoreOperation)expression).getArg1(),\n-                      ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_GT:\n-            return gt(((CoreOperation)expression).getArg1(),\n-                      ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_LTE:\n-            return lte(((CoreOperation)expression).getArg1(),\n-                       ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_GTE:\n-            return gte(((CoreOperation)expression).getArg1(),\n-                       ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_EQ:\n-            return eq(((CoreOperation)expression).getArg1(),\n-                      ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_NE:\n-            return ne(((CoreOperation)expression).getArg1(),\n-                      ((CoreOperation)expression).getArg2());\n-\n-        case Expression.OP_AND:\n-            return and(((CoreOperation)expression).getArguments());\n-\n-        case Expression.OP_OR:\n-            return or(((CoreOperation)expression).getArguments());\n-\n-        case Expression.OP_VAR:\n-            return getVariable(((VariableReference)expression).getVariableName());\n-\n-        case Expression.OP_CORE_FUNCTION:\n-            return coreFunction((CoreFunction)expression);\n-\n-        case Expression.OP_LOCATION_PATH:\n-            if (firstMatch){\n-                return getSingleNodePointerForPath((LocationPath)expression);\n-            }\n-            else {\n-                return path((LocationPath)expression);\n-            }\n-\n-        case Expression.OP_EXPRESSION_PATH:\n-            return expressionPath((ExpressionPath)expression, firstMatch);\n-\n-        case Expression.OP_FUNCTION:\n-            return function(((ExtensionFunction)expression).getFunctionName(),\n-                            ((ExtensionFunction)expression).getArguments());\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Computes <code>\"left | right\"<code>\n-     */\n-    protected Object union(Expression left, Expression right){\n-        Object l = eval(left, false);\n-        Object r = eval(right, false);\n-        EvalContext lctx;\n-        if (l instanceof EvalContext){\n-            lctx = (EvalContext)l;\n-        }\n-        else {\n-            lctx = getRootContext().getConstantContext(l);\n-        }\n-        EvalContext rctx;\n-        if (r instanceof EvalContext){\n-            rctx = (EvalContext)r;\n-        }\n-        else {\n-            rctx = getRootContext().getConstantContext(r);\n-        }\n-        return new UnionContext(getRootContext(), new EvalContext[]{lctx, rctx});\n-    }\n-\n-    /**\n-     * Computes <code>\"-arg\"<code>\n-     */\n-    protected Object minus(Expression arg){\n-        double a = doubleValue(eval(arg));\n-        return new Double(-a);\n-    }\n-\n-    /**\n-     * Computes <code>\"a + b + c + d\"<code>\n-     */\n-    protected Object sum(Expression[] arguments){\n-        double s = 0.0;\n-        for (int i = 0; i < arguments.length; i++){\n-            s += doubleValue(eval(arguments[i]));\n-        }\n-        return new Double(s);\n-    }\n-\n-    /**\n-     * Computes <code>\"left - right\"<code>\n-     */\n-    protected Object minus(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return new Double(l - r);\n-    }\n-\n-    /**\n-     * Computes <code>\"left div right\"<code>\n-     */\n-    protected Object div(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return new Double(l/r);\n-    }\n-\n-    /**\n-     * Computes <code>\"left * right\"<code>\n-     */\n-    protected Object mult(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return new Double(l*r);\n-    }\n-\n-    /**\n-     * Computes <code>\"left mod right\"<code>\n-     */\n-    protected Object mod(Expression left, Expression right){\n-        long l = (long)doubleValue(eval(left));\n-        long r = (long)doubleValue(eval(right));\n-        return new Double(l%r);\n-    }\n-\n-    /**\n-     * Computes <code>\"left &lt; right\"<code>\n-     */\n-    protected Object lt(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return l < r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left &gt; right\"<code>\n-     */\n-    protected Object gt(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return l > r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left &lt;= right\"<code>\n-     */\n-    protected Object lte(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left &gt;= right\"<code>\n-     */\n-    protected Object gte(Expression left, Expression right){\n-        double l = doubleValue(eval(left));\n-        double r = doubleValue(eval(right));\n-        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left = right\"<code>\n-     */\n-    protected Object eq(Expression left, Expression right){\n-        return equal(left, right) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left != right\"<code>\n-     */\n-    protected Object ne(Expression left, Expression right){\n-        return equal(left, right) ? Boolean.FALSE : Boolean.TRUE;\n-    }\n-\n-    /**\n-     * Compares two values\n-     */\n-    protected boolean equal(Expression left, Expression right){\n-        Object l = eval(left);\n-        Object r = eval(right);\n-        boolean result;\n-        if (l == r){\n-            return true;\n-        }\n-\n-        if (l instanceof EvalContext && r instanceof EvalContext){\n-            Set lset = new HashSet(((EvalContext)l).valueSet());\n-            Set rset = new HashSet(((EvalContext)r).valueSet());\n-            return lset.equals(rset);\n-        }\n-\n-        if (l instanceof EvalContext){\n-            l = ((EvalContext)l).getSingleNodePointer();\n-        }\n-        if (r instanceof EvalContext){\n-            r = ((EvalContext)r).getSingleNodePointer();\n-        }\n-\n-        if (l instanceof Pointer && r instanceof Pointer){\n-            if (l.equals(r)){\n-                return true;\n-            }\n-        }\n-\n-        if (l instanceof NodePointer){\n-            l = ((NodePointer)l).getValue();\n-        }\n-        if (r instanceof NodePointer){\n-            r = ((NodePointer)r).getValue();\n-        }\n-\n-        if (l instanceof Boolean || r instanceof Boolean){\n-            result = (booleanValue(l) == booleanValue(r));\n-        }\n-        else if (l instanceof Number || r instanceof Number){\n-            result = (doubleValue(l) == doubleValue(r));\n-        }\n-        else if (l instanceof String || r instanceof String){\n-            result = (stringValue(l).equals(stringValue(r)));\n-        }\n-        else if (l == null){\n-            return r == null;\n-        }\n-        else {\n-            result = l.equals(r);\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Extracts all values from a context\n-     */\n-    private Set valueSet(){\n-        HashSet set = new HashSet();\n-        while(nextSet()){\n-            while(nextNode()){\n-                NodePointer pointer = getCurrentNodePointer();\n-                set.add(pointer.getValue());\n-            }\n-        }\n-        return set;\n-    }\n-\n-    /**\n-     * Computes <code>\"left and right\"<code>\n-     */\n-    protected Object and(Expression[] arguments){\n-        for (int i = 0; i < arguments.length; i++){\n-            if (!booleanValue(eval(arguments[i]))){\n-                return Boolean.FALSE;\n-            }\n-        }\n-        return Boolean.TRUE;\n-    }\n-\n-    /**\n-     * Computes <code>\"left or right\"<code>\n-     */\n-    protected Object or(Expression[] arguments){\n-        for (int i = 0; i < arguments.length; i++){\n-            if (booleanValue(eval(arguments[i]))){\n-                return Boolean.TRUE;\n-            }\n-        }\n-        return Boolean.FALSE;\n-    }\n-\n-    /**\n-     * Converts the supplied object to String\n-     */\n-    public static String stringValue(Object object){\n-        if (object instanceof String){\n-            return (String)object;\n-        }\n-        else if (object instanceof Number){\n-            return String.valueOf(((Number)object).doubleValue());\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? \"true\" : \"false\";\n-        }\n-        else if (object == null){\n-            return \"\";\n-        }\n-        else if (object instanceof NodePointer){\n-            return stringValue(((NodePointer)object).getValue());\n-        }\n-        else if (object instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)object;\n-            Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr != null){\n-                return stringValue(ptr);\n-            }\n-            return \"\";\n-        }\n-        return String.valueOf(object);\n-    }\n-\n-    /**\n-     * Converts the supplied object to Number\n-     */\n-    protected Number number(Object object){\n-        if (object instanceof Number){\n-            return (Number)object;\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? ONE : ZERO;\n-        }\n-        else if (object instanceof String){\n-            Double value;\n-            try {\n-                value = new Double((String)object);\n-            }\n-            catch (NumberFormatException ex){\n-                value = NaN;\n-            }\n-            return value;\n-        }\n-        else if (object instanceof EvalContext){\n-            return number(stringValue(object));\n-        }\n-        else if (object instanceof NodePointer){\n-            return number(((NodePointer)object).getValue());\n-        }\n-//        else if (object instanceof Node){\n-//            System.err.println(\"HERE\");\n-//            return number(stringValue(object));\n-//        }\n-        return ZERO;\n-    }\n-\n-    /**\n-     * Converts the supplied object to double\n-     */\n-    public static double doubleValue(Object object){\n-        if (object instanceof Number){\n-            return ((Number)object).doubleValue();\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? 0.0 : 1.0;\n-        }\n-        else if (object instanceof String){\n-            if (object.equals(\"\")){\n-                return 0.0;\n-            }\n-\n-            double value;\n-            try {\n-                value = Double.parseDouble((String)object);\n-            }\n-            catch (NumberFormatException ex){\n-                value = Double.NaN;\n-            }\n-            return value;\n-        }\n-        else if (object instanceof NodePointer){\n-            return doubleValue(((NodePointer)object).getValue());\n-        }\n-        else if (object instanceof EvalContext){\n-            return doubleValue(stringValue(object));\n-        }\n-        return 0;\n-    }\n-\n-    /**\n-     * Converts the supplied object to boolean\n-     */\n-    public static boolean booleanValue(Object object){\n-        if (object instanceof Number){\n-            double value = ((Number)object).doubleValue();\n-            return value != 0 && value != -0 && !Double.isNaN(value);\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue();\n-        }\n-        else if (object instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)object;\n-            return ctx.nextSet() && ctx.nextNode();\n-        }\n-        else if (object instanceof String){\n-            return ((String)object).length() != 0;\n-        }\n-        else if (object instanceof NodePointer){\n-            return booleanValue(((NodePointer)object).getValue());\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Walks a location path and finds a single node that matches the path\n-     */\n-    protected Pointer getSingleNodePointerForPath(LocationPath path) {\n-        // Create a chain of contexts\n-        EvalContext rootContext;\n-        if (path.isAbsolute()) {\n-            rootContext = getRootContext();\n-        }\n-        else {\n-            rootContext = this;\n-        }\n-        return getSingleNodePointerForSteps(\n-                    new InitialContext(rootContext), path);\n-    }\n-    /**\n-     * Walks a location path and returns a context containing all\n-     * nodes matching the path\n-     */\n-    protected EvalContext path(LocationPath path){\n-        // Create a chain of contexts\n-        EvalContext rootContext;\n-        if (path.isAbsolute()){\n-            rootContext = getRootContext();\n-        }\n-        else {\n-            rootContext = this;\n-        }\n-        return evalSteps(new InitialContext(rootContext), path);\n-    }\n-\n-    /**\n-     * Walks an expression path (a path that starts with an expression)\n-     */\n-    protected Object expressionPath(ExpressionPath path, boolean firstMatch){\n-        Expression expression = path.getExpression();\n-        Object value = eval(expression, false);\n-        EvalContext context;\n-        if (value instanceof InitialContext){\n-            // This is an optimization. We can avoid iterating through a collection\n-            // if the context bean is in fact one.\n-            context = (InitialContext)value;\n-        }\n-        else if (value instanceof EvalContext){\n-            // UnionContext will collect all values from the \"value\" context\n-            // and treat the whole thing as a big collection.\n-            context = new UnionContext(this, new EvalContext[]{(EvalContext)value});\n-        }\n-        else {\n-            context = getRootContext().getConstantContext(value);\n-        }\n-\n-        Expression predicates[] = path.getPredicates();\n-\n-        if (firstMatch &&\n-                path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) &&\n-                !(context instanceof UnionContext)){\n-            EvalContext ctx = context;\n-            NodePointer ptr = (NodePointer)ctx.getSingleNodePointer();\n-            if (ptr != null &&\n-                    (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n-                     predicates == null || predicates.length == 0)){\n-                NodePointer pointer = SimplePathInterpreter.interpretPredicates(this, ptr, predicates);\n-                return SimplePathInterpreter.interpretPath(this, pointer, path.getSteps());\n-            }\n-        }\n-\n-        if (predicates != null){\n-            for (int j = 0; j < predicates.length; j++){\n-//                System.err.println(\"PREDICATE: \" + predicates[j]);\n-                context = new PredicateContext(context, predicates[j]);\n-            }\n-        }\n-        if (firstMatch){\n-            return getSingleNodePointerForSteps(context, path);\n-        }\n-        else {\n-            return evalSteps(context, path);\n-        }\n-    }\n-\n-    /**\n-     * Given a root context, walks a path therefrom and finds the \n-     * pointer to the first element matching the path.\n-     */\n-    private Pointer getSingleNodePointerForSteps(EvalContext context, Path path){\n-        Step steps[] = path.getSteps();\n-        if (steps.length == 0){\n-            return context.getSingleNodePointer();\n-        }\n-\n-        if (path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE)){\n-            NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n-            return SimplePathInterpreter.interpretPath(this, ptr, steps);\n-        }\n-        else {\n-            for (int i = 0; i < steps.length; i++){\n-                context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n-                Expression predicates[] = steps[i].getPredicates();\n-                if (predicates != null){\n-                    for (int j = 0; j < predicates.length; j++){\n-                        context = new PredicateContext(context, predicates[j]);\n-                    }\n-                }\n-            }\n-    \n-            return context.getSingleNodePointer();\n-        }\n-    }\n-\n-    /**\n-     * Given a root context, walks a path therefrom and builds a context\n-     * that contains all nodes matching the path.\n-     */\n-    private EvalContext evalSteps(EvalContext context, Path path){\n-        Step steps[] = path.getSteps();\n-        if (steps.length == 0){\n-            return context;\n-        }\n-\n-        for (int i = 0; i < steps.length; i++){\n-            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n-            Expression predicates[] = steps[i].getPredicates();\n-            if (predicates != null){\n-                for (int j = 0; j < predicates.length; j++){\n-                    context = new PredicateContext(context, predicates[j]);\n-                }\n-            }\n-        }\n-\n-        return context;\n-    }\n-\n-    /**\n-     * Different axes are serviced by different contexts. This method\n-     * allocates the right context for the supplied step.\n-     */\n-    protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest){\n-        switch(axis){\n-            case Compiler.AXIS_ANCESTOR:\n-                return new AncestorContext(context, false, nodeTest);\n-            case Compiler.AXIS_ANCESTOR_OR_SELF:\n-                return new AncestorContext(context, true, nodeTest);\n-            case Compiler.AXIS_ATTRIBUTE:\n-                return new AttributeContext(context, nodeTest);\n-            case Compiler.AXIS_CHILD:\n-                return new ChildContext(context, nodeTest, false, false);\n-            case Compiler.AXIS_DESCENDANT:\n-                return new DescendantContext(context, false, nodeTest);\n-            case Compiler.AXIS_DESCENDANT_OR_SELF:\n-                return new DescendantContext(context, true, nodeTest);\n-            case Compiler.AXIS_FOLLOWING:\n-                return new PrecedingOrFollowingContext(context, nodeTest, false);\n-            case Compiler.AXIS_FOLLOWING_SIBLING:\n-                return new ChildContext(context, nodeTest, true, false);\n-            case Compiler.AXIS_NAMESPACE:\n-                return new NamespaceContext(context, nodeTest);\n-            case Compiler.AXIS_PARENT:\n-                return new ParentContext(context, nodeTest);\n-            case Compiler.AXIS_PRECEDING:\n-                return new PrecedingOrFollowingContext(context, nodeTest, true);\n-            case Compiler.AXIS_PRECEDING_SIBLING:\n-                return new ChildContext(context, nodeTest, true, true);\n-            case Compiler.AXIS_SELF:\n-                return new SelfContext(context, nodeTest);\n-        }\n-        return null;        // Never happens\n-    }\n-\n-    /**\n-     * Computes an extension function\n-     */\n-    protected Object function(QName functionName, Expression[] arguments){\n-        Object[] parameters = null;\n-        if (arguments != null){\n-            parameters = new Object[arguments.length];\n-            for (int i = 0; i < arguments.length; i++){\n-                Object param = eval(arguments[i], false);\n-                parameters[i] = param;\n-            }\n-        }\n-        Function function = getRootContext().getFunction(functionName, parameters);\n-        if (function == null){\n-            throw new JXPathException(\"No such function: \" + functionName +\n-                 Arrays.asList(parameters));\n-        }\n-\n-        return function.invoke(this, parameters);\n-    }\n-\n-    /**\n-     * Computes a built-in function\n-     */\n-    protected Object coreFunction(CoreFunction function){\n-        int code = function.getFunctionCode();\n-        switch(code){\n-            case Compiler.FUNCTION_LAST:                return functionLast(function);\n-            case Compiler.FUNCTION_POSITION:            return functionPosition(function);\n-            case Compiler.FUNCTION_COUNT:               return functionCount(function);\n-            case Compiler.FUNCTION_LANG:                return functionLang(function);\n-            case Compiler.FUNCTION_ID:\n-            {\n-                System.err.println(\"UNIMPLEMENTED: \" + function);\n-                return null;\n-            }\n-            case Compiler.FUNCTION_LOCAL_NAME:          return functionLocalName(function);\n-            case Compiler.FUNCTION_NAMESPACE_URI:       return functionNamespaceURI(function);\n-            case Compiler.FUNCTION_NAME:                return functionName(function);\n-            case Compiler.FUNCTION_STRING:              return functionString(function);\n-            case Compiler.FUNCTION_CONCAT:              return functionConcat(function);\n-            case Compiler.FUNCTION_STARTS_WITH:         return functionStartsWith(function);\n-            case Compiler.FUNCTION_CONTAINS:            return functionContains(function);\n-            case Compiler.FUNCTION_SUBSTRING_BEFORE:    return functionSubstringBefore(function);\n-            case Compiler.FUNCTION_SUBSTRING_AFTER:     return functionSubstringAfter(function);\n-            case Compiler.FUNCTION_SUBSTRING:           return functionSubstring(function);\n-            case Compiler.FUNCTION_STRING_LENGTH:       return functionStringLength(function);\n-            case Compiler.FUNCTION_NORMALIZE_SPACE:     return functionNormalizeSpace(function);\n-            case Compiler.FUNCTION_TRANSLATE:           return functionTranslate(function);\n-            case Compiler.FUNCTION_BOOLEAN:             return functionBoolean(function);\n-            case Compiler.FUNCTION_NOT:                 return functionNot(function);\n-            case Compiler.FUNCTION_TRUE:                return functionTrue(function);\n-            case Compiler.FUNCTION_FALSE:               return functionFalse(function);\n-            case Compiler.FUNCTION_NULL:                return functionNull(function);\n-            case Compiler.FUNCTION_NUMBER:              return functionNumber(function);\n-            case Compiler.FUNCTION_SUM:                 return functionSum(function);\n-            case Compiler.FUNCTION_FLOOR:               return functionFloor(function);\n-            case Compiler.FUNCTION_CEILING:             return functionCeiling(function);\n-            case Compiler.FUNCTION_ROUND:               return functionRound(function);\n-//            case Compiler.FUNCTION_KEY:\n-//                System.err.println(\"UNIMPLEMENTED: \" + function);\n-        }\n-        return null;\n-    }\n-\n-    protected Object functionLast(CoreFunction function){\n-        assertArgCount(function, 0);\n-        // Move the position to the beginning and iterate through\n-        // the context to count nodes.\n-        int old = getCurrentPosition();\n-        reset();\n-        int count = 0;\n-        while(nextNode()){\n-            count++;\n-        }\n-\n-        // Restore the current position.\n-        if (old != 0){\n-            setPosition(old);\n-        }\n-        return new Double(count);\n-    }\n-\n-    protected Object functionPosition(CoreFunction function){\n-        assertArgCount(function, 0);\n-        return new Integer(getCurrentPosition());\n-    }\n-\n-    protected Object functionCount(CoreFunction function){\n-        assertArgCount(function, 1);\n-        Expression arg1 = function.getArg1();\n-        int count = 0;\n-        Object value = eval(arg1, false);\n-        if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getValue();\n-        }\n-        if (value instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)value;\n-            while(ctx.nextSet()){\n-                while(ctx.nextNode()){\n-                    count++;\n-                }\n-            }\n-        }\n-        else if (value instanceof Collection){\n-            count = ((Collection)value).size();\n-        }\n-        else if (value == null){\n-            count = 0;\n-        }\n-        else {\n-            count = 1;\n-        }\n-        return new Double(count);\n-    }\n-\n-    protected Object functionLang(CoreFunction function){\n-        assertArgCount(function, 1);\n-        String lang = stringValue(eval(function.getArg1()));\n-        NodePointer pointer = (NodePointer)getSingleNodePointer();\n-        if (pointer == null){\n-            return Boolean.FALSE;\n-        }\n-        return pointer.isLanguage(lang) ? Boolean.TRUE: Boolean.FALSE;\n-    }\n-\n-    protected Object functionNamespaceURI(CoreFunction function){\n-        if (function.getArgumentCount() == 0){\n-            return getCurrentNodePointer();\n-        }\n-        assertArgCount(function, 1);\n-        Object set = eval(function.getArg1(), false);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.nextNode()){\n-                String str = ctx.getCurrentNodePointer().getNamespaceURI();\n-                return str == null ? \"\" : str;\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    protected Object functionLocalName(CoreFunction function){\n-        if (function.getArgumentCount() == 0){\n-            return getCurrentNodePointer();\n-        }\n-        assertArgCount(function, 1);\n-        Object set = eval(function.getArg1(), false);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.nextNode()){\n-                return ctx.getCurrentNodePointer().getName().getName();\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    protected Object functionName(CoreFunction function){\n-        if (function.getArgumentCount() == 0){\n-            return getCurrentNodePointer();\n-        }\n-        assertArgCount(function, 1);\n-        Object set = eval(function.getArg1(), false);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.nextNode()){\n-                return ctx.getCurrentNodePointer().getExpandedName().toString();\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    protected Object functionString(CoreFunction function){\n-        if (function.getArgumentCount() == 0){\n-            return stringValue(getCurrentNodePointer());\n-        }\n-        assertArgCount(function, 1);\n-        return stringValue(eval(function.getArg1()));\n-    }\n-\n-    protected Object functionConcat(CoreFunction function){\n-        if (function.getArgumentCount() < 2){\n-            assertArgCount(function, 2);\n-        }\n-        StringBuffer buffer = new StringBuffer();\n-        Expression args[] = function.getArguments();\n-        for (int i = 0; i < args.length; i++){\n-            buffer.append(stringValue(eval(args[i])));\n-        }\n-        return buffer.toString();\n-    }\n-\n-    protected Object functionStartsWith(CoreFunction function){\n-        assertArgCount(function, 2);\n-        String s1 = stringValue(eval(function.getArg1()));\n-        String s2 = stringValue(eval(function.getArg2()));\n-        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    protected Object functionContains(CoreFunction function){\n-        assertArgCount(function, 2);\n-        String s1 = stringValue(eval(function.getArg1()));\n-        String s2 = stringValue(eval(function.getArg2()));\n-        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    protected Object functionSubstringBefore(CoreFunction function){\n-        assertArgCount(function, 2);\n-        String s1 = stringValue(eval(function.getArg1()));\n-        String s2 = stringValue(eval(function.getArg2()));\n-        int index = s1.indexOf(s2);\n-        if (index == -1){\n-            return \"\";\n-        }\n-        return s1.substring(0, index);\n-    }\n-\n-    protected Object functionSubstringAfter(CoreFunction function){\n-        assertArgCount(function, 2);\n-        String s1 = stringValue(eval(function.getArg1()));\n-        String s2 = stringValue(eval(function.getArg2()));\n-        int index = s1.indexOf(s2);\n-        if (index == -1){\n-            return \"\";\n-        }\n-        return s1.substring(index + s2.length());\n-    }\n-\n-    protected Object functionSubstring(CoreFunction function){\n-        int ac = function.getArgumentCount();\n-        if (ac != 2 && ac != 3){\n-            assertArgCount(function, 2);\n-        }\n-\n-        String s1 = stringValue(eval(function.getArg1()));\n-        double from = doubleValue(eval(function.getArg2()));\n-        if (Double.isNaN(from)){\n-            return \"\";\n-        }\n-\n-        from = Math.round(from);\n-        if (ac == 2){\n-            if (from < 1){\n-                from = 1;\n-            }\n-            return s1.substring((int)from - 1);\n-        }\n-        else {\n-            double length = doubleValue(eval(function.getArg3()));\n-            length = Math.round(length);\n-            if (length < 0){\n-                return \"\";\n-            }\n-\n-            double to = from + length;\n-            if (to < 1){\n-                return \"\";\n-            }\n-\n-            if (to > s1.length() + 1){\n-                if (from < 1){\n-                    from = 1;\n-                }\n-                return s1.substring((int)from - 1);\n-            }\n-\n-            if (from < 1){\n-                from = 1;\n-            }\n-            return s1.substring((int)from - 1, (int)(to - 1));\n-        }\n-    }\n-\n-    protected Object functionStringLength(CoreFunction function){\n-        String s;\n-        if (function.getArgumentCount() == 0){\n-            s = stringValue(getCurrentNodePointer());\n-        }\n-        else {\n-            assertArgCount(function, 1);\n-            s = stringValue(eval(function.getArg1()));\n-        }\n-        return new Double(s.length());\n-    }\n-\n-    protected Object functionNormalizeSpace(CoreFunction function){\n-        assertArgCount(function, 1);\n-        String s = stringValue(eval(function.getArg1()));\n-        char chars[] = s.toCharArray();\n-        int out = 0;\n-        int phase = 0;\n-        for (int in = 0; in < chars.length; in++){\n-            switch(chars[in]){\n-                case 0x20:\n-                case 0x9:\n-                case 0xD:\n-                case 0xA:\n-                    if (phase == 0){      // beginning\n-                        ;\n-                    }\n-                    else if (phase == 1){ // non-space\n-                        phase = 2;\n-                        chars[out++] = ' ';\n-                    }\n-                    break;\n-                default:\n-                    chars[out++] = chars[in];\n-                    phase = 1;\n-            }\n-        }\n-        if (phase == 2){ // trailing-space\n-            out--;\n-        }\n-        return new String(chars, 0, out);\n-    }\n-\n-    protected Object functionTranslate(CoreFunction function){\n-        assertArgCount(function, 3);\n-        String s1 = stringValue(eval(function.getArg1()));\n-        String s2 = stringValue(eval(function.getArg2()));\n-        String s3 = stringValue(eval(function.getArg3()));\n-        char chars[] = s1.toCharArray();\n-        int out = 0;\n-        for (int in = 0; in < chars.length; in++){\n-            char c = chars[in];\n-            int inx = s2.indexOf(c);\n-            if (inx != -1){\n-                if (inx < s3.length()){\n-                    chars[out++] = s3.charAt(inx);\n-                }\n-            }\n-            else {\n-                chars[out++] = c;\n-            }\n-        }\n-        return new String(chars, 0, out);\n-    }\n-\n-    protected Object functionBoolean(CoreFunction function){\n-        assertArgCount(function, 1);\n-        return booleanValue(eval(function.getArg1())) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    protected Object functionNot(CoreFunction function){\n-        assertArgCount(function, 1);\n-        return booleanValue(eval(function.getArg1())) ? Boolean.FALSE : Boolean.TRUE;\n-    }\n-\n-    protected Object functionTrue(CoreFunction function){\n-        assertArgCount(function, 0);\n-        return Boolean.TRUE;\n-    }\n-\n-    protected Object functionFalse(CoreFunction function){\n-        assertArgCount(function, 0);\n-        return Boolean.FALSE;\n-    }\n-\n-    protected Object functionNull(CoreFunction function){\n-        assertArgCount(function, 0);\n-        return new NullPointer(null, getRootContext().getCurrentNodePointer().getLocale());\n-    }\n-\n-    protected Object functionNumber(CoreFunction function){\n-        if (function.getArgumentCount() == 0){\n-            return number(getCurrentNodePointer());\n-        }\n-        assertArgCount(function, 1);\n-        return number(eval(function.getArg1()));\n-    }\n-\n-    protected Object functionSum(CoreFunction function){\n-        assertArgCount(function, 1);\n-        Object v = eval(function.getArg1(), false);\n-        if (v == null){\n-            return ZERO;\n-        }\n-        else if (v instanceof EvalContext){\n-            double sum = 0.0;\n-            EvalContext ctx = (EvalContext)v;\n-            while (ctx.nextSet()){\n-                while (ctx.nextNode()){\n-                    sum += doubleValue(ctx.getCurrentNodePointer());\n-                }\n-            }\n-            return new Double(sum);\n-        }\n-        throw new JXPathException(\"Invalid argument type for 'sum': \"\n-            + v.getClass().getName());\n-    }\n-\n-    protected Object functionFloor(CoreFunction function){\n-        assertArgCount(function, 1);\n-        double v = doubleValue(eval(function.getArg1()));\n-        return new Double(Math.floor(v));\n-    }\n-\n-    protected Object functionCeiling(CoreFunction function){\n-        assertArgCount(function, 1);\n-        double v = doubleValue(eval(function.getArg1()));\n-        return new Double(Math.ceil(v));\n-    }\n-\n-    protected Object functionRound(CoreFunction function){\n-        assertArgCount(function, 1);\n-        double v = doubleValue(eval(function.getArg1()));\n-        return new Double(Math.round(v));\n-    }\n-\n-    private void assertArgCount(CoreFunction function, int count){\n-        if (function.getArgumentCount() != count){\n-            throw new JXPathException(\"Incorrect number of argument: \"\n-                + function);\n-        }\n-    }\n-    \n-    public static class PointerIterator implements Iterator {\n-        private Iterator iterator;\n-        private QName qname;\n-        private Locale locale;\n-        \n-        public PointerIterator(Iterator it, QName qname, Locale locale){\n-            this.iterator = it;\n-            this.qname = qname;\n-            this.locale = locale;\n-        }\n-        \n-        public boolean hasNext(){\n-            return iterator.hasNext();\n-        }\n-        \n-        public Object next(){\n-            Object o = iterator.next();            \n-            return NodePointer.newNodePointer(qname, o, locale);\n-        }\n-        \n-        public void remove(){\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-    \n-    public static class ValueIterator implements Iterator {\n-        private Iterator iterator;\n-        \n-        public ValueIterator(Iterator it){\n-            this.iterator = it;\n-        }\n-        \n-        public boolean hasNext(){\n-            return iterator.hasNext();\n-        }\n-        \n-        public Object next(){\n-            Object o = iterator.next();\n-            if (o instanceof Pointer){\n-                return ((Pointer)o).getValue();\n-            }\n-            return o;\n-        }\n-        \n-        public void remove(){\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java,v 1.1 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/05/08 00:40:00 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/05/08 00:40:00 $\n+ */\n+public class InfoSetUtil {\n+\n+    private static final Double ZERO = new Double(0);\n+    private static final Double ONE = new Double(1);\n+    private static final Double NaN = new Double(Double.NaN);\n+\n+\n+    /**\n+     * Converts the supplied object to String\n+     */\n+    public static String stringValue(Object object){\n+        if (object instanceof String){\n+            return (String)object;\n+        }\n+        else if (object instanceof Number){\n+            return String.valueOf(((Number)object).doubleValue());\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? \"true\" : \"false\";\n+        }\n+        else if (object == null){\n+            return \"\";\n+        }\n+        else if (object instanceof NodePointer){\n+            return stringValue(((NodePointer)object).getValue());\n+        }\n+        else if (object instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)object;\n+            Pointer ptr = ctx.getSingleNodePointer();\n+            if (ptr != null){\n+                return stringValue(ptr);\n+            }\n+            return \"\";\n+        }\n+        return String.valueOf(object);\n+    }\n+\n+    /**\n+     * Converts the supplied object to Number\n+     */\n+    public static Number number(Object object){\n+        if (object instanceof Number){\n+            return (Number)object;\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? ONE : ZERO;\n+        }\n+        else if (object instanceof String){\n+            Double value;\n+            try {\n+                value = new Double((String)object);\n+            }\n+            catch (NumberFormatException ex){\n+                value = NaN;\n+            }\n+            return value;\n+        }\n+        else if (object instanceof EvalContext){\n+            return number(stringValue(object));\n+        }\n+        else if (object instanceof NodePointer){\n+            return number(((NodePointer)object).getValue());\n+        }\n+        return ZERO;\n+    }\n+\n+    /**\n+     * Converts the supplied object to double\n+     */\n+    public static double doubleValue(Object object){\n+        if (object instanceof Number){\n+            return ((Number)object).doubleValue();\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue() ? 0.0 : 1.0;\n+        }\n+        else if (object instanceof String){\n+            if (object.equals(\"\")){\n+                return 0.0;\n+            }\n+\n+            double value;\n+            try {\n+                value = Double.parseDouble((String)object);\n+            }\n+            catch (NumberFormatException ex){\n+                value = Double.NaN;\n+            }\n+            return value;\n+        }\n+        else if (object instanceof NodePointer){\n+            return doubleValue(((NodePointer)object).getValue());\n+        }\n+        else if (object instanceof EvalContext){\n+            return doubleValue(stringValue(object));\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Converts the supplied object to boolean\n+     */\n+    public static boolean booleanValue(Object object){\n+        if (object instanceof Number){\n+            double value = ((Number)object).doubleValue();\n+            return value != 0 && value != -0 && !Double.isNaN(value);\n+        }\n+        else if (object instanceof Boolean){\n+            return ((Boolean)object).booleanValue();\n+        }\n+        else if (object instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)object;\n+            return ctx.nextSet() && ctx.nextNode();\n+        }\n+        else if (object instanceof String){\n+            return ((String)object).length() != 0;\n+        }\n+        else if (object instanceof NodePointer){\n+            return booleanValue(((NodePointer)object).getValue());\n+        }\n+        return false;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.14 2002/04/28 04:37:01 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/04/28 04:37:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.15 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2002/04/28 04:37:01 $\n+ * @version $Revision: 1.15 $ $Date: 2002/05/08 00:40:00 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n     public static NodePointerFactory[] getNodePointerFactories(){\n         return nodeFactoryArray;\n     }\n-    \n+\n     public CompiledExpression compile(String xpath){\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n             }\n             if (expr == null){\n                 expr = (Expression)Parser.parseExpression(xpath, compiler);\n-                expr.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n                 compiled.put(xpath, new SoftReference(expr));\n                 if (cleanupCount++ >= CLEANUP_THRESHOLD){\n                     cleanupCache();\n             expr = (Expression)compiled.get(xpath);\n             if (expr == null){\n                 expr = (Expression)Parser.parseExpression(xpath, compiler);\n-                expr.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n                 compiled.put(xpath, expr);\n             }\n         }\n     public Object getValue(String xpath){\n         return getValue(xpath, compileExpression(xpath));\n     }\n-    \n-    public Object getValue(String xpath, Expression expr){    \n-        Object result = getRootContext().eval(expr);        \n+\n+    public Object getValue(String xpath, Expression expr){\n+        Object result = expr.computeValue(getRootContext());\n         if (result == null && !lenient){\n             throw new JXPathException(\"No value for xpath: \" + xpath);\n         }\n         Expression expr = compileExpression(xpath);\n         return getValue(xpath, expr, requiredType);\n     }\n-    \n+\n     public Object getValue(String xpath, Expression expr, Class requiredType){\n         Object value = getValue(xpath, expr);\n         if (value != null && requiredType != null){\n     public Iterator iterate(String xpath){\n         return iterate(xpath, compileExpression(xpath));\n     }\n-    \n+\n     public Iterator iterate(String xpath, Expression expr){\n-        return getRootContext().iterate(expr);        \n+        return expr.iterate(getRootContext());\n     }\n \n     public Pointer getPointer(String xpath){\n         return getPointer(xpath, compileExpression(xpath));\n     }\n-    \n+\n     public Pointer getPointer(String xpath, Expression expr){\n-        Object result = getRootContext().eval(expr);        \n+        Object result = expr.computeValue(getRootContext());\n         if (result instanceof EvalContext){\n             result = ((EvalContext)result).getSingleNodePointer();\n         }\n     public void setValue(String xpath, Object value){\n         setValue(xpath, compileExpression(xpath), value);\n     }\n-    \n-    \n+\n+\n     public void setValue(String xpath, Expression expr, Object value){\n         try {\n             setValue(xpath, expr, value, false);\n     public void createPath(String xpath, Object value){\n         createPath(xpath, compileExpression(xpath), value);\n     }\n-    \n+\n     public void createPath(String xpath, Expression expr, Object value){\n         try {\n             setValue(xpath, expr, value, true);\n     }\n \n     private void setValue(String xpath, Expression expr, Object value, boolean create){\n-        Object result = getRootContext().eval(expr);        \n+        Object result = expr.computeValue(getRootContext());\n //        System.err.println(\"RESULT: \" + result);\n         Pointer pointer = null;\n \n     }\n \n     public Iterator iteratePointers(String xpath, Expression expr){\n-        return getRootContext().iteratePointers(expr);\n-    }\n-    \n+        return expr.iteratePointers(getRootContext());\n+    }\n+\n     private void printPointer(NodePointer pointer){\n         Pointer p = pointer;\n         while (p != null){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.8 2002/04/28 04:35:48 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/04/28 04:35:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.9 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.CoreOperation;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.ri.compiler.NameAttributeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/04/28 04:35:48 $\n+ * @version $Revision: 1.9 $ $Date: 2002/05/08 00:40:00 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n     private boolean done = false;\n-    private Expression dynamicPropertyNameExpression;\n+    private Expression nameTestExpression;\n     private PropertyPointer dynamicPropertyPointer;\n \n     public PredicateContext(EvalContext parentContext, Expression expression){\n         super(parentContext);\n         this.expression = expression;\n-        dynamicPropertyNameExpression = (Expression)expression.\n-            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+        if (expression instanceof NameAttributeTest){\n+            nameTestExpression = \n+                ((NameAttributeTest)expression).getNameTestExpression();\n+        }\n     }\n \n     public boolean nextNode(){\n         }\n         while (parentContext.nextNode()){\n             if (setupDynamicPropertyPointer()){\n-                Object pred = parentContext.eval(dynamicPropertyNameExpression);\n+                Object pred = nameTestExpression.computeValue(parentContext);\n                 if (pred instanceof NodePointer){\n                     pred = ((NodePointer)pred).getValue();\n                 }\n-                dynamicPropertyPointer.setPropertyName(stringValue(pred));\n+                dynamicPropertyPointer.setPropertyName(InfoSetUtil.stringValue(pred));\n                 done = true;\n                 return true;\n             }\n             else {\n-                Object pred = parentContext.eval(expression);\n+                Object pred = expression.computeValue(parentContext);\n                 if (pred instanceof NodePointer){\n                     pred = ((NodePointer)pred).getNodeValue();\n                 }\n                 if (pred instanceof Number){\n-                    int pos = (int)doubleValue(pred);\n+                    int pos = (int)InfoSetUtil.doubleValue(pred);\n                     position++;\n                     done = true;\n                     return parentContext.setPosition(pos);\n                 }\n-                else if (booleanValue(pred)){\n+                else if (InfoSetUtil.booleanValue(pred)){\n                     position++;\n                     return true;\n                 }\n      * \"map[@name = 'name']\" syntax\n      */\n     private boolean setupDynamicPropertyPointer(){\n-        if (dynamicPropertyNameExpression == null){\n+        if (nameTestExpression == null){\n             return false;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n  * An simple XPath evaluation mechanism, which works only for some xpaths\n             }\n             else {\n                 Expression lastIndexPredicate = null;\n-                if (predicates[count - 1].\n-                            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+                if (!(predicates[count - 1] instanceof NameAttributeTest)){\n                     lastIndexPredicate = predicates[count - 1];\n                 }\n \n \n         int count = predicates.length;\n         Expression lastIndexPredicate = null;\n-        if (predicates[count - 1].\n-                    getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+        if (!(predicates[count - 1] instanceof NameAttributeTest)){\n             lastIndexPredicate = predicates[count - 1];\n         }\n \n     }\n \n     private static int indexFromPredicate(EvalContext context, Expression predicate){\n-        Object value = context.eval(predicate);\n+        Object value = predicate.computeValue(context);\n         if (value instanceof EvalContext){\n             value = ((EvalContext)value).getSingleNodePointer();\n         }\n         }\n \n         if (value instanceof Number){\n-            return (int)(context.doubleValue(value) + 0.5) - 1;\n-        }\n-        else if (context.booleanValue(value)){\n+            return (int)(InfoSetUtil.doubleValue(value) + 0.5) - 1;\n+        }\n+        else if (InfoSetUtil.booleanValue(value)){\n             return 0;\n         }\n \n         return -1;\n     }\n \n-    private static String keyFromPredicate(EvalContext context, Expression predicate){\n-        Expression expr = (Expression)predicate.\n-                getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-        return context.stringValue(context.eval(expr));\n+    private static String keyFromPredicate(EvalContext context,\n+                Expression predicate){\n+        Expression expr = ((NameAttributeTest)predicate).\n+                                    getNameTestExpression();\n+        return InfoSetUtil.stringValue(expr.computeValue(context));\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java,v 1.2 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n /**\n  * A compile tree element containing a constant number or string.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class Constant extends Expression {\n \n         this.value = string;\n     }\n \n+    public Object compute(EvalContext context){\n+        return value;\n+    }\n+\n     /**\n      * Returns the value of the constant.\n      */\n-    public Object getValue(){\n+    public Object computeValue(EvalContext context){\n         return value;\n     }\n \n         return false;\n     }\n \n-    /**\n-     * Ignores the argument, sets the evaluation mode to EVALUATION_MODE_ALWAYS.\n-     * There is no reason to store the constant value in a temporary register\n-     */\n-    public void setEvaluationMode(int evalMode){\n-        super.setEvaluationMode(EVALUATION_MODE_ALWAYS);\n-    }\n-\n     public String toString(){\n         return \"(CONST \" + value + \")\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n+\n+import java.util.Collection;\n \n /**\n  * An element of the compile tree representing one of built-in functions\n  * like \"position()\" or \"number()\".\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class CoreFunction extends Operation {\n \n+    private static final Double ZERO = new Double(0);\n     private int functionCode;\n \n     public CoreFunction(int functionCode, Expression args[]){\n         }\n         return super.opCodeToString() + ':' + function;\n     }\n+\n+    public Object compute(EvalContext context){\n+        return computeValue(context);\n+    }\n+\n+    /**\n+     * Computes a built-in function\n+     */\n+    public Object computeValue(EvalContext context){\n+        switch(functionCode){\n+            case Compiler.FUNCTION_LAST:                return functionLast(context);\n+            case Compiler.FUNCTION_POSITION:            return functionPosition(context);\n+            case Compiler.FUNCTION_COUNT:               return functionCount(context);\n+            case Compiler.FUNCTION_LANG:                return functionLang(context);\n+            case Compiler.FUNCTION_ID:\n+            {\n+                System.err.println(\"UNIMPLEMENTED: \" + this);\n+                return null;\n+            }\n+            case Compiler.FUNCTION_LOCAL_NAME:          return functionLocalName(context);\n+            case Compiler.FUNCTION_NAMESPACE_URI:       return functionNamespaceURI(context);\n+            case Compiler.FUNCTION_NAME:                return functionName(context);\n+            case Compiler.FUNCTION_STRING:              return functionString(context);\n+            case Compiler.FUNCTION_CONCAT:              return functionConcat(context);\n+            case Compiler.FUNCTION_STARTS_WITH:         return functionStartsWith(context);\n+            case Compiler.FUNCTION_CONTAINS:            return functionContains(context);\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE:    return functionSubstringBefore(context);\n+            case Compiler.FUNCTION_SUBSTRING_AFTER:     return functionSubstringAfter(context);\n+            case Compiler.FUNCTION_SUBSTRING:           return functionSubstring(context);\n+            case Compiler.FUNCTION_STRING_LENGTH:       return functionStringLength(context);\n+            case Compiler.FUNCTION_NORMALIZE_SPACE:     return functionNormalizeSpace(context);\n+            case Compiler.FUNCTION_TRANSLATE:           return functionTranslate(context);\n+            case Compiler.FUNCTION_BOOLEAN:             return functionBoolean(context);\n+            case Compiler.FUNCTION_NOT:                 return functionNot(context);\n+            case Compiler.FUNCTION_TRUE:                return functionTrue(context);\n+            case Compiler.FUNCTION_FALSE:               return functionFalse(context);\n+            case Compiler.FUNCTION_NULL:                return functionNull(context);\n+            case Compiler.FUNCTION_NUMBER:              return functionNumber(context);\n+            case Compiler.FUNCTION_SUM:                 return functionSum(context);\n+            case Compiler.FUNCTION_FLOOR:               return functionFloor(context);\n+            case Compiler.FUNCTION_CEILING:             return functionCeiling(context);\n+            case Compiler.FUNCTION_ROUND:               return functionRound(context);\n+//            case Compiler.FUNCTION_KEY:\n+//                System.err.println(\"UNIMPLEMENTED: \" + function);\n+        }\n+        return null;\n+    }\n+\n+    protected Object functionLast(EvalContext context){\n+        assertArgCount(0);\n+        // Move the position to the beginning and iterate through\n+        // the context to count nodes.\n+        int old = context.getCurrentPosition();\n+        context.reset();\n+        int count = 0;\n+        while(context.nextNode()){\n+            count++;\n+        }\n+\n+        // Restore the current position.\n+        if (old != 0){\n+            context.setPosition(old);\n+        }\n+        return new Double(count);\n+    }\n+\n+    protected Object functionPosition(EvalContext context){\n+        assertArgCount(0);\n+        return new Integer(context.getCurrentPosition());\n+    }\n+\n+    protected Object functionCount(EvalContext context){\n+        assertArgCount(1);\n+        Expression arg1 = getArg1();\n+        int count = 0;\n+        Object value = arg1.compute(context);\n+        if (value instanceof NodePointer){\n+            value = ((NodePointer)value).getValue();\n+        }\n+        if (value instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)value;\n+            while(ctx.hasNext()){\n+                ctx.next();\n+                count++;\n+            }\n+        }\n+        else if (value instanceof Collection){\n+            count = ((Collection)value).size();\n+        }\n+        else if (value == null){\n+            count = 0;\n+        }\n+        else {\n+            count = 1;\n+        }\n+        return new Double(count);\n+    }\n+\n+    protected Object functionLang(EvalContext context){\n+        assertArgCount(1);\n+        String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        NodePointer pointer = (NodePointer)context.getSingleNodePointer();\n+        if (pointer == null){\n+            return Boolean.FALSE;\n+        }\n+        return pointer.isLanguage(lang) ? Boolean.TRUE: Boolean.FALSE;\n+    }\n+\n+    protected Object functionNamespaceURI(EvalContext context){\n+        if (getArgumentCount() == 0){\n+            return context.getCurrentNodePointer();\n+        }\n+        assertArgCount(1);\n+        Object set = getArg1().compute(context);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.hasNext()){\n+                ctx.next();\n+                String str = ctx.getCurrentNodePointer().getNamespaceURI();\n+                return str == null ? \"\" : str;\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionLocalName(EvalContext context){\n+        if (getArgumentCount() == 0){\n+            return context.getCurrentNodePointer();\n+        }\n+        assertArgCount(1);\n+        Object set = getArg1().compute(context);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.hasNext()){\n+                ctx.next();\n+                return ctx.getCurrentNodePointer().getName().getName();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionName(EvalContext context){\n+        if (getArgumentCount() == 0){\n+            return context.getCurrentNodePointer();\n+        }\n+        assertArgCount(1);\n+        Object set = getArg1().compute(context);\n+        if (set instanceof EvalContext){\n+            EvalContext ctx = (EvalContext)set;\n+            if (ctx.hasNext()){\n+                ctx.next();\n+                return ctx.getCurrentNodePointer().getExpandedName().toString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    protected Object functionString(EvalContext context){\n+        if (getArgumentCount() == 0){\n+            return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n+        }\n+        assertArgCount(1);\n+        return InfoSetUtil.stringValue(getArg1().computeValue(context));\n+    }\n+\n+    protected Object functionConcat(EvalContext context){\n+        if (getArgumentCount() < 2){\n+            assertArgCount(2);\n+        }\n+        StringBuffer buffer = new StringBuffer();\n+        Expression args[] = getArguments();\n+        for (int i = 0; i < args.length; i++){\n+            buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n+        }\n+        return buffer.toString();\n+    }\n+\n+    protected Object functionStartsWith(EvalContext context){\n+        assertArgCount(2);\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionContains(EvalContext context){\n+        assertArgCount(2);\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionSubstringBefore(EvalContext context){\n+        assertArgCount(2);\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        int index = s1.indexOf(s2);\n+        if (index == -1){\n+            return \"\";\n+        }\n+        return s1.substring(0, index);\n+    }\n+\n+    protected Object functionSubstringAfter(EvalContext context){\n+        assertArgCount(2);\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        int index = s1.indexOf(s2);\n+        if (index == -1){\n+            return \"\";\n+        }\n+        return s1.substring(index + s2.length());\n+    }\n+\n+    protected Object functionSubstring(EvalContext context){\n+        int ac = getArgumentCount();\n+        if (ac != 2 && ac != 3){\n+            assertArgCount(2);\n+        }\n+\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n+        if (Double.isNaN(from)){\n+            return \"\";\n+        }\n+\n+        from = Math.round(from);\n+        if (ac == 2){\n+            if (from < 1){\n+                from = 1;\n+            }\n+            return s1.substring((int)from - 1);\n+        }\n+        else {\n+            double length = InfoSetUtil.doubleValue(getArg3().computeValue(context));\n+            length = Math.round(length);\n+            if (length < 0){\n+                return \"\";\n+            }\n+\n+            double to = from + length;\n+            if (to < 1){\n+                return \"\";\n+            }\n+\n+            if (to > s1.length() + 1){\n+                if (from < 1){\n+                    from = 1;\n+                }\n+                return s1.substring((int)from - 1);\n+            }\n+\n+            if (from < 1){\n+                from = 1;\n+            }\n+            return s1.substring((int)from - 1, (int)(to - 1));\n+        }\n+    }\n+\n+    protected Object functionStringLength(EvalContext context){\n+        String s;\n+        if (getArgumentCount() == 0){\n+            s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n+        }\n+        else {\n+            assertArgCount(1);\n+            s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        }\n+        return new Double(s.length());\n+    }\n+\n+    protected Object functionNormalizeSpace(EvalContext context){\n+        assertArgCount(1);\n+        String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        char chars[] = s.toCharArray();\n+        int out = 0;\n+        int phase = 0;\n+        for (int in = 0; in < chars.length; in++){\n+            switch(chars[in]){\n+                case 0x20:\n+                case 0x9:\n+                case 0xD:\n+                case 0xA:\n+                    if (phase == 0){      // beginning\n+                        ;\n+                    }\n+                    else if (phase == 1){ // non-space\n+                        phase = 2;\n+                        chars[out++] = ' ';\n+                    }\n+                    break;\n+                default:\n+                    chars[out++] = chars[in];\n+                    phase = 1;\n+            }\n+        }\n+        if (phase == 2){ // trailing-space\n+            out--;\n+        }\n+        return new String(chars, 0, out);\n+    }\n+\n+    protected Object functionTranslate(EvalContext context){\n+        assertArgCount(3);\n+        String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n+        String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n+        String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n+        char chars[] = s1.toCharArray();\n+        int out = 0;\n+        for (int in = 0; in < chars.length; in++){\n+            char c = chars[in];\n+            int inx = s2.indexOf(c);\n+            if (inx != -1){\n+                if (inx < s3.length()){\n+                    chars[out++] = s3.charAt(inx);\n+                }\n+            }\n+            else {\n+                chars[out++] = c;\n+            }\n+        }\n+        return new String(chars, 0, out);\n+    }\n+\n+    protected Object functionBoolean(EvalContext context){\n+        assertArgCount(1);\n+        return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionNot(EvalContext context){\n+        assertArgCount(1);\n+        return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n+    protected Object functionTrue(EvalContext context){\n+        assertArgCount(0);\n+        return Boolean.TRUE;\n+    }\n+\n+    protected Object functionFalse(EvalContext context){\n+        assertArgCount(0);\n+        return Boolean.FALSE;\n+    }\n+\n+    protected Object functionNull(EvalContext context){\n+        assertArgCount(0);\n+        return new NullPointer(null, context.getRootContext().getCurrentNodePointer().getLocale());\n+    }\n+\n+    protected Object functionNumber(EvalContext context){\n+        if (getArgumentCount() == 0){\n+            return InfoSetUtil.number(context.getCurrentNodePointer());\n+        }\n+        assertArgCount(1);\n+        return InfoSetUtil.number(getArg1().computeValue(context));\n+    }\n+\n+    protected Object functionSum(EvalContext context){\n+        assertArgCount(1);\n+        Object v = getArg1().compute(context);\n+        if (v == null){\n+            return ZERO;\n+        }\n+        else if (v instanceof EvalContext){\n+            double sum = 0.0;\n+            EvalContext ctx = (EvalContext)v;\n+            while (ctx.nextSet()){\n+                while (ctx.nextNode()){\n+                    sum += InfoSetUtil.doubleValue(ctx.getCurrentNodePointer());\n+                }\n+            }\n+            return new Double(sum);\n+        }\n+        throw new JXPathException(\"Invalid argument type for 'sum': \"\n+            + v.getClass().getName());\n+    }\n+\n+    protected Object functionFloor(EvalContext context){\n+        assertArgCount(1);\n+        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n+        return new Double(Math.floor(v));\n+    }\n+\n+    protected Object functionCeiling(EvalContext context){\n+        assertArgCount(1);\n+        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n+        return new Double(Math.ceil(v));\n+    }\n+\n+    protected Object functionRound(EvalContext context){\n+        assertArgCount(1);\n+        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n+        return new Double(Math.round(v));\n+    }\n+\n+    private void assertArgCount(int count){\n+        if (getArgumentCount() != count){\n+            throw new JXPathException(\"Incorrect number of argument: \" + this);\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.4 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.axes.UnionContext;\n+\n+import java.util.Set;\n+import java.util.HashSet;\n \n /**\n  * A compile tree element representing one of the core operations like \"+\",\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class CoreOperation extends Operation {\n-\n-    private Object dynamicPropertyAccessHint;\n-    public static final String DYNAMIC_PROPERTY_ACCESS_HINT = \"dynamicPropertyAccessHint\";\n-    private static final Object NO_HINT = new Object();\n-    private static QName QNAME_NAME = new QName(null, \"name\");\n-\n     public CoreOperation(int code, Expression args[]){\n         super(code, args);\n     }\n         return args[1];\n     }\n \n-    /**\n-     * Recognized predicated formatted as <code>[@name = <i>expr</i>]</code>\n-     */\n-    public Object getEvaluationHint(String hint){\n-        if (getExpressionTypeCode() != OP_EQ ||\n-                !hint.equals(DYNAMIC_PROPERTY_ACCESS_HINT)){\n-            return null;\n-        }\n-\n-        if (dynamicPropertyAccessHint == null){\n-            dynamicPropertyAccessHint = NO_HINT;\n-\n-            Expression arg1 = getArg1();\n-            if (arg1.getExpressionTypeCode() == Expression.OP_LOCATION_PATH){\n-                Step[] steps = ((LocationPath)arg1).getSteps();\n-                if (steps.length == 1 &&\n-                        steps[0].getAxis() == Compiler.AXIS_ATTRIBUTE &&\n-                        steps[0].getNodeTest() instanceof NodeNameTest &&\n-                        ((NodeNameTest)steps[0].getNodeTest()).getNodeName().equals(QNAME_NAME)){\n-                    dynamicPropertyAccessHint = getArg2();\n-                }\n+    public Object compute(EvalContext context){\n+        return computeValue(context);\n+    }\n+\n+    public Object computeValue(EvalContext context){\n+        switch (getExpressionTypeCode()){\n+            case Expression.OP_UNION:\n+                return union(context, args[0], args[1]);\n+\n+            case Expression.OP_UNARY_MINUS:\n+                return minus(context, args[0]);\n+\n+            case Expression.OP_SUM:\n+                return sum(context, args);\n+\n+            case Expression.OP_MINUS:\n+                return minus(context, args[0], args[1]);\n+\n+            case Expression.OP_MULT:\n+                return mult(context, args[0], args[1]);\n+\n+            case Expression.OP_DIV:\n+                return div(context, args[0], args[1]);\n+\n+            case Expression.OP_MOD:\n+                return mod(context, args[0], args[1]);\n+\n+            case Expression.OP_LT:\n+                return lt(context, args[0], args[1]);\n+\n+            case Expression.OP_GT:\n+                return gt(context, args[0], args[1]);\n+\n+            case Expression.OP_LTE:\n+                return lte(context, args[0], args[1]);\n+\n+            case Expression.OP_GTE:\n+                return gte(context, args[0], args[1]);\n+\n+            case Expression.OP_EQ:\n+                return eq(context, args[0], args[1]);\n+\n+            case Expression.OP_NE:\n+                return ne(context, args[0], args[1]);\n+\n+            case Expression.OP_AND:\n+                return and(context, args);\n+\n+            case Expression.OP_OR:\n+                return or(context, args);\n+        }\n+        return null; // Should never happen\n+    }\n+\n+    /**\n+     * Computes <code>\"left | right\"<code>\n+     */\n+    protected Object union(EvalContext context, Expression left, Expression right){\n+        Object l = left.compute(context);\n+        Object r = right.compute(context);\n+        EvalContext lctx;\n+        if (l instanceof EvalContext){\n+            lctx = (EvalContext)l;\n+        }\n+        else {\n+            lctx = context.getRootContext().getConstantContext(l);\n+        }\n+        EvalContext rctx;\n+        if (r instanceof EvalContext){\n+            rctx = (EvalContext)r;\n+        }\n+        else {\n+            rctx = context.getRootContext().getConstantContext(r);\n+        }\n+        return new UnionContext(context.getRootContext(), new EvalContext[]{lctx, rctx});\n+    }\n+\n+    /**\n+     * Computes <code>\"-arg\"<code>\n+     */\n+    protected Object minus(EvalContext context, Expression arg){\n+        double a = InfoSetUtil.doubleValue(arg.computeValue(context));\n+        return new Double(-a);\n+    }\n+\n+    /**\n+     * Computes <code>\"a + b + c + d\"<code>\n+     */\n+    protected Object sum(EvalContext context, Expression[] arguments){\n+        double s = 0.0;\n+        for (int i = 0; i < arguments.length; i++){\n+            s += InfoSetUtil.doubleValue(arguments[i].computeValue(context));\n+        }\n+        return new Double(s);\n+    }\n+\n+    /**\n+     * Computes <code>\"left - right\"<code>\n+     */\n+    protected Object minus(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l - r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left div right\"<code>\n+     */\n+    protected Object div(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l/r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left * right\"<code>\n+     */\n+    protected Object mult(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l*r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left mod right\"<code>\n+     */\n+    protected Object mod(EvalContext context, Expression left, Expression right){\n+        long l = (long)InfoSetUtil.doubleValue(left.computeValue(context));\n+        long r = (long)InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l%r);\n+    }\n+\n+    /**\n+     * Computes <code>\"left &lt; right\"<code>\n+     */\n+    protected Object lt(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return l < r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &gt; right\"<code>\n+     */\n+    protected Object gt(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return l > r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &lt;= right\"<code>\n+     */\n+    protected Object lte(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return l <= r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left &gt;= right\"<code>\n+     */\n+    protected Object gte(EvalContext context, Expression left, Expression right){\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return l >= r ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left = right\"<code>\n+     */\n+    protected Object eq(EvalContext context, Expression left, Expression right){\n+        return equal(context, left, right) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left != right\"<code>\n+     */\n+    protected Object ne(EvalContext context, Expression left, Expression right){\n+        return equal(context, left, right) ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Compares two values\n+     */\n+    protected boolean equal(EvalContext context, Expression left, Expression right){\n+        Object l = left.computeValue(context);\n+        Object r = right.computeValue(context);\n+        boolean result;\n+        if (l == r){\n+            return true;\n+        }\n+\n+        if (l instanceof EvalContext && r instanceof EvalContext){\n+            Set lset = new HashSet(valueSet(((EvalContext)l)));\n+            Set rset = new HashSet(valueSet(((EvalContext)r)));\n+            return lset.equals(rset);\n+        }\n+\n+        if (l instanceof EvalContext){\n+            l = ((EvalContext)l).getSingleNodePointer();\n+        }\n+        if (r instanceof EvalContext){\n+            r = ((EvalContext)r).getSingleNodePointer();\n+        }\n+\n+        if (l instanceof Pointer && r instanceof Pointer){\n+            if (l.equals(r)){\n+                return true;\n             }\n         }\n-        if (dynamicPropertyAccessHint == NO_HINT){\n-            return null;\n-        }\n-        return dynamicPropertyAccessHint;\n+\n+        if (l instanceof NodePointer){\n+            l = ((NodePointer)l).getValue();\n+        }\n+        if (r instanceof NodePointer){\n+            r = ((NodePointer)r).getValue();\n+        }\n+\n+        if (l instanceof Boolean || r instanceof Boolean){\n+            result = (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n+        }\n+        else if (l instanceof Number || r instanceof Number){\n+            result = (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n+        }\n+        else if (l instanceof String || r instanceof String){\n+            result = (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n+        }\n+        else if (l == null){\n+            return r == null;\n+        }\n+        else {\n+            result = l.equals(r);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Extracts all values from a context\n+     */\n+    private Set valueSet(EvalContext context){\n+        HashSet set = new HashSet();\n+        while(context.hasNext()){\n+            context.next();\n+            NodePointer pointer = context.getCurrentNodePointer();\n+            set.add(pointer.getValue());\n+        }\n+        return set;\n+    }\n+\n+    /**\n+     * Computes <code>\"left and right\"<code>\n+     */\n+    protected Object and(EvalContext context, Expression[] arguments){\n+        for (int i = 0; i < arguments.length; i++){\n+            if (!InfoSetUtil.booleanValue(arguments[i].computeValue(context))){\n+                return Boolean.FALSE;\n+            }\n+        }\n+        return Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Computes <code>\"left or right\"<code>\n+     */\n+    protected Object or(EvalContext context, Expression[] arguments){\n+        for (int i = 0; i < arguments.length; i++){\n+            if (InfoSetUtil.booleanValue(arguments[i].computeValue(context))){\n+                return Boolean.TRUE;\n+            }\n+        }\n+        return Boolean.FALSE;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,v 1.2 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.util.ValueUtils;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Locale;\n+\n /**\n  * Common superclass for several types of nodes in the parse tree. Provides\n  * APIs for optimization of evaluation of expressions.  Specifically, an\n  * provides that hint.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n  */\n public abstract class Expression {\n \n \n     public static final int OP_CORE_FUNCTION = 22;\n \n+    public static final int OP_KEY_LOOKUP = 23;\n+\n+    protected static Double ZERO = new Double(0);\n+    protected static Double ONE = new Double(1);\n+    protected static Double NaN = new Double(Double.NaN);\n+\n     private int typeCode;\n \n     private boolean contextDependencyKnown = false;\n     private boolean contextDependent;\n \n-    public static final int EVALUATION_MODE_ONCE = 0;\n-    public static final int EVALUATION_MODE_ONCE_AND_SAVE = 1;\n-    public static final int EVALUATION_MODE_ALWAYS = 2;\n-    private int evaluationMode;\n-\n-    private int id = -1;\n-\n     protected Expression(int typeCode){\n         this.typeCode = typeCode;\n-    }\n-\n-    /**\n-     * Expression IDs are used with context-independent expressions\n-     * for identifying the register holding the intermediate result of\n-     * this expression evaluation.\n-     */\n-    public void setID(int id){\n-        this.id = id;\n-    }\n-\n-    /**\n-     * @see #setID\n-     */\n-    public int getID(){\n-        return id;\n     }\n \n     public int getExpressionTypeCode(){\n      * Implemented by subclasses and result is cached by isContextDependent()\n      */\n     public abstract boolean computeContextDependent();\n-\n-    /**\n-     * Evaluation mode can be EVALUATION_MODE_ONCE, EVALUATION_MODE_ONCE_AND_SAVE\n-     * or EVALUATION_MODE_ALWAYS, depending on whether or not this expression\n-     * is context-dependent.  The compiler calls setEvaluationMode(EVALUATION_MODE_ONCE)\n-     * on the root Expression.  That expression recursively computes\n-     * the evaluation mode for its children and calls setEvaluationMode on\n-     * each of them.\n-     */\n-    public void setEvaluationMode(int mode){\n-        this.evaluationMode = mode;\n-    }\n-\n-    /**\n-     * @see #setEvaluationMode\n-     */\n-    public int getEvaluationMode(){\n-        return evaluationMode;\n-    }\n-\n-    /**\n-     * Some expressions return optimization hints that\n-     * help the interpreter choose between alternative\n-     * evaluation algorithms.\n-     */\n-    public Object getEvaluationHint(String hint){\n-        return null;\n-    }\n \n     public String toString(){\n         StringBuffer buffer = new StringBuffer();\n         }\n         return \"UNKNOWN\";\n     }\n+\n+    /**\n+     * Evaluates the expression. If the result is a node set, returns\n+     * the first element of the node set.\n+     */\n+    public abstract Object computeValue(EvalContext context);\n+    public abstract Object compute(EvalContext context);\n+\n+    public Iterator iterate(EvalContext context){\n+        Object result = compute(context);\n+        if (result instanceof EvalContext){\n+            return new ValueIterator((EvalContext)result);\n+        }\n+        return ValueUtils.iterate(result);\n+    }\n+\n+    public Iterator iteratePointers(EvalContext context){\n+        Object result = compute(context);\n+        if (result == null){\n+            return Collections.EMPTY_LIST.iterator();\n+        }\n+        if (result instanceof EvalContext){\n+            return (EvalContext)result;\n+        }\n+        return new PointerIterator(ValueUtils.iterate(result),\n+                new QName(null, \"value\"),\n+                context.getRootContext().getCurrentNodePointer().getLocale());\n+    }\n+\n+    public static class PointerIterator implements Iterator {\n+        private Iterator iterator;\n+        private QName qname;\n+        private Locale locale;\n+\n+        public PointerIterator(Iterator it, QName qname, Locale locale){\n+            this.iterator = it;\n+            this.qname = qname;\n+            this.locale = locale;\n+        }\n+\n+        public boolean hasNext(){\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next(){\n+            Object o = iterator.next();\n+            return NodePointer.newNodePointer(qname, o, locale);\n+        }\n+\n+        public void remove(){\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static class ValueIterator implements Iterator {\n+        private Iterator iterator;\n+\n+        public ValueIterator(Iterator it){\n+            this.iterator = it;\n+        }\n+\n+        public boolean hasNext(){\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next(){\n+            Object o = iterator.next();\n+            if (o instanceof Pointer){\n+                return ((Pointer)o).getValue();\n+            }\n+            return o;\n+        }\n+\n+        public void remove(){\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n /**\n  * An element of the parse tree that represents an expression path, which is\n  * a path that starts with an expression like a function call: <code>getFoo(.)/bar</code>.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class ExpressionPath extends Path {\n \n     }\n \n     /**\n-     * Based on the supplied argument computes the evaluation mode\n-     * for the base expression, predicates and steps.\n-     */\n-    public void setEvaluationMode(int mode){\n-        super.setEvaluationMode(mode);\n-\n-        switch(mode){\n-            case EVALUATION_MODE_ALWAYS:\n-                if (expression.isContextDependent()){\n-                    expression.setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n-                }\n-                else {\n-                    expression.setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n-                }\n-                break;\n-            case EVALUATION_MODE_ONCE:\n-            case EVALUATION_MODE_ONCE_AND_SAVE:\n-                expression.setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n-                break;\n-        }\n-\n-        if (predicates != null){\n-            for (int i = 0; i < predicates.length; i++){\n-                switch(mode){\n-                    case EVALUATION_MODE_ALWAYS:\n-                        if (predicates[i].isContextDependent()){\n-                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n-                        }\n-                        else {\n-                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n-                        }\n-                        break;\n-                    case EVALUATION_MODE_ONCE:\n-                    case EVALUATION_MODE_ONCE_AND_SAVE:\n-                        predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n      * Recognized paths formatted as <code>$x[3]/foo[2]</code>.  The\n      * evaluation of such \"simple\" paths is optimized and streamlined.\n      */\n-    public Object getEvaluationHint(String hint){\n-        if (!hint.equals(BASIC_PREDICATES_HINT)){\n-            return super.getEvaluationHint(hint);\n-        }\n-\n+    public boolean isSimpleExpressionPath(){\n         if (!basicKnown){\n             basicKnown = true;\n-            basic = super.getEvaluationHint(BASIC_PATH_HINT).equals(Boolean.TRUE) &&\n-                    areBasicPredicates(getPredicates());\n-        }\n-        return basic ? Boolean.TRUE : Boolean.FALSE;\n+            basic = isSimplePath() && areBasicPredicates(getPredicates());\n+        }\n+        return basic;\n     }\n \n     public String toString(){\n         buffer.append(')');\n         return buffer.toString();\n     }\n+\n+    public Object compute(EvalContext context){\n+        return expressionPath(context, false);\n+    }\n+\n+    public Object computeValue(EvalContext context){\n+        return expressionPath(context, true);\n+    }\n+\n+    /**\n+     * Walks an expression path (a path that starts with an expression)\n+     */\n+    protected Object expressionPath(EvalContext evalContext, boolean firstMatch){\n+        Object value = expression.compute(evalContext);\n+        EvalContext context;\n+        if (value instanceof InitialContext){\n+            // This is an optimization. We can avoid iterating through a collection\n+            // if the context bean is in fact one.\n+            context = (InitialContext)value;\n+        }\n+        else if (value instanceof EvalContext){\n+            // UnionContext will collect all values from the \"value\" context\n+            // and treat the whole thing as a big collection.\n+            context = new UnionContext(evalContext, new EvalContext[]{(EvalContext)value});\n+        }\n+        else {\n+            context = evalContext.getRootContext().getConstantContext(value);\n+        }\n+\n+        if (firstMatch && isSimpleExpressionPath() &&\n+                !(context instanceof UnionContext)){\n+            EvalContext ctx = context;\n+            NodePointer ptr = (NodePointer)ctx.getSingleNodePointer();\n+            if (ptr != null &&\n+                    (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n+                     predicates == null || predicates.length == 0)){\n+                NodePointer pointer = SimplePathInterpreter.\n+                    interpretPredicates(evalContext, ptr, predicates);\n+                return SimplePathInterpreter.interpretPath(evalContext,\n+                    pointer, getSteps());\n+            }\n+        }\n+\n+        if (predicates != null){\n+            for (int j = 0; j < predicates.length; j++){\n+//                System.err.println(\"PREDICATE: \" + predicates[j]);\n+                context = new PredicateContext(context, predicates[j]);\n+            }\n+        }\n+        if (firstMatch){\n+            return getSingleNodePointerForSteps(context);\n+        }\n+        else {\n+            return evalSteps(context);\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.4 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+import java.util.Arrays;\n \n /**\n  * Represents an element of the parse tree representing an extension function call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class ExtensionFunction extends Operation {\n \n     public String opCodeToString(){\n         return super.opCodeToString() + ':' + functionName;\n     }\n+\n+    public Object compute(EvalContext context){\n+        return computeValue(context);\n+    }\n+\n+    public Object computeValue(EvalContext context){\n+        Object[] parameters = null;\n+        if (args != null){\n+            parameters = new Object[args.length];\n+            for (int i = 0; i < args.length; i++){\n+                Object param = args[i].compute(context);\n+                parameters[i] = param;\n+            }\n+        }\n+        Function function = context.getRootContext().getFunction(functionName, parameters);\n+        if (function == null){\n+            throw new JXPathException(\"No such function: \" + functionName +\n+                 Arrays.asList(parameters));\n+        }\n+\n+        return function.invoke(context, parameters);\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.4 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n+\n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class LocationPath extends Path {\n \n         buffer.append(')');\n         return buffer.toString();\n     }\n+\n+    public Object compute(EvalContext context){\n+        // Create a chain of contexts\n+        EvalContext rootContext;\n+        if (isAbsolute()){\n+            rootContext = context.getRootContext();\n+        }\n+        else {\n+            rootContext = context;\n+        }\n+        return evalSteps(new InitialContext(rootContext));\n+    }\n+\n+\n+    public Object computeValue(EvalContext context){\n+        // Create a chain of contexts\n+        EvalContext rootContext;\n+        if (isAbsolute()) {\n+            rootContext = context.getRootContext();\n+        }\n+        else {\n+            rootContext = context;\n+        }\n+        return getSingleNodePointerForSteps(new InitialContext(rootContext));\n+    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n+package org.apache.commons.jxpath.ri.compiler;\n+\n+import org.apache.commons.jxpath.ri.EvalContext;\n+\n+/**\n+ *\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/05/08 00:39:59 $\n+ */\n+public class NameAttributeTest extends CoreOperation {\n+\n+    public NameAttributeTest(Expression namePath, Expression nameValue){\n+        super(OP_EQ, namePath, nameValue);\n+    }\n+\n+    public Expression getNameTestExpression(){\n+        return getArg2();\n+    }\n+\n+    /**\n+     * @see Expression#computeContextDependent()\n+     */\n+    public boolean computeContextDependent() {\n+        return true;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java,v 1.2 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n  */\n-public class Operation extends Expression {\n+public abstract class Operation extends Expression {\n \n     protected Expression args[];\n \n         }\n         return false;\n     }\n-\n-    public void setEvaluationMode(int mode){\n-        super.setEvaluationMode(mode);\n-        if (args != null){\n-            for (int i = 0; i < args.length; i++){\n-                switch(mode){\n-                    case EVALUATION_MODE_ALWAYS:\n-                        if (args[i].isContextDependent()){\n-                            args[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n-                        }\n-                        else {\n-                            args[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n-                        }\n-                        break;\n-                    case EVALUATION_MODE_ONCE:\n-                    case EVALUATION_MODE_ONCE_AND_SAVE:\n-                        args[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n-                        break;\n-                }\n-            }\n-        }\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.axes.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n  */\n-public class Path extends Expression {\n+public abstract class Path extends Expression {\n \n     private Step[] steps;\n     public static final String BASIC_PATH_HINT = \"basicPathHint\";\n         return false;\n     }\n \n-    public void setEvaluationMode(int mode){\n-        super.setEvaluationMode(mode);\n-        if (steps != null){\n-            for (int i = 0; i < steps.length; i++){\n-                if (steps[i].isContextDependent()){\n-                    steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n-                }\n-                else {\n-                    switch(mode){\n-                        case EVALUATION_MODE_ALWAYS:\n-                        case EVALUATION_MODE_ONCE_AND_SAVE:\n-                                steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n-                            break;\n-                        case EVALUATION_MODE_ONCE:\n-                            steps[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     /**\n      * Recognized paths formatted as <code>foo/bar[3]/baz[@name = 'biz']</code>.  The\n      * evaluation of such \"simple\" paths is optimized and streamlined.\n      */\n-    public Object getEvaluationHint(String hint){\n-        if (!hint.equals(BASIC_PATH_HINT)){\n-            return null;\n-        }\n-\n+    public boolean isSimplePath(){\n         if (!basicKnown){\n             basicKnown = true;\n             basic = true;\n             Step[] steps = getSteps();\n             for (int i = 0; i < steps.length; i++){\n-//                System.err.println(\"STEP: \" + steps[i]);\n                 if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n                         !(steps[i].getNodeTest() instanceof NodeNameTest) ||\n-                        ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName().equals(\"*\")){\n+                        ((NodeNameTest)steps[i].getNodeTest()).\n+                                    getNodeName().getName().equals(\"*\")){\n                     basic = false;\n                     break;\n                 }\n-                Expression predicates[] = steps[i].getPredicates();\n-                basic = basic && areBasicPredicates(predicates);\n-            }\n-        }\n-        return basic ? Boolean.TRUE : Boolean.FALSE;\n+                if (basic){\n+                    basic = areBasicPredicates(steps[i].getPredicates());\n+                }\n+            }\n+        }\n+        return basic;\n     }\n \n     protected boolean areBasicPredicates(Expression predicates[]){\n         if (predicates != null && predicates.length != 0){\n             boolean firstIndex = true;\n             for (int i = 0; i < predicates.length; i++){\n-                Expression dyn = (Expression)predicates[i].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-                if (dyn != null){\n-                    if (dyn.isContextDependent()){\n+                if (predicates[i] instanceof NameAttributeTest){\n+                    if (((NameAttributeTest)predicates[i]).\n+                                getNameTestExpression().isContextDependent()){\n                         return false;\n                     }\n                 }\n         }\n         return true;\n     }\n+\n+    /**\n+     * Given a root context, walks a path therefrom and finds the\n+     * pointer to the first element matching the path.\n+     */\n+    protected Pointer getSingleNodePointerForSteps(EvalContext context){\n+        if (steps.length == 0){\n+            return context.getSingleNodePointer();\n+        }\n+\n+        if (isSimplePath()){\n+            NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n+            return SimplePathInterpreter.interpretPath(context, ptr, steps);\n+        }\n+        else {\n+            for (int i = 0; i < steps.length; i++){\n+                context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+                Expression predicates[] = steps[i].getPredicates();\n+                if (predicates != null){\n+                    for (int j = 0; j < predicates.length; j++){\n+                        context = new PredicateContext(context, predicates[j]);\n+                    }\n+                }\n+            }\n+\n+            return context.getSingleNodePointer();\n+        }\n+    }\n+\n+    /**\n+     * Given a root context, walks a path therefrom and builds a context\n+     * that contains all nodes matching the path.\n+     */\n+    protected EvalContext evalSteps(EvalContext context){\n+        if (steps.length == 0){\n+            return context;\n+        }\n+\n+        for (int i = 0; i < steps.length; i++){\n+            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+            Expression predicates[] = steps[i].getPredicates();\n+            if (predicates != null){\n+                for (int j = 0; j < predicates.length; j++){\n+                    context = new PredicateContext(context, predicates[j]);\n+                }\n+            }\n+        }\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Different axes are serviced by different contexts. This method\n+     * allocates the right context for the supplied step.\n+     */\n+    protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest){\n+        switch(axis){\n+            case Compiler.AXIS_ANCESTOR:\n+                return new AncestorContext(context, false, nodeTest);\n+            case Compiler.AXIS_ANCESTOR_OR_SELF:\n+                return new AncestorContext(context, true, nodeTest);\n+            case Compiler.AXIS_ATTRIBUTE:\n+                return new AttributeContext(context, nodeTest);\n+            case Compiler.AXIS_CHILD:\n+                return new ChildContext(context, nodeTest, false, false);\n+            case Compiler.AXIS_DESCENDANT:\n+                return new DescendantContext(context, false, nodeTest);\n+            case Compiler.AXIS_DESCENDANT_OR_SELF:\n+                return new DescendantContext(context, true, nodeTest);\n+            case Compiler.AXIS_FOLLOWING:\n+                return new PrecedingOrFollowingContext(context, nodeTest, false);\n+            case Compiler.AXIS_FOLLOWING_SIBLING:\n+                return new ChildContext(context, nodeTest, true, false);\n+            case Compiler.AXIS_NAMESPACE:\n+                return new NamespaceContext(context, nodeTest);\n+            case Compiler.AXIS_PARENT:\n+                return new ParentContext(context, nodeTest);\n+            case Compiler.AXIS_PRECEDING:\n+                return new PrecedingOrFollowingContext(context, nodeTest, true);\n+            case Compiler.AXIS_PRECEDING_SIBLING:\n+                return new ChildContext(context, nodeTest, true, true);\n+            case Compiler.AXIS_SELF:\n+                return new SelfContext(context, nodeTest);\n+        }\n+        return null;        // Never happens\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class Step {\n     private int axis;\n             }\n         }\n         return false;\n-    }\n-\n-    public void setEvaluationMode(int mode){\n-        if (predicates != null){\n-            for (int i = 0; i < predicates.length; i++){\n-                switch(mode){\n-                    case Expression.EVALUATION_MODE_ALWAYS:\n-                        if (predicates[i].isContextDependent()){\n-                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ALWAYS);\n-                        }\n-                        else {\n-                            predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE_AND_SAVE);\n-                        }\n-                        break;\n-                    case Expression.EVALUATION_MODE_ONCE:\n-                    case Expression.EVALUATION_MODE_ONCE_AND_SAVE:\n-                        predicates[i].setEvaluationMode(Expression.EVALUATION_MODE_ONCE);\n-                        break;\n-                }\n-            }\n-        }\n     }\n \n     public String toString(){\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.4 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class TreeCompiler implements Compiler {\n \n+    private static final QName QNAME_NAME = new QName(null, \"name\");\n+\n     public Object number(String value){\n         return new Constant(new Double(value));\n     }\n         return new QName(prefix, name);\n     }\n \n-    /*\n-    public Object nodeTypeTest(int nodeType){\n-        return new NodeTypeTest(nodeType);\n-    }\n-\n-    public Object processingInstructionTest(String value){\n-        return new ProcessingInstructionTest(value);\n-    }\n-\n-    public Object traverse(boolean recursive, int axis, Object nodeTest, Object[] predicates){\n-        return new Step(recursive, axis, (NodeTest)nodeTest, toExpressionArray(predicates));\n-    }\n-*/\n     public Object sum(Object[] arguments){\n         return new CoreOperation(Expression.OP_SUM, toExpressionArray(arguments));\n     }\n     }\n \n     public Object equal(Object left, Object right){\n-        return new CoreOperation(Expression.OP_EQ, (Expression)left, (Expression)right);\n+        if (isNameAttributeTest((Expression)left)){\n+            return new NameAttributeTest((Expression)left, (Expression)right);\n+        }\n+        else {\n+            return new CoreOperation(Expression.OP_EQ, (Expression)left, (Expression)right);\n+        }\n     }\n \n     public Object notEqual(Object left, Object right){\n         }\n         return stepArray;\n     }\n+    \n+    private boolean isNameAttributeTest(Expression arg){\n+        if (arg.getExpressionTypeCode() != Expression.OP_LOCATION_PATH){\n+            return false;\n+        }\n+        \n+        Step[] steps = ((LocationPath)arg).getSteps();\n+        if (steps.length != 1){\n+            return false;\n+        }\n+        if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE){\n+            return false;\n+        }\n+        NodeTest test = steps[0].getNodeTest();\n+        if (!(test instanceof NodeNameTest)){\n+            return false;\n+        }\n+        if (!((NodeNameTest)test).getNodeName().equals(QNAME_NAME)){\n+            return false;\n+        }\n+        return true;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:39:59 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.EvalContext;\n \n /**\n  * An element of the compile tree holding a variable reference.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n  */\n public class VariableReference extends Expression {\n \n         return false;\n     }\n \n-    public void setEvaluationMode(int evalMode){\n-        if (evalMode == EVALUATION_MODE_ALWAYS){\n-            super.setEvaluationMode(EVALUATION_MODE_ONCE_AND_SAVE);\n-        }\n-        else {\n-            super.setEvaluationMode(evalMode);\n-        }\n+    public Object compute(EvalContext context){\n+        return computeValue(context);\n+    }\n+\n+    /**\n+     * Returns the value of the variable.\n+     */\n+    public Object computeValue(EvalContext context){\n+        return context.getRootContext().getVariableContext(varName);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.3 2002/04/26 01:00:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/26 01:00:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.4 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/26 01:00:38 $\n+ * @version $Revision: 1.4 $ $Date: 2002/05/08 00:40:00 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n         DOMAttributePointer other = (DOMAttributePointer)object;\n         return attr == other.attr;\n     }\n-    \n+\n     public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n         // Won't happen - attributes don't have children\n         return 0;\n-    }    \n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.15 2002/04/28 04:37:01 dmitri Exp $\n- * $Revision: 1.15 $\n- * $Date: 2002/04/28 04:37:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.16 2002/05/08 00:40:00 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2002/05/08 00:40:00 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.w3c.dom.*;\n import java.util.*;\n-\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.util.*;\n import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.parser.*;\n import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import java.beans.*;\n \n-import org.apache.xpath.XPath;\n-import org.apache.xpath.XPathContext;\n-import org.apache.xml.utils.PrefixResolver;\n-import org.apache.xml.utils.PrefixResolverDefault;\n+//import org.apache.xpath.XPath;\n+//import org.apache.xpath.XPathContext;\n+//import org.apache.xml.utils.PrefixResolver;\n+//import org.apache.xml.utils.PrefixResolverDefault;\n \n /**\n  * <p>\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2002/04/28 04:37:01 $\n+ * @version $Revision: 1.16 $ $Date: 2002/05/08 00:40:00 $\n  */\n \n public class JXPathTestCase extends TestCase\n {\n-    private boolean enabled = true;\n+    private boolean enabled = false;\n \n     /**\n      * Exercises this test case only\n     private void testGetValue(JXPathContext context, String xpath, Object expected) {\n         Object actual = context.getValue(xpath);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n-        \n+\n         CompiledExpression expr = context.compile(xpath);\n         actual = expr.getValue(context);\n         assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n     private void testGetValue(JXPathContext context, String xpath, Object expected, Class requiredType) {\n         Object actual = context.getValue(xpath, requiredType);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n- \n+\n         CompiledExpression expr = context.compile(xpath);\n         actual = expr.getValue(context, requiredType);\n         assertEquals(\"Evaluating CE <\" + xpath + \">\", expected, actual);\n     }\n \n     public void testDocumentOrder(){\n-        if (!enabled){\n-            return;\n-        }\n+//        if (!enabled){\n+//            return;\n+//        }\n \n         JXPathContext context = JXPathContext.newContext(createTestBeanWithDOM());\n+\n         testDocumentOrder(context, \"boolean\", \"int\", -1);\n         testDocumentOrder(context, \"integers[1]\", \"integers[2]\", -1);\n         testDocumentOrder(context, \"integers[1]\", \"integers[1]\", 0);\n      * Test JXPath.createPath() with various arguments\n      */\n     public void testCreatePath(){\n-//        if (!enabled){\n-//            return;\n-//        }\n+        if (!enabled){\n+            return;\n+        }\n         TestBean tBean = createTestBeanWithDOM();\n         tBean.setNestedBean(null);\n         tBean.setBeans(null);\n     }\n \n     public void testParserReferenceImpl() throws Exception {\n-        if (!enabled){\n-            return;\n-        }\n+//        if (!enabled){\n+//            return;\n+//        }\n         System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n                 \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n         testParser(JXPathContextFactory.newInstance().newContext(null, bean), false);\n     }\n \n     static final XP[] xpath_tests = new XP[]{\n-\n+/*\n         // Numbers\n         test(\"1\", new Double(1.0)),\n         testEval(\"1\", list(new Double(1.0))),\n \n         test(\"name(integers)\", \"integers\"),\n         testEval(\"*[name(.) = 'integers']\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n-\n+*/\n         // Dynamic properties\n         test(\"nestedBean[@name = 'int']\", new Integer(1)),    // Not implemented in Xalan\n         testPath(\"nestedBean[@name = 'int']\", \"/nestedBean/int\"),\n         test(\"$object//street\", \"Orchard Road\"),\n         testPath(\"$object//street\", \"$object/vendor[1]/location[1]/address[1]/street[1]\"),\n     };\n+\n+    public void testTypeConversions(){\n+        for (int i=0; i < typeConversionTests.length; i++) {\n+            TypeConversionTest test = typeConversionTests[i];\n+            try {\n+                boolean can = TypeUtils.canConvert(test.from, test.toType);\n+                assertTrue(\"Can convert: \" + test, can);\n+                Object result = TypeUtils.convert(test.from, test.toType);\n+                if (result.getClass().isArray()){\n+                    ArrayList list = new ArrayList();\n+                    for (int j = 0; j < Array.getLength(result); j++){\n+                        list.add(Array.get(result, j));\n+                    }\n+                    result = list;\n+                }\n+                assertEquals(\"Convert: \" + test, test.expected, result);\n+            }\n+            catch (Exception ex){\n+                System.err.println(\"Exception during conversion test <\" + test + \">\");\n+                ex.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    private static class TypeConversionTest {\n+        public Object from;\n+        public Class toType;\n+        public Object expected;\n+\n+        public TypeConversionTest(Object from, Class toType, Object expected){\n+            this.from = from;\n+            this.toType = toType;\n+            this.expected = expected;\n+        }\n+        public String toString(){\n+            return from.getClass() + \" to \" + toType;\n+        }\n+    }\n+\n+    private TypeConversionTest[] typeConversionTests = new TypeConversionTest[]{\n+        new TypeConversionTest(new Integer(1), String.class, \"1\"),\n+\n+        new TypeConversionTest(new int[]{1, 2}, List.class,\n+                Arrays.asList(new Object[]{new Integer(1), new Integer(2)})),\n+\n+        new TypeConversionTest(new int[]{1, 2}, String[].class,\n+                list(\"1\", \"2\")),\n+\n+        new TypeConversionTest(list(new Integer(1), new Integer(2)), String[].class,\n+                list(\"1\", \"2\")),\n+    };\n }", "timestamp": 1020818400, "metainfo": ""}