{"sha": "d5a51635e77e49efbf18c5b51834f533e7972953", "log": "1. Now bean's properties can be accessed either with the child:: or the attribute:: axis. 2. Missing attributes can be created with an AbstractFactory   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n      * starts with the given root, which is the result of evaluation\n      * of the root expression of the expression path, applies the\n      * given predicates to it and then follows the given steps.\n-     * All steps must have the axis \"child::\"\n+     * All steps must have the axis \"child::\" or \"attribute::\"\n      * and a name test.  They can also optionally have predicates\n      * of type [@name=...] or simply [...] interpreted as an index.\n      */\n                 Step[] steps, int current_step)\n     {\n         Step step = steps[current_step];\n-        NodePointer childPointer;\n-        if (step.getAxis() == Compiler.AXIS_CHILD){\n-            // Treat the name test as a property name\n-            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n-\n-            childPointer = parentPointer.getPropertyPointer();\n-            ((PropertyPointer)childPointer).setPropertyName(name.toString());\n-        }\n-        else {\n-            childPointer = parentPointer;\n-        }\n+        NodePointer childPointer = createChildPointerForStep(parentPointer, step);\n \n         if (!childPointer.isActual()){\n             // The property does not exist - create a null pointer.\n                 Step[] steps, int current_step)\n     {\n         Step step = steps[current_step];\n+\n+        if (step.getAxis() == Compiler.AXIS_SELF){\n+            return doStep(context, parentPointer, steps, current_step + 1);\n+        }\n+\n         int bestQuality = 0;\n         NodePointer bestMatch = null;\n-        NodeIterator it =\n-                parentPointer.childIterator(step.getNodeTest(), false, null);\n+        NodeIterator it = getNodeIterator(parentPointer, step);\n         if (it != null){\n             for (int i = 1; it.setPosition(i); i++){\n                 NodePointer childPointer = it.getNodePointer();\n         Step step = steps[current_step];\n         Expression predicates[] = step.getPredicates();\n \n-        NodePointer childPointer;\n-        if (step.getAxis() == Compiler.AXIS_CHILD){\n-            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n-            childPointer = parentPointer.getPropertyPointer();\n-            ((PropertyPointer)childPointer).setPropertyName(name.toString());\n-        }\n-        else {\n-            childPointer = parentPointer;\n-        }\n+        NodePointer childPointer =\n+                createChildPointerForStep(parentPointer, step);\n         if (!childPointer.isActual()){\n             // Property does not exist - return a null pointer\n             return createNullPointer(\n             context, childPointer, steps, current_step, predicates, 0);\n     }\n \n+    private static NodePointer createChildPointerForStep(\n+                PropertyOwnerPointer parentPointer, Step step)\n+    {\n+        int axis = step.getAxis();\n+        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE){\n+            NodePointer childPointer;\n+            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)){\n+                childPointer = new LangAttributePointer(parentPointer);\n+            }\n+            else {\n+                childPointer = parentPointer.getPropertyPointer();\n+                ((PropertyPointer)childPointer).setPropertyName(name.toString());\n+                childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n+            }\n+            return childPointer;\n+        }\n+        else {\n+            return parentPointer;\n+        }\n+    }\n+\n     /**\n      * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n      * The method evaluates the first predicate in a special way and\n         Step step = steps[current_step];\n         Expression predicates[] = step.getPredicates();\n \n-        if (step.getAxis() == Compiler.AXIS_SELF){\n+        int axis = step.getAxis();\n+        if (axis == Compiler.AXIS_SELF){\n             return doPredicate(context, parent,\n                 steps, current_step, predicates, 0);\n         }\n         // It is a very common use case, so it deserves individual\n         // attention\n         if (predicates.length == 1){\n-            NodeIterator it = parent.childIterator(\n-                    step.getNodeTest(), false, null);\n+            NodeIterator it = getNodeIterator(parent, step);\n             NodePointer pointer = null;\n             if (it != null){\n                 if (predicate instanceof NameAttributeTest){ // [@name = key]\n             }\n         }\n         else {\n-            NodeIterator it = parent.childIterator(\n-                    step.getNodeTest(), false, null);\n+            NodeIterator it = getNodeIterator(parent, step);\n             if (it != null){\n                 List list = new ArrayList();\n                 for (int i = 1; it.setPosition(i); i++){\n \n         Step step = steps[current_step];\n \n-        if (step.getAxis() == Compiler.AXIS_CHILD){\n+        int axis = step.getAxis();\n+        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE){\n             NullPropertyPointer pointer = new NullPropertyPointer(parent);\n             QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n             pointer.setPropertyName(name.toString());\n+            pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n             parent = pointer;\n         }\n         // else { it is self::node() }\n         return createNullPointer(\n                     context, parent, steps, current_step + 1);\n     }\n+\n+    private static NodeIterator getNodeIterator(NodePointer pointer, Step step){\n+        if (step.getAxis() == Compiler.AXIS_CHILD){\n+            return pointer.childIterator(step.getNodeTest(), false, null);\n+        }\n+        else {      // Compiler.AXIS_ATTRIBUTE\n+            if (!(step.getNodeTest() instanceof NodeNameTest)){\n+                throw new UnsupportedOperationException(\n+                    \"Not supported node test for attributes: \" +\n+                        step.getNodeTest());\n+            }\n+            return pointer.attributeIterator(\n+                ((NodeNameTest)step.getNodeTest()).getNodeName());\n+        }\n+    }\n+\n+    private static boolean isLangAttribute(QName name){\n+        return name.getPrefix() != null &&\n+                name.getPrefix().equals(\"xml\") &&\n+                name.getName().equals(\"lang\");\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.5 2002/08/10 01:39:29 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/08/10 01:39:29 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.6 2002/10/13 02:59:01 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/10/13 02:59:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/08/10 01:39:29 $\n+ * @version $Revision: 1.6 $ $Date: 2002/10/13 02:59:01 $\n  */\n public abstract class Path extends Expression {\n \n                                 Compiler.NODE_TYPE_NODE){\n                     accepted = true;\n                 }\n-                else if (steps[i].getAxis() == Compiler.AXIS_CHILD &&\n+                else if ((steps[i].getAxis() == Compiler.AXIS_CHILD ||\n+                          steps[i].getAxis() == Compiler.AXIS_ATTRIBUTE)  &&\n                         (steps[i].getNodeTest() instanceof NodeNameTest) &&\n                         !((NodeNameTest)steps[i].getNodeTest()).\n                                     getNodeName().getName().equals(\"*\")){\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.10 2002/08/10 16:13:03 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/08/10 16:13:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.11 2002/10/13 02:59:01 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/10/13 02:59:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/08/10 16:13:03 $\n+ * @version $Revision: 1.11 $ $Date: 2002/10/13 02:59:01 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n \n     public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n     protected int index = WHOLE_COLLECTION;\n     public static String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n+    private boolean attribute = false;\n \n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n     public static NodePointer newNodePointer(\n-        QName name,\n-        Object bean,\n-        Locale locale) {\n+            QName name, Object bean, Locale locale)\n+    {\n         if (bean == null) {\n             return new NullPointer(name, locale);\n         }\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n-            NodePointer pointer = factories[i].createNodePointer(name, bean, locale);\n+            NodePointer pointer = factories[i].\n+                    createNodePointer(name, bean, locale);\n             if (pointer != null) {\n                 return pointer;\n             }\n         }\n         throw new JXPathException(\n-            \"Could not allocate a NodePointer for object of \" + bean.getClass());\n+            \"Could not allocate a NodePointer for object of \" +\n+            bean.getClass());\n     }\n \n     /**\n      * Allocates an new child NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n-    public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean) {\n+    public static NodePointer newChildNodePointer(\n+            NodePointer parent, QName name, Object bean)\n+    {\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n-            NodePointer pointer = factories[i].createNodePointer(parent, name, bean);\n+            NodePointer pointer = factories[i].\n+                    createNodePointer(parent, name, bean);\n             if (pointer != null) {\n                 return pointer;\n             }\n         }\n         throw new JXPathException(\n-            \"Could not allocate a NodePointer for object of \" + bean.getClass());\n+            \"Could not allocate a NodePointer for object of \" +\n+            bean.getClass());\n     }\n \n     protected NodePointer parent;\n \n     public NodePointer getParent() {\n         return parent;\n+    }\n+\n+    /**\n+     * Set to true if the pointer represents the \"attribute::\" axis.\n+     */\n+    public void setAttribute(boolean attribute){\n+        this.attribute = attribute;\n+    }\n+\n+    /**\n+     * Returns true if the pointer represents the \"attribute::\" axis.\n+     */\n+    public boolean isAttribute(){\n+        return attribute;\n     }\n \n     /**\n \n     /**\n      * If the pointer represents a collection (or collection element),\n-     * returns the length of the collection. Otherwise returns 1 (even if the value is null).\n+     * returns the length of the collection.\n+     * Otherwise returns 1 (even if the value is null).\n      */\n     public int getLength() {\n         Object value = getBaseValue();\n      * if it is null. A non-actual pointer represents a part that does not exist\n      * at all.\n      * For instance consider the pointer \"/address/street\".\n-     * If both <em>address</em> and <em>street</em> are not null, the pointer is actual.\n-     * If <em>address</em> is not null, but <em>street</em> is null, the pointer is still actual.\n+     * If both <em>address</em> and <em>street</em> are not null,\n+     * the pointer is actual.\n+     * If <em>address</em> is not null, but <em>street</em> is null,\n+     * the pointer is still actual.\n      * If <em>address</em> is null, the pointer is not actual.\n-     * (In JavaBeans) if <em>address</em> is not a property of the root bean, a Pointer\n-     * for this path cannot be obtained at all - actual or otherwise.\n+     * (In JavaBeans) if <em>address</em> is not a property of the root bean,\n+     * a Pointer for this path cannot be obtained at all - actual or otherwise.\n      */\n     public boolean isActual() {\n         if (index == WHOLE_COLLECTION) {\n     /**\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n-     * \n+     *\n      * @deprecated 1.1 Please use getNode()\n      */\n     public Object getNodeValue(){\n-    \treturn getNode();\n+        return getNode();\n     }\n \n     /**\n      * to a \"canonical\" type.\n      */\n     public abstract Object getNode();\n-    \n+\n     /**\n      * Converts the value to the required type and changes the corresponding\n      * object to that value.\n      * Compares two child NodePointers and returns a positive number,\n      * zero or a positive number according to the order of the pointers.\n      */\n-    public abstract int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2);\n+    public abstract int compareChildNodePointers(\n+            NodePointer pointer1, NodePointer pointer2);\n \n     /**\n      * Checks if this Pointer matches the supplied NodeTest.\n             return testLocalName.equals(nodeName.getName());\n         }\n         else if (test instanceof NodeTypeTest) {\n-            if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) {\n+            if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE){\n                 return isNode();\n             }\n         }\n                             int index, Object value) {\n         throw new JXPathException(\n             \"Cannot create an object for path \"\n-                + asPath()\n+                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n \n     /**\n      * Called by a child pointer when it needs to create a parent object\n-     * for a non-existent collection element.  It may have to expand the collection,\n-     * then create an element object and return a new pointer describing the\n-     * newly created element.\n-     */\n-    public NodePointer createChild(JXPathContext context, QName name, int index) {\n+     * for a non-existent collection element.  It may have to expand the\n+     * collection, then create an element object and return a new pointer\n+     * describing the newly created element.\n+     */\n+    public NodePointer createChild(\n+            JXPathContext context, QName name, int index) {\n         throw new JXPathException(\n             \"Cannot create an object for path \"\n-                + asPath()\n+                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n+                + \", operation is not allowed for this type of node\");\n+    }\n+\n+    /**\n+     * Called to create a non-existing attribute\n+     */\n+    public NodePointer createAttribute(JXPathContext context, QName name){\n+        throw new JXPathException(\n+            \"Cannot create an attribute for path \"\n+                + asPath() + \"/@\" + name\n                 + \", operation is not allowed for this type of node\");\n     }\n \n     }\n \n     /**\n-     * Returns a NodeIterator that iterates over all attributes of the current node\n-     * matching the supplied node name (could have a wildcard).\n+     * Returns a NodeIterator that iterates over all attributes of the current\n+     * node matching the supplied node name (could have a wildcard).\n      * May return null if the object does not support the attributes.\n      */\n     public NodeIterator attributeIterator(QName qname) {\n \n     /**\n      * Returns a NodePointer for the specified namespace. Will return null\n-     * if namespaces are not supported. Will return UNKNOWN_NAMESPACE if there is no such namespace.\n+     * if namespaces are not supported.\n+     * Will return UNKNOWN_NAMESPACE if there is no such namespace.\n      */\n     public NodePointer namespacePointer(String namespace) {\n         return null;\n         StringBuffer buffer = new StringBuffer();\n         if (getParent() != null) {\n             buffer.append(getParent().asPath());\n-            // TBD: the following needs to be redesigned.  What this condition says is\n-            // \"if the parent of this node has already appended this node's name,\n-            // don't do it again\".  However, I would hate to add an ugly API like\n-            // \"isResponsibleForAppendingChildName()\".\n-            if (getParent().isNode() || (parent instanceof NullElementPointer)) {\n+            // TBD: the following needs to be redesigned.\n+            // What this condition says is\n+            // \"if the parent of this node has already appended this node's\n+            // name, don't do it again\".  However, I would hate to add an ugly\n+            // API like \"isResponsibleForAppendingChildName()\".\n+            if (getParent().isNode() || (parent instanceof NullElementPointer)){\n                 QName name = getName();\n                 if (name != null) {\n                     buffer.append('/');\n+                    if (attribute){\n+                        buffer.append('@');\n+                    }\n                     buffer.append(name);\n                 }\n             }\n         }\n         else {\n             QName name = getName();\n+            if (attribute){\n+                buffer.append('@');\n+            }\n             buffer.append(name);\n         }\n         if (index != WHOLE_COLLECTION && isCollection()) {\n         return buffer.toString();\n     }\n \n-    public static int count = 0;\n     public Object clone() {\n-        count ++;\n         try {\n             NodePointer ptr = (NodePointer)super.clone();\n             if (parent != null){\n     }\n \n     public int compareTo(Object object){\n-        NodePointer pointer = (NodePointer) object;         // Let it throw a ClassCastException\n+        // Let it throw a ClassCastException\n+        NodePointer pointer = (NodePointer) object;\n         if (parent == pointer.parent){\n             if (parent == null){\n                 return 0;\n         return compareNodePointers(this, depth1, pointer, depth2);\n     }\n \n-    private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2){\n-//        System.err.println(\"Comparing \" + p1.asPath() + \" (\" + depth1 + \") ~ \" +\n-//                p2.asPath() + \" (\" + depth2 + \")\");\n+    private int compareNodePointers(\n+            NodePointer p1, int depth1, NodePointer p2, int depth2)\n+    {\n         if (depth1 < depth2){\n             int r = compareNodePointers(p1, depth1, p2.parent, depth2-1);\n             if (r != 0){\n                 \"Cannot compare pointers that do not belong to the same tree: '\"\n                 + p1 + \"' and '\" + p2 + \"'\");\n         }\n-        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n+        int r = compareNodePointers(\n+                p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0){\n             return r;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.2 2002/04/24 04:06:46 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:06:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.3 2002/10/13 02:59:01 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/10/13 02:59:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * An iterator of attributes of a JavaBean. Currently supports only one\n- * attribute - \"lang\".\n+ * An iterator of attributes of a JavaBean. Returns bean properties as\n+ * well as the \"xml:lang\" attribute.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:06:46 $\n+ * @version $Revision: 1.3 $ $Date: 2002/10/13 02:59:01 $\n  */\n-public class BeanAttributeIterator implements NodeIterator {\n+public class BeanAttributeIterator extends PropertyIterator {\n     private NodePointer parent;\n-    private QName name;\n     private int position = 0;\n+    private boolean includeXmlLang;\n \n-    public BeanAttributeIterator(NodePointer parent, QName name){\n+    public BeanAttributeIterator(PropertyOwnerPointer parent, QName name){\n+        super(parent,\n+                (name.getPrefix() == null &&\n+                 (name.getName() == null || name.getName().equals(\"*\"))) ?\n+                        null : name.toString(), false, null);\n         this.parent = parent;\n-        this.name = name;\n+        includeXmlLang =\n+            (name.getPrefix() != null && name.getPrefix().equals(\"xml\")) &&\n+            (name.getName().equals(\"lang\") || name.getName().equals(\"*\"));\n     }\n \n     public NodePointer getNodePointer(){\n-        return new LangAttributePointer(parent);\n+        if (includeXmlLang && position == 1){\n+            return new LangAttributePointer(parent);\n+        }\n+        else {\n+            return super.getNodePointer();\n+        }\n     }\n \n     public int getPosition(){\n \n     public boolean setPosition(int position){\n         this.position = position;\n-        return position == 1 && name.getPrefix() != null && name.getPrefix().equals(\"xml\") &&\n-            (name.getName().equals(\"lang\") || name.getName().equals(\"*\"));\n+        if (includeXmlLang){\n+            if (position == 1){\n+                return true;\n+            }\n+            else {\n+                return super.setPosition(position - 1);\n+            }\n+        }\n+        else {\n+            this.position = position;\n+            return super.setPosition(position);\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.7 2002/08/10 16:13:04 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/08/10 16:13:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.8 2002/10/13 02:59:01 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/10/13 02:59:01 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/08/10 16:13:04 $\n+ * @version $Revision: 1.8 $ $Date: 2002/10/13 02:59:01 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n     }\n \n     public QName getName(){\n-        return new QName(null, propertyName);\n+        return new QName(propertyName);\n     }\n \n     public void setPropertyIndex(int index){\n     }\n \n     public NodePointer getValuePointer(){\n-        return new NullPointer(this,  new QName(null, getPropertyName()));\n+        return new NullPointer(this,  new QName(getPropertyName()));\n     }\n \n     protected boolean isActualProperty(){\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-        return parent.createChild(context, getName(), getIndex());\n+        if (isAttribute()){\n+            return parent.createAttribute(context, getName());\n+        }\n+        else {\n+            return parent.createChild(context, getName(), getIndex());\n+        }\n     }\n \n     public NodePointer createPath(JXPathContext context, Object value){\n-        return parent.createChild(context, getName(), getIndex(), value);\n-    }\n-\n-    public NodePointer createChild(JXPathContext context, \n+        if (isAttribute()){\n+            NodePointer pointer = parent.createAttribute(context, getName());\n+            pointer.setValue(value);\n+            return pointer;\n+        }\n+        else {\n+            return parent.createChild(context, getName(), getIndex(), value);\n+        }\n+    }\n+\n+    public NodePointer createChild(JXPathContext context,\n             QName name, int index, Object value){\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n-    public NodePointer createChild(JXPathContext context, \n+    public NodePointer createChild(JXPathContext context,\n             QName name, int index){\n         return createPath(context).createChild(context, name, index);\n     }\n     private String escape(String string){\n         int index = string.indexOf('\\'');\n         while (index != -1){\n-            string = string.substring(0, index) + \"&apos;\" + \n+            string = string.substring(0, index) + \"&apos;\" +\n                     string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n         while (index != -1){\n-            string = string.substring(0, index) + \"&quot;\" + \n+            string = string.substring(0, index) + \"&quot;\" +\n                     string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.9 2002/08/26 22:15:26 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/08/26 22:15:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.10 2002/10/13 02:59:02 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/10/13 02:59:02 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/08/26 22:15:26 $\n+ * @version $Revision: 1.10 $ $Date: 2002/10/13 02:59:02 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n         NodePointer ptr = createChild(context, name, index);\n         ptr.setValue(value);\n         return ptr;\n+    }\n+\n+    public NodePointer createAttribute(JXPathContext context, QName name){\n+        if (!(node instanceof Element)){\n+            return super.createAttribute(context, name);\n+        }\n+        Element element = (Element)node;\n+        String prefix = name.getPrefix();\n+        if (prefix != null){\n+            String ns = getNamespaceURI(prefix);\n+            if (ns == null){\n+                throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\n+            }\n+            element.setAttributeNS(ns, name.toString(), \"\");\n+        }\n+        else {\n+            if (!element.hasAttribute(name.getName())){\n+                element.setAttribute(name.getName(), \"\");\n+            }\n+        }\n+        NodeIterator it = attributeIterator(name);\n+        it.setPosition(1);\n+        return it.getNodePointer();\n     }\n \n     public void remove(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:29:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.2 2002/10/13 02:59:02 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/10/13 02:59:02 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ * @version $Revision: 1.2 $ $Date: 2002/10/13 02:59:02 $\n  */\n public class JDOMNodePointer extends NodePointer {\n     private Object node;\n         return ptr;\n     }\n \n+    public NodePointer createAttribute(JXPathContext context, QName name){\n+        if (!(node instanceof Element)){\n+            return super.createAttribute(context, name);\n+        }\n+\n+        Element element = (Element)node;\n+        String prefix = name.getPrefix();\n+        if (prefix != null){\n+            Namespace ns = element.getNamespace(prefix);\n+            if (ns == null){\n+                throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\n+            }\n+            Attribute attr = element.getAttribute(name.getName(), ns);\n+            if (attr == null){\n+                element.setAttribute(name.getName(), \"\", ns);\n+            }\n+        }\n+        else {\n+            Attribute attr = element.getAttribute(name.getName());\n+            if (attr == null){\n+                element.setAttribute(name.getName(), \"\");\n+            }\n+        }\n+        NodeIterator it = attributeIterator(name);\n+        it.setPosition(1);\n+        return it.getNodePointer();\n+    }\n+\n     public void remove(){\n         Element parent = nodeParent(node);\n         if (parent == null){", "timestamp": 1034477942, "metainfo": ""}