{"sha": "b9c9d01e7673524c6f7ec4f7d0f9c6632bddc7c1", "log": "tentative json schema java representation.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n+\n+import java.math.BigDecimal;\n+import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n         //objectNode.put(\"required\", false);\n         return objectNode;\n     }\n-\n+    \n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaFactory.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+public class SchemaFactory {\n+\n+\t\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class AnySchema extends ValueTypeSchema {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.ANY.toString());\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+/*\n+ * This attribute defines the allowed items in an instance array, and\n+   MUST be a schema or an array of schemas.  The default value is an\n+   empty schema which allows any value for items in the instance array.\n+ */\n+public class ArraySchema extends ContainerTypeSchema {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.ARRAY.toString());\n+\t\n+\t//This attribute defines the minimum number of values in an array\n+\tprivate int minItems;\n+\t\n+\t//This attribute defines the maximum number of values in an array\n+\tprivate int maxItems;\n+\t\n+\t/*\n+\t * This attribute indicates that all items in an array instance MUST be\n+\t   unique (contains no two identical values).\n+\t\n+\t   Two instance are consider equal if they are both of the same type\n+\t   and:\n+\t\n+\t      are null; or are booleans/numbers/strings and have the same value; or\n+\t\n+\t      are arrays, contains the same number of items, and each item in\n+\t      the array is equal to the corresponding item in the other array;\n+\t      or\n+\t\n+\t      are objects, contains the same property names, and each property\n+\t      in the object is equal to the corresponding property in the other\n+\t      object.\n+\t */\n+\tprivate boolean uniqueItems;\n+\t\n+\tprivate ArraySchema.Items items;\n+\t\n+\tprivate ArraySchema.AdditionalItems additionalItems;\n+\t\n+\t/*\n+\t * This attribute defines the allowed items in an instance array, and\n+\t   MUST be a schema or an array of schemas.  The default value is an\n+\t   empty schema which allows any value for items in the instance array.\n+\t */\n+\tpublic static abstract class Items {}\n+\t\n+\t/*\n+\t * When this attribute value is a schema and the instance value is an\n+\t   array, then all the items in the array MUST be valid according to the\n+\t   schema.\n+\t */\n+\tpublic static class SingleItems extends ArraySchema.Items {\n+\t\tpublic static final ArraySchema.SingleItems defaultSingleItems = new SingleItems();\n+\t}\n+\t\n+\t/*\n+\t * When this attribute value is an array of schemas and the instance\n+\t   value is an array, each position in the instance array MUST conform\n+\t   to the schema in the corresponding position for this array.  This\n+\t   called tuple typing.  When tuple typing is used, additional items are\n+\t   allowed, disallowed, or constrained by the \"additionalItems\"\n+\t */\n+\tpublic static class ArrayItems extends ArraySchema.Items {}\n+\t\n+\t/*\n+\t * This provides a definition for additional items in an array instance\n+   when tuple definitions of the items is provided.\n+\t */\n+\tpublic static abstract class AdditionalItems {}\n+\t\n+\t/*\n+\t *  This can be false\n+   \t\tto indicate additional items in the array are not allowed\n+\t */\n+\tpublic static class NoAdditionalItems {}\n+\t\n+\t/*\n+\t * or it can\n+   \t\tbe a schema that defines the schema of the additional items.\n+\t */\n+\tpublic static class SchemaAdditionalItems {\n+\t\tprivate Schema schema;\n+\t}\n+ }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/BooleanSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.BooleanNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class BooleanSchema extends ValueTypeSchema<BooleanNode> {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.BOOLEAN.toString());\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+\n+public abstract class ContainerTypeSchema extends SimpleTypeSchema {\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/HyperSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.jsonschema.types.HyperSchema.LinkDescriptionObject;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class HyperSchema extends Schema {\n+\t\n+\t\n+\t/*\n+\t * This attribute indicates that the instance property SHOULD NOT be\n+\t   changed.  Attempts by a user agent to modify the value of this\n+\t   property are expected to be rejected by a server.\n+\t */\n+\tprivate TextNode readOnly;\n+\t\n+\t/*\n+\t * If the instance property value is a string, this attribute defines\n+\t   that the string SHOULD be interpreted as binary data and decoded\n+\t   using the encoding named by this schema property.  RFC 2045, Sec 6.1\n+\t   [RFC2045] lists the possible values for this property.\n+\t */\n+\tprivate TextNode contentEncoding;\n+\t\n+\t\n+\t/*\n+\t * This attribute is a URI that defines what the instance's URI MUST\n+\t   start with in order to validate.  The value of the \"pathStart\"\n+\t   attribute MUST be resolved as per RFC 3986, Sec 5 [RFC3986], and is\n+\t   relative to the instance's URI.\n+\t\n+\t   When multiple schemas have been referenced for an instance, the user\n+\t   agent can determine if this schema is applicable for a particular\n+\t   instance by determining if the URI of the instance begins with the\n+\t   the value of the \"pathStart\" attribute.  If the URI of the instance\n+\t   does not start with this URI, or if another schema specifies a\n+\t   starting URI that is longer and also matches the instance, this\n+\t   schema SHOULD NOT be applied to the instance.  Any schema that does\n+\t   not have a pathStart attribute SHOULD be considered applicable to all\n+\t   the instances for which it is referenced.\n+\t */\n+\tprivate TextNode pathStart;\n+\t\n+\t/*\n+\t * This attribute defines the media type of the instance representations\n+\t\tthat this schema is defining.\n+\t */\n+\tprivate TextNode mediaType;\n+\t\n+\t/*\n+\t * This property indicates the fragment resolution protocol to use for\n+\t   resolving fragment identifiers in URIs within the instance\n+\t   representations.  This applies to the instance object URIs and all\n+\t   children of the instance object's URIs.  The default fragment\n+\t   resolution protocol is \"slash-delimited\", which is defined below.\n+\t   Other fragment resolution protocols MAY be used, but are not defined\n+\t   in this document.\n+\t\n+\t   The fragment identifier is based on RFC 2396, Sec 5 [RFC2396], and\n+\t   defines the mechanism for resolving references to entities within a\n+\t   document.\n+\t */\n+\tprivate TextNode fragmentResolution;\n+\t/*\n+\t * 6.2.1.  slash-delimited fragment resolution\n+\n+\t\t   With the slash-delimited fragment resolution protocol, the fragment\n+\t\t   identifier is interpreted as a series of property reference tokens\n+\t\t   that start with and are delimited by the \"/\" character (\\x2F).  Each\n+\t\t   property reference token is a series of unreserved or escaped URI\n+\t\t   characters.  Each property reference token SHOULD be interpreted,\n+\t\t   starting from the beginning of the fragment identifier, as a path\n+\t\t   reference in the target JSON structure.  The final target value of\n+\t\t   the fragment can be determined by starting with the root of the JSON\n+\t\t   structure from the representation of the resource identified by the\n+\t\t   pre-fragment URI.  If the target is a JSON object, then the new\n+\t\t   target is the value of the property with the name identified by the\n+\t\t   next property reference token in the fragment.  If the target is a\n+\t\t   JSON array, then the target is determined by finding the item in\n+\t\t   array the array with the index defined by the next property reference\n+\t\t   token (which MUST be a number).  The target is successively updated\n+\t\t   for each property reference token, until the entire fragment has been \n+\t\t   traversed.\n+\t\t\n+\t\t   Property names SHOULD be URI-encoded.  In particular, any \"/\" in a\n+\t\t   property name MUST be encoded to avoid being interpreted as a\n+\t\t   property delimiter.\n+\t\t\n+\t\t   For example, for the following JSON representation:\n+\t\t\n+\t\t   {\n+\t\t     \"foo\":{\n+\t\t       \"anArray\":[\n+\t\t         {\"prop\":44}\n+\t\t       ],\n+\t\t       \"another prop\":{\n+\t\t         \"baz\":\"A string\"\n+\t\t       }\n+\t\t     }\n+\t\t   }\n+\t\t\n+\t\t   The following fragment identifiers would be resolved:\n+\t\t\n+\t\t   fragment identifier      resolution\n+\t\t   -------------------      ----------\n+\t\t   #                        self, the root of the resource itself\n+\t\t   #/foo                    the object referred to by the foo property\n+\t\t   #/foo/another%20prop     the object referred to by the \"another prop\"\n+\t\t                            property of the object referred to by the\n+\t\t                            \"foo\" property\n+\t\t   #/foo/another%20prop/baz the string referred to by the value of \"baz\"\n+\t\t                            property of the \"another prop\" property of\n+\t\t                            the object referred to by the \"foo\" property\n+\t\t   #/foo/anArray/0          the first object in the \"anArray\" array\n+\t\t\n+\t\t6.2.2.  dot-delimited fragment resolution\n+\t\t\n+\t\t   The dot-delimited fragment resolution protocol is the same as slash-\n+\t\t   delimited fragment resolution protocol except that the \".\" character\n+\t\t   (\\x2E) is used as the delimiter between property names (instead of\n+\t\t   \"/\") and the path does not need to start with a \".\".  For example,\n+\t\t   #.foo and #foo are a valid fragment identifiers for referencing the\n+\t\t   value of the foo propery.\n+\t*/\n+\t\n+\tprivate LinkDescriptionObject[] links;\n+\t\n+\t/*\n+\t *  A link description object is used to describe link relations.  In the\n+\t   context of a schema, it defines the link relations of the instances\n+\t   of the schema, and can be parameterized by the instance values.  The\n+\t   link description format can be used on its own in regular (non-schema\n+\t   documents), and use of this format can be declared by referencing the\n+\t   normative link description schema as the the schema for the data\n+\t   structure that uses the links.\n+\t */\n+\tpublic class LinkDescriptionObject {\n+\t\t\n+\t\t/*\n+\t\t * The value of the \"href\" link description property indicates the\n+\t\t   target URI of the related resource.  The value of the instance\n+\t\t   property SHOULD be resolved as a URI-Reference per RFC 3986 [RFC3986]\n+\t\t   and MAY be a relative URI.  The base URI to be used for relative\n+\t\t   resolution SHOULD be the URI used to retrieve the instance object\n+\t\t   (not the schema) when used within a schema.  Also, when links are\n+\t\t   used within a schema, the URI SHOULD be parametrized by the property\n+\t\t   values of the instance object, if property values exist for the\n+\t\t   corresponding variables in the template (otherwise they MAY be\n+\t\t   provided from alternate sources, like user input).\n+\t\t\n+\t\t   Instance property values SHOULD be substituted into the URIs where\n+\t\t   matching braces ('{', '}') are found surrounding zero or more\n+\t\t   characters, creating an expanded URI.  Instance property value\n+\t\t   substitutions are resolved by using the text between the braces to\n+\t\t   denote the property name from the instance to get the value to\n+\t\t   substitute.  For example, if an href value is defined:\n+\t\t\n+\t\t   http://somesite.com/{id}\n+\t\t\n+\t\t   Then it would be resolved by replace the value of the \"id\" property\n+\t\t   value from the instance object.  If the value of the \"id\" property\n+\t\t   was \"45\", the expanded URI would be:\n+\n+\t\t   http://somesite.com/45\n+\t \t\n+\t\t   If matching braces are found with the string \"@\" (no quotes) between\n+\t\t   the braces, then the actual instance value SHOULD be used to replace\n+\t\t   the braces, rather than a property value.  This should only be used\n+\t\t   in situations where the instance is a scalar (string, boolean, or\n+\t\t   number), and not for objects or arrays.\n+\n+\t\t */\n+\t\tprivate TextNode href;\n+\t\t\n+\t\t/*\n+\t\t * The value of the \"rel\" property indicates the name of the relation to\n+\t\t   the target resource.  The relation to the target SHOULD be\n+\t\t   interpreted as specifically from the instance object that the schema\n+\t\t   (or sub-schema) applies to, not just the top level resource that\n+\t\t   contains the object within its hierarchy.  If a resource JSON\n+\t\t   representation contains a sub object with a property interpreted as a\n+\t\t   link, that sub-object holds the relation with the target.  A relation\n+\t\t   to target from the top level resource MUST be indicated with the\n+\t\t   schema describing the top level JSON representation.\n+\t\t\n+\t\t   Relationship definitions SHOULD NOT be media type dependent, and\n+\t\t   users are encouraged to utilize existing accepted relation\n+\t\t   definitions, including those in existing relation registries (see RFC\n+\t\t   4287 [RFC4287]).  However, we define these relations here for clarity\n+\t\t   of normative interpretation within the context of JSON hyper schema\n+\t\t   defined relations:\n+\t\t\n+\t\t   self  If the relation value is \"self\", when this property is\n+\t\t      encountered in the instance object, the object represents a\n+\t\t      resource and the instance object is treated as a full\n+\t\t      representation of the target resource identified by the specified\n+\t\t      URI.\n+\t\t\n+\t\t   full  This indicates that the target of the link is the full\n+\t\t      representation for the instance object.  The object that contains\n+\t\t      this link possibly may not be the full representation.\n+\t\t\n+\t\t   describedby  This indicates the target of the link is the schema for\n+\t\t      the instance object.  This MAY be used to specifically denote the\n+\t\t      schemas of objects within a JSON object hierarchy, facilitating\n+\t\t      polymorphic type data structures.\n+\t\t\n+\t\t   root  This relation indicates that the target of the link SHOULD be\n+\t\t      treated as the root or the body of the representation for the\n+\t\t      purposes of user agent interaction or fragment resolution.  All\n+\t\t      other properties of the instance objects can be regarded as meta-\n+\t\t       data descriptions for the data.\n+\n+\t\t   The following relations are applicable for schemas (the schema as the\n+\t\t   \"from\" resource in the relation):\n+\t\t\n+\t\t   instances  This indicates the target resource that represents\n+\t\t      collection of instances of a schema.\n+\t\t\n+\t\t   create  This indicates a target to use for creating new instances of\n+\t\t      a schema.  This link definition SHOULD be a submission link with a\n+\t\t      non-safe method (like POST).\n+\t\t\n+\t\t   For example, if a schema is defined:\n+\t\t\n+\t\t   {\n+\t\t     \"links\": [\n+\t\t       {\n+\t\t         \"rel\": \"self\"\n+\t\t         \"href\": \"{id}\"\n+\t\t       },\n+\t\t       {\n+\t\t         \"rel\": \"up\"\n+\t\t         \"href\": \"{upId}\"\n+\t\t       },\n+\t\t       {\n+\t\t         \"rel\": \"children\"\n+\t\t         \"href\": \"?upId={id}\"\n+\t\t       }\n+\t\t     ]\n+\t\t   }\n+\t\t\n+\t\t   And if a collection of instance resource's JSON representation was\n+\t\t   retrieved:\n+\t\t\n+\t\t   GET /Resource/\n+\t\t\n+\t\t   [\n+\t\t     {\n+\t\t       \"id\": \"thing\",\n+\t\t       \"upId\": \"parent\"\n+\t\t     },\n+\t\t     {\n+\t\t       \"id\": \"thing2\",\n+\t\t       \"upId\": \"parent\"\n+\t\t     }\n+\t\t   ]\n+\t\t\n+\t\t   This would indicate that for the first item in the collection, its\n+\t\t   own (self) URI would resolve to \"/Resource/thing\" and the first\n+\t\t   item's \"up\" relation SHOULD be resolved to the resource at\n+\t\t   \"/Resource/parent\".  The \"children\" collection would be located at\n+\t\t   \"/Resource/?upId=thing\".\n+\t\t */\n+\t\tprivate TextNode rel;\n+\t\t\n+\t\t/*\n+\t\t * This property value is a schema that defines the expected structure\n+\t\t\tof the JSON representation of the target of the link.\n+\t\t */\n+\t\tprivate Schema targetSchema;\n+\t\t\n+\t\t/*\n+\t\t * This attribute defines which method can be used to access the target\n+\t\t   resource.  In an HTTP environment, this would be \"GET\" or \"POST\"\n+\t\t   (other HTTP methods such as \"PUT\" and \"DELETE\" have semantics that\n+\t\t   are clearly implied by accessed resources, and do not need to be\n+\t\t   defined here).  This defaults to \"GET\".\n+\t\t */\n+\t\tprivate TextNode method;\n+\t\t\n+\t\t/*\n+\t\t *  If present, this property indicates a query media type format that\n+\t\t   the server supports for querying or posting to the collection of\n+\t\t   instances at the target resource.  The query can be suffixed to the\n+\t\t   target URI to query the collection with property-based constraints on\n+\t\t   the resources that SHOULD be returned from the server or used to post\n+\t\t   data to the resource (depending on the method).  For example, with\n+\t\t   the following schema:\n+\t\t\n+\t\t   {\n+\t\t    \"links\":[\n+\t\t      {\n+\t\t        \"enctype\":\"application/x-www-form-urlencoded\",\n+\t\t        \"method\":\"GET\",\n+\t\t        \"href\":\"/Product/\",\n+\t\t        \"properties\":{\n+\t\t           \"name\":{\"description\":\"name of the product\"}\n+\t\t        }\n+\t\t      }\n+\t\t    ]\n+\t\t   }\n+\t\t   This indicates that the client can query the server for instances\n+\t\t   that have a specific name:\n+\t\t\n+\t\t   /Product/?name=Slinky\n+\t\t\n+\t\t   If no enctype or method is specified, only the single URI specified\n+\t\t   by the href property is defined.  If the method is POST,\n+\t\t   \"application/json\" is the default media type.\n+\t\t */\n+\t\tprivate TextNode enctype;\n+\t\t\n+\t\t/*\n+\t\t * This attribute contains a schema which defines the acceptable\n+\t\t   structure of the submitted request (for a GET request, this schema\n+\t\t   would define the properties for the query string and for a POST\n+\t\t   request, this would define the body).\n+\t\t */\n+\t\tprivate Schema schema;\n+\t\t\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.IntNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class IntegerSchema extends NumberSchema {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.INTEGER.toString());\n+\t\n+\t/*\n+\t * This attribute defines what value the number instance must be\n+\t   divisible by with no remainder (the result of the division must be an\n+\t   integer.)  The value of this attribute SHOULD NOT be 0.\n+\t */\n+\tprivate IntNode divisibleBy;\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NullSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+/**\n+ * value must be null;\n+ */\n+public class NullSchema extends ValueTypeSchema {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.NULL.toString());\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.BooleanNode;\n+import com.fasterxml.jackson.databind.node.NumericNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class NumberSchema extends ValueTypeSchema<NumericNode> {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.NUMBER.toString());\n+\t//This attribute defines the minimum value of the instance property\n+\tprivate NumericNode minimum;\n+\t\n+\t//This attribute defines the maximum value of the instance property\n+\tprivate NumericNode maximum;\n+\t\n+\t/*\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"minimum\" attribute.\n+\t */\n+\tprivate BooleanNode exclusiveMinimum = BooleanNode.FALSE;\n+\t\n+\t/*\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"maximum\" attribute.\n+\t */\n+\tprivate BooleanNode exclusiveMaximum = BooleanNode.FALSE;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class ObjectSchema extends ContainerTypeSchema {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.OBJECT.toString());\n+\t\n+\t/*\n+\t *  This attribute is an object with property definitions that define the\n+\t   valid values of instance object property values.  When the instance\n+\t   value is an object, the property values of the instance object MUST\n+\t   conform to the property definitions in this object.  In this object,\n+\t   each property definition's value MUST be a schema, and the property's\n+\t   name MUST be the name of the instance property that it defines.  The\n+\t   instance property value MUST be valid according to the schema from\n+\t   the property definition.  Properties are considered unordered, the\n+\t   order of the instance properties MAY be in any order.\n+\t */\n+\tprivate Map<String, Schema> properties;\n+\tpublic Schema putProperty(String name, Schema value) {\n+\t\treturn properties.put(name, value);\n+\t}\n+\t\n+\t/*\n+\t * \n+\t   This attribute is an object that defines the schema for a set of\n+\t   property names of an object instance.  The name of each property of\n+\t   this attribute's object is a regular expression pattern in the ECMA\n+\t   262/Perl 5 format, while the value is a schema.  If the pattern\n+\t   matches the name of a property on the instance object, the value of\n+\t   the instance's property MUST be valid against the pattern name's\n+\t   schema value.\n+\t */\n+\tprivate Map<String, Schema> patternProperties;\n+\tpublic Schema putPatternProperty(String regex, Schema value) {\n+\t\treturn patternProperties.put(regex, value);\n+\t}\n+\t\n+\t/*\n+\t * This attribute defines a schema for all properties that are not\n+\t   explicitly defined in an object type definition.  If specified, the\n+\t   value MUST be a schema or a boolean.  If false is provided, no\n+\t   additional properties are allowed beyond the properties defined in\n+\t   the schema.  The default value is an empty schema which allows any\n+\t   value for additional properties.\n+\t */\n+\tprivate AdditionalProperties additionalProperties;\n+\tpublic void rejectAdditionalProperties() {\n+\t\tadditionalProperties = NoAdditionalProperties.instance;\n+\t}\n+\t\n+\tpublic static abstract class AdditionalProperties {}\n+\tpublic static class NoAdditionalProperties extends AdditionalProperties {\n+\t\tpublic static final NoAdditionalProperties instance = new NoAdditionalProperties();\n+\t\tprotected NoAdditionalProperties() {}\n+\t}\n+\tpublic static class SchemaAdditionalProperties extends AdditionalProperties{\n+\t\tprivate Schema schema;\n+\t\tpublic SchemaAdditionalProperties(Schema schema) {\n+\t\t\tthis.schema = schema;\n+\t\t}\n+\t}\n+\t/*\n+\t * This attribute is an object that defines the requirements of a\n+\t   property on an instance object.  If an object instance has a property\n+\t   with the same name as a property in this attribute's object, then the\n+\t   instance must be valid against the attribute's property value\n+\t */\n+\tprivate List<Dependency> dependencies;\n+\tpublic boolean addSimpleDependency(String depender, String dependsOn) {\n+\t\treturn dependencies.add(new SimpleDependency(depender, dependsOn));\n+\t}\n+\tpublic boolean addSchemaDependency(String depender, Schema parentMustMatch) {\n+\t\treturn dependencies.add(new SchemaDependency(depender, parentMustMatch));\n+\t}\n+\t\n+\tpublic static abstract class Dependency {}\n+\n+\t/*\n+\t * Simple Dependency  If the dependency value is a string, then the\n+      instance object MUST have a property with the same name as the\n+      dependency value.  If the dependency value is an array of strings,\n+      then the instance object MUST have a property with the same name\n+      as each string in the dependency value's array.\n+\t */\n+\tpublic static class SimpleDependency extends Dependency {\n+\t\tprivate String depender;\n+\t\tprivate String dependsOn;\n+\t\t\n+\t\tpublic SimpleDependency(String depender, String dependsOn) {\n+\t\t\tthis.depender = depender;\n+\t\t\tthis.dependsOn = dependsOn;\n+\t\t}\n+\t}\n+\t\n+\t/*\n+\t * Schema Dependency  If the dependency value is a schema, then the\n+  \t\tinstance object MUST be valid against the schema.\n+\t */\n+\tpublic static class SchemaDependency extends Dependency {\n+\t\tprivate String depender;\n+\t\tprivate Schema parentMustMatch;\n+\t\tpublic SchemaDependency(String depender, Schema parentMustMatch) {\n+\t\t\tthis.depender = depender;\n+\t\t\tthis.parentMustMatch = parentMustMatch;\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/Schema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.BooleanNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+\n+/**\n+ * <a href=\"http://tools.ietf.org/id/draft-zyp-json-schema-03.txt\"> Json Schema Draft </a>\n+ *  <blockquote>\n+   \tJSON (JavaScript Object Notation) Schema defines the media type\n+\t\"application/schema+json\", a JSON based format for defining the\n+\tstructure of JSON data.  JSON Schema provides a contract for what\n+\tJSON data is required for a given application and how to interact\n+\twith it.  JSON Schema is intended to define validation,\n+\tdocumentation, hyperlink navigation, and interaction control of JSON\n+\tdata.\n+\t</blockquote>\n+\t\n+\t<blockquote>\n+\tJSON (JavaScript Object Notation) Schema is a JSON media type for\n+\tdefining the structure of JSON data.  JSON Schema provides a contract\n+\tfor what JSON data is required for a given application and how to\n+\tinteract with it.  JSON Schema is intended to define validation,\n+\tdocumentation, hyperlink navigation, and interaction control of JSON\n+\tdata.\n+\t</blockquote>\n+\t\n+\tAn example JSON Schema provided by the Schema draft:\n+\t<pre>\n+\t{\n+\t  \"name\":\"Product\",\n+\t  \"properties\":{\n+\t    \"id\":{\n+\t      \"type\":\"number\",\n+\t      \"description\":\"Product identifier\",\n+\t      \"required\":true\n+\t    },\n+\t    \"name\":{\n+\t      \"description\":\"Name of the product\",\n+\t      \"type\":\"string\",\n+\t      \"required\":true\n+\t    },\n+\t    \"price\":{\n+\t      \"required\":true,\n+\t      \"type\": \"number\",\n+\t      \"minimum\":0,\n+\t      \"required\":true\n+\t    },\n+\t    \"tags\":{\n+\t      \"type\":\"array\",\n+\t      \"items\":{\n+\t        \"type\":\"string\"\n+\t      }\n+\t    }\n+\t  },\n+\t  \"links\":[\n+\t    {\n+\t      \"rel\":\"full\",\n+\t      \"href\":\"{id}\"\n+\t    },\n+\t    {\n+\t      \"rel\":\"comments\",\n+\t      \"href\":\"comments/?id={id}\"\n+\t    }\n+\t  ]\n+\t}\n+\t</pre>\n+\n+ * @author jphelan\n+ */\n+public abstract class Schema { \n+\t public JsonNode asJson() {\n+\t\t \n+\t\t return null;\n+\t }\n+\t\n+\t/**\n+\t * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n+\t * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n+\t * \n+\t * @param writer Bean property serializer to use to create schema value\n+\t * @param propertiesNode Node which the given property would exist within\n+\t * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+\t * \tprocessing\n+\t * \t\n+\t *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n+\t */\n+\tpublic static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) {\n+\t\tJavaType propType = writer.getSerializationType();\n+\t\n+\t\t// 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+\t\tType hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n+\t\tJsonNode schemaNode;\n+\t\t// Maybe it already has annotated/statically configured serializer?\n+\t\tJsonSerializer<Object> ser = writer.getSerializer();\n+\t\n+\t\ttry {\n+\t\t\tif (ser == null) { // nope\n+\t\t\t\tClass<?> serType = writer.getRawSerializationType();\n+\t\t\t\tif (serType == null) {\n+\t\t\t\t\tserType = writer.getPropertyType();\n+\t\t\t\t}\n+\t\t\t\tser = provider.findValueSerializer(serType, writer);\n+\t\t\t}\n+\t\t\tboolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n+\t\t\tif (ser instanceof SchemaAware) {\n+\t\t\t\tschemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n+\t\t\t} else {  \n+\t\t\t\tschemaNode = JsonSchema.getDefaultSchemaNode(); \n+\t\t\t}\n+\t\t} catch (JsonMappingException e) {\n+\t\t\tschemaNode = JsonSchema.getDefaultSchemaNode(); \n+\t\t\t//TODO: log error\n+\t\t}\n+\t\tpropertiesNode.put(writer.getName(), schemaNode);\n+\t}\n+\n+\t/*\n+\t * This attribute indicates if the instance must have a value, and not\n+\t   be undefined.  This is false by default, making the instance\n+\t   optional.\n+\t */\n+\tprivate BooleanNode required = BooleanNode.FALSE;// default = false;\n+\t\n+\t/*\n+\t *  This attribute defines the current URI of this schema (this attribute\n+\t   is effectively a \"self\" link).  This URI MAY be relative or absolute.\n+\t   If the URI is relative it is resolved against the current URI of the\n+\t   parent schema it is contained in.  If this schema is not contained in\n+\t   any parent schema, the current URI of the parent schema is held to be\n+\t   the URI under which this schema was addressed.  If id is missing, the\n+\t   current URI of a schema is defined to be that of the parent schema.\n+\t   The current URI of the schema is also used to construct relative\n+\t   references such as for $ref.\n+\t */\n+\tprivate TextNode id;\n+\t\n+\t/*\n+\t * This attribute defines a URI of a schema that contains the full\n+\t   representation of this schema.  When a validator encounters this\n+\t   attribute, it SHOULD replace the current schema with the schema\n+\t   referenced by the value's URI (if known and available) and re-\n+\t   validate the instance.  This URI MAY be relative or absolute, and\n+\t   relative URIs SHOULD be resolved against the URI of the current\n+\t   schema.\n+\t */\n+\tprivate TextNode $ref; \n+\t\n+\t/*\n+\t * This attribute defines a URI of a JSON Schema that is the schema of\n+\t   the current schema.  When this attribute is defined, a validator\n+\t   SHOULD use the schema referenced by the value's URI (if known and\n+\t   available) when resolving Hyper Schema (Section 6) links\n+\t   (Section 6.1).\n+\t\n+\t   A validator MAY use this attribute's value to determine which version\n+\t   of JSON Schema the current schema is written in, and provide the\n+\t   appropriate validation features and behavior.  Therefore, it is\n+\t   RECOMMENDED that all schema authors include this attribute in their\n+\t   schemas to prevent conflicts with future JSON Schema specification\n+\t   changes.\n+\n+\t */\n+\tprivate TextNode $schema;\n+\t\n+\t/*\n+\t * The value of this property MUST be another schema which will provide\n+\t   a base schema which the current schema will inherit from.  The\n+\t   inheritance rules are such that any instance that is valid according\n+\t   to the current schema MUST be valid according to the referenced\n+\t   schema.  This MAY also be an array, in which case, the instance MUST\n+\t   be valid for all the schemas in the array.  A schema that extends\n+\t   another schema MAY define additional attributes, constrain existing\n+\t   attributes, or add other constraints.\n+\t\n+\t   Conceptually, the behavior of extends can be seen as validating an\n+\t   instance against all constraints in the extending schema as well as\n+\t   the extended schema(s).  More optimized implementations that merge\n+\t   schemas are possible, but are not required.  An example of using\n+\t   \"extends\":\n+\t\n+\t   {\n+\t     \"description\":\"An adult\",\n+\t     \"properties\":{\"age\":{\"minimum\": 21}},\n+\t     \"extends\":\"person\"\n+\t   }\n+\t   {\n+\t     \"description\":\"Extended schema\",\n+\t     \"properties\":{\"deprecated\":{\"type\": \"boolean\"}},\n+\t     \"extends\":\"http://json-schema.org/draft-03/schema\"\n+\t   }\n+\t */\n+\tprivate Schema[] extendsextends;\n+\n+\t/*\n+\t * This attribute takes the same values as the \"type\" attribute, however\n+\t   if the instance matches the type or if this value is an array and the\n+\t   instance matches any type or schema in the array, then this instance\n+\t   is not valid.\n+\t */\n+\tprivate Schema[] disallow;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SchemaType.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+public enum SchemaType {\n+\tSTRING {\n+\t\t@Override\n+\t\tpublic String toString() { return \"string\"; }\n+\t},\n+\tNUMBER {\n+\t\t@Override\n+\t\tpublic String toString() { return \"number\"; }\n+\t},\n+\tINTEGER {\n+\t\t@Override\n+\t\tpublic String toString() { return \"integer\"; }\n+\t},\n+\tBOOLEAN {\n+\t\t@Override\n+\t\tpublic String toString() { return \"boolean\"; }\n+\t},\n+\tOBJECT {\n+\t\t@Override\n+\t\tpublic String toString() { return \"object\"; }\n+\t},\n+\tARRAY {\n+\t\t@Override\n+\t\tpublic String toString() { return \"array\"; }\n+\t},\n+\tNULL {\n+\t\t@Override\n+\t\tpublic String toString() { return \"null\"; }\n+\t},\n+\tANY {\n+\t\t@Override\n+\t\tpublic String toString() { return \"any\"; }\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public abstract class SimpleTypeSchema extends Schema {\n+\t\n+\n+\t/*\n+\t * This provides an enumeration of all possible values that are valid\n+\t   for the instance property.  This MUST be an array, and each item in\n+\t   the array represents a possible value for the instance value.  If\n+\t   this attribute is defined, the instance value MUST be one of the\n+\t   values in the array in order for the schema to be valid.  Comparison\n+\t   of enum values uses the same algorithm as defined in \"uniqueItems\"\n+\t   (Section 5.15).\n+\t */\n+\tprivate Set<JsonNode> enumenum;\n+\t\n+\t/*\n+\t * This attribute defines the default value of the instance when the\n+\t\tinstance is undefined.\n+\t */\n+\tprivate JsonNode defaultdefault;\n+\t\n+\t/*\n+\t * This attribute is a string that provides a short description of the\n+\t\tinstance property.\n+\t */\n+\tprivate TextNode title;\n+\t\n+\t/*\n+\t * This attribute is a string that provides a full description of the of\n+\t\tpurpose the instance property.\n+\t */\n+\tprivate TextNode description;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.IntNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class StringSchema extends ValueTypeSchema<TextNode> {\n+\tpublic static final TextNode type = TextNode.valueOf(SchemaType.STRING.toString());\n+\t\n+\t/*\n+\t * this provides a regular\n+\t   expression that a string instance MUST match in order to be valid.\n+\t   Regular expressions SHOULD follow the regular expression\n+\t   specification from ECMA 262/Perl 5\n+\t */\n+\tprivate TextNode pattern;\n+\t\n+\t//this defines the minimum length of the string.\n+\tprivate IntNode minLength;\n+\t\n+\t//this defines the maximum length of the string.\n+\tprivate IntNode maxLength;\n+\t\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+\n+public class UnionTypeSchema extends Schema {\n+\tprivate ValueTypeSchema[] elements;\n+\tprivate ArrayNode value;\n+\tpublic final ValueTypeSchema[] getElements() { return elements; }\n+\tpublic final void setElements(ValueTypeSchema[] elements) {\n+\t\tassert elements.length >= 2 : \"Union Type Schemas must contain two or more Simple Type Schemas\" ;\n+\t\tthis.elements = elements;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n+package com.fasterxml.jackson.databind.jsonschema.types;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+/**\n+* A primitive type. \n+*/\n+public abstract class ValueTypeSchema<T extends JsonNode> extends SimpleTypeSchema {\n+\t\t\n+\tprivate T value;\n+\t\n+\t/*\n+\t * This property defines the type of data, content type, or microformat\n+\t   to be expected in the instance property values.  A format attribute\n+\t   MAY be one of the values listed below, and if so, SHOULD adhere to\n+\t   the semantics describing for the format.  A format SHOULD only be\n+\t   used to give meaning to primitive types (string, integer, number, or\n+\t   boolean).  Validators MAY (but are not required to) validate that the\n+\t   instance values conform to a format.\n+\t */\n+\tprivate ValueTypeSchema.Format format;\n+\t\n+\tpublic static enum Format {\n+\t\tDATE_TIME {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"date-time\"; }\n+\t\t},\n+\t\tDATE {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"date\"; }\n+\t\t},\n+\t\tTIME {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"time\"; }\n+\t\t},\n+\t\tUTC_MILLISEC {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"utc-millisec\"; }\n+\t\t},\n+\t\tREGEX {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"regex\"; }\n+\t\t},\n+\t\tCOLOR {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"color\"; }\n+\t\t},\n+\t\tSTYLE {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"style\"; }\n+\t\t},\n+\t\tPHONE {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"phone\"; }\n+\t\t},\n+\t\tURI {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"uri\"; }\n+\t\t},\n+\t\tEMAIL {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"email\"; }\n+\t\t},\n+\t\tIP_ADDRESS {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"ip-address\"; }\n+\t\t},\n+\t\tIPV6 {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"ipv6\"; }\n+\t\t},\n+\t\tHOST_NAME {\n+\t\t\t@Override\n+\t\t\tpublic String toString() { return \"host-name\"; }\n+\t\t}\n+\t\t\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n-import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n \n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n \t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n \t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t\tSchema.depositSchemaProperty(writer, propertiesNode, provider);\n \t\t\t}\n \t\t}\n \t}\n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n \t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n \t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t\tSchema.depositSchemaProperty(writer, propertiesNode, provider);\n \t\t\t}\n \t\t}\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.*;\n             }\n             JavaType propType = prop.getSerializationType();\n \n-            depositSchemaProperty(prop, propertiesNode, provider);\n+            Schema.depositSchemaProperty(prop, propertiesNode, provider);\n \n         }\n         o.put(\"properties\", propertiesNode);\n         return (value == null) ? false : value.booleanValue();\n     }\n     \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n-     * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param propertiesNode Node which the given property would exist within\n-     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n-     * \tprocessing\n-     * \t\n-     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) {\n-\t\tJavaType propType = writer.getSerializationType();\n-\n-\t\t// 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n-\t\tType hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n-\t\tJsonNode schemaNode;\n-\t\t// Maybe it already has annotated/statically configured serializer?\n-\t\tJsonSerializer<Object> ser = writer.getSerializer();\n-\n-\t\ttry {\n-\t\t\tif (ser == null) { // nope\n-\t\t\t\tClass<?> serType = writer.getRawSerializationType();\n-\t\t\t\tif (serType == null) {\n-\t\t\t\t\tserType = writer.getPropertyType();\n-\t\t\t\t}\n-\t\t\t\tser = provider.findValueSerializer(serType, writer);\n-\t\t\t}\n-\t\t\tboolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n-\t\t\tif (ser instanceof SchemaAware) {\n-\t\t\t\tschemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n-\t\t\t} else {  \n-\t\t\t\tschemaNode = JsonSchema.getDefaultSchemaNode(); \n-\t\t\t}\n-\t\t} catch (JsonMappingException e) {\n-\t\t\tschemaNode = JsonSchema.getDefaultSchemaNode(); \n-\t\t\t//TODO: log error\n-\t\t}\n-\t\tpropertiesNode.put(writer.getName(), schemaNode);\n-\t}\n-    \n }", "timestamp": 1343329443, "metainfo": ""}