{"sha": "6b89162eb32a94c5686ed56dc9c8e5a4d1c7e919", "log": "Trying to make StdDateFormat use Locale, if defined", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n                 if (format != null) {\n                     TimeZone tz = format.getTimeZone();\n                     // First: fully custom pattern?\n-                    String pattern = format.getPattern();\n-                    if (pattern.length() > 0){\n-                        Locale loc = format.getLocale();\n-                        if (loc == null) {\n-                            loc = ctxt.getLocale();\n-                        }\n+                    if (format.hasPattern()) {\n+                        final String pattern = format.getPattern();\n+                        final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n                         SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                         if (tz == null) {\n                             tz = ctxt.getTimeZone();\n                         DateFormat df = ctxt.getConfig().getDateFormat();\n                         // one shortcut: with our custom format, can simplify handling a bit\n                         if (df.getClass() == StdDateFormat.class) {\n-                            df = ((StdDateFormat) df).withTimeZone(tz);\n+                            final Locale loc = format.hasLocale() ? format.getLocale() : ctxt.getLocale();\n+                            StdDateFormat std = (StdDateFormat) df;\n+                            std = std.withTimeZone(tz);\n+                            std = std.withLocale(loc);\n+                            df = std;\n                         } else {\n                             // otherwise need to clone, re-set timezone:\n                             df = (DateFormat) df.clone();\n                             df.setTimeZone(tz);\n                         }\n-                        return withDateFormat(df, pattern);\n+                        return withDateFormat(df, _formatString);\n                     }\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n                 }\n                 // If not, do we have a pattern?\n                 TimeZone tz = format.getTimeZone();\n-                String pattern = format.getPattern();\n-                if (pattern.length() > 0){\n-                    Locale loc = format.getLocale();\n-                    if (loc == null) {\n-                        loc = prov.getLocale();\n-                    }\n+                if (format.hasPattern()) {\n+                    String pattern = format.getPattern();\n+                    final Locale loc = format.hasLocale() ? format.getLocale() : prov.getLocale();\n                     SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                     if (tz == null) {\n                         tz = prov.getTimeZone();\n                     DateFormat df = prov.getConfig().getDateFormat();\n                     // one shortcut: with our custom format, can simplify handling a bit\n                     if (df.getClass() == StdDateFormat.class) {\n-                        df = StdDateFormat.getISO8601Format(tz);\n+                        final Locale loc = format.hasLocale() ? format.getLocale() : prov.getLocale();\n+                        df = StdDateFormat.getISO8601Format(tz, loc);\n                     } else {\n                         // otherwise need to clone, re-set timezone:\n                         df = (DateFormat) df.clone();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n      * JDK date parsing is awfully brittle, and ISO-8601 is quite\n      * permissive. The two don't mix, need to write a better one.\n      */\n-    // Note: [JACKSON-697] is the issue for rewrite\n \n     /**\n      * Defines a commonly used date format that conforms\n     static {\n         DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n     }\n+\n+    private final static Locale DEFAULT_LOCALE = Locale.US;\n     \n     protected final static DateFormat DATE_FORMAT_RFC1123;\n \n         /* Another important thing: let's force use of GMT for\n          * baseline DataFormat objects\n          */\n-        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, Locale.US);\n+\n+        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);\n         DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n-        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601);\n+        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);\n         DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n-        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z);\n+        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);\n         DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n-        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN);\n+        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);\n         DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n     }\n     \n     /**\n-     * A singleton instance can be used for cloning purposes.\n+     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.\n      */\n     public final static StdDateFormat instance = new StdDateFormat();\n     \n      * we will have non-null value here.\n      */\n     protected transient TimeZone _timezone;\n+\n+    protected final Locale _locale;\n     \n     protected transient DateFormat _formatRFC1123;\n     protected transient DateFormat _formatISO8601;\n     /**********************************************************\n      */\n \n-    public StdDateFormat() { }\n+    public StdDateFormat() {\n+        _locale = DEFAULT_LOCALE;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4, use variant that also takes Locale\n+     */\n+    @Deprecated // since 2.4\n     public StdDateFormat(TimeZone tz) {\n+        this(tz, DEFAULT_LOCALE);\n+    }\n+    \n+    public StdDateFormat(TimeZone tz, Locale loc) {\n         _timezone = tz;\n+        _locale = loc;\n     }\n \n     public static TimeZone getDefaultTimeZone() {\n         if (tz == null) {\n             tz = DEFAULT_TIMEZONE;\n         }\n-        return new StdDateFormat(tz);\n+        if (tz.equals(_timezone)) {\n+            return this;\n+        }\n+        return new StdDateFormat(tz, _locale);\n+    }\n+\n+    public StdDateFormat withLocale(Locale loc) {\n+        if (loc.equals(_locale)) {\n+            return this;\n+        }\n+        return new StdDateFormat(_timezone, loc);\n     }\n     \n     @Override\n         /* Although there is that much state to share, we do need to\n          * orchestrate a bit, mostly since timezones may be changed\n          */\n-        return new StdDateFormat();\n+        return new StdDateFormat(_timezone, _locale);\n     }\n \n     /**\n      * Method for getting the globally shared DateFormat instance\n      * that uses GMT timezone and can handle simple ISO-8601\n      * compliant date format.\n-     */\n+     * \n+     * @deprecated Since 2.4 not to be used.\n+     */\n+    @Deprecated\n     public static DateFormat getBlueprintISO8601Format() {\n         return DATE_FORMAT_ISO8601;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4; use variant that takes Locale\n+     */\n+    @Deprecated\n+    public static DateFormat getISO8601Format(TimeZone tz) {\n+        return getISO8601Format(tz, DEFAULT_LOCALE);\n     }\n \n     /**\n      * Method for getting a non-shared DateFormat instance\n      * that uses specified timezone and can handle simple ISO-8601\n      * compliant date format.\n-     */\n-    public static DateFormat getISO8601Format(TimeZone tz) {\n-        return _cloneFormat(DATE_FORMAT_ISO8601, tz);\n-    }\n-\n+     * \n+     * @since 2.4\n+     */\n+    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {\n+        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc);\n+    }\n+    \n     /**\n      * Method for getting the globally shared DateFormat instance\n      * that uses GMT timezone and can handle RFC-1123\n      * compliant date format.\n-     */\n+     * \n+     * @deprecated Since 2.4 not to be used.\n+     */\n+    @Deprecated\n     public static DateFormat getBlueprintRFC1123Format() {\n         return DATE_FORMAT_RFC1123;\n     }\n-\n \n     /**\n      * Method for getting a non-shared DateFormat instance\n      * that uses specific timezone and can handle RFC-1123\n      * compliant date format.\n-     */\n+     * \n+     * @since 2.4\n+     */\n+    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {\n+        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, tz, loc);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.4; use variant that takes Locale\n+     */\n+    @Deprecated\n     public static DateFormat getRFC1123Format(TimeZone tz) {\n-        return _cloneFormat(DATE_FORMAT_RFC1123, tz);\n-    }\n-\n+        return getRFC1123Format(tz, DEFAULT_LOCALE);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API\n         /* DateFormats are timezone-specific (via Calendar contained),\n          * so need to reset instances if timezone changes:\n          */\n-        if (tz != _timezone) {\n+        if (!tz.equals(_timezone)) {\n             _formatRFC1123 = null;\n             _formatISO8601 = null;\n             _formatISO8601_z = null;\n             FieldPosition fieldPosition)\n     {\n         if (_formatISO8601 == null) {\n-            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601);\n+            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n         }\n         return _formatISO8601.format(date, toAppendTo, fieldPosition);\n     }\n         if (tz != null) {\n             str += \" (timezone: \"+tz+\")\";\n         }\n+        str += \"(locale: \"+_locale+\")\";\n         return str;\n     }\n     \n \n         // [JACKSON-200]: need to support \"plain\" date...\n         if (len <= 10 && Character.isDigit(c)) {\n-           df = _formatPlain;\n+            df = _formatPlain;\n             if (df == null) {\n-                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN);\n+                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n             }\n         } else if (c == 'Z') {\n             df = _formatISO8601_z;\n             if (df == null) {\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z);\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n             }\n             // [JACKSON-334]: may be missing milliseconds... if so, add\n             if (dateStr.charAt(len-4) == ':') {\n                 \n                 df = _formatISO8601;\n                 if (_formatISO8601 == null) {\n-                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601);\n+                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                 }\n             } else {\n                 /* 24-Nov-2009, tatu: Ugh. This is getting pretty\n-                 *   ugly. Need to rewrite soon!\n+                 *   ugly. Need to rewrite!\n                  */\n \n                 // If not, plain date. Easiest to just patch 'Z' in the end?\n                 dateStr = sb.toString();\n                 df = _formatISO8601_z;\n                 if (df == null) {\n-                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z);\n+                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n+                            _timezone, _locale);\n                 }\n             }\n         }\n     protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n     {\n         if (_formatRFC1123 == null) {\n-            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123);\n+            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123, _timezone, _locale);\n         }\n         return _formatRFC1123.parse(dateStr, pos);\n     }\n         return false;\n     }\n \n-    private final DateFormat _cloneFormat(DateFormat df) {\n-        return _cloneFormat(df, _timezone);\n-    }\n-\n-    private final static DateFormat _cloneFormat(DateFormat df, TimeZone tz)\n-    {\n-        df = (DateFormat) df.clone();\n-        if (tz != null) {\n-            df.setTimeZone(tz);\n+    private final static DateFormat _cloneFormat(DateFormat df, String format,\n+            TimeZone tz, Locale loc)\n+    {\n+        if (!loc.equals(DEFAULT_LOCALE)) {\n+            df = new SimpleDateFormat(format, loc);\n+            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n+        } else {\n+            df = (DateFormat) df.clone();\n+            if (tz != null) {\n+                df.setTimeZone(tz);\n+            }\n         }\n         return df;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java\n     extends BaseMapTest\n {\n     public void testFactories() {\n-        assertNotNull(StdDateFormat.getBlueprintISO8601Format());\n-        assertNotNull(StdDateFormat.getBlueprintRFC1123Format());\n         TimeZone tz = TimeZone.getTimeZone(\"GMT\");\n-        assertNotNull(StdDateFormat.getISO8601Format(tz));\n-        assertNotNull(StdDateFormat.getRFC1123Format(tz));\n+        Locale loc = Locale.US;\n+        assertNotNull(StdDateFormat.getISO8601Format(tz, loc));\n+        assertNotNull(StdDateFormat.getRFC1123Format(tz, loc));\n     }\n \n     public void testInvalid() {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n         public Date date;\n     }\n \n+    static class DateAsStringBeanGermany\n+    {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"/yyyy/MM/dd/\", locale=\"fr_FR\")\n+        public Date date;\n+    }\n+    \n     static class CalendarAsStringBean\n     {\n         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\";yyyy/MM/dd;\")\n \n     public void testCustomDateWithAnnotation() throws Exception\n     {\n-        DateAsStringBean result = MAPPER.readValue(\"{\\\"date\\\":\\\"/2005/05/25/\\\"}\", DateAsStringBean.class);\n+        final String INPUT = \"{\\\"date\\\":\\\"/2005/05/25/\\\"}\";\n+        DateAsStringBean result = MAPPER.readValue(INPUT, DateAsStringBean.class);\n         assertNotNull(result);\n         assertNotNull(result.date);\n         Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n         assertEquals(2005, c.get(Calendar.YEAR));\n         assertEquals(Calendar.MAY, c.get(Calendar.MONTH));\n         assertEquals(25, c.get(Calendar.DAY_OF_MONTH));\n+\n+        // 27-Mar-2014, tatu: Let's verify that changing Locale won't break it;\n+        //   either via context Locale\n+        result = MAPPER.reader(DateAsStringBean.class)\n+                .with(Locale.GERMANY)\n+                .readValue(INPUT);\n+        assertNotNull(result);\n+        assertNotNull(result.date);\n+        l = result.date.getTime();\n+        if (l == 0L) {\n+            fail(\"Should not get null date\");\n+        }\n+        c.setTimeInMillis(l);\n+        assertEquals(2005, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));\n+        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));\n+\n+        // or, via annotations\n+        DateAsStringBeanGermany result2 = MAPPER.reader(DateAsStringBeanGermany.class).readValue(INPUT);\n+        assertNotNull(result2);\n+        assertNotNull(result2.date);\n+        l = result2.date.getTime();\n+        if (l == 0L) {\n+            fail(\"Should not get null date\");\n+        }\n+        c.setTimeInMillis(l);\n+        assertEquals(2005, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.MAY, c.get(Calendar.MONTH));\n+        assertEquals(25, c.get(Calendar.DAY_OF_MONTH));\n     }\n \n     public void testCustomCalendarWithAnnotation() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         String json = mapper.writeValueAsString(new Date(0));\n         // pacific time is GMT-8; so midnight becomes 16:00 previous day:\n         assertEquals(quote(\"1969-12-31/16:00 PST\"), json);\n+\n+        // Let's also verify that Locale won't matter too much...\n+        mapper.setLocale(Locale.FRANCE);\n+        json = mapper.writeValueAsString(new Date(0));\n+        assertEquals(quote(\"1969-12-31/16:00 PST\"), json);\n     }\n }\n ", "timestamp": 1395987239, "metainfo": ""}