{"sha": "15212e8d7438bd862574c652e0419879d8b720c4", "log": "Completed [JACKSON-787] implementation; @JsonIgnoreProperties now usable for properties too", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n      * Copy-constructor that can be used by sub-classes to allow\n      * copy-on-write styling copying of settings of an existing instance.\n      */\n-    protected BeanDeserializer(BeanDeserializer src) {\n+    protected BeanDeserializer(BeanDeserializerBase src) {\n     \tsuper(src, src._ignoreAllUnknown);\n     }\n \n-    protected BeanDeserializer(BeanDeserializer src, boolean ignoreAllUnknown) {\n+    protected BeanDeserializer(BeanDeserializerBase src, boolean ignoreAllUnknown) {\n         super(src, ignoreAllUnknown);\n     }\n     \n-    protected BeanDeserializer(BeanDeserializer src, NameTransformer unwrapper) {\n+    protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {\n     \tsuper(src, unwrapper);\n     }\n \n-    public BeanDeserializer(BeanDeserializer src, ObjectIdReader oir) {\n+    public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {\n     \tsuper(src, oir);\n+    }\n+\n+    public BeanDeserializer(BeanDeserializerBase src, HashSet<String> ignorableProps) {\n+        super(src, ignorableProps);\n     }\n     \n     @Override\n         return new BeanDeserializer(this, unwrapper);\n     }\n \n+    @Override\n     public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {\n         return new BeanDeserializer(this, oir);\n     }\n \n+    @Override\n+    public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n+        return new BeanDeserializer(this, ignorableProps);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializer implementation\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n  * Base class for <code>BeanDeserializer</code>.\n  */\n public abstract class BeanDeserializerBase\n-\textends StdDeserializer<Object>\n-\timplements ContextualDeserializer, ResolvableDeserializer\n+    extends StdDeserializer<Object>\n+    implements ContextualDeserializer, ResolvableDeserializer\n {\n     /*\n     /**********************************************************\n         }\n         _needViewProcesing = src._needViewProcesing;\n         // probably adds a twist, so:\n-        _vanillaProcessing = false;        \n+        _vanillaProcessing = false;\n     }\n \n     public BeanDeserializerBase(BeanDeserializerBase src, ObjectIdReader oir)\n         if (oir == null) {\n             _beanProperties = src._beanProperties;\n         } else {\n-        \t_beanProperties = src._beanProperties.withProperty(new ObjectIdProperty(oir));\n-        }\n-    }\n-\n+            _beanProperties = src._beanProperties.withProperty(new ObjectIdProperty(oir));\n+        }\n+    }\n+\n+    public BeanDeserializerBase(BeanDeserializerBase src, HashSet<String> ignorableProps)\n+    {\n+        super(src._beanType);\n+        \n+        _classAnnotations = src._classAnnotations;\n+        _beanType = src._beanType;\n+        \n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        \n+        _backRefs = src._backRefs;\n+        _ignorableProps = ignorableProps;\n+        _ignoreAllUnknown = src._ignoreAllUnknown;\n+        _anySetter = src._anySetter;\n+        _injectables = src._injectables;\n+        \n+        _nonStandardCreation = src._nonStandardCreation;\n+        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n+        _needViewProcesing = src._needViewProcesing;\n+\n+        _vanillaProcessing = src._vanillaProcessing;\n+        _objectIdReader = src._objectIdReader;\n+        _beanProperties = src._beanProperties;\n+    }\n+    \n     @Override\n     public abstract JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper);\n \n     public abstract BeanDeserializerBase withObjectIdReader(ObjectIdReader oir);\n+\n+    public abstract BeanDeserializerBase withIgnorableProperties(HashSet<String> ignorableProps);\n     \n     /*\n     /**********************************************************\n             BeanProperty property) throws JsonMappingException\n     {\n         ObjectIdReader oir = _objectIdReader;\n+        String[] ignorals = null;\n         \n         // First: may have an override for Object Id:\n-        if (property != null) {\n-            final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        if (property != null && intr != null) {\n             final AnnotatedMember accessor = property.getMember();\n+            ignorals = intr.findPropertiesToIgnore(accessor);\n             final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n             if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                 Class<?> implClass = objectIdInfo.getGeneratorType();\n             }\n         }\n         // either way, need to resolve serializer:\n+        BeanDeserializerBase contextual = this;\n         if (oir != null && oir != _objectIdReader) {\n-            return withObjectIdReader(oir);\n-        }\n-        return this;\n+            contextual = contextual.withObjectIdReader(oir);\n+        }\n+        // And possibly add more properties to ignore\n+        if (ignorals != null && ignorals.length != 0) {\n+            HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals);\n+            contextual = contextual.withIgnorableProperties(newIgnored);\n+        }\n+        return contextual;\n     }\n \n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n         super(src, oir);\n         _buildMethod = src._buildMethod;\n     }\n+\n+    public BuilderBasedDeserializer(BuilderBasedDeserializer src, HashSet<String> ignorableProps) {\n+        super(src, ignorableProps);\n+        _buildMethod = src._buildMethod;\n+    }\n     \n     @Override\n     public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n     {\n-        /* bit kludgy but we don't want to accidentally change type; sub-classes\n-         * MUST override this method to support unwrapped properties...\n-         */\n-        if (getClass() != BuilderBasedDeserializer.class) {\n-            return this;\n-        }\n         /* main thing really is to just enforce ignoring of unknown\n          * properties; since there may be multiple unwrapped values\n          * and properties for all may be interleaved...\n         return new BuilderBasedDeserializer(this, oir);\n     }\n \n+    @Override\n+    public BuilderBasedDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {\n+        return new BuilderBasedDeserializer(this, ignorableProps);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializer implementation\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n \n     protected MapDeserializer(MapDeserializer src,\n             KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n-            TypeDeserializer valueTypeDeser)\n+            TypeDeserializer valueTypeDeser,\n+            HashSet<String> ignorable)\n     {\n         super(src._valueClass);\n         _mapType = src._mapType;\n         _propertyBasedCreator = src._propertyBasedCreator;\n         _delegateDeserializer = src._delegateDeserializer;\n         _hasDefaultCreator = src._hasDefaultCreator;\n-        // should we make a copy here?\n-        _ignorableProperties = src._ignorableProperties;\n+        _ignorableProperties = ignorable;\n \n         _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n     }\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected MapDeserializer withResolved(KeyDeserializer keyDeser,\n-            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser)\n-    {\n-        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser)) {\n+            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser,\n+            HashSet<String> ignorable)\n+    {\n+        \n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser)\n+                && (_ignorableProperties == ignorable)) {\n             return this;\n         }\n         return new MapDeserializer(this,\n-                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser);\n+                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable);\n     }\n     \n     /**\n         if (vtd != null) {\n             vtd = vtd.forProperty(property);\n         }\n-        return withResolved(kd, vtd, vd);\n+        HashSet<String> ignored = _ignorableProperties;\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        if (intr != null && property != null) {\n+            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n+            if (moreToIgnore != null) {\n+                ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n+                for (String str : moreToIgnore) {\n+                    ignored.add(str);\n+                }\n+            }\n+        }\n+        return withResolved(kd, vtd, vd, ignored);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n             JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n             oiw = oiw.withSerializer(ser);\n             if (oiw != _objectIdWriter) {\n-                contextual = withObjectIdWriter(oiw);\n+                contextual = contextual.withObjectIdWriter(oiw);\n             }\n         }\n         // And possibly add more properties to ignore\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n         if (elements != null) {\n             for (T elem : elements) {\n                 result.add(elem);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public static <T> HashSet<T> setAndArray(Set<T> set, T[] elements)\n+    {\n+        HashSet<T> result = new HashSet<T>();\n+        if (set != null) {\n+            result.addAll(set);\n+        }\n+        if (elements != null) {\n+            for (T value : elements) {\n+                result.add(value);\n             }\n         }\n         return result;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestUnknownPropertyDeserialization.java\n+package com.fasterxml.jackson.databind.filter;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n+\n+/**\n+ * Unit tests for checking handling of unknown properties\n+ */\n+public class TestUnknownPropertyDeserialization\n+    extends BaseMapTest\n+{\n+    final static String JSON_UNKNOWN_FIELD = \"{ \\\"a\\\" : 1, \\\"foo\\\" : [ 1, 2, 3], \\\"b\\\" : -1 }\";\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class TestBean\n+    {\n+        String _unknown;\n+\n+        int _a, _b;\n+\n+        public TestBean() { }\n+\n+        public void setA(int a) { _a = a; }\n+        public void setB(int b) { _b = b; }\n+\n+        public void markUnknown(String unk) { _unknown = unk; }\n+    }\n+\n+    /**\n+     * Simple {@link DeserializationProblemHandler} sub-class that\n+     * just marks unknown property/ies when encountered, along with\n+     * Json value of the property.\n+     */\n+    final static class MyHandler\n+        extends DeserializationProblemHandler\n+    {\n+        @Override\n+        public boolean handleUnknownProperty(DeserializationContext ctxt,\n+                JsonParser jp, JsonDeserializer<?> deserializer,\n+                Object bean, String propertyName)\n+            throws IOException, JsonProcessingException\n+        {\n+            // very simple, just to verify that we do see correct token type\n+            ((TestBean) bean).markUnknown(propertyName+\":\"+jp.getCurrentToken().toString());\n+            // Yup, we are good to go; must skip whatever value we'd have:\n+            jp.skipChildren();\n+            return true;\n+        }\n+    }\n+\n+    @JsonIgnoreProperties({\"b\", \"c\"})\n+    static class IgnoreSome\n+    {\n+        public int a, b;\n+        private String c, d;\n+\n+        public IgnoreSome() { }\n+\n+        public String c() { return c; }\n+        public void setC(String value) { c = value; }\n+        public String d() { return d; }\n+        public void setD(String value) { d = value; }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown=true)\n+    static class IgnoreUnknown {\n+        public int a;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonIgnoreProperties({\"a\", \"d\"})\n+    static class IgnoreMap extends HashMap<String,Object> { }\n+\n+    static class ImplicitIgnores {\n+        @JsonIgnore public int a;\n+        @JsonIgnore public void setB(int b) { }\n+        public int c;\n+    }\n+\n+    // // Ignored as per [JACKSON-787]\n+\n+    static class XYZWrapper1 {\n+        @JsonIgnoreProperties({\"x\"})\n+        public YZ value;\n+    }\n+\n+    static class YZ {\n+        public int y, z;\n+    }\n+\n+    static class XYZWrapper2 {\n+        @JsonIgnoreProperties({\"y\"})\n+        public X value;\n+    }\n+\n+    @JsonIgnoreProperties({\"z\"})\n+    static class X {\n+        public int x;\n+    }\n+\n+    static class MapWithoutX {\n+        @JsonIgnoreProperties(\"x\")\n+        public Map<String,Integer> values;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    /**\n+     * By default we should just get an exception if an unknown property\n+     * is encountered\n+     */\n+    public void testUnknownHandlingDefault()\n+        throws Exception\n+    {\n+        try {\n+            MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        } catch (JsonMappingException jex) {\n+            verifyException(jex, \"Unrecognized field \\\"foo\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Test that verifies that it is possible to ignore unknown properties using\n+     * {@link DeserializationProblemHandler}.\n+     */\n+    public void testUnknownHandlingIgnoreWithHandler()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.clearProblemHandlers();\n+        mapper.addHandler(new MyHandler());\n+        TestBean result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        assertNotNull(result);\n+        assertEquals(1, result._a);\n+        assertEquals(-1, result._b);\n+        assertEquals(\"foo:START_ARRAY\", result._unknown);\n+    }\n+\n+    /**\n+     * Test for checking that it is also possible to simply suppress\n+     * error reporting for unknown properties.\n+     */\n+    public void testUnknownHandlingIgnoreWithFeature()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        TestBean result = null;\n+        try {\n+            result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        } catch (JsonMappingException jex) {\n+            fail(\"Did not expect a problem, got: \"+jex.getMessage());\n+        }\n+        assertNotNull(result);\n+        assertEquals(1, result._a);\n+        assertNull(result._unknown);\n+        assertEquals(-1, result._b);\n+    }\n+\n+    public void testWithClassIgnore()\n+        throws Exception\n+    {\n+        IgnoreSome result = MAPPER.readValue(\"{ \\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":\\\"x\\\",\\\"d\\\":\\\"y\\\"}\",\n+                IgnoreSome.class);\n+        // first: should deserialize 2 of properties normally\n+        assertEquals(1, result.a);\n+        assertEquals(\"y\", result.d());\n+        // and not take other 2\n+        assertEquals(0, result.b);\n+        assertNull(result.c());\n+    }\n+\n+    /// @since 1.4\n+    public void testClassIgnoreWithMap() throws Exception\n+    {\n+        // Let's actually use incompatible types for \"a\" and \"d\"; should not matter when ignored\n+        IgnoreMap result = MAPPER.readValue\n+            (\"{ \\\"a\\\":[ 1],\\n\"\n+                +\"\\\"b\\\":2,\\n\"\n+                +\"\\\"c\\\": \\\"x\\\",\\n\"\n+                +\"\\\"d\\\":false }\", IgnoreMap.class);\n+        assertEquals(2, result.size());\n+        Object ob = result.get(\"b\");\n+        assertEquals(Integer.class, ob.getClass());\n+        assertEquals(Integer.valueOf(2), ob);\n+        assertEquals(\"x\", result.get(\"c\"));\n+        assertFalse(result.containsKey(\"a\"));\n+        assertFalse(result.containsKey(\"d\"));\n+    }\n+\n+    public void testClassWithIgnoreUnknown() throws Exception\n+    {\n+        IgnoreUnknown result = MAPPER.readValue\n+            (\"{\\\"b\\\":3,\\\"c\\\":[1,2],\\\"x\\\":{ },\\\"a\\\":-3}\", IgnoreUnknown.class);\n+        assertEquals(-3, result.a);\n+    }\n+\n+    /**\n+     * Test that verifies that use of {@link JsonIgnore} will add implicit\n+     * skipping of matching properties.\n+     */\n+    public void testClassWithUnknownAndIgnore() throws Exception\n+    {\n+        // should be ok: \"a\" and \"b\" ignored, \"c\" mapped:\n+        ImplicitIgnores result = MAPPER.readValue\n+            (\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3 }\", ImplicitIgnores.class);\n+        assertEquals(3, result.c);\n+\n+        // but \"d\" is not defined, so should still error\n+        try {\n+            MAPPER.readValue(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4 }\", ImplicitIgnores.class);            \n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unrecognized field \\\"d\\\"\");\n+        }\n+    }\n+\n+    public void testPropertyIgnoral() throws Exception\n+    {\n+        XYZWrapper1 result = MAPPER.readValue(\"{\\\"value\\\":{\\\"y\\\":2,\\\"x\\\":1,\\\"z\\\":3}}\", XYZWrapper1.class);\n+        assertEquals(2, result.value.y);\n+        assertEquals(3, result.value.z);\n+    }\n+\n+    public void testPropertyIgnoralWithClass() throws Exception\n+    {\n+        XYZWrapper2 result = MAPPER.readValue(\"{\\\"value\\\":{\\\"y\\\":2,\\\"x\\\":1,\\\"z\\\":3}}\", XYZWrapper2.class);\n+        assertEquals(1, result.value.x);\n+    }\n+\n+    public void testPropertyIgnoralForMap() throws Exception\n+    {\n+        MapWithoutX result = MAPPER.readValue(\"{\\\"values\\\":{\\\"x\\\":1,\\\"y\\\":2}}\", MapWithoutX.class);\n+        assertNotNull(result.values);\n+        assertEquals(1, result.values.size());\n+        assertEquals(Integer.valueOf(2), result.values.get(\"y\"));\n+    }\n+}\n+", "timestamp": 1329804805, "metainfo": ""}