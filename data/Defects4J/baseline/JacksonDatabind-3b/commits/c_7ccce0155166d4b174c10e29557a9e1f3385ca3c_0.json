{"sha": "7ccce0155166d4b174c10e29557a9e1f3385ca3c", "log": "Implement [Issue#28], add ObjectMapper.copy()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n     @Override\n     public final ObjectMapper getCodec() { return (ObjectMapper) _objectCodec; }\n \n+    // @since 2.1\n+    public JsonFactory copy()\n+    {\n+        if (getClass() != MappingJsonFactory.class) {\n+            throw new IllegalStateException(\"Can not copy(): \"+getClass().getName()+\" does not override method; it has to\");\n+        }\n+        // note: as with base class, must NOT copy mapper reference\n+        return new MappingJsonFactory(null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Format detection functionality (since 1.8)\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     }\n \n     /**\n+     * Copy-constructor, mostly used to support {@link #copy}.\n+     * \n+     * @since 2.1\n+     */\n+    protected ObjectMapper(ObjectMapper src)\n+    {\n+        _jsonFactory = src._jsonFactory.copy();\n+        _jsonFactory.setCodec(this);\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootNames = new RootNameLookup();\n+        _typeFactory = src._typeFactory;\n+        _serializationConfig = src._serializationConfig;\n+        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixInAnnotations);\n+        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixInAnnotations);\n+        _serializerProvider = src._serializerProvider;\n+        _deserializationContext = src._deserializationContext;\n+\n+        // Default serializer factory is stateless, can just assign\n+        _serializerFactory = src._serializerFactory;\n+    }\n+    \n+    /**\n      * Constructs instance that uses specified {@link JsonFactory}\n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s, and uses given providers for accessing\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n+    }\n+\n+    /**\n+     * Method for creating a new {@link ObjectMapper} instance that\n+     * has same initial configuration as this instance. Note that this\n+     * also requires making a copy of the underlying {@link JsonFactory}\n+     * instance.\n+     *<p>\n+     * Method is typically\n+     * used when multiple, differently configured mappers are needed.\n+     * Although configuration is shared, cached serializers and deserializers\n+     * are NOT shared, which means that the new instance may be re-configured\n+     * before use; meaning that it behaves the same way as if an instance\n+     * was constructed from scratch.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectMapper copy()\n+    {\n+        return new ObjectMapper(this);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected SerializationConfig(SerializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n         _rootName = src._rootName;\n         _view = view;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src);\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+        _view = src._view;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n         \n         public void setX(int v) { value = v; }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    final static ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testProps()\n     {\n \n     public void testSupport()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.canSerialize(String.class));\n-\n-        assertTrue(m.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n+        assertTrue(MAPPER.canSerialize(String.class));\n+        assertTrue(MAPPER.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n     }\n \n     public void testTreeRead() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         String JSON = \"{ }\";\n-        JsonNode n = m.readTree(JSON);\n+        JsonNode n = MAPPER.readTree(JSON);\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new StringReader(JSON));\n+        n = MAPPER.readTree(new StringReader(JSON));\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n         assertTrue(n instanceof ObjectNode);\n     }\n \n     public void testJsonFactoryLinkage()\n     {\n         // first, implicit factory, giving implicit linkage\n-        ObjectMapper m = new ObjectMapper();\n-        assertSame(m, m.getJsonFactory().getCodec());\n+        assertSame(MAPPER, MAPPER.getJsonFactory().getCodec());\n \n         // and then explicit factory, which should also be implicitly linked\n         JsonFactory f = new JsonFactory();\n-        m = new ObjectMapper(f);\n+        ObjectMapper m = new ObjectMapper(f);\n         assertSame(f, m.getJsonFactory());\n         assertSame(m, f.getCodec());\n     }\n      */\n     public void testProviderConfig() throws Exception   \n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        ObjectMapper m = new ObjectMapper();\n+\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = mapper.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n         assertNotNull(bean);\n-        assertEquals(1, mapper._deserializationContext._cache.cachedDeserializersCount());\n-        mapper._deserializationContext._cache.flushCachedDeserializers();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n+        m._deserializationContext._cache.flushCachedDeserializers();\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+    }\n+    \n+    // [Issue#28]: ObjectMapper.copy()\n+    public void testCopy() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // // First: verify that handling of features is decoupled:\n+        \n+        ObjectMapper m2 = m.copy();\n+        assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        // but should NOT change the original\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // nor vice versa:\n+        assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+\n+        // // Also, underlying JsonFactory instances should be distinct\n+        \n+        assertNotSame(m.getJsonFactory(), m2.getJsonFactory());\n+\n+        // ... anything else? (probably should do more tests, add as needed)\n     }\n }", "timestamp": 1344122274, "metainfo": ""}