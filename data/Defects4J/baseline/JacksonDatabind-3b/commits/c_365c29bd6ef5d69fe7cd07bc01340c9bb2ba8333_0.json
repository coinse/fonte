{"sha": "365c29bd6ef5d69fe7cd07bc01340c9bb2ba8333", "log": "Groundwork for addressing renaming of explicit names with PropertyNamingStrategy", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n             if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) {\n                 continue;\n             }\n-            \n-            _property(implName).addField(f, explName, visible, ignored);\n+            _property(implName).addField(f, explName, true, visible, ignored);\n         }\n     }\n \n                 if (name != null) {\n                     // shouldn't need to worry about @JsonIgnore (no real point, so)\n                     POJOPropertyBuilder prop = _property(name);\n-                    prop.addCtor(param, name, true, false);\n+                    // 28-Mar-2014, tatu: for now, all names considered explicit\n+                    prop.addCtor(param, name, true, true, false);\n                     _creatorProperties.add(prop);\n                 }\n             }\n                 if (name != null) {\n                     // shouldn't need to worry about @JsonIgnore (no real point, so)\n                     POJOPropertyBuilder prop = _property(name);\n-                    prop.addCtor(param, name, true, false);\n+                    // 28-Mar-2014, tatu: for now, all names considered explicit\n+                    prop.addCtor(param, name, true, true, false);\n                     _creatorProperties.add(prop);\n                 }\n             }\n             visible = true;\n         }\n         boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n-        _property(implName).addGetter(m, explName, visible, ignore);\n+        _property(implName).addGetter(m, explName, true, visible, ignore);\n     }\n \n     protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)\n             visible = true;\n         }\n         boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n-        _property(implName).addSetter(m, explName, visible, ignore);\n+        _property(implName).addSetter(m, explName, true, visible, ignore);\n     }\n     \n     protected void _addInjectables()\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n     @Override\n     public boolean isExplicitlyIncluded() {\n+        return _anyExplicits(_fields)\n+                || _anyExplicits(_getters)\n+                || _anyExplicits(_setters)\n+                || _anyExplicits(_ctorParameters)\n+                ;\n+    }\n+\n+    @Override\n+    public boolean isExplicitlyNamed() {\n         return _anyExplicitNames(_fields)\n                 || _anyExplicitNames(_getters)\n                 || _anyExplicitNames(_setters)\n                 || _anyExplicitNames(_ctorParameters)\n                 ;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* BeanPropertyDefinition implementation, accessor access\n     /**********************************************************\n      */\n     \n-    public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored) {\n-        _fields = new Linked<AnnotatedField>(a, _fields, ename, visible, ignored);\n-    }\n-\n-    public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored) {\n-        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored);\n-    }\n-\n-    public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n-        _getters = new Linked<AnnotatedMethod>(a, _getters, ename, visible, ignored);\n-    }\n-\n-    public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n-        _setters = new Linked<AnnotatedMethod>(a, _setters, ename, visible, ignored);\n+    public void addField(AnnotatedField a, String name, boolean explName, boolean visible, boolean ignored) {\n+        _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);\n+    }\n+\n+    public void addCtor(AnnotatedParameter a, String name, boolean explName, boolean visible, boolean ignored) {\n+        _ctorParameters = new Linked<AnnotatedParameter>(a, _ctorParameters, name, explName, visible, ignored);\n+    }\n+\n+    public void addGetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+        _getters = new Linked<AnnotatedMethod>(a, _getters, name, explName, visible, ignored);\n+    }\n+\n+    public void addSetter(AnnotatedMethod a, String name, boolean explName, boolean visible, boolean ignored) {\n+        _setters = new Linked<AnnotatedMethod>(a, _setters, name, explName, visible, ignored);\n     }\n \n     /**\n     /**********************************************************\n      */\n \n+    private <T> boolean _anyExplicits(Linked<T> n)\n+    {\n+        for (; n != null; n = n.next) {\n+            if (n.name != null && n.name.length() > 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private <T> boolean _anyExplicitNames(Linked<T> n)\n     {\n         for (; n != null; n = n.next) {\n-            if (n.explicitName != null && n.explicitName.length() > 0) {\n+            if (n.name != null && n.isNameExplicit) {\n                 return true;\n             }\n         }\n         renamed = findRenamed(_getters, renamed);\n         renamed = findRenamed(_setters, renamed);\n         renamed = findRenamed(_ctorParameters, renamed);\n-        return (renamed == null) ? null : renamed.explicitName;\n+        return (renamed == null) ? null : renamed.name;\n     }\n \n     private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node,\n             Linked<? extends AnnotatedMember> renamed)\n     {\n         for (; node != null; node = node.next) {\n-            String explName = node.explicitName;\n-            if (explName == null) {\n+            String name = node.name;\n+            if (name == null) {\n                 continue;\n             }\n             // different from default name?\n              *   fix but for now, let's not worry about that.\n              * \n              */\n-            if (explName.equals(_name.getSimpleName())) { // nope, skip\n+            if (name.equals(_name.getSimpleName())) { // nope, skip\n                 continue;\n             }\n             if (renamed == null) {\n                 renamed = node;\n             } else {\n                 // different from an earlier renaming? problem\n-                if (!explName.equals(renamed.explicitName)) {\n+                if (!name.equals(renamed.name)) {\n                     throw new IllegalStateException(\"Conflicting property name definitions: '\"\n-                            +renamed.explicitName+\"' (for \"+renamed.value+\") vs '\"\n-                            +node.explicitName+\"' (for \"+node.value+\")\");\n+                            +renamed.name+\"' (for \"+renamed.value+\") vs '\"\n+                            +node.name+\"' (for \"+node.value+\")\");\n                 }\n             }\n         }\n         public final T value;\n         public final Linked<T> next;\n \n-        public final String explicitName;\n+        public final String name;\n+        public final boolean isNameExplicit;\n         public final boolean isVisible;\n         public final boolean isMarkedIgnored;\n         \n         public Linked(T v, Linked<T> n,\n-                String explName, boolean visible, boolean ignored)\n+                String name, boolean explName, boolean visible, boolean ignored)\n         {\n             value = v;\n             next = n;\n             // ensure that we'll never have missing names\n-            if (explName == null) {\n-                explicitName = null;\n-            } else {\n-                explicitName = (explName.length() == 0) ? null : explName;\n-            }\n+            this.name = (name == null || name.length() == 0) ? null : name;\n+            isNameExplicit = explName;\n             isVisible = visible;\n             isMarkedIgnored = ignored;\n         }\n \n-        public Linked<T> withValue(T newValue)\n-        {\n+        public Linked<T> withValue(T newValue) {\n             if (newValue == value) {\n                 return this;\n             }\n-            return new Linked<T>(newValue, next, explicitName, isVisible, isMarkedIgnored);\n+            return new Linked<T>(newValue, next, name, isNameExplicit, isVisible, isMarkedIgnored);\n         }\n         \n         public Linked<T> withNext(Linked<T> newNext) {\n             if (newNext == next) {\n                 return this;\n             }\n-            return new Linked<T>(value, newNext, explicitName, isVisible, isMarkedIgnored);\n+            return new Linked<T>(value, newNext, name, isNameExplicit, isVisible, isMarkedIgnored);\n         }\n         \n         public Linked<T> withoutIgnored()\n                 return this;\n             }\n             Linked<T> newNext = next.trimByVisibility();\n-            if (explicitName != null) { // this already has highest; how about next one?\n-                if (newNext.explicitName == null) { // next one not, drop it\n+            if (name != null) { // this already has highest; how about next one?\n+                if (newNext.name == null) { // next one not, drop it\n                     return withNext(null);\n                 }\n                 //  both have it, keep\n                 return withNext(newNext);\n             }\n-            if (newNext.explicitName != null) { // next one has higher, return it...\n+            if (newNext.name != null) { // next one has higher, return it...\n                 return newNext;\n             }\n             // neither has explicit name; how about visibility?", "timestamp": 1396047060, "metainfo": ""}