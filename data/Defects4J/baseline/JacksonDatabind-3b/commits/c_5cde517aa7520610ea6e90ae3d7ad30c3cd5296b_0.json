{"sha": "5cde517aa7520610ea6e90ae3d7ad30c3cd5296b", "log": "Start working on [Issue#120]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             ArrayType type, final BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         JavaType elemType = type.getContentType();\n         \n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n-        if (contentDeser == null) {\n-            // Maybe special array type, such as \"primitive\" arrays (int[] etc)\n-            JsonDeserializer<?> deser = _arrayDeserializers.get(elemType);\n-            if (deser != null) {\n-                /* 23-Nov-2010, tatu: Although not commonly needed, ability to override\n-                 *   deserializers for all types (including primitive arrays) is useful\n-                 *   so let's allow this\n-                 */\n-                JsonDeserializer<?> custom = _findCustomArrayDeserializer(type,\n-                        ctxt.getConfig(), beanDesc, null, contentDeser);\n-                if (custom != null) {\n-                    return custom;\n-                }\n-                return deser;\n-            }\n-            // If not, generic one:\n-            if (elemType.isPrimitive()) { // sanity check\n-                throw new IllegalArgumentException(\"Internal error: primitive type (\"+type+\") passed, no array deserializer found\");\n-            }\n-        }\n         // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n-            elemTypeDeser = findTypeDeserializer(ctxt.getConfig(), elemType);\n+            elemTypeDeser = findTypeDeserializer(config, elemType);\n         }\n         // 23-Nov-2010, tatu: Custom array deserializer?\n         JsonDeserializer<?> custom = _findCustomArrayDeserializer(type,\n-                ctxt.getConfig(), beanDesc, elemTypeDeser, contentDeser);\n+                config, beanDesc, elemTypeDeser, contentDeser);\n         if (custom != null) {\n             return custom;\n         }\n-        return new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n+\n+        JsonDeserializer<?>  deser = null;       \n+        if (contentDeser == null) {\n+            // Maybe special array type, such as \"primitive\" arrays (int[] etc)\n+            deser = _arrayDeserializers.get(elemType);\n+            if (deser == null) {\n+                if (elemType.isPrimitive()) { // sanity check\n+                    throw new IllegalArgumentException(\"Internal error: primitive type (\"+type+\") passed, no array deserializer found\");\n+                }\n+            }\n+        }\n+        if (deser == null) {\n+            deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n+        }\n+        // and then new with 2.2: ability to post-process it too\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser);\n+            }\n+        }\n+        return deser;\n     }\n \n     protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n \n /**\n- * Abstract class that defines API for objects that can be registered (for {@link BeanDeserializerFactory}\n- * to participate in constructing {@link BeanDeserializer} instances.\n+ * Abstract class that defines API for objects that can be registered\n+ * to participate in constructing {@link JsonDeserializer} instances\n+ * (via {@link DeserializerFactory}).\n  * This is typically done by modules that want alter some aspects of deserialization\n  * process; and is preferable to sub-classing of {@link BeanDeserializerFactory}.\n  *<p>\n- * Sequence in which callback methods are called is as follows:\n+ * Note that Jackson 2.2 adds more methods for customization; with earlier versions\n+ * only {@link BeanDeserializer} instances could be modified, but with 2.2 all types\n+ * of deserializers can be changed.\n+ *<p>\n+ * Sequence in which callback methods are called for {@link BeanDeserializer} is:\n  *  <li>{@link #updateProperties} is called once all property definitions are\n  *    collected, and initial filtering (by ignorable type and explicit ignoral-by-bean)\n  *    has been performed.\n  *    but before it is returned to be used\n  *   </li>\n  * </ol>\n+ *<p>\n+ * For other types of deserializers, methods called depend on type of values for\n+ * which deserializer is being constructed; and only a single method is called\n+ * since the process does not involve builders (unlike that of {@link BeanDeserializer}.\n  *<p>\n  * Default method implementations are \"no-op\"s, meaning that methods are implemented\n  * but have no effect; this is mostly so that new methods can be added in later\n             BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n         return deserializer;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Callback methods for other types (since 2.2)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link DeserializerFactory} after it has constructed the\n+     * standard deserializer for given\n+     * {@link ArrayType}\n+     * to make it possible to either replace or augment this deserializer with\n+     * additional functionality.\n+     * \n+     * @param config Configuration in use\n+     * @param valueType Type of the value deserializer is used for.\n+     * @param beanDesc Description f\n+     * @param deserializer Default deserializer that would be used.\n+     * \n+     * @return Deserializer to use; either <code>deserializer</code> that was passed\n+     *   in, or an instance method constructed.\n+     * \n+     * @since 2.2\n+     */\n+    public JsonDeserializer<?> modifyArrayDeserializer(DeserializationConfig config,\n+            ArrayType valueType,\n+            BeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+        return deserializer;\n+    }\n+    \n }", "timestamp": 1353886987, "metainfo": ""}