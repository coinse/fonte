{"sha": "44ac79f3447cf5816b370ee0ffe57b40af6c1e6f", "log": "Starting to implement #239: first part, serialization, now supported.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.math.BigInteger;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n         throws JsonMappingException\n     {\n         Class<?> raw = type.getRawClass();\n-        // One unfortunate special case, as per [JACKSON-484]\n-        if (InetAddress.class.isAssignableFrom(raw)) {\n-            return InetAddressSerializer.instance;\n-        }\n-        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n-            return InetSocketAddressSerializer.instance;\n-        }\n-        // ... and another one, [JACKSON-522], for TimeZone\n-        if (TimeZone.class.isAssignableFrom(raw)) {\n-            return TimeZoneSerializer.instance;\n-        }\n-        // and yet one more [JACKSON-789]\n-        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n-            return ToStringSerializer.instance;\n-        }\n         \n         // Then check for optional/external serializers [JACKSON-386]\n         JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n             return ser;\n         }\n         \n+        if (Calendar.class.isAssignableFrom(raw)) {\n+            return CalendarSerializer.instance;\n+        }\n+        if (java.util.Date.class.isAssignableFrom(raw)) {\n+            return DateSerializer.instance;\n+        }\n+        if (ByteBuffer.class.isAssignableFrom(raw)) {\n+            return ByteBufferSerializer.instance;\n+        }\n+        if (InetAddress.class.isAssignableFrom(raw)) {\n+            return InetAddressSerializer.instance;\n+        }\n+        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n+            return InetSocketAddressSerializer.instance;\n+        }\n+        if (TimeZone.class.isAssignableFrom(raw)) {\n+            return TimeZoneSerializer.instance;\n+        }\n+        if (java.nio.charset.Charset.class.isAssignableFrom(raw)) {\n+            return ToStringSerializer.instance;\n+        }\n         if (Number.class.isAssignableFrom(raw)) {\n             return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n             return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n-        }\n-        if (Calendar.class.isAssignableFrom(raw)) {\n-            return CalendarSerializer.instance;\n-        }\n-        if (java.util.Date.class.isAssignableFrom(raw)) {\n-            return DateSerializer.instance;\n         }\n         return null;\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class ByteBufferSerializer extends StdScalarSerializer<ByteBuffer>\n+{\n+    public final static ByteBufferSerializer instance = new ByteBufferSerializer();\n+\n+    public ByteBufferSerializer() { super(ByteBuffer.class); }\n+\n+    @Override\n+    public void serialize(ByteBuffer bbuf, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // first, simple case when wrapping an array...\n+        if (bbuf.hasArray()) {\n+            gen.writeBinary(bbuf.array(), 0, bbuf.limit());\n+            return;\n+        }\n+        // the other case is more complicated however. Best to handle with InputStream wrapper.\n+        // But should we rewind it; and/or make a copy?\n+        ByteBuffer copy = bbuf.asReadOnlyBuffer();\n+        if (copy.position() > 0) {\n+            copy.rewind();\n+        }\n+        InputStream in = new ByteBufferBackedInputStream(copy);\n+        gen.writeBinary(in, copy.remaining());\n+        in.close();\n+    }\n+\n+    public class ByteBufferBackedInputStream extends InputStream\n+    {\n+        protected final ByteBuffer _buffer;\n+\n+        public ByteBufferBackedInputStream(ByteBuffer buf) {\n+            _buffer = buf;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            return _buffer.hasRemaining() ? (_buffer.get() & 0xFF) : -1;\n+        }\n+\n+        @Override\n+        public int read(byte[] bytes, int off, int len) throws IOException\n+        {\n+            if (!_buffer.hasRemaining()) {\n+                return -1;\n+            }\n+            len = Math.min(len, _buffer.remaining());\n+            _buffer.get(bytes, off, len);\n+            return len;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+\n+/**\n+ * Also: default bean access will not do much good with Class.class. But\n+ * we can just serialize the class name and that should be enough.\n+ */\n+public class ClassSerializer\n+    extends StdScalarSerializer<Class<?>>\n+{\n+    public ClassSerializer() { super(Class.class, false); }\n+\n+    @Override\n+    public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.getName());\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+            throws JsonMappingException\n+    {\n+        visitor.expectStringFormat(typeHint);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+\n+/**\n+ * For now, File objects get serialized by just outputting\n+ * absolute (but not canonical) name as String value\n+ */\n+public class FileSerializer\n+    extends StdScalarSerializer<File>\n+{\n+    public FileSerializer() { super(File.class); }\n+\n+    @Override\n+    public void serialize(File value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.getAbsolutePath());\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+            throws JsonMappingException\n+    {\n+        visitor.expectStringFormat(typeHint);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n         sers.put(AtomicInteger.class, AtomicIntegerSerializer.class);\n         sers.put(AtomicLong.class, AtomicLongSerializer.class);\n         \n-        // then types that need specialized serializers\n+        // then other types that need specialized serializers\n         sers.put(File.class, FileSerializer.class);\n         sers.put(Class.class, ClassSerializer.class);\n \n             visitor.expectAnyFormat(typeHint);\n         }\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Specialized serializers, referential types\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * For now, File objects get serialized by just outputting\n-     * absolute (but not canonical) name as String value\n-     */\n-    public final static class FileSerializer\n-        extends StdScalarSerializer<File>\n-    {\n-        public FileSerializer() { super(File.class); }\n-\n-        @Override\n-        public void serialize(File value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            jgen.writeString(value.getAbsolutePath());\n-        }\n-\n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"string\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n-        {\n-            visitor.expectStringFormat(typeHint);\n-        }\n-    }\n-\n-    /**\n-     * Also: default bean access will not do much good with Class.class. But\n-     * we can just serialize the class name and that should be enough.\n-     */\n-    public final static class ClassSerializer\n-        extends StdScalarSerializer<Class<?>>\n-    {\n-        public ClassSerializer() { super(Class.class, false); }\n-\n-        @Override\n-        public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            jgen.writeString(value.getName());\n-        }\n-\n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"string\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n-        {\n-            visitor.expectStringFormat(typeHint);\n-        }\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n import java.math.BigDecimal;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Pattern;\n     {\n         assertEquals(quote(\"UTF-8\"), MAPPER.writeValueAsString(Charset.forName(\"UTF-8\")));\n     }\n+\n+    // [Issue#239]: Support serialization of ByteBuffer\n+    public void testByteBuffer() throws IOException\n+    {\n+        final byte[] INPUT_BYTES = new byte[] { 1, 2, 3, 4, 5 };\n+        String exp = MAPPER.writeValueAsString(INPUT_BYTES);\n+        ByteBuffer bbuf = ByteBuffer.wrap(INPUT_BYTES);\n+        assertEquals(exp, MAPPER.writeValueAsString(bbuf));\n+\n+        // so far so good, but must ensure Native buffers also work:\n+        ByteBuffer bbuf2 = ByteBuffer.allocateDirect(5);\n+        bbuf2.put(INPUT_BYTES);\n+        assertEquals(exp, MAPPER.writeValueAsString(bbuf2));\n+    }\n }", "timestamp": 1373513777, "metainfo": ""}