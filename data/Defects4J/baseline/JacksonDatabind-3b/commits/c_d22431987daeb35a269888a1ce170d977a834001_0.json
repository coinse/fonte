{"sha": "d22431987daeb35a269888a1ce170d977a834001", "log": "Fixing #166", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     {\n         // sanity check for null first:\n         if (fromValue == null) return null;\n-        // also, as per [Issue-11], consider case for simple cast\n-        // ... one caveat; while everything is Object.class, let's not take shortcut\n-        if (toValueType != Object.class && toValueType.isAssignableFrom(fromValue.getClass())) {\n-            return (T) fromValue;\n-        }\n         return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n     } \n \n     {\n         // sanity check for null first:\n         if (fromValue == null) return null;\n+        return (T) _convert(fromValue, toValueType);\n+    } \n+\n+    /**\n+     * Actual conversion implementation: instead of using existing read\n+     * and write methods, much of code is inlined. Reason for this is\n+     * that we must avoid wrapping/unwrapping both for efficiency and\n+     * for correctness. If wrapping/unwrapping is actually desired,\n+     * caller must use explicit <code>writeValue</code> and\n+     * <code>readValue</code> methods.\n+     */\n+    protected Object _convert(Object fromValue, JavaType toValueType)\n+        throws IllegalArgumentException\n+    {        \n         // also, as per [Issue-11], consider case for simple cast\n         /* But with caveats: one is that while everything is Object.class, we don't\n          * want to \"optimize\" that out; and the other is that we also do not want\n         if (targetType != Object.class\n                 && !toValueType.hasGenericTypes()\n                 && targetType.isAssignableFrom(fromValue.getClass())) {\n-            return (T) fromValue;\n-        }\n-        return (T) _convert(fromValue, toValueType);\n-    } \n-\n-    /**\n-     * Actual conversion implementation: instead of using existing read\n-     * and write methods, much of code is inlined. Reason for this is\n-     * that we must avoid wrapping/unwrapping both for efficiency and\n-     * for correctness. If wrapping/unwrapping is actually desired,\n-     * caller must use explicit <code>writeValue</code> and\n-     * <code>readValue</code> methods.\n-     */\n-    protected Object _convert(Object fromValue, JavaType toValueType)\n-        throws IllegalArgumentException\n-    {        \n+            return fromValue;\n+        }\n+        \n         /* Then use TokenBuffer, which is a JsonGenerator:\n          * (see [JACKSON-175])\n          */", "timestamp": 1360727880, "metainfo": ""}