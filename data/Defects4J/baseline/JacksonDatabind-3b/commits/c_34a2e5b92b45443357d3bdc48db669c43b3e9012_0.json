{"sha": "34a2e5b92b45443357d3bdc48db669c43b3e9012", "log": "Finally implement #326 (originally one of oldest open bugs from codehaus issue tracker!)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n         _serializer.serializeFields((Map<?,?>) value, jgen, provider);\n     }\n \n+    /**\n+     * @since 2.3\n+     */\n+    public void getAndFilter(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            PropertyFilter filter)\n+        throws Exception\n+        {\n+            Object value = _accessor.getValue(bean);\n+            if (value == null) {\n+                return;\n+            }\n+            if (!(value instanceof Map<?,?>)) {\n+                throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n+                        +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n+            }\n+            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter);\n+        }\n+    \n     // Note: NOT part of ResolvableSerializer...\n     public void resolve(SerializerProvider provider) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                 }\n             }\n             if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+                _anyGetterWriter.getAndFilter(bean, jgen, provider, filter);\n             }\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.PropertyWriter;\n+\n+/**\n+ * Helper class needed to support flexible filtering of Map properties\n+ * with generic JSON Filter functionality. Since {@link java.util.Map}s\n+ * are not handled as a collection of properties by Jackson (unlike POJOs),\n+ * bit more wrapping is required.\n+ */\n+public class MapProperty extends PropertyWriter\n+{\n+    protected TypeSerializer _typeSerializer;\n+    \n+    protected Object _key, _value;\n+\n+    protected JsonSerializer<Object> _keySerializer, _valueSerializer;\n+\n+    public MapProperty(TypeSerializer typeSer)\n+    {\n+        _typeSerializer = typeSer;\n+    }\n+    \n+    /**\n+     * Initialization method that needs to be called before passing\n+     * property to filter.\n+     */\n+    public void reset(Object key, Object value,\n+            JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer)\n+    {\n+        _key = key;\n+        _value = value;\n+        _keySerializer = keySer;\n+        _valueSerializer = valueSer;\n+    }\n+    \n+    @Override\n+    public String getName() {\n+        if (_key instanceof String) {\n+            return (String) _key;\n+        }\n+        return String.valueOf(_key);\n+    }\n+\n+    @Override\n+    public PropertyName getFullName() {\n+        return new PropertyName(getName());\n+    }\n+\n+    @Override\n+    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+            SerializerProvider provider) throws IOException\n+    {\n+        _keySerializer.serialize(_key, jgen, provider);\n+        if (_typeSerializer == null) {\n+            _valueSerializer.serialize(_value, jgen, provider);\n+        } else {\n+            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+        }\n+    }\n+\n+    @Override\n+    public void serializeAsOmittedField(Object pojo, JsonGenerator jgen,\n+            SerializerProvider provider) throws Exception\n+    {\n+        if (!jgen.canOmitFields()) {\n+            jgen.writeOmittedField(getName());\n+        }\n+    }\n+\n+    @Override\n+    public void serializeAsColumn(Object pojo, JsonGenerator jgen,\n+            SerializerProvider provider) throws Exception\n+    {\n+        if (_typeSerializer == null) {\n+            _valueSerializer.serialize(_value, jgen, provider);\n+        } else {\n+            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+        }\n+    }\n+\n+    @Override\n+    public void serializeAsPlaceholder(Object pojo, JsonGenerator jgen,\n+            SerializerProvider provider) throws Exception\n+    {\n+        jgen.writeNull();\n+    }\n+\n+    @Override\n+    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n+        throws JsonMappingException\n+    {\n+    }\n+\n+    @Override\n+    public void depositSchemaProperty(ObjectNode propertiesNode,\n+            SerializerProvider provider) throws JsonMappingException {\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n      */\n     protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-            throws IOException, JsonGenerationException\n+        throws IOException, JsonGenerationException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         }\n     }\n \n+    /**\n+     * Helper method used when we have a JSON Filter to use for potentially\n+     * filtering out Map entries.\n+     *<p>\n+     * NOTE: initially only called externally, by <code>AnyGetterWriter</code>\n+     * \n+     * @since 2.3\n+     */\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            PropertyFilter filter)\n+        throws IOException, JsonGenerationException\n+    {\n+        final HashSet<String> ignored = _ignoredEntries;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+        final MapProperty prop = new MapProperty(_valueTypeSerializer);\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            // First, serialize key\n+            final Object keyElem = entry.getKey();\n+            final Object valueElem = entry.getValue();\n+            JsonSerializer<Object> keySer;\n+            if (keyElem == null) {\n+                keySer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                // [JACKSON-314] skip entries with null values?\n+                if (skipNulls && valueElem == null) continue;\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySer = _keySerializer;\n+            }\n+            JsonSerializer<Object> valueSer;\n+            // And then value\n+            if (valueElem == null) {\n+                valueSer = provider.getDefaultNullValueSerializer();\n+            } else {\n+                Class<?> cc = valueElem.getClass();\n+                valueSer = serializers.serializerFor(cc);\n+                if (valueSer == null) {\n+                    if (_valueType.hasGenericTypes()) {\n+                        valueSer = _findAndAddDynamic(serializers,\n+                                provider.constructSpecializedType(_valueType, cc), provider);\n+                    } else {\n+                        valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                    }\n+                    serializers = _dynamicValueSerializers;\n+                }\n+            }\n+            prop.reset(keyElem, valueElem, keySer, valueSer);\n+            try {\n+                filter.serializeAsField(value, jgen, provider, prop);\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+    \n     protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestAnyGetterFiltering.java\n+package com.fasterxml.jackson.databind.filter;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n+\n+/**\n+ * Unit tests for ensuring that entries accessible via \"any filter\"\n+ * can also be filtered with JSON Filter functionality.\n+ */\n+public class TestAnyGetterFiltering extends BaseMapTest\n+{\n+    @JsonFilter(\"anyFilter\")\n+    public static class AnyBean\n+    {\n+        private Map<String, String> properties = new HashMap<String, String>();\n+        {\n+            properties.put(\"a\", \"1\");\n+            properties.put(\"b\", \"2\");\n+        }\n+\n+        @JsonAnyGetter\n+        public Map<String, String> anyProperties()\n+        {\n+            return properties;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    // should also work for @JsonAnyGetter, as per [JACKSON-516]\n+    public void testAnyGetterFiltering() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"anyFilter\",\n+                SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+        assertEquals(\"{\\\"b\\\":\\\"2\\\"}\", mapper.writer(prov).writeValueAsString(new AnyBean()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestJsonFilter.java\n+package com.fasterxml.jackson.databind.filter;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.impl.*;\n+\n+/**\n+ * Tests for verifying that bean property filtering using JsonFilter\n+ * works as expected.\n+ */\n+public class TestJsonFilter extends BaseMapTest\n+{\n+    @JsonFilter(\"RootFilter\")\n+    static class Bean {\n+        public String a = \"a\";\n+        public String b = \"b\";\n+    }\n+\n+    \n+    // [Issue#89]\n+    static class Pod\n+    {\n+        protected String username;\n+\n+//        @JsonProperty(value = \"user_password\")\n+        protected String userPassword;\n+\n+        public String getUsername() {\n+            return username;\n+        }\n+\n+        public void setUsername(String value) {\n+            this.username = value;\n+        }\n+\n+        @JsonIgnore\n+        @JsonProperty(value = \"user_password\")\n+        public java.lang.String getUserPassword() {\n+            return userPassword;\n+        }\n+\n+        @JsonProperty(value = \"user_password\")\n+        public void setUserPassword(String value) {\n+            this.userPassword = value;\n+        }\n+    }    \n+\n+    // [Issue#306]: JsonFilter for properties, too!\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class FilteredProps\n+    {\n+        // will default to using \"RootFilter\", only including 'a'\n+        public Bean first = new Bean();\n+\n+        // but minimal includes 'b'\n+        @JsonFilter(\"b\")\n+        public Bean second = new Bean();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    public void testSimpleInclusionFilter() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"RootFilter\",\n+                SimpleBeanPropertyFilter.filterOutAllExcept(\"a\"));\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", MAPPER.writer(prov).writeValueAsString(new Bean()));\n+\n+        // [JACKSON-504]: also verify it works via mapper\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setFilters(prov);\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", mapper.writeValueAsString(new Bean()));\n+    }\n+\n+    public void testSimpleExclusionFilter() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"RootFilter\",\n+                SimpleBeanPropertyFilter.serializeAllExcept(\"a\"));\n+        assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", MAPPER.writer(prov).writeValueAsString(new Bean()));\n+    }\n+\n+    // should handle missing case gracefully\n+    public void testMissingFilter() throws Exception\n+    {\n+        // First: default behavior should be to throw an exception\n+        try {\n+            MAPPER.writeValueAsString(new Bean());\n+            fail(\"Should have failed without configured filter\");\n+        } catch (JsonMappingException e) { // should be resolved to a MappingException (internally may be something else)\n+            verifyException(e, \"Can not resolve PropertyFilter with id 'RootFilter'\");\n+        }\n+        \n+        // but when changing behavior, should work difference\n+        SimpleFilterProvider fp = new SimpleFilterProvider().setFailOnUnknownId(false);\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setFilters(fp);\n+        String json = mapper.writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", json);\n+    }\n+    \n+    // defaulting, as per [JACKSON-449]\n+    public void testDefaultFilter() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+        assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", MAPPER.writer(prov).writeValueAsString(new Bean()));\n+    }\n+    \n+    // [Issue#89] combining @JsonIgnore, @JsonProperty\n+    public void testIssue89() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Pod pod = new Pod();\n+        pod.username = \"Bob\";\n+        pod.userPassword = \"s3cr3t!\";\n+\n+        String json = mapper.writeValueAsString(pod);\n+\n+        assertEquals(\"{\\\"username\\\":\\\"Bob\\\"}\", json);\n+\n+        Pod pod2 = mapper.readValue(\"{\\\"username\\\":\\\"Bill\\\",\\\"user_password\\\":\\\"foo!\\\"}\", Pod.class);\n+        assertEquals(\"Bill\", pod2.username);\n+        assertEquals(\"foo!\", pod2.userPassword);\n+    }\n+\n+    // Wrt [Issue#306]\n+    public void testFilterOnProperty() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider()\n+            .addFilter(\"RootFilter\", SimpleBeanPropertyFilter.filterOutAllExcept(\"a\"))\n+            .addFilter(\"b\", SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+\n+        assertEquals(\"{\\\"first\\\":{\\\"a\\\":\\\"a\\\"},\\\"second\\\":{\\\"b\\\":\\\"b\\\"}}\",\n+                MAPPER.writer(prov).writeValueAsString(new FilteredProps()));\n+    }\n+}", "timestamp": 1382074630, "metainfo": ""}