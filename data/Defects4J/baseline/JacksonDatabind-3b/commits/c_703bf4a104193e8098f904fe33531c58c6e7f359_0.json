{"sha": "703bf4a104193e8098f904fe33531c58c6e7f359", "log": "Implement [JACKSON-749]: Make @JsonValue the canonical serialization of Enums, so that deserializer also uses it", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n /**\n         = PrimitiveArrayDeserializers.getAll();\n \n     /**\n-     * To support external/optional deserializers, we'll use this helper class\n-     * (as per [JACKSON-386])\n+     * To support external/optional deserializers, we'll use a helper class\n      */\n     protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n     \n         if (contentDeser == null) { // not defined by annotation\n             // One special type: EnumSet:\n             if (EnumSet.class.isAssignableFrom(collectionClass)) {\n-                return new EnumSetDeserializer(constructEnumResolver(contentType.getRawClass(), config));\n+                return new EnumSetDeserializer(constructEnumResolver(contentType.getRawClass(), config,\n+                        _findJsonValueFor(config, contentType)));\n             }\n             // But otherwise we can just use a generic value deserializer:\n             // 'null' -> collections have no referring fields\n             if (kt == null || !kt.isEnum()) {\n                 throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n             }\n-            return new EnumMapDeserializer(constructEnumResolver(kt, config), contentDeser);\n+            return new EnumMapDeserializer(constructEnumResolver(kt, config, _findJsonValueFor(config, keyType)),\n+                    contentDeser);\n         }\n \n         // Otherwise, generic handler works ok.\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        /* 18-Feb-2009, tatu: Must first check if we have a class annotation\n-         *    that should override default deserializer\n-         */\n-        BasicBeanDescription beanDesc = config.introspectForCreation(type);\n+        BasicBeanDescription beanDesc = config.introspect(type);\n         JsonDeserializer<?> des = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n         if (des != null) {\n             return des;\n                         +enumClass.getName()+\")\");\n             }\n         }\n-        return new EnumDeserializer(constructEnumResolver(enumClass, config));\n+        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n+        return new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n     }\n \n     @Override\n     /**\n      * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n      * deserializer registered for given type.\n-     * \n-     * @since 1.8\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> findStdBeanDeserializer(DeserializationConfig config,\n      *    deserializer type will be this type or its subtype)\n      * \n      * @return Type deserializer to use for given base type, if one is needed; null if not.\n-     * \n-     * @since 1.5\n      */\n     public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType,\n            AnnotatedMember annotated, BeanProperty property)\n      * \n      * @param containerType Type of property; must be a container type\n      * @param propertyEntity Field or method that contains container property\n-     * \n-     * @since 1.5\n      */    \n     public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType,\n             AnnotatedMember propertyEntity, BeanProperty property)\n     \treturn type;\n     }\n     \n-    protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config)\n-    {\n+    protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config,\n+            AnnotatedMethod jsonValueMethod)\n+    {\n+        if (jsonValueMethod != null) {\n+            Method accessor = jsonValueMethod.getAnnotated();\n+            if (config.canOverrideAccessModifiers()) {\n+                ClassUtil.checkAndFixAccess(accessor);\n+            }\n+            return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n+        }\n         // [JACKSON-212]: may need to use Enum.toString()\n         if (config.isEnabled(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING)) {\n             return EnumResolver.constructUnsafeUsingToString(enumClass);\n         }\n         return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n     }\n+\n+    protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)\n+    {\n+        if (enumType == null) {\n+            return null;\n+        }\n+        BasicBeanDescription beanDesc = config.introspect(enumType);\n+        return beanDesc.findJsonValueMethod();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n                     for (Constructor<?> ctor : valueClass.getConstructors()) {\n                         Class<?>[] paramTypes = ctor.getParameterTypes();\n                         if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n-                            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                            if (config.canOverrideAccessModifiers()) {\n                                 ClassUtil.checkAndFixAccess(ctor);\n                             }\n                             return new SettableBeanProperty.InnerClassProperty(prop, ctor);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n             BasicBeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        boolean fixAccess = config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+        boolean fixAccess = config.canOverrideAccessModifiers();\n         CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         \n     {\n         Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n         if (raw != null) {\n-            boolean fixAccess = config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+            boolean fixAccess = config.canOverrideAccessModifiers();\n             for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                 AnnotatedMember m = entry.getValue();\n                 if (fixAccess) {\n             BasicBeanDescription beanDesc, AnnotatedMethod setter)\n         throws JsonMappingException\n     {\n-        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             setter.fixAccess(); // to ensure we can call it\n         }\n         // we know it's a 2-arg method, second arg is the value\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n-        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             setter.fixAccess();\n         }\n \n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n-        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             field.fixAccess();\n         }\n         JavaType t0 = beanDesc.bindingsForBeanType().resolveType(field.getGenericType());\n         throws JsonMappingException\n     {\n         // need to ensure it is callable now:\n-        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             getter.fixAccess();\n         }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n         if (factory.getParameterType(0) != String.class) {\n             throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n         }\n-        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n         return new FactoryBasedDeserializer(enumClass, factory);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n         // Ok, so: can we find T(String) constructor?\n         Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class);\n         if (ctor != null) {\n-            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            if (config.canOverrideAccessModifiers()) {\n                 ClassUtil.checkAndFixAccess(ctor);\n             }\n             return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor);\n          */\n         Method m = beanDesc.findFactoryMethod(String.class);\n         if (m != null){\n-            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            if (config.canOverrideAccessModifiers()) {\n                 ClassUtil.checkAndFixAccess(m);\n             }\n             return new StdKeyDeserializer.StringFactoryKeyDeserializer(m);\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n         desc._anySetterMethod = coll.getAnySetterMethod();\n         desc._ignoredPropertyNames = coll.getIgnoredPropertyNames();\n         desc._injectables = coll.getInjectables();\n+        desc._jsonValueMethod = coll.getJsonValueMethod();\n         return desc;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n public abstract class BasicSerializerFactory\n     extends SerializerFactory\n {\n-    \n     /*\n     /**********************************************************\n     /* Configuration, lookup tables/maps\n         if (valueMethod != null) {\n             // [JACKSON-586]: need to ensure accessibility of method\n             Method m = valueMethod.getAnnotated();\n-            if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            if (config.canOverrideAccessModifiers()) {\n                 ClassUtil.checkAndFixAccess(m);\n             }\n             JsonSerializer<Object> ser = findSerializerFromAnnotation(config, valueMethod, property);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         /**\n          * List of providers for additional serializers, checked before considering default\n          * basic or bean serialializers.\n-         * \n-         * @since 1.7\n          */\n         protected final Serializers[] _additionalSerializers;\n \n         /**\n-         * @since 1.8\n+         * List of providers for additional key serializers, checked before considering default\n+         * key serialializers.\n          */\n         protected final Serializers[] _additionalKeySerializers;\n         \n         \n         AnnotatedMethod anyGetter = beanDesc.findAnyGetter();\n         if (anyGetter != null) { // since 1.6\n-            if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            if (config.canOverrideAccessModifiers()) {\n                 anyGetter.fixAccess();\n             }\n             JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n             PropertyBuilder pb, boolean staticTyping, String name, AnnotatedMember accessor)\n         throws JsonMappingException\n     {\n-        if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+        if (config.canOverrideAccessModifiers()) {\n             accessor.fixAccess();\n         }\n         JavaType type = accessor.getType(typeContext);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n             /* If we can fix access rights, we should; otherwise non-public\n              * classes or default constructor will prevent instantiation\n              */\n-            _defaultBean = _beanDesc.instantiateBean(_config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+            _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers());\n             if (_defaultBean == null) {\n                 Class<?> cls = _beanDesc.getClassInfo().getAnnotated();\n                 throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation\");\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n \n+import java.lang.reflect.Method;\n import java.util.*;\n \n /**\n         }\n         return new EnumResolver<ET>(enumCls, enumValues, map);\n     }    \n+\n+    public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingMethod(Class<ET> enumCls,\n+            Method accessor)\n+    {\n+        ET[] enumValues = enumCls.getEnumConstants();\n+        HashMap<String, ET> map = new HashMap<String, ET>();\n+        // from last to first, so that in case of duplicate values, first wins\n+        for (int i = enumValues.length; --i >= 0; ) {\n+            ET en = enumValues[i];\n+            try {\n+                Object o = accessor.invoke(en);\n+                if (o != null) {\n+                    map.put(o.toString(), en);\n+                }\n+            } catch (Exception e) {\n+                throw new IllegalArgumentException(\"Failed to access @JsonValue of Enum value \"+en+\": \"+e.getMessage());\n+            }\n+        }\n+        return new EnumResolver<ET>(enumCls, enumValues, map);\n+    }    \n     \n     /**\n      * This method is needed because of the dynamic nature of constructing Enum\n         Class<Enum> enumCls = (Class<Enum>) rawEnumCls;\n         return constructUsingToString(enumCls);\n     }\n+\n+    /**\n+     * Method used when actual String serialization is indicated using @JsonValue\n+     * on a method.\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static EnumResolver<?> constructUnsafeUsingMethod(Class<?> rawEnumCls, Method accessor)\n+    {            \n+        // wrong as ever but:\n+        Class<Enum> enumCls = (Class<Enum>) rawEnumCls;\n+        return constructUsingMethod(enumCls, accessor);\n+    }\n     \n     public T findEnum(String key)\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.util.EnumMap;\n+import java.util.EnumSet;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n         @Override\n         public String toString() { return name().toLowerCase(); }\n     }\n+\n+    // for [JACKSON-749]\n+    protected enum EnumWithJsonValue {\n+        A(\"foo\"), B(\"bar\");\n+        private final String name;\n+        private EnumWithJsonValue(String n) {\n+            name = n;\n+        }\n+        @JsonValue\n+        @Override\n+        public String toString() { return name; }\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n+    protected final ObjectMapper mapper = new ObjectMapper();\n+\n     public void testSimple() throws Exception\n     {\n         // First \"good\" case with Strings\n-        ObjectMapper mapper = new ObjectMapper();\n         String JSON = \"\\\"OK\\\" \\\"RULES\\\"  null\";\n         // multiple main-level mappings, need explicit parser:\n         JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n      */\n     public void testComplexEnum() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         String json = mapper.writeValueAsString(TimeUnit.HOURS);\n         assertEquals(quote(\"HOURS\"), json);\n         TimeUnit result = mapper.readValue(json, TimeUnit.class);\n      */\n     public void testAnnotated() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         AnnotatedTestEnum e = mapper.readValue(\"\\\"JACKSON\\\"\", AnnotatedTestEnum.class);\n         /* dummy deser always returns value OK, independent of input;\n          * only works if annotation is used\n \n     public void testEnumMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         EnumMap<TestEnum,String> value = mapper.readValue(\"{\\\"OK\\\":\\\"value\\\"}\",\n                 new TypeReference<EnumMap<TestEnum,String>>() { });\n         assertEquals(\"value\", value.get(TestEnum.OK));\n     // Test [JACKSON-214]\n     public void testSubclassedEnums() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         EnumWithSubClass value = mapper.readValue(\"\\\"A\\\"\", EnumWithSubClass.class);\n         assertEquals(EnumWithSubClass.A, value);\n     }\n     // [JACKSON-193]\n     public void testCreatorEnums() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         EnumWithCreator value = mapper.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n     }\n     // [JACKSON-212]\n     public void testToStringEnums() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n-        LowerCaseEnum value = mapper.readValue(\"\\\"c\\\"\", LowerCaseEnum.class);\n+        // can't reuse global one due to reconfig\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        LowerCaseEnum value = m.readValue(\"\\\"c\\\"\", LowerCaseEnum.class);\n         assertEquals(LowerCaseEnum.C, value);\n     }\n \n     // [JACKSON-212]\n     public void testToStringEnumMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n-        EnumMap<LowerCaseEnum,String> value = mapper.readValue(\"{\\\"a\\\":\\\"value\\\"}\",\n+        // can't reuse global one due to reconfig\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        EnumMap<LowerCaseEnum,String> value = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\",\n                 new TypeReference<EnumMap<LowerCaseEnum,String>>() { });\n         assertEquals(\"value\", value.get(LowerCaseEnum.A));\n     }\n     public void testNumbersToEnums() throws Exception\n     {\n         // by default numbers are fine:\n-        ObjectMapper mapper = new ObjectMapper();\n         assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS));\n         TestEnum value = mapper.readValue(\"1\", TestEnum.class);\n         assertSame(TestEnum.RULES, value);\n \n         // but can also be changed to errors:\n-        mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n         try {\n-            value = mapper.readValue(\"1\", TestEnum.class);\n+            value = m.readValue(\"1\", TestEnum.class);\n             fail(\"Expected an error\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Not allowed to deserialize Enum value out of JSON number\");\n     // [JACKSON-684], enums using index\n     public void testEnumsWithIndex() throws Exception\n     {\n-        // by default numbers are fine:\n-        ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n-        String json = mapper.writeValueAsString(TestEnum.RULES);\n+        ObjectMapper m = new ObjectMapper();\n+        m.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        String json = m.writeValueAsString(TestEnum.RULES);\n         assertEquals(String.valueOf(TestEnum.RULES.ordinal()), json);\n-        TestEnum result = mapper.readValue(json, TestEnum.class);\n+        TestEnum result = m.readValue(json, TestEnum.class);\n         assertSame(TestEnum.RULES, result);\n     }        \n+\n+    // [JACKSON-749]: @JsonValue should be considered as well\n+    public void testEnumsWithJsonValue() throws Exception\n+    {\n+        // first, enum as is\n+        EnumWithJsonValue e = mapper.readValue(quote(\"foo\"), EnumWithJsonValue.class);\n+        assertSame(EnumWithJsonValue.A, e);\n+        e = mapper.readValue(quote(\"bar\"), EnumWithJsonValue.class);\n+        assertSame(EnumWithJsonValue.B, e);\n+\n+        // then in EnumSet\n+        EnumSet<EnumWithJsonValue> set = mapper.readValue(\"[\\\"bar\\\"]\",\n+                new TypeReference<EnumSet<EnumWithJsonValue>>() { });\n+        assertNotNull(set);\n+        assertEquals(1, set.size());\n+        assertTrue(set.contains(EnumWithJsonValue.B));\n+        assertFalse(set.contains(EnumWithJsonValue.A));\n+\n+        // and finally EnumMap\n+        EnumMap<EnumWithJsonValue,Integer> map = mapper.readValue(\"{\\\"foo\\\":13}\",\n+                new TypeReference<EnumMap<EnumWithJsonValue, Integer>>() { });\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(13), map.get(EnumWithJsonValue.A));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n         @Override\n         public String toString() { return name; }\n     }\n-\n+    \n     protected static interface ToStringMixin {\n         @Override\n         @JsonValue public String toString();", "timestamp": 1326348877, "metainfo": ""}