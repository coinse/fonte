{"sha": "82b474d51545919cb38a49485f56fd29d6ed199b", "log": "Fix 3 unit test failures", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.*;\n-import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n-import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Class that defines caching layer between callers (like\n+ * {@link ObjectMapper},\n+ * {@link com.fasterxml.jackson.databind.DeserializationContext})\n+ * and classes that construct deserializers\n+ * ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}).\n+ */\n+public final class DeserializerCache\n+{\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will also cache some dynamically constructed deserializers;\n+     * specifically, ones that are expensive to construct.\n+     * This currently means bean and Enum deserializers; array, List and Map\n+     * deserializers will not be cached.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+\n+    /**\n+     * During deserializer construction process we may need to keep track of partially\n+     * completed deserializers, to resolve cyclic dependencies. This is the\n+     * map used for storing deserializers before they are fully complete.\n+     */\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public DeserializerCache() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Access to caching aspects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many deserializers this\n+     * provider is caching currently \n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of deserializers get cached;\n+     * default implementation caches only dynamically constructed deserializers,\n+     * but not eagerly constructed standard deserializers (which is different\n+     * from how serializer provider works).\n+     *<p>\n+     * The main use case for this method is to allow conditional flushing of\n+     * deserializer cache, if certain number of entries is reached.\n+     */\n+    public int cachedDeserializersCount() {\n+        return _cachedDeserializers.size();\n+    }\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     */\n+    public void flushCachedDeserializers() {\n+        _cachedDeserializers.clear();       \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General deserializer locating method\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a deserializer for a value of given type;\n+     * or if no such deserializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for value types; not for keys.\n+     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *<p>\n+     * Note also that deserializer returned is guaranteed to be resolved\n+     * (if it is of type {@link ResolvableDeserializer}), but\n+     * not contextualized (wrt {@link ContextualDeserializer}): caller\n+     * has to handle latter if necessary.\n+     *\n+     * @param ctxt Deserialization context\n+     * @param propertyType Declared type of the value to deserializer (obtained using\n+     *   'setter' method signature and/or type annotations\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType propertyType)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, need to request factory to construct (or recycle)\n+        deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n+        if (deser == null) {\n+            /* Should we let caller handle it? Let's have a helper method\n+             * decide it; can throw an exception, or return a valid\n+             * deserializer\n+             */\n+            deser = _handleUnknownValueDeserializer(propertyType);\n+        }\n+        return deser;\n+    }\n+\n+    /**\n+     * Method called to get hold of a deserializer to use for deserializing\n+     * keys for {@link java.util.Map}.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable key deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        KeyDeserializer kd = factory.createKeyDeserializer(ctxt, type);\n+        if (kd == null) { // if none found, need to use a placeholder that'll fail\n+            return _handleUnknownKeyDeserializer(type);\n+        }\n+        // First: need to resolve?\n+        if (kd instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) kd).resolve(ctxt);\n+        }\n+        return kd;\n+    }\n+\n+    /**\n+     * Method called to find out whether provider would be able to find\n+     * a deserializer for given type, using a root reference (i.e. not\n+     * through fields or membership in an array or collection)\n+     */\n+    public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+    {\n+        /* Note: mostly copied from findValueDeserializer, except for\n+         * handling of unknown types\n+         */\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+        if (deser == null) {\n+            try {\n+                deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return (deser != null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods that handle cache lookups\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"Null JavaType passed\");\n+        }\n+        return _cachedDeserializers.get(type);\n+    }\n+\n+    /**\n+     * Method that will try to create a deserializer for given type,\n+     * and resolve and cache it if necessary\n+     * \n+     * @param config Configuration\n+     * @param type Type of property to deserializer\n+     * @param property Property (field, setter, ctor arg) to use deserializer for\n+     */\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Only one thread to construct deserializers at any given point in time;\n+         * limitations necessary to ensure that only completely initialized ones\n+         * are visible and used.\n+         */\n+        synchronized (_incompleteDeserializers) {\n+            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n+            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+            if (deser != null) {\n+                return deser;\n+            }\n+            int count = _incompleteDeserializers.size();\n+            // Or perhaps being resolved right now?\n+            if (count > 0) {\n+                deser = _incompleteDeserializers.get(type);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+            // Nope: need to create and possibly cache\n+            try {\n+                return _createAndCache2(ctxt, factory, type);\n+            } finally {\n+                // also: any deserializers that have been created are complete by now\n+                if (count == 0 && _incompleteDeserializers.size() > 0) {\n+                    _incompleteDeserializers.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that handles actual construction (via factory) and caching (both\n+     * intermediate and eventual)\n+     */\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser;\n+        try {\n+            deser = _createDeserializer(ctxt, factory, type);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+        if (deser == null) {\n+            return null;\n+        }\n+        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n+         * (but can be re-defined for sub-classes by using @JsonCachable!)\n+         */\n+        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n+        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n+        boolean addToCache = deser.isCachable();\n+\n+        /* we will temporarily hold on to all created deserializers (to\n+         * handle cyclic references, and possibly reuse non-cached\n+         * deserializers (list, map))\n+         */\n+        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n+         *   resolution of a reference -- couple of ways to prevent this;\n+         *   either not add Lists or Maps, or clear references eagerly.\n+         *   Let's actually do both; since both seem reasonable.\n+         */\n+        /* Need to resolve? Mostly done for bean deserializers; required for\n+         * resolving cyclic references.\n+         */\n+        if (isResolvable) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer)deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n+        if (addToCache) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for actual construction of deserializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that does the heavy lifting of checking for per-type annotations,\n+     * find out full type, and figure out which actual factory method\n+     * to call.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n+            DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        // First things first: do we need to use abstract type mapping?\n+        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n+            type = factory.mapAbstractType(config, type);\n+        }\n+        BeanDescription beanDesc = config.introspect(type);\n+        // Then: does type define explicit deserializer to use, with annotation(s)?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n+                beanDesc.getClassInfo());\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // If not, may have further type-modification annotations to check:\n+        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n+        if (newType != type) {\n+            type = newType;\n+            beanDesc = config.introspect(newType);\n+        }\n+\n+        // If not, let's see which factory method to use:\n+        if (type.isEnumType()) {\n+            return (JsonDeserializer<Object>) factory.createEnumDeserializer(ctxt,\n+                    type, beanDesc);\n+        }\n+        if (type.isContainerType()) {\n+            if (type.isArrayType()) {\n+                return (JsonDeserializer<Object>) factory.createArrayDeserializer(ctxt,\n+                        (ArrayType) type, beanDesc);\n+            }\n+            if (type.isMapLikeType()) {\n+                MapLikeType mlt = (MapLikeType) type;\n+                if (mlt.isTrueMapType()) {\n+                    return (JsonDeserializer<Object>) factory.createMapDeserializer(ctxt,\n+                            (MapType) mlt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createMapLikeDeserializer(ctxt,\n+                        mlt, beanDesc);\n+            }\n+            if (type.isCollectionLikeType()) {\n+                CollectionLikeType clt = (CollectionLikeType) type;\n+                if (clt.isTrueCollectionType()) {\n+                    return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n+                            (CollectionType) clt, beanDesc);\n+                }\n+                return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n+                        clt, beanDesc);\n+            }\n+        }\n+\n+        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n+        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n+            return (JsonDeserializer<Object>) factory.createTreeDeserializer(config, type, beanDesc);\n+        }\n+        return (JsonDeserializer<Object>) factory.createBeanDeserializer(ctxt, type, beanDesc);\n+    }\n+\n+    /**\n+     * Helper method called to check if a class or method\n+     * has annotation that tells which class to use for deserialization.\n+     * Returns null if no such annotation found.\n+     */\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n+            Annotated ann)\n+        throws JsonMappingException\n+    {\n+        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        return ctxt.deserializerInstance(ann, deserDef);\n+    }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, JavaType type)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type);\n+        if (subclass != null) {\n+            try {\n+                type = type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n+                    if (kd != null) {\n+                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n+                }\n+            }            \n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n+            if (cc != null) {\n+                try {\n+                    type = type.narrowContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            // ... as well as deserializer for contents:\n+            JavaType contentType = type.getContentType();\n+            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+                Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = ctxt.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = type.withContentValueHandler(cd);\n+                    }\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable error reporting methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Let's try to figure out the reason, to give better error\n+         * messages\n+         */\n+        Class<?> rawClass = type.getRawClass();\n+        if (!ClassUtil.isConcrete(rawClass)) {\n+            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n+        }\n+        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n+    }\n+\n+    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n     }\n \n-    protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n-        new HashMap<String, JsonSerializer<?>>();\n-    static {\n-        // Arrays of various types (including common object types)\n-        _arraySerializers.put(boolean[].class.getName(), new StdArraySerializers.BooleanArraySerializer());\n-        _arraySerializers.put(byte[].class.getName(), new StdArraySerializers.ByteArraySerializer());\n-        _arraySerializers.put(char[].class.getName(), new StdArraySerializers.CharArraySerializer());\n-        _arraySerializers.put(short[].class.getName(), new StdArraySerializers.ShortArraySerializer());\n-        _arraySerializers.put(int[].class.getName(), new StdArraySerializers.IntArraySerializer());\n-        _arraySerializers.put(long[].class.getName(), new StdArraySerializers.LongArraySerializer());\n-        _arraySerializers.put(float[].class.getName(), new StdArraySerializers.FloatArraySerializer());\n-        _arraySerializers.put(double[].class.getName(), new StdArraySerializers.DoubleArraySerializer());\n-    }\n-\n     /*\n     /**********************************************************\n     /* Configuration\n                 return StringArraySerializer.instance;\n             }\n             // other standard types?\n-            JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n+            JsonSerializer<?> ser = StdArraySerializers.findStandardImpl(raw);\n             if (ser != null) {\n                 return ser;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         if (ser != null) {\n             return (JsonSerializer<Object>) ser;\n         }\n+        \n         // Next: we may have annotations that further define types to use...\n         JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+\n         // and if so, we consider it implicit \"force static typing\" instruction\n         boolean staticTyping = (type != origType);\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerCache.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\n+\n+/**\n+ * Simple cache object that allows for doing 2-level lookups: first level is\n+ * by \"local\" read-only lookup Map (used without locking)\n+ * and second backup level is by a shared modifiable HashMap.\n+ * The idea is that after a while, most serializers are found from the\n+ * local Map (to optimize performance, reduce lock contention),\n+ * but that during buildup we can use a shared map to reduce both\n+ * number of distinct read-only maps constructed, and number of\n+ * serializers constructed.\n+ *<p>\n+ * Since version 1.5 cache will actually contain three kinds of entries,\n+ * based on combination of class pair key. First class in key is for the\n+ * type to serialize, and second one is type used for determining how\n+ * to resolve value type. One (but not both) of entries can be null.\n+ */\n+public final class SerializerCache\n+{\n+    /**\n+     * Shared, modifiable map; all access needs to be through synchronized blocks.\n+     *<p>\n+     * NOTE: keys are of various types (see below for key types), in addition to\n+     * basic {@link JavaType} used for \"untyped\" serializers.\n+     */\n+    private HashMap<TypeKey, JsonSerializer<Object>> _sharedMap = new HashMap<TypeKey, JsonSerializer<Object>>(64);\n+\n+    /**\n+     * Most recent read-only instance, created from _sharedMap, if any.\n+     */\n+    private ReadOnlyClassToSerializerMap _readOnlyMap = null;\n+\n+    public SerializerCache() { }\n+\n+    /**\n+     * Method that can be called to get a read-only instance populated from the\n+     * most recent version of the shared lookup Map.\n+     */\n+    public ReadOnlyClassToSerializerMap getReadOnlyLookupMap()\n+    {\n+        ReadOnlyClassToSerializerMap m;\n+        synchronized (this) {\n+            m = _readOnlyMap;\n+            if (m == null) {\n+                _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap);\n+            }\n+        }\n+        return m.instance();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Lookup methods for accessing shared (slow) cache\n+    /**********************************************************\n+     */\n+\n+    public synchronized int size() {\n+        return _sharedMap.size();\n+    }\n+    \n+    /**\n+     * Method that checks if the shared (and hence, synchronized) lookup Map might have\n+     * untyped serializer for given type.\n+     */\n+    public JsonSerializer<Object> untypedValueSerializer(Class<?> type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, true));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(Class<?> cls)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(cls, true));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for adding shared serializer instances\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called if none of lookups succeeded, and caller had to construct\n+     * a serializer. If so, we will update the shared lookup map so that it\n+     * can be resolved via it next time.\n+     */\n+    public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+\n+    public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(cls, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+    \n+    public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called by StdSerializerProvider#flushCachedSerializers() to\n+     * clear all cached serializers\n+     */\n+    public synchronized void flush() {\n+        _sharedMap.clear();\n+    }\n+\n+    /*\n+    /**************************************************************\n+    /* Helper class(es)\n+    /**************************************************************\n+     */\n+\n+    /**\n+     * Key that offers two \"modes\"; one with raw class, as used for\n+     * cases were raw class type is available (for example, when using\n+     * runtime type); and one with full generics-including.\n+     */\n+    public final static class TypeKey\n+    {\n+        protected int _hashCode;\n+\n+        protected Class<?> _class;\n+\n+        protected JavaType _type;\n+\n+        /**\n+         * Indicator of whether serializer stored has a type serializer\n+         * wrapper around it or not; if not, it is \"untyped\" serializer;\n+         * if it has, it is \"typed\"\n+         */\n+        protected boolean _isTyped;\n+        \n+        public TypeKey(Class<?> key, boolean typed) {\n+            _class = key;\n+            _type = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        public TypeKey(JavaType key, boolean typed) {\n+            _type = key;\n+            _class = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        private final static int hash(Class<?> cls, boolean typed) {\n+            int hash = cls.getName().hashCode();\n+            if (typed) {\n+                ++hash;\n+            }\n+            return hash;\n+        }\n+\n+        private final static int hash(JavaType type, boolean typed) {\n+            int hash = type.hashCode() - 1;\n+            if (typed) {\n+                --hash;\n+            }\n+            return hash;\n+        }\n+        \n+        public void resetTyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = true;\n+            _hashCode = hash(cls, true);\n+        }\n+\n+        public void resetUntyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = false;\n+            _hashCode = hash(cls, false);\n+        }\n+        \n+        public void resetTyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = true;\n+            _hashCode = hash(type, true);\n+        }\n+\n+        public void resetUntyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = false;\n+            _hashCode = hash(type, false);\n+        }\n+        \n+        @Override public final int hashCode() { return _hashCode; }\n+\n+        @Override public final String toString() {\n+            if (_class != null) {\n+                return \"{class: \"+_class.getName()+\", typed? \"+_isTyped+\"}\";\n+            }\n+            return \"{type: \"+_type+\", typed? \"+_isTyped+\"}\";\n+        }\n+        \n+        // note: we assume key is never used for anything other than as map key, so:\n+        @Override public final boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            TypeKey other = (TypeKey) o;\n+            if (other._isTyped == _isTyped) {\n+                if (_class != null) {\n+                    return other._class == _class;\n+                }\n+                return _type.equals(other._type);\n+            }\n+            return false;\n+        } \n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n \n     @SuppressWarnings(\"unchecked\")\n     public IndexedStringListSerializer(JsonSerializer<?> ser) {\n-        super(List.class, null);\n+        super(List.class);\n         _serializer = (JsonSerializer<String>) ser;\n         \n     }\n     {\n         JsonSerializer<?> ser = _serializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n import java.util.Map;\n \n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+import com.fasterxml.jackson.databind.ser.SerializerCache.TypeKey;\n \n /**\n  * Specialized read-only map used for storing and accessing serializers by type.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+import com.fasterxml.jackson.databind.ser.SerializerCache.TypeKey;\n \n /**\n  * Optimized lookup table for accessing two types of serializers; typed\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n     {\n         JsonSerializer<?> ser = _elementSerializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n     @SuppressWarnings(\"unchecked\")\n     protected StringCollectionSerializer(JsonSerializer<?> ser)\n     {\n-        super(Collection.class, null);\n+        super(Collection.class);\n         _serializer = (JsonSerializer<String>) ser;\n     }        \n     \n     {\n         JsonSerializer<?> ser = _serializer;\n         if (ser == null) {\n-            ser = provider.findValueSerializer(String.class, _property);\n+            ser = provider.findValueSerializer(String.class, property);\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                     continue;\n                 }\n             }\n+            \n             JsonSerializer<Object> ser = provider.findValueSerializer(type, prop);\n             /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n              *   too, earlier; if so, it's time to connect the dots here:\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         JsonSerializer<?> ser = _valueSerializer;\n         if (ser == null) {\n             if (_valueTypeIsStatic) {\n-                ser = provider.findValueSerializer(_valueType, _property);\n+                ser = provider.findValueSerializer(_valueType, property);\n             }\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n          */\n         JsonSerializer<?> keySer = _keySerializer;\n         if (keySer == null) {\n-            keySer = provider.findKeySerializer(_keyType, _property);\n+            keySer = provider.findKeySerializer(_keyType, property);\n         } else if (keySer instanceof ContextualSerializer) {\n             keySer = ((ContextualSerializer) keySer).createContextual(provider, property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n-import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n public abstract class StaticListSerializerBase<T extends Collection<?>>\n     extends StdSerializer<T>\n {\n-    /**\n-     * Property that contains String List to serialize, if known.\n-     */\n-    protected final BeanProperty _property;\n-\n-    protected StaticListSerializerBase(Class<?> cls, BeanProperty property)\n-    {\n+    protected StaticListSerializerBase(Class<?> cls) {\n         super(cls, false);\n-        _property = property;\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.util.HashMap;\n \n import com.fasterxml.jackson.core.*;\n \n  */\n public class StdArraySerializers\n {\n+    protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n+        new HashMap<String, JsonSerializer<?>>();\n+    static {\n+        // Arrays of various types (including common object types)\n+        _arraySerializers.put(boolean[].class.getName(), new StdArraySerializers.BooleanArraySerializer());\n+        _arraySerializers.put(byte[].class.getName(), new StdArraySerializers.ByteArraySerializer());\n+        _arraySerializers.put(char[].class.getName(), new StdArraySerializers.CharArraySerializer());\n+        _arraySerializers.put(short[].class.getName(), new StdArraySerializers.ShortArraySerializer());\n+        _arraySerializers.put(int[].class.getName(), new StdArraySerializers.IntArraySerializer());\n+        _arraySerializers.put(long[].class.getName(), new StdArraySerializers.LongArraySerializer());\n+        _arraySerializers.put(float[].class.getName(), new StdArraySerializers.FloatArraySerializer());\n+        _arraySerializers.put(double[].class.getName(), new StdArraySerializers.DoubleArraySerializer());\n+    }\n+\n     protected StdArraySerializers() { }\n \n+    /**\n+     * Accessor for checking to see if there is a standard serializer for\n+     * given primitive value type.\n+     */\n+    public static JsonSerializer<?> findStandardImpl(Class<?> cls)\n+    {\n+        return _arraySerializers.get(cls.getName());\n+    }\n+    \n     /*\n      ****************************************************************\n     /* Intermediate base classes", "timestamp": 1328232797, "metainfo": ""}