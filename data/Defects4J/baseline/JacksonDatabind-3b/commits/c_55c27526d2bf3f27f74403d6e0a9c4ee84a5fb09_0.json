{"sha": "55c27526d2bf3f27f74403d6e0a9c4ee84a5fb09", "log": "Trying to straighten up new visitor system", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n  * contextualization.\n  */\n public abstract class JsonSerializer<T>\n+    implements JsonFormatVisitable // since 2.1\n {\n     /*\n     /**********************************************************\n     public JsonSerializer<?> getDelegatee() {\n         return null;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Default JsonFormatVisitable implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default implementation simply calls {@link JsonFormatVisitorWrapper#expectAnyFormat(JavaType)}.\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType type)\n+        throws JsonMappingException\n+    {\n+        visitor.expectAnyFormat(type);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n         return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n     }\n-    \n-    /**\n-     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n-     * instance for specified class.\n+\n+    /**\n+     * Method for visiting type hierarchy for given type, using specified visitor.\n+     *<p>\n+     * This method can be used for things like\n+     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n+     * instance for specified type.\n      *\n-     * @param javaType The class to generate schema for\n-     */\n-    public void acceptJsonFormatVisitor(JavaType javaType, JsonFormatVisitorWrapper visitor) throws JsonMappingException {\n-    \tif (javaType == null) {\n-    \t\tthrow new IllegalArgumentException(\"class must be provided\");\n+     * @param type Type to generate schema for (possibly with generic signature)\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n+        throws JsonMappingException\n+    {\n+        acceptJsonFormatVisitor(_typeFactory.constructType(type), visitor);\n+    }\n+    \n+    /**\n+     * Method for visiting type hierarchy for given type, using specified visitor.\n+     *<p>\n+     * This method can be used for things like\n+     * generating <a href=\"http://json-schema.org/\">Json Schema</a>\n+     * instance for specified type.\n+     *\n+     * @param type Type to generate schema for (possibly with generic signature)\n+     * \n+     * @since 2.1\n+     */\n+    public void acceptJsonFormatVisitor(JavaType type, JsonFormatVisitorWrapper visitor)\n+        throws JsonMappingException\n+    {\n+    \tif (type == null) {\n+    \t    throw new IllegalArgumentException(\"type must be provided\");\n     \t}\n-    \t\n     \tif (visitor == null) {\n-    \t\treturn;\n+    \t    return;\n     \t}\n     \tDefaultSerializerProvider provider = _serializerProvider(getSerializationConfig());\n         visitor.setProvider(provider);\n-    \tprovider.acceptJsonFormatVisitor(javaType, visitor);\n+    \tprovider.acceptJsonFormatVisitor(type, visitor);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n package com.fasterxml.jackson.databind.jsonFormatVisitors;\n \n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n \n /**\n  * Marker interface for schema-aware serializers.\n {\n     /**\n      * Get the representation of the schema to which this serializer will conform.\n-     * @param typeHint TODO\n+     * @param typeHint Type of element (entity like property) being visited\n      *\n      * @returns <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n      */\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint);\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWithSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWithSerializerProvider.java\n \n /**\n  * @author jphelan\n- *\n  */\n public interface JsonFormatVisitorWithSerializerProvider {\n-\n-\tpublic SerializerProvider getProvider();\n-\tpublic abstract void setProvider(SerializerProvider provider);\n+    public SerializerProvider getProvider();\n+    public abstract void setProvider(SerializerProvider provider);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n \n import com.fasterxml.jackson.databind.JavaType;\n \n-public interface JsonFormatVisitorWrapper extends JsonFormatVisitorWithSerializerProvider{\n-\n-\tpublic JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType);\n-\tpublic JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType);\n-\tpublic JsonStringFormatVisitor expectStringFormat(JavaType convertedType);\n-\tpublic JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType);\n-\tpublic JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType);\n-\tpublic JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType);\n-\tpublic JsonNullFormatVisitor expectNullFormat(JavaType convertedType);\n-\tpublic JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType);\n-\t\n+public interface JsonFormatVisitorWrapper extends JsonFormatVisitorWithSerializerProvider\n+{\n+    public JsonObjectFormatVisitor expectObjectFormat(JavaType convertedType);\n+    public JsonArrayFormatVisitor expectArrayFormat(JavaType convertedType);\n+    public JsonStringFormatVisitor expectStringFormat(JavaType convertedType);\n+    public JsonNumberFormatVisitor expectNumberFormat(JavaType convertedType);\n+    public JsonIntegerFormatVisitor expectIntegerFormat(JavaType convertedType);\n+    public JsonBooleanFormatVisitor expectBooleanFormat(JavaType convertedType);\n+    public JsonNullFormatVisitor expectNullFormat(JavaType convertedType);\n+    public JsonAnyFormatVisitor expectAnyFormat(JavaType convertedType);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n      * @param propertiesNode Node which the given property would exist within\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      * \tprocessing\n-     *\n      */\n     public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode,\n-    \t\tSerializerProvider provider);\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n     \n     /**\n      * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      * \tprocessing\n      * \n+     * @since 2.1\n      */\n     public void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor,\n-    \t\tSerializerProvider provider);\n+            SerializerProvider provider)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n         /* no need for embedded type information for JSON schema generation (all\n          * type information it needs is accessible via \"untyped\" serializer)\n          */\n-        JsonSerializer<Object> ser = findValueSerializer(javaType, null);\n-        if (ser instanceof JsonFormatVisitable) {\n-            ((JsonFormatVisitable) ser).acceptJsonFormatVisitor(visitor, javaType);\n-        } else {\n-            visitor.expectAnyFormat(javaType);\n-        }\n+        findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n  */\n public abstract class SimpleBeanPropertyFilter implements BeanPropertyFilter\n {\n-\t/*\n+    /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n-\t */\n+     */\n \n-\tprotected SimpleBeanPropertyFilter() { }\n+    protected SimpleBeanPropertyFilter() { }\n \n-\t/**\n-\t * Factory method to construct filter that filters out all properties <b>except</b>\n-\t * ones includes in set\n-\t */\n-\tpublic static SimpleBeanPropertyFilter filterOutAllExcept(Set<String> properties) {\n-\t\treturn new FilterExceptFilter(properties);\n-\t}\n+    /**\n+     * Factory method to construct filter that filters out all properties <b>except</b>\n+     * ones includes in set\n+     */\n+    public static SimpleBeanPropertyFilter filterOutAllExcept(Set<String> properties) {\n+        return new FilterExceptFilter(properties);\n+    }\n \n-\tpublic static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) {\n-\t\tHashSet<String> properties = new HashSet<String>(propertyArray.length);\n-\t\tCollections.addAll(properties, propertyArray);\n-\t\treturn new FilterExceptFilter(properties);\n-\t}\n+    public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) {\n+        HashSet<String> properties = new HashSet<String>(propertyArray.length);\n+        Collections.addAll(properties, propertyArray);\n+        return new FilterExceptFilter(properties);\n+    }\n \n-\tpublic static SimpleBeanPropertyFilter serializeAllExcept(Set<String> properties) {\n-\t\treturn new SerializeExceptFilter(properties);\n-\t}\n+    public static SimpleBeanPropertyFilter serializeAllExcept(Set<String> properties) {\n+        return new SerializeExceptFilter(properties);\n+    }\n \n-\tpublic static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) {\n-\t\tHashSet<String> properties = new HashSet<String>(propertyArray.length);\n-\t\tCollections.addAll(properties, propertyArray);\n-\t\treturn new SerializeExceptFilter(properties);\n-\t}\n+    public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) {\n+        HashSet<String> properties = new HashSet<String>(propertyArray.length);\n+        Collections.addAll(properties, propertyArray);\n+        return new SerializeExceptFilter(properties);\n+    }\n \n-\t/*\n+    /*\n     /**********************************************************\n     /* Sub-classes\n     /**********************************************************\n-\t */\n+     */\n \n-\t/**\n-\t * Filter implementation which defaults to filtering out unknown\n-\t * properties and only serializes ones explicitly listed.\n-\t */\n-\tpublic static class FilterExceptFilter\n-\textends SimpleBeanPropertyFilter\n-\t{\n-\t\t/**\n-\t\t * Set of property names to serialize.\n-\t\t */\n-\t\tprotected final Set<String> _propertiesToInclude;\n+    /**\n+     * Filter implementation which defaults to filtering out unknown\n+     * properties and only serializes ones explicitly listed.\n+     */\n+    public static class FilterExceptFilter\n+        extends SimpleBeanPropertyFilter\n+    {\n+        /**\n+         * Set of property names to serialize.\n+         */\n+        protected final Set<String> _propertiesToInclude;\n \n-\t\tpublic FilterExceptFilter(Set<String> properties) {\n-\t\t\t_propertiesToInclude = properties;\n-\t\t}\n+        public FilterExceptFilter(Set<String> properties) {\n+            _propertiesToInclude = properties;\n+        }\n \n-\t\tpublic void serializeAsField(Object bean, JsonGenerator jgen,\n-\t\t\t\tSerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-\t\t{\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\twriter.serializeAsField(bean, jgen, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n-\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-\t\t\t}\n-\t\t}\n-\t}\n+        public void serializeAsField(Object bean, JsonGenerator jgen,\n+                SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n+        {\n+            if (_propertiesToInclude.contains(writer.getName())) {\n+                writer.serializeAsField(bean, jgen, provider);\n+            }\n+        }\n \n-\t/**\n-\t * Filter implementation which defaults to serializing all\n-\t * properties, except for ones explicitly listed to be filtered out.\n-\t */\n-\tpublic static class SerializeExceptFilter\n-\textends SimpleBeanPropertyFilter\n-\t{\n-\t\t/**\n-\t\t * Set of property names to filter out.\n-\t\t */\n-\t\tprotected final Set<String> _propertiesToExclude;\n+        public void depositSchemaProperty(BeanPropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            if (_propertiesToInclude.contains(writer.getName())) {\n+                BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+            }\n+        }\n \n-\t\tpublic SerializeExceptFilter(Set<String> properties) {\n-\t\t\t_propertiesToExclude = properties;\n-\t\t}\n+        public void depositSchemaProperty(BeanPropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            if (_propertiesToInclude.contains(writer.getName())) {\n+                BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n+            }\n+        }\n+    }\n \n-\t\tpublic void serializeAsField(Object bean, JsonGenerator jgen,\n-\t\t\t\tSerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-\t\t{\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\twriter.serializeAsField(bean, jgen, provider);\n-\t\t\t}\n-\t\t}\n+    /**\n+     * Filter implementation which defaults to serializing all\n+     * properties, except for ones explicitly listed to be filtered out.\n+     */\n+    public static class SerializeExceptFilter\n+        extends SimpleBeanPropertyFilter\n+    {\n+        /**\n+         * Set of property names to filter out.\n+         */\n+        protected final Set<String> _propertiesToExclude;\n \n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n-\t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n-\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n-\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-\t\t\t}\n-\t\t}\n-\t}\n+        public SerializeExceptFilter(Set<String> properties) {\n+            _propertiesToExclude = properties;\n+        }\n \n+        public void serializeAsField(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n+        {\n+            if (!_propertiesToExclude.contains(writer.getName())) {\n+                writer.serializeAsField(bean, jgen, provider);\n+            }\n+        }\n+\n+        public void depositSchemaProperty(BeanPropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            if (!_propertiesToExclude.contains(writer.getName())) {\n+                BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+            }\n+        }\n+\n+        public void depositSchemaProperty(BeanPropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            if (!_propertiesToExclude.contains(writer.getName())) {\n+                BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n     /**\n      * Determines if a bean property is required, as determined by\n      * {@link com.fasterxml.jackson.databind.AnnotationIntrospector#hasRequiredMarker}.\n-     *<p>\n-     * \n      * \n      * @param prop the bean property.\n      * @return true if the property is optional, false otherwise.\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n     \t//deposit your output format \n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n      * \t\n      *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n      */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider)\n+    public static void depositSchemaProperty(BeanPropertyWriter writer,\n+            ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException\n     {\n         JavaType propType = writer.getSerializationType();\n \n         JsonNode schemaNode;\n         // Maybe it already has annotated/statically configured serializer?\n         JsonSerializer<Object> ser = writer.getSerializer();\n-\n-        try {\n-            if (ser == null) { // nope\n-                Class<?> serType = writer.getRawSerializationType();\n-                if (serType == null) {\n-                    serType = writer.getPropertyType();\n-                }\n-                ser = provider.findValueSerializer(serType, writer);\n-            }\n-            boolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n-            if (ser instanceof SchemaAware) {\n-                schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n-            } else {  \n-                schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            }\n-        } catch (JsonMappingException e) {\n+        if (ser == null) { // nope\n+            Class<?> serType = writer.getRawSerializationType();\n+            if (serType == null) {\n+                serType = writer.getPropertyType();\n+            }\n+            ser = provider.findValueSerializer(serType, writer);\n+        }\n+        boolean isOptional = !isPropertyRequired(writer, provider);\n+        if (ser instanceof SchemaAware) {\n+            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n+        } else {  \n             schemaNode = JsonSchema.getDefaultSchemaNode(); \n-            // TODO: handle in better way (why not throw?)\n         }\n         propertiesNode.put(writer.getName(), schemaNode);\n     }\n      * @param writer Bean property serializer to use to create schema value\n      * @param objectVisitor ObjectVisitor which cab receive the property\n      */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor) {\n+    public static void depositSchemaProperty(BeanPropertyWriter writer,\n+            JsonObjectFormatVisitor objectVisitor)\n+        throws JsonMappingException\n+    {\n         if (isPropertyRequired(writer, objectVisitor.getProvider())) {\n             objectVisitor.property(writer); \n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n         }\n         return o;\n     }\n-    \n-    @SuppressWarnings(\"unchecked\")\n+\n+    /* !!! 03-Oct-2012, tatu: This is total mess, and partly incorrect. MUST be\n+     *   rewritten in near future, to work.\n+     */\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n-        if (typeHint instanceof ParameterizedType) {\n-            Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n-            if (typeArgs.length == 2) {\n-                JavaType enumType = visitor.getProvider().constructType(typeArgs[0]);\n-                JavaType valueType = visitor.getProvider().constructType(typeArgs[1]);\n-//                ObjectNode propsNode = JsonNodeFactory.instance.objectNode();\n-                Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n-                for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n-                \tJsonSerializer<Object> ser;\n-                \tString name = visitor.getProvider().getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue);\n-                \ttry {\n-                \t\tser = visitor.getProvider().findValueSerializer(valueType.getRawClass(), _property);\n-                \t\tif (ser instanceof JsonFormatVisitable)  {\n-                \t\t\tobjectVisitor.property(name, (JsonFormatVisitable) ser, valueType);\n-                \t\t} \n-                \t\tcontinue;\n-                \t} catch (JsonMappingException e) {\n-                \t\t//TODO: log error\n-                \t}\n-                \tobjectVisitor.property(name);\n-                }\n-            }\n+    \t/*\n+        JavaType enumType = typeHint.containedType(0);\n+    \tif (enumType == null) {\n+    \t    enumType = visitor.getProvider().constructType(Object.class);\n+    \t}\n+    \t*/\n+        JavaType valueType = typeHint.containedType(1);\n+    \tif (valueType == null) {\n+    \t    valueType = visitor.getProvider().constructType(Object.class);\n+    \t}\n+        JsonSerializer<Object> ser = _valueSerializer;\n+//        Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n+        for (Map.Entry<?,SerializedString> entry : _keyEnums.internalMap().entrySet()) {\n+            String name = entry.getValue().getValue();\n+            // should all have the same type, so:\n+            if (ser == null) {\n+                ser = visitor.getProvider().findValueSerializer(entry.getKey().getClass(), _property);\n+            }\n+            objectVisitor.property(name, (JsonFormatVisitable) ser, valueType);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-    {\n-    \tif (_valueSerializer instanceof JsonFormatVisitable) {\n-    \t\t((JsonFormatVisitable) _valueSerializer).acceptJsonFormatVisitor(visitor, null); \n-    \t} else {\n-    \t\tvisitor.expectAnyFormat(typeHint);\n+        throws JsonMappingException\n+    {\n+        if (_valueSerializer != null) {\n+            _valueSerializer.acceptJsonFormatVisitor(visitor, null); \n+        } else {\n+            visitor.expectAnyFormat(typeHint);\n     \t}\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n     {\n-        if (_delegateSerializer instanceof JsonFormatVisitable) {\n-            ((JsonFormatVisitable) _delegateSerializer).acceptJsonFormatVisitor(visitor, typeHint);\n-            return;\n-        }\n-        super.acceptJsonFormatVisitor(visitor, typeHint);\n+        /* 03-Sep-2012, tatu: Not sure if this can be made to really work\n+         *    properly... but for now, try this:\n+         */\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n      * overriden by custom serializers.\n      */\n //  @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) { \n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+        throws JsonMappingException\n+    {\n     \tvisitor.expectAnyFormat(typeHint);\n     }\n             \n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n     public Collection<SerializedString> values() {\n         return _values.values();\n     }\n+\n+    /**\n+     * Method used for serialization and introspection by core Jackson\n+     * code.\n+     * \n+     * @since 2.1\n+     */\n+    public EnumMap<?,SerializedString> internalMap() {\n+        return _values;\n+    }\n+\n }", "timestamp": 1349326586, "metainfo": ""}