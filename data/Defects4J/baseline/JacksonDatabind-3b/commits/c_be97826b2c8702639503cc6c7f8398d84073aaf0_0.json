{"sha": "be97826b2c8702639503cc6c7f8398d84073aaf0", "log": "Completed (?) #124 implementation: now Converters seem to work ok", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Basic container for information gathered by {@link ClassIntrospector} to\n      * defined by defaults and possible annotations.\n      * Note that this may be further refined by per-property annotations.\n      * \n-     * @since 2.1s\n+     * @since 2.1\n      */\n     public abstract JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue);\n+\n+    /**\n+     * Method for finding {@link Converter} used for serializing instances\n+     * of this class.\n+     * \n+     * @since 2.1\n+     */\n+    public abstract Converter<Object,Object> findSerializationConverter();\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonSerialize.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonSerialize.java\n     /**\n      * Similar to {@link #converter}, but used for values of structures types\n      * (List, arrays, Maps).\n+     * Note that this property does NOT have effect when used as Class annotation;\n+     * it can only be used as property annotation: this because association between\n+     * container and value types is loose and as such converters seldom make sense\n+     * for such usage.\n      *\n      * @since 2.2\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Default {@link BeanDescription} implementation.\n     protected BasicBeanDescription(POJOPropertiesCollector coll)\n     {\n         this(coll.getConfig(), coll.getType(), coll.getClassDef(), coll.getProperties());\n-    \t_objectIdInfo = coll.getObjectIdInfo();\n+        _objectIdInfo = coll.getObjectIdInfo();\n     }\n \n     /**\n     \n     /*\n     /**********************************************************\n-    /* Introspection for serialization, factories\n+    /* Introspection for deserialization, factories\n     /**********************************************************\n      */\n \n     /**********************************************************\n      */\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Converter<Object,Object> findSerializationConverter()\n+    {\n+        if (_annotationIntrospector == null) {\n+            return null;\n+        }\n+        Object converterDef = _annotationIntrospector.findSerializationConverter(_classInfo);\n+        if (converterDef == null) {\n+            return null;\n+        }\n+        if (converterDef instanceof Converter<?,?>) {\n+            return (Converter<Object,Object>) converterDef;\n+        }\n+        if (!(converterDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Converter definition of type \"\n+                    +converterDef.getClass().getName()+\"; expected type Converter or Class<Converter> instead\");\n+        }\n+        Class<?> converterClass = (Class<?>)converterDef;\n+        // there are some known \"no class\" markers to consider too:\n+        if (converterClass == Converter.None.class || converterClass == NoClass.class) {\n+            return null;\n+        }\n+        if (!Converter.class.isAssignableFrom(converterClass)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                    +converterClass.getName()+\"; expected Class<Converter>\");\n+        }\n+        HandlerInstantiator hi = _config.getHandlerInstantiator();\n+        Converter<?,?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass);\n+        if (conv == null) {\n+            conv = (Converter<?,?>) ClassUtil.createInstance(converterClass,\n+                    _config.canOverrideAccessModifiers());\n+        }\n+        return (Converter<Object,Object>) conv;\n+    }\n+\n     /**\n      * Method for determining whether null properties should be written\n      * out for a Bean of introspected type. This is based on global\n         return result;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Introspection for deserialization\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public Class<?> findPOJOBuilder()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n      * that tells the class to use for serialization.\n      * Returns null if no such annotation found.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,\n             Annotated a)\n         throws JsonMappingException\n         }\n         JsonSerializer<Object> ser = prov.serializerInstance(a, serDef);\n         // One more thing however: may need to also apply a converter:\n-        Converter<Object,Object> conv = findConverterFromAnnotation(prov, a);\n-        if (conv != null) {\n-            TypeFactory tf = prov.getTypeFactory();\n-            JavaType converterType = tf.constructType(conv.getClass());\n-            JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n-            if (params == null || params.length != 2) {\n-                throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n-                        +converterType);\n-            }\n-            JavaType delegateType = params[1];\n-            return new StdDelegatingSerializer(conv, delegateType, ser);\n-        }\n-        return ser;\n-    }\n-\n-    protected Converter<Object,Object> findConverterFromAnnotation(SerializerProvider prov,\n+        return (JsonSerializer<Object>) findConvertingSerializer(prov, a, ser);\n+    }\n+\n+    /**\n+     * Helper method that will check whether given annotated entity (usually class,\n+     * but may also be a property accessor) indicates that a {@link Converter} is to\n+     * be used; and if so, to construct and return suitable serializer for it.\n+     * If not, will simply return given serializer as is.\n+     */\n+    protected JsonSerializer<?> findConvertingSerializer(SerializerProvider prov,\n+            Annotated a, JsonSerializer<?> ser)\n+        throws JsonMappingException\n+    {\n+        Converter<Object,Object> conv = findConverter(prov, a);\n+        if (conv == null) {\n+            return ser;\n+        }\n+        TypeFactory tf = prov.getTypeFactory();\n+        JavaType converterType = tf.constructType(conv.getClass());\n+        JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n+        if (params == null || params.length != 2) {\n+            throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                    +converterType);\n+        }\n+        JavaType delegateType = params[1];\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+\n+    protected Converter<Object,Object> findConverter(SerializerProvider prov,\n             Annotated a)\n         throws JsonMappingException\n     {\n         Object convDef = prov.getAnnotationIntrospector().findSerializationConverter(a);\n-        if (convDef != null) {\n-            return prov.converterInstance(a, convDef);\n-        }\n-        return null;\n+        if (convDef == null) {\n+            return null;\n+        }\n+        return prov.converterInstance(a, convDef);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;\n import com.fasterxml.jackson.databind.ser.std.MapSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Factory class that can provide serializers for any regular Java beans\n             return (JsonSerializer<Object>) ser;\n         }\n         boolean staticTyping;\n-        \n         // Next: we may have annotations that further define types to use...\n         JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n         if (type == origType) { // no changes, won't force static typing\n                 beanDesc = config.introspect(type);\n             }\n         }\n-\n+        // Slight detour: do we have a Converter to consider?\n+        Converter<Object,Object> conv = beanDesc.findSerializationConverter();\n+        if (conv == null) { // no, simple:\n+            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+        }\n+        // otherwise need to do bit of introspection\n+        TypeFactory tf = prov.getTypeFactory();\n+        JavaType converterType = tf.constructType(conv.getClass());\n+        JavaType[] params = tf.findTypeParameters(converterType, Converter.class);\n+        if (params == null || params.length != 2) {\n+            throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n+                    +converterType);\n+        }\n+        JavaType delegateType = params[1];\n+        return new StdDelegatingSerializer(conv, delegateType,\n+                _createSerializer2(prov, delegateType, beanDesc, true));\n+    }\n+\n+    protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n+        throws JsonMappingException\n+    {\n         // Then JsonSerializable, @JsonValue etc:\n-        ser = findSerializerByAnnotations(prov, type, beanDesc);\n+        JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);\n         if (ser != null) {\n-            return (JsonSerializer<Object>) ser;\n-        }\n+            return ser;\n+        }\n+        final SerializationConfig config = prov.getConfig();\n         \n         // Container types differ from non-container types\n         // (note: called method checks for module-provided serializers)\n-        if (origType.isContainerType()) {\n+        if (type.isContainerType()) {\n             if (!staticTyping) {\n                 staticTyping = usesStaticTyping(config, beanDesc, null);\n                 // [Issue#23]: Need to figure out how to force passed parameterization\n             ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n             // Will return right away, since called method does post-processing:\n             if (ser != null) {\n-                return (JsonSerializer<Object>) ser;\n+                return ser;\n             }\n         } else {\n             // Modules may provide serializers of POJO types:\n             }\n         }\n         \n-        /* Otherwise, we will check \"primary types\"; both marker types that\n-         * indicate specific handling (JsonSerializable), or main types that have\n-         * precedence over container types\n-         */\n+        // Otherwise, we will check \"primary types\"; both marker types that\n+        // indicate specific handling (JsonSerializable), or main types that have\n+        // precedence over container types\n         if (ser == null) {\n             ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n             if (ser == null) {\n                 ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n                 if (ser == null) {\n-                    /* And this is where this class comes in: if type is not a\n-                     * known \"primary JDK type\", perhaps it's a bean? We can still\n-                     * get a null, if we can't find a single suitable bean property.\n-                     */\n+                    // And this is where this class comes in: if type is not a\n+                    // known \"primary JDK type\", perhaps it's a bean? We can still\n+                    // get a null, if we can't find a single suitable bean property.\n                     ser = findBeanSerializer(prov, type, beanDesc);\n-                    /* Finally: maybe we can still deal with it as an\n-                     * implementation of some basic JDK interface?\n-                     */\n+                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                     if (ser == null) {\n                         ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                     }\n                 }\n             }\n         }\n-        return (JsonSerializer<Object>) ser;\n+        return ser;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n package com.fasterxml.jackson.databind.ser;\n \n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Intermediate base class for serializers used for serializing\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n         }\n         return gen.forScope(objectIdInfo.getScope());\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public Converter<Object,Object> converterInstance(Annotated annotated,\n             Object converterDef)\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingSerializer.java\n \n     public void testClassAnnotationForLists() throws Exception\n     {\n-        String json = objectWriter().writeValueAsString(new ConvertingBeanContainer(new ConvertingBean(3, 4)));\n-        assertEquals(\"{\\\"values\\\":[1,2]}\", json);\n+        String json = objectWriter().writeValueAsString(new ConvertingBeanContainer(\n+                new ConvertingBean(1, 2), new ConvertingBean(3, 4)));\n+        assertEquals(\"{\\\"values\\\":[[1,2],[3,4]]}\", json);\n     }\n \n     public void testPropertyAnnotationSimple() throws Exception", "timestamp": 1361255331, "metainfo": ""}