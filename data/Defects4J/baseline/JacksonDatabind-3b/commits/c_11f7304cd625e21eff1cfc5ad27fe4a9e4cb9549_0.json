{"sha": "11f7304cd625e21eff1cfc5ad27fe4a9e4cb9549", "log": "Implemented #343, DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * Note that this property does NOT affect other aspects of data-binding; that is,\n      * no detection is done with respect to POJO properties or {@link java.util.Map}\n      * keys. New features may be added to control additional cases.\n+     *<p>\n+     * Feature is disabled by default so that no exception is thrown.\n      * \n      * @since 2.3\n      */\n     FAIL_ON_READING_DUP_TREE_KEY(false),\n-    \n+\n+    /**\n+     * Feature that determines what happens when a property that has been explicitly\n+     * marked as ignorable is encountered in input: if feature is enabled,\n+     * {@link JsonMappingException} is thrown; if false, property is quietly skipped.\n+     *<p>\n+     * Feature is disabled by default so that no exception is thrown.\n+     *\n+     * @since 2.3\n+     */\n+    FAIL_ON_IGNORED_PROPERTIES(false),\n+\n     /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n                 }\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, bean, propName);\n-            }\n+            handleUnknownVanilla(jp, ctxt, bean, propName);\n         }\n         return bean;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Concrete deserialization methods\n                 }\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, propName, ctxt);\n-                }\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, bean, propName);         \n-            }\n+            handleUnknownVanilla(jp, ctxt, bean, propName);\n         }\n         return bean;\n     }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n                 }\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, bean, propName);\n-            }\n+            handleUnknownVanilla(jp, ctxt, bean, propName);\n         }\n         return bean;\n     }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.JsonToken;\n+\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.exc.IgnoredPropertyException;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ClassKey;\n     implements ContextualDeserializer, ResolvableDeserializer,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -2038793552422727904L;\n+    private static final long serialVersionUID = 2960120955735322578L;\n \n     protected final static PropertyName TEMP_PROPERTY_NAME = new PropertyName(\"#temporary-name\");\n \n     }\n     \n     /**\n-     * Method called when a JSON property is encountered that has not matching\n-     * setter, any-setter or field, and thus can not be assigned.\n-     */\n-    @Override\n-    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,\n-            Object beanOrClass, String propName)\n-        throws IOException, JsonProcessingException\n-    {\n-        /* 22-Aug-2010, tatu: Caller now mostly checks for ignorable properties, so\n-         *    following should not be necessary. However, \"handleUnknownProperties()\" seems\n-         *    to still possibly need it so it is left for now.\n-         */\n-        // If registered as ignorable, skip\n-        if (_ignoreAllUnknown ||\n-            (_ignorableProps != null && _ignorableProps.contains(propName))) {\n-            jp.skipChildren();\n-            return;\n-        }\n-        /* Otherwise use default handling (call handler(s); if not\n-         * handled, throw exception or skip depending on settings)\n-         */\n-        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);\n-    }\n-\n-    /**\n      * Method called to handle set of one or more unknown properties,\n      * stored in their entirety in given {@link TokenBuffer}\n      * (as field entries, name and value).\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n+    protected Object handleUnknownProperties(DeserializationContext ctxt,\n+            Object bean, TokenBuffer unknownTokens)\n         throws IOException, JsonProcessingException\n     {\n         // First: add closing END_OBJECT as marker\n         throws IOException, JsonProcessingException\n     {\n         if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-            jp.skipChildren();\n+            handleIgnoredProperty(jp, ctxt, bean, propName);\n         } else if (_anySetter != null) {\n             try {\n                // should we consider return type of any setter?\n         }\n     }\n \n+    /**\n+     * Method called when a JSON property is encountered that has not matching\n+     * setter, any-setter or field, and thus can not be assigned.\n+     */\n+    @Override\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt,\n+            Object beanOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_ignoreAllUnknown) {\n+            jp.skipChildren();\n+            return;\n+        }\n+        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+            handleIgnoredProperty(jp, ctxt, beanOrClass, propName);\n+        }\n+        // Otherwise use default handling (call handler(s); if not\n+        // handled, throw exception or skip depending on settings)\n+        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);\n+    }\n+\n+    /**\n+     * Method called when an explicitly ignored property (one specified with a\n+     * name to match, either by property annotation or class annotation) is encountered.\n+     * \n+     * @since 2.3\n+     */\n+    protected void handleIgnoredProperty(JsonParser jp, DeserializationContext ctxt,\n+            Object beanOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)) {\n+            throw IgnoredPropertyException.from(jp, beanOrClass, propName, getKnownPropertyNames());\n+        }\n+        jp.skipChildren();\n+    }\n+    \n     /**\n      * Method called in cases where we may have polymorphic deserialization\n      * case: that is, type of Creator-constructed bean is not the type\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n                 }\n                 continue;\n             }\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                // should we try to get return value of any setter too?\n-                _anySetter.deserializeAndSet(jp, ctxt, builder, propName);\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, builder, propName);\n-            }\n+            handleUnknownVanilla(jp, ctxt, handledType(), propName);\n         }\n         return builder;\n     }\n                 }\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, propName, ctxt);\n-                }\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, bean, propName);         \n-            }\n+            handleUnknownVanilla(jp, ctxt, bean, propName);\n         }\n         return bean;\n     }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n                 }\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n-            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n-            } else if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-                continue;\n-            } else {\n-                // Unknown: let's call handler method\n-                handleUnknownProperty(jp, ctxt, bean, propName);\n-            }\n+            handleUnknownVanilla(jp, ctxt, bean, propName);\n         }\n         return bean;\n     }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n                 buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                jp.skipChildren();\n+                handleIgnoredProperty(jp, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n     /**\n      * Deserializer we delegate operations that we can not handle.\n      */\n-    protected final BeanDeserializerBase _delegate;\n+    final protected BeanDeserializerBase _delegate;\n \n     /**\n      * Properties in order expected to be found in JSON array.\n      */\n-    protected final SettableBeanProperty[] _orderedProperties;\n-\n-    protected final AnnotatedMethod _buildMethod;\n+    final protected SettableBeanProperty[] _orderedProperties;\n+\n+    final protected AnnotatedMethod _buildMethod;\n         \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n import java.io.IOException;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n+        /* 06-Nov-2013, tatu: Looks like the only way to make polymorphic deser to work\n+         *   correctly is to add support here; problem being that handler is not available\n+         *   for nominal type of AtomicReference but only \"contained\" type...\n+         */\n+        if (_valueTypeDeserializer != null) {\n+            return new AtomicReference<Object>(_valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer));\n+        }\n         return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n     }\n-    \n+\n     @Override\n-    public AtomicReference<?> deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n+    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t == JsonToken.VALUE_NULL) {\n-            return getNullValue();\n-        }\n-        /* 03-Nov-2013, tatu: This gets rather tricky with \"natural\" types\n-         *   (String, Integer, Boolean), which do NOT include type information.\n-         *   These might actually be handled ok except that nominal type here\n-         *   is `Optional`, so special handling is not invoked; instead, need\n-         *   to do a work-around here.\n-         */\n-        if (t != null && t.isScalarValue()) {\n-            return deserialize(jp, ctxt);\n-        }\n-        Object refd = _valueTypeDeserializer.deserializeTypedFromAny(jp, ctxt);\n-        return new AtomicReference<Object>(refd);\n+        return (Object[]) typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/IgnoredPropertyException.java\n+package com.fasterxml.jackson.databind.exc;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+/**\n+ * Specialized {@link JsonMappingException} sub-class used to indicate\n+ * case where an explicitly ignored property is encountered, and mapper\n+ * is configured to consider this an error.\n+ * \n+ * @since 2.3\n+ */\n+public class IgnoredPropertyException\n+    extends PropertyBindingException\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public IgnoredPropertyException(String msg, JsonLocation loc,\n+            Class<?> referringClass, String propName,\n+            Collection<Object> propertyIds)\n+    {\n+        super(msg, loc, referringClass, propName, propertyIds);\n+    }\n+\n+    /**\n+     * Factory method used for constructing instances of this exception type.\n+     * \n+     * @param jp Underlying parser used for reading input being used for data-binding\n+     * @param fromObjectOrClass Reference to either instance of problematic type (\n+     *    if available), or if not, type itself\n+     * @param propertyName Name of unrecognized property\n+     * @param propertyIds (optional, null if not available) Set of properties that\n+     *    type would recognize, if completely known: null if set can not be determined.\n+     */\n+    public static IgnoredPropertyException from(JsonParser jp,\n+            Object fromObjectOrClass, String propertyName,\n+            Collection<Object> propertyIds)\n+    {\n+        if (fromObjectOrClass == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        Class<?> ref;\n+        if (fromObjectOrClass instanceof Class<?>) {\n+            ref = (Class<?>) fromObjectOrClass;\n+        } else {\n+            ref = fromObjectOrClass.getClass();\n+        }\n+        String msg = \"Ignored field \\\"\"+propertyName+\"\\\" (class \"+ref.getName()\n+                +\") encountered; mapper configured not to allow this\";\n+        IgnoredPropertyException e = new IgnoredPropertyException(msg,\n+                jp.getCurrentLocation(), ref, propertyName, propertyIds);\n+        // but let's also ensure path includes this last (missing) segment\n+        e.prependPath(fromObjectOrClass, propertyName);\n+        return e;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java\n+package com.fasterxml.jackson.databind.exc;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+/**\n+ * Base class for {@link JsonMappingException}s that are specifically related\n+ * to problems related to binding an individual property.\n+ * \n+ * @since 2.3\n+ */\n+@SuppressWarnings(\"serial\")\n+public abstract class PropertyBindingException\n+    extends JsonMappingException\n+{\n+    /**\n+     * Class that does not contain mapping for the unrecognized property.\n+     */\n+    protected final Class<?> _referringClass;\n+    \n+    /**\n+     *<p>\n+     * Note: redundant information since it is also included in the\n+     * reference path.\n+     */\n+    protected final String _propertyName;\n+    \n+    /**\n+     * Set of ids of properties that are known for the type, if this\n+     * can be statically determined.\n+     */\n+    protected final Collection<Object> _propertyIds;\n+\n+    /**\n+     * Lazily constructed description of known properties, used for\n+     * constructing actual message if and as needed.\n+     */\n+    protected transient String _propertiesAsString;\n+    \n+    protected PropertyBindingException(String msg, JsonLocation loc,\n+            Class<?> referringClass, String propName,\n+            Collection<Object> propertyIds)\n+    {\n+        \n+        super(msg, loc);\n+        _referringClass = referringClass;\n+        _propertyName = propName;\n+        _propertyIds = propertyIds;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overrides\n+    /**********************************************************\n+     */\n+\n+    private final static int MAX_DESC_LENGTH = 200;\n+    \n+    @Override\n+    public String getMessageSuffix()\n+    {\n+        String suffix = _propertiesAsString;\n+        if (suffix == null && _propertyIds != null) {\n+            StringBuilder sb = new StringBuilder(100);\n+            int len = _propertyIds.size();\n+            if (len == 1) {\n+                sb.append(\" (one known property: \\\"\");\n+                sb.append(String.valueOf(_propertyIds.iterator().next()));\n+                sb.append('\"');\n+            } else {\n+                sb.append(\" (\").append(len).append(\" known properties: \");\n+                Iterator<Object> it = _propertyIds.iterator();\n+                while (it.hasNext()) {\n+                    sb.append('\"');\n+                    sb.append(String.valueOf(it.next()));\n+                    sb.append('\"');\n+                    // one other thing: limit max length\n+                    if (sb.length() > MAX_DESC_LENGTH) {\n+                        sb.append(\" [truncated]\");\n+                        break;\n+                    }\n+                    if (it.hasNext()) {\n+                        sb.append(\", \");\n+                    }\n+                }\n+            }\n+            sb.append(\"])\");\n+            _propertiesAsString = suffix = sb.toString();\n+        }\n+        return suffix;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing type (class) that is missing definition to allow\n+     * binding of the unrecognized property.\n+     */\n+    public Class<?> getReferringClass() {\n+        return _referringClass;\n+    }\n+    \n+    /**\n+     * Convenience method for accessing logical property name that could\n+     * not be mapped. Note that it is the last path reference in the\n+     * underlying path.\n+     */\n+    public String getPropertyName() {\n+        return _propertyName;\n+    }    \n+    \n+    public Collection<Object> getKnownPropertyIds()\n+    {\n+        if (_propertyIds == null) {\n+            return null;\n+        }\n+        return Collections.unmodifiableCollection(_propertyIds);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n  * or field).\n  */\n public class UnrecognizedPropertyException\n-    extends JsonMappingException\n+    extends PropertyBindingException\n {\n     private static final long serialVersionUID = 1L;\n \n-    /**\n-     * Class that does not contain mapping for the unrecognized property.\n-     */\n-    protected final Class<?> _referringClass;\n-    \n-    /**\n-     *<p>\n-     * Note: redundant information since it is also included in the\n-     * reference path.\n-     */\n-    protected final String _unrecognizedPropertyName;\n-    \n-    /**\n-     * Set of ids of properties that are known for the type, if this\n-     * can be statically determined.\n-     */\n-    protected final Collection<Object> _propertyIds;\n-\n-    /**\n-     * Lazily constructed description of known properties, used for\n-     * constructing actual message if and as needed.\n-     */\n-    protected transient String _propertiesAsString;\n-    \n     public UnrecognizedPropertyException(String msg, JsonLocation loc,\n             Class<?> referringClass, String propName,\n             Collection<Object> propertyIds)\n     {\n-        \n-        super(msg, loc);\n-        _referringClass = referringClass;\n-        _unrecognizedPropertyName = propName;\n-        _propertyIds = propertyIds;\n+        super(msg, loc, referringClass, propName, propertyIds);\n     }\n \n     /**\n         return e;\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Overrides\n-    /**********************************************************\n+    /**\n+     * @deprecated Since 2.3, use {@link #getPropertyName} instead.\n      */\n-\n-    private final static int MAX_DESC_LENGTH = 200;\n-    \n-    @Override\n-    public String getMessageSuffix()\n-    {\n-        String suffix = _propertiesAsString;\n-        if (suffix == null && _propertyIds != null) {\n-            StringBuilder sb = new StringBuilder(100);\n-            int len = _propertyIds.size();\n-            if (len == 1) {\n-                sb.append(\" (one known property: \\\"\");\n-                sb.append(String.valueOf(_propertyIds.iterator().next()));\n-                sb.append('\"');\n-            } else {\n-                sb.append(\" (\").append(len).append(\" known properties: \");\n-                Iterator<Object> it = _propertyIds.iterator();\n-                while (it.hasNext()) {\n-                    sb.append('\"');\n-                    sb.append(String.valueOf(it.next()));\n-                    sb.append('\"');\n-                    // one other thing: limit max length\n-                    if (sb.length() > MAX_DESC_LENGTH) {\n-                        sb.append(\" [truncated]\");\n-                        break;\n-                    }\n-                    if (it.hasNext()) {\n-                        sb.append(\", \");\n-                    }\n-                }\n-            }\n-            sb.append(\"])\");\n-            _propertiesAsString = suffix = sb.toString();\n-        }\n-        return suffix;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Extended API\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Method for accessing type (class) that is missing definition to allow\n-     * binding of the unrecognized property.\n-     */\n-    public Class<?> getReferringClass() {\n-        return _referringClass;\n-    }\n-    \n-    /**\n-     * Convenience method for accessing logical property name that could\n-     * not be mapped. Note that it is the last path reference in the\n-     * underlying path.\n-     */\n+    @Deprecated // since 2.3\n     public String getUnrecognizedPropertyName() {\n-        return _unrecognizedPropertyName;\n+        return getPropertyName();\n     }    \n-    \n-    public Collection<Object> getKnownPropertyIds()\n-    {\n-        if (_propertyIds == null) {\n-            return null;\n-        }\n-        return Collections.unmodifiableCollection(_propertyIds);\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n         return _idFrom(value, type);\n     }\n \n+    @Deprecated // since 2.3\n     @Override\n     public JavaType typeFromId(String id) {\n         return _typeFromId(id, _typeFactory);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n      */\n     @Override\n     public ValueNode numberNode(Long value) {\n+        if (value == null) {\n+            return nullNode();\n+        }\n         long l = value.longValue();\n-        if (_inIntRange(l)) {\n-            return IntNode.valueOf((int) l);\n-        }\n-        return (value == null) ? nullNode() : LongNode.valueOf(l);\n+        return _inIntRange(l)\n+                ? IntNode.valueOf((int) l) : LongNode.valueOf(l);\n     }\n     \n     /**\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestAnnotationIgnore.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnnotationIgnore.java\n public class TestAnnotationIgnore\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /// Class for testing {@link JsonIgnore} annotations with setters\n+    // Class for testing {@link JsonIgnore} annotations with setters\n     final static class SizeClassIgnore\n     {\n         int _x = 0;\n         }\n     }\n \n+    @JsonIgnoreProperties({ \"z\" })\n+    final static class NoYOrZ\n+    {\n+        public int x;\n+\n+        @JsonIgnore\n+        public int y = 1;\n+    }\n+    \n     /*\n     /**********************************************************\n-    /* Unit tests\n+    /* Test methods\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     public void testSimpleIgnore() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SizeClassIgnore result = m.readValue\n+        SizeClassIgnore result = MAPPER.readValue\n             (\"{ \\\"x\\\":1, \\\"y\\\" : 2 }\",\n              SizeClassIgnore.class);\n         // x should be set, y not\n         assertEquals(0, result._y);\n     }\n \n+    public void testFailOnIgnore() throws Exception\n+    {\n+        ObjectReader r = MAPPER.reader(NoYOrZ.class);\n+        \n+        // First, fine to get \"x\":\n+        NoYOrZ result = r.readValue(aposToQuotes(\"{'x':3}\"));\n+        assertEquals(3, result.x);\n+        assertEquals(1, result.y);\n+\n+        // but not 'y'\n+        r = r.with(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);\n+        try {\n+            result = r.readValue(aposToQuotes(\"{'x':3, 'y':4}\"));\n+            fail(\"Should fail\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Ignored field\");\n+        }\n+\n+        // or 'z'\n+        try {\n+            result = r.readValue(aposToQuotes(\"{'z':2 }\"));\n+            fail(\"Should fail\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Ignored field\");\n+        }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n         if (exc == null) {\n             fail(\"Should have failed binding\");\n         }\n-        assertEquals(\"bar\", exc.getUnrecognizedPropertyName());\n+        assertEquals(\"bar\", exc.getPropertyName());\n         assertEquals(Bean.class, exc.getReferringClass());\n         // also: should get list of known properties\n         verifyException(exc, \"propX\");\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleAtomicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleAtomicTypes.java\n {\n     private final ObjectMapper MAPPER = objectMapper();\n \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n+    @JsonSubTypes({ @JsonSubTypes.Type(Impl.class) })\n+    static abstract class Base { }\n+\n+    @JsonTypeName(\"I\")\n+    static class Impl extends Base {\n+        public int value;\n+\n+        public Impl() { }\n+        public Impl(int v) { value = v; }\n+    }\n+\n+    static class RefWrapper\n+    {\n+        public AtomicReference<Base> w;\n+\n+        public RefWrapper() { }\n+        public RefWrapper(Base b) {\n+            w = new AtomicReference<Base>(b);\n+        }\n+        public RefWrapper(int i) {\n+            w = new AtomicReference<Base>(new Impl(i));\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(1, longs[0]);\n         assertEquals(2, longs[1]);\n     }\n+\n+    // [Issue#340]\n+    public void testPolymorphicAtomicReference() throws Exception\n+    {\n+        RefWrapper input = new RefWrapper(13);\n+        String json = MAPPER.writeValueAsString(input);\n+        \n+        RefWrapper result = MAPPER.readValue(json, RefWrapper.class);\n+        assertNotNull(result.w);\n+        Object ob = result.w.get();\n+        assertEquals(Impl.class, ob.getClass());\n+        assertEquals(13, ((Impl) ob).value);\n+    }\n }", "timestamp": 1383891955, "metainfo": ""}