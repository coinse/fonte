{"sha": "6a5bd873db44b283f016d6dfb3426ada8b0e7d14", "log": "Rewrite delegating serializer, after realizing initial API was not good", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Serializer implementation where given Java type is first converted\n- * (by implemenetation sub-class provides) into an intermediate\n- * \"delegate type\", and then serialized by Jackson.\n+ * to an intermediate \"delegate type\" (using a configured\n+ * {@link Converter}, and then this delegate value is serialized by Jackson.\n+ *<p>\n  * Note that although types may be related, they must not be same; trying\n  * to do this will result in an exception.\n- *\n- * @param <T> Java type being serialized and that is first converted into\n- *   delegate type <code>DT</code>\n- * @param <DT> Delegate type, intermediate into which sub-class converts\n- *   Java type <code>T</code>, and that Jackson serializes using standard\n- *   serializer of that type\n  * \n  * @since 2.1\n  */\n-public abstract class StdDelegatingSerializer<T,DT>\n-    extends StdSerializer<T>\n+public class StdDelegatingSerializer\n+    extends StdSerializer<Object>\n     implements ContextualSerializer,\n         JsonFormatVisitable, SchemaAware\n {\n+    protected final Converter<Object,?> _converter;\n+    \n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n     /**********************************************************\n      */\n \n-    public StdDelegatingSerializer() {\n+    @SuppressWarnings(\"unchecked\")\n+    public StdDelegatingSerializer(Converter<?,?> converter)\n+    {\n         super(Object.class, false);\n+        _converter = (Converter<Object,?>)converter;\n         _delegateType = null;\n         _delegateSerializer = null;\n     }\n \n-    public StdDelegatingSerializer(Class<T> cls) {\n-        super(cls);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter)\n+    {\n+        super(cls, false);\n+        _converter = (Converter<Object,?>)converter;\n         _delegateType = null;\n         _delegateSerializer = null;\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n-    protected StdDelegatingSerializer(JavaType delegateType,\n-            JsonSerializer<?> delegateSerializer)\n+    protected StdDelegatingSerializer(Converter<Object,?> converter,\n+            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n     {\n         super(delegateType);\n+        _converter = converter;\n         _delegateType = delegateType;\n         _delegateSerializer = (JsonSerializer<Object>) delegateSerializer;\n     }\n \n     /**\n-     * Method that sub-classes have to implement for creating the actual\n-     * serializer instance, once all delegating information has been\n-     * collected: typically simply calls a constructor.\n+     * Method used for creating resolved contextual instances. Must be\n+     * overridden when sub-classing.\n      */\n-    protected abstract JsonSerializer<?> withDelegate(JavaType delegateType,\n-            JsonSerializer<?> delegateSerializer);\n+    protected JsonSerializer<?> withDelegate(Converter<Object,?> converter,\n+            JavaType delegateType, JsonSerializer<?> delegateSerializer)\n+    {\n+        if (getClass() != StdDelegatingSerializer.class) {\n+            throw new IllegalStateException(\"Sub-class \"+getClass().getName()+\" must override 'withDelegate'\");\n+        }\n+        return new StdDelegatingSerializer(converter, delegateType, delegateSerializer);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Contextualization\n+    /**********************************************************\n+     */\n     \n     // @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n     {\n         // First: figure out what is the fully generic delegate type:\n         TypeFactory tf = provider.getTypeFactory();\n-        JavaType implType = tf.constructType(getClass());\n-        JavaType[] params = tf.findTypeParameters(implType, StdDelegatingSerializer.class);\n+        JavaType implType = tf.constructType(_converter.getClass());\n+        JavaType[] params = tf.findTypeParameters(implType, Converter.class);\n         if (params == null || params.length != 2) {\n-            throw new JsonMappingException(\"Could not determine StdDelegatingSerializer parameterization for \"\n+            throw new JsonMappingException(\"Could not determine Converter parameterization for \"\n                     +implType);\n         }\n         // and then we can find serializer to delegate to, construct a new instance:\n         JavaType delegateType = params[1];\n-        return withDelegate(delegateType, provider.findValueSerializer(delegateType, property));\n+        return withDelegate(_converter, delegateType,\n+                provider.findValueSerializer(delegateType, property));\n     }\n \n     /*\n     /**********************************************************\n      */\n \n-    /**\n-     * Method for sub-class to implement, used for converting given\n-     * value into delegate value, which is then serialized by standard\n-     * Jackson serializer.\n-     * \n-     * @param value Property value tyo serializer\n-     * @param provider Contextual provider to use\n-     * \n-     * @return Delegate value to serialize\n-     */\n-    public abstract DT convert(T value, SerializerProvider provider) \n-        throws JsonMappingException;\n-\n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n-        DT delegateValue = convert(value, provider);\n+        Object delegateValue = _converter.convert(value);\n+        // should we accept nulls?\n+        if (delegateValue == null) {\n+            provider.defaultSerializeNull(jgen);\n+            return;\n+        }\n         _delegateSerializer.serialize(delegateValue, jgen, provider);\n     }\n \n     @Override\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException\n     {\n-        DT delegateValue = convert(value, provider);\n+        Object delegateValue = _converter.convert(value);\n         _delegateSerializer.serializeWithType(delegateValue, jgen, provider, typeSer);\n     }\n     \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Converter.java\n+package com.fasterxml.jackson.databind.util;\n+\n+/**\n+ * Helper interface for things that convert Objects of\n+ * one type to another.\n+ *\n+ * @param <IN>\n+ * @param <OUT>\n+ * \n+ * @seealso {@link com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer}\n+ * \n+ * @since 2.1\n+ */\n+public interface Converter<IN,OUT>\n+{\n+    /**\n+     * Main conversion methods\n+     */\n+    public OUT convert(IN value);\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n  * Test for verifying [JACKSON-238]\n         protected int y() { return 7; }\n     }\n \n-    public static class ImmutableSerializer\n-        extends StdDelegatingSerializer<Immutable, Map<String,Integer>>\n+    public static class ImmutableConverter\n+        implements Converter<Immutable, Map<String,Integer>>\n     {\n-        public ImmutableSerializer() { super(Immutable.class); }\n-        protected ImmutableSerializer(JavaType delegateType, JsonSerializer<?> delegateSerializer) {\n-            super(delegateType, delegateSerializer);\n-        }\n-\n         @Override\n-        protected JsonSerializer<?> withDelegate(JavaType delegateType, JsonSerializer<?> delegateSerializer) {\n-            return new ImmutableSerializer(delegateType, delegateSerializer);\n-        }\n-\n-        @Override\n-        public Map<String, Integer> convert(Immutable value, SerializerProvider provider)\n-                throws JsonMappingException {\n+        public Map<String, Integer> convert(Immutable value)\n+        {\n             HashMap<String,Integer> map = new LinkedHashMap<String,Integer>();\n             map.put(\"x\", value.x());\n             map.put(\"y\", value.y());\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n-        module.addSerializer(Immutable.class, new ImmutableSerializer());\n+        module.addSerializer(new StdDelegatingSerializer(Immutable.class,\n+                new ImmutableConverter()));\n         mapper.registerModule(module);\n         assertEquals(\"{\\\"x\\\":3,\\\"y\\\":7}\", mapper.writeValueAsString(new Immutable()));\n     }", "timestamp": 1349056436, "metainfo": ""}