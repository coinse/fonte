{"sha": "8d9e6338249d7866be55e057cc5085d1ff8abbd0", "log": "Trying to simplify handling of String collections", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n      * \n      * @since 2.1\n      */\n-    protected final String _parseString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        // Issue#381\n-        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+    protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_STRING) {\n+            return jp.getText();\n+        }\n+        \n+        // Issue#381\n+        if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final String parsed = _parseString(jp, ctxt);\n             if (jp.nextToken() != JsonToken.END_ARRAY) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n \n     @Override\n     public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,\n-                                          Collection<String> result)\n+            Collection<String> result)\n         throws IOException\n     {\n         // Ok: must point to START_ARRAY\n         JsonToken t;\n \n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-            result.add((t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt));\n+            String value;\n+            if (t == JsonToken.VALUE_STRING) {\n+                value = jp.getText();\n+            } else if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else {\n+                value = _parseString(jp, ctxt);\n+            }\n+            result.add(value);\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n     @Override\n     public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n+        JsonToken curr = jp.getCurrentToken();\n+        if (curr == JsonToken.VALUE_STRING) {\n+            return jp.getText();\n+        }\n+\n         // Issue#381\n-        if (jp.getCurrentToken() == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+        if (curr == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final String parsed = _parseString(jp, ctxt);\n             if (jp.nextToken() != JsonToken.END_ARRAY) {\n             }            \n             return parsed;            \n         }\n-        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n-        String text = jp.getValueAsString();\n-        if (text != null) {\n-            return text;\n-        }\n         // [JACKSON-330]: need to gracefully handle byte[] data, as base64\n-        JsonToken curr = jp.getCurrentToken();\n         if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n             Object ob = jp.getEmbeddedObject();\n             if (ob == null) {\n             // otherwise, try conversion using toString()...\n             return ob.toString();\n         }\n+        // allow coercions for other scalar types\n+        String text = jp.getValueAsString();\n+        if (text != null) {\n+            return text;\n+        }\n         throw ctxt.mappingException(_valueClass, curr);\n     }\n ", "timestamp": 1399755695, "metainfo": ""}