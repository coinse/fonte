{"sha": "0aef72dd7e0d05c6583e24bf079297441e700a9d", "log": "Minor improvements to handling of boolean values (allow long values)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * {@link TypeFactory}.\n      */\n     @Override\n+    @SuppressWarnings(\"unchecked\")\n     public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return readValue(jp, (JavaType) valueType);\n+        return (T) _readValue(copyDeserializationConfig(), jp, (JavaType) valueType);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n      * was specified with {@link #withValueToUpdate(Object)}.\n      */\n     @Override\n+    @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp, ResolvedType valueType) throws IOException, JsonProcessingException {\n-        return readValue(jp, (JavaType) valueType);\n+        return (T) withType((JavaType)valueType).readValue(jp);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonParser.NumberType;\n import com.fasterxml.jackson.core.io.NumberInput;\n \n import com.fasterxml.jackson.databind.*;\n         }\n         // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return (jp.getIntValue() != 0);\n+            // 11-Jan-2012, tatus: May be outside of int...\n+            if (jp.getNumberType() == NumberType.INT) {\n+                return (jp.getIntValue() != 0);\n+            }\n+            return _parseBooleanFromNumber(jp, ctxt);\n         }\n         // And finally, let's allow Strings to be converted too\n         if (t == JsonToken.VALUE_STRING) {\n         }\n         // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; \n+            // 11-Jan-2012, tatus: May be outside of int...\n+            if (jp.getNumberType() == NumberType.INT) {\n+                return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE;\n+            }\n+            return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt));\n         }\n         if (t == JsonToken.VALUE_NULL) {\n             return (Boolean) getNullValue();\n         }\n         // Otherwise, no can do:\n         throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        if (jp.getNumberType() == NumberType.LONG) {\n+            return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE;\n+        }\n+        // no really good logic; let's actually resort to textual comparison\n+        String str = jp.getText();\n+        if (\"0.0\".equals(str) || \"0\".equals(str)) {\n+            return Boolean.FALSE;\n+        }\n+        return Boolean.TRUE;\n     }\n \n     protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt)\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n import java.util.Locale;\n import java.util.regex.Pattern;\n \n+import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n \n-public class TestJdkTypes\n-    extends com.fasterxml.jackson.databind.BaseMapTest\n+public class TestJdkTypes extends BaseMapTest\n {\n     static class PrimitivesBean\n     {\n              this.name = name;\n              clazz = String.class;\n          }\n-    }    \n-\n+    }\n+\n+    static class BooleanBean {\n+        public Boolean wrapper;\n+        public boolean primitive;\n+        \n+        protected Boolean ctor;\n+        \n+        @JsonCreator\n+        public BooleanBean(@JsonProperty(\"ctor\") Boolean foo) {\n+            ctor = foo;\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n- \n-    private final ObjectMapper MAPPER = new ObjectMapper();\n-    \n+    \n+    private final ObjectMapper mapper = new ObjectMapper();\n+\n     /**\n      * Related to issue [JACKSON-155].\n      */\n     {\n         // Not portable etc... has to do:\n         File src = new File(\"/test\").getAbsoluteFile();\n-        File result = MAPPER.readValue(\"\\\"\"+src.getAbsolutePath()+\"\\\"\", File.class);\n+        File result = mapper.readValue(\"\\\"\"+src.getAbsolutePath()+\"\\\"\", File.class);\n         assertEquals(src.getAbsolutePath(), result.getAbsolutePath());\n     }\n \n         /* Ok: easiest way is to just serialize first; problem\n          * is the backslash\n          */\n-        String json = MAPPER.writeValueAsString(exp);\n-        Pattern result = MAPPER.readValue(json, Pattern.class);\n+        String json = mapper.writeValueAsString(exp);\n+        Pattern result = mapper.readValue(json, Pattern.class);\n         assertEquals(exp.pattern(), result.pattern());\n     }\n \n     public void testCurrency() throws IOException\n     {\n         Currency usd = Currency.getInstance(\"USD\");\n-        assertEquals(usd, MAPPER.readValue(quote(\"USD\"), Currency.class));\n+        assertEquals(usd, new ObjectMapper().readValue(quote(\"USD\"), Currency.class));\n     }\n \n     /**\n      * Test for [JACKSON-419]\n+     * \n+     * @since 1.7\n      */\n     public void testLocale() throws IOException\n     {\n-        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n-        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n-        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n+        assertEquals(new Locale(\"en\"), mapper.readValue(quote(\"en\"), Locale.class));\n+        assertEquals(new Locale(\"es\", \"ES\"), mapper.readValue(quote(\"es_ES\"), Locale.class));\n+        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), mapper.readValue(quote(\"fi_FI_savo\"), Locale.class));\n     }\n \n     /**\n      * Test for [JACKSON-420] (add DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES)\n+     * \n+     * @since 1.7\n      */\n     public void testNullForPrimitives() throws IOException\n     {\n         // by default, ok to rely on defaults\n-        PrimitivesBean bean = MAPPER.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n+        PrimitivesBean bean = mapper.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals(0, bean.intValue);\n         assertEquals(false, bean.booleanValue);\n         assertEquals(0.0, bean.doubleValue);\n \n-        bean = MAPPER.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals((byte) 0, bean.byteValue);\n         assertEquals(0.0f, bean.floatValue);\n         \n         // but not when enabled\n-        ObjectMapper  mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n+        final ObjectMapper mapper2 = new ObjectMapper();\n+        mapper2.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n \n         // boolean\n         try {\n-            mapper.readValue(\"{\\\"booleanValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"booleanValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for boolean + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type boolean\");\n         }\n         // byte/char/short/int/long\n         try {\n-            mapper.readValue(\"{\\\"byteValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"byteValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for byte + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type byte\");\n         }\n         try {\n-            mapper.readValue(\"{\\\"charValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"charValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for char + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type char\");\n         }\n         try {\n-            mapper.readValue(\"{\\\"shortValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"shortValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for short + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type short\");\n         }\n         try {\n-            mapper.readValue(\"{\\\"intValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"intValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for int + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type int\");\n         }\n         try {\n-            mapper.readValue(\"{\\\"longValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"longValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for long + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type long\");\n \n         // float/double\n         try {\n-            mapper.readValue(\"{\\\"floatValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"floatValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for float + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type float\");\n         }\n         try {\n-            mapper.readValue(\"{\\\"doubleValue\\\":null}\", PrimitivesBean.class);\n+            mapper2.readValue(\"{\\\"doubleValue\\\":null}\", PrimitivesBean.class);\n             fail(\"Expected failure for double + null\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Can not map JSON null into type double\");\n      */\n     public void testCharSequence() throws IOException\n     {\n-        CharSequence cs = MAPPER.readValue(\"\\\"abc\\\"\", CharSequence.class);\n+        CharSequence cs = mapper.readValue(\"\\\"abc\\\"\", CharSequence.class);\n         assertEquals(String.class, cs.getClass());\n         assertEquals(\"abc\", cs.toString());\n     }\n     // [JACKSON-484]\n     public void testInetAddress() throws IOException\n     {\n-        InetAddress address = MAPPER.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n+        InetAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n         assertEquals(\"127.0.0.1\", address.getHostAddress());\n \n         // should we try resolving host names? That requires connectivity... \n         final String HOST = \"www.ning.com\";\n-        address = MAPPER.readValue(quote(HOST), InetAddress.class);\n+        address = mapper.readValue(quote(HOST), InetAddress.class);\n         assertEquals(HOST, address.getHostName());\n     }\n \n     // [JACKSON-597]\n     public void testClass() throws IOException\n     {\n-        assertSame(String.class, MAPPER.readValue(quote(\"java.lang.String\"), Class.class));\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertSame(String.class, mapper.readValue(quote(\"java.lang.String\"), Class.class));\n \n         // then primitive types\n-        assertSame(Boolean.TYPE, MAPPER.readValue(quote(\"boolean\"), Class.class));\n-        assertSame(Byte.TYPE, MAPPER.readValue(quote(\"byte\"), Class.class));\n-        assertSame(Short.TYPE, MAPPER.readValue(quote(\"short\"), Class.class));\n-        assertSame(Character.TYPE, MAPPER.readValue(quote(\"char\"), Class.class));\n-        assertSame(Integer.TYPE, MAPPER.readValue(quote(\"int\"), Class.class));\n-        assertSame(Long.TYPE, MAPPER.readValue(quote(\"long\"), Class.class));\n-        assertSame(Float.TYPE, MAPPER.readValue(quote(\"float\"), Class.class));\n-        assertSame(Double.TYPE, MAPPER.readValue(quote(\"double\"), Class.class));\n-        assertSame(Void.TYPE, MAPPER.readValue(quote(\"void\"), Class.class));\n+        assertSame(Boolean.TYPE, mapper.readValue(quote(\"boolean\"), Class.class));\n+        assertSame(Byte.TYPE, mapper.readValue(quote(\"byte\"), Class.class));\n+        assertSame(Short.TYPE, mapper.readValue(quote(\"short\"), Class.class));\n+        assertSame(Character.TYPE, mapper.readValue(quote(\"char\"), Class.class));\n+        assertSame(Integer.TYPE, mapper.readValue(quote(\"int\"), Class.class));\n+        assertSame(Long.TYPE, mapper.readValue(quote(\"long\"), Class.class));\n+        assertSame(Float.TYPE, mapper.readValue(quote(\"float\"), Class.class));\n+        assertSame(Double.TYPE, mapper.readValue(quote(\"double\"), Class.class));\n+        assertSame(Void.TYPE, mapper.readValue(quote(\"void\"), Class.class));\n     }\n \n     // [JACKSON-605]\n     public void testClassWithParams() throws IOException\n     {\n-        String json = MAPPER.writeValueAsString(new ParamClassBean(\"Foobar\"));\n-\n-        ParamClassBean result = MAPPER.readValue(json, ParamClassBean.class);\n+        String json = mapper.writeValueAsString(new ParamClassBean(\"Foobar\"));\n+\n+        ParamClassBean result = mapper.readValue(json, ParamClassBean.class);\n         assertEquals(\"Foobar\", result.name);\n         assertSame(String.class, result.clazz);\n     }\n         WrappersBean bean;\n \n         // by default, ok to rely on defaults\n-        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.booleanValue);\n-        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.byteValue);\n \n         // char/Character is different... not sure if this should work or not:\n-        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.charValue);\n \n-        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.shortValue);\n-        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.intValue);\n-        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.longValue);\n-        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.floatValue);\n-        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.doubleValue);\n     }\n \n     // for [JACKSON-616]\n+    // @since 1.9\n     public void testEmptyStringForPrimitives() throws IOException\n     {\n         PrimitivesBean bean;\n-        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertFalse(bean.booleanValue);\n-        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((byte) 0, bean.byteValue);\n-        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((char) 0, bean.charValue);\n-        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((short) 0, bean.shortValue);\n-        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0, bean.intValue);\n-        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0L, bean.longValue);\n-        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0f, bean.floatValue);\n-        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0, bean.doubleValue);\n     }\n \n     // for [JACKSON-652]\n+    // @since 1.9\n     public void testUntypedWithJsonArrays() throws Exception\n     {\n         // by default we get:\n-        Object ob = MAPPER.readValue(\"[1]\", Object.class);\n+        Object ob = mapper.readValue(\"[1]\", Object.class);\n         assertTrue(ob instanceof List<?>);\n \n         // but can change to produce Object[]:\n-        MAPPER.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n-        ob = MAPPER.readValue(\"[1]\", Object.class);\n+        mapper.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        ob = mapper.readValue(\"[1]\", Object.class);\n         assertEquals(Object[].class, ob.getClass());\n     }\n+\n+    // Test for verifying that Long values are coerced to boolean correctly as well\n+    public void testLongToBoolean() throws Exception\n+    {\n+        long value = 1L + Integer.MAX_VALUE;\n+        BooleanBean b = mapper.readValue(\"{\\\"primitive\\\" : \"+value+\", \\\"wrapper\\\":\"+value+\", \\\"ctor\\\":\"+value+\"}\",\n+                    BooleanBean.class);\n+        assertEquals(Boolean.TRUE, b.wrapper);\n+        assertTrue(b.primitive);\n+        assertEquals(Boolean.TRUE, b.ctor);\n+    }\n }", "timestamp": 1326325378, "metainfo": ""}