{"sha": "b009194c5f68fa4d773723113beeed3ae9308b9d", "log": "Full fix for #318", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n /**\n  * Abstract factory base class that can provide deserializers for standard\n  * JDK classes, including collection classes and simple heuristics for\n- * \"upcasting\" commmon collection interface types\n+ * \"upcasting\" common collection interface types\n  * (such as {@link java.util.Collection}).\n  *<p>\n  * Since all simple deserializers are eagerly instantiated, and there is\n      */\n     protected final static PropertyName UNWRAPPED_CREATOR_PARAM_NAME = new PropertyName(\"@JsonUnwrapped\");\n     \n-    /**\n-     * Also special array deserializers for primitive array types.\n-     */\n-//    final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers = PrimitiveArrayDeserializers.getAll();\n-    \n     /* We do some defaulting for abstract Map classes and\n      * interfaces, to avoid having to use exact types or annotations in\n      * cases where the most common concrete Maps will do.\n             if (!isCreator && !isVisible) {\n                 continue;\n             }\n+\n             // [JACKSON-541] improved handling a bit so:\n             // 2 or more args; all params must have name annotations\n             // ... or @JacksonInject (or equivalent)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n         // At which point we still have all kinds of properties; not all with mutators:\n         for (BeanPropertyDefinition propDef : propDefs) {\n             SettableBeanProperty prop = null;\n-            if (propDef.hasConstructorParameter()) {\n-                /* [JACKSON-700] If property is passed via constructor parameter, we must\n-                 *   handle things in special way. Not sure what is the most optimal way...\n-                 *   for now, let's just call a (new) method in builder, which does nothing.\n-                 */\n-                // but let's call a method just to allow custom builders to be aware...\n-                final String name = propDef.getName();\n-                if (creatorProps != null) {\n-                    for (SettableBeanProperty cp : creatorProps) {\n-                        if (name.equals(cp.getName())) {\n-                            prop = cp;\n-                            break;\n-                        }\n-                    }\n-                }\n-                if (prop == null) {\n-                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n-                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n-                }\n-                builder.addCreatorProperty(prop);\n-                continue;\n-            }\n+            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n+             *   we need to do linkage (as per [Issue#318]), and so need to start with\n+             *   other types, and only then create constructor parameter, if any.\n+             */\n             if (propDef.hasSetter()) {\n                 Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                 prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n                     prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                 }\n             }\n+            if (propDef.hasConstructorParameter()) {\n+                /* [JACKSON-700] If property is passed via constructor parameter, we must\n+                 *   handle things in special way. Not sure what is the most optimal way...\n+                 *   for now, let's just call a (new) method in builder, which does nothing.\n+                 */\n+                // but let's call a method just to allow custom builders to be aware...\n+                final String name = propDef.getName();\n+                CreatorProperty cprop = null;\n+                if (creatorProps != null) {\n+                    for (SettableBeanProperty cp : creatorProps) {\n+                        if (name.equals(cp.getName())) {\n+                            cprop = (CreatorProperty) cp;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (cprop == null) {\n+                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n+                              +name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n+                }\n+                if (prop != null) {\n+                    cprop = cprop.withFallbackSetter(prop);\n+                }\n+                prop = cprop;\n+                builder.addCreatorProperty(cprop);\n+                continue;\n+            }\n+            \n             if (prop != null) {\n                 Class<?>[] views = propDef.findViews();\n                 if (views == null) {\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n-        AnnotatedMember mutator = propDef.getMutator();\n+        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n         if (ctxt.canOverrideAccessModifiers()) {\n             mutator.fixAccess();\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n  * should never be called -- instead, value must separately passed.\n  *<p>\n  * Note on injectable values: unlike with other mutators, where\n- * deserializer and injecting are separate, here we deal the two as related\n+ * deserializer and injecting are separate, here we treat the two as related\n  * things. This is necessary to add proper priority, as well as to simplify\n  * coordination.\n  */\n      * @since 2.1\n      */\n     protected final int _creatorIndex;\n+\n+    /**\n+     * In special cases, when implementing \"updateValue\", we can not use\n+     * constructors or factory methods, but have to fall back on using a\n+     * setter (or mutable field property). If so, this refers to that fallback\n+     * accessor\n+     * \n+     * @since 2.3\n+     */\n+    protected final SettableBeanProperty _fallbackSetter;\n     \n     /**\n      * @param name Name of the logical property\n         _annotated = param;\n         _creatorIndex = index;\n         _injectableValueId = injectableValueId;\n+        _fallbackSetter = null;\n     }\n \n     @Deprecated // since 2.3\n         _annotated = src._annotated;\n         _creatorIndex = src._creatorIndex;\n         _injectableValueId = src._injectableValueId;\n+        _fallbackSetter = src._fallbackSetter;\n     }\n \n     @Deprecated // since 2.3\n     protected CreatorProperty(CreatorProperty src, String newName) {\n         this(src, new PropertyName(newName));\n     }\n-    \n+\n     protected CreatorProperty(CreatorProperty src, JsonDeserializer<?> deser) {\n         super(src, deser);\n         _annotated = src._annotated;\n         _creatorIndex = src._creatorIndex;\n         _injectableValueId = src._injectableValueId;\n-    }\n-\n+        _fallbackSetter = src._fallbackSetter;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected CreatorProperty(CreatorProperty src, SettableBeanProperty fallbackSetter) {\n+        super(src);\n+        _annotated = src._annotated;\n+        _creatorIndex = src._creatorIndex;\n+        _injectableValueId = src._injectableValueId;\n+        _fallbackSetter = fallbackSetter;\n+    }\n+    \n     @Override\n     public CreatorProperty withName(PropertyName newName) {\n         return new CreatorProperty(this, newName);\n         return new CreatorProperty(this, deser);\n     }\n \n+    public CreatorProperty withFallbackSetter(SettableBeanProperty fallbackSetter) {\n+        return new CreatorProperty(this, fallbackSetter);\n+    }\n+    \n     /**\n      * Method that can be called to locate value to be injected for this\n      * property, if it is configured for this.\n         /* Hmmmh. Should we return quietly (NOP), or error?\n          * Perhaps better to throw an exception, since it's generally an error.\n          */\n-        throw new IllegalStateException(\"Method should never be called on a \"+getClass().getName());\n+        if (_fallbackSetter == null) {\n+            throw new IllegalStateException(\"No fallback setter/field defined: can not use creator property for \"\n+                    +getClass().getName());\n+        }\n+        _fallbackSetter.set(instance, value);\n     }\n \n     @Override\n     public Object setAndReturn(Object instance, Object value) throws IOException\n     {\n-        return instance;\n+        if (_fallbackSetter == null) {\n+            throw new IllegalStateException(\"No fallback setter/field defined: can not use creator property for \"\n+                    +getClass().getName());\n+        }\n+        return _fallbackSetter.setAndReturn(instance, value);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n     public abstract AnnotatedMember getMutator();\n \n     /**\n+     * @since 2.3\n+     */\n+    public abstract AnnotatedMember getNonConstructorMutator();\n+    \n+    /**\n      * Method used to find the property member (getter, setter, field) that has\n      * the highest precedence in current context (getter method when serializing,\n      * if available, and so forth), if any.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n      * Accessor to find out whether type specified requires inclusion\n      * of Object Identifier.\n      */\n-    public ObjectIdInfo getObjectIdInfo() {\n+    public ObjectIdInfo getObjectIdInfo()\n+    {\n         if (_annotationIntrospector == null) {\n             return null;\n         }\n      */\n     public Class<?> findPOJOBuilderClass()\n     {\n-    \treturn _annotationIntrospector.findPOJOBuilder(_classDef);\n+        return _annotationIntrospector.findPOJOBuilder(_classDef);\n     }\n     \n     // for unit tests:\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n         }\n         return m;\n     }\n-    \n+\n+    @Override\n+    public AnnotatedMember getNonConstructorMutator() {\n+        AnnotatedMember m = getSetter();\n+        if (m == null) {\n+            m = getField();\n+        }\n+        return m;\n+    }\n+\n     @Override\n     public AnnotatedMember getPrimaryMember() {\n         if (_forSerialization) {\n     public void removeNonVisible() {\n         removeNonVisible(false);\n     }\n-    \n     \n     public void removeNonVisible(boolean force)\n     {\n                 AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);\n                 _fields = _fields.withValue(_fields.value.withAnnotations(ann));\n             }\n-        } else {\n+        } else { // for deserialization\n             if (_ctorParameters != null) {\n                 AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);\n                 _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann));\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n      * @param propertiesNode Node which the given property would exist within\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      *  processing\n-     * \n-     * @since 2.1\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n+     */\n+    @Override\n+    @Deprecated\n     public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n         throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n     public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n         throws JsonMappingException\n     {\n+        // !!! TODO\n     }\n \n     @Override\n+    @Deprecated\n     public void depositSchemaProperty(ObjectNode propertiesNode,\n             SerializerProvider provider) throws JsonMappingException {\n+        // !!! TODO\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n     }\n \n     @Override\n+    public AnnotatedMember getNonConstructorMutator() {\n+        AnnotatedMember acc = getSetter();\n+        if (acc == null) {\n+            acc = getField();\n+        }\n+        return acc;\n+    }\n+\n+    @Override\n     public AnnotatedMember getPrimaryMember() {\n         return _member;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n     /**********************************************************\n      */\n \n+    /* 18-Oct-2013, tatu: Not sure why, but looks like sharing the default\n+     *   ObjectMapper here can lead to strange unit test suite failures, so\n+     *   let's create a private copy for this class only.\n+     */\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testConfigs() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        byte[] base = jdkSerialize(mapper.getDeserializationConfig().getBaseSettings());\n+        byte[] base = jdkSerialize(MAPPER.getDeserializationConfig().getBaseSettings());\n         assertNotNull(jdkDeserialize(base));\n \n         // first things first: underlying BaseSettings\n         \n-        DeserializationConfig origDC = mapper.getDeserializationConfig();\n-        SerializationConfig origSC = mapper.getSerializationConfig();\n+        DeserializationConfig origDC = MAPPER.getDeserializationConfig();\n+        SerializationConfig origSC = MAPPER.getSerializationConfig();\n         byte[] dcBytes = jdkSerialize(origDC);\n         byte[] scBytes = jdkSerialize(origSC);\n \n \n     public void testObjectWriter() throws IOException\n     {\n-        ObjectWriter origWriter = new ObjectMapper().writer();\n+        ObjectWriter origWriter = MAPPER.writer();\n         final String EXP_JSON = \"{\\\"x\\\":2,\\\"y\\\":3}\";\n         final MyPojo p = new MyPojo(2, 3);\n         assertEquals(EXP_JSON, origWriter.writeValueAsString(p));\n     \n     public void testObjectReader() throws IOException\n     {\n-        ObjectReader origReader = new ObjectMapper().reader(MyPojo.class);\n+        ObjectReader origReader = MAPPER.reader(MyPojo.class);\n         final String JSON = \"{\\\"x\\\":1,\\\"y\\\":2}\";\n         MyPojo p1 = origReader.readValue(JSON);\n         assertEquals(2, p1.y);\n \n     public void testObjectMapper() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         final String EXP_JSON = \"{\\\"x\\\":2,\\\"y\\\":3}\";\n         final MyPojo p = new MyPojo(2, 3);\n-        assertEquals(EXP_JSON, mapper.writeValueAsString(p));\n+        assertEquals(EXP_JSON, MAPPER.writeValueAsString(p));\n \n-        byte[] bytes = jdkSerialize(mapper);\n+        byte[] bytes = jdkSerialize(MAPPER);\n         ObjectMapper mapper2 = jdkDeserialize(bytes);\n         assertEquals(EXP_JSON, mapper2.writeValueAsString(p));\n         MyPojo p2 = mapper2.readValue(EXP_JSON, MyPojo.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestConvertingDeserializer.java\n         }\n     }\n     \n-    static class PointConverter extends StdConverter<int[], Point>\n+    private static class PointConverter extends StdConverter<int[], Point>\n     {\n         @Override public Point convert(int[] value) {\n             return new Point(value[0], value[1]);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueUpdate.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestValueUpdate extends BaseTest\n+{\n+    static class Bean\n+    {\n+        private String a;\n+        private String b;\n+\n+        @JsonCreator\n+        public Bean(@JsonProperty(\"a\") String a, @JsonProperty(\"b\") String b)\n+        {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        String getA() {\n+            return a;\n+        }\n+\n+        void setA(String a) {\n+            this.a = a;\n+        }\n+\n+        String getB() {\n+            return b;\n+        }\n+\n+        void setB(String b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    // [Issue#318] (and Scala module issue #83]\n+    public void testValueUpdateWithCreator() throws Exception\n+    {\n+        Bean bean = new Bean(\"abc\", \"def\");\n+        new ObjectMapper().reader(Bean.class).withValueToUpdate(bean).readValue(\"{\\\"a\\\":\\\"ghi\\\",\\\"b\\\":\\\"jkl\\\"}\");\n+        assertEquals(\"ghi\", bean.getA());\n+        assertEquals(\"jkl\", bean.getB());\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestArraySerialization.java\n package com.fasterxml.jackson.databind.ser;\n-\n-import java.io.*;\n-\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n public class TestArraySerialization\n-    extends BaseTest\n+    extends BaseMapTest\n {\n-    private final ObjectMapper MAPPER = new ObjectMapper();\n+    private final ObjectMapper MAPPER = objectMapper();\n     \n     public void testLongStringArray() throws Exception\n     {\n     \n     public void testIntArray() throws Exception\n     {\n-        StringWriter sw = new StringWriter();\n-        MAPPER.writeValue(sw, new int[] { 1, 2, 3, -7 });\n-        assertEquals(\"[1,2,3,-7]\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(new int[] { 1, 2, 3, -7 });\n+        assertEquals(\"[1,2,3,-7]\", json);\n     }\n \n     public void testBigIntArray() throws Exception\n     \n     public void testLongArray() throws Exception\n     {\n-        StringWriter sw = new StringWriter();\n-        MAPPER.writeValue(sw, new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });\n-        assertEquals(\"[\"+Long.MIN_VALUE+\",0,\"+Long.MAX_VALUE+\"]\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });\n+        assertEquals(\"[\"+Long.MIN_VALUE+\",0,\"+Long.MAX_VALUE+\"]\", json);\n     }\n \n     public void testStringArray() throws Exception\n     {\n-        StringWriter sw = new StringWriter();\n-        MAPPER.writeValue(sw, new String[] { \"a\", \"\\\"foo\\\"\", null });\n-        assertEquals(\"[\\\"a\\\",\\\"\\\\\\\"foo\\\\\\\"\\\",null]\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(new String[] { \"a\", \"\\\"foo\\\"\", null });\n+        assertEquals(\"[\\\"a\\\",\\\"\\\\\\\"foo\\\\\\\"\\\",null]\", json);\n     }\n \n     public void testDoubleArray() throws Exception\n     {\n-        StringWriter sw = new StringWriter();\n-        MAPPER.writeValue(sw, new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });\n-        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });\n+        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", json);\n     }\n \n     public void testFloatArray() throws Exception\n     {\n-        StringWriter sw = new StringWriter();\n-        MAPPER.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });\n-        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });\n+        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", json);\n     }\n }", "timestamp": 1382165550, "metainfo": ""}