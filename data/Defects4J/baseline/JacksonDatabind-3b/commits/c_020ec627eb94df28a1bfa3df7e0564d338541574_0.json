{"sha": "020ec627eb94df28a1bfa3df7e0564d338541574", "log": "Merge branch 'master' into feature/inet-socket-address", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     public boolean hasSerializer() { return _serializer != null; }\n     public boolean hasNullSerializer() { return _nullSerializer != null; }\n \n+    /**\n+     * Accessor that will return true if this bean property has to support\n+     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n+     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n+     *<p>\n+     * Default implementation simply returns false.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean isUnwrapping() {\n+        return false;\n+    }\n+    \n     public boolean willSuppressNulls() { return _suppressNulls; }\n     \n     // Needed by BeanSerializer#getSchema\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n     /* Overrides\n     /**********************************************************\n      */\n+\n+    @Override\n+    public boolean isUnwrapping() {\n+        return true;\n+    }\n     \n     @Override\n     public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n \n import java.io.*;\n import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n import java.net.URI;\n import java.net.URL;\n import java.nio.charset.Charset;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n \n /**\n  * Container class that contains serializers for JDK types that\n                 Pattern.class,\n                 Locale.class,\n                 InetAddress.class,\n+                InetSocketAddress.class,\n                 Charset.class,\n                 AtomicBoolean.class,\n                 Class.class,\n             PatternDeserializer.instance,\n             LocaleDeserializer.instance,\n             InetAddressDeserializer.instance,\n+            InetSocketAddressDeserializer.instance,\n             CharsetDeserializer.instance,\n             \n             // other types:\n         }\n         if (rawType == InetAddress.class) {\n             return InetAddressDeserializer.instance;\n+        }\n+        if (rawType == InetSocketAddress.class) {\n+            return InetSocketAddressDeserializer.instance;\n         }\n         if (rawType == Charset.class) {\n             return CharsetDeserializer.instance;\n             throws IOException\n         {\n             return InetAddress.getByName(value);\n+        }\n+    }\n+\n+    /**\n+     * Deserializer for {@link InetSocketAddress}.\n+     *\n+     * @see <a href=\"https://github.com/FasterXML/jackson-databind/issues/48\">Issue 48</a>.\n+     */\n+    protected static class InetSocketAddressDeserializer\n+            extends FromStringDeserializer<InetSocketAddress>\n+    {\n+        public final static InetSocketAddressDeserializer instance = new InetSocketAddressDeserializer();\n+\n+        public InetSocketAddressDeserializer() { super(InetSocketAddress.class); }\n+\n+        @Override\n+        protected InetSocketAddress _deserialize(String value, DeserializationContext ctxt)\n+                throws IOException\n+        {\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(\n+                            \"Bracketed IPv6 address must contain closing bracket.\",\n+                            value, InetSocketAddress.class);\n+                }\n+\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int i = value.indexOf(':');\n+                if (i != -1 && value.indexOf(':', i + 1) == -1) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(i));\n+                    return new InetSocketAddress(value.substring(0, i), port);\n+                } else {\n+                    // host or unbracketed IPv6, without port number\n+                    return new InetSocketAddress(value, 0);\n+                }\n+            }\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n         // One unfortunate special case, as per [JACKSON-484]\n         if (InetAddress.class.isAssignableFrom(raw)) {\n             return InetAddressSerializer.instance;\n+        }\n+        if (InetSocketAddress.class.isAssignableFrom(raw)) {\n+            return InetSocketAddressSerializer.instance;\n         }\n         // ... and another one, [JACKSON-522], for TimeZone\n         if (TimeZone.class.isAssignableFrom(raw)) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetSocketAddressSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+\n+import java.io.IOException;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Simple serializer for {@link InetSocketAddress}.\n+ */\n+public class InetSocketAddressSerializer\n+    extends StdScalarSerializer<InetSocketAddress>\n+{\n+    public final static InetSocketAddressSerializer instance = new InetSocketAddressSerializer();\n+\n+    public InetSocketAddressSerializer() { super(InetSocketAddress.class); }\n+\n+    @Override\n+    public void serialize(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        InetAddress addr = value.getAddress();\n+        String str = addr == null ? value.getHostName() : addr.toString().trim();\n+        int ix = str.indexOf('/');\n+        if (ix >= 0) {\n+            if (ix == 0) { // missing host name; use address\n+                str = addr instanceof Inet6Address\n+                        ? \"[\" + str.substring(1) + \"]\" // bracket IPv6 addresses with\n+                        : str.substring(1);\n+\n+            } else { // otherwise use name\n+                str = str.substring(0, ix);\n+            }\n+        }\n+\n+        jgen.writeString(str + \":\" + value.getPort());\n+    }\n+\n+    @Override\n+    public void serializeWithType(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Better ensure we don't use specific sub-classes...\n+        typeSer.writeTypePrefixForScalar(value, jgen, InetSocketAddress.class);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n         // should we try resolving host names? That requires connectivity... \n         final String HOST = \"www.ning.com\";\n         address = mapper.readValue(quote(HOST), InetAddress.class);\n+        assertEquals(HOST, address.getHostName());\n+    }\n+\n+    public void testInetSocketAddress() throws IOException\n+    {\n+        InetSocketAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetSocketAddress.class);\n+        assertEquals(\"127.0.0.1\", address.getAddress().getHostAddress());\n+\n+        InetSocketAddress ip6 = mapper.readValue(\n+                quote(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"), InetSocketAddress.class);\n+        assertEquals(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\", ip6.getAddress().getHostAddress());\n+\n+        InetSocketAddress ip6port = mapper.readValue(\n+                quote(\"[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443\"), InetSocketAddress.class);\n+        assertEquals(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\", ip6port.getAddress().getHostAddress());\n+        assertEquals(443, ip6port.getPort());\n+\n+        // should we try resolving host names? That requires connectivity...\n+        final String HOST = \"www.ning.com\";\n+        address = mapper.readValue(quote(HOST), InetSocketAddress.class);\n         assertEquals(HOST, address.getHostName());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n import java.io.*;\n import java.math.BigDecimal;\n import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n import java.nio.charset.Charset;\n import java.util.*;\n import java.util.regex.Pattern;\n         assertEquals(quote(\"ning.com\"), MAPPER.writeValueAsString(InetAddress.getByName(\"ning.com\")));\n     }\n \n+    public void testInetSocketAddress() throws IOException\n+    {\n+        assertEquals(\n+                quote(\"127.0.0.1:8080\"),\n+                MAPPER.writeValueAsString(new InetSocketAddress(\"127.0.0.1\", 8080)));\n+        assertEquals(\n+                quote(\"ning.com:6667\"),\n+                MAPPER.writeValueAsString(new InetSocketAddress(\"ning.com\", 6667)));\n+        assertEquals(\n+                quote(\"[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443\"),\n+                MAPPER.writeValueAsString(new InetSocketAddress(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\", 443)));\n+    }\n+\n     // [JACKSON-597]\n     public void testClass() throws IOException\n     {", "timestamp": 1372152785, "metainfo": ""}