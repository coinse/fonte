{"sha": "f1c5f8f392069401c1daaa6601cc45cbf9f5fd34", "log": "Refactoring to improve grouping of deserializers", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n  * does not support handling of the type. In latter case, further calls can be made\n  * for other providers; in former case returned key deserializer is used for handling of\n  * key instances of specified type.\n- * \n- * @since 1.8\n  */\n public interface KeyDeserializers\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.AtomicBooleanDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.CalendarDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.ClassDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.DateDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.JavaTypeDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StringDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.TimestampDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.TokenBufferDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n \n /**\n  * Helper class used to contain simple/well-known deserializers for core JDK types.\n- *<p>\n- * Note: as of Jackson 1.9, we use type-erased class for registering, since\n- * some types may come either as type-erased or typed (for example,\n- * <code>java.lang.Class</code>).\n  */\n class StdDeserializers\n {\n         StdDeserializer<?> strDeser = new StringDeserializer();\n         add(strDeser, String.class);\n         add(strDeser, CharSequence.class);\n-        add(new ClassDeserializer());\n \n-        // Then primitive-wrappers (simple):\n-        add(new StdDeserializer.BooleanDeserializer(Boolean.class, null));\n-        add(new StdDeserializer.ByteDeserializer(Byte.class, null));\n-        add(new StdDeserializer.ShortDeserializer(Short.class, null));\n-        add(new StdDeserializer.CharacterDeserializer(Character.class, null));\n-        add(new StdDeserializer.IntegerDeserializer(Integer.class, null));\n-        add(new StdDeserializer.LongDeserializer(Long.class, null));\n-        add(new StdDeserializer.FloatDeserializer(Float.class, null));\n-        add(new StdDeserializer.DoubleDeserializer(Double.class, null));\n-        \n-        /* And actual primitives: difference is the way nulls are to be\n-         * handled...\n-         */\n-        add(new StdDeserializer.BooleanDeserializer(Boolean.TYPE, Boolean.FALSE));\n-        add(new StdDeserializer.ByteDeserializer(Byte.TYPE, Byte.valueOf((byte)(0))));\n-        add(new StdDeserializer.ShortDeserializer(Short.TYPE, Short.valueOf((short)0)));\n-        add(new StdDeserializer.CharacterDeserializer(Character.TYPE, Character.valueOf('\\0')));\n-        add(new StdDeserializer.IntegerDeserializer(Integer.TYPE, Integer.valueOf(0)));\n-        add(new StdDeserializer.LongDeserializer(Long.TYPE, Long.valueOf(0L)));\n-        add(new StdDeserializer.FloatDeserializer(Float.TYPE, Float.valueOf(0.0f)));\n-        add(new StdDeserializer.DoubleDeserializer(Double.TYPE, Double.valueOf(0.0)));\n-        \n-        // and related\n-        add(new StdDeserializer.NumberDeserializer());\n-        add(new StdDeserializer.BigDecimalDeserializer());\n-        add(new StdDeserializer.BigIntegerDeserializer());\n-        \n-        add(new CalendarDeserializer());\n-        add(new DateDeserializer());\n-        /* 24-Jan-2010, tatu: When including type information, we may\n-         *    know that we specifically need GregorianCalendar...\n-         */\n-        add(new CalendarDeserializer(GregorianCalendar.class),\n-                GregorianCalendar.class);\n-        add(new StdDeserializer.SqlDateDeserializer());\n-        add(new TimestampDeserializer());\n-\n-        // From-string deserializers:\n-        for (StdDeserializer<?> deser : FromStringDeserializer.all()) {\n-            add(deser);\n-        }\n-\n-        // And finally some odds and ends\n-\n-        // to deserialize Throwable, need stack trace elements:\n-        add(new StdDeserializer.StackTraceElementDeserializer());\n+        // Primitives/wrappers, other Numbers:\n+        add(NumberDeserializers.all());\n+        // Date/time types\n+        add(DateDeserializers.all());\n+        // other JDK types\n+        add(JdkDeserializers.all());\n \n         // [JACKSON-283] need to support atomic types, too\n         // (note: AtomicInteger/Long work due to single-arg constructor)\n         add(new AtomicBooleanDeserializer());\n \n-        // including some core Jackson types:\n-        add(new TokenBufferDeserializer());\n-        add(new JavaTypeDeserializer());\n+        add(JacksonDeserializers.all());\n     }\n \n     /**\n         return new StdDeserializers()._deserializers;\n     }\n \n-    private void add(StdDeserializer<?> stdDeser)\n-    {\n+    private void add(StdDeserializer<?>[] serializers) {\n+        for (StdDeserializer<?> ser : serializers) {\n+            add(ser, ser.getValueClass());\n+        }\n+    }\n+\n+    private void add(StdDeserializer<?> stdDeser) {\n         add(stdDeser, stdDeser.getValueClass());\n     }\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+\n+/**\n+ * Container class for core JDK date/time type deserializers.\n+ */\n+public class DateDeserializers\n+{\n+    public static StdDeserializer<?>[] all()\n+    {\n+        return  new StdDeserializer[] {\n+            new CalendarDeserializer(), // for nominal type of java.util.Calendar\n+            new DateDeserializer(),\n+            /* 24-Jan-2010, tatu: When including type information, we may\n+             *    know that we specifically need GregorianCalendar...\n+             */\n+            new CalendarDeserializer(GregorianCalendar.class),\n+            new SqlDateDeserializer(),\n+            new TimestampDeserializer(),\n+            new TimeZoneDeserializer()\n+        };\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations\n+    /**********************************************************\n+     */\n+    \n+    @JacksonStdImpl\n+    public static class CalendarDeserializer\n+        extends StdScalarDeserializer<Calendar>\n+    {\n+        /**\n+         * We may know actual expected type; if so, it will be\n+         * used for instantiation.\n+         */\n+        protected final Class<? extends Calendar> _calendarClass;\n+        \n+        public CalendarDeserializer() {\n+            super(Calendar.class);\n+            _calendarClass = null;\n+        }\n+\n+        public CalendarDeserializer(Class<? extends Calendar> cc) {\n+            super(cc);\n+            _calendarClass = cc;\n+        }\n+\n+        @Override\n+        public Calendar deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            Date d = _parseDate(jp, ctxt);\n+            if (d == null) {\n+                return null;\n+            }\n+            if (_calendarClass == null) {\n+                return ctxt.constructCalendar(d);\n+            }\n+            try {\n+                Calendar c = _calendarClass.newInstance();            \n+                c.setTimeInMillis(d.getTime());\n+                return c;\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_calendarClass, e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Simple deserializer for handling {@link java.util.Date} values.\n+     *<p>\n+     * One way to customize Date formats accepted is to override method\n+     * {@link DeserializationContext#parseDate} that this basic\n+     * deserializer calls.\n+     */\n+    public static class DateDeserializer\n+        extends StdScalarDeserializer<Date>\n+    {\n+        public DateDeserializer() { super(Date.class); }\n+       \n+        @Override\n+        public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseDate(jp, ctxt);\n+        }\n+    }\n+\n+    /**\n+     * Compared to plain old {@link java.util.Date}, SQL version is easier\n+     * to deal with: mostly because it is more limited.\n+     */\n+    public static class SqlDateDeserializer\n+        extends StdScalarDeserializer<java.sql.Date>\n+    {\n+        public SqlDateDeserializer() { super(java.sql.Date.class); }\n+\n+        @Override\n+        public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            Date d = _parseDate(jp, ctxt);\n+            return (d == null) ? null : new java.sql.Date(d.getTime());\n+        }\n+    }\n+\n+    /**\n+     * Simple deserializer for handling {@link java.sql.Timestamp} values.\n+     *<p>\n+     * One way to customize Timestamp formats accepted is to override method\n+     * {@link DeserializationContext#parseDate} that this basic\n+     * deserializer calls.\n+     */\n+    public static class TimestampDeserializer\n+        extends StdScalarDeserializer<Timestamp>\n+    {\n+        public TimestampDeserializer() { super(Timestamp.class); }\n+\n+        @Override\n+        public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return new Timestamp(_parseDate(jp, ctxt).getTime());\n+        }\n+    }\n+\n+    /**\n+     * As per [JACKSON-522], also need special handling for TimeZones\n+     * \n+     * @since 1.7.4\n+     */\n+    protected static class TimeZoneDeserializer\n+        extends FromStringDeserializer<TimeZone>\n+    {\n+        public TimeZoneDeserializer() { super(TimeZone.class); }\n+\n+        @Override\n+        protected TimeZone _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return TimeZone.getTimeZone(value);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.*;\n-import java.net.InetAddress;\n-import java.net.URI;\n-import java.net.URL;\n-import java.util.*;\n-import java.util.regex.Pattern;\n \n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n /**\n- * Base class for simple deserializer which only accept JSON String\n+ * Base class for simple deserializers that only accept JSON String\n  * values as the source.\n- * \n- * @since 1.9 (moved from higher-level package)\n  */\n public abstract class FromStringDeserializer<T>\n     extends StdScalarDeserializer<T>\n         super(vc);\n     }\n \n-    public static Iterable<FromStringDeserializer<?>>all()\n-    {\n-        ArrayList<FromStringDeserializer<?>> all = new ArrayList<FromStringDeserializer<?>>();\n-\n-        all.add(new UUIDDeserializer());\n-        all.add(new URLDeserializer());\n-        all.add(new URIDeserializer());\n-        all.add(new CurrencyDeserializer());\n-        all.add(new PatternDeserializer());\n-        // since 1.7:\n-        all.add(new LocaleDeserializer());\n-        // 1.8:\n-        all.add(new InetAddressDeserializer());\n-        all.add(new TimeZoneDeserializer());\n-\n-        return all;\n-    }\n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations\n+    /**********************************************************\n+     */\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n         throw ctxt.mappingException(\"Don't know how to convert embedded Object of type \"\n                 +ob.getClass().getName()+\" into \"+_valueClass.getName());\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Then concrete implementations\n-    /**********************************************************\n-     */\n \n-    public static class UUIDDeserializer\n-        extends FromStringDeserializer<UUID>\n-    {\n-        public UUIDDeserializer() { super(UUID.class); }\n-\n-        @Override\n-        protected UUID _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return UUID.fromString(value);\n-        }\n-\n-        @Override\n-        protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            if (ob instanceof byte[]) {\n-                byte[] bytes = (byte[]) ob;\n-                if (bytes.length != 16) {\n-                    ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n-                }\n-                // clumsy, but should work for now...\n-                DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n-                long l1 = in.readLong();\n-                long l2 = in.readLong();\n-                return new UUID(l1, l2);\n-            }\n-            super._deserializeEmbedded(ob, ctxt);\n-            return null; // never gets here\n-        }\n-    }\n-\n-    public static class URLDeserializer\n-        extends FromStringDeserializer<URL>\n-    {\n-        public URLDeserializer() { super(URL.class); }\n-        \n-        @Override\n-        protected URL _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return new URL(value);\n-        }\n-    }\n-\n-    public static class URIDeserializer\n-        extends FromStringDeserializer<URI>\n-    {\n-        public URIDeserializer() { super(URI.class); }\n-\n-        @Override\n-        protected URI _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            return URI.create(value);\n-        }\n-    }\n-\n-    public static class CurrencyDeserializer\n-        extends FromStringDeserializer<Currency>\n-    {\n-        public CurrencyDeserializer() { super(Currency.class); }\n-        \n-        @Override\n-        protected Currency _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            // will throw IAE if unknown:\n-            return Currency.getInstance(value);\n-        }\n-    }\n-\n-    public static class PatternDeserializer\n-        extends FromStringDeserializer<Pattern>\n-    {\n-        public PatternDeserializer() { super(Pattern.class); }\n-        \n-        @Override\n-        protected Pattern _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            // will throw IAE (or its subclass) if malformed\n-            return Pattern.compile(value);\n-        }\n-    }\n-\n-    /**\n-     * Kept protected as it's not meant to be extensible at this point\n-     * \n-     * @since 1.7\n-     */\n-    protected static class LocaleDeserializer\n-        extends FromStringDeserializer<Locale>\n-    {\n-        public LocaleDeserializer() { super(Locale.class); }\n-        \n-        @Override\n-        protected Locale _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            int ix = value.indexOf('_');\n-            if (ix < 0) { // single argument\n-                return new Locale(value);\n-            }\n-            String first = value.substring(0, ix);\n-            value = value.substring(ix+1);\n-            ix = value.indexOf('_');\n-            if (ix < 0) { // two pieces\n-                return new Locale(first, value);\n-            }\n-            String second = value.substring(0, ix);\n-            return new Locale(first, second, value.substring(ix+1));\n-        }\n-    }\n-\n-    /**\n-     * As per [JACKSON-484], also need special handling for InetAddress...\n-     * \n-     * @since 1.7.4\n-     */\n-    protected static class InetAddressDeserializer\n-        extends FromStringDeserializer<InetAddress>\n-    {\n-        public InetAddressDeserializer() { super(InetAddress.class); }\n-\n-        @Override\n-        protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return InetAddress.getByName(value);\n-        }\n-    }\n-\n-    /**\n-     * As per [JACKSON-522], also need special handling for InetAddress...\n-     * \n-     * @since 1.7.4\n-     */\n-    protected static class TimeZoneDeserializer\n-        extends FromStringDeserializer<TimeZone>\n-    {\n-        public TimeZoneDeserializer() { super(TimeZone.class); }\n-\n-        @Override\n-        protected TimeZone _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return TimeZone.getTimeZone(value);\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Container class for core Jackson type deserializers.\n+ */\n+public class JacksonDeserializers\n+{\n+    public static StdDeserializer<?>[] all()\n+    {\n+        return  new StdDeserializer[] {\n+            new TokenBufferDeserializer(),\n+            new JavaTypeDeserializer()\n+        };\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Deserializer for {@link JavaType} values.\n+     */\n+    public static class JavaTypeDeserializer\n+        extends StdScalarDeserializer<JavaType>\n+    {\n+        public JavaTypeDeserializer() { super(JavaType.class); }\n+        \n+        @Override\n+        public JavaType deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken curr = jp.getCurrentToken();\n+            // Usually should just get string value:\n+            if (curr == JsonToken.VALUE_STRING) {\n+                String str = jp.getText().trim();\n+                if (str.length() == 0) {\n+                    return getEmptyValue();\n+                }\n+                return ctxt.getTypeFactory().constructFromCanonical(str);\n+            }\n+            // or occasionally just embedded object maybe\n+            if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                return (JavaType) jp.getEmbeddedObject();\n+            }\n+            throw ctxt.mappingException(_valueClass);\n+        }\n+    }\n+    \n+    /**\n+     * We also want to directly support deserialization of {@link TokenBuffer}.\n+     *<p>\n+     * Note that we use scalar deserializer base just because we claim\n+     * to be of scalar for type information inclusion purposes; actual\n+     * underlying content can be of any (Object, Array, scalar) type.\n+     */\n+    @JacksonStdImpl\n+    public static class TokenBufferDeserializer\n+        extends StdScalarDeserializer<TokenBuffer>\n+    {\n+        public TokenBufferDeserializer() { super(TokenBuffer.class); }\n+\n+        @Override\n+        public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            TokenBuffer tb = new TokenBuffer(jp.getCodec());\n+            // quite simple, given that TokenBuffer is a JsonGenerator:\n+            tb.copyCurrentStructure(jp);\n+            return tb;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import com.fasterxml.jackson.core.Base64Variants;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+public class JdkDeserializers\n+{\n+    public static StdDeserializer<?>[] all()\n+    {\n+        return new StdDeserializer[] {\n+\n+            // from String types:\n+            new StringDeserializer(),\n+            new UUIDDeserializer(),\n+            new URLDeserializer(),\n+            new URIDeserializer(),\n+            new CurrencyDeserializer(),\n+            new PatternDeserializer(),\n+            new LocaleDeserializer(),\n+            new InetAddressDeserializer(),\n+\n+            // other types:\n+            new ClassDeserializer(),\n+            new StackTraceElementDeserializer()\n+        };\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations: from-String deserializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Note: final as performance optimization: not expected to need sub-classing;\n+     * if sub-classing was needed could re-factor into reusable part, final\n+     * \"Impl\" sub-class\n+     */\n+    @JacksonStdImpl\n+    public final static class StringDeserializer\n+        extends StdScalarDeserializer<String>\n+    {\n+        public StringDeserializer() { super(String.class); }\n+\n+        @Override\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken curr = jp.getCurrentToken();\n+            // Usually should just get string value:\n+            if (curr == JsonToken.VALUE_STRING) {\n+                return jp.getText();\n+            }\n+            // [JACKSON-330]: need to gracefully handle byte[] data, as base64\n+            if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                Object ob = jp.getEmbeddedObject();\n+                if (ob == null) {\n+                    return null;\n+                }\n+                if (ob instanceof byte[]) {\n+                    return Base64Variants.getDefaultVariant().encode((byte[]) ob, false);\n+                }\n+                // otherwise, try conversion using toString()...\n+                return ob.toString();\n+            }\n+            // Can deserialize any scalar value, but not markers\n+            if (curr.isScalarValue()) {\n+                return jp.getText();\n+            }\n+            throw ctxt.mappingException(_valueClass, curr);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public String deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return deserialize(jp, ctxt);\n+        }\n+    }\n+    \n+    public static class UUIDDeserializer\n+        extends FromStringDeserializer<UUID>\n+    {\n+        public UUIDDeserializer() { super(UUID.class); }\n+\n+        @Override\n+        protected UUID _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return UUID.fromString(value);\n+        }\n+    \n+        @Override\n+        protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (ob instanceof byte[]) {\n+                byte[] bytes = (byte[]) ob;\n+                if (bytes.length != 16) {\n+                    ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n+                }\n+                // clumsy, but should work for now...\n+                DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n+                long l1 = in.readLong();\n+                long l2 = in.readLong();\n+                return new UUID(l1, l2);\n+            }\n+            super._deserializeEmbedded(ob, ctxt);\n+            return null; // never gets here\n+        }\n+    }\n+\n+    public static class URLDeserializer\n+        extends FromStringDeserializer<URL>\n+    {\n+        public URLDeserializer() { super(URL.class); }\n+        \n+        @Override\n+        protected URL _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return new URL(value);\n+        }\n+    }\n+    \n+    public static class URIDeserializer\n+        extends FromStringDeserializer<URI>\n+    {\n+        public URIDeserializer() { super(URI.class); }\n+    \n+        @Override\n+        protected URI _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            return URI.create(value);\n+        }\n+    }\n+    \n+    public static class CurrencyDeserializer\n+        extends FromStringDeserializer<Currency>\n+    {\n+        public CurrencyDeserializer() { super(Currency.class); }\n+        \n+        @Override\n+        protected Currency _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        }\n+    }\n+    \n+    public static class PatternDeserializer\n+        extends FromStringDeserializer<Pattern>\n+    {\n+        public PatternDeserializer() { super(Pattern.class); }\n+        \n+        @Override\n+        protected Pattern _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        }\n+    }\n+    \n+    /**\n+     * Kept protected as it's not meant to be extensible at this point\n+     */\n+    protected static class LocaleDeserializer\n+        extends FromStringDeserializer<Locale>\n+    {\n+        public LocaleDeserializer() { super(Locale.class); }\n+        \n+        @Override\n+        protected Locale _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            int ix = value.indexOf('_');\n+            if (ix < 0) { // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix+1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) { // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix+1));\n+        }\n+    }\n+    \n+    /**\n+     * As per [JACKSON-484], also need special handling for InetAddress...\n+     */\n+    protected static class InetAddressDeserializer\n+        extends FromStringDeserializer<InetAddress>\n+    {\n+        public InetAddressDeserializer() { super(InetAddress.class); }\n+    \n+        @Override\n+        protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return InetAddress.getByName(value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializers for other JDK types\n+    /**********************************************************\n+     */\n+\n+    public static class StackTraceElementDeserializer\n+        extends StdScalarDeserializer<StackTraceElement>\n+    {\n+        public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n+    \n+        @Override\n+        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            // Must get an Object\n+            if (t == JsonToken.START_OBJECT) {\n+                String className = \"\", methodName = \"\", fileName = \"\";\n+                int lineNumber = -1;\n+    \n+                while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {\n+                    String propName = jp.getCurrentName();\n+                    if (\"className\".equals(propName)) {\n+                        className = jp.getText();\n+                    } else if (\"fileName\".equals(propName)) {\n+                        fileName = jp.getText();\n+                    } else if (\"lineNumber\".equals(propName)) {\n+                        if (t.isNumeric()) {\n+                            lineNumber = jp.getIntValue();\n+                        } else {\n+                            throw JsonMappingException.from(jp, \"Non-numeric token (\"+t+\") for property 'lineNumber'\");\n+                        }\n+                    } else if (\"methodName\".equals(propName)) {\n+                        methodName = jp.getText();\n+                    } else if (\"nativeMethod\".equals(propName)) {\n+                        // no setter, not passed via constructor: ignore\n+                    } else {\n+                        handleUnknownProperty(jp, ctxt, _valueClass, propName);\n+                    }\n+                }\n+                return new StackTraceElement(className, methodName, fileName, lineNumber);\n+            }\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Container class for deserializers that handle core JDK primitive\n+ * (and matching wrapper) types, as well as standard \"big\" numeric types.\n+ * Note that this includes types such as {@link java.lang.Boolean}\n+ * and {@link java.lang.Character} which are not strictly numeric,\n+ * but are part of primitive/wrapper types.\n+ */\n+public class NumberDeserializers\n+{\n+    public static StdDeserializer<?>[] all()\n+    {\n+        return new StdDeserializer<?>[] {\n+                // primitive-wrappers (simple):\n+                new BooleanDeserializer(Boolean.class, null),\n+                new ByteDeserializer(Byte.class, null),\n+                new ShortDeserializer(Short.class, null),\n+                new CharacterDeserializer(Character.class, null),\n+                new IntegerDeserializer(Integer.class, null),\n+                new LongDeserializer(Long.class, null),\n+                new FloatDeserializer(Float.class, null),\n+                new DoubleDeserializer(Double.class, null),\n+\n+                /* And actual primitives: difference is the way nulls are to be\n+                 * handled...\n+                 */\n+                new BooleanDeserializer(Boolean.TYPE, Boolean.FALSE),\n+                new ByteDeserializer(Byte.TYPE, Byte.valueOf((byte)(0))),\n+                new ShortDeserializer(Short.TYPE, Short.valueOf((short)0)),\n+                new CharacterDeserializer(Character.TYPE, Character.valueOf('\\0')),\n+                new IntegerDeserializer(Integer.TYPE, Integer.valueOf(0)),\n+                new LongDeserializer(Long.TYPE, Long.valueOf(0L)),\n+                new FloatDeserializer(Float.TYPE, Float.valueOf(0.0f)),\n+                new DoubleDeserializer(Double.TYPE, Double.valueOf(0.0)),\n+                \n+                // and related\n+                new NumberDeserializer(),\n+                new BigDecimalDeserializer(),\n+                new BigIntegerDeserializer()\n+        };\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Then one intermediate base class for things that have\n+    /* both primitive and wrapper types\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class PrimitiveOrWrapperDeserializer<T>\n+        extends StdScalarDeserializer<T>\n+    {\n+        final T _nullValue;\n+        \n+        protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl)\n+        {\n+            super(vc);\n+            _nullValue = nvl;\n+        }\n+        \n+        @Override\n+        public final T getNullValue() {\n+            return _nullValue;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Then primitive/wrapper types\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public final static class BooleanDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Boolean>\n+    {\n+        public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+        \n+        @Override\n+        public Boolean deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseBoolean(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Boolean deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseBoolean(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class ByteDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Byte>\n+    {\n+        public ByteDeserializer(Class<Byte> cls, Byte nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Byte deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseByte(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class ShortDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Short>\n+    {\n+        public ShortDeserializer(Class<Short> cls, Short nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Short deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseShort(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class CharacterDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Character>\n+    {\n+        public CharacterDeserializer(Class<Character> cls, Character nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            int value;\n+\n+            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n+                value = jp.getIntValue();\n+                if (value >= 0 && value <= 0xFFFF) {\n+                    return Character.valueOf((char) value);\n+                }\n+            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n+                // But does it have to be exactly one char?\n+                String text = jp.getText();\n+                if (text.length() == 1) {\n+                    return Character.valueOf(text.charAt(0));\n+                }\n+                // actually, empty should become null?\n+                if (text.length() == 0) {\n+                    return (Character) getEmptyValue();\n+                }\n+            }\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class IntegerDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Integer>\n+    {\n+        public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Integer deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseInteger(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseInteger(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Long>\n+    {\n+        public LongDeserializer(Class<Long> cls, Long nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Long deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseLong(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class FloatDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Float>\n+    {\n+        public FloatDeserializer(Class<Float> cls, Float nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Float deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n+             *   here, so let's not bother even trying...\n+             */\n+            return _parseFloat(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class DoubleDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Double>\n+    {\n+        public DoubleDeserializer(Class<Double> cls, Double nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Double deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseDouble(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseDouble(jp, ctxt);\n+        }\n+    }\n+\n+    /**\n+     * For type <code>Number.class</code>, we can just rely on type\n+     * mappings that plain {@link JsonParser#getNumberValue} returns.\n+     *<p>\n+     * Since 1.5, there is one additional complication: some numeric\n+     * types (specifically, int/Integer and double/Double) are \"non-typed\";\n+     * meaning that they will NEVER be output with type information.\n+     * But other numeric types may need such type information.\n+     * This is why {@link #deserializeWithType} must be overridden.\n+     */\n+    @JacksonStdImpl\n+    public final static class NumberDeserializer\n+        extends StdScalarDeserializer<Number>\n+    {\n+        public NumberDeserializer() { super(Number.class); }\n+\n+        @Override\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    return jp.getBigIntegerValue();\n+                }\n+                return jp.getNumberValue();\n+            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                /* [JACKSON-72]: need to allow overriding the behavior\n+                 * regarding which type to use\n+                 */\n+                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    return jp.getDecimalValue();\n+                }\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+\n+            /* Textual values are more difficult... not parsing itself, but figuring\n+             * out 'minimal' type to use \n+             */\n+            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                String text = jp.getText().trim();\n+                try {\n+                    if (text.indexOf('.') >= 0) { // floating point\n+                        // as per [JACKSON-72]:\n+                        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                            return new BigDecimal(text);\n+                        }\n+                        return new Double(text);\n+                    }\n+                    // as per [JACKSON-100]:\n+                    if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                        return new BigInteger(text);\n+                    }\n+                    long value = Long.parseLong(text);\n+                    if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n+                        return Integer.valueOf((int) value);\n+                    }\n+                    return Long.valueOf(value);\n+                } catch (IllegalArgumentException iae) {\n+                    throw ctxt.weirdStringException(_valueClass, \"not a valid number\");\n+                }\n+            }\n+            // Otherwise, no can do:\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+\n+        /**\n+         * As mentioned in class Javadoc, there is additional complexity in\n+         * handling potentially mixed type information here. Because of this,\n+         * we must actually check for \"raw\" integers and doubles first, before\n+         * calling type deserializer.\n+         */\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                                          TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            switch (jp.getCurrentToken()) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+            case VALUE_STRING:\n+                // can not point to type information: hence must be non-typed (int/double)\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And then bit more complicated (but non-structured) number\n+    /* types\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * This is bit trickier to implement efficiently, while avoiding\n+     * overflow problems.\n+     */\n+    @JacksonStdImpl\n+    public static class BigIntegerDeserializer\n+        extends StdScalarDeserializer<BigInteger>\n+    {\n+        public BigIntegerDeserializer() { super(BigInteger.class); }\n+\n+        @Override\n+                public BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            String text;\n+\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                switch (jp.getNumberType()) {\n+                case INT:\n+                case LONG:\n+                    return BigInteger.valueOf(jp.getLongValue());\n+                }\n+            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                /* Whether to fail if there's non-integer part?\n+                 * Could do by calling BigDecimal.toBigIntegerExact()\n+                 */\n+                return jp.getDecimalValue().toBigInteger();\n+            } else if (t != JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                // String is ok too, can easily convert; otherwise, no can do:\n+                throw ctxt.mappingException(_valueClass, t);\n+            }\n+            text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return null;\n+            }\n+            try {\n+                return new BigInteger(text);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n+            }\n+        }\n+    }\n+    \n+    @JacksonStdImpl\n+    public static class BigDecimalDeserializer\n+        extends StdScalarDeserializer<BigDecimal>\n+    {\n+        public BigDecimalDeserializer() { super(BigDecimal.class); }\n+\n+        @Override\n+        public BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                return jp.getDecimalValue();\n+            }\n+            // String is ok too, can easily convert\n+            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                String text = jp.getText().trim();\n+                if (text.length() == 0) {\n+                    return null;\n+                }\n+                try {\n+                    return new BigDecimal(text);\n+                } catch (IllegalArgumentException iae) {\n+                    throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n+                }\n+            }\n+            // Otherwise, no can do:\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n      * deserializer Jackson uses; as opposed to a custom deserializer installed by\n      * a module or calling application. Determination is done using\n      * {@link JacksonStdImpl} annotation on deserializer class.\n-     * \n-     * @since 1.7\n      */\n     protected boolean isDefaultSerializer(JsonDeserializer<?> deserializer)\n     {\n     \n     /*\n     /**********************************************************\n-    /* Helper methods for sub-classes, parsing\n+    /* Helper methods for sub-classes, parsing: while mostly\n+    /* useful for numeric types, can be also useful for dealing\n+    /* with things serialized as numbers (such as Dates).\n     /**********************************************************\n      */\n \n     /****************************************************\n     /* Helper methods for sub-classes, resolving dependencies\n     /****************************************************\n-    */\n+     */\n \n     /**\n      * Helper method used to locate deserializers for properties the\n         }\n         // ... or if not, just ignore\n     }\n-\n-\n-    /*\n-    /**********************************************************\n-    /* Then one intermediate base class for things that have\n-    /* both primitive and wrapper types\n-    /**********************************************************\n-     */\n-\n-    protected abstract static class PrimitiveOrWrapperDeserializer<T>\n-        extends StdScalarDeserializer<T>\n-    {\n-        final T _nullValue;\n-        \n-        protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl)\n-        {\n-            super(vc);\n-            _nullValue = nvl;\n-        }\n-        \n-        @Override\n-        public final T getNullValue() {\n-            return _nullValue;\n-        }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Then primitive/wrapper types\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    public final static class BooleanDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Boolean>\n-    {\n-        public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-        \n-        @Override\n-\tpublic Boolean deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseBoolean(jp, ctxt);\n-        }\n-\n-        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n-        // (is it an error to even call this version?)\n-        @Override\n-        public Boolean deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-                TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseBoolean(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class ByteDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Byte>\n-    {\n-        public ByteDeserializer(Class<Byte> cls, Byte nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Byte deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseByte(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class ShortDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Short>\n-    {\n-        public ShortDeserializer(Class<Short> cls, Short nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Short deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseShort(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class CharacterDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Character>\n-    {\n-        public CharacterDeserializer(Class<Character> cls, Character nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            int value;\n-\n-            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n-                value = jp.getIntValue();\n-                if (value >= 0 && value <= 0xFFFF) {\n-                    return Character.valueOf((char) value);\n-                }\n-            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n-                // But does it have to be exactly one char?\n-                String text = jp.getText();\n-                if (text.length() == 1) {\n-                    return Character.valueOf(text.charAt(0));\n-                }\n-                // actually, empty should become null?\n-                if (text.length() == 0) {\n-                    return (Character) getEmptyValue();\n-                }\n-            }\n-            throw ctxt.mappingException(_valueClass, t);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class IntegerDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Integer>\n-    {\n-        public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Integer deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseInteger(jp, ctxt);\n-        }\n-\n-        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n-        // (is it an error to even call this version?)\n-        @Override\n-        public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-                TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseInteger(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class LongDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Long>\n-    {\n-        public LongDeserializer(Class<Long> cls, Long nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Long deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseLong(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class FloatDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Float>\n-    {\n-        public FloatDeserializer(Class<Float> cls, Float nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Float deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n-             *   here, so let's not bother even trying...\n-             */\n-            return _parseFloat(jp, ctxt);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    public final static class DoubleDeserializer\n-        extends PrimitiveOrWrapperDeserializer<Double>\n-    {\n-        public DoubleDeserializer(Class<Double> cls, Double nvl)\n-        {\n-            super(cls, nvl);\n-        }\n-\n-        @Override\n-        public Double deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseDouble(jp, ctxt);\n-        }\n-\n-        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n-        // (is it an error to even call this version?)\n-        @Override\n-        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-                TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            return _parseDouble(jp, ctxt);\n-        }\n-    }\n-\n-    /**\n-     * For type <code>Number.class</code>, we can just rely on type\n-     * mappings that plain {@link JsonParser#getNumberValue} returns.\n-     *<p>\n-     * Since 1.5, there is one additional complication: some numeric\n-     * types (specifically, int/Integer and double/Double) are \"non-typed\";\n-     * meaning that they will NEVER be output with type information.\n-     * But other numeric types may need such type information.\n-     * This is why {@link #deserializeWithType} must be overridden.\n-     */\n-    @JacksonStdImpl\n-    public final static class NumberDeserializer\n-        extends StdScalarDeserializer<Number>\n-    {\n-        public NumberDeserializer() { super(Number.class); }\n-\n-        @Override\n-        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n-                    return jp.getBigIntegerValue();\n-                }\n-                return jp.getNumberValue();\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                /* [JACKSON-72]: need to allow overriding the behavior\n-                 * regarding which type to use\n-                 */\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                    return jp.getDecimalValue();\n-                }\n-                return Double.valueOf(jp.getDoubleValue());\n-            }\n-\n-            /* Textual values are more difficult... not parsing itself, but figuring\n-             * out 'minimal' type to use \n-             */\n-            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n-                String text = jp.getText().trim();\n-                try {\n-                    if (text.indexOf('.') >= 0) { // floating point\n-                        // as per [JACKSON-72]:\n-                        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                            return new BigDecimal(text);\n-                        }\n-                        return new Double(text);\n-                    }\n-                    // as per [JACKSON-100]:\n-                    if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n-                        return new BigInteger(text);\n-                    }\n-                    long value = Long.parseLong(text);\n-                    if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n-                        return Integer.valueOf((int) value);\n-                    }\n-                    return Long.valueOf(value);\n-                } catch (IllegalArgumentException iae) {\n-                    throw ctxt.weirdStringException(_valueClass, \"not a valid number\");\n-                }\n-            }\n-            // Otherwise, no can do:\n-            throw ctxt.mappingException(_valueClass, t);\n-        }\n-\n-        /**\n-         * As mentioned in class Javadoc, there is additional complexity in\n-         * handling potentially mixed type information here. Because of this,\n-         * we must actually check for \"raw\" integers and doubles first, before\n-         * calling type deserializer.\n-         */\n-        @Override\n-        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-                                          TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            switch (jp.getCurrentToken()) {\n-            case VALUE_NUMBER_INT:\n-            case VALUE_NUMBER_FLOAT:\n-            case VALUE_STRING:\n-                // can not point to type information: hence must be non-typed (int/double)\n-                return deserialize(jp, ctxt);\n-            }\n-            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n-        }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* And then bit more complicated (but non-structured) number\n-    /* types\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    public static class BigDecimalDeserializer\n-        extends StdScalarDeserializer<BigDecimal>\n-    {\n-        public BigDecimalDeserializer() { super(BigDecimal.class); }\n-\n-        @Override\n-\tpublic BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                return jp.getDecimalValue();\n-            }\n-            // String is ok too, can easily convert\n-            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n-                String text = jp.getText().trim();\n-                if (text.length() == 0) {\n-                    return null;\n-                }\n-                try {\n-                    return new BigDecimal(text);\n-                } catch (IllegalArgumentException iae) {\n-                    throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n-                }\n-            }\n-            // Otherwise, no can do:\n-            throw ctxt.mappingException(_valueClass, t);\n-        }\n-    }\n-\n-    /**\n-     * This is bit trickier to implement efficiently, while avoiding\n-     * overflow problems.\n-     */\n-    @JacksonStdImpl\n-    public static class BigIntegerDeserializer\n-        extends StdScalarDeserializer<BigInteger>\n-    {\n-        public BigIntegerDeserializer() { super(BigInteger.class); }\n-\n-        @Override\n-\t\tpublic BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            String text;\n-\n-            if (t == JsonToken.VALUE_NUMBER_INT) {\n-                switch (jp.getNumberType()) {\n-                case INT:\n-                case LONG:\n-                    return BigInteger.valueOf(jp.getLongValue());\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                /* Whether to fail if there's non-integer part?\n-                 * Could do by calling BigDecimal.toBigIntegerExact()\n-                 */\n-                return jp.getDecimalValue().toBigInteger();\n-            } else if (t != JsonToken.VALUE_STRING) { // let's do implicit re-parse\n-                // String is ok too, can easily convert; otherwise, no can do:\n-                throw ctxt.mappingException(_valueClass, t);\n-            }\n-            text = jp.getText().trim();\n-            if (text.length() == 0) {\n-                return null;\n-            }\n-            try {\n-                return new BigInteger(text);\n-            } catch (IllegalArgumentException iae) {\n-                throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n-            }\n-        }\n-    }\n-\n-    /*\n-    /****************************************************\n-    /* Then trickier things: Date/Calendar types\n-    /****************************************************\n-     */\n-\n-    /**\n-     * Compared to plain old {@link java.util.Date}, SQL version is easier\n-     * to deal with: mostly because it is more limited.\n-     */\n-    public static class SqlDateDeserializer\n-        extends StdScalarDeserializer<java.sql.Date>\n-    {\n-        public SqlDateDeserializer() { super(java.sql.Date.class); }\n-\n-        @Override\n-        public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            Date d = _parseDate(jp, ctxt);\n-            return (d == null) ? null : new java.sql.Date(d.getTime());\n-        }\n-    }\n-\n-    /*\n-    /****************************************************\n-    /* And other oddities\n-    /****************************************************\n-    */\n-\n-    public static class StackTraceElementDeserializer\n-        extends StdScalarDeserializer<StackTraceElement>\n-    {\n-        public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n-\n-        @Override\n-        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            JsonToken t = jp.getCurrentToken();\n-            // Must get an Object\n-            if (t == JsonToken.START_OBJECT) {\n-                String className = \"\", methodName = \"\", fileName = \"\";\n-                int lineNumber = -1;\n-\n-                while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {\n-                    String propName = jp.getCurrentName();\n-                    if (\"className\".equals(propName)) {\n-                        className = jp.getText();\n-                    } else if (\"fileName\".equals(propName)) {\n-                        fileName = jp.getText();\n-                    } else if (\"lineNumber\".equals(propName)) {\n-                        if (t.isNumeric()) {\n-                            lineNumber = jp.getIntValue();\n-                        } else {\n-                            throw JsonMappingException.from(jp, \"Non-numeric token (\"+t+\") for property 'lineNumber'\");\n-                        }\n-                    } else if (\"methodName\".equals(propName)) {\n-                        methodName = jp.getText();\n-                    } else if (\"nativeMethod\".equals(propName)) {\n-                        // no setter, not passed via constructor: ignore\n-                    } else {\n-                        handleUnknownProperty(jp, ctxt, _valueClass, propName);\n-                    }\n-                }\n-                return new StackTraceElement(className, methodName, fileName, lineNumber);\n-            }\n-            throw ctxt.mappingException(_valueClass, t);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n-\n+/**\n+ * Specifically optimized version for {@link java.util.Collection}s\n+ * that contain String values; reason is that this is a very common\n+ * type and we can make use of the fact that Strings are final.\n+ */\n @JacksonStdImpl\n public final class StringCollectionDeserializer\n     extends ContainerDeserializerBase<Collection<String>>\n     // // Instance construction settings:\n     \n     /**\n-     * @since 1.9\n+     * Instantiator used in case custom handling is needed for creation.\n      */\n     protected final ValueInstantiator _valueInstantiator;\n \n     /**\n      * Copy-constructor that can be used by sub-classes to allow\n      * copy-on-write styling copying of settings of an existing instance.\n-     * \n-     * @since 1.9\n      */\n     protected StringCollectionDeserializer(StringCollectionDeserializer src)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         return deserialize(jp, ctxt);\n-    }}\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n         }        \n     }\n \n+    static class Bean744\n+    {\n+        protected Map<String,Object> additionalProperties;\n+        \n+        @JsonAnySetter\n+        public void addAdditionalProperty(String key, Object value) {\n+            if (additionalProperties == null) additionalProperties = new HashMap<String, Object>();\n+            additionalProperties.put(key,value);\n+        }\n+        \n+        public void setAdditionalProperties(Map<String, Object> additionalProperties) {\n+            this.additionalProperties = additionalProperties;\n+        }\n+\n+        @JsonAnyGetter\n+        public Map<String,Object> getAdditionalProperties() { return additionalProperties; }\n+\n+        @JsonIgnore\n+        public String getName() {\n+           return (String) additionalProperties.get(\"name\");\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(\"Bob\", bean.map.get(\"name\"));\n         assertEquals(1, bean.map.size());\n     }\n+\n+    public void testProblem744() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Bean744 bean = m.readValue(\"{\\\"name\\\":\\\"Bob\\\"}\", Bean744.class);\n+        assertNotNull(bean.additionalProperties);\n+        assertEquals(1, bean.additionalProperties.size());\n+        assertEquals(\"Bob\", bean.additionalProperties.get(\"name\"));\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n \n         public int getX() { return i; }\n     }\n+\n+    static class Issue744Bean\n+    {\n+        protected Map<String,Object> additionalProperties;\n+        \n+        @JsonAnySetter\n+        public void addAdditionalProperty(String key, Object value) {\n+            if (additionalProperties == null) additionalProperties = new HashMap<String, Object>();\n+            additionalProperties.put(key,value);\n+        }\n+        \n+        public void setAdditionalProperties(Map<String, Object> additionalProperties) {\n+            this.additionalProperties = additionalProperties;\n+        }\n+\n+        @JsonAnyGetter\n+        public Map<String,Object> getAdditionalProperties() { return additionalProperties; }\n+\n+        @JsonIgnore\n+        public String getName() {\n+           return (String) additionalProperties.get(\"name\");\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n         String json = mapper.writeValueAsString(bean);\n         assertNotNull(json);\n     }\n+\n+    public void testJackson744() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        BasicBeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue744Bean.class));\n+        assertNotNull(beanDesc);\n+        AnnotatedMethod setter = beanDesc.findAnySetter();\n+        assertNotNull(setter);\n+    }\n     \n     /*\n     /**********************************************************", "timestamp": 1325047728, "metainfo": ""}