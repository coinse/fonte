{"sha": "fdf3a9143b82b61140602f2f1c1090a3cd28ffd5", "log": "refactoring handling of forward-references", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n             if (!(_valueDeserializer.getObjectIdReader() != null)) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n-            AnySetterReferring referring = new AnySetterReferring(instance, propName, reference.getUnresolvedId(),\n-                    reference.getLocation());\n+            AnySetterReferring referring = new AnySetterReferring(this, reference,\n+                    _type.getRawClass(), instance, propName);\n             reference.getRoid().appendReferring(referring);\n         }\n     }\n \n     @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n \n-    private class AnySetterReferring extends Referring {\n-        private Object _pojo;\n-        private String _propName;\n-        private Object _unresolvedId;\n-\n-        public AnySetterReferring(Object instance, String propName, Object id, JsonLocation location)\n+    private static class AnySetterReferring extends Referring {\n+        private final SettableAnyProperty _parent;\n+        private final Object _pojo;\n+        private final String _propName;\n+\n+        public AnySetterReferring(SettableAnyProperty parent,\n+                UnresolvedForwardReference reference, Class<?> type, Object instance, String propName)\n         {\n-            super(location, _type.getRawClass());\n+            super(reference, type);\n+            _parent = parent;\n             _pojo = instance;\n             _propName = propName;\n-            _unresolvedId = id;\n         }\n \n         @Override\n         public void handleResolvedForwardReference(Object id, Object value)\n             throws IOException\n         {\n-            if (!id.equals(_unresolvedId)) {\n+            if (!hasId(id)) {\n                 throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id.toString()\n                         + \"] that wasn't previously registered.\");\n             }\n-            set(_pojo, _propName, value);\n+            _parent.set(_pojo, _propName, value);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n \n-import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationContext;\n     }\n \n     @Override\n-    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser)\n-    {\n+    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n         return new ObjectIdReferenceProperty(this, deser);\n     }\n \n     @Override\n-    public SettableBeanProperty withName(PropertyName newName)\n-    {\n+    public SettableBeanProperty withName(PropertyName newName) {\n         return new ObjectIdReferenceProperty(this, newName);\n     }\n \n     @Override\n-    public <A extends Annotation> A getAnnotation(Class<A> acls)\n-    {\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _forward.getAnnotation(acls);\n     }\n \n     @Override\n-    public AnnotatedMember getMember()\n-    {\n+    public AnnotatedMember getMember() {\n         return _forward.getMember();\n     }\n \n             if (!usingIdentityInfo) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n-            reference.getRoid().appendReferring(\n-                    new PropertyReferring(instance, reference.getUnresolvedId(), reference.getLocation()));\n+            reference.getRoid().appendReferring(new PropertyReferring(this, reference, _type.getRawClass(), instance));\n             return null;\n         }\n     }\n         return _forward.setAndReturn(instance, value);\n     }\n \n-    public final class PropertyReferring extends Referring {\n+    public final static class PropertyReferring extends Referring {\n+        private final ObjectIdReferenceProperty _parent;\n         public final Object _pojo;\n-        private Object _unresolvedId;\n \n-        public PropertyReferring(Object ob, Object id, JsonLocation location)\n+        public PropertyReferring(ObjectIdReferenceProperty parent,\n+                UnresolvedForwardReference ref, Class<?> type, Object ob)\n         {\n-            super(location, _type.getRawClass());\n+            super(ref, type);\n+            _parent = parent;\n             _pojo = ob;\n-            _unresolvedId = id;\n         }\n \n         @Override\n         public void handleResolvedForwardReference(Object id, Object value)\n             throws IOException\n         {\n-            if (!id.equals(_unresolvedId)) {\n+            if (!hasId(id)) {\n                 throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                         + \"] that wasn't previously seen as unresolved.\");\n             }\n-            set(_pojo, value);\n+            _parent.set(_pojo, value);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n \n /**\n  * Simple value container for containing information about single Object Id\n      */\n \n     public static abstract class Referring {\n-        private final JsonLocation _location;\n+        private final UnresolvedForwardReference _reference;\n         private final Class<?> _beanType;\n \n-        public Referring(JsonLocation location, Class<?> beanType)\n-        {\n-            _location = location;\n+        public Referring(UnresolvedForwardReference ref, Class<?> beanType) {\n+            _reference = ref;\n             _beanType = beanType;\n         }\n \n-        public JsonLocation getLocation() { return _location; }\n+        public JsonLocation getLocation() { return _reference.getLocation(); }\n         public Class<?> getBeanType() { return _beanType; }\n \n-        public abstract void handleResolvedForwardReference(Object id, Object value)\n-            throws IOException;\n+        public abstract void handleResolvedForwardReference(Object id, Object value) throws IOException;\n+        public final boolean hasId(Object id) {\n+            return id.equals(_reference.getUnresolvedId());\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n             Collection<Object> previous = _result;\n             while (iterator.hasNext()) {\n                 UnresolvedId unresolvedId = iterator.next();\n-                if (unresolvedId._id.equals(id)) {\n+                if (unresolvedId.hasId(id)) {\n                     iterator.remove();\n                     previous.add(value);\n                     previous.addAll(unresolvedId._next);\n      */\n     private final static class UnresolvedId extends Referring {\n         private final CollectionReferringAccumulator _parent;\n-        private final Object _id;\n         private final List<Object> _next = new ArrayList<Object>();\n         \n-        private UnresolvedId(CollectionReferringAccumulator parent, UnresolvedForwardReference reference,\n-                Class<?> contentType)\n+        private UnresolvedId(CollectionReferringAccumulator parent,\n+                UnresolvedForwardReference reference, Class<?> contentType)\n         {\n-            super(reference.getLocation(), contentType);\n+            super(reference, contentType);\n             _parent = parent;\n-            _id = reference.getUnresolvedId();\n-        }\n-\n+        }\n+        \n         @Override\n         public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n             _parent.resolveForwardReference(id, value);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumulator(result);\n+            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumulator(result);\n+            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final class MapReferringAccumulator  {\n+    private final static class MapReferringAccumulator  {\n+        private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n          * A list of {@link UnresolvedId} to maintain ordering.\n          */\n         private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n \n-        public MapReferringAccumulator(Map<Object, Object> result) {\n+        public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n+            _valueType = valueType;\n             _result = result;\n         }\n \n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n         {\n-            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation(),\n-                    _mapType.getContentType().getRawClass());\n+            UnresolvedId id = new UnresolvedId(this, reference, _valueType, key);\n             _accumulator.add(id);\n             return id;\n         }\n \n-        public void resolveForwardReference(Object id, Object value)\n-            throws IOException\n+        public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n             Iterator<UnresolvedId> iterator = _accumulator.iterator();\n             // Resolve ordering after resolution of an id. This mean either:\n             Map<Object,Object> previous = _result;\n             while (iterator.hasNext()) {\n                 UnresolvedId unresolvedId = iterator.next();\n-                if (unresolvedId._id.equals(id)) {\n+                if (unresolvedId.hasId(id)) {\n                     iterator.remove();\n                     previous.put(unresolvedId._key, value);\n                     previous.putAll(unresolvedId._next);\n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                     + \"] that wasn't previously seen as unresolved.\");\n         }\n-\n-        /**\n-         * Helper class to maintain processing order of value. The resolved\n-         * object associated with {@link #_id} comes before the values in\n-         * {@link _next}.\n-         */\n-        private final class UnresolvedId extends Referring {\n-            private final Object _id;\n-            private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n-            private final Object _key;\n-\n-            private UnresolvedId(Object key, Object id, JsonLocation location,\n-                    Class<?> valueType)\n-            {\n-                super(location, valueType);\n-                _key = key;\n-                _id = id;\n-            }\n-\n-            @Override\n-            public void handleResolvedForwardReference(Object id, Object value) throws IOException\n-            {\n-                resolveForwardReference(id, value);\n-            }\n+    }\n+\n+    /**\n+     * Helper class to maintain processing order of value. The resolved\n+     * object associated with {@link #_id} comes before the values in\n+     * {@link _next}.\n+     */\n+    private final static class UnresolvedId extends Referring {\n+        private final MapReferringAccumulator _parent;\n+        private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n+        private final Object _key;\n+        \n+        private UnresolvedId(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+                Class<?> valueType, Object key)\n+        {\n+            super(ref, valueType);\n+            _parent = parent;\n+            _key = key;\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n+        {\n+            _parent.resolveForwardReference(id, value);\n         }\n     }\n }", "timestamp": 1394853036, "metainfo": ""}