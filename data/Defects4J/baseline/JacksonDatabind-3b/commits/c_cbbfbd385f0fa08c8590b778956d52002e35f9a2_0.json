{"sha": "cbbfbd385f0fa08c8590b778956d52002e35f9a2", "log": "Implement [JACKSON-748], ability to register subtypes from modules", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n package com.fasterxml.jackson.databind;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n     /**\n      * Interface Jackson exposes to modules for purpose of registering\n      * extended functionality.\n+     * Usually implemented by {@link ObjectMapper}, but modules should\n+     * NOT rely on this -- if they do require access to mapper instance,\n+     * they need to call {@link SetupContext#getOwner} method.\n      */\n     public static interface SetupContext\n     {\n          */\n         public <C extends ObjectCodec> C getOwner();\n \n+        public boolean isEnabled(MapperConfig.Feature f);\n+        \n         public boolean isEnabled(DeserializationConfig.Feature f);\n \n         public boolean isEnabled(SerializationConfig.Feature f);\n \n+        public boolean isEnabled(JsonFactory.Feature f);\n+        \n         public boolean isEnabled(JsonParser.Feature f);\n \n         public boolean isEnabled(JsonGenerator.Feature f);\n          */\n         public void appendAnnotationIntrospector(AnnotationIntrospector ai);\n \n+        /**\n+         * Method for registering specified classes as subtypes (of supertype(s)\n+         * they have)\n+         */\n+        public void registerSubtypes(Class<?>... subtypes);\n+\n+        /**\n+         * Method for registering specified classes as subtypes (of supertype(s)\n+         * they have), using specified type names.\n+         */\n+        public void registerSubtypes(NamedType... subtypes);\n+        \n         /**\n          * Method used for defining mix-in annotations to use for augmenting\n          * specified class or interface.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n             }\n             \n             @Override\n+            public boolean isEnabled(MapperConfig.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n             public boolean isEnabled(DeserializationConfig.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n-\n+            \n             @Override\n             public boolean isEnabled(SerializationConfig.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n \n             @Override\n+            public boolean isEnabled(JsonFactory.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n             public boolean isEnabled(JsonParser.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n-\n+            \n             @Override\n             public boolean isEnabled(JsonGenerator.Feature f) {\n                 return mapper.isEnabled(f);\n                 mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n             }\n \n+            @Override\n+            public void registerSubtypes(Class<?>... subtypes) {\n+                mapper.registerSubtypes(subtypes);\n+            }\n+\n+            @Override\n+            public void registerSubtypes(NamedType... subtypes) {\n+                mapper.registerSubtypes(subtypes);\n+            }\n+            \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                 mapper.addMixInAnnotations(target, mixinSource);\n      *  getJsonFactory().isEnabled(f);\n      *</pre>\n      */\n+    public boolean isEnabled(JsonFactory.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getJsonFactory().isEnabled(f);\n+     *</pre>\n+     */\n     public boolean isEnabled(JsonParser.Feature f) {\n         return _jsonFactory.isEnabled(f);\n     }\n-\n+    \n     /**\n      * Convenience method, equivalent to:\n      *<pre>\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n  * as external identifier\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public final class NamedType\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n package com.fasterxml.jackson.databind.module;\n \n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.Map;\n \n import com.fasterxml.jackson.core.Version;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n \n /**\n  * Simple {@link Module} implementation that allows registration\n      */\n     protected HashMap<Class<?>, Class<?>> _mixins = null;\n     \n+    /**\n+     * Set of subtypes to register, if any.\n+     */\n+    protected LinkedHashSet<NamedType> _subtypes = null;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: creation\n     }\n \n     /**\n+     * Method for adding set of subtypes to be registered with\n+     * {@link ObjectMapper}\n+     * this is an alternative to using annotations in super type to indicate subtypes.\n+     */\n+    public SimpleModule registerSubtypes(Class<?> ... subtypes)\n+    {\n+        if (_subtypes == null) {\n+            _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length));\n+        }\n+        for (Class<?> subtype : subtypes) {\n+            _subtypes.add(new NamedType(subtype));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding set of subtypes (along with type name to use) to be registered with\n+     * {@link ObjectMapper}\n+     * this is an alternative to using annotations in super type to indicate subtypes.\n+     */\n+    public SimpleModule registerSubtypes(NamedType ... subtypes)\n+    {\n+        if (_subtypes == null) {\n+            _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length));\n+        }\n+        for (NamedType subtype : subtypes) {\n+            _subtypes.add(subtype);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n      * Method for specifying that annotations define by <code>mixinClass</code>\n      * should be \"mixed in\" with annotations that <code>targetType</code>\n      * has (as if they were directly included on it!).\n         if (_valueInstantiators != null) {\n             context.addValueInstantiators(_valueInstantiators);\n         }\n+        if (_subtypes != null && _subtypes.size() > 0) {\n+            context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()]));\n+        }\n         if (_mixins != null) {\n             for (Map.Entry<Class<?>,Class<?>> entry : _mixins.entrySet()) {\n                 context.setMixInAnnotations(entry.getKey(), entry.getValue());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n         assertSame(SubC.class, result.value.getClass());\n     }\n \n+    // [JACKSON-748]: also works via modules\n+    public void testSubtypesViaModule() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule();\n+        module.registerSubtypes(SubB.class, SubC.class, SubD.class);\n+        mapper.registerModule(module);\n+        String json = mapper.writeValueAsString(new PropertyBean(new SubC()));\n+        PropertyBean result = mapper.readValue(json, PropertyBean.class);\n+        assertSame(SubC.class, result.value.getClass());\n+    }\n+    \n     public void testSerialization() throws Exception\n     {\n         // serialization can detect type name ok without anything extra:", "timestamp": 1327104471, "metainfo": ""}