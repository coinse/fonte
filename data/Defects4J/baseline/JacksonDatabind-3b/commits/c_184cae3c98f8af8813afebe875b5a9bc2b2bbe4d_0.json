{"sha": "184cae3c98f8af8813afebe875b5a9bc2b2bbe4d", "log": "Implementation of custom object id resolution.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n         }\n         return gen.forScope(objectIdInfo.getScope());\n     }\n-    \n+\n+    public ObjectIdResolver objectIdResolverInstance(Annotated annotated, ObjectIdInfo objectIdInfo)\n+    {\n+        Class<? extends ObjectIdResolver> implClass = objectIdInfo.getResolverType();\n+        final MapperConfig<?> config = getConfig();\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        ObjectIdResolver resolver = (hi == null) ? null : hi.resolverIdGeneratorInstance(config, annotated, implClass);\n+        if (resolver == null) {\n+            resolver = ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers());\n+        }\n+\n+        return resolver;\n+    }\n+\n     /**\n      * Helper method to use to construct a {@link Converter}, given a definition\n      * that may be either actual converter instance, or Class for instantiating one.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      * Method called to find and return entry corresponding to given\n      * Object Id: will add an entry if necessary, and never returns null\n      */\n-    public abstract ReadableObjectId findObjectId(Object id,\n-            ObjectIdGenerator<?> generator);\n+    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver);\n+\n+    @Deprecated\n+    public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator);\n \n     /**\n      * Method called to ensure that every object id encounter during processing\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n package com.fasterxml.jackson.databind.cfg;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n         return null;\n     }\n \n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n+    {\n+        return null;\n+    }\n+\n     /**\n      * Method called to construct a NamingStrategy instance used for specified\n      * class.\n             Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n-        Object pojo = roid.item;\n+        Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n             throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n                 JavaType idType;\n                 SettableBeanProperty idProp;\n                 ObjectIdGenerator<?> idGen;\n+                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                 if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                     PropertyName propName = objectIdInfo.getPropertyName();\n                     idProp = findProperty(propName);\n                 }\n                 JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                 oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n-                \t\tidGen, deser, idProp);\n+                \t\tidGen, deser, idProp, resolver);\n             }\n         }\n         // either way, need to resolve serializer:\n             id = _convertObjectId(jp, ctxt, rawId, idDeser);\n         }\n \n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(pojo);\n         // also: may need to set a property value as well\n         SettableBeanProperty idProp = _objectIdReader.idProperty;\n         throws IOException, JsonProcessingException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n-        Object pojo = roid.item;\n+        Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n             throw new UnresolvedForwardReference(\"Could not resolve Object Id [\"+id+\"] (for \"\n                     +_beanType+\").\", jp.getCurrentLocation(), roid);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n         SettableBeanProperty idProp;\n         ObjectIdGenerator<?> gen;\n \n+        ObjectIdResolver resolver = ctxt.objectIdResolverInstance(beanDesc.getClassInfo(), objectIdInfo);\n+\n         // Just one special case: Property-based generator is trickier\n         if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n             PropertyName propName = objectIdInfo.getPropertyName();\n         // also: unlike with value deserializers, let's just resolve one we need here\n         JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n         builder.setObjectIdReader(ObjectIdReader.construct(idType,\n-                objectIdInfo.getPropertyName(), gen, deser, idProp));\n+                objectIdInfo.getPropertyName(), gen, deser, idProp, resolver));\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n+import java.util.List;\n import java.util.Map.Entry;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n \n     protected transient LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId> _objectIds;\n \n+    private List<ObjectIdResolver> _objectIdResolvers;\n+\n     /**\n      * Constructor that will pass specified deserializer factory and\n      * cache: cache may be null (in which case default implementation\n      */\n \n     @Override\n-    public ReadableObjectId findObjectId(Object id,\n-            ObjectIdGenerator<?> generator)\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolverType)\n     {\n         final ObjectIdGenerator.IdKey key = generator.key(id);\n         if (_objectIds == null) {\n-            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n             ReadableObjectId entry = _objectIds.get(key);\n             if (entry != null) {\n                 return entry;\n             }\n         }\n-        ReadableObjectId entry = new ReadableObjectId(id);\n+\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        } else {\n+            for (ObjectIdResolver res : _objectIdResolvers) {\n+                if (res.canUseFor(resolverType)) {\n+                    resolver = res;\n+                    break;\n+                }\n+            }\n+        }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            _objectIdResolvers.add(resolver);\n+        }\n+\n+        ReadableObjectId entry = new ReadableObjectId(key);\n+        entry.setResolver(resolver);\n         _objectIds.put(key, entry);\n         return entry;\n     }\n     \n     @Override\n-    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n-    {\n-        if(_objectIds == null){\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator)\n+    {\n+        return findObjectId(id, generator, new SimpleObjectIdResolver());\n+    }\n+\n+    @Override\n+    public void checkUnresolvedObjectId()\n+        throws UnresolvedForwardReference\n+    {\n+        if (_objectIds == null) {\n             return;\n         }\n \n         UnresolvedForwardReference exception = null;\n         for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n             ReadableObjectId roid = entry.getValue();\n-            if(roid.hasReferringProperties()){\n-                if(exception == null){\n+            if (roid.hasReferringProperties()) {\n+                if (exception == null) {\n                     exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n                 }\n                 for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext();) {\n                     Referring referring = iterator.next();\n-                    exception.addUnresolvedId(roid.id, referring.getBeanType(), referring.getLocation());\n+                    exception.addUnresolvedId(roid.getKey().key, referring.getBeanType(), referring.getLocation());\n                 }\n             }\n         }\n-        if(exception != null){\n+        if (exception != null) {\n             throw exception;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedForwardReference.java\n     }\n \n     public Object getUnresolvedId() {\n-        return _roid.id;\n+        return _roid.getKey().key;\n     }\n \n     public void addUnresolvedId(Object id, Class<?> type, JsonLocation where) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n      * the key.\n      */\n     public final ObjectIdGenerator<?> generator;\n-    \n+\n+    /**\n+     * \n+     */\n+    public final ObjectIdResolver resolver;\n+\n     /**\n      * Deserializer used for deserializing id values.\n      */\n     \n     @SuppressWarnings(\"unchecked\")\n     protected ObjectIdReader(JavaType t, PropertyName propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n+            JsonDeserializer<?> deser, SettableBeanProperty idProp, ObjectIdResolver resolver)\n     {\n         _idType = t;\n         propertyName = propName;\n         generator = gen;\n+        this.resolver = resolver;\n         _deserializer = (JsonDeserializer<Object>) deser;\n         idProperty = idProp;\n+    }\n+\n+    @Deprecated // since 2.4\n+    protected ObjectIdReader(JavaType t, PropertyName propName, ObjectIdGenerator<?> gen,\n+            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n+    {\n+        this(t,propName, gen, deser, idProp, new SimpleObjectIdResolver());\n     }\n \n     @Deprecated // since 2.3\n      */\n     public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n             ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n+            SettableBeanProperty idProp, ObjectIdResolver resolver)\n+    {\n+        return new ObjectIdReader(idType, propName, generator, deser, idProp, resolver);\n+    }\n+\n+    @Deprecated // since 2.4\n+    public static ObjectIdReader construct(JavaType idType, PropertyName propName,\n+            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n             SettableBeanProperty idProp)\n     {\n-        return new ObjectIdReader(idType, propName, generator, deser, idProp);\n+        return construct(idType, propName, generator, deser, idProp, new SimpleObjectIdResolver());\n     }\n     \n     @Deprecated // since 2.3\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n     {\n         // note: no null checks (unlike usually); deserializer should fail if one found\n         Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         roid.bindItem(instance);\n         // also: may need to set a property value as well\n         SettableBeanProperty idProp = _objectIdReader.idProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n     {\n         if (_objectIdReader != null) {\n             if (_idValue != null) {\n-                ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator);\n+                ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator, _objectIdReader.resolver);\n                 roid.bindItem(bean);\n                 // also: may need to set a property value as well\n                 SettableBeanProperty idProp = _objectIdReader.idProperty;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n import java.util.Iterator;\n import java.util.LinkedList;\n \n+import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.JsonLocation;\n \n /**\n  */\n public class ReadableObjectId\n {\n+    /**\n+     * @deprecated Prefer using {@link #resolve()}, which is able to handle\n+     *             external id resolving mechanism.\n+     */\n+    @Deprecated\n+    public Object item;\n+    @Deprecated\n     public final Object id;\n \n-    public Object item;\n+    private final IdKey _key;\n \n     private LinkedList<Referring> _referringProperties;\n \n+    private ObjectIdResolver _resolver;\n+\n+    @Deprecated\n     public ReadableObjectId(Object id)\n     {\n         this.id = id;\n+        _key = null;\n+    }\n+\n+    public ReadableObjectId(IdKey key)\n+    {\n+        _key = key;\n+        id = key.key;\n+    }\n+\n+    public void setResolver(ObjectIdResolver resolver)\n+    {\n+        _resolver = resolver;\n+    }\n+\n+    public IdKey getKey()\n+    {\n+        return _key;\n     }\n \n     public void appendReferring(Referring currentReferring) {\n      */\n     public void bindItem(Object ob) throws IOException\n     {\n-        if (item != null) {\n-            throw new IllegalStateException(\"Already had POJO for id (\" + id.getClass().getName() + \") [\" + id + \"]\");\n-        }\n+        _resolver.bindItem(_key, ob);\n         item = ob;\n         if (_referringProperties != null) {\n             Iterator<Referring> it = _referringProperties.iterator();\n                 it.next().handleResolvedForwardReference(id, ob);\n             }\n         }\n+    }\n+\n+    public Object resolve(){\n+         return (item = _resolver.resolveId(_key));\n     }\n \n     public boolean hasReferringProperties() {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         }\n         // In future may need to allow passing namespace?\n         PropertyName name = new PropertyName(info.property());\n-        return new ObjectIdInfo(name, info.scope(), info.generator());\n+        return new ObjectIdInfo(name, info.scope(), info.generator(), info.resolver());\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java\n \n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.databind.PropertyName;\n \n /**\n {\n     protected final PropertyName _propertyName;\n     protected final Class<? extends ObjectIdGenerator<?>> _generator;\n+    private final Class<? extends ObjectIdResolver> _resolver;\n     protected final Class<?> _scope;\n     protected final boolean _alwaysAsId;\n \n-    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen) {\n+    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n+            Class<? extends ObjectIdResolver> resolver)\n+    {\n+        this(name, scope, gen, false, resolver);\n+    }\n+\n+    @Deprecated // since 2.4\n+    public ObjectIdInfo(PropertyName name, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen)\n+    {\n         this(name, scope, gen, false);\n     }\n \n     protected ObjectIdInfo(PropertyName prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n             boolean alwaysAsId)\n     {\n+        this(prop, scope, gen, alwaysAsId, SimpleObjectIdResolver.class);\n+\n+    }\n+\n+    protected ObjectIdInfo(PropertyName prop, Class<?> scope, Class<? extends ObjectIdGenerator<?>> gen,\n+            boolean alwaysAsId, Class<? extends ObjectIdResolver> resolver)\n+    {\n         _propertyName = prop;\n         _scope = scope;\n         _generator = gen;\n         _alwaysAsId = alwaysAsId;\n+        _resolver = resolver;\n     }\n \n     public ObjectIdInfo withAlwaysAsId(boolean state) {\n     public PropertyName getPropertyName() { return _propertyName; }\n     public Class<?> getScope() { return _scope; }\n     public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; }\n+    public Class<? extends ObjectIdResolver> getResolverType() { return _resolver; }\n     public boolean getAlwaysAsId() { return _alwaysAsId; }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n                 // no ObjectId override, but maybe ObjectIdRef?\n                 if (oiw != null) {\n                     objectIdInfo = intr.findObjectReferenceInfo(accessor,\n-                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null));\n+                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                     oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n                 }\n             } else {\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n \n import com.fasterxml.jackson.annotation.JsonAnySetter;\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.UnresolvedId;\n import com.fasterxml.jackson.databind.struct.TestObjectId.Company;\n  */\n public class TestObjectIdDeserialization extends BaseMapTest\n {\n+    private static final String POOL_KEY = \"POOL\";\n+\n     // // Classes for external id use\n     \n     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n             // Ensure that it is never called with null because of unresolved reference.\n             assertNotNull(value);\n             values.put(field, value);\n+        }\n+    }\n+\n+    static class CustomResolutionWrapper {\n+        public List<WithCustomResolution> data;\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\", resolver = PoolResolver.class)\n+    static class WithCustomResolution {\n+        public int id;\n+        public int data;\n+\n+        public WithCustomResolution(int id, int data)\n+        {\n+            this.id = id;\n+            this.data = data;\n+        }\n+    }\n+\n+    public static class PoolResolver implements ObjectIdResolver {\n+        private Map<Object,WithCustomResolution> _pool;\n+\n+        public PoolResolver() {}\n+        public PoolResolver(Map<Object,WithCustomResolution> pool){ _pool = pool; }\n+\n+        @Override\n+        public void bindItem(IdKey id, Object pojo){ }\n+\n+        @Override\n+        public Object resolveId(IdKey id){ return _pool.get(id.key); }\n+\n+        @Override\n+        public boolean canUseFor(ObjectIdResolver resolverType)\n+        {\n+            return resolverType.getClass() == getClass() && _pool != null && !_pool.isEmpty();\n+        }\n+        \n+        @Override\n+        public ObjectIdResolver newForDeserialization(Object c)\n+        {\n+            DeserializationContext context = (DeserializationContext)c;\n+            @SuppressWarnings(\"unchecked\")\n+            Map<Object,WithCustomResolution> pool = (Map<Object,WithCustomResolution>)context.getAttribute(POOL_KEY);\n+            return new PoolResolver(pool);\n         }\n     }\n \n         assertSame(result.node, result.node.next.node);\n         assertEquals(3, result.node.customId);\n     }\n+\n+    /*\n+    /*****************************************************\n+    /* Unit tests, custom id resolver\n+    /*****************************************************\n+     */\n+    public void testCustomPoolResolver()\n+        throws Exception\n+    {\n+        Map<Object,WithCustomResolution> pool = new HashMap<Object,WithCustomResolution>();\n+        pool.put(1, new WithCustomResolution(1, 1));\n+        pool.put(2, new WithCustomResolution(2, 2));\n+        pool.put(3, new WithCustomResolution(3, 3));\n+        pool.put(4, new WithCustomResolution(4, 4));\n+        pool.put(5, new WithCustomResolution(5, 5));\n+        ContextAttributes attrs = mapper.getDeserializationConfig().getAttributes().withSharedAttribute(POOL_KEY, pool);\n+        String content = \"{\\\"data\\\":[1,2,3,4,5]}\";\n+        CustomResolutionWrapper wrapper = mapper.reader(CustomResolutionWrapper.class).with(attrs).readValue(content);\n+        assertFalse(wrapper.data.isEmpty());\n+        for (WithCustomResolution ob : wrapper.data) {\n+            assertSame(pool.get(ob.id), ob);\n+        }\n+    }\n }", "timestamp": 1392047956, "metainfo": ""}