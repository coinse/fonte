{"sha": "cb65c7691fc5dc710f9b482cb6de63d0bf2a5d0b", "log": "Assimilate JavaType deserializer as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         throws JsonMappingException\n     {\n         Class<?> rawType = type.getRawClass();\n+        // Object (\"untyped\"), String equivalents:\n+        if (rawType == CLASS_OBJECT) {\n+            return new UntypedObjectDeserializer();\n+        }\n+        if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n+            return StringDeserializer.instance;\n+        }\n+        if (rawType == CLASS_ITERABLE) {\n+            // [Issue#199]: Can and should 'upgrade' to a Collection type:\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+            CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n+            // Should we re-introspect beanDesc? For now let's not...\n+            return createCollectionDeserializer(ctxt, ct, beanDesc);\n+        }\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n-            // Object (\"untyped\"), String equivalents:\n-            if (rawType == CLASS_OBJECT) {\n-                return new UntypedObjectDeserializer();\n-            }\n-            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n-                return StringDeserializer.instance;\n-            }\n-            if (rawType == CLASS_ITERABLE) {\n-                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n-                TypeFactory tf = ctxt.getTypeFactory();\n-                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n-                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n-                // Should we re-introspect beanDesc? For now let's not...\n-                return createCollectionDeserializer(ctxt, ct, beanDesc);\n-            }\n             // Primitives/wrappers, other Numbers:\n             JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n             if (deser == null) {\n                 deser = DateDeserializers.find(rawType, clsName);\n-                if (deser == null) {\n-                    deser = JdkDeserializers.find(rawType, clsName);\n-                }\n-            }\n-            return deser;\n-        }\n-        if (clsName.startsWith(\"com.fasterxml.\")) {\n-            // and a few Jackson types as well:\n-            if (rawType == TokenBuffer.class) {\n-                return new TokenBufferDeserializer();\n-            }\n-            if (JavaType.class.isAssignableFrom(rawType)) {\n-                return new JavaTypeDeserializer();\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \n+            }\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        // and a few Jackson types as well:\n+        if (rawType == TokenBuffer.class) {\n+            return new TokenBufferDeserializer();\n+        }\n+        return JdkDeserializers.find(rawType, clsName);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n {\n     public static Class<?>[] types() {\n         return new Class<?>[] {\n+            File.class,\n             URL.class,\n             URI.class,\n             Class.class,\n-            File.class,\n+            JavaType.class,\n             Currency.class,\n             Pattern.class,\n             Locale.class,\n             kind = Std.STD_URI;\n         } else if (rawType == Class.class) {\n             kind = Std.STD_CLASS;\n+        } else if (rawType == JavaType.class) {\n+            kind = Std.STD_JAVA_TYPE;\n         } else if (rawType == Currency.class) {\n             kind = Std.STD_CURRENCY;\n         } else if (rawType == Pattern.class) {\n         public final static int STD_URL = 2;\n         public final static int STD_URI = 3;\n         public final static int STD_CLASS = 4;\n-        public final static int STD_CURRENCY = 5;\n-        public final static int STD_PATTERN = 6;\n-        public final static int STD_LOCALE = 7;\n-        public final static int STD_CHARSET = 8;\n-        public final static int STD_INET_ADDRESS = 9;\n-        public final static int STD_INET_SOCKET_ADDRESS = 10;\n+        public final static int STD_JAVA_TYPE = 5;\n+        public final static int STD_CURRENCY = 6;\n+        public final static int STD_PATTERN = 7;\n+        public final static int STD_LOCALE = 8;\n+        public final static int STD_CHARSET = 9;\n+        public final static int STD_INET_ADDRESS = 10;\n+        public final static int STD_INET_SOCKET_ADDRESS = 11;\n         \n         protected final int _kind;\n         \n                 } catch (Exception e) {\n                     throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                 }\n+            case STD_JAVA_TYPE:\n+                return ctxt.getTypeFactory().constructFromCanonical(value);\n             case STD_CURRENCY:\n                 // will throw IAE if unknown:\n                 return Currency.getInstance(value);", "timestamp": 1388611511, "metainfo": ""}