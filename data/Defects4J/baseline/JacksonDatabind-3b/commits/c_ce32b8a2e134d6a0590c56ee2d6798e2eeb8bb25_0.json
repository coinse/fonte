{"sha": "ce32b8a2e134d6a0590c56ee2d6798e2eeb8bb25", "log": "Further refactoring for DeserializerFactories", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n         }\n         return null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n-    /* JsonDeserializerFactory impl (partial)\n-    /**********************************************************\n-     */\n-\n+    /* JsonDeserializerFactory impl (partial): type mappings\n+    /**********************************************************\n+     */\n+\n+    public JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException\n+    {\n+        // first, general mappings\n+        while (true) {\n+            JavaType next = _mapAbstractType2(config, type);\n+            if (next == null) {\n+                return type;\n+            }\n+            /* Should not have to worry about cycles; but better verify since they will invariably\n+             * occur... :-)\n+             * (also: guard against invalid resolution to a non-related type)\n+             */\n+            Class<?> prevCls = type.getRawClass();\n+            Class<?> nextCls = next.getRawClass();\n+            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n+                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n+            }\n+            type = next;\n+        }\n+    }\n+\n+    /**\n+     * Method that will find abstract type mapping for specified type, doing a single\n+     * lookup through registered abstract type resolvers; will not do recursive lookups.\n+     */\n+    private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException\n+    {\n+        Class<?> currClass = type.getRawClass();\n+        if (_factoryConfig.hasAbstractTypeResolvers()) {\n+            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n+                JavaType concrete = resolver.findTypeMapping(config, type);\n+                if (concrete != null && concrete.getRawClass() != currClass) {\n+                    return concrete;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializerFactory impl (partial): ValueInstantiators\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Value instantiator is created both based on creator annotations,\n+     * and on optional externally provided instantiators (registered through\n+     * module interface).\n+     */\n     @Override\n-    public abstract ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n+    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n             BeanDescription beanDesc)\n-        throws JsonMappingException;\n-\n-    @Override\n-    public abstract JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n-            throws JsonMappingException;\n-    \n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        ValueInstantiator instantiator = null;\n+        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n+        if (instDef != null) {\n+            instantiator = _valueInstantiatorInstance(config, ac, instDef);\n+        }\n+        if (instantiator == null) {\n+            /* Second: see if some of standard Jackson/JDK types might provide value\n+             * instantiators.\n+             */\n+            instantiator = _findStdValueInstantiator(config, beanDesc);\n+            if (instantiator == null) {\n+                instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc);\n+            }\n+        }\n+        \n+        // finally: anyone want to modify ValueInstantiator?\n+        if (_factoryConfig.hasValueInstantiators()) {\n+            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n+                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n+                // let's do sanity check; easier to spot buggy handlers\n+                if (instantiator == null) {\n+                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n+                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n+                }\n+            }\n+        }\n+        \n+        return instantiator;\n+    }\n+\n+    private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config,\n+            BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return JacksonDeserializers.findValueInstantiator(config, beanDesc);\n+    }\n+\n+    /**\n+     * Method that will construct standard default {@link ValueInstantiator}\n+     * using annotations (like @JsonCreator) and visibility rules\n+     */\n+    protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt,\n+            BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n+        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        \n+        // First, let's figure out constructor/factory-based instantiation\n+        // 23-Jan-2010, tatus: but only for concrete types\n+        if (beanDesc.getType().isConcrete()) {\n+            AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n+            if (defaultCtor != null) {\n+                if (fixAccess) {\n+                    ClassUtil.checkAndFixAccess(defaultCtor.getAnnotated());\n+                }\n+                creators.setDefaultConstructor(defaultCtor);\n+            }\n+        }\n+\n+        // need to construct suitable visibility checker:\n+        final DeserializationConfig config = ctxt.getConfig();\n+        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n+        vchecker = config.getAnnotationIntrospector().findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n+\n+        /* Important: first add factory methods; then constructors, so\n+         * latter can override former!\n+         */\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n+        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n+\n+        return creators.constructValueInstantiator(config);\n+    }\n+\n+    public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n+            Annotated annotated, Object instDef)\n+        throws JsonMappingException\n+    {\n+        if (instDef == null) {\n+            return null;\n+        }\n+\n+        ValueInstantiator inst;\n+        \n+        if (instDef instanceof ValueInstantiator) {\n+            inst = (ValueInstantiator) instDef;\n+        } else {\n+            if (!(instDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n+                        +instDef.getClass().getName()\n+                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n+            }\n+            Class<?> instClass = (Class<?>)instDef;\n+            if (instClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n+                        +\"; expected Class<ValueInstantiator>\");\n+            }\n+            HandlerInstantiator hi = config.getHandlerInstantiator();\n+            if (hi != null) {\n+                inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n+            } else {\n+                inst = (ValueInstantiator) ClassUtil.createInstance(instClass,\n+                        config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // not resolvable or contextual, just return:\n+        return inst;\n+    }\n+    \n+    protected void _addDeserializerConstructors\n+        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+         AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n+            int argCount = ctor.getParameterCount();\n+            if (argCount < 1) {\n+                continue;\n+            }\n+            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n+            // some single-arg constructors (String, number) are auto-detected\n+            if (argCount == 1) {\n+                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n+                        ctor, isCreator, isVisible);\n+                continue;\n+            }\n+            if (!isCreator && !isVisible) {\n+                continue;\n+            }\n+            // [JACKSON-541] improved handling a bit so:\n+            // 2 or more args; all params must have name annotations\n+            // ... or @JacksonInject (or equivalent)\n+            /* [JACKSON-711] One more possibility; can have 1 or more injectables, and\n+             * exactly one non-annotated parameter: if so, it's still delegating.\n+             */\n+            AnnotatedParameter nonAnnotatedParam = null;\n+            int namedCount = 0;\n+            int injectCount = 0;\n+            CreatorProperty[] properties = new CreatorProperty[argCount];\n+            for (int i = 0; i < argCount; ++i) {\n+                AnnotatedParameter param = ctor.getParameter(i);\n+                String name = (param == null) ? null : intr.findDeserializationName(param);\n+                Object injectId = intr.findInjectableValueId(param);\n+                if (name != null && name.length() > 0) {\n+                    ++namedCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                } else if (injectId != null) {\n+                    ++injectCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                } else if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+\n+            // Ok: if named or injectable, we have more work to do\n+            if (isCreator || namedCount > 0 || injectCount > 0) {\n+                // simple case; everything covered:\n+                if ((namedCount + injectCount) == argCount) {\n+                    creators.addPropertyCreator(ctor, properties);\n+                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n+                    creators.addDelegatingCreator(ctor, properties);\n+                } else { // otherwise, epic fail\n+                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n+            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators,\n+            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n+        throws JsonMappingException\n+    {\n+        // note: if we do have parameter name, it'll be \"property constructor\":\n+        AnnotatedParameter param = ctor.getParameter(0);\n+        String name = intr.findDeserializationName(param);\n+        Object injectId = intr.findInjectableValueId(param);\n+    \n+        if ((injectId != null) || (name != null && name.length() > 0)) { // property-based\n+            // We know there's a name and it's only 1 parameter.\n+            CreatorProperty[] properties = new CreatorProperty[1];\n+            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n+            creators.addPropertyCreator(ctor, properties);\n+            return true;\n+        }\n+    \n+        // otherwise either 'simple' number, String, or general delegate:\n+        Class<?> type = ctor.getRawParameterType(0);\n+        if (type == String.class) {\n+            if (isCreator || isVisible) {\n+                creators.addStringCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == int.class || type == Integer.class) {\n+            if (isCreator || isVisible) {\n+                creators.addIntCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == long.class || type == Long.class) {\n+            if (isCreator || isVisible) {\n+                creators.addLongCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == double.class || type == Double.class) {\n+            if (isCreator || isVisible) {\n+                creators.addDoubleCreator(ctor);\n+            }\n+            return true;\n+        }\n+    \n+        // Delegating Creator ok iff it has @JsonCreator (etc)\n+        if (isCreator) {\n+            creators.addDelegatingCreator(ctor, null);\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    protected void _addDeserializerFactoryMethods\n+        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+         AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n+            int argCount = factory.getParameterCount();\n+            if (argCount < 1) {\n+                continue;\n+            }\n+            boolean isCreator = intr.hasCreatorAnnotation(factory);\n+            // some single-arg factory methods (String, number) are auto-detected\n+            if (argCount == 1) {\n+                AnnotatedParameter param = factory.getParameter(0);\n+                String name = intr.findDeserializationName(param);\n+                Object injectId = intr.findInjectableValueId(param);\n+\n+                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n+                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n+                            factory, isCreator);\n+                    // otherwise just ignored\n+                    continue;\n+                }\n+                // fall through if there's name\n+            } else {\n+                // more than 2 args, must be @JsonCreator\n+                if (!intr.hasCreatorAnnotation(factory)) {\n+                    continue;\n+                }\n+            }\n+            // 1 or more args; all params must have name annotations\n+            AnnotatedParameter nonAnnotatedParam = null;            \n+            CreatorProperty[] properties = new CreatorProperty[argCount];\n+            int namedCount = 0;\n+            int injectCount = 0;            \n+            for (int i = 0; i < argCount; ++i) {\n+                AnnotatedParameter param = factory.getParameter(i);\n+                String name = intr.findDeserializationName(param);\n+                Object injectId = intr.findInjectableValueId(param);\n+                if (name != null && name.length() > 0) {\n+                    ++namedCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                } else if (injectId != null) {\n+                    ++injectCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                } else if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+\n+            // Ok: if named or injectable, we have more work to do\n+            if (isCreator || namedCount > 0 || injectCount > 0) {\n+                // simple case; everything covered:\n+                if ((namedCount + injectCount) == argCount) {\n+                    creators.addPropertyCreator(factory, properties);\n+                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n+                    creators.addDelegatingCreator(factory, properties);\n+                } else { // otherwise, epic fail\n+                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n+                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n+            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators,\n+            AnnotatedMethod factory, boolean isCreator)\n+        throws JsonMappingException\n+    {\n+        Class<?> type = factory.getRawParameterType(0);\n+        \n+        if (type == String.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addStringCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == int.class || type == Integer.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addIntCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == long.class || type == Long.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addLongCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == double.class || type == Double.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addDoubleCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == boolean.class || type == Boolean.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addBooleanCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (intr.hasCreatorAnnotation(factory)) {\n+            creators.addDelegatingCreator(factory, null);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Method that will construct a property object that represents\n+     * a logical property passed via Creator (constructor or static\n+     * factory method)\n+     */\n+    protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt,\n+            BeanDescription beanDesc, String name, int index,\n+            AnnotatedParameter param,\n+            Object injectableValueId)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n+        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), param);\n+        JavaType type = resolveType(ctxt, beanDesc, t0, param, property);\n+        if (type != t0) {\n+            property = property.withType(type);\n+        }\n+        // Is there an annotation that specifies exact deserializer?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param, property);\n+        // If yes, we are mostly done:\n+        type = modifyTypeByAnnotation(ctxt, param, type, property);\n+\n+        // Type deserializer: either comes from property (and already resolved)\n+        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n+        // or if not, based on type being referenced:\n+        if (typeDeser == null) {\n+            typeDeser = findTypeDeserializer(config, type, property);\n+        }\n+        CreatorProperty prop = new CreatorProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), param, index, injectableValueId);\n+        if (deser != null) {\n+            prop = prop.withValueDeserializer(deser);\n+        }\n+        return prop;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializerFactory impl (partial): actual\n+    /* deserializer factory methods\n+    /**********************************************************\n+     */\n+        \n     @Override\n     public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n             ArrayType type, final BeanDescription beanDesc, BeanProperty property)\n         }\n         return null;\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializerFactory impl (partial): type deserializers\n+    /**********************************************************\n+     */\n+\n     @Override\n     public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType,\n             BeanProperty property)\n         return b.buildTypeDeserializer(config, baseType, subtypes, property);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializerFactory impl (partial): key deserializers\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n     \n     /*\n     /**********************************************************\n+    /* Helper methods, factories\n+    /**********************************************************\n+     */\n+\n+    /*\n+    /**********************************************************\n     /* Helper methods, value/content/key type introspection\n     /**********************************************************\n      */\n         return ctxt.deserializerInstance(ann, property, deserDef);\n     }\n \n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     * @param prop property that refers to type, if any; null\n+     *   if no property information available (when modify type declaration\n+     *   of a class, for example)\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    @SuppressWarnings({ \"unchecked\" })\n+    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, T type, BeanProperty prop)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type,\n+                (prop == null) ? null : prop.getName());\n+        if (subclass != null) {\n+            try {\n+                type = (T) type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(),\n+                    (prop == null) ? null : prop.getName());\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType = type.getKeyType(); // just in case it's used below\n+                }\n+            }            \n+           \n+           // and finally content class; only applicable to structured types\n+           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(),\n+                   (prop == null) ? null : prop.getName());\n+           if (cc != null) {\n+               try {\n+                   type = (T) type.narrowContentsBy(cc);\n+               } catch (IllegalArgumentException iae) {\n+                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+               }\n+           }\n+           // ... as well as deserializer for contents:\n+           JavaType contentType = type.getContentType();\n+           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+               Object cdDef = intr.findContentDeserializer(a);\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, prop, cdDef);\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+    \n     /**\n      * Helper method used to resolve method return types and field\n      * types. The main trick here is that the containing bean may\n     \treturn type;\n     }\n     \n-    public ValueInstantiator valueInstantiatorInstance(DeserializationConfig config,\n-            Annotated annotated, Object instDef)\n-        throws JsonMappingException\n-    {\n-        if (instDef == null) {\n-            return null;\n-        }\n-\n-        ValueInstantiator inst;\n-        \n-        if (instDef instanceof ValueInstantiator) {\n-            inst = (ValueInstantiator) instDef;\n-        } else {\n-            if (!(instDef instanceof Class)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n-                        +instDef.getClass().getName()\n-                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n-            }\n-            Class<?> instClass = (Class<?>)instDef;\n-            if (instClass == NoClass.class) {\n-                return null;\n-            }\n-            if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n-                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n-                        +\"; expected Class<ValueInstantiator>\");\n-            }\n-            HandlerInstantiator hi = config.getHandlerInstantiator();\n-            if (hi != null) {\n-                inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n-            } else {\n-                inst = (ValueInstantiator) ClassUtil.createInstance(instClass,\n-                        config.canOverrideAccessModifiers());\n-            }\n-        }\n-        // not resolvable or contextual, just return:\n-        return inst;\n-    }\n-    \n     protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config,\n             AnnotatedMethod jsonValueMethod)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n-import com.fasterxml.jackson.databind.deser.std.JacksonDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n      */\n \n     /**\n-     * Method that will find complete abstract type mapping for specified type, doing as\n-     * many resolution steps as necessary.\n-     */\n-    @Override\n-    public JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n-        throws JsonMappingException\n-    {\n-        // first, general mappings\n-        while (true) {\n-            JavaType next = _mapAbstractType2(config, type);\n-            if (next == null) {\n-                return type;\n-            }\n-            /* Should not have to worry about cycles; but better verify since they will invariably\n-             * occur... :-)\n-             * (also: guard against invalid resolution to a non-related type)\n-             */\n-            Class<?> prevCls = type.getRawClass();\n-            Class<?> nextCls = next.getRawClass();\n-            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n-                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n-            }\n-            type = next;\n-        }\n-    }\n-    \n-    /**\n-     * Value instantiator is created both based on creator annotations,\n-     * and on optional externally provided instantiators (registered through\n-     * module interface).\n-     */\n-    @Override\n-    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        final DeserializationConfig config = ctxt.getConfig();\n-\n-        ValueInstantiator instantiator = null;\n-        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n-        AnnotatedClass ac = beanDesc.getClassInfo();\n-        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n-        if (instDef != null) {\n-            instantiator = valueInstantiatorInstance(config, ac, instDef);\n-        }\n-        if (instantiator == null) {\n-            /* Second: see if some of standard Jackson/JDK types might provide value\n-             * instantiators.\n-             */\n-            instantiator = findStdValueInstantiator(config, beanDesc);\n-            if (instantiator == null) {\n-                instantiator = constructDefaultValueInstantiator(ctxt, beanDesc);\n-            }\n-        }\n-        \n-        // finally: anyone want to modify ValueInstantiator?\n-        if (_factoryConfig.hasValueInstantiators()) {\n-            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n-                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n-                // let's do sanity check; easier to spot buggy handlers\n-                if (instantiator == null) {\n-                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n-                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n-                }\n-            }\n-        }\n-        \n-        return instantiator;\n-    }\n-\n-    /**\n      * Method that {@link DeserializerCache}s call to create a new\n      * deserializer for types other than Collections, Maps, arrays and\n      * enums.\n         }\n         // Use generic bean introspection to build deserializer\n         return buildBeanDeserializer(ctxt, type, beanDesc, property);\n-    }\n-\n-    /**\n-     * Method that will find abstract type mapping for specified type, doing a single\n-     * lookup through registered abstract type resolvers; will not do recursive lookups.\n-     */\n-    protected JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n-        throws JsonMappingException\n-    {\n-        Class<?> currClass = type.getRawClass();\n-        if (_factoryConfig.hasAbstractTypeResolvers()) {\n-            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n-                JavaType concrete = resolver.findTypeMapping(config, type);\n-                if (concrete != null && concrete.getRawClass() != currClass) {\n-                    return concrete;\n-                }\n-            }\n-        }\n-        return null;\n     }\n     \n     protected JavaType materializeAbstractType(DeserializationConfig config,\n      */\n     protected BeanDeserializerBuilder constructBeanDeserializerBuilder(BeanDescription beanDesc) {\n         return new BeanDeserializerBuilder(beanDesc);\n-    }\n-\n-    protected ValueInstantiator findStdValueInstantiator(DeserializationConfig config,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        return JacksonDeserializers.findValueInstantiator(config, beanDesc);\n-    }\n-    \n-    /**\n-     * Method that will construct standard default {@link ValueInstantiator}\n-     * using annotations (like @JsonCreator) and visibility rules\n-     */\n-    protected ValueInstantiator constructDefaultValueInstantiator(DeserializationContext ctxt,\n-            BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n-        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n-        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-        \n-        // First, let's figure out constructor/factory-based instantiation\n-        // 23-Jan-2010, tatus: but only for concrete types\n-        if (beanDesc.getType().isConcrete()) {\n-            AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n-            if (defaultCtor != null) {\n-                if (fixAccess) {\n-                    ClassUtil.checkAndFixAccess(defaultCtor.getAnnotated());\n-                }\n-                creators.setDefaultConstructor(defaultCtor);\n-            }\n-        }\n-\n-        // need to construct suitable visibility checker:\n-        final DeserializationConfig config = ctxt.getConfig();\n-        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n-        vchecker = config.getAnnotationIntrospector().findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n-\n-        /* Important: first add factory methods; then constructors, so\n-         * latter can override former!\n-         */\n-        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n-        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n-\n-        return creators.constructValueInstantiator(config);\n-    }\n-\n-    protected void _addDeserializerConstructors\n-        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n-        throws JsonMappingException\n-    {\n-        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n-            int argCount = ctor.getParameterCount();\n-            if (argCount < 1) {\n-                continue;\n-            }\n-            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n-            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n-            // some single-arg constructors (String, number) are auto-detected\n-            if (argCount == 1) {\n-                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n-                        ctor, isCreator, isVisible);\n-                continue;\n-            }\n-            if (!isCreator && !isVisible) {\n-            \tcontinue;\n-            }\n-            // [JACKSON-541] improved handling a bit so:\n-            // 2 or more args; all params must have name annotations\n-            // ... or @JacksonInject (or equivalent)\n-            /* [JACKSON-711] One more possibility; can have 1 or more injectables, and\n-             * exactly one non-annotated parameter: if so, it's still delegating.\n-             */\n-            AnnotatedParameter nonAnnotatedParam = null;\n-            int namedCount = 0;\n-            int injectCount = 0;\n-            CreatorProperty[] properties = new CreatorProperty[argCount];\n-            for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                String name = (param == null) ? null : intr.findDeserializationName(param);\n-                Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.length() > 0) {\n-                    ++namedCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) {\n-                    ++injectCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (nonAnnotatedParam == null) {\n-                    nonAnnotatedParam = param;\n-                }\n-            }\n-\n-            // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n-                // simple case; everything covered:\n-                if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(ctor, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n-                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(ctor, properties);\n-                } else { // otherwise, epic fail\n-                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n-                }\n-            }\n-        }\n-    }\n-\n-    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-            AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n-        throws JsonMappingException\n-    {\n-        // note: if we do have parameter name, it'll be \"property constructor\":\n-        AnnotatedParameter param = ctor.getParameter(0);\n-        String name = intr.findDeserializationName(param);\n-        Object injectId = intr.findInjectableValueId(param);\n-    \n-        if ((injectId != null) || (name != null && name.length() > 0)) { // property-based\n-            // We know there's a name and it's only 1 parameter.\n-            CreatorProperty[] properties = new CreatorProperty[1];\n-            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n-            creators.addPropertyCreator(ctor, properties);\n-            return true;\n-        }\n-    \n-        // otherwise either 'simple' number, String, or general delegate:\n-        Class<?> type = ctor.getRawParameterType(0);\n-        if (type == String.class) {\n-            if (isCreator || isVisible) {\n-                creators.addStringCreator(ctor);\n-            }\n-            return true;\n-        }\n-        if (type == int.class || type == Integer.class) {\n-            if (isCreator || isVisible) {\n-                creators.addIntCreator(ctor);\n-            }\n-            return true;\n-        }\n-        if (type == long.class || type == Long.class) {\n-            if (isCreator || isVisible) {\n-                creators.addLongCreator(ctor);\n-            }\n-            return true;\n-        }\n-        if (type == double.class || type == Double.class) {\n-            if (isCreator || isVisible) {\n-                creators.addDoubleCreator(ctor);\n-            }\n-            return true;\n-        }\n-    \n-        // Delegating Creator ok iff it has @JsonCreator (etc)\n-        if (isCreator) {\n-            creators.addDelegatingCreator(ctor, null);\n-            return true;\n-        }\n-        return false;\n-    }\n-    \n-    protected void _addDeserializerFactoryMethods\n-        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n-        throws JsonMappingException\n-    {\n-        final DeserializationConfig config = ctxt.getConfig();\n-        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n-            int argCount = factory.getParameterCount();\n-            if (argCount < 1) {\n-                continue;\n-            }\n-            boolean isCreator = intr.hasCreatorAnnotation(factory);\n-            // some single-arg factory methods (String, number) are auto-detected\n-            if (argCount == 1) {\n-                AnnotatedParameter param = factory.getParameter(0);\n-                String name = intr.findDeserializationName(param);\n-                Object injectId = intr.findInjectableValueId(param);\n-\n-                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n-                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n-                            factory, isCreator);\n-                    // otherwise just ignored\n-                    continue;\n-                }\n-                // fall through if there's name\n-            } else {\n-                // more than 2 args, must be @JsonCreator\n-                if (!intr.hasCreatorAnnotation(factory)) {\n-                    continue;\n-                }\n-            }\n-            // 1 or more args; all params must have name annotations\n-            AnnotatedParameter nonAnnotatedParam = null;            \n-            CreatorProperty[] properties = new CreatorProperty[argCount];\n-            int namedCount = 0;\n-            int injectCount = 0;            \n-            for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = factory.getParameter(i);\n-                String name = intr.findDeserializationName(param);\n-                Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.length() > 0) {\n-                    ++namedCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) {\n-                    ++injectCount;\n-                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (nonAnnotatedParam == null) {\n-                    nonAnnotatedParam = param;\n-                }\n-            }\n-\n-            // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n-                // simple case; everything covered:\n-                if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(factory, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n-                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(factory, properties);\n-                } else { // otherwise, epic fail\n-                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n-                            +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n-                }\n-            }\n-        }\n-    }\n-\n-    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n-            BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-            AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedMethod factory, boolean isCreator)\n-        throws JsonMappingException\n-    {\n-        Class<?> type = factory.getRawParameterType(0);\n-        \n-        if (type == String.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addStringCreator(factory);\n-            }\n-            return true;\n-        }\n-        if (type == int.class || type == Integer.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addIntCreator(factory);\n-            }\n-            return true;\n-        }\n-        if (type == long.class || type == Long.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addLongCreator(factory);\n-            }\n-            return true;\n-        }\n-        if (type == double.class || type == Double.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addDoubleCreator(factory);\n-            }\n-            return true;\n-        }\n-        if (type == boolean.class || type == Boolean.class) {\n-            if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addBooleanCreator(factory);\n-            }\n-            return true;\n-        }\n-        if (intr.hasCreatorAnnotation(factory)) {\n-            creators.addDelegatingCreator(factory, null);\n-            return true;\n-        }\n-        return false;\n-    }\n-    \n-    /**\n-     * Method that will construct a property object that represents\n-     * a logical property passed via Creator (constructor or static\n-     * factory method)\n-     */\n-    protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt,\n-            BeanDescription beanDesc, String name, int index,\n-            AnnotatedParameter param,\n-            Object injectableValueId)\n-        throws JsonMappingException\n-    {\n-        final DeserializationConfig config = ctxt.getConfig();\n-        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n-        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), param);\n-        JavaType type = resolveType(ctxt, beanDesc, t0, param, property);\n-        if (type != t0) {\n-            property = property.withType(type);\n-        }\n-        // Is there an annotation that specifies exact deserializer?\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param, property);\n-        // If yes, we are mostly done:\n-        type = modifyTypeByAnnotation(ctxt, param, type, property);\n-\n-        // Type deserializer: either comes from property (and already resolved)\n-        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n-        // or if not, based on type being referenced:\n-        if (typeDeser == null) {\n-            typeDeser = findTypeDeserializer(config, type, property);\n-        }\n-        CreatorProperty prop = new CreatorProperty(name, type, typeDeser,\n-                beanDesc.getClassAnnotations(), param, index, injectableValueId);\n-        if (deser != null) {\n-            prop = prop.withValueDeserializer(deser);\n-        }\n-        return prop;\n     }\n     \n     /**\n      */\n     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanPropertyDefinition propDef,\n-            /*\n-            String name,\n-            AnnotatedMember setter,\n-            */\n             Type jdkType)\n         throws JsonMappingException\n     {\n         }\n         return status;\n     }\n-\n-    /**\n-     * Method called to see if given method has annotations that indicate\n-     * a more specific type than what the argument specifies.\n-     * If annotations are present, they must specify compatible Class;\n-     * instance of which can be assigned using the method. This means\n-     * that the Class has to be raw class of type, or its sub-class\n-     * (or, implementing class if original Class instance is an interface).\n-     *\n-     * @param a Method or field that the type is associated with\n-     * @param type Type derived from the setter argument\n-     * @param prop property that refers to type, if any; null\n-     *   if no property information available (when modify type declaration\n-     *   of a class, for example)\n-     *\n-     * @return Original type if no annotations are present; or a more\n-     *   specific type derived from it if type annotation(s) was found\n-     *\n-     * @throws JsonMappingException if invalid annotation is found\n-     */\n-    @SuppressWarnings({ \"unchecked\" })\n-    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n-            Annotated a, T type, BeanProperty prop)\n-        throws JsonMappingException\n-    {\n-        // first: let's check class for the instance itself:\n-        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-        Class<?> subclass = intr.findDeserializationType(a, type,\n-                (prop == null) ? null : prop.getName());\n-        if (subclass != null) {\n-            try {\n-                type = (T) type.narrowBy(subclass);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n-            }\n-        }\n-\n-        // then key class\n-        if (type.isContainerType()) {\n-            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(),\n-                    (prop == null) ? null : prop.getName());\n-            if (keyClass != null) {\n-                // illegal to use on non-Maps\n-                if (!(type instanceof MapLikeType)) {\n-                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n-                }\n-                try {\n-                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n-                }\n-            }\n-            JavaType keyType = type.getKeyType();\n-            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n-             *   (not 100% why or how, but this does seem to get called more than once, which\n-             *   is not good: for now, let's just avoid errors)\n-             */\n-            if (keyType != null && keyType.getValueHandler() == null) {\n-                Object kdDef = intr.findKeyDeserializer(a);\n-                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, prop, kdDef);\n-                if (kd != null) {\n-                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                    keyType = type.getKeyType(); // just in case it's used below\n-                }\n-            }            \n-           \n-           // and finally content class; only applicable to structured types\n-           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(),\n-                   (prop == null) ? null : prop.getName());\n-           if (cc != null) {\n-               try {\n-                   type = (T) type.narrowContentsBy(cc);\n-               } catch (IllegalArgumentException iae) {\n-                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n-               }\n-           }\n-           // ... as well as deserializer for contents:\n-           JavaType contentType = type.getContentType();\n-           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n-               Object cdDef = intr.findContentDeserializer(a);\n-                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, prop, cdDef);\n-                if (cd != null) {\n-                    type = (T) type.withContentValueHandler(cd);\n-                }\n-            }\n-        }\n-        return type;\n-    }\n }", "timestamp": 1327612942, "metainfo": ""}