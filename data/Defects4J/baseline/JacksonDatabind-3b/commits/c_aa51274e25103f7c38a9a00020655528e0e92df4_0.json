{"sha": "aa51274e25103f7c38a9a00020655528e0e92df4", "log": "Implemented [JACKSON-435], using @JsonFormat for Dates, Calendars", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.ISO8601Utils;\n import com.fasterxml.jackson.databind.util.LinkedNode;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n \n      * owners (<code>ObjectMapper</code>, <code>ObjectReader</code>)\n      * access it.\n      */\n-    public final DeserializerFactory _factory;\n+    protected final DeserializerFactory _factory;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Locale used for formatting purposes.\n+     */\n+    protected Locale _locale;\n+\n+    /**\n+     * Timezone to use as the default; if not specified, will\n+     * default to GMT\n+     */\n+    protected TimeZone _timezone;\n \n     /*\n     /**********************************************************\n         _parser = jp;\n         _injectableValues = injectableValues;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, mutators\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.0\n+     */\n+    public void setLocale(Locale l) {\n+        _locale = l;\n+    }\n+    \n+    /**\n+     * @since 2.0\n+     */\n+    public void setTimeZone(TimeZone tz) {\n+        _timezone = tz;\n+    }\n     \n     /*\n     /**********************************************************\n         return _config.getTypeFactory();\n     }\n \n+    /**\n+     * Method for accessing default Locale to use; can be overridden.\n+     */\n+    public Locale getLocale() {\n+        if (_locale != null) {\n+            return _locale;\n+        }\n+        return Locale.getDefault();\n+    }\n+\n+    public TimeZone getTimeZone() {\n+        if (_timezone != null) {\n+            return _timezone;\n+        }\n+        return ISO8601Utils.timeZoneGMT();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, pass-through to DeserializerCache\n     {\n         try {\n             return getDateFormat().parse(dateStr);\n-        } catch (ParseException pex) {\n-            throw new IllegalArgumentException(pex.getMessage());\n+        } catch (ParseException e) {\n+            throw new IllegalArgumentException(\"Failed to parse Date value '\"+dateStr+\"': \"+e.getMessage());\n         }\n     }\n \n         /* 08-Jan-2008, tatu: not optimal, but should work for the\n          *   most part; let's revise as needed.\n          */\n-        Calendar c = Calendar.getInstance();\n+        Calendar c = Calendar.getInstance(getTimeZone());\n         c.setTime(d);\n         return c;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n      * thread-safe when configuring methods (such as this one) are NOT called.\n      */\n-    public void setDateFormat(DateFormat dateFormat)\n+    public ObjectMapper setDateFormat(DateFormat dateFormat)\n     {\n         _deserializationConfig = _deserializationConfig.withDateFormat(dateFormat);\n         _serializationConfig = _serializationConfig.withDateFormat(dateFormat);\n+        return this;\n     }\n \n     /**\n      *\n      * @param hi Instantiator to use; if null, use the default implementation\n      */\n-    public void setHandlerInstantiator(HandlerInstantiator hi)\n+    public Object setHandlerInstantiator(HandlerInstantiator hi)\n     {\n         _deserializationConfig = _deserializationConfig.withHandlerInstantiator(hi);\n         _serializationConfig = _serializationConfig.withHandlerInstantiator(hi);\n+        return this;\n     }\n     \n     /**\n      */\n     public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n         _injectableValues = injectableValues;\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for overriding default locale (which simply uses\n+     * {@link Locale#getDefault()}).\n+     */\n+    public ObjectMapper setLocale(Locale l) {\n+        _deserializationContext.setLocale(l);\n+        _serializerProvider.setLocale(l);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for overriding default TimeZone (GMT)\n+     */\n+    public ObjectMapper setTimeZone(TimeZone tz) {\n+        _deserializationContext.setTimeZone(tz);\n+        _serializerProvider.setTimeZone(tz);\n         return this;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n \n import java.io.IOException;\n import java.sql.Timestamp;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.TimeZone;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n \n /**\n  * Container class for core JDK date/time type deserializers.\n \n     /*\n     /**********************************************************\n-    /* Deserializer implementations\n+    /* Intermediate class for Date-based ones\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class DateBasedDeserializer<T>\n+        extends StdScalarDeserializer<T>\n+        implements ContextualDeserializer\n+    {\n+        /**\n+         * Specific format to use, if non-null; if null will\n+         * just use default format.\n+         */\n+        protected final DateFormat _customFormat;\n+\n+        protected DateBasedDeserializer(Class<?> clz) {\n+            super(clz);\n+            _customFormat = null;\n+        }\n+\n+        protected DateBasedDeserializer(DateBasedDeserializer<T> base,\n+                DateFormat format) {\n+            super(base._valueClass);\n+            _customFormat = format;\n+        }\n+\n+        protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df);\n+        \n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n+           throws JsonMappingException\n+        {\n+            if (property != null) {\n+                JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat(property.getMember());\n+                if (format != null) {\n+                    String pattern = format.pattern;\n+                    if (pattern.length() > 0){\n+                        SimpleDateFormat df = new SimpleDateFormat(pattern, ctxt.getLocale());\n+                        df.setTimeZone(ctxt.getTimeZone());\n+                        return withDateFormat(df);\n+                    }\n+                }\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n+        protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+                String str = jp.getText().trim();\n+                if (str.length() == 0) {\n+                    return (Date) getEmptyValue();\n+                }\n+                synchronized (_customFormat) {\n+                    try {\n+                        return _customFormat.parse(str);\n+                    } catch (ParseException e) {\n+                        throw new IllegalArgumentException(\"Failed to parse Date value '\"+str+\"': \"+e.getMessage());\n+                    }\n+                }\n+            }\n+            return super._parseDate(jp, ctxt);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations for Date types\n     /**********************************************************\n      */\n     \n     @JacksonStdImpl\n     public static class CalendarDeserializer\n-        extends StdScalarDeserializer<Calendar>\n+        extends DateBasedDeserializer<Calendar>\n     {\n         /**\n          * We may know actual expected type; if so, it will be\n             _calendarClass = cc;\n         }\n \n+        public CalendarDeserializer(CalendarDeserializer src, DateFormat df) {\n+            super(src, df);\n+            _calendarClass = src._calendarClass;\n+        }\n+\n+        @Override\n+        protected CalendarDeserializer withDateFormat(DateFormat df) {\n+            return new CalendarDeserializer(this, df);\n+        }\n+        \n         @Override\n         public Calendar deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n      * deserializer calls.\n      */\n     public static class DateDeserializer\n-        extends StdScalarDeserializer<Date>\n+        extends DateBasedDeserializer<Date>\n     {\n         public DateDeserializer() { super(Date.class); }\n-       \n+        public DateDeserializer(DateDeserializer base, DateFormat df) {\n+            super(base, df);\n+        }\n+\n+        @Override\n+        protected DateDeserializer withDateFormat(DateFormat df) {\n+            return new DateDeserializer(this, df);\n+        }\n+        \n         @Override\n         public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n      * to deal with: mostly because it is more limited.\n      */\n     public static class SqlDateDeserializer\n-        extends StdScalarDeserializer<java.sql.Date>\n+        extends DateBasedDeserializer<java.sql.Date>\n     {\n         public SqlDateDeserializer() { super(java.sql.Date.class); }\n-\n+        public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df) {\n+            super(src, df);\n+        }\n+\n+        @Override\n+        protected SqlDateDeserializer withDateFormat(DateFormat df) {\n+            return new SqlDateDeserializer(this, df);\n+        }\n+        \n         @Override\n         public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n      * deserializer calls.\n      */\n     public static class TimestampDeserializer\n-        extends StdScalarDeserializer<Timestamp>\n+        extends DateBasedDeserializer<Timestamp>\n     {\n         public TimestampDeserializer() { super(Timestamp.class); }\n-\n+        public TimestampDeserializer(TimestampDeserializer src, DateFormat df) {\n+            super(src, df);\n+        }\n+\n+        @Override\n+        protected TimestampDeserializer withDateFormat(DateFormat df) {\n+            return new TimestampDeserializer(this, df);\n+        }\n+        \n         @Override\n         public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n         }\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations for Date-related types\n+    /**********************************************************\n+     */\n+    \n     /**\n      * As per [JACKSON-522], also need special handling for TimeZones\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         throw ctxt.mappingException(_valueClass, t);\n     }\n \n-    \n     protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n         }\n         if (t == JsonToken.VALUE_STRING) {\n             try {\n-                /* As per [JACKSON-203], take empty Strings to mean\n-                 * null\n-                 */\n+                // As per [JACKSON-203], take empty Strings to mean\n                 String str = jp.getText().trim();\n                 if (str.length() == 0) {\n                     return (Date) getEmptyValue();\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n             return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n-    }\n-    \n+    }    \n }", "timestamp": 1329979893, "metainfo": ""}