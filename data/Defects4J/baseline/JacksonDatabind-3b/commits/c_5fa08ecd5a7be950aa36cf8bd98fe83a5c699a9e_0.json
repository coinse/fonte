{"sha": "5fa08ecd5a7be950aa36cf8bd98fe83a5c699a9e", "log": "Change to work with 'untyped' type/object ids", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n     protected Object _deserializeWithNativeTypeId(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        final String typeId = jp.getTypeId();\n+        final Object typeId0 = jp.getTypeId();\n         JsonDeserializer<Object> deser;\n-        if (typeId == null) {\n+        if (typeId0 == null) {\n             if (_defaultImpl != null) {\n                 deser = _findDefaultImplDeserializer(ctxt);\n             } else {\n                 throw ctxt.mappingException(\"No (native) type id found when one was expected for polymorphic type handling\");\n             }\n         } else {\n+            String typeId = (typeId0 instanceof String) ? (String) typeId0 : String.valueOf(typeId0);\n             deser = _findDeserializer(ctxt, typeId);\n         }\n         /* 02-Aug-2013, tatu: What if type id is marked as \"visible\"? Should we try to\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n      * @since 2.3\n      */\n     protected final boolean _hasNativeTypeIds;\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected final boolean _hasNativeObjectIds;\n     \n     /*\n     /**********************************************************\n      */\n     protected int _appendOffset;\n \n+    /**\n+     * If native type ids supported, this is the id for following\n+     * value (or first token of one) to be written.\n+     */\n+    protected Object _typeId;\n+\n+    /**\n+     * If native object ids supported, this is the id for following\n+     * value (or first token of one) to be written.\n+     */\n+    protected Object _objectId;\n+    \n     /*\n     /**********************************************************\n     /* Output state\n      * @param codec Object codec to use for stream-based object\n      *   conversion through parser/generator interfaces. If null,\n      *   such methods can not be used.\n-     * @param nativeTypeIds Whether resulting {@link JsonParser} (if created)\n-     *   is considered to support native type ids\n-     */\n-    public TokenBuffer(ObjectCodec codec, boolean nativeTypeIds)\n+     * @param hasNativeIds Whether resulting {@link JsonParser} (if created)\n+     *   is considered to support native type and object ids\n+     */\n+    public TokenBuffer(ObjectCodec codec, boolean hasNativeIds)\n     {\n         _objectCodec = codec;\n         _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n         // at first we have just one segment\n         _first = _last = new Segment();\n         _appendOffset = 0;\n-        _hasNativeTypeIds = nativeTypeIds;\n+        _hasNativeTypeIds = hasNativeIds;\n+        _hasNativeObjectIds = hasNativeIds;\n     }\n \n     /**\n         _first = _last = new Segment();\n         _appendOffset = 0;\n         _hasNativeTypeIds = jp.canReadTypeId();\n+        // !!! TODO\n+        _hasNativeObjectIds = false;\n     }\n     \n     @Override\n     public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {\n         throw new UnsupportedOperationException();\n     }\n-    \n+\n+    /*\n+    /***********************************************************\n+    /* JsonGenerator implementation: native ids\n+    /***********************************************************\n+     */\n+\n+    @Override\n+    public boolean canWriteTypeId() {\n+        return _hasNativeTypeIds;\n+    }\n+\n+    @Override\n+    public boolean canWriteObjectId() {\n+        return _hasNativeObjectIds;\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) {\n+        _typeId = id;\n+    }\n+    \n+    @Override\n+    public void writeObjectId(Object id) {\n+        _objectId = id;\n+    }\n+\n     /*\n     /**********************************************************\n     /* JsonGenerator implementation; pass-through copy\n     {\n         if (_hasNativeTypeIds) {\n             _copyTypeId(jp);\n+        }\n+        if (_hasNativeObjectIds) {\n+            _copyObjectId(jp);\n         }\n         switch (jp.getCurrentToken()) {\n         case START_OBJECT:\n             writeNull();\n             break;\n         case VALUE_EMBEDDED_OBJECT:\n-            if (_hasNativeTypeIds) {\n-                _copyTypeId(jp);\n-            }\n             writeObject(jp.getEmbeddedObject());\n             break;\n         default:\n         }\n     }\n \n-    protected void _copyTypeId(JsonParser jp) throws IOException, JsonProcessingException\n-    {\n-        String typeId = jp.getTypeId();\n-        if (typeId != null) {\n-            writeTypeId(typeId);\n-        }\n+    protected final void _copyTypeId(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        Object id = jp.getTypeId();\n+        if (id != null) {\n+            writeTypeId(id);\n+        }\n+    }\n+\n+    protected final void _copyObjectId(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        // !!! TODO\n+        /*\n+        Object id = jp.getObjectId();\n+        if (id != null) {\n+            writeObjectId(id);\n+        }\n+        */\n     }\n     \n     @Override\n             if (_hasNativeTypeIds) {\n                 _copyTypeId(jp);\n             }\n+            if (_hasNativeObjectIds) {\n+                _copyObjectId(jp);\n+            }\n             writeStartArray();\n             while (jp.nextToken() != JsonToken.END_ARRAY) {\n                 copyCurrentStructure(jp);\n             if (_hasNativeTypeIds) {\n                 _copyTypeId(jp);\n             }\n+            if (_hasNativeObjectIds) {\n+                _copyObjectId(jp);\n+            }\n             writeStartObject();\n             while (jp.nextToken() != JsonToken.END_OBJECT) {\n                 copyCurrentStructure(jp);\n     /* Internal methods\n     /**********************************************************\n      */\n-    protected final void _append(JsonToken type) {\n+\n+    protected final void _append(JsonToken type)\n+    {\n         Segment next = _last.append(_appendOffset, type);\n         if (next == null) {\n             ++_appendOffset;\n         }\n     }\n \n-    protected final void _append(JsonToken type, Object value) {\n+    protected final void _append(JsonToken type, Object value)\n+    {\n         Segment next = _last.append(_appendOffset, type, value);\n         if (next == null) {\n             ++_appendOffset;\n         }\n     }\n \n-    protected final void _appendRaw(int rawType, Object value) {\n+    protected final void _appendRaw(int rawType, Object value)\n+    {\n         Segment next = _last.appendRaw(_appendOffset, rawType, value);\n         if (next == null) {\n             ++_appendOffset;\n         }\n \n         @Override\n-        public String getTypeId() throws IOException, JsonParseException\n+        public Object getTypeId() throws IOException, JsonParseException\n         {\n             if (!_hasNativeTypeIds) {\n                 return super.getTypeId();", "timestamp": 1375754115, "metainfo": ""}