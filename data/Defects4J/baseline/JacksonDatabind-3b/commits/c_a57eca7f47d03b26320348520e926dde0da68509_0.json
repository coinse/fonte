{"sha": "a57eca7f47d03b26320348520e926dde0da68509", "log": "Yet more refactoring, eliminating BeanProperty from TypeSerializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n         @Override\n         public TypeSerializer buildTypeSerializer(SerializationConfig config,\n-                JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+                JavaType baseType, Collection<NamedType> subtypes)\n         {\n-            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes, property) : null;            \n+            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n         }\n \n         /**\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.SerializationConfig;\n      *    handle; super type of all types it will be used for.\n      */\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n-            JavaType baseType, Collection<NamedType> subtypes,\n-            BeanProperty property);            \n+            JavaType baseType, Collection<NamedType> subtypes);\n \n     /**\n      * Method for building type deserializer based on current configuration\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n \n \n  */\n public abstract class TypeSerializer\n {\n+    /*\n+    /**********************************************************\n+    /* Initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to create contextual version, to be used for\n+     * values of given property. This may be the type itself\n+     * (as is the case for bean properties), or values contained\n+     * (for {@link java.util.Collection} or {@link java.util.Map}\n+     * valued properties).\n+     * \n+     * @since 2.0\n+     */\n+    public abstract TypeSerializer forProperty(BeanProperty prop);\n+    \n     /*\n     /**********************************************************\n     /* Introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java\n         super(idRes, property);\n     }\n \n+    @Override\n+    public AsArrayTypeSerializer forProperty(BeanProperty prop) {\n+        if (_property == prop) return this;\n+        return new AsArrayTypeSerializer(this._idResolver, prop);\n+    }\n+    \n     @Override\n     public As getTypeInclusion() { return As.WRAPPER_ARRAY; }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeSerializer.java\n        _typePropertyName = propName;\n    }\n \n+   @Override\n+   public AsExternalTypeSerializer forProperty(BeanProperty prop) {\n+       if (_property == prop) return this;\n+       return new AsExternalTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+   }\n+   \n    @Override\n    public String getPropertyName() { return _typePropertyName; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeSerializer.java\n         _typePropertyName = propName;\n     }\n \n+    @Override\n+    public AsPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        if (_property == prop) return this;\n+        return new AsPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n     @Override\n     public String getPropertyName() { return _typePropertyName; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java\n         super(idRes, property);\n     }\n \n+    @Override\n+    public AsWrapperTypeSerializer forProperty(BeanProperty prop) {\n+        if (_property == prop) return this;\n+        return new AsWrapperTypeSerializer(this._idResolver, prop);\n+    }\n+    \n     @Override\n     public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n     \n     @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n-            JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+            JavaType baseType, Collection<NamedType> subtypes)\n     {\n         if (_idType == JsonTypeInfo.Id.NONE) {\n             return null;\n         TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, property);\n+            return new AsArrayTypeSerializer(idRes, null);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, property,\n+            return new AsPropertyTypeSerializer(idRes, null,\n                     _typeProperty);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, property);\n+            return new AsWrapperTypeSerializer(idRes, null);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, property,\n+            return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n      */\n     @Override\n     public TypeSerializer createTypeSerializer(SerializationConfig config,\n-            JavaType baseType, BeanProperty property)\n+            JavaType baseType)\n     {\n         BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n         AnnotatedClass ac = bean.getClassInfo();\n         } else {\n             subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai);\n         }\n-        return (b == null) ? null : b.buildTypeSerializer(config, baseType, subtypes, property);\n+        return (b == null) ? null : b.buildTypeSerializer(config, baseType, subtypes);\n     }\n     \n     /*\n         // Let's see what we can learn about element/content/value type, type serializer for it:\n         JavaType elementType = type.getContentType();\n         TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n-                elementType, property);\n+                elementType);\n         \n         // if elements have type serializer, can not force static typing:\n         if (elementTypeSerializer != null) {\n         if (valueType == null) {\n             valueType = TypeFactory.unknownType();\n         }\n-        TypeSerializer vts = createTypeSerializer(config, valueType, property);\n+        TypeSerializer vts = createTypeSerializer(config, valueType);\n         return StdContainerSerializers.iteratorSerializer(valueType,\n                 usesStaticTyping(config, beanDesc, vts, property), vts, property);\n     }\n         if (valueType == null) {\n             valueType = TypeFactory.unknownType();\n         }\n-        TypeSerializer vts = createTypeSerializer(config, valueType, property);\n+        TypeSerializer vts = createTypeSerializer(config, valueType);\n         return StdContainerSerializers.iterableSerializer(valueType,\n-                usesStaticTyping(config, beanDesc, vts, property), vts, property);\n+                usesStaticTyping(config, beanDesc, vts, property),\n+                vts, property);\n     }\n     \n     /*\n      * (declared types)  should be used for properties.\n      * (instead of dynamic runtime types).\n      */\n-    protected boolean usesStaticTyping(SerializationConfig config, BeanDescription beanDesc,\n-            TypeSerializer typeSer, BeanProperty property)\n+    protected boolean usesStaticTyping(SerializationConfig config,\n+            BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property)\n     {\n         /* 16-Aug-2010, tatu: If there is a (value) type serializer, we can not force\n          *    static typing; that would make it impossible to handle expected subtypes\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n         // Defaulting: if no annotations on member, check value class\n         if (b == null) {\n-            return createTypeSerializer(config, baseType, property);\n+            return createTypeSerializer(config, baseType);\n         }\n         Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n-        return b.buildTypeSerializer(config, baseType, subtypes, property);\n+        return b.buildTypeSerializer(config, baseType, subtypes);\n     }\n \n     /**\n      * \n      * @return Type serializer to use for property value contents, if one is needed; null if not.\n      */    \n-    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config,\n-            AnnotatedMember accessor, BeanProperty property)\n+    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType,\n+            SerializationConfig config, AnnotatedMember accessor)\n         throws JsonMappingException\n     {\n         JavaType contentType = containerType.getContentType();\n         TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n         // Defaulting: if no annotations on member, check value class\n         if (b == null) {\n-            return createTypeSerializer(config, contentType, property);\n+            return createTypeSerializer(config, contentType);\n         }\n         Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n-        return b.buildTypeSerializer(config, contentType, subtypes, property);\n+        return b.buildTypeSerializer(config, contentType, subtypes);\n     }\n     \n     /*\n             // copied from BasicSerializerFactory.buildMapSerializer():\n             boolean staticTyping = config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING);\n             JavaType valueType = type.getContentType();\n-            TypeSerializer typeSer = createTypeSerializer(config, valueType, property);\n+            TypeSerializer typeSer = createTypeSerializer(config, valueType);\n             // last 2 nulls; don't know key, value serializers (yet)\n             MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                     typeSer, null, null);\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n         if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n-            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor, property);\n+            contentTypeSer = findPropertyContentTypeSerializer(type, prov.getConfig(), accessor);\n         }\n \n         // and if not JAXB collection/array with annotations, maybe regular type info?\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n      * @return Type serializer to use for the base type, if one is needed; null if not.\n      */\n     public abstract TypeSerializer createTypeSerializer(SerializationConfig config,\n-            JavaType baseType, BeanProperty property)\n+            JavaType baseType)\n         throws JsonMappingException;\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n      *    a hint \n      */\n     @Override\n-    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache,\n-            BeanProperty property)\n+    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n+            boolean cache, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Two-phase lookups; local non-shared cache, then shared:\n         // Well, let's just compose from pieces:\n         ser = findValueSerializer(valueType, property);\n         TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config,\n-                _config.constructType(valueType), property);\n+                _config.constructType(valueType));\n         if (typeSer != null) {\n+            typeSer = typeSer.forProperty(property);\n             ser = new TypeWrappedSerializer(typeSer, ser);\n         }\n         if (cache) {\n \n         // Well, let's just compose from pieces:\n         ser = findValueSerializer(valueType, property);\n-        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType, property);\n+        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType);\n         if (typeSer != null) {\n+            typeSer = typeSer.forProperty(property);\n             ser = new TypeWrappedSerializer(typeSer, ser);\n         }\n         if (cache) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n         super(List.class, elemType, staticTyping, vts, property, valueSerializer);\n     }\n \n-    public IndexedListSerializer(IndexedListSerializer src, BeanProperty property,\n-            JsonSerializer<?> valueSerializer)\n+    public IndexedListSerializer(IndexedListSerializer src,\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer)\n     {\n-        super(src, property, valueSerializer);\n+        super(src, property, vts, valueSerializer);\n     }\n \n     @Override\n     public IndexedListSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer) {\n-        return new IndexedListSerializer(this, property, elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer) {\n+        return new IndexedListSerializer(this, property, vts, elementSerializer);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n         super(Iterator.class, elemType, staticTyping, vts, property, null);\n     }\n \n-    public IteratorSerializer(IteratorSerializer src, BeanProperty property,\n-            JsonSerializer<?> valueSerializer)\n+    public IteratorSerializer(IteratorSerializer src,\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer)\n     {\n-        super(src, property, valueSerializer);\n+        super(src, property, vts, valueSerializer);\n     }\n \n     @Override\n \n     @Override\n     public IteratorSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer) {\n-        return new IteratorSerializer(this, property, elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer) {\n+        return new IteratorSerializer(this, property, vts, elementSerializer);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n      */\n     \n     protected StringArraySerializer() {\n-        super(String[].class, null, null);\n+        super(String[].class, null);\n         _elementSerializer = null;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n public abstract class ArraySerializerBase<T>\n     extends ContainerSerializer<T>\n {\n-    protected final TypeSerializer _valueTypeSerializer;\n+    protected final BeanProperty _property;\n \n-    protected final BeanProperty _property;\n-    \n-    protected ArraySerializerBase(Class<T> cls, TypeSerializer vts, BeanProperty property)\n+    protected ArraySerializerBase(Class<T> cls)\n     {\n         super(cls);\n-        _valueTypeSerializer = vts;\n+        _property = null;\n+    }\n+\n+    protected ArraySerializerBase(Class<T> cls, BeanProperty property)\n+    {\n+        super(cls);\n         _property = property;\n     }\n-    \n-    protected ArraySerializerBase(ArraySerializerBase<?> src, TypeSerializer vts)\n+\n+    protected ArraySerializerBase(ArraySerializerBase<?> src)\n     {\n         super(src._handledType, false);\n-        _valueTypeSerializer = vts;\n         _property = src._property;\n     }\n     \n     protected ArraySerializerBase(ArraySerializerBase<?> src, BeanProperty property)\n     {\n         super(src._handledType, false);\n-        _valueTypeSerializer = src._valueTypeSerializer;\n         _property = property;\n     }\n-\n     \n     @Override\n     public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n \n     @SuppressWarnings(\"unchecked\")\n     protected AsArraySerializerBase(AsArraySerializerBase<?> src,\n-            BeanProperty property, JsonSerializer<?> elementSerializer)\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer)\n     {\n         super(src);\n         _elementType = src._elementType;\n         _staticTyping = src._staticTyping;\n-        _valueTypeSerializer = src._valueTypeSerializer;\n+        _valueTypeSerializer = vts;\n         _property = src._property;\n         _elementSerializer = (JsonSerializer<Object>) elementSerializer;\n         _dynamicSerializers = src._dynamicSerializers;\n     }\n     \n     public abstract AsArraySerializerBase<T> withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer);\n \n     /*\n     /**********************************************************\n             BeanProperty property)\n         throws JsonMappingException\n     {\n+        TypeSerializer typeSer = _valueTypeSerializer;\n+        if (typeSer != null) {\n+            typeSer = typeSer.forProperty(property);\n+        }\n         JsonSerializer<?> ser = _elementSerializer;\n         if (ser == null) {\n             if (_staticTyping && _elementType != null) {\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n-        if ((ser != _elementSerializer) || (property != _property)) {\n-            return withResolved(property, ser);\n+        if ((ser != _elementSerializer) || (property != _property) || _valueTypeSerializer != typeSer) {\n+            return withResolved(property, typeSer, ser);\n         }\n         return this;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n         super(Collection.class, elemType, staticTyping, vts, property, valueSerializer);\n     }\n \n-    public CollectionSerializer(CollectionSerializer src, BeanProperty property,\n-            JsonSerializer<?> valueSerializer)\n+    public CollectionSerializer(CollectionSerializer src,\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer)\n     {\n-        super(src, property, valueSerializer);\n+        super(src, property, vts, valueSerializer);\n     }\n     \n     @Override\n \n     @Override\n     public CollectionSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer) {\n-        return new CollectionSerializer(this, property, elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer) {\n+        return new CollectionSerializer(this, property, vts, elementSerializer);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n         super(EnumSet.class, elemType, true, null, property, null);\n     }\n \n-    public EnumSetSerializer(EnumSetSerializer src, BeanProperty property,\n-            JsonSerializer<?> valueSerializer)\n+    public EnumSetSerializer(EnumSetSerializer src,\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer)\n     {\n-        super(src, property, valueSerializer);\n+        super(src, property, vts, valueSerializer);\n     }\n     \n     @Override\n \n     @Override\n     public EnumSetSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer) {\n-        return new EnumSetSerializer(this, property, elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer) {\n+        return new EnumSetSerializer(this, property, vts, elementSerializer);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n public class IterableSerializer\n     extends AsArraySerializerBase<Iterable<?>>\n {\n-    public IterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property)\n+    public IterableSerializer(JavaType elemType, boolean staticTyping,\n+            TypeSerializer vts, BeanProperty property)\n     {\n         super(Iterable.class, elemType, staticTyping, vts, property, null);\n     }\n \n     public IterableSerializer(IterableSerializer src, BeanProperty property,\n-            JsonSerializer<?> valueSerializer)\n+            TypeSerializer vts, JsonSerializer<?> valueSerializer)\n     {\n-        super(src, property, valueSerializer);\n+        super(src, property, vts, valueSerializer);\n     }\n     \n     @Override\n \n     @Override\n     public IterableSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> elementSerializer) {\n-        return new IterableSerializer(this, property, elementSerializer);\n+            TypeSerializer vts, JsonSerializer<?> elementSerializer) {\n+        return new IterableSerializer(this, property, vts, elementSerializer);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n     protected final JavaType _elementType;\n \n     /**\n+     * Type serializer to use for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+    \n+    /**\n      * Value serializer to use, if it can be statically determined.\n      */\n     protected JsonSerializer<Object> _elementSerializer;\n     public ObjectArraySerializer(JavaType elemType, boolean staticTyping,\n             TypeSerializer vts, JsonSerializer<Object> elementSerializer)\n     {\n-        super(Object[].class, vts, null);\n+        super(Object[].class, null);\n         _elementType = elemType;\n         _staticTyping = staticTyping;\n+        _valueTypeSerializer = vts;\n         _dynamicSerializers = PropertySerializerMap.emptyMap();\n         _elementSerializer = elementSerializer;\n     }\n \n-    public ObjectArraySerializer(ObjectArraySerializer src, TypeSerializer typeSer)\n-    {\n-        super(src, typeSer);\n+    public ObjectArraySerializer(ObjectArraySerializer src, TypeSerializer vts)\n+    {\n+        super(src);\n         _elementType = src._elementType;\n+        _valueTypeSerializer = vts;\n         _staticTyping = src._staticTyping;\n         _dynamicSerializers = src._dynamicSerializers;\n         _elementSerializer = src._elementSerializer;\n     \n     @SuppressWarnings(\"unchecked\")\n     public ObjectArraySerializer(ObjectArraySerializer src,\n-            BeanProperty property, JsonSerializer<?> elementSerializer)\n-    {\n-        super(src, property);\n+            BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer)\n+    {\n+        super(src,  property);\n         _elementType = src._elementType;\n+        _valueTypeSerializer = vts;\n         _staticTyping = src._staticTyping;\n         _dynamicSerializers = src._dynamicSerializers;\n         _elementSerializer = (JsonSerializer<Object>) elementSerializer;\n         return new ObjectArraySerializer(_elementType, _staticTyping, vts, _elementSerializer);\n     }\n \n-    public ObjectArraySerializer withResolved(BeanProperty prop, JsonSerializer<?> ser) {\n-        if (_property == prop && ser == _elementSerializer) {\n+    public ObjectArraySerializer withResolved(BeanProperty prop,\n+            TypeSerializer vts, JsonSerializer<?> ser) {\n+        if (_property == prop && ser == _elementSerializer && _valueTypeSerializer == vts) {\n             return this;\n         }\n-        return new ObjectArraySerializer(this, prop, ser);\n+        return new ObjectArraySerializer(this, prop, vts, ser);\n     }\n \n     /*\n             BeanProperty property)\n         throws JsonMappingException\n     {\n-        if (_elementSerializer == null) {\n+        TypeSerializer vts = _valueTypeSerializer;\n+        if (vts != null) {\n+            vts = vts.forProperty(property);\n+        }\n+        JsonSerializer<?> ser = _elementSerializer;\n+        if (ser == null) {\n             if (_staticTyping) {\n-                return withResolved(property, provider.findValueSerializer(_elementType, property));\n-            }\n-        } else if (_elementSerializer instanceof ContextualSerializer) {\n-            return withResolved(property, ((ContextualSerializer) _elementSerializer)\n-                    .createContextual(provider, property));\n-        }\n-        return this;\n+                ser = provider.findValueSerializer(_elementType, property);\n+            }\n+        } else if (ser instanceof ContextualSerializer) {\n+            ser = ((ContextualSerializer) _elementSerializer).createContextual(provider, property);\n+        }\n+        return withResolved(property, vts, ser);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n \n     /*\n      ****************************************************************\n-    /* Concrete serializers, arrays\n+    /* Intermediate base classes\n      ****************************************************************\n      */\n \n+    /**\n+     * Intermediate base class used for cases where we may add\n+     * type information (excludes boolean/int/double arrays).\n+     */\n+    protected abstract static class TypedPrimitiveArraySerializer<T>\n+        extends ArraySerializerBase<T>\n+    {\n+        /**\n+         * Type serializer to use for values, if any.\n+         */\n+        protected final TypeSerializer _valueTypeSerializer;\n+        \n+        protected TypedPrimitiveArraySerializer(Class<T> cls) {\n+            super(cls);\n+            _valueTypeSerializer = null;\n+        }\n+\n+        protected TypedPrimitiveArraySerializer(TypedPrimitiveArraySerializer<T> src,\n+                BeanProperty prop, TypeSerializer vts) {\n+            super(src, prop);\n+            _valueTypeSerializer = vts;\n+        }\n+    }\n+    \n+    /*\n+    /****************************************************************\n+    /* Concrete serializers, arrays\n+    /****************************************************************\n+     */\n \n     @JacksonStdImpl\n     public final static class BooleanArraySerializer\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Boolean.class);\n \n-        public BooleanArraySerializer() { super(boolean[].class, null, null); }\n+        public BooleanArraySerializer() { super(boolean[].class, null); }\n \n         /**\n          * Booleans never add type info; hence, even if type serializer is suggested,\n \n     @JacksonStdImpl\n     public final static class ShortArraySerializer\n-        extends ArraySerializerBase<short[]>\n+        extends TypedPrimitiveArraySerializer<short[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Short.TYPE);\n \n-        public ShortArraySerializer() { this(null); }\n-        public ShortArraySerializer(TypeSerializer vts) { super(short[].class, vts, null); }\n+        public ShortArraySerializer() { super(short[].class); }\n+        public ShortArraySerializer(ShortArraySerializer src, BeanProperty prop, TypeSerializer vts) {\n+            super(src, prop, vts);\n+        }\n \n         @Override\n         public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n-            return new ShortArraySerializer(vts);\n+            return new ShortArraySerializer(this, _property, vts);\n         }\n \n         @Override\n         public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n+            if (_valueTypeSerializer != null) {\n+                for (int i = 0, len = value.length; i < len; ++i) {\n+                    _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Short.TYPE);\n+                    jgen.writeNumber(value[i]);\n+                    _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen);\n+                }\n+                return;\n+            }\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber((int)value[i]);\n             }\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Integer.TYPE);\n \n-        public IntArraySerializer() { super(int[].class, null, null); }\n+        public IntArraySerializer() { super(int[].class, null); }\n \n         /**\n          * Ints never add type info; hence, even if type serializer is suggested,\n \n     @JacksonStdImpl\n     public final static class LongArraySerializer\n-        extends ArraySerializerBase<long[]>\n+        extends TypedPrimitiveArraySerializer<long[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Long.TYPE);\n \n-        public LongArraySerializer() { this(null); }\n-        public LongArraySerializer(TypeSerializer vts) { super(long[].class, vts, null); }\n+        public LongArraySerializer() { super(long[].class); }\n+        public LongArraySerializer(LongArraySerializer src, BeanProperty prop,\n+                TypeSerializer vts) {\n+            super(src, prop, vts);\n+        }\n \n         @Override\n         public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n-            return new LongArraySerializer(vts);\n+            return new LongArraySerializer(this, _property, vts);\n         }\n \n         @Override\n         public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n+            if (_valueTypeSerializer != null) {\n+                for (int i = 0, len = value.length; i < len; ++i) {\n+                    _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Long.TYPE);\n+                    jgen.writeNumber(value[i]);\n+                    _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen);\n+                }\n+                return;\n+            }\n+            \n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n             }\n \n     @JacksonStdImpl\n     public final static class FloatArraySerializer\n-        extends ArraySerializerBase<float[]>\n+        extends TypedPrimitiveArraySerializer<float[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Float.TYPE);\n         \n-        public FloatArraySerializer() { this(null); }\n-        public FloatArraySerializer(TypeSerializer vts) { super(float[].class, vts, null); }\n+        public FloatArraySerializer() {\n+            super(float[].class);\n+        }\n+        public FloatArraySerializer(FloatArraySerializer src, BeanProperty prop,\n+                TypeSerializer vts) {\n+            super(src, prop, vts);\n+        }\n \n         @Override\n         public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n-            return new FloatArraySerializer(vts);\n+            return new FloatArraySerializer(this, _property, vts);\n         }\n \n         @Override\n         public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n+            if (_valueTypeSerializer != null) {\n+                for (int i = 0, len = value.length; i < len; ++i) {\n+                    _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Float.TYPE);\n+                    jgen.writeNumber(value[i]);\n+                    _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen);\n+                }\n+                return;\n+            }\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n             }\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Double.TYPE);\n \n-        public DoubleArraySerializer() { super(double[].class, null, null); }\n+        public DoubleArraySerializer() { super(double[].class, null); }\n \n         /**\n          * Doubles never add type info; hence, even if type serializer is suggested,", "timestamp": 1328138774, "metainfo": ""}