{"sha": "54d47c1b3dd0a3597cda3366add9cbd49a57b51f", "log": "demoting deserializeWithObjectId()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             }\n         }\n         return bean;\n-    }\n-\n-    /**\n-     * Alternative deserialization method used when we expect to see Object Id;\n-     * if so, we will need to ensure that the Id is seen before anything\n-     * else, to ensure that it is available for solving references,\n-     * even if JSON itself is not ordered that way. This may require\n-     * buffering in some cases, but usually just a simple lookup to ensure\n-     * that ordering is correct.\n-     */\n-    @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        final String idPropName = _objectIdReader.propertyName;\n-        // First, the simple case: we point to the Object Id property\n-        if (idPropName.equals(jp.getCurrentName())) {\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        // otherwise need to reorder things\n-        TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec());\n-        TokenBuffer mergedBuffer = null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // when we match the id property, can start merging\n-            if (mergedBuffer == null) {\n-                if (idPropName.equals(propName)) {\n-                    mergedBuffer = new TokenBuffer(jp.getCodec());\n-                    mergedBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    mergedBuffer.copyCurrentStructure(jp);\n-                    mergedBuffer.append(tmpBuffer);\n-                    tmpBuffer = null;\n-                } else {\n-                    tmpBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    tmpBuffer.copyCurrentStructure(jp);\n-                }\n-            } else {\n-                mergedBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                mergedBuffer.copyCurrentStructure(jp);\n-            }\n-        }\n-        // note: we really should get merged buffer (and if not, that is likely error), but\n-        // for now let's allow missing case as well. Will be caught be a later stage...\n-        TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer;\n-        buffer.writeEndObject();\n-        // important: need to advance to point to first FIELD_NAME:\n-        JsonParser mergedParser = buffer.asParser();\n-        mergedParser.nextToken();\n-        return deserializeFromObject(mergedParser, ctxt);\n     }\n     \n     public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n     /* Partial deserializer implementation\n     /**********************************************************\n      */\n-    \n+\n+    /**\n+     * General version used when handling needs more advanced\n+     * features.\n+     */\n+    public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n     @Override\n     public final Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n \n+    // NOTE: currently only used by standard BeanDeserializer (not Builder-based)\n+    /**\n+     * Alternative deserialization method used when we expect to see Object Id;\n+     * if so, we will need to ensure that the Id is seen before anything\n+     * else, to ensure that it is available for solving references,\n+     * even if JSON itself is not ordered that way. This may require\n+     * buffering in some cases, but usually just a simple lookup to ensure\n+     * that ordering is correct.\n+     */\n+    @SuppressWarnings(\"resource\")\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        final String idPropName = _objectIdReader.propertyName;\n+        // First, the simple case: we point to the Object Id property\n+        if (idPropName.equals(jp.getCurrentName())) {\n+            return deserializeFromObject(jp, ctxt);\n+        }\n+        // otherwise need to reorder things\n+        TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec());\n+        TokenBuffer mergedBuffer = null;\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // when we match the id property, can start merging\n+            if (mergedBuffer == null) {\n+                if (idPropName.equals(propName)) {\n+                    mergedBuffer = new TokenBuffer(jp.getCodec());\n+                    mergedBuffer.writeFieldName(propName);\n+                    jp.nextToken();\n+                    mergedBuffer.copyCurrentStructure(jp);\n+                    mergedBuffer.append(tmpBuffer);\n+                    tmpBuffer = null;\n+                } else {\n+                    tmpBuffer.writeFieldName(propName);\n+                    jp.nextToken();\n+                    tmpBuffer.copyCurrentStructure(jp);\n+                }\n+            } else {\n+                mergedBuffer.writeFieldName(propName);\n+                jp.nextToken();\n+                mergedBuffer.copyCurrentStructure(jp);\n+            }\n+        }\n+        // note: we really should get merged buffer (and if not, that is likely error), but\n+        // for now let's allow missing case as well. Will be caught be a later stage...\n+        TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer;\n+        buffer.writeEndObject();\n+        // important: need to advance to point to first FIELD_NAME:\n+        JsonParser mergedParser = buffer.asParser();\n+        mergedParser.nextToken();\n+        return deserializeFromObject(mergedParser, ctxt);\n+    }\n+    \n     /**\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n         return finishBuild(ctxt, builder);\n     }\n \n+    // needed since 2.1\n+    @Override\n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        return _deserializeFromNonArray(jp, ctxt);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, non-standard creation\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n         return bean;\n     }\n \n+\n+    // needed since 2.1\n+    @Override\n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        return _deserializeFromNonArray(jp, ctxt);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, non-standard creation", "timestamp": 1353179486, "metainfo": ""}