{"sha": "b4851e506ed082552331a3a8bad31c0439377c5b", "log": "Refactoring default SerializerProvider's handling of root null values", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n     public void serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException\n     {\n-        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        Class<?> cls = value.getClass();\n+        // true, since we do want to cache root-level typed serializers (ditto for null property)\n+        JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n+\n+        // Ok: should we wrap result in an additional property (\"root name\")?\n+        String rootName = _config.getRootName();\n         final boolean wrap;\n-\n-        if (value == null) { // no type provided; must just use the default null serializer\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false; // no name to use for wrapping; can't do!\n-        } else {\n-            Class<?> cls = value.getClass();\n-            // true, since we do want to cache root-level typed serializers (ditto for null property)\n-            ser = findTypedValueSerializer(cls, true, null);\n-\n-            // Ok: should we wrap result in an additional property (\"root name\")?\n-            String rootName = _config.getRootName();\n-            if (rootName == null) { // not explicitly specified\n-                // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-                if (wrap) {\n-                    jgen.writeStartObject();\n-                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n-                }\n-            } else if (rootName.length() == 0) {\n-                wrap = false;\n-            } else { // [JACKSON-764]\n-                // empty String means explicitly disabled; non-empty that it is enabled\n-                wrap = true;\n+        if (rootName == null) { // not explicitly specified\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n                 jgen.writeStartObject();\n-                jgen.writeFieldName(rootName);\n-            }\n+                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else { // [JACKSON-764]\n+            // empty String means explicitly disabled; non-empty that it is enabled\n+            wrap = true;\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(rootName);\n         }\n         try {\n             ser.serialize(value, jgen, this);\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonGenerationException\n     {\n-        final boolean wrap;\n-\n-        JsonSerializer<Object> ser;\n         if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                _reportIncompatibleRootType(value, rootType);\n-            }\n-            // root value, not reached via property:\n-            ser = findTypedValueSerializer(rootType, true, null);\n-            // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-            if (wrap) {\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        // Let's ensure types are compatible at this point\n+        if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+            _reportIncompatibleRootType(value, rootType);\n+        }\n+        // root value, not reached via property:\n+        JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n+        // [JACKSON-163]\n+        final boolean wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+        if (wrap) {\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n         }\n         try {\n             ser.serialize(value, jgen, this);\n             JsonSerializer<Object> ser)\n         throws IOException, JsonGenerationException\n     {\n-        final boolean wrap;\n-\n         if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (rootType != null) {\n-                if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                    _reportIncompatibleRootType(value, rootType);\n-                }\n-            }\n-            // root value, not reached via property:\n-            if (ser == null) {\n-                ser = findTypedValueSerializer(rootType, true, null);\n-            }\n-            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-            if (wrap) {\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        // Let's ensure types are compatible at this point\n+        if (rootType != null) {\n+            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                _reportIncompatibleRootType(value, rootType);\n+            }\n+        }\n+        // root value, not reached via property:\n+        if (ser == null) {\n+            ser = findTypedValueSerializer(rootType, true, null);\n+        }\n+        final boolean wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+        if (wrap) {\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n         }\n         try {\n             ser.serialize(value, jgen, this);\n             throw new JsonMappingException(msg, e);\n         }\n     }\n-    \n+\n+    /**\n+     * Helper method called when root value to serialize is null\n+     * \n+     * @since 2.3\n+     */\n+    protected void _serializeNull(JsonGenerator jgen)\n+        throws IOException, JsonGenerationException\n+    {\n+        JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n+        try {\n+            ser.serialize(null, jgen, this);\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n      * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n      * For efficient operation, let's try to minimize number of times we\n      * need to introspect root element name to use.\n      */\n-    protected LRUMap<ClassKey,SerializedString> _rootNames;\n+    protected transient LRUMap<ClassKey,SerializedString> _rootNames;\n \n     public RootNameLookup() { }\n \n         return findRootName(rootType.getRawClass(), config);\n     }\n \n-    public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n+    public SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n     {\n         ClassKey key = new ClassKey(rootType);\n \n-        if (_rootNames == null) {\n-            _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n-        } else {\n-            SerializedString name = _rootNames.get(key);\n-            if (name != null) {\n-                return name;\n+        synchronized (this) {\n+            if (_rootNames == null) {\n+                _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n+            } else {\n+                SerializedString name = _rootNames.get(key);\n+                if (name != null) {\n+                    return name;\n+                }\n             }\n         }\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n             nameStr = pname.getSimpleName();\n         }\n         SerializedString name = new SerializedString(nameStr);\n-        _rootNames.put(key, name);\n+        synchronized (this) {\n+            _rootNames.put(key, name);\n+        }\n         return name;\n     }\n }", "timestamp": 1376543347, "metainfo": ""}