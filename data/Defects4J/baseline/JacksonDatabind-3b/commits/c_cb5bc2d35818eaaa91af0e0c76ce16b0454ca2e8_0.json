{"sha": "cb5bc2d35818eaaa91af0e0c76ce16b0454ca2e8", "log": "and still more refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n \n     public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n     {\n-        if (!_classNames.contains(clsName)) {\n-            return null;\n-        }\n-        // Start with the most common type\n-        if (rawType == Calendar.class) {\n-            return CalendarDeserializer.instance;\n-        }\n-        if (rawType == java.util.Date.class) {\n-            return DateDeserializer.instance;\n-        }\n-        if (rawType == java.sql.Date.class) {\n-            return SqlDateDeserializer.instance;\n-        }\n-        if (rawType == Timestamp.class) {\n-            return TimestampDeserializer.instance;\n-        }\n-        if (rawType == GregorianCalendar.class) {\n-            return CalendarDeserializer.gregorianInstance;\n-        }\n-        // should never occur\n-        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+clsName);\n+        if (_classNames.contains(clsName)) {\n+            // Start with the most common type\n+            if (rawType == Calendar.class) {\n+                return new CalendarDeserializer();\n+            }\n+            if (rawType == java.util.Date.class) {\n+                return DateDeserializer.instance;\n+            }\n+            if (rawType == java.sql.Date.class) {\n+                return new SqlDateDeserializer();\n+            }\n+            if (rawType == Timestamp.class) {\n+                return new TimestampDeserializer();\n+            }\n+            if (rawType == GregorianCalendar.class) {\n+                return new CalendarDeserializer(GregorianCalendar.class);\n+            }\n+        }\n+        return null;\n     }\n     \n     /*\n      */\n     \n     @JacksonStdImpl\n-    public static class CalendarDeserializer\n-        extends DateBasedDeserializer<Calendar>\n-    {\n-        public final static CalendarDeserializer instance = new CalendarDeserializer();\n-        public final static CalendarDeserializer gregorianInstance = new CalendarDeserializer(GregorianCalendar.class);\n-        \n+    public static class CalendarDeserializer extends DateBasedDeserializer<Calendar>\n+    {\n         /**\n          * We may know actual expected type; if so, it will be\n          * used for instantiation.\n         }\n         \n         @Override\n-        public Calendar deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             Date d = _parseDate(jp, ctxt);\n             if (d == null) {\n      * {@link DeserializationContext#parseDate} that this basic\n      * deserializer calls.\n      */\n-    public static class DateDeserializer\n-        extends DateBasedDeserializer<Date>\n+    public static class DateDeserializer extends DateBasedDeserializer<Date>\n     {\n         public final static DateDeserializer instance = new DateDeserializer();\n \n         }\n         \n         @Override\n-        public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return _parseDate(jp, ctxt);\n         }\n     }\n     public static class SqlDateDeserializer\n         extends DateBasedDeserializer<java.sql.Date>\n     {\n-        public final static SqlDateDeserializer instance = new SqlDateDeserializer();\n-\n         public SqlDateDeserializer() { super(java.sql.Date.class); }\n         public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df, String formatString) {\n             super(src, df, formatString);\n         }\n         \n         @Override\n-        public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             Date d = _parseDate(jp, ctxt);\n             return (d == null) ? null : new java.sql.Date(d.getTime());\n         }\n      * {@link DeserializationContext#parseDate} that this basic\n      * deserializer calls.\n      */\n-    public static class TimestampDeserializer\n-        extends DateBasedDeserializer<Timestamp>\n-    {\n-        public final static TimestampDeserializer instance = new TimestampDeserializer();\n-\n+    public static class TimestampDeserializer extends DateBasedDeserializer<Timestamp>\n+    {\n         public TimestampDeserializer() { super(Timestamp.class); }\n         public TimestampDeserializer(TimestampDeserializer src, DateFormat df, String formatString) {\n             super(src, df, formatString);\n         }\n         \n         @Override\n-        public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             return new Timestamp(_parseDate(jp, ctxt).getTime());\n         }", "timestamp": 1388731954, "metainfo": ""}