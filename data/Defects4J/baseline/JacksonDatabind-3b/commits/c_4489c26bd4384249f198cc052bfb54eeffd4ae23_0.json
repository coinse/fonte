{"sha": "4489c26bd4384249f198cc052bfb54eeffd4ae23", "log": "Complete [JACKSON-756] fix for 2.0.0", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n     }\n \n     /**\n-     * And finally, we have special array deserializers for primitive\n-     * array types\n+     * Also special array deserializers for primitive array types.\n      */\n     protected final static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n         = PrimitiveArrayDeserializers.getAll();\n \n     /**\n+     * Set of available key deserializers is currently limited\n+     * to standard types; and all known instances are storing in this map.\n+     */\n+    final static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n+    \n+    /**\n      * To support external/optional deserializers, we'll use a helper class\n      */\n     protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n-    \n+\n     /*\n     /**********************************************************\n+    /* Config\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Configuration settings for this factory; immutable instance (just like this\n+     * factory), new version created via copy-constructor (fluent-style)\n+     */\n+    protected final Config _factoryConfig;\n+    \n+    /*\n+    /**********************************************************\n     /* Life cycle\n     /**********************************************************\n      */\n \n-    protected BasicDeserializerFactory() { }\n-\n+    protected BasicDeserializerFactory(Config config) {\n+        _factoryConfig = config;\n+    }\n+\n+    @Override\n+    public final Config getConfig() {\n+        return _factoryConfig;\n+    }\n+    \n     // can't be implemented quite here\n     @Override\n     public abstract DeserializerFactory withConfig(DeserializerFactory.Config config);\n         if (keyDes == null) {\n             keyDes = p.findKeyDeserializer(config, keyType, property);\n         }\n-        // Then optional type info (1.5); either attached to type, or resolve separately:\n+        // Then optional type info (1.5); either attached to type, or resolved separately:\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (contentTypeDeser == null) {\n         return _findCustomMapLikeDeserializer(type, config, p, beanDesc, property,\n                 keyDes, contentTypeDeser, contentDeser);\n     }\n-    \n+\n     /**\n      * Factory method for constructing serializers of {@link Enum} types.\n      */\n             }\n         }\n         return b.buildTypeDeserializer(config, baseType, subtypes, property);\n+    }\n+\n+    @Override\n+    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (_factoryConfig.hasKeyDeserializers()) {\n+            BasicBeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n+            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n+                KeyDeserializer deser = d.findKeyDeserializer(type, config, beanDesc, property);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+        }\n+        // and if none found, standard ones:\n+        // No serializer needed if it's plain old String, or Object/untyped\n+        Class<?> raw = type.getRawClass();\n+        if (raw == String.class || raw == Object.class) {\n+            return StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n+        }\n+        // Most other keys are of limited number of static types\n+        KeyDeserializer kdes = _keyDeserializers.get(type);\n+        if (kdes != null) {\n+            return kdes;\n+        }\n+        // And then other one-offs; first, Enum:\n+        if (type.isEnumType()) {\n+            return _createEnumKeyDeserializer(config, type, property);\n+        }\n+        // One more thing: can we find ctor(String) or valueOf(String)?\n+        kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+        return kdes;\n+    }\n+\n+    private KeyDeserializer _createEnumKeyDeserializer(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        BasicBeanDescription beanDesc = config.introspect(type);\n+        JsonDeserializer<?> des = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (des != null) {\n+            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n+        }\n+        Class<?> enumClass = type.getRawClass();\n+        // 23-Nov-2010, tatu: Custom deserializer?\n+        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc, property);\n+        if (custom != null) {\n+            return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n+        }\n+\n+        EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod());\n+        // [JACKSON-193] May have @JsonCreator for static factory method:\n+        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n+            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n+                int argCount = factory.getParameterCount();\n+                if (argCount == 1) {\n+                    Class<?> returnType = factory.getRawType();\n+                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n+                    if (returnType.isAssignableFrom(enumClass)) {\n+                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'\n+                        if (factory.getParameterType(0) != String.class) {\n+                            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n+                        }\n+                        if (config.canOverrideAccessModifiers()) {\n+                            ClassUtil.checkAndFixAccess(factory.getMember());\n+                        }\n+                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);\n+                    }\n+                }\n+                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n+                        +enumClass.getName()+\")\");\n+            }\n+        }\n+        // [JACKSON-749] Also, need to consider @JsonValue, if one found\n+        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.JacksonDeserializers;\n-import com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n      * Signature of <b>Throwable.initCause</b> method.\n      */\n     private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n-\n-    /**\n-     * Set of available key deserializers is currently limited\n-     * to standard types; and all known instances are storing\n-     * in this map.\n-     */\n-    final static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n     \n     /*\n     /**********************************************************\n      */\n     public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(null);\n \n-    /**\n-     * Configuration settings for this factory; immutable instance (just like this\n-     * factory), new version created via copy-constructor (fluent-style)\n-     */\n-    protected final Config _factoryConfig;\n-\n-    public BeanDeserializerFactory(DeserializerFactory.Config config) {\n-        if (config == null) {\n-            config = new ConfigImpl();\n-        }\n-        _factoryConfig = config;\n-    }\n-\n-    @Override\n-    public final Config getConfig() {\n-        return _factoryConfig;\n+    public BeanDeserializerFactory(DeserializerFactory.Config config)\n+    {\n+        super((config == null) ? new ConfigImpl() : config);\n     }\n     \n     /**\n     /* custom deserializers\n     /**********************************************************\n      */\n-\n-    @Override\n-    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        if (_factoryConfig.hasKeyDeserializers()) {\n-            BasicBeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n-            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n-                KeyDeserializer deser = d.findKeyDeserializer(type, config, beanDesc, property);\n-                if (deser != null) {\n-                    return deser;\n-                }\n-            }\n-        }\n-        // and if none found, standard ones:\n-        // No serializer needed if it's plain old String, or Object/untyped\n-        Class<?> raw = type.getRawClass();\n-        if (raw == String.class || raw == Object.class) {\n-            return StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n-        }\n-        // Most other keys are of limited number of static types\n-        KeyDeserializer kdes = _keyDeserializers.get(type);\n-        if (kdes != null) {\n-            return kdes;\n-        }\n-        // And then other one-offs; first, Enum:\n-        if (type.isEnumType()) {\n-            return StdKeyDeserializers.constructEnumKeyDeserializer(config, type);\n-        }\n-        // One more thing: can we find ctor(String) or valueOf(String)?\n-        kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n-        return kdes;\n-    }\n     \n     @Override\n     protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config,\n     /**\n      * Method that will find if bean has any managed- or back-reference properties,\n      * and if so add them to bean, to be linked during resolution phase.\n-     * \n-     * @since 1.6\n      */\n     protected void addReferenceProperties(DeserializationConfig config,\n             BasicBeanDescription beanDesc, BeanDeserializerBuilder builder)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n             }\n             String value = jp.getText();\n             try {\n-                return _factory.invoke(_enumClass, value);\n+                return _factory.invoke(null, value);\n             } catch (Exception e) {\n                 ClassUtil.unwrapAndThrowAsIAE(e);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n /**\n     /**********************************************************\n      */\n \n+    /**\n+     * Key deserializer that wraps a \"regular\" deserializer (but one\n+     * that must recognize FIELD_NAMEs as text!) to reuse existing\n+     * handlers as key handlers.\n+     */\n+    final static class DelegatingKD extends KeyDeserializer // note: NOT the std one\n+    {\n+        final protected Class<?> _keyClass;\n+\n+        protected final JsonDeserializer<?> _delegate;\n+        \n+        protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {\n+            _keyClass = cls;\n+            _delegate = deser;\n+        }\n+\n+        @Override\n+        public final Object deserializeKey(String key, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (key == null) { // is this even legal call?\n+                return null;\n+            }\n+            try {\n+                // Ugh... should not have to give parser which may or may not be correct one...\n+                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n+                if (result != null) {\n+                    return result;\n+                }\n+            } catch (Exception re) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation: \"+re.getMessage());\n+            }\n+            throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n+        }\n+\n+        public Class<?> getKeyClass() { return _keyClass; }\n+    }\n+     \n     final static class EnumKD extends StdKeyDeserializer\n     {\n         protected final EnumResolver<?> _resolver;\n \n-        protected EnumKD(EnumResolver<?> er)\n-        {\n+        protected final AnnotatedMethod _factory;\n+\n+        protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) {\n             super(er.getEnumClass());\n             _resolver = er;\n-        }\n-\n-        @Override\n-        public Enum<?> _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+            _factory = factory;\n+        }\n+\n+        @Override\n+        public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            if (_factory != null) {\n+                try {\n+                    return _factory.call1(key);\n+                } catch (Exception e) {\n+                    ClassUtil.unwrapAndThrowAsIAE(e);\n+                }\n+            }\n             Enum<?> e = _resolver.findEnum(key);\n             if (e == null) {\n                 throw ctxt.weirdKeyException(_keyClass, key, \"not one of values for Enum class\");\n             return e;\n         }\n     }\n-\n+    \n     /**\n      * Key deserializer that calls a single-string-arg constructor\n      * to instantiate desired key type.\n         }\n \n         @Override\n-        public java.util.Date _parse(String key, DeserializationContext ctxt)\n+        public Object _parse(String key, DeserializationContext ctxt)\n             throws IllegalArgumentException, JsonMappingException\n         {\n             return ctxt.parseDate(key);\n         }\n \n         @Override\n-        public java.util.Calendar _parse(String key, DeserializationContext ctxt)\n+        public Object _parse(String key, DeserializationContext ctxt)\n             throws IllegalArgumentException, JsonMappingException\n         {\n             java.util.Date date = ctxt.parseDate(key);\n         }\n \n         @Override\n-        public UUID _parse(String key, DeserializationContext ctxt)\n+        public Object _parse(String key, DeserializationContext ctxt)\n             throws IllegalArgumentException, JsonMappingException\n         {\n             return UUID.fromString(key);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n \n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n     /**********************************************************\n      */\n \n-    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config, JavaType type)\n-    {\n-        return StdKeyDeserializer.StringKD.forType(type.getClass());\n+    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config, JavaType type) {\n+        return StdKeyDeserializer.StringKD.forType(type.getRawClass());\n     }\n     \n-    public static KeyDeserializer constructEnumKeyDeserializer(DeserializationConfig config, JavaType type)\n-    {\n-        EnumResolver<?> er = EnumResolver.constructUnsafe(type.getRawClass(), config.getAnnotationIntrospector());\n-        return new StdKeyDeserializer.EnumKD(er);\n+    public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) {\n+        return new StdKeyDeserializer.EnumKD(enumResolver, null);\n     }\n \n+    public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver,\n+            AnnotatedMethod factory) {\n+        return new StdKeyDeserializer.EnumKD(enumResolver, factory);\n+    }\n+    \n+    public static KeyDeserializer constructDelegatingKeyDeserializer(DeserializationConfig config,\n+            JavaType type, JsonDeserializer<?> deser)\n+    {\n+        return new StdKeyDeserializer.DelegatingKD(type.getRawClass(), deser);\n+    }\n+    \n     public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type)\n     {\n         /* We don't need full deserialization information, just need to", "timestamp": 1326848986, "metainfo": ""}