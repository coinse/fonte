{"sha": "247a3da8b4db8f900cf28c3998f549731b5289c9", "log": "refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n     }\n \n     @Override\n-    public void set(Object instance, Object value)\n-        throws IOException\n-    {\n+    public void set(Object instance, Object value) throws IOException {\n         _forward.set(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-        throws IOException\n-    {\n+    public Object setAndReturn(Object instance, Object value) throws IOException {\n         return _forward.setAndReturn(instance, value);\n     }\n \n         }\n \n         @Override\n-        public void handleResolvedForwardReference(Object id, Object value)\n-            throws IOException\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n         {\n             if (!hasId(id)) {\n                 throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         private final Collection<Object> _result;\n \n         /**\n-         * A list of {@link UnresolvedId} to maintain ordering.\n+         * A list of {@link CollectionReferring} to maintain ordering.\n          */\n-        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+        private List<CollectionReferring> _accumulator = new ArrayList<CollectionReferring>();\n \n         public CollectionReferringAccumulator(Class<?> elementType, Collection<Object> result) {\n             _elementType = elementType;\n             if (_accumulator.isEmpty()) {\n                 _result.add(value);\n             } else {\n-                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                CollectionReferring unresolvedId = _accumulator.get(_accumulator.size() - 1);\n                 unresolvedId._next.add(value);\n             }\n         }\n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference)\n         {\n-            UnresolvedId id = new UnresolvedId(this, reference, _elementType);\n+            CollectionReferring id = new CollectionReferring(this, reference, _elementType);\n             _accumulator.add(id);\n             return id;\n         }\n \n         public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n-            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            Iterator<CollectionReferring> iterator = _accumulator.iterator();\n             // Resolve ordering after resolution of an id. This mean either:\n             // 1- adding to the result collection in case of the first unresolved id.\n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Collection<Object> previous = _result;\n             while (iterator.hasNext()) {\n-                UnresolvedId unresolvedId = iterator.next();\n+                CollectionReferring unresolvedId = iterator.next();\n                 if (unresolvedId.hasId(id)) {\n                     iterator.remove();\n                     previous.add(value);\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class UnresolvedId extends Referring {\n+    private final static class CollectionReferring extends Referring {\n         private final CollectionReferringAccumulator _parent;\n         private final List<Object> _next = new ArrayList<Object>();\n         \n-        private UnresolvedId(CollectionReferringAccumulator parent,\n+        private CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n         {\n             super(reference, contentType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n-         * A list of {@link UnresolvedId} to maintain ordering.\n+         * A list of {@link MapReferring} to maintain ordering.\n          */\n-        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n+        private List<MapReferring> _accumulator = new ArrayList<MapReferring>();\n \n         public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n             _valueType = valueType;\n             if (_accumulator.isEmpty()) {\n                 _result.put(key, value);\n             } else {\n-                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n+                MapReferring unresolvedId = _accumulator.get(_accumulator.size() - 1);\n                 unresolvedId._next.put(key, value);\n             }\n         }\n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n         {\n-            UnresolvedId id = new UnresolvedId(this, reference, _valueType, key);\n+            MapReferring id = new MapReferring(this, reference, _valueType, key);\n             _accumulator.add(id);\n             return id;\n         }\n \n         public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n-            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            Iterator<MapReferring> iterator = _accumulator.iterator();\n             // Resolve ordering after resolution of an id. This mean either:\n             // 1- adding to the result map in case of the first unresolved id.\n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Map<Object,Object> previous = _result;\n             while (iterator.hasNext()) {\n-                UnresolvedId unresolvedId = iterator.next();\n+                MapReferring unresolvedId = iterator.next();\n                 if (unresolvedId.hasId(id)) {\n                     iterator.remove();\n                     previous.put(unresolvedId._key, value);\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class UnresolvedId extends Referring {\n+    private final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n         private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n         private final Object _key;\n         \n-        private UnresolvedId(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n         }\n \n         @Override\n-        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n-        {\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n             _parent.resolveForwardReference(id, value);\n         }\n     }", "timestamp": 1394854608, "metainfo": ""}