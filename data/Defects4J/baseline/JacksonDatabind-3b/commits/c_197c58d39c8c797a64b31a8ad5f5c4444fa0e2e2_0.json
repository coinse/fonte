{"sha": "197c58d39c8c797a64b31a8ad5f5c4444fa0e2e2", "log": "Serializer-side refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         _concrete.put(Character.TYPE.getName(), sls);\n \n         // Primitives/wrappers for primitives (primitives needed for Beans)\n-        _concrete.put(Boolean.TYPE.getName(), new StdSerializers.BooleanSerializer(true));\n-        _concrete.put(Boolean.class.getName(), new StdSerializers.BooleanSerializer(false));\n-        final JsonSerializer<?> intS = new StdSerializers.IntegerSerializer();\n-        _concrete.put(Integer.class.getName(), intS);\n-        _concrete.put(Integer.TYPE.getName(), intS);\n-        _concrete.put(Long.class.getName(), StdSerializers.LongSerializer.instance);\n-        _concrete.put(Long.TYPE.getName(), StdSerializers.LongSerializer.instance);\n-        _concrete.put(Byte.class.getName(), StdSerializers.IntLikeSerializer.instance);\n-        _concrete.put(Byte.TYPE.getName(), StdSerializers.IntLikeSerializer.instance);\n-        _concrete.put(Short.class.getName(), StdSerializers.IntLikeSerializer.instance);\n-        _concrete.put(Short.TYPE.getName(), StdSerializers.IntLikeSerializer.instance);\n-\n-        // Numbers, limited length floating point\n-        _concrete.put(Float.class.getName(), StdSerializers.FloatSerializer.instance);\n-        _concrete.put(Float.TYPE.getName(), StdSerializers.FloatSerializer.instance);\n-        _concrete.put(Double.class.getName(), StdSerializers.DoubleSerializer.instance);\n-        _concrete.put(Double.TYPE.getName(), StdSerializers.DoubleSerializer.instance);\n+        NumberSerializers.addAll(_concrete);\n+        _concrete.put(Boolean.TYPE.getName(), new BooleanSerializer(true));\n+        _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = new StdSerializers.NumberSerializer();\n+        final JsonSerializer<?> ns = new NumberSerializers.NumberSerializer();\n         _concrete.put(BigInteger.class.getName(), ns);\n         _concrete.put(BigDecimal.class.getName(), ns);\n         \n         _concrete.put(java.util.Date.class.getName(), dateSer);\n         // note: timestamps are very similar to java.util.Date, thus serialized as such\n         _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n-        _concrete.put(java.sql.Date.class.getName(), new StdSerializers.SqlDateSerializer());\n-        _concrete.put(java.sql.Time.class.getName(), new StdSerializers.SqlTimeSerializer());\n+        _concrete.put(java.sql.Date.class.getName(), new SqlDateSerializer());\n+        _concrete.put(java.sql.Time.class.getName(), new SqlTimeSerializer());\n \n         // And then other standard non-structured JDK types\n         for (Map.Entry<Class<?>,Object> en : new StdJdkSerializers().provide()) {\n         }\n         \n         if (Number.class.isAssignableFrom(raw)) {\n-            return StdSerializers.NumberSerializer.instance;\n+            return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n             @SuppressWarnings(\"unchecked\")\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+\n+/**\n+ * Serializer used for primitive boolean, as well as java.util.Boolean\n+ * wrapper type.\n+ *<p>\n+ * Since this is one of \"native\" types, no type information is ever\n+ * included on serialization (unlike for most scalar types as of 1.5)\n+ */\n+@JacksonStdImpl\n+public final class BooleanSerializer\n+    extends NonTypedScalarSerializerBase<Boolean>\n+{\n+    /**\n+     * Whether type serialized is primitive (boolean) or wrapper\n+     * (java.lang.Boolean); if true, former, if false, latter.\n+     */\n+    final boolean _forPrimitive;\n+\n+    public BooleanSerializer(boolean forPrimitive)\n+    {\n+        super(Boolean.class);\n+        _forPrimitive = forPrimitive;\n+    }\n+\n+    @Override\n+    public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeBoolean(value.booleanValue());\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"boolean\", !_forPrimitive);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+\n+/**\n+ * Container class for serializers used for handling standard JDK-provided types.\n+ */\n+public class NumberSerializers\n+{\n+    protected NumberSerializers() { }\n+    \n+    public static void addAll(Map<String, JsonSerializer<?>> allDeserializers)\n+    {\n+        final JsonSerializer<?> intS = new IntegerSerializer();\n+        allDeserializers.put(Integer.class.getName(), intS);\n+        allDeserializers.put(Integer.TYPE.getName(), intS);\n+        allDeserializers.put(Long.class.getName(), LongSerializer.instance);\n+        allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance);\n+        allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance);\n+        allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance);\n+        allDeserializers.put(Short.class.getName(), IntLikeSerializer.instance);\n+        allDeserializers.put(Short.TYPE.getName(), IntLikeSerializer.instance);\n+\n+        // Numbers, limited length floating point\n+        allDeserializers.put(Float.class.getName(), FloatSerializer.instance);\n+        allDeserializers.put(Float.TYPE.getName(), FloatSerializer.instance);\n+        allDeserializers.put(Double.class.getName(), DoubleSerializer.instance);\n+        allDeserializers.put(Double.TYPE.getName(), DoubleSerializer.instance);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers\n+    /**********************************************************\n+     */\n+    \n+\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, numerics\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is the special serializer for regular {@link java.lang.Integer}s\n+     * (and primitive ints)\n+     *<p>\n+     * Since this is one of \"native\" types, no type information is ever\n+     * included on serialization (unlike for most scalar types as of 1.5)\n+     */\n+    @JacksonStdImpl\n+    public final static class IntegerSerializer\n+        extends NonTypedScalarSerializerBase<Integer>\n+    {\n+        public IntegerSerializer() { super(Integer.class); }\n+    \n+        @Override\n+        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.intValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+\n+    /**\n+     * Similar to {@link IntegerSerializer}, but will not cast to Integer:\n+     * instead, cast is to {@link java.lang.Number}, and conversion is\n+     * by calling {@link java.lang.Number#intValue}.\n+     */\n+    @JacksonStdImpl\n+    public final static class IntLikeSerializer\n+        extends StdScalarSerializer<Number>\n+    {\n+        final static IntLikeSerializer instance = new IntLikeSerializer();\n+    \n+        public IntLikeSerializer() { super(Number.class); }\n+        \n+        @Override\n+        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.intValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongSerializer\n+        extends StdScalarSerializer<Long>\n+    {\n+        final static LongSerializer instance = new LongSerializer();\n+    \n+        public LongSerializer() { super(Long.class); }\n+        \n+        @Override\n+        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.longValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+    \n+    @JacksonStdImpl\n+    public final static class FloatSerializer\n+        extends StdScalarSerializer<Float>\n+    {\n+        final static FloatSerializer instance = new FloatSerializer();\n+    \n+        public FloatSerializer() { super(Float.class); }\n+        \n+        @Override\n+        public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.floatValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+\n+    /**\n+     * This is the special serializer for regular {@link java.lang.Double}s\n+     * (and primitive doubles)\n+     *<p>\n+     * Since this is one of \"native\" types, no type information is ever\n+     * included on serialization (unlike for most scalar types as of 1.5)\n+     */\n+    @JacksonStdImpl\n+    public final static class DoubleSerializer\n+        extends NonTypedScalarSerializerBase<Double>\n+    {\n+        final static DoubleSerializer instance = new DoubleSerializer();\n+    \n+        public DoubleSerializer() { super(Double.class); }\n+    \n+        @Override\n+        public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.doubleValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+    \n+    /**\n+     * As a fallback, we may need to use this serializer for other\n+     * types of {@link Number}s (custom types).\n+     */\n+    @JacksonStdImpl\n+    public final static class NumberSerializer\n+        extends StdScalarSerializer<Number>\n+    {\n+        public final static NumberSerializer instance = new NumberSerializer();\n+    \n+        public NumberSerializer() { super(Number.class); }\n+    \n+        @Override\n+        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n+            if (value instanceof BigDecimal) {\n+                jgen.writeNumber((BigDecimal) value);\n+            } else if (value instanceof BigInteger) {\n+                jgen.writeNumber((BigInteger) value);\n+                \n+            /* These shouldn't match (as there are more specific ones),\n+             * but just to be sure:\n+             */\n+            } else if (value instanceof Integer) {\n+                jgen.writeNumber(value.intValue());\n+            } else if (value instanceof Long) {\n+                jgen.writeNumber(value.longValue());\n+            } else if (value instanceof Double) {\n+                jgen.writeNumber(value.doubleValue());\n+            } else if (value instanceof Float) {\n+                jgen.writeNumber(value.floatValue());\n+            } else if ((value instanceof Byte) || (value instanceof Short)) {\n+                jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n+            } else {\n+                // We'll have to use fallback \"untyped\" number write method\n+                jgen.writeNumber(value.toString());\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonNode;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+\n+/**\n+ * Compared to regular {@link java.util.Date} serialization, we do use String\n+ * representation here. Why? Basically to truncate of time part, since\n+ * that should not be used by plain SQL date.\n+ */\n+@JacksonStdImpl\n+public class SqlDateSerializer\n+    extends StdScalarSerializer<java.sql.Date>\n+{\n+    public SqlDateSerializer() { super(java.sql.Date.class); }\n+\n+    @Override\n+    public void serialize(java.sql.Date value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.toString());\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //todo: (ryan) add a format for the date in the schema?\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+\n+@JacksonStdImpl\n+public class SqlTimeSerializer\n+    extends StdScalarSerializer<java.sql.Time>\n+{\n+    public SqlTimeSerializer() { super(java.sql.Time.class); }\n+\n+    @Override\n+    public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.toString());\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+}", "timestamp": 1327171992, "metainfo": ""}