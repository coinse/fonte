{"sha": "845897f6970c70f35ddd880d538765ec5a2956f4", "log": "Combine a bunch of simple \"from-string\" deserialziers", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.*;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Currency;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.DeserializationContext;\n \n /**\n  * Base class for simple deserializers that only accept JSON String\n  * values as the source.\n  */\n-public abstract class FromStringDeserializer<T>\n-    extends StdScalarDeserializer<T>\n+@SuppressWarnings(\"serial\")\n+public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n {\n-    private static final long serialVersionUID = 1L;\n-\n+    public static Class<?>[] types() {\n+        return new Class<?>[] {\n+            URL.class,\n+            URI.class,\n+            File.class,\n+            Currency.class,\n+            Pattern.class,\n+            Locale.class,\n+        };\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserializer implementations\n+    /**********************************************************\n+     */\n+    \n     protected FromStringDeserializer(Class<?> vc) {\n         super(vc);\n     }\n \n+    /**\n+     * Factory method for trying to find a deserializer for one of supported\n+     * types that have simple from-String serialization.\n+     */\n+    public static Std findDeserializer(Class<?> rawType)\n+    {\n+        int kind = 0;\n+        if (rawType == File.class) {\n+            kind = Std.STD_FILE;\n+        } else if (rawType == URL.class) {\n+            kind = Std.STD_URL;\n+        } else if (rawType == URI.class) {\n+            kind = Std.STD_URI;\n+        } else if (rawType == Currency.class) {\n+            kind = Std.STD_CURRENCY;\n+        } else if (rawType == Pattern.class) {\n+            kind = Std.STD_PATTERN;\n+        } else if (rawType == Locale.class) {\n+            kind = Std.STD_LOCALE;\n+        } else {\n+            return null;\n+        }\n+        return new Std(rawType, kind);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Deserializer implementations\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public final T deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n         String text = jp.getValueAsString();\n         throw ctxt.mappingException(_valueClass);\n     }\n         \n-    protected abstract T _deserialize(String value, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n \n-    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException {\n         // default impl: error out\n-        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type \"\n-                +ob.getClass().getName()+\" into \"+_valueClass.getName());\n+        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type \"+ob.getClass().getName()+\" into \"+_valueClass.getName());\n     }\n \n+    /*\n+    /**********************************************************\n+    /* A general-purpose implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * \"Chameleon\" deserializer that works on simple types that are deserialized\n+     * from a simple String.\n+     * \n+     * @since 2.4\n+     */\n+    public static class Std extends FromStringDeserializer<Object>\n+    {\n+        private static final long serialVersionUID = 1;\n+\n+        public final static int STD_FILE = 1;\n+        public final static int STD_URL = 2;\n+        public final static int STD_URI = 3;\n+        public final static int STD_CURRENCY = 4;\n+        public final static int STD_PATTERN = 5;\n+        public final static int STD_LOCALE = 6;\n+        \n+        protected final int _kind;\n+        \n+        protected Std(Class<?> valueType, int kind) {\n+            super(valueType);\n+            _kind = kind;\n+        }\n+\n+        @Override\n+        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n+        {\n+            switch (_kind) {\n+            case STD_FILE:\n+                return new File(value);\n+            case STD_URL:\n+                return new URL(value);\n+            case STD_URI:\n+                return URI.create(value);\n+            case STD_CURRENCY:\n+                // will throw IAE if unknown:\n+                return Currency.getInstance(value);\n+            case STD_PATTERN:\n+                // will throw IAE (or its subclass) if malformed\n+                return Pattern.compile(value);\n+            case STD_LOCALE:\n+                {\n+                    int ix = value.indexOf('_');\n+                    if (ix < 0) { // single argument\n+                        return new Locale(value);\n+                    }\n+                    String first = value.substring(0, ix);\n+                    value = value.substring(ix+1);\n+                    ix = value.indexOf('_');\n+                    if (ix < 0) { // two pieces\n+                        return new Locale(first, value);\n+                    }\n+                    String second = value.substring(0, ix);\n+                    return new Locale(first, second, value.substring(ix+1));\n+                }\n+            }\n+            throw new IllegalArgumentException();\n+        }\n+        \n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/InetAddressDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/InetAddressDeserializer.java\n /**\n  * As per [JACKSON-484], also need special handling for InetAddress...\n  */\n-class InetAddressDeserializer\n-    extends FromStringDeserializer<InetAddress>\n+public class InetAddressDeserializer extends FromStringDeserializer<InetAddress>\n {\n     private static final long serialVersionUID = 1L;\n-\n-    public final static InetAddressDeserializer instance = new InetAddressDeserializer();\n \n     public InetAddressDeserializer() { super(InetAddress.class); }\n \n     @Override\n-    protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n-        throws IOException\n-    {\n+    protected InetAddress _deserialize(String value, DeserializationContext ctxt) throws IOException {\n         return InetAddress.getByName(value);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/InetSocketAddressDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/InetSocketAddressDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n-    public final static InetSocketAddressDeserializer instance = new InetSocketAddressDeserializer();\n-\n     public InetSocketAddressDeserializer() { super(InetSocketAddress.class); }\n \n     @Override\n     protected InetSocketAddress _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n+        throws IOException\n     {\n         if (value.startsWith(\"[\")) {\n             // bracketed IPv6 (with port number)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JavaTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JavaTypeDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n     public JavaTypeDeserializer() { super(JavaType.class); }\n     \n     @Override\n-    public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         JsonToken curr = jp.getCurrentToken();\n         // Usually should just get string value:\n         if (curr == JsonToken.VALUE_STRING) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n package com.fasterxml.jackson.databind.deser.std;\n \n-import java.io.*;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.net.URL;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.regex.Pattern;\n \n import com.fasterxml.jackson.databind.*;\n \n  * Container class that contains serializers for JDK types that\n  * require special handling for some reason.\n  */\n-@SuppressWarnings(\"serial\")\n public class JdkDeserializers\n {\n     private final static HashSet<String> _classNames = new HashSet<String>();\n     static {\n         // note: can skip primitive types; other ways to check them:\n-        Class<?>[] numberTypes = new Class<?>[] {\n+        Class<?>[] types = new Class<?>[] {\n                 UUID.class,\n-                URL.class,\n-                URI.class,\n-                File.class,\n-                Currency.class,\n-                Pattern.class,\n-                Locale.class,\n                 InetAddress.class,\n                 InetSocketAddress.class,\n                 Charset.class,\n                 StackTraceElement.class,\n                 ByteBuffer.class\n         };\n-        for (Class<?> cls : numberTypes) {\n+        for (Class<?> cls : types) {\n+            _classNames.add(cls.getName());\n+        }\n+        for (Class<?> cls : FromStringDeserializer.types()) {\n             _classNames.add(cls.getName());\n         }\n     }\n         if (!_classNames.contains(clsName)) {\n             return null;\n         }\n-        /* Ok: following ones would work via String-arg detection too;\n-         * if we get more may want to formally change.\n-         */\n-        if (rawType == URI.class) {\n-            return URIDeserializer.instance;\n+        JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);\n+        if (d != null) {\n+            return d;\n         }\n-        if (rawType == URL.class) {\n-            return URLDeserializer.instance;\n-        }\n-        if (rawType == File.class) {\n-            return FileDeserializer.instance;\n-        }\n-        /* But these will require custom handling regardless:\n-         */\n         if (rawType == UUID.class) {\n-            return UUIDDeserializer.instance;\n-        }\n-        if (rawType == Currency.class) {\n-            return CurrencyDeserializer.instance;\n-        }\n-        if (rawType == Pattern.class) {\n-            return PatternDeserializer.instance;\n-        }\n-        if (rawType == Locale.class) {\n-            return LocaleDeserializer.instance;\n+            return new UUIDDeserializer();\n         }\n         if (rawType == InetAddress.class) {\n-            return InetAddressDeserializer.instance;\n+            return new InetAddressDeserializer();\n         }\n         if (rawType == InetSocketAddress.class) {\n-            return InetSocketAddressDeserializer.instance;\n+            return new InetSocketAddressDeserializer();\n         }\n         if (rawType == Charset.class) {\n             return new CharsetDeserializer();\n         // should never occur\n         throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+clsName);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Deserializer implementations: from-String deserializers\n-    /**********************************************************\n-     */\n-\n-    public static class URLDeserializer\n-        extends FromStringDeserializer<URL>\n-    {\n-        public final static URLDeserializer instance = new URLDeserializer();\n-\n-        public URLDeserializer() { super(URL.class); }\n-        \n-        @Override\n-        protected URL _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            return new URL(value);\n-        }\n-    }\n-    \n-    public static class URIDeserializer\n-        extends FromStringDeserializer<URI>\n-    {\n-        public final static URIDeserializer instance = new URIDeserializer();\n-\n-        public URIDeserializer() { super(URI.class); }\n-    \n-        @Override\n-        protected URI _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            return URI.create(value);\n-        }\n-    }\n-    \n-    public static class CurrencyDeserializer\n-        extends FromStringDeserializer<Currency>\n-    {\n-        public final static CurrencyDeserializer instance = new CurrencyDeserializer();\n-\n-        public CurrencyDeserializer() { super(Currency.class); }\n-        \n-        @Override\n-        protected Currency _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            // will throw IAE if unknown:\n-            return Currency.getInstance(value);\n-        }\n-    }\n-    \n-    public static class PatternDeserializer\n-        extends FromStringDeserializer<Pattern>\n-    {\n-        public final static PatternDeserializer instance = new PatternDeserializer();\n-\n-        public PatternDeserializer() { super(Pattern.class); }\n-        \n-        @Override\n-        protected Pattern _deserialize(String value, DeserializationContext ctxt)\n-            throws IllegalArgumentException\n-        {\n-            // will throw IAE (or its subclass) if malformed\n-            return Pattern.compile(value);\n-        }\n-    }\n-    \n-    /**\n-     * Kept protected as it's not meant to be extensible at this point\n-     */\n-    protected static class LocaleDeserializer\n-        extends FromStringDeserializer<Locale>\n-    {\n-        public final static LocaleDeserializer instance = new LocaleDeserializer();\n-\n-        public LocaleDeserializer() { super(Locale.class); }\n-        \n-        @Override\n-        protected Locale _deserialize(String value, DeserializationContext ctxt)\n-            throws IOException\n-        {\n-            int ix = value.indexOf('_');\n-            if (ix < 0) { // single argument\n-                return new Locale(value);\n-            }\n-            String first = value.substring(0, ix);\n-            value = value.substring(ix+1);\n-            ix = value.indexOf('_');\n-            if (ix < 0) { // two pieces\n-                return new Locale(first, value);\n-            }\n-            String second = value.substring(0, ix);\n-            return new Locale(first, second, value.substring(ix+1));\n-        }\n-    }\n-    \n-    public static class FileDeserializer\n-        extends FromStringDeserializer<File>\n-    {\n-        public final static FileDeserializer instance = new FileDeserializer();\n-\n-        public FileDeserializer() { super(File.class); }\n-        \n-        @Override\n-        protected File _deserialize(String value, DeserializationContext ctxt)\n-        {\n-            return new File(value);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n     final static class LocaleKD extends StdKeyDeserializer {\n         private static final long serialVersionUID = 1L;\n \n-        protected JdkDeserializers.LocaleDeserializer _localeDeserializer;\n-\n-        LocaleKD() { super(Locale.class); _localeDeserializer = new JdkDeserializers.LocaleDeserializer();}\n-\n-        @Override\n-        protected Locale _parse(String key, DeserializationContext ctxt) throws JsonMappingException {\n+        protected FromStringDeserializer<?> _deser;\n+\n+        LocaleKD() { super(Locale.class);\n+            _deser = FromStringDeserializer.findDeserializer(Locale.class);\n+        }\n+\n+        @Override\n+        protected Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException {\n             try {\n-                return _localeDeserializer._deserialize(key,ctxt);\n+                return _deser._deserialize(key, ctxt);\n             } catch (IOException e) {\n                 throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as locale\");\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n     }\n    \n     @Override\n-    public String[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n         if (!jp.isExpectedStartArrayToken()) {\n     /**\n      * Offlined version used when we do not use the default deserialization method.\n      */\n-    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n         Object[] chunk = buffer.resetAndStart();\n     }\n     \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-        TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n     }\n \n-    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n      * of String values, or if we have to use separate value deserializer.\n      */\n     @Override\n-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-            BeanProperty property) throws JsonMappingException\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n     {\n         JsonDeserializer<?> deser = _elementDeserializer;\n         // #125: May have a content converter\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<String>) _valueInstantiator.createUsingDelegate(ctxt,\n     @Override\n     public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,\n                                           Collection<String> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // Ok: must point to START_ARRAY\n         if (!jp.isExpectedStartArrayToken()) {\n     }\n     \n     private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,\n-            Collection<String> result, final JsonDeserializer<String> deser)\n-        throws IOException, JsonProcessingException\n+            Collection<String> result, final JsonDeserializer<String> deser) throws IOException\n     {\n         JsonToken t;\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n     }\n     \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n     }\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n-    private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n-            Collection<String> result)\n-        throws IOException, JsonProcessingException\n+    private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt, Collection<String> result) throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n @JacksonStdImpl\n-public final class StringDeserializer\n-    extends StdScalarDeserializer<String>\n+public final class StringDeserializer extends StdScalarDeserializer<String>\n {\n     private static final long serialVersionUID = 1L;\n \n     public StringDeserializer() { super(String.class); }\n \n     @Override\n-    public String deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n         String text = jp.getValueAsString();\n     // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n     // (is it an error to even call this version?)\n     @Override\n-    public String deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+    public String deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n         return deserialize(jp, ctxt);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n     /************************************************************\n      */\n \n-    public ThrowableDeserializer(BeanDeserializer baseDeserializer)\n-    {\n+    public ThrowableDeserializer(BeanDeserializer baseDeserializer) {\n         super(baseDeserializer);\n         // need to disable this, since we do post-processing\n         _vanillaProcessing = false;\n     /**\n      * Alternative constructor used when creating \"unwrapping\" deserializers\n      */\n-    protected ThrowableDeserializer(BeanDeserializer src, NameTransformer unwrapper)\n-    {\n+    protected ThrowableDeserializer(BeanDeserializer src, NameTransformer unwrapper) {\n         super(src, unwrapper);\n     }\n     \n     @Override\n-    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper)\n-    {\n+    public JsonDeserializer<Object> unwrappingDeserializer(NameTransformer unwrapper) {\n         if (getClass() != ThrowableDeserializer.class) {\n             return this;\n         }\n      */\n \n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n         if (_propertyBasedCreator != null) { // proper @JsonCreator\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n     public TokenBufferDeserializer() { super(TokenBuffer.class); }\n \n     @Override\n-    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return createBufferInstance(jp).deserialize(jp, ctxt);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java\n import java.util.UUID;\n \n import com.fasterxml.jackson.core.Base64Variants;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.DeserializationContext;\n \n-public class UUIDDeserializer\n-    extends FromStringDeserializer<UUID>\n+public class UUIDDeserializer extends FromStringDeserializer<UUID>\n {\n     private static final long serialVersionUID = 1L;\n \n     final static int[] HEX_DIGITS = new int[127];\n     static {\n         Arrays.fill(HEX_DIGITS, -1);\n-        for (int i = 0; i < 10; ++i) {\n-            HEX_DIGITS['0' + i] = i;\n-        }\n+        for (int i = 0; i < 10; ++i) { HEX_DIGITS['0' + i] = i; }\n         for (int i = 0; i < 6; ++i) {\n             HEX_DIGITS['a' + i] = 10 + i;\n             HEX_DIGITS['A' + i] = 10 + i;\n         }\n     }\n \n-    public final static UUIDDeserializer instance = new UUIDDeserializer();\n-\n     public UUIDDeserializer() { super(UUID.class); }\n \n     @Override\n-    protected UUID _deserialize(String id, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected UUID _deserialize(String id, DeserializationContext ctxt) throws IOException\n     {\n         // Adapted from java-uuid-generator (https://github.com/cowtowncoder/java-uuid-generator)\n         // which is 5x faster than UUID.fromString(value), as oper \"ManualReadPerfWithUUID\"\n     }\n     \n     @Override\n-    protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException\n     {\n         if (ob instanceof byte[]) {\n             return _fromBytes((byte[]) ob, ctxt);\n     }\n     \n     static int intFromChars(String str, int index) {\n-        return (byteFromChars(str, index) << 24)\n-                +(byteFromChars(str, index+2) << 16)\n-                +(byteFromChars(str, index+4) << 8)\n-                + byteFromChars(str, index+6);\n+        return (byteFromChars(str, index) << 24) + (byteFromChars(str, index+2) << 16) + (byteFromChars(str, index+4) << 8) + byteFromChars(str, index+6);\n     }\n     \n     static int shortFromChars(String str, int index) {\n                 +\"' (value 0x\"+Integer.toHexString(c)+\") for UUID String \\\"\"+uuidStr+\"\\\"\");\n     }\n     \n-    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    private UUID _fromBytes(byte[] bytes, DeserializationContext ctxt) throws IOException {\n         if (bytes.length != 16) {\n             ctxt.mappingException(\"Can only construct UUIDs from byte[16]; got \"+bytes.length+\" bytes\");\n         }\n         return new UUID(_long(bytes, 0), _long(bytes, 8));\n     }\n \n-    private static long _long(byte[] b, int offset)\n-    {\n+    private static long _long(byte[] b, int offset) {\n         long l1 = ((long) _int(b, offset)) << 32;\n         long l2 = _int(b, offset+4);\n         // faster to just do it than check if it has sign\n         return l1 | l2;\n     }\n \n-    private static int _int(byte[] b, int offset)\n-    {\n-        return (b[offset] << 24)\n-                | ((b[offset+1] & 0xFF) << 16)\n-                | ((b[offset+2] & 0xFF) << 8)\n-                | (b[offset+3] & 0xFF)\n-                ;\n+    private static int _int(byte[] b, int offset) {\n+        return (b[offset] << 24) | ((b[offset+1] & 0xFF) << 16) | ((b[offset+2] & 0xFF) << 8) | (b[offset+3] & 0xFF);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n      */\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         switch (jp.getCurrentToken()) {\n         case FIELD_NAME:\n     }\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         switch (t) {\n     /**\n      * Method called to map a JSON Array into a Java value.\n      */\n-    protected Object mapArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // Minor optimization to handle small lists (default size for ArrayList is 10)\n         if (jp.nextToken()  == JsonToken.END_ARRAY) {\n     /**\n      * Method called to map a JSON Object into a Java value.\n      */\n-    protected Object mapObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n     /**\n      * Method called to map a JSON Array into a Java Object array (Object[]).\n      */\n-    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         // Minor optimization to handle small lists (default size for ArrayList is 10)\n         if (jp.nextToken()  == JsonToken.END_ARRAY) {", "timestamp": 1388609779, "metainfo": ""}