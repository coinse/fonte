{"sha": "5abbb53fa2da96a7548d4bf25d5954d5f58e8105", "log": "Removed buffering during object id resolution, no longer needed. Fixes FasterXML/jackson-dataformat-xml#104", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    @SuppressWarnings(\"resource\")\n     protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n     {\n-        final String idPropName = _objectIdReader.propertyName.getSimpleName();\n-        // First, the simple case: we point to the Object Id property\n-        if (idPropName.equals(jp.getCurrentName())\n-                // 05-Aug-2013, tatu: Or might point to a native Object Id\n-                || jp.canReadObjectId()) {\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        // otherwise need to reorder things\n-        TokenBuffer tmpBuffer = new TokenBuffer(jp);\n-        TokenBuffer mergedBuffer = null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // when we match the id property, can start merging\n-            if (mergedBuffer == null) {\n-                if (idPropName.equals(propName)) {\n-                    mergedBuffer = new TokenBuffer(jp);\n-                    mergedBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    mergedBuffer.copyCurrentStructure(jp);\n-                    mergedBuffer.append(tmpBuffer);\n-                    tmpBuffer = null;\n-                } else {\n-                    tmpBuffer.writeFieldName(propName);\n-                    jp.nextToken();\n-                    tmpBuffer.copyCurrentStructure(jp);\n-                }\n-            } else {\n-                mergedBuffer.writeFieldName(propName);\n-                jp.nextToken();\n-                mergedBuffer.copyCurrentStructure(jp);\n-            }\n-        }\n-        // note: we really should get merged buffer (and if not, that is likely error), but\n-        // for now let's allow missing case as well. Will be caught be a later stage...\n-        TokenBuffer buffer = (mergedBuffer == null) ? tmpBuffer : mergedBuffer;\n-        buffer.writeEndObject();\n-        // important: need to advance to point to first FIELD_NAME:\n-        JsonParser mergedParser = buffer.asParser();\n-        mergedParser.nextToken();\n-        return deserializeFromObject(mergedParser, ctxt);\n+        return deserializeFromObject(jp, ctxt);\n     }\n     \n     /**", "timestamp": 1392664485, "metainfo": ""}