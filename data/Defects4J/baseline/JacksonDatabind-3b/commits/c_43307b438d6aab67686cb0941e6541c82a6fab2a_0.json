{"sha": "43307b438d6aab67686cb0941e6541c82a6fab2a", "log": "Fixed #23", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n     implements java.io.Serializable, // 2.1\n         java.lang.reflect.Type // 2.2\n {\n-    // for 2.1.0:\n-    private static final long serialVersionUID = -5321897246493723158L;\n+    private static final long serialVersionUID = 6774285981275451126L;\n \n     /**\n      * This is the nominal type-erased Class that would be close to the\n      * different kinds of handlers, with unrelated types.\n      */\n     protected final Object _typeHandler;\n-    \n+\n+    /**\n+     * Whether entities defined with this type should be handled using\n+     * static typing (as opposed to dynamic runtime type) or not.\n+     * \n+     * @since 2.2\n+     */\n+    protected final boolean _asStatic;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n      *   to hash code of the class name \n      */\n     protected JavaType(Class<?> raw, int additionalHash,\n-            Object valueHandler, Object typeHandler)\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n         _class = raw;\n         _hashCode = raw.getName().hashCode() + additionalHash;\n         _valueHandler = valueHandler;\n         _typeHandler = typeHandler;\n-    }\n-\n-    /**\n-     * Serialization method called when no additional type information is\n-     * to be included in serialization.\n-     */\n+        _asStatic = asStatic;\n+    }\n     \n     /**\n      * \"Copy method\" that will construct a new instance that is identical to\n      * @return Newly created type instance\n      */\n     public abstract JavaType withContentValueHandler(Object h);\n+\n+    /**\n+     * Method that can be called to get a type instance that indicates\n+     * that values of the type should be handled using \"static typing\" for purposes\n+     * of serialization (as opposed to \"dynamic\" aka runtime typing):\n+     * meaning that no runtime information is needed for determining serializers to use.\n+     * The main use case is to allow forcing of specific root value serialization type,\n+     * and specifically in resolving serializers for contained types (element types\n+     * for arrays, Collections and Maps).\n+     * \n+     * @since 2.2\n+     */\n+    public abstract JavaType withStaticTyping();\n     \n     /*\n     /**********************************************************\n      */\n     @Override\n     public boolean isMapLikeType() { return false; }\n+\n+    /**\n+     * Accessor for checking whether handlers for dealing with values of\n+     * this type should use static typing (as opposed to dynamic typing).\n+     * Note that while value of 'true' does mean that static typing is to\n+     * be used, value of 'false' may still be overridden by other settings.\n+     * \n+     * @since 2.2\n+     */\n+    public final boolean useStaticType() {\n+        return _asStatic;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * type.\n      */\n     public ObjectWriter writerWithType(Class<?> rootType) {\n-        JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n-        return new ObjectWriter(this, getSerializationConfig(), t, /*PrettyPrinter*/null);\n+        return new ObjectWriter(this, getSerializationConfig(),\n+                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n+                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n     }\n \n     /**\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n-    public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n+        return new ObjectWriter(this, getSerializationConfig(),\n+                // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n+                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n     }\n \n     /**\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n-    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n-        return new ObjectWriter(this, getSerializationConfig(), t, /*PrettyPrinter*/null);\n+    public ObjectWriter writerWithType(JavaType rootType) {\n+        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n         _serializerFactory = mapper._serializerFactory;\n         _jsonFactory = mapper._jsonFactory;\n \n+        if (rootType != null) {\n+            rootType = rootType.withStaticTyping();\n+        }\n         _rootType = rootType;\n         _prettyPrinter = pp;\n         _schema = null;\n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _jsonFactory = base._jsonFactory;\n-        \n+\n         _rootType = rootType;\n         _rootSerializer = rootSer;\n         _prettyPrinter = pp;\n         _serializerFactory = base._serializerFactory;\n         _jsonFactory = base._jsonFactory;\n         _schema = base._schema;\n-        \n+\n         _rootType = base._rootType;\n         _rootSerializer = base._rootSerializer;\n         _prettyPrinter = base._prettyPrinter;\n      */\n     public ObjectWriter withType(JavaType rootType)\n     {\n+        // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n+        rootType = rootType.withStaticTyping();\n         JsonSerializer<Object> rootSer = _prefetchRootSerializer(_config, rootType);\n-        return (rootType == _rootType) ? this\n-        // type is stored here, no need to make a copy of config\n-            : new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema);\n+        return new ObjectWriter(this, _config, rootType, rootSer, _prettyPrinter, _schema);\n     }    \n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         throws JsonMappingException\n     {\n         final SerializationConfig config = prov.getConfig();\n+\n+        /* [Issue#23], 15-Mar-2013, tatu: must force static handling of root value type,\n+         *   with just one important exception: if value type is \"untyped\", let's\n+         *   leave it as is; no clean way to make it work.\n+         */\n+        if (!staticTyping && type.useStaticType()) {\n+            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n+                staticTyping = true;\n+            }\n+        }\n+        \n         // Let's see what we can learn about element/content/value type, type serializer for it:\n         JavaType elementType = type.getContentType();\n         TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n         if (t != null) {\n-            if (t == JsonSerialize.Typing.STATIC) {\n-                return true;\n-            }\n-        } else {\n-            if (config.isEnabled(MapperFeature.USE_STATIC_TYPING)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+            return (t == JsonSerialize.Typing.STATIC);\n+        }\n+        return config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n     }\n \n     protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n public final class ArrayType\n     extends TypeBase\n {\n-    private static final long serialVersionUID = -6866628807166594553L;\n+    private static final long serialVersionUID = 9040058063449087477L;\n \n     /**\n      * Type of elements in the array.\n      * it is essentially immutable and thus can be shared.\n      */\n     protected final Object _emptyArray;\n-\n+    \n     private ArrayType(JavaType componentType, Object emptyInstance,\n-            Object valueHandler, Object typeHandler)\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n         super(emptyInstance.getClass(), componentType.hashCode(),\n-                valueHandler, typeHandler);\n+                valueHandler, typeHandler, asStatic);\n         _componentType = componentType;\n         _emptyArray = emptyInstance;\n     }\n          * passing that in).\n          */\n         Object emptyInstance = Array.newInstance(componentType.getRawClass(), 0);\n-        return new ArrayType(componentType, emptyInstance, null, null);\n+        return new ArrayType(componentType, emptyInstance, null, null, false);\n     }                                   \n     \n     @Override\n         if (h == _typeHandler) {\n             return this;\n         }\n-        return new ArrayType(_componentType, _emptyArray, _valueHandler, h);\n+        return new ArrayType(_componentType, _emptyArray, _valueHandler, h, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new ArrayType(_componentType.withTypeHandler(h), _emptyArray,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n         if (h == _valueHandler) {\n             return this;\n         }\n-        return new ArrayType(_componentType, _emptyArray, h, _typeHandler);\n+        return new ArrayType(_componentType, _emptyArray, h, _typeHandler,_asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new ArrayType(_componentType.withValueHandler(h), _emptyArray,\n-                _valueHandler, _typeHandler);\n-    }\n-    \n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public ArrayType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new ArrayType(_componentType.withStaticTyping(),\n+                _emptyArray, _valueHandler, _typeHandler, true);\n+    }\n+\n     @Override\n     protected String buildCanonicalName() {\n         return _class.getName();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Methods for narrowing conversions\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n  */\n public class CollectionLikeType extends TypeBase\n {\n-    private static final long serialVersionUID = -2079769185110719683L;\n+    private static final long serialVersionUID = 4611641304150899138L;\n \n     /**\n      * Type of elements in collection\n      */\n \n     protected CollectionLikeType(Class<?> collT, JavaType elemT,\n-            Object valueHandler, Object typeHandler)\n-    {\n-        super(collT, elemT.hashCode(), valueHandler, typeHandler);\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        super(collT, elemT.hashCode(), valueHandler, typeHandler, asStatic);\n         _elementType = elemT;\n     }\n     \n     @Override\n     protected JavaType _narrow(Class<?> subclass) {\n         return new CollectionLikeType(subclass, _elementType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new CollectionLikeType(_class, _elementType.narrowBy(contentClass),\n-                _valueHandler, _typeHandler);    }\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n \n     @Override\n     public JavaType widenContentsBy(Class<?> contentClass)\n             return this;\n         }\n         return new CollectionLikeType(_class, _elementType.widenBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     public static CollectionLikeType construct(Class<?> rawType, JavaType elemT)\n     {\n         // nominally component types will be just Object.class\n-        return new CollectionLikeType(rawType, elemT, null, null);\n+        return new CollectionLikeType(rawType, elemT, null, null, false);\n     }\n \n     @Override\n     public CollectionLikeType withTypeHandler(Object h)\n     {\n-        return new CollectionLikeType(_class, _elementType, _valueHandler, h);\n+        return new CollectionLikeType(_class, _elementType, _valueHandler, h, _asStatic);\n     }\n \n     @Override\n     public CollectionLikeType withContentTypeHandler(Object h)\n     {\n         return new CollectionLikeType(_class, _elementType.withTypeHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public CollectionLikeType withValueHandler(Object h) {\n-        return new CollectionLikeType(_class, _elementType, h, _typeHandler);\n+        return new CollectionLikeType(_class, _elementType, h, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public CollectionLikeType withContentValueHandler(Object h) {\n         return new CollectionLikeType(_class, _elementType.withValueHandler(h),\n-                _valueHandler, _typeHandler);\n-    }\n-    \n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public CollectionLikeType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new CollectionLikeType(_class, _elementType.withStaticTyping(),\n+                _valueHandler, _typeHandler, true);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n public final class CollectionType\n     extends CollectionLikeType\n {\n-    private static final long serialVersionUID = 7218006718717444365L;\n+    private static final long serialVersionUID = -7834910259750909424L;\n \n     /*\n     /**********************************************************\n      */\n \n     private CollectionType(Class<?> collT, JavaType elemT,\n-            Object valueHandler, Object typeHandler)\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n-        super(collT,  elemT, valueHandler, typeHandler);\n+        super(collT,  elemT, valueHandler, typeHandler, asStatic);\n     }\n \n     @Override\n     protected JavaType _narrow(Class<?> subclass) {\n-        return new CollectionType(subclass, _elementType, null, null);\n+        return new CollectionType(subclass, _elementType, null, null, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new CollectionType(_class, _elementType.narrowBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new CollectionType(_class, _elementType.widenBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     public static CollectionType construct(Class<?> rawType, JavaType elemT)\n     {\n         // nominally component types will be just Object.class\n-        return new CollectionType(rawType, elemT, null, null);\n+        return new CollectionType(rawType, elemT, null, null, false);\n     }\n \n     // Since 1.7:\n     @Override\n     public CollectionType withTypeHandler(Object h) {\n-        return new CollectionType(_class, _elementType, _valueHandler, h);\n+        return new CollectionType(_class, _elementType, _valueHandler, h, _asStatic);\n     }\n \n     // Since 1.7:\n     public CollectionType withContentTypeHandler(Object h)\n     {\n         return new CollectionType(_class, _elementType.withTypeHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n-    // Since 1.9:\n     @Override\n     public CollectionType withValueHandler(Object h) {\n-        return new CollectionType(_class, _elementType, h, _typeHandler);\n+        return new CollectionType(_class, _elementType, h, _typeHandler, _asStatic);\n     }\n \n-    // Since 1.9:\n     @Override\n     public  CollectionType withContentValueHandler(Object h) {\n         return new CollectionType(_class, _elementType.withValueHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public CollectionType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new CollectionType(_class, _elementType.withStaticTyping(),\n+                _valueHandler, _typeHandler, true);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n  */\n public class MapLikeType extends TypeBase\n {\n-    private static final long serialVersionUID = -4720638149668688793L;\n+    private static final long serialVersionUID = 416067702302823522L;\n \n     /**\n      * Type of keys of Map.\n      */\n \n     protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT,\n-            Object valueHandler, Object typeHandler)\n-    {\n-        super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler);\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler, asStatic);\n         _keyType = keyT;\n         _valueType = valueT;\n     }\n     public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n     {\n         // nominally component types will be just Object.class\n-        return new MapLikeType(rawType, keyT, valueT, null, null);\n-    }\n-\n-    @Override\n-    protected JavaType _narrow(Class<?> subclass)\n-    {\n-        return new MapLikeType(subclass, _keyType, _valueType, _valueHandler, _typeHandler);\n+        return new MapLikeType(rawType, keyT, valueT, null, null, false);\n+    }\n+\n+    @Override\n+    protected JavaType _narrow(Class<?> subclass) {\n+        return new MapLikeType(subclass, _keyType, _valueType, _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new MapLikeType(_class, _keyType, _valueType.narrowBy(contentClass),\n-               _valueHandler, _typeHandler);\n+               _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new MapLikeType(_class, _keyType, _valueType.widenBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     public JavaType narrowKey(Class<?> keySubclass)\n             return this;\n         }\n         return new MapLikeType(_class, _keyType.narrowBy(keySubclass), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     public JavaType widenKey(Class<?> keySubclass)\n             return this;\n         }\n         return new MapLikeType(_class, _keyType.widenBy(keySubclass), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public MapLikeType withTypeHandler(Object h)\n     {\n-        return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h);\n+        return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);\n     }\n \n     @Override\n     public MapLikeType withContentTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType, _valueType.withTypeHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public MapLikeType withValueHandler(Object h) {\n-        return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler);\n+        return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public MapLikeType withContentValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),\n-                _valueHandler, _typeHandler);\n-    }\n-    \n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public MapLikeType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new MapLikeType(_class, _keyType, _valueType.withStaticTyping(),\n+                _valueHandler, _typeHandler, true);\n+    }\n+\n     @Override\n     protected String buildCanonicalName() {\n         StringBuilder sb = new StringBuilder();\n     public MapLikeType withKeyTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     public MapLikeType withKeyValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     /**\n     {\n         return \"[map-like type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n     }\n-    \n+\n     @Override\n     public boolean equals(Object o)\n     {\n             && _keyType.equals(other._keyType)\n             && _valueType.equals(other._valueType);\n     }\n-    \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n  */\n public final class MapType extends MapLikeType\n {\n-    private static final long serialVersionUID = 2276544408153191774L;\n+    private static final long serialVersionUID = -811146779148281500L;\n \n     /*\n     /**********************************************************\n      */\n \n     private MapType(Class<?> mapType, JavaType keyT, JavaType valueT,\n-            Object valueHandler, Object typeHandler) {\n-        super(mapType, keyT, valueT, valueHandler, typeHandler);\n+            Object valueHandler, Object typeHandler, boolean asStatic) {\n+        super(mapType, keyT, valueT, valueHandler, typeHandler, asStatic);\n     }\n     \n     public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n         // nominally component types will be just Object.class\n-        return new MapType(rawType, keyT, valueT, null, null);\n+        return new MapType(rawType, keyT, valueT, null, null, false);\n     }\n \n     @Override\n     protected JavaType _narrow(Class<?> subclass) {\n         return new MapType(subclass, _keyType, _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new MapType(_class, _keyType, _valueType.narrowBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new MapType(_class, _keyType, _valueType.widenBy(contentClass),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n             return this;\n         }\n         return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n             return this;\n         }\n         return new MapType(_class, _keyType.widenBy(keySubclass), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public MapType withTypeHandler(Object h) {\n-        return new MapType(_class, _keyType, _valueType, _valueHandler, h);\n+        return new MapType(_class, _keyType, _valueType, _valueHandler, h, _asStatic);\n     }\n \n     @Override\n     public MapType withContentTypeHandler(Object h)\n     {\n         return new MapType(_class, _keyType, _valueType.withTypeHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public MapType withValueHandler(Object h) {\n-        return new MapType(_class, _keyType, _valueType, h, _typeHandler);\n+        return new MapType(_class, _keyType, _valueType, h, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public MapType withContentValueHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType.withValueHandler(h),\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n+    @Override\n+    public MapType withStaticTyping() {\n+        if (_asStatic) {\n+            return this;\n+        }\n+        return new MapType(_class, _keyType.withStaticTyping(), _valueType.withStaticTyping(),\n+                _valueHandler, _typeHandler, true);\n     }\n \n     /*\n     public MapType withKeyTypeHandler(Object h)\n     {\n         return new MapType(_class, _keyType.withTypeHandler(h), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n \n     @Override\n     public MapType withKeyValueHandler(Object h) {\n         return new MapType(_class, _keyType.withValueHandler(h), _valueType,\n-                _valueHandler, _typeHandler);\n+                _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n      */\n \n     protected SimpleType(Class<?> cls) {\n-        this(cls, null, null, null, null);\n+        this(cls, null, null, null, null, false);\n     }\n \n     protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,\n-            Object valueHandler, Object typeHandler)\n-    {\n-        super(cls, 0, valueHandler, typeHandler);\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        super(cls, 0, valueHandler, typeHandler, asStatic);\n         if (typeNames == null || typeNames.length == 0) {\n             _typeNames = null;\n             _typeParameters = null;\n      * not in same package\n      */\n     public static SimpleType constructUnsafe(Class<?> raw) {\n-        return new SimpleType(raw, null, null, null, null);\n-    }\n-    \n+        return new SimpleType(raw, null, null, null, null, false);\n+    }\n+\n     @Override\n     protected JavaType _narrow(Class<?> subclass)\n     {\n         // Should we check that there is a sub-class relationship?\n-        return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler);\n+        return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,\n+                _asStatic);\n     }\n \n     @Override\n         return new SimpleType(cls);\n     }\n \n-    // Since 1.7:\n     @Override\n     public SimpleType withTypeHandler(Object h)\n     {\n-        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h);\n-    }\n-\n-    // Since 1.7:\n+        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic);\n+    }\n+\n     @Override\n     public JavaType withContentTypeHandler(Object h) {\n         // no content type, so:\n         throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n     }\n \n-    // Since 1.9:\n     @Override\n     public SimpleType withValueHandler(Object h) {\n         if (h == _valueHandler) {\n             return this;\n         }\n-        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler);\n-    }\n-    \n-    // Since 1.9:\n+        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic);\n+    }\n+    \n     @Override\n     public  SimpleType withContentValueHandler(Object h) {\n         // no content type, so:\n         throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n     }\n-    \n+\n+    @Override\n+    public SimpleType withStaticTyping() {\n+        return _asStatic ? this : new SimpleType(_class,\n+                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n     @Override\n     protected String buildCanonicalName()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n     volatile transient String _canonicalName;\n \n     /**\n+     * @deprecated Since 2.2 use method that takes 'asStatic' argument\n+     */\n+    @Deprecated\n+    protected TypeBase(Class<?> raw, int hash,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        this(raw, hash, valueHandler, typeHandler, false);\n+    }\n+\n+    /**\n      * Main constructor to use by extending classes.\n      */\n     protected TypeBase(Class<?> raw, int hash,\n-            Object valueHandler, Object typeHandler)\n+            Object valueHandler, Object typeHandler, boolean asStatic)\n     {\n-        super(raw, hash, valueHandler, typeHandler);\n+        super(raw, hash, valueHandler, typeHandler, asStatic);\n     }\n \n     @Override\n     public String toCanonical()\n     {\n-    \tString str = _canonicalName;\n-    \tif (str == null) {\n+        String str = _canonicalName;\n+        if (str == null) {\n             str = buildCanonicalName();\n-    \t}\n-    \treturn str;\n+        }\n+        return str;\n     }\n     \n     protected abstract String buildCanonicalName();\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n         for (int i = 0, len = typeVars.length; i < len; ++i) {\n             names[i] = typeVars[i].getName();\n         }\n-        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null);\n+        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false);\n         return resultType;\n     } \n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestTypedRootValueSerialization extends BaseMapTest\n+{\n+    // [JACKSON-822]\n+    static interface Issue822Interface {\n+        public int getA();\n+    }\n+\n+    // If this annotation is added, things will work:\n+    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n+    // but it should not be necessary when root type is passed\n+    static class Issue822Impl implements Issue822Interface {\n+        @Override\n+        public int getA() { return 3; }\n+        public int getB() { return 9; }\n+    }\n+\n+    // First ensure that basic interface-override works:\n+    public void testTypedSerialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        // start with specific value case:\n+        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n+    }\n+    \n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+// Work-around when real solution not yet implemented:        \n+//        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+                new Issue822Interface[] { new Issue822Impl() }));\n+    }\n+    \n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+     // Work-around when real solution not yet implemented:        \n+//        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n+\n+        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n+        list.add(new Issue822Impl());\n+        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+                .writeValueAsString(list);\n+        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n+    }\n+\n+    public void testTypedMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();\n+        map.put(\"a\", new Issue822Impl());\n+        String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})\n+                .writeValueAsString(map);\n+        assertEquals(\"{\\\"a\\\":{\\\"a\\\":3}}\", listJson);\n+    }\n+}", "timestamp": 1363387065, "metainfo": ""}