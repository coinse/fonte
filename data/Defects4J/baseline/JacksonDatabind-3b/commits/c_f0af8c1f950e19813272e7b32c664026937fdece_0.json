{"sha": "f0af8c1f950e19813272e7b32c664026937fdece", "log": "Complete #239 implementation", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ByteBufferDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.ByteBufferBackedOutputStream;\n+\n+public class ByteBufferDeserializer extends StdScalarDeserializer<ByteBuffer>\n+{\n+    private static final long serialVersionUID = 1L;\n+    \n+    protected ByteBufferDeserializer() { super(ByteBuffer.class); }\n+\n+    @Override\n+    public ByteBuffer deserialize(JsonParser parser, DeserializationContext cx)\n+        throws IOException, JsonProcessingException\n+    {\n+        byte[] b = parser.getBinaryValue();\n+        return ByteBuffer.wrap(b);\n+    }\n+\n+    @Override\n+    public ByteBuffer deserialize(JsonParser jp, DeserializationContext ctxt,\n+            ByteBuffer intoValue)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Let's actually read in streaming manner...\n+        OutputStream out = new ByteBufferBackedOutputStream(intoValue);\n+        jp.readBinaryValue(ctxt.getBase64Variant(), out);\n+        out.close();\n+        return intoValue;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CharsetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CharsetDeserializer.java\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n-// [JACKSON-789]\n public class CharsetDeserializer\n     extends FromStringDeserializer<Charset>\n {\n     private static final long serialVersionUID = 1L;\n-\n-    public final static CharsetDeserializer instance = new CharsetDeserializer();\n \n     public CharsetDeserializer() { super(Charset.class); }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n         for (Class<?> cls : numberTypes) {\n             _classNames.add(cls.getName());\n         }\n-    }\n-\n-    /**\n-     * @deprecated Since 2.2 -- use {@link #find} instead.\n-     */\n-    @Deprecated\n-    public static StdDeserializer<?>[] all()\n-    {\n-        return  new StdDeserializer[] {\n-            CalendarDeserializer.instance, // for nominal type of java.util.Calendar\n-            DateDeserializer.instance,\n-            /* 24-Jan-2010, tatu: When including type information, we may\n-             *    know that we specifically need GregorianCalendar...\n-             */\n-            CalendarDeserializer.gregorianInstance,\n-            SqlDateDeserializer.instance,\n-            TimestampDeserializer.instance,\n-            TimeZoneDeserializer.instance\n-        };\n     }\n \n     public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import java.net.InetSocketAddress;\n import java.net.URI;\n import java.net.URL;\n+import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.util.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n                 Charset.class,\n                 AtomicBoolean.class,\n                 Class.class,\n-                StackTraceElement.class\n-\n+                StackTraceElement.class,\n+                ByteBuffer.class\n         };\n         for (Class<?> cls : numberTypes) {\n             _classNames.add(cls.getName());\n             return InetSocketAddressDeserializer.instance;\n         }\n         if (rawType == Charset.class) {\n-            return CharsetDeserializer.instance;\n+            return new CharsetDeserializer();\n         }\n         if (rawType == Class.class) {\n             return ClassDeserializer.instance;\n         if (rawType == AtomicBoolean.class) {\n             // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n             return AtomicBooleanDeserializer.instance;\n+        }\n+        if (rawType == ByteBuffer.class) {\n+            return new ByteBufferDeserializer();\n         }\n         // should never occur\n         throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+clsName);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;\n \n public class ByteBufferSerializer extends StdScalarSerializer<ByteBuffer>\n {\n         gen.writeBinary(in, copy.remaining());\n         in.close();\n     }\n-\n-    public class ByteBufferBackedInputStream extends InputStream\n-    {\n-        protected final ByteBuffer _buffer;\n-\n-        public ByteBufferBackedInputStream(ByteBuffer buf) {\n-            _buffer = buf;\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            return _buffer.hasRemaining() ? (_buffer.get() & 0xFF) : -1;\n-        }\n-\n-        @Override\n-        public int read(byte[] bytes, int off, int len) throws IOException\n-        {\n-            if (!_buffer.hasRemaining()) {\n-                return -1;\n-            }\n-            len = Math.min(len, _buffer.remaining());\n-            _buffer.get(bytes, off, len);\n-            return len;\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedInputStream.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Simple {@link InputStream} implementation that exposes currently\n+ * available content of a {@link ByteBuffer}.\n+ */\n+public class ByteBufferBackedInputStream extends InputStream\n+{\n+    protected final ByteBuffer _buffer;\n+\n+    public ByteBufferBackedInputStream(ByteBuffer buf) {\n+        _buffer = buf;\n+    }\n+\n+    @Override\n+    public int available() {\n+        return _buffer.remaining();\n+    }\n+    \n+    @Override\n+    public int read() throws IOException {\n+        return _buffer.hasRemaining() ? (_buffer.get() & 0xFF) : -1;\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int off, int len) throws IOException\n+    {\n+        if (!_buffer.hasRemaining()) {\n+            return -1;\n+        }\n+        len = Math.min(len, _buffer.remaining());\n+        _buffer.get(bytes, off, len);\n+        return len;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedOutputStream.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Simple {@link OutputStream} implementation that appends content\n+ * written in given {@link ByteBuffer} instance.\n+ */\n+public class ByteBufferBackedOutputStream extends OutputStream\n+{\n+    protected final ByteBuffer _buffer;\n+\n+    public ByteBufferBackedOutputStream(ByteBuffer buf) {\n+        this._buffer = buf;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        _buffer.put((byte) b);\n+    }\n+\n+    @Override\n+    public void write(byte[] bytes, int off, int len) throws IOException {\n+        _buffer.put(bytes, off, len);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n \n import java.io.*;\n import java.net.*;\n+import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.util.Currency;\n import java.util.List;\n     /**********************************************************\n      */\n     \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     /**\n      * Related to issues [JACKSON-155], [#170].\n         String abs = src.getAbsolutePath();\n \n         // escape backslashes (for portability with windows)\n-        String json = mapper.writeValueAsString(abs);\n-        File result = mapper.readValue(json, File.class);\n+        String json = MAPPER.writeValueAsString(abs);\n+        File result = MAPPER.readValue(json, File.class);\n         assertEquals(abs, result.getAbsolutePath());\n \n         // Then #170\n         /* Ok: easiest way is to just serialize first; problem\n          * is the backslash\n          */\n-        String json = mapper.writeValueAsString(exp);\n-        Pattern result = mapper.readValue(json, Pattern.class);\n+        String json = MAPPER.writeValueAsString(exp);\n+        Pattern result = MAPPER.readValue(json, Pattern.class);\n         assertEquals(exp.pattern(), result.pattern());\n     }\n \n      */\n     public void testLocale() throws IOException\n     {\n-        assertEquals(new Locale(\"en\"), mapper.readValue(quote(\"en\"), Locale.class));\n-        assertEquals(new Locale(\"es\", \"ES\"), mapper.readValue(quote(\"es_ES\"), Locale.class));\n-        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), mapper.readValue(quote(\"fi_FI_savo\"), Locale.class));\n+        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n+        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n+        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n     }\n \n     /**\n     public void testNullForPrimitives() throws IOException\n     {\n         // by default, ok to rely on defaults\n-        PrimitivesBean bean = mapper.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n+        PrimitivesBean bean = MAPPER.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals(0, bean.intValue);\n         assertEquals(false, bean.booleanValue);\n         assertEquals(0.0, bean.doubleValue);\n \n-        bean = mapper.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n                 PrimitivesBean.class);\n         assertNotNull(bean);\n         assertEquals((byte) 0, bean.byteValue);\n      */\n     public void testCharSequence() throws IOException\n     {\n-        CharSequence cs = mapper.readValue(\"\\\"abc\\\"\", CharSequence.class);\n+        CharSequence cs = MAPPER.readValue(\"\\\"abc\\\"\", CharSequence.class);\n         assertEquals(String.class, cs.getClass());\n         assertEquals(\"abc\", cs.toString());\n     }\n     // [JACKSON-484]\n     public void testInetAddress() throws IOException\n     {\n-        InetAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n+        InetAddress address = MAPPER.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n         assertEquals(\"127.0.0.1\", address.getHostAddress());\n \n         // should we try resolving host names? That requires connectivity... \n         final String HOST = \"www.ning.com\";\n-        address = mapper.readValue(quote(HOST), InetAddress.class);\n+        address = MAPPER.readValue(quote(HOST), InetAddress.class);\n         assertEquals(HOST, address.getHostName());\n     }\n \n     public void testInetSocketAddress() throws IOException\n     {\n-        InetSocketAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetSocketAddress.class);\n+        InetSocketAddress address = MAPPER.readValue(quote(\"127.0.0.1\"), InetSocketAddress.class);\n         assertEquals(\"127.0.0.1\", address.getAddress().getHostAddress());\n \n-        InetSocketAddress ip6 = mapper.readValue(\n+        InetSocketAddress ip6 = MAPPER.readValue(\n                 quote(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"), InetSocketAddress.class);\n         assertEquals(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\", ip6.getAddress().getHostAddress());\n \n-        InetSocketAddress ip6port = mapper.readValue(\n+        InetSocketAddress ip6port = MAPPER.readValue(\n                 quote(\"[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443\"), InetSocketAddress.class);\n         assertEquals(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\", ip6port.getAddress().getHostAddress());\n         assertEquals(443, ip6port.getPort());\n \n         // should we try resolving host names? That requires connectivity...\n         final String HOST = \"www.ning.com\";\n-        address = mapper.readValue(quote(HOST), InetSocketAddress.class);\n+        address = MAPPER.readValue(quote(HOST), InetSocketAddress.class);\n         assertEquals(HOST, address.getHostName());\n     }\n \n     // [JACKSON-605]\n     public void testClassWithParams() throws IOException\n     {\n-        String json = mapper.writeValueAsString(new ParamClassBean(\"Foobar\"));\n-\n-        ParamClassBean result = mapper.readValue(json, ParamClassBean.class);\n+        String json = MAPPER.writeValueAsString(new ParamClassBean(\"Foobar\"));\n+\n+        ParamClassBean result = MAPPER.readValue(json, ParamClassBean.class);\n         assertEquals(\"Foobar\", result.name);\n         assertSame(String.class, result.clazz);\n     }\n         WrappersBean bean;\n \n         // by default, ok to rely on defaults\n-        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.booleanValue);\n-        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.byteValue);\n \n         // char/Character is different... not sure if this should work or not:\n-        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.charValue);\n \n-        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.shortValue);\n-        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.intValue);\n-        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.longValue);\n-        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.floatValue);\n-        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n         assertNull(bean.doubleValue);\n     }\n \n     public void testEmptyStringForPrimitives() throws IOException\n     {\n         PrimitivesBean bean;\n-        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertFalse(bean.booleanValue);\n-        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((byte) 0, bean.byteValue);\n-        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((char) 0, bean.charValue);\n-        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals((short) 0, bean.shortValue);\n-        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0, bean.intValue);\n-        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0L, bean.longValue);\n-        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0f, bean.floatValue);\n-        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        bean = MAPPER.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n         assertEquals(0.0, bean.doubleValue);\n     }\n \n     public void testUntypedWithJsonArrays() throws Exception\n     {\n         // by default we get:\n-        Object ob = mapper.readValue(\"[1]\", Object.class);\n+        Object ob = MAPPER.readValue(\"[1]\", Object.class);\n         assertTrue(ob instanceof List<?>);\n \n         // but can change to produce Object[]:\n-        mapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n-        ob = mapper.readValue(\"[1]\", Object.class);\n+        MAPPER.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        ob = MAPPER.readValue(\"[1]\", Object.class);\n         assertEquals(Object[].class, ob.getClass());\n     }\n \n     public void testLongToBoolean() throws Exception\n     {\n         long value = 1L + Integer.MAX_VALUE;\n-        BooleanBean b = mapper.readValue(\"{\\\"primitive\\\" : \"+value+\", \\\"wrapper\\\":\"+value+\", \\\"ctor\\\":\"+value+\"}\",\n+        BooleanBean b = MAPPER.readValue(\"{\\\"primitive\\\" : \"+value+\", \\\"wrapper\\\":\"+value+\", \\\"ctor\\\":\"+value+\"}\",\n                     BooleanBean.class);\n         assertEquals(Boolean.TRUE, b.wrapper);\n         assertTrue(b.primitive);\n     public void testCharset() throws Exception\n     {\n         Charset UTF8 = Charset.forName(\"UTF-8\");\n-        assertSame(UTF8, mapper.readValue(quote(\"UTF-8\"), Charset.class));\n+        assertSame(UTF8, MAPPER.readValue(quote(\"UTF-8\"), Charset.class));\n     }\n \n     // [JACKSON-888]\n         } catch (Exception e) {\n             elem = e.getStackTrace()[0];\n         }\n-        String json = mapper.writeValueAsString(elem);\n-        StackTraceElement back = mapper.readValue(json, StackTraceElement.class);\n+        String json = MAPPER.writeValueAsString(elem);\n+        StackTraceElement back = MAPPER.readValue(json, StackTraceElement.class);\n         \n         assertEquals(\"testStackTraceElement\", back.getMethodName());\n         assertEquals(elem.getLineNumber(), back.getLineNumber());\n         assertTrue(back.getClassName().endsWith(\"TestJdkTypes\"));\n         assertFalse(back.isNativeMethod());\n     }\n+\n+    // [Issue#239]\n+    public void testByteBuffer() throws Exception\n+    {\n+        byte[] INPUT = new byte[] { 1, 3, 9, -1, 6 };\n+        String exp = MAPPER.writeValueAsString(INPUT);\n+        ByteBuffer result = MAPPER.readValue(exp,  ByteBuffer.class); \n+        assertNotNull(result);\n+        assertEquals(INPUT.length, result.remaining());\n+        for (int i = 0; i < INPUT.length; ++i) {\n+            assertEquals(INPUT[i], result.get());\n+        }\n+        assertEquals(0, result.remaining());\n+    }\n }", "timestamp": 1373563222, "metainfo": ""}