{"sha": "bc6485776be5c45a52e4b07459caf3b9a78c80d3", "log": "Minor improvements to SubtypeResolver, to pass base type of property, to support structured values properly", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             return findTypeDeserializer(config, baseType);\n         }\n         // but if annotations found, may need to resolve subtypes:\n-        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated,\n-                config, ai);\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n+                annotated, config, ai, baseType);\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     }\n     \n             return findTypeDeserializer(config, contentType);\n         }\n         // but if annotations found, may need to resolve subtypes:\n-        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai);\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n+                propertyEntity, config, ai, contentType);\n         return b.buildTypeDeserializer(config, contentType, subtypes);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonFormatVisitable.java\n      * Get the representation of the schema to which this serializer will conform.\n      * @param typeHint TODO\n      *\n-     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     * @returns <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n      */\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/SubtypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/SubtypeResolver.java\n import java.util.Collection;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n     public abstract void registerSubtypes(Class<?>... classes);\n     \n     /**\n-     * Method for finding out all reachable subtypes for a property specified\n-     * by given element (method or field)\n+     * @deprecated Since 2.1: use variant that takes in property type.\n      */\n+    @Deprecated\n     public abstract Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n             MapperConfig<?> config, AnnotationIntrospector ai);\n \n+    /**\n+     * Method for finding out all reachable subtypes for a property specified\n+     * by given element (method or field)\n+     * \n+     * @param baseType Effective property base type to use; may differ from\n+     *    actual type of property; for structured types it is content (value) type and NOT\n+     *    structured type.\n+     * \n+     * @since 2.1\n+     */\n+    public abstract Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n+            MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType);\n+    \n     /**\n      * Method for finding out all reachable subtypes for given type.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n         }\n         registerSubtypes(types);\n     }\n+\n+    /**\n+     * @deprecated Since 2.1\n+     */\n+    @Deprecated\n+    @Override\n+    public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n+        MapperConfig<?> config, AnnotationIntrospector ai)\n+    {\n+        return collectAndResolveSubtypes(property, config, ai, null);\n+    }\n     \n     /**\n      * \n      * @param property Base member to use for type resolution: either annotated type (class),\n      *    or property (field, getter/setter)\n+     *    \n+     * @since 2.1\n      */\n     @Override\n     public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n-        MapperConfig<?> config, AnnotationIntrospector ai)\n+        MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType)\n     {\n+        // for backwards compatibility, must allow null here:\n+        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+        \n         HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n         // start with registered subtypes (which have precedence)\n         if (_registeredSubtypes != null) {\n-            Class<?> rawBase = property.getRawType();\n             for (NamedType subtype : _registeredSubtypes) {\n                 // is it a subtype of root type?\n                 if (rawBase.isAssignableFrom(subtype.getType())) { // yes\n                 }\n             }\n         }\n-\n+        \n         // then annotated types for property itself\n         Collection<NamedType> st = ai.findSubtypes(property);\n         if (st != null) {\n                 _collectAndResolve(ac, nt, config, ai, collected);\n             }            \n         }\n-        NamedType rootType = new NamedType(property.getRawType(), null);\n-        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(property.getRawType(), ai, config);\n+        \n+        NamedType rootType = new NamedType(rawBase, null);\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config);\n             \n         // and finally subtypes via annotations from base type (recursively)\n         _collectAndResolve(ac, rootType, config, ai, collected);\n      * Method called to find subtypes for a specific type (class)\n      */\n     protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType,\n-            MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes)\n+            MapperConfig<?> config, AnnotationIntrospector ai,\n+            HashMap<NamedType, NamedType> collectedSubtypes)\n     {\n         if (!namedType.hasName()) {\n             String name = ai.findTypeName(annotatedType);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         if (b == null) {\n             return createTypeSerializer(config, baseType);\n         }\n-        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(\n+                accessor, config, ai, baseType);\n         return b.buildTypeSerializer(config, baseType, subtypes);\n     }\n \n         if (b == null) {\n             return createTypeSerializer(config, contentType);\n         }\n-        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor,\n+                config, ai, contentType);\n         return b.buildTypeSerializer(config, contentType, subtypes);\n     }\n     ", "timestamp": 1345240756, "metainfo": ""}