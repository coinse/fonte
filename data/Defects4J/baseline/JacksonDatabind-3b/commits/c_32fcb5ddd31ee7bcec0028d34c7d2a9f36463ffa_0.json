{"sha": "32fcb5ddd31ee7bcec0028d34c7d2a9f36463ffa", "log": "Improve default impl for missing type handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n                          T intoValue)\n         throws IOException, JsonProcessingException\n     {\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"Can not update object of type \"+intoValue.getClass().getName());\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n      * values of type this serializer handles, using specified type serializer\n      * for embedding necessary type information.\n      *<p>\n-     * Default implementation will ignore serialization of type information,\n-     * and just calls {@link #serialize}: serializers that can embed\n-     * type information should override this to implement actual handling.\n-     * Most common such handling is done by something like:\n+     * Default implementation will throw {@link UnsupportedOperationException}\n+     * to indicate that proper type handling needs to be implemented.\n+     *<p>\n+     * For simple datatypes written as a single scalar value (JSON String, Number, Boolean),\n+     * implementation would look like:\n      *<pre>\n      *  // note: method to call depends on whether this type is serialized as JSON scalar, object or Array!\n      *  typeSer.writeTypePrefixForScalar(value, jgen);\n      *  serialize(value, jgen, provider);\n      *  typeSer.writeTypeSuffixForScalar(value, jgen);\n      *</pre>\n+     * and implementations for type serialized as JSON Arrays or Objects would differ slightly,\n+     * as <code>START-ARRAY>/<code>END-ARRAY</code> and\n+     * <code>START-OBJECT>/<code>END-OBJECT</code> pairs\n+     * need to be properly handled with respect to serializing of contents.\n      *\n      * @param value Value to serialize; can <b>not</b> be null.\n      * @param jgen Generator used to output resulting Json content\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException\n     {\n-        serialize(value, jgen, provider);\n+        Class<?> clz = handledType();\n+        if (clz == null) {\n+            clz = value.getClass();\n+        }\n+        throw new UnsupportedOperationException(\"Type id handling not implemented for type \"+clz.getName());\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n         assertSame(result.node, result.node.next.node);\n     }\n \n+    // Another test to ensure ordering is not required (i.e. can do front references)\n+    public void testSimpleDeserWithForwardRefs() throws Exception\n+    {\n+        IdWrapper result = mapper.readValue(\"{\\\"node\\\":{\\\"value\\\":7,\\\"next\\\":{\\\"node\\\":1}, \\\"@id\\\":1}}\"\n+                ,IdWrapper.class);\n+        assertEquals(7, result.node.value);\n+        assertSame(result.node, result.node.next.node);\n+    }\n+    \n     /*\n     /*****************************************************\n     /* Unit tests, custom (property-based) id deserialization", "timestamp": 1330303180, "metainfo": ""}