{"sha": "45c7f244af3b61473b18fb32e93b048e79d41b5b", "log": "Last parts of straightening out JsonFormatVisitable; also realized there is one backwards incompatible part (damn)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n  * Interface that defines API for filter objects use (as configured\n  * using {@link com.fasterxml.jackson.annotation.JsonFilter})\n  * for filtering bean properties to serialize.\n+ *<p>\n+ * Note that Jackson 2.1 added two new methods -- as a result, it is\n+ * strongly recommended that custom implementations extend\n+ * {@link com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter},\n+ * to avoid backwards compatibility issues in future.\n  */\n public interface BeanPropertyFilter\n {\n     /**\n      * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n      * form the given property exist within the parent, or root, schema. Filters can omit\n-     * adding the property to the node, or choose the form of the schema value for the property\n+     * adding the property to the node, or choose the form of the schema value for the property.\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(propertiesNode, provider);\n+     * }\n+     *</pre>\n      * \n      * @param writer Bean property serializer to use to create schema value\n      * @param propertiesNode Node which the given property would exist within\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      * \tprocessing\n+     * \n+     * @since 2.1\n      */\n     public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode,\n             SerializerProvider provider)\n      * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n      * form the given property exist within the parent, or root, schema. Filters can omit\n      * adding the property to the node, or choose the form of the schema value for the property\n+     *<p>\n+     * Typical implementation is something like:\n+     *<pre>\n+     * if (include(writer)) {\n+     *      writer.depositSchemaProperty(objectVisitor, provider);\n+     * }\n+     *</pre>\n      * \n      * @param writer Bean property serializer to use to create schema value\n      * @param objectVisitor JsonObjectFormatVisitor which should be aware of \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Annotations;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n+\n+    /**\n+     *<p>\n+     * NOTE: due to introspection, this is a <b>slow</b> method to call\n+     * and should never be called during actual serialization or filtering\n+     * of the property. Rather it is needed for traversal needed for things\n+     * like constructing JSON Schema instances.\n+     * \n+     * @since 2.1\n+     */\n+    protected boolean isRequired(AnnotationIntrospector intr)\n+    {\n+        Boolean value = intr.hasRequiredMarker(_member);\n+        return (value == null) ? false : value.booleanValue();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Support for JsonFormatVisitable\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to handle appropriate type-specific visiting\n+     * over logical property this writer handles.\n+     * \n+     * @param objectVisitor ObjectVisitor which can receive the property\n+     * \n+     * @since 2.1\n+     */\n+    public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n+        throws JsonMappingException\n+    {\n+        if (isRequired(objectVisitor.getProvider().getAnnotationIntrospector())) {\n+            objectVisitor.property(this); \n+        } else {\n+            objectVisitor.optionalProperty(this);\n+        }\n+    }\n+\n+    /**\n+     * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n+     * Otherwise, add the default schema {@link JsonNode} in place of the writer's output\n+     * \n+     * @param propertiesNode Node which the given property would exist within\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     *  processing\n+     *  \n+     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n+     * \n+     * @since 2.1\n+     */\n+    public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JavaType propType = getSerializationType();\n+        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+        Type hint = (propType == null) ? getGenericPropertyType() : propType.getRawClass();\n+        JsonNode schemaNode;\n+        // Maybe it already has annotated/statically configured serializer?\n+        JsonSerializer<Object> ser = getSerializer();\n+        if (ser == null) { // nope\n+            Class<?> serType = getRawSerializationType();\n+            if (serType == null) {\n+                serType = getPropertyType();\n+            }\n+            ser = provider.findValueSerializer(serType, this);\n+        }\n+        boolean isOptional = !isRequired(provider.getAnnotationIntrospector());\n+        if (ser instanceof SchemaAware) {\n+            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n+        } else {  \n+            schemaNode = JsonSchema.getDefaultSchemaNode(); \n+        }\n+        propertiesNode.put(getName(), schemaNode);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n-import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n \n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n \n     /*\n     /**********************************************************\n+    /* Methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to determine whether property will be included\n+     * (if 'true' returned) or filtered out (if 'false' returned)\n+     */\n+    protected abstract boolean include(BeanPropertyWriter writer);\n+\n+    public void serializeAsField(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n+    {\n+        if (include(writer)) {\n+            writer.serializeAsField(bean, jgen, provider);\n+        }\n+    }\n+\n+    \n+    public void depositSchemaProperty(BeanPropertyWriter writer,\n+            ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(propertiesNode, provider);\n+        }\n+    }\n+\n+    public void depositSchemaProperty(BeanPropertyWriter writer,\n+            JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (include(writer)) {\n+            writer.depositSchemaProperty(objectVisitor);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Sub-classes\n     /**********************************************************\n      */\n             _propertiesToInclude = properties;\n         }\n \n-        public void serializeAsField(Object bean, JsonGenerator jgen,\n-                SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-        {\n-            if (_propertiesToInclude.contains(writer.getName())) {\n-                writer.serializeAsField(bean, jgen, provider);\n-            }\n-        }\n-\n-        public void depositSchemaProperty(BeanPropertyWriter writer,\n-                ObjectNode propertiesNode, SerializerProvider provider)\n-            throws JsonMappingException\n-        {\n-            if (_propertiesToInclude.contains(writer.getName())) {\n-                BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-            }\n-        }\n-\n-        public void depositSchemaProperty(BeanPropertyWriter writer,\n-                JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n-            throws JsonMappingException\n-        {\n-            if (_propertiesToInclude.contains(writer.getName())) {\n-                BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-            }\n+        protected boolean include(BeanPropertyWriter writer) {\n+            return _propertiesToInclude.contains(writer.getName());\n         }\n     }\n \n             _propertiesToExclude = properties;\n         }\n \n-        public void serializeAsField(Object bean, JsonGenerator jgen,\n-            SerializerProvider provider, BeanPropertyWriter writer) throws Exception\n-        {\n-            if (!_propertiesToExclude.contains(writer.getName())) {\n-                writer.serializeAsField(bean, jgen, provider);\n-            }\n-        }\n-\n-        public void depositSchemaProperty(BeanPropertyWriter writer,\n-                ObjectNode propertiesNode, SerializerProvider provider)\n-            throws JsonMappingException\n-        {\n-            if (!_propertiesToExclude.contains(writer.getName())) {\n-                BeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n-            }\n-        }\n-\n-        public void depositSchemaProperty(BeanPropertyWriter writer,\n-                JsonObjectFormatVisitor objectVisitor, SerializerProvider provider)\n-            throws JsonMappingException\n-        {\n-            if (!_propertiesToExclude.contains(writer.getName())) {\n-                BeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n-            }\n+        protected boolean include(BeanPropertyWriter writer) {\n+            return !_propertiesToExclude.contains(writer.getName());\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n         ObjectNode propertiesNode = o.objectNode();\n         final BeanPropertyFilter filter;\n         if (_propertyFilterId != null) {\n-        \tfilter = findFilter(provider);\n-        } else {\n-        \tfilter = null;\n+            filter = findFilter(provider);\n+        } else {\n+            filter = null;\n         }\n         \t\t\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n             if (filter != null) {\n             \tfilter.depositSchemaProperty(prop, propertiesNode, provider);\n-            \t continue;\n-            }\n-            depositSchemaProperty(prop, propertiesNode, provider);\n+            \tcontinue;\n+            }\n+            prop.depositSchemaProperty(propertiesNode, provider);\n \n         }\n         o.put(\"properties\", propertiesNode);\n         return o;\n-    }\n-\n-    /**\n-     * Determines if a bean property is required, as determined by\n-     * {@link com.fasterxml.jackson.databind.AnnotationIntrospector#hasRequiredMarker}.\n-     * \n-     * @param prop the bean property.\n-     * @return true if the property is optional, false otherwise.\n-     */\n-    public static boolean isPropertyRequired(final BeanPropertyWriter prop, final SerializerProvider provider) {\n-        Boolean value = provider.getAnnotationIntrospector().hasRequiredMarker(prop.getMember());\n-        return (value == null) ? false : value.booleanValue();\n     }\n     \n     @Override\n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n  \n         if (_propertyFilterId != null) {\n-            try {\n-                BeanPropertyFilter filter = findFilter(visitor.getProvider());\n-                for (int i = 0; i < _props.length; i++) {\n-                    BeanPropertyWriter prop = _props[i];\n-                    filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n-                }\n-                return;\n-            } catch (JsonMappingException e) {\n-                throw new IllegalStateException(\"Internal error: \"+e.getMessage(), e);\n-            }\n-        } \n-        \t\t\n-        for (int i = 0; i < _props.length; i++) {\n-            BeanPropertyWriter prop = _props[i];\n-            BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);\n-        }\n-    }\n-\n-    \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n-     * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param propertiesNode Node which the given property would exist within\n-     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n-     * \tprocessing\n-     * \t\n-     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer,\n-            ObjectNode propertiesNode, SerializerProvider provider)\n-        throws JsonMappingException\n-    {\n-        JavaType propType = writer.getSerializationType();\n-\n-        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n-        Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n-        JsonNode schemaNode;\n-        // Maybe it already has annotated/statically configured serializer?\n-        JsonSerializer<Object> ser = writer.getSerializer();\n-        if (ser == null) { // nope\n-            Class<?> serType = writer.getRawSerializationType();\n-            if (serType == null) {\n-                serType = writer.getPropertyType();\n-            }\n-            ser = provider.findValueSerializer(serType, writer);\n-        }\n-        boolean isOptional = !isPropertyRequired(writer, provider);\n-        if (ser instanceof SchemaAware) {\n-            schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n-        } else {  \n-            schemaNode = JsonSchema.getDefaultSchemaNode(); \n-        }\n-        propertiesNode.put(writer.getName(), schemaNode);\n-    }\n-    \n-    /**\n-     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the \n-     *  given {@link JsonObjectFormatVisitor}.\n-     * \n-     * @param writer Bean property serializer to use to create schema value\n-     * @param objectVisitor ObjectVisitor which cab receive the property\n-     */\n-    public static void depositSchemaProperty(BeanPropertyWriter writer,\n-            JsonObjectFormatVisitor objectVisitor)\n-        throws JsonMappingException\n-    {\n-        if (isPropertyRequired(writer, objectVisitor.getProvider())) {\n-            objectVisitor.property(writer); \n-        } else {\n-            objectVisitor.optionalProperty(writer);\n+            BeanPropertyFilter filter = findFilter(visitor.getProvider());\n+            for (int i = 0; i < _props.length; i++) {\n+                BeanPropertyWriter prop = _props[i];\n+                filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n+            }\n+        } else {\n+            for (int i = 0; i < _props.length; i++) {\n+                _props[i].depositSchemaProperty(objectVisitor);\n+            }\n         }\n     }\n }", "timestamp": 1349328977, "metainfo": ""}