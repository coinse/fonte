{"sha": "5d8d3d2fb9b6f2fd86fdde71bf1c38e7d5bc2455", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.lang.reflect.Type;\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, \"cause\", am);\n+            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, \"cause\", am,\n+                    am.getParameterType(0));\n             if (prop != null) {\n                 /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                  *   to set (with new 1.9 code)... but let's replace it just in case,\n                 builder.addCreatorProperty(property);\n                 continue;\n             }\n-            // primary: have a setter?\n+            AnnotatedMember accessor;\n+            Class<?> rawPropertyType;\n+            Type propertyType;\n             if (property.hasSetter()) {\n                 AnnotatedMethod setter = property.getSetter();\n-                // [JACKSON-429] Some types are declared as ignorable as well\n-                Class<?> type = setter.getParameterClass(0);\n-                if (isIgnorableType(ctxt.getConfig(), beanDesc, type, ignoredTypes)) {\n-                    // important: make ignorable, to avoid errors if value is actually seen\n-                    builder.addIgnorable(name);\n-                    continue;\n-                }\n-                SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, name, setter);\n-                if (prop != null) {\n-                    builder.addProperty(prop);\n-                }\n+                rawPropertyType = setter.getParameterClass(0);\n+                propertyType = setter.getParameterType(0);\n+                accessor = setter;\n+            } else if (property.hasField()) {\n+                accessor = property.getField();\n+                rawPropertyType = accessor.getRawType();\n+                propertyType = accessor.getGenericType();\n+            } else {\n                 continue;\n             }\n-            if (property.hasField()) {\n-                AnnotatedField field = property.getField();\n-                // [JACKSON-429] Some types are declared as ignorable as well\n-                Class<?> type = field.getRawType();\n-                if (isIgnorableType(ctxt.getConfig(), beanDesc, type, ignoredTypes)) {\n-                    // important: make ignorable, to avoid errors if value is actually seen\n-                    builder.addIgnorable(name);\n-                    continue;\n-                }\n-                SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, name, field);\n+            \n+            // [JACKSON-429] Some types are declared as ignorable as well\n+            if (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes)) {\n+                // important: make ignorable, to avoid errors if value is actually seen\n+                builder.addIgnorable(name);\n+            } else {\n+                SettableBeanProperty prop = constructSettableProperty(ctxt,\n+                        beanDesc, name, accessor, propertyType);\n                 if (prop != null) {\n                     builder.addProperty(prop);\n                 }\n             for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n                 String name = en.getKey();\n                 AnnotatedMember m = en.getValue();\n+                Type genericType;\n                 if (m instanceof AnnotatedMethod) {\n-                    builder.addBackReferenceProperty(name, constructSettableProperty(\n-                            ctxt, beanDesc, m.getName(), (AnnotatedMethod) m));\n+                    genericType = ((AnnotatedMethod) m).getParameterType(0);\n                 } else {\n-                    builder.addBackReferenceProperty(name, constructSettableProperty(\n-                            ctxt, beanDesc, m.getName(), (AnnotatedField) m));\n-                }\n+                    genericType = m.getRawType();\n+                }\n+                builder.addBackReferenceProperty(name, constructSettableProperty(\n+                        ctxt, beanDesc, m.getName(), m, genericType));\n             }\n         }\n     }\n      */\n     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, String name,\n-            AnnotatedMethod setter)\n+            AnnotatedMember setter, Type jdkType)\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n         }\n \n         // note: this works since we know there's exactly one argument for methods\n-        JavaType t0 = beanDesc.bindingsForBeanType().resolveType(setter.getParameterType(0));\n+        JavaType t0 = beanDesc.resolveType(jdkType);\n+\n         BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), setter);\n         JavaType type = resolveType(ctxt, beanDesc, t0, setter, property);\n         // did type change?\n         JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, setter, property);\n         type = modifyTypeByAnnotation(ctxt, setter, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n-        SettableBeanProperty prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n-                beanDesc.getClassAnnotations(), setter);\n+        SettableBeanProperty prop;\n+        if (setter instanceof AnnotatedMethod) {\n+            prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), (AnnotatedMethod) setter);\n+        } else {\n+            prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n+                    beanDesc.getClassAnnotations(), (AnnotatedField) setter);\n+        }\n         if (propDeser != null) {\n             prop = prop.withValueDeserializer(propDeser);\n         }\n         // [JACKSON-235]: need to retain name of managed forward references:\n         AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(setter);\n-        if (ref != null && ref.isManagedReference()) {\n-            prop.setManagedReferenceName(ref.getName());\n-        }\n-        return prop;\n-    }\n-\n-    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n-            BeanDescription beanDesc, String name, AnnotatedField field)\n-        throws JsonMappingException\n-    {\n-        // need to ensure method is callable (for non-public)\n-        if (ctxt.canOverrideAccessModifiers()) {\n-            field.fixAccess();\n-        }\n-        JavaType t0 = beanDesc.bindingsForBeanType().resolveType(field.getGenericType());\n-        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), field);\n-        JavaType type = resolveType(ctxt, beanDesc, t0, field, property);\n-        // did type change?\n-        if (type != t0) {\n-            property = property.withType(type);\n-        }\n-        /* First: does the Method specify the deserializer to use?\n-         * If so, let's use it.\n-         */\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, field, property);\n-        type = modifyTypeByAnnotation(ctxt, field, type, property);\n-        TypeDeserializer typeDeser = type.getTypeHandler();\n-        SettableBeanProperty prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n-                beanDesc.getClassAnnotations(), field);\n-        if (propDeser != null) {\n-            prop = prop.withValueDeserializer(propDeser);\n-        }\n-        // [JACKSON-235]: need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(field);\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n             getter.fixAccess();\n         }\n \n+        /* 26-Jan-2012, tatu: Alas, this complication is still needed to handle\n+         *   (or at least work around) local type declarations...\n+         */\n         JavaType type = getter.getType(beanDesc.bindingsForBeanType());\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n         return (index >= types.length) ? null : types[index];\n     }\n \n+    public Type getGenericReturnType() {\n+        return _method.getGenericReturnType();\n+    }\n+    \n     public Class<?> getRawReturnType() {\n         return _method.getReturnType();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n             resultType = _fromWildcard((WildcardType) type, context);\n         } else {\n             // sanity check\n-            throw new IllegalArgumentException(\"Unrecognized Type: \"+type.toString());\n+            throw new IllegalArgumentException(\"Unrecognized Type: \"+((type == null) ? \"[null]\" : type.toString()));\n         }\n         /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n          * for now only call for simple types (i.e. not for arrays, map or collections).", "timestamp": 1327608067, "metainfo": ""}