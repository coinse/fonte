{"sha": "83050563fc78bfbe2df78b8494be794483a5ec0e", "log": "Merge pull request #218 from karldmoore/master  #217 - JSON parse exceptions are not wrapped like others", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n             DeserializationContext ctxt)\n         throws IOException\n     {\n-        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+\t\tt = throwOrReturnThrowable(t, ctxt);\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n+    }\n+\n+    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+\t\tt = throwOrReturnThrowable(t, ctxt);\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, index);\n+    }\n+\t\n+\tprivate Throwable throwOrReturnThrowable(Throwable t, DeserializationContext ctxt) \n+\t\tthrows IOException\n+\t{\n+\t    /* 05-Mar-2009, tatu: But one nasty edge is when we get\n          *   StackOverflow: usually due to infinite loop. But that\n          *   usually gets hidden within an InvocationTargetException...\n          */\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+\t\twhile (t instanceof InvocationTargetException && t.getCause() != null) {\n             t = t.getCause();\n         }\n         // Errors and \"plain\" IOExceptions to be passed as is\n             throw (Error) t;\n         }\n         boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n-        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n+        // Ditto for IOExceptions; except we may want to wrap json exceptions\n         if (t instanceof IOException) {\n-            if (!wrap || !(t instanceof JsonMappingException)) {\n+            if (!wrap || !(t instanceof JsonProcessingException)) {\n                 throw (IOException) t;\n             }\n         } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n                 throw (RuntimeException) t;\n             }\n         }\n-        // [JACKSON-55] Need to add reference information\n-        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n-    }\n-\n-    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n-        throws IOException\n-    {\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n-        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n-        if (t instanceof IOException) {\n-            if (!wrap || !(t instanceof JsonMappingException)) {\n-                throw (IOException) t;\n-            }\n-        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n-            if (t instanceof RuntimeException) {\n-                throw (RuntimeException) t;\n-            }\n-        }\n-        // [JACKSON-55] Need to add reference information\n-        throw JsonMappingException.wrapWithPath(t, bean, index);\n-    }\n+\t\treturn t;\n+\t}\n \n     protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n         throws IOException\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n         try {\n             MAPPER.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n         } catch (JsonProcessingException e) {\n-            verifyException(e, \"boolProp\");\n+            verifyException(e, \"foobar\");\n         }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n         try {\n             mapper.readValue(json, MyBeanHolder.class);\n             fail(\"should have raised exception\");\n-        } catch (JsonParseException e) {\n+        } catch (JsonProcessingException e) {\n             verifyException(e, \"not numeric\");\n         }\n     }\n         try {\n             MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class);\n             fail(\"should have raised exception instead value was set to \" + result.defaultValue.value.decimal.toString());\n-        } catch (JsonParseException e) {\n+        } catch (JsonProcessingException e) {\n             verifyException(e, \"not numeric\");\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n     protected BeanDeserializerBuilder(BeanDeserializerBuilder src)\n     {\n         _beanDesc = src._beanDesc;\n+        _defaultViewInclusion = src._defaultViewInclusion;\n+\n         _anySetter = src._anySetter;\n         _ignoreAllUnknown = src._ignoreAllUnknown;\n \n         // Hmmh. Should we create defensive copies here? For now, not yet\n         _ignorableProps = src._ignorableProps;        \n         _valueInstantiator = src._valueInstantiator;\n-        _defaultViewInclusion = src._defaultViewInclusion;\n+        _objectIdReader = src._objectIdReader;\n+        \n+        _buildMethod = src._buildMethod;\n+        _builderConfig = src._builderConfig;\n     }\n \n     private static HashMap<String, SettableBeanProperty> _copy(HashMap<String, SettableBeanProperty> src)\n         _objectIdReader = r;\n     }\n \n-    public void setPOJOBuilder(AnnotatedMethod buildMethod,\n-            JsonPOJOBuilder.Value config) {\n-    \t_buildMethod = buildMethod;\n-    \t_builderConfig = config;\n+    public void setPOJOBuilder(AnnotatedMethod buildMethod, JsonPOJOBuilder.Value config) {\n+        _buildMethod = buildMethod;\n+        _builderConfig = config;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n             HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n             boolean hasViews)\n     {\n-    \tsuper(builder, beanDesc, properties, backRefs,\n-    \t\t\tignorableProps, ignoreAllUnknown, hasViews);\n-    \t_buildMethod = builder.getBuildMethod();\n-    \t// 05-Mar-2012, tatu: Can not really make Object Ids work with builders, not yet anyway\n-    \tif (_objectIdReader != null) {\n-    \t    throw new IllegalArgumentException(\"Can not use Object Id with Builder-based deserialization (type \"\n-    \t            +beanDesc.getType()+\")\");\n-    \t}\n+        super(builder, beanDesc, properties, backRefs,\n+                ignorableProps, ignoreAllUnknown, hasViews);\n+        _buildMethod = builder.getBuildMethod();\n+        // 05-Mar-2012, tatu: Can not really make Object Ids work with builders, not yet anyway\n+        if (_objectIdReader != null) {\n+            throw new IllegalArgumentException(\"Can not use Object Id with Builder-based deserialization (type \"\n+                    +beanDesc.getType()+\")\");\n+        }\n     }\n \n     /**\n     }\n     \n     protected BuilderBasedDeserializer(BuilderBasedDeserializer src, NameTransformer unwrapper) {\n-    \tsuper(src, unwrapper);\n+        super(src, unwrapper);\n         _buildMethod = src._buildMethod;\n     }\n \n     {\n         try {\n             return _buildMethod.getMember().invoke(builder);\n-    \t} catch (Exception e) {\n-    \t    wrapInstantiationProblem(e, ctxt);\n-    \t    return null;\n-    \t}\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null;\n+        }\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n                     return nodeFactory.binaryNode((byte[]) ob);\n                 }\n                 // any other special handling needed?\n-                return nodeFactory.POJONode(ob);\n+                return nodeFactory.pojoNode(ob);\n             }\n \n         case VALUE_STRING:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n                 : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n         _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n     }\n-    \n+\n     /**\n      * Copy-constructor that sub-classes can use when creating new instances\n      * by fluent-style construction\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n         if (value == null) {\n             addNull();\n         } else {\n-            _add(POJONode(value));\n+            _add(pojoNode(value));\n         }\n         return this;\n     }\n         if (value == null) {\n             return insertNull(index);\n         }\n-        return _insert(index, POJONode(value));\n+        return _insert(index, pojoNode(value));\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n package com.fasterxml.jackson.databind.node;\n \n import java.math.BigDecimal;\n+import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n \n  */\n public abstract class ContainerNode<T extends ContainerNode<T>>\n     extends BaseJsonNode\n+    implements JsonNodeCreator\n {\n     /**\n      * We will keep a reference to the Object (usually TreeMapper)\n \n     /*\n     /**********************************************************\n-    /* NodeCreator implementation, just dispatch to\n+    /* JsonNodeCreator implementation, just dispatch to\n     /* the real creator\n     /**********************************************************\n      */\n      * Factory method that constructs and returns an empty {@link ArrayNode}\n      * Construction is done using registered {@link JsonNodeFactory}.\n      */\n+    @Override\n     public final ArrayNode arrayNode() { return _nodeFactory.arrayNode(); }\n \n     /**\n      * Factory method that constructs and returns an empty {@link ObjectNode}\n      * Construction is done using registered {@link JsonNodeFactory}.\n      */\n+    @Override\n     public final ObjectNode objectNode() { return _nodeFactory.objectNode(); }\n \n+    @Override\n     public final NullNode nullNode() { return _nodeFactory.nullNode(); }\n \n+    @Override\n     public final BooleanNode booleanNode(boolean v) { return _nodeFactory.booleanNode(v); }\n \n+    @Override\n     public final NumericNode numberNode(byte v) { return _nodeFactory.numberNode(v); }\n+    @Override\n     public final NumericNode numberNode(short v) { return _nodeFactory.numberNode(v); }\n+    @Override\n     public final NumericNode numberNode(int v) { return _nodeFactory.numberNode(v); }\n+    @Override\n     public final NumericNode numberNode(long v) { return _nodeFactory.numberNode(v); }\n+\n+    // was missing from 2.2 and before\n+    @Override\n+    public final NumericNode numberNode(BigInteger v) { return _nodeFactory.numberNode(v); }\n+\n+    @Override\n     public final NumericNode numberNode(float v) { return _nodeFactory.numberNode(v); }\n+    @Override\n     public final NumericNode numberNode(double v) { return _nodeFactory.numberNode(v); }\n+    @Override\n     public final NumericNode numberNode(BigDecimal v) { return (_nodeFactory.numberNode(v)); }\n \n+    // // Wrapper types, missing from 2.2 and before\n+    @Override\n+    public final ValueNode numberNode(Byte v) { return _nodeFactory.numberNode(v); }\n+    @Override\n+    public final ValueNode numberNode(Short v) { return _nodeFactory.numberNode(v); }\n+    @Override\n+    public final ValueNode numberNode(Integer v) { return _nodeFactory.numberNode(v); }\n+    @Override\n+    public final ValueNode numberNode(Long v) { return _nodeFactory.numberNode(v); }\n+\n+    @Override\n+    public final ValueNode numberNode(Float v) { return _nodeFactory.numberNode(v); }\n+    @Override\n+    public final ValueNode numberNode(Double v) { return _nodeFactory.numberNode(v); }\n+    \n+    @Override\n     public final TextNode textNode(String text) { return _nodeFactory.textNode(text); }\n \n+    @Override\n     public final BinaryNode binaryNode(byte[] data) { return _nodeFactory.binaryNode(data); }\n+    @Override\n     public final BinaryNode binaryNode(byte[] data, int offset, int length) { return _nodeFactory.binaryNode(data, offset, length); }\n \n-    public final POJONode POJONode(Object pojo) { return _nodeFactory.POJONode(pojo); }\n+    @Override\n+    public final ValueNode pojoNode(Object pojo) { return _nodeFactory.pojoNode(pojo); }\n \n+    /**\n+     * @deprecated Since 2.3 Use {@link #pojoNode} instead.\n+     */\n+    @Deprecated\n+    public final POJONode POJONode(Object pojo) { return (POJONode) _nodeFactory.pojoNode(pojo); }\n+    \n     /*\n     /**********************************************************\n     /* Common mutators\n      * @return Container node itself (to allow method call chaining)\n      */\n     public abstract T removeAll();\n-\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeCreator.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * Interface that defines common \"creator\" functionality implemented\n+ * both by {@link JsonNodeFactory} and {@link ContainerNode} (that is,\n+ * JSON Object and Array nodes).\n+ * \n+ * @since 2.3\n+ */\n+public interface JsonNodeCreator\n+{\n+    // Enumerated/singleton types\n+    \n+    public ValueNode booleanNode(boolean v);\n+    public ValueNode nullNode();\n+\n+    // Numeric types\n+\n+    public ValueNode numberNode(byte v);\n+    public ValueNode numberNode(Byte value);\n+    public ValueNode numberNode(short v);\n+    public ValueNode numberNode(Short value);\n+    public ValueNode numberNode(int v);\n+    public ValueNode numberNode(Integer value);\n+    public ValueNode numberNode(long v);\n+    public ValueNode numberNode(Long value);\n+    public ValueNode numberNode(BigInteger v);\n+    public ValueNode numberNode(float v);\n+    public ValueNode numberNode(Float value);\n+    public ValueNode numberNode(double v);\n+    public ValueNode numberNode(Double value);\n+    public ValueNode numberNode(BigDecimal v);\n+\n+    // Textual nodes, other value (non-structured) nodes\n+\n+    public ValueNode textNode(String text);\n+    public ValueNode binaryNode(byte[] data);\n+    public ValueNode binaryNode(byte[] data, int offset, int length);\n+    public ValueNode pojoNode(Object pojo);\n+\n+    // Structured nodes:\n+    // (bit unkosher, due to forward references... but has to do for now)\n+\n+    public ArrayNode arrayNode();\n+    public ObjectNode objectNode();\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n  */\n public class JsonNodeFactory\n     implements java.io.Serializable // since 2.1\n+        ,JsonNodeCreator // since 2.3\n {\n-    // for 2.1:\n-    private static final long serialVersionUID = 2323165117839546871L;\n+    // with 2.2\n+    private static final long serialVersionUID = -3271940633258788634L;\n \n     private final boolean _cfgBigDecimalExact;\n \n      * Factory method for getting an instance of JSON boolean value\n      * (either literal 'true' or 'false')\n      */\n+    @Override\n     public BooleanNode booleanNode(boolean v) {\n         return v ? BooleanNode.getTrue() : BooleanNode.getFalse();\n     }\n      * Factory method for getting an instance of JSON null node (which\n      * represents literal null value)\n      */\n+    @Override\n     public NullNode nullNode() { return NullNode.getInstance(); }\n \n     /*\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 8-bit value\n      */\n+    @Override\n     public NumericNode numberNode(byte v) { return IntNode.valueOf(v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Byte value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     }\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 16-bit integer value\n      */\n+    @Override\n     public NumericNode numberNode(short v) { return ShortNode.valueOf(v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Short value) {\n         return (value == null) ? nullNode() : ShortNode.valueOf(value);\n     }\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 32-bit integer value\n      */\n+    @Override\n     public NumericNode numberNode(int v) { return IntNode.valueOf(v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     }\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 64-bit integer value\n      */\n+    @Override\n     public NumericNode numberNode(long v) { return LongNode.valueOf(v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Long value) {\n         return (value == null) ? nullNode() : LongNode.valueOf(value.longValue());\n     }\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given unlimited range integer value\n      */\n+    @Override\n     public NumericNode numberNode(BigInteger v) { return BigIntegerNode.valueOf(v); }\n \n     /**\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 32-bit floating point value\n      */\n+    @Override\n     public NumericNode numberNode(float v) { return FloatNode.valueOf((float) v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Float value) {\n         return (value == null) ? nullNode() : FloatNode.valueOf(value.floatValue());\n     }\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 64-bit floating point value\n      */\n+    @Override\n     public NumericNode numberNode(double v) { return DoubleNode.valueOf(v); }\n \n     /**\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n+    @Override\n     public ValueNode numberNode(Double value) {\n         return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n     }\n      *\n      * @see #JsonNodeFactory(boolean)\n      */\n+    @Override\n     public NumericNode numberNode(BigDecimal v)\n     {\n         /*\n      * Factory method for constructing a node that represents JSON\n      * String value\n      */\n+    @Override\n     public TextNode textNode(String text) { return TextNode.valueOf(text); }\n \n     /**\n      * binary data, and will get serialized as equivalent base64-encoded\n      * String value\n      */\n+    @Override\n     public BinaryNode binaryNode(byte[] data) { return BinaryNode.valueOf(data); }\n \n     /**\n      * binary data, and will get serialized as equivalent base64-encoded\n      * String value\n      */\n+    @Override\n     public BinaryNode binaryNode(byte[] data, int offset, int length) {\n         return BinaryNode.valueOf(data, offset, length);\n     }\n     /**\n      * Factory method for constructing an empty JSON Array node\n      */\n+    @Override\n     public ArrayNode arrayNode() { return new ArrayNode(this); }\n \n     /**\n      * Factory method for constructing an empty JSON Object (\"struct\") node\n      */\n+    @Override\n     public ObjectNode objectNode() { return new ObjectNode(this); }\n \n     /**\n      * using data binding, usually as JSON Objects, but in some\n      * cases as JSON Strings or other node types.\n      */\n+    @Override\n+    public ValueNode pojoNode(Object pojo) { return new POJONode(pojo); }\n+\n+    /**\n+     * @deprecated Since 2.3 Use {@link #pojoNode} instead.\n+     */\n+    @Deprecated\n     public POJONode POJONode(Object pojo) { return new POJONode(pojo); }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode putPOJO(String fieldName, Object pojo) {\n-        _children.put(fieldName, POJONode(pojo));\n+        _children.put(fieldName, pojoNode(pojo));\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n             } else { // can NOT suppress entries in tabular output\n                 jgen.writeNull();\n             }\n+            return;\n         }\n         // otherwise find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n \n     protected void failForEmpty(Object value) throws JsonMappingException\n     {\n-        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS) )\");\n+        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )\");\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java\n         ObjectMapper mapper = new ObjectMapper();\n         // also need tree mapper to construct tree to serialize\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.set(\"pojo\", mapper.getNodeFactory().POJONode(\"abc\"));\n+        n.set(\"pojo\", mapper.getNodeFactory().pojoNode(\"abc\"));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getFactory().createGenerator(sw);\n         mapper.writeTree(jg, n);\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.set(\"pojo\", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));\n+        n.set(\"pojo\", mapper.getNodeFactory().pojoNode(new int[] { 1, 2, 3 }));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getFactory().createGenerator(sw);\n         mapper.writeTree(jg, n);\n         ObjectMapper mapper = new ObjectMapper();\n         // also need tree mapper to construct tree to serialize\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.set(\"pojo\", mapper.getNodeFactory().POJONode(new Bean()));\n+        n.set(\"pojo\", mapper.getNodeFactory().pojoNode(new Bean()));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getFactory().createGenerator(sw);\n         mapper.writeTree(jg, n);\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n     static class A {\n         public B value = new B();\n     }\n-    \n+\n     @JsonPropertyOrder(alphabetic=true)\n     static class B {\n         public int x = 1;\n     @JsonFormat(shape=Shape.ARRAY)\n     static class SingleBean {\n         public String name = \"foo\";\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    @JsonFormat(shape=Shape.ARRAY)\n+    static class TwoStringsBean {\n+        public String bar = null;\n+        public String foo = \"bar\";\n     }\n     \n     /*\n         String json = MAPPER.writeValueAsString(new FlatPojo(\"Bubba\", 1, 2, false));\n         // will have wrapper POJO, then POJO-as-array..\n         assertEquals(\"[false,\\\"Bubba\\\",1,2]\", json);\n-    }    \n+    }\n+\n+    // [Issue#223]\n+    public void testNullColumn() throws Exception\n+    {\n+        assertEquals(\"[null,\\\"bar\\\"]\", MAPPER.writeValueAsString(new TwoStringsBean()));\n+    }\n \n     /*\n     /*****************************************************", "timestamp": 1368849499, "metainfo": ""}