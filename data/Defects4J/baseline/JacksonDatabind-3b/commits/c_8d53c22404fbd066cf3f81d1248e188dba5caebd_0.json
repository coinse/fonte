{"sha": "8d53c22404fbd066cf3f81d1248e188dba5caebd", "log": "More refactoring, piping through \"wrapper name\" so downstream code need not use introspector", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n      * Method to get declared type of the property.\n      */\n     public JavaType getType();\n+\n+    /**\n+     * If property is indicated to be wrapped, name of\n+     * wrapper element to use.\n+     * \n+     * @since 2.2\n+     */\n+    public PropertyName getWrapperName();\n     \n     /**\n      * Whether value for property is marked as required using\n     {\n         protected final String _name;\n         protected final JavaType _type;\n+        protected final PropertyName _wrapperName;\n+        \n+        protected final boolean _isRequired;\n \n         /**\n          * Physical entity (field, method or constructor argument) that\n          */\n         protected final Annotations _contextAnnotations;\n         \n-        public Std(String name, JavaType type, Annotations contextAnnotations, AnnotatedMember member)\n+        public Std(String name, JavaType type, PropertyName wrapperName,\n+                Annotations contextAnnotations, AnnotatedMember member,\n+                boolean isRequired)\n         {\n             _name = name;\n             _type = type;\n+            _wrapperName = wrapperName;\n+            _isRequired = isRequired;\n             _member = member;\n             _contextAnnotations = contextAnnotations;\n         }\n         \n         public Std withType(JavaType type) {\n-            return new Std(_name, type, _contextAnnotations, _member);\n+            return new Std(_name, type, _wrapperName, _contextAnnotations, _member, _isRequired);\n         }\n         \n         @Override\n         }\n \n         @Override\n+        public PropertyName getWrapperName() {\n+            return _wrapperName;\n+        }\n+        \n+        @Override\n         public boolean isRequired() {\n-            // !!! TODO (maybe): allow changing\n-            return false;\n+            return _isRequired;\n         }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n  * @since 2.1\n  */\n public class PropertyName\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 7930806520033045126L;\n+\n+    private final static String _USE_DEFAULT = \"\";\n+    private final static String _NO_NAME = \"#disabled\";\n+\n     /**\n      * Special placeholder value that indicates that name to use should be\n      * based on the standard heuristics. This can be different from returning\n      * null, as null means \"no information available, whereas this value\n      * indicates explicit defaulting.\n      */\n-    public final static PropertyName USE_DEFAULT = new PropertyName(\"\", null);\n+    public final static PropertyName USE_DEFAULT = new PropertyName(_USE_DEFAULT, null);\n \n     /**\n      * Special placeholder value that indicates that there is no name associated.\n      * Exact semantics to use (if any) depend on actual annotation in use, but\n      * commonly this value disables behavior for which name would be needed.\n      */\n-    public final static PropertyName NO_NAME = new PropertyName(new String(\"#disabled\"), null);\n+    public final static PropertyName NO_NAME = new PropertyName(new String(_NO_NAME), null);\n     \n     /**\n      * Basic name of the property.\n         _namespace = namespace;\n     }\n \n+    // To support JDK serialization, recovery of Singleton instance\n+    protected Object readResolve() {\n+        if (_simpleName == null || _USE_DEFAULT.equals(_simpleName)) {\n+            return USE_DEFAULT;\n+        }\n+        if (_simpleName.equals(_NO_NAME)) {\n+            return NO_NAME;\n+        }\n+        return this;\n+    }\n+    \n     public static PropertyName construct(String simpleName, String ns)\n     {\n         if (simpleName == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n+        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param);\n+        // how to default? Other code assumes missing value means 'false', so:\n+        boolean req = (b == null) ? false : b.booleanValue();\n+\n         JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n-        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), param);\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0,\n+                intr.findWrapperName(param),\n+                beanDesc.getClassAnnotations(), param, req);\n         JavaType type = resolveType(ctxt, beanDesc, t0, param);\n         if (type != t0) {\n             property = property.withType(type);\n         if (typeDeser == null) {\n             typeDeser = findTypeDeserializer(config, type);\n         }\n-        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n-        Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param);\n-        // how to default? Other code assumes missing value means 'false', so:\n-        boolean isRequired = (b == null) ? false : b.booleanValue();\n-\n-        CreatorProperty prop = new CreatorProperty(name, type, typeDeser,\n-                beanDesc.getClassAnnotations(), param, index, injectableValueId,\n-                isRequired);\n+\n+        CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(),\n+                typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId,\n+                property.isRequired());\n         if (deser != null) {\n             prop = prop.withValueDeserializer(deser);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n             AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n             // Need to create a temporary property to allow contextual deserializers:\n             BeanProperty.Std property = new BeanProperty.Std(null,\n-                    delegateType, _classAnnotations, delegateCreator);\n+                    delegateType, null, _classAnnotations, delegateCreator, false);\n             _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n         }\n         // we know it's a 2-arg method, second arg is the value\n         JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getGenericParameterType(1));\n-        BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, beanDesc.getClassAnnotations(), setter);\n+        BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, null,\n+                beanDesc.getClassAnnotations(), setter, false);\n         type = resolveType(ctxt, beanDesc, type, setter);\n \n         /* AnySetter can be annotated with @JsonClass (etc) just like a\n         // note: this works since we know there's exactly one argument for methods\n         JavaType t0 = beanDesc.resolveType(jdkType);\n \n-        BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, beanDesc.getClassAnnotations(), mutator);\n+        BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(),\n+                beanDesc.getClassAnnotations(), mutator, propDef.isRequired());\n         JavaType type = resolveType(ctxt, beanDesc, t0, mutator);\n         // did type change?\n         if (type != t0) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.PropertyName;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n             Annotations contextAnnotations, AnnotatedParameter param,\n             int index, Object injectableValueId)\n     {\n-        this(name, type, typeDeser, contextAnnotations, param, index, injectableValueId,\n-                true);\n+        this(name, type, null, typeDeser, contextAnnotations, param, index,\n+                injectableValueId, true);\n     }\n     \n     /**\n      *    method parameter; used for accessing annotations of the property\n      * @param index Index of this property within creator invocatino\n      */\n-    public CreatorProperty(String name, JavaType type, TypeDeserializer typeDeser,\n+    public CreatorProperty(String name, JavaType type, PropertyName wrapperName,\n+            TypeDeserializer typeDeser,\n             Annotations contextAnnotations, AnnotatedParameter param,\n             int index, Object injectableValueId,\n             boolean isRequired)\n     {\n-        super(name, type, typeDeser, contextAnnotations, isRequired);\n+        super(name, type, wrapperName, typeDeser, contextAnnotations, isRequired);\n         _annotated = param;\n         _creatorIndex = index;\n         _injectableValueId = injectableValueId;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n      * Base type for property; may be a supertype of actual value.\n      */\n     protected final JavaType _type;\n+\n+    /**\n+     * @since 2.2\n+     */\n+    protected final PropertyName _wrapperName;\n     \n     /**\n      * Class that contains this property (either class that declares\n     protected SettableBeanProperty(BeanPropertyDefinition propDef,\n             JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations)\n     {\n-        this(propDef.getName(), type, typeDeser, contextAnnotations,\n+        this(propDef.getName(), type, propDef.getWrapperName(), typeDeser, contextAnnotations,\n                 propDef.isRequired());\n     }\n \n     @Deprecated // since 2.2\n-    protected SettableBeanProperty(String propName,\n-            JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations)\n-    {\n-        this(propName, type, typeDeser, contextAnnotations, false);\n-    }\n-    \n-    protected SettableBeanProperty(String propName,\n-            JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations,\n+    protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n+            TypeDeserializer typeDeser, Annotations contextAnnotations)\n+    {\n+        this(propName, type, wrapper, typeDeser, contextAnnotations, false);\n+    }\n+    \n+    protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n+            TypeDeserializer typeDeser, Annotations contextAnnotations,\n             boolean isRequired)\n     {\n         /* 09-Jan-2009, tatu: Intern()ing makes sense since Jackson parsed\n             _propName = InternCache.instance.intern(propName);\n         }\n         _type = type;\n+        _wrapperName = wrapper;\n         _isRequired = isRequired;\n         _contextAnnotations = contextAnnotations;\n         _viewMatcher = null;\n     {\n         _propName = src._propName;\n         _type = src._type;\n+        _wrapperName = src._wrapperName;\n         _isRequired = src._isRequired;\n         _contextAnnotations = src._contextAnnotations;\n         _valueDeserializer = src._valueDeserializer;\n     {\n         _propName = src._propName;\n         _type = src._type;\n+        _wrapperName = src._wrapperName;\n         _isRequired = src._isRequired;\n         _contextAnnotations = src._contextAnnotations;\n         _valueTypeDeserializer = src._valueTypeDeserializer;\n     {\n         _propName = newName;\n         _type = src._type;\n+        _wrapperName = src._wrapperName;\n         _isRequired = src._isRequired;\n         _contextAnnotations = src._contextAnnotations;\n         _valueDeserializer = src._valueDeserializer;\n     @Override\n     public JavaType getType() { return _type; }\n \n+    @Override\n+    public PropertyName getWrapperName() {\n+        return _wrapperName;\n+    }\n+    \n     @Override\n     public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n             String refName, SettableBeanProperty backward,\n             Annotations contextAnnotations, boolean isContainer)\n     {\n-        super(forward.getName(), forward.getType(), forward.getValueTypeDeserializer(),\n-                contextAnnotations,\n+        super(forward.getName(), forward.getType(), forward.getWrapperName(),\n+                forward.getValueTypeDeserializer(), contextAnnotations,\n                 forward.isRequired());\n         _referenceName = refName;\n         _managedProperty = forward;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n     public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n             boolean isRequired)\n     {\n-        super(objectIdReader.propertyName, objectIdReader.idType, null, null,\n+        super(objectIdReader.propertyName, objectIdReader.idType, null, null, null,\n                 isRequired);\n         _objectIdReader = objectIdReader;\n         _valueDeserializer = objectIdReader.deserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ValueInjector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ValueInjector.java\n             Annotations contextAnnotations, AnnotatedMember mutator,\n             Object valueId)\n     {\n-        super(propertyName, type, contextAnnotations, mutator);\n+        super(propertyName, type, null, contextAnnotations, mutator, false);\n         _valueId = valueId;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n             JavaType intType = config.constructType(Integer.TYPE);\n             JavaType longType = config.constructType(Long.TYPE);\n             return  new CreatorProperty[] {\n-                    new CreatorProperty(\"sourceRef\", config.constructType(Object.class), null, null, null, 0, null, true),\n-                    new CreatorProperty(\"byteOffset\", longType, null, null, null, 1, null, true),\n-                    new CreatorProperty(\"charOffset\", longType, null, null, null, 2, null, true),\n-                    new CreatorProperty(\"lineNr\", intType, null, null, null, 3, null, true),\n-                    new CreatorProperty(\"columnNr\", intType, null, null, null, 4, null, true)\n+                    creatorProp(\"sourceRef\", config.constructType(Object.class), 0),\n+                    creatorProp(\"byteOffset\", longType, 1),\n+                    creatorProp(\"charOffset\", longType, 2),\n+                    creatorProp(\"lineNr\", intType, 3),\n+                    creatorProp(\"columnNr\", intType, 4)\n             };\n         }\n \n+        private static CreatorProperty creatorProp(String name, JavaType type, int index) {\n+            return new CreatorProperty(name, type, null,\n+                    null, null, null, index, null, true);\n+        }\n+        \n         @Override\n         public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {\n             return new JsonLocation(args[0], _long(args[1]), _long(args[2]),\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n     @Override\n     public PropertyName getWrapperName() {\n-    \t/* 13-Mar-2013, tatu: Accessing via primary member SHOULD work,\n-    \t *   due to annotation merging. However, I have seen some problems\n-    \t *   with this access (for other annotations) so will leave full\n-    \t *   traversal code in place just in case.\n-    \t */\n-    \tAnnotatedMember member = getPrimaryMember();\n-    \treturn (member == null) ? null : _annotationIntrospector.findWrapperName(member);\n+        /* 13-Mar-2013, tatu: Accessing via primary member SHOULD work,\n+         *   due to annotation merging. However, I have seen some problems\n+         *   with this access (for other annotations) so will leave full\n+         *   traversal code in place just in case.\n+         */\n+        AnnotatedMember member = getPrimaryMember();\n+        return (member == null || _annotationIntrospector == null) ? null\n+                : _annotationIntrospector.findWrapperName(member);\n     \t/*\n         return fromMemberAnnotations(new WithMember<PropertyName>() {\n             @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     protected final SerializedString _name;\n \n     /**\n+     * Wrapper name to use for this element, if any\n+     * \n+     * @since 2.2\n+     */\n+    protected final PropertyName _wrapperName;\n+    \n+    /**\n      * Type to use for locating serializer; normally same as return\n      * type of the accessor method, but may be overridden by annotations.\n      */\n         _member = member;\n         _contextAnnotations = contextAnnotations;\n         _name = new SerializedString(propDef.getName());\n+        _wrapperName = propDef.getWrapperName();\n         _declaredType = declaredType;\n         _serializer = (JsonSerializer<Object>) ser;\n         _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n     protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name)\n     {\n         _name = name;\n+        _wrapperName = base._wrapperName;\n \n         _member = base._member;\n         _contextAnnotations = base._contextAnnotations;\n     }\n \n     @Override\n+    public PropertyName getWrapperName() {\n+        return _wrapperName;\n+    }\n+\n+    @Override\n     public boolean isRequired() {\n         return _isRequired;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n             // last 2 nulls; don't know key, value serializers (yet)\n             MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n                     typeSer, null, null);\n-            BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType,\n-                    beanDesc.getClassAnnotations(), anyGetter);\n+            BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null,\n+                    beanDesc.getClassAnnotations(), anyGetter, false);\n             builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer));\n         }\n         // Next: need to gather view information, if any:\n             accessor.fixAccess();\n         }\n         JavaType type = accessor.getType(typeContext);\n-        BeanProperty.Std property = new BeanProperty.Std(name, type, pb.getClassAnnotations(), accessor);\n+        BeanProperty.Std property = new BeanProperty.Std(name, type, propDef.getWrapperName(),\n+                pb.getClassAnnotations(), accessor, propDef.isRequired());\n \n         // Does member specify a serializer? If so, let's use it.\n         JsonSerializer<?> annotatedSerializer = findSerializerFromAnnotation(prov,\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestValueInstantiator.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueInstantiator.java\n         \n         @Override\n         public boolean canCreateFromObjectWith() { return true; }\n-\n+        \n         @Override\n         public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n             return  new CreatorProperty[] {\n-                    new CreatorProperty(\"type\", config.constructType(Class.class),\n+                    new CreatorProperty(\"type\", config.constructType(Class.class), null,\n                             null, null, null, 0, null, true)\n             };\n         }\n         @Override\n         public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n             return  new CreatorProperty[] {\n-                    new CreatorProperty(\"name\", config.constructType(String.class),\n+                    new CreatorProperty(\"name\", config.constructType(String.class), null,\n                             null, null, null, 0, null, true)\n             };\n         }\n                     @Override\n                     public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n                         return  new CreatorProperty[] {\n-                                new CreatorProperty(\"secret\", config.constructType(String.class),\n+                                new CreatorProperty(\"secret\", config.constructType(String.class), null,\n                                         null, null, null, 0, null, true)\n                         };\n                     }", "timestamp": 1363215369, "metainfo": ""}