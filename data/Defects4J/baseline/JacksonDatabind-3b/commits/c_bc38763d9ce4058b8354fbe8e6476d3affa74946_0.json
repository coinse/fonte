{"sha": "bc38763d9ce4058b8354fbe8e6476d3affa74946", "log": "Implemented #277", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n     public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        TokenBuffer tb = new TokenBuffer(jp);\n-        // quite simple, given that TokenBuffer is a JsonGenerator:\n-        tb.copyCurrentStructure(jp);\n-        return tb;\n+        return createBufferInstance(jp).deserialize(jp, ctxt);\n+    }\n+\n+    protected TokenBuffer createBufferInstance(JsonParser jp) {\n+        return new TokenBuffer(jp);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n         /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n          * so that old method need not add check for existence of filter.\n          */\n-        \n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             props = _filteredProps;\n             serializeFields(bean, jgen, provider);\n             return;\n         }\n-        \n         int i = 0;\n         try {\n             for (final int len = props.length; i < len; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n import java.io.*;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.TreeMap;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n \n /**\n  * Utility class used for efficient storage of {@link JsonToken}\n     /**\n      * @since 2.3\n      */\n-    protected final boolean _hasNativeTypeIds;\n+    protected boolean _hasNativeTypeIds;\n \n     /**\n      * @since 2.3\n      */\n-    protected final boolean _hasNativeObjectIds;\n+    protected boolean _hasNativeObjectIds;\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected boolean _mayHaveNativeIds;\n     \n     /*\n     /**********************************************************\n      * value (or first token of one) to be written.\n      */\n     protected Object _objectId;\n-    \n+\n+    /**\n+     * Do we currnetly have a native type or object id buffered?\n+     */\n+    protected boolean _hasNativeId = false;\n+\n     /*\n     /**********************************************************\n     /* Output state\n         _appendOffset = 0;\n         _hasNativeTypeIds = hasNativeIds;\n         _hasNativeObjectIds = hasNativeIds;\n+\n+        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n     }\n \n     /**\n         _first = _last = new Segment();\n         _appendOffset = 0;\n         _hasNativeTypeIds = jp.canReadTypeId();\n-        // !!! TODO\n-        _hasNativeObjectIds = false;\n+        _hasNativeObjectIds = jp.canReadObjectId();\n+        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n     }\n     \n     @Override\n      */\n     public JsonParser asParser(ObjectCodec codec)\n     {\n-        return new Parser(_first, codec);\n+        return new Parser(_first, codec, _hasNativeTypeIds, _hasNativeObjectIds);\n     }\n \n     /**\n      */\n     public JsonParser asParser(JsonParser src)\n     {\n-        Parser p = new Parser(_first, src.getCodec());\n+        Parser p = new Parser(_first, src.getCodec(), _hasNativeTypeIds, _hasNativeObjectIds);\n         p.setLocation(src.getTokenLocation());\n         return p;\n     }\n     public TokenBuffer append(TokenBuffer other)\n         throws IOException, JsonGenerationException\n     {\n+        // Important? If source has native ids, need to store\n+        if (!_hasNativeTypeIds) {  \n+            _hasNativeTypeIds = other.canWriteTypeId();\n+        }\n+        if (!_hasNativeObjectIds) {\n+            _hasNativeObjectIds = other.canWriteObjectId();\n+        }\n+        _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n+        \n         JsonParser jp = other.asParser();\n         while (jp.nextToken() != null) {\n-            this.copyCurrentEvent(jp);\n+            copyCurrentStructure(jp);\n         }\n         return this;\n     }\n         Segment segment = _first;\n         int ptr = -1;\n \n+        final boolean checkIds = _mayHaveNativeIds;\n+        boolean hasIds = checkIds && (segment.hasIds());\n+\n         while (true) {\n             if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n                 ptr = 0;\n                 segment = segment.next();\n                 if (segment == null) break;\n+                hasIds = checkIds && (segment.hasIds());\n             }\n             JsonToken t = segment.type(ptr);\n             if (t == null) break;\n \n+            if (hasIds) {\n+                Object id = segment.findObjectId(ptr);\n+                if (id != null) {\n+                    jgen.writeObjectId(id);\n+                }\n+                id = segment.findTypeId(ptr);\n+                if (id != null) {\n+                    jgen.writeTypeId(id);\n+                }\n+            }\n+            \n             // Note: copied from 'copyCurrentEvent'...\n             switch (t) {\n             case START_OBJECT:\n         }\n     }\n \n+    /**\n+     * Helper method used by standard deserializer.\n+     * \n+     * @since 2.3\n+     */\n+    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        copyCurrentStructure(jp);\n+        return this;\n+    }\n+    \n     @Override\n     @SuppressWarnings(\"resource\")\n     public String toString()\n \n         StringBuilder sb = new StringBuilder();\n         sb.append(\"[TokenBuffer: \");\n+\n+        /*\n+sb.append(\"NativeTypeIds=\").append(_hasNativeTypeIds).append(\",\");\n+sb.append(\"NativeObjectIds=\").append(_hasNativeObjectIds).append(\",\");\n+*/\n+        \n         JsonParser jp = asParser();\n         int count = 0;\n+        final boolean hasNativeIds = _hasNativeTypeIds || _hasNativeObjectIds;\n \n         while (true) {\n             JsonToken t;\n             try {\n                 t = jp.nextToken();\n                 if (t == null) break;\n+\n+                if (hasNativeIds) {\n+                    _appendNativeIds(sb);\n+                }\n+                        \n                 if (count < MAX_COUNT) {\n                     if (count > 0) {\n                         sb.append(\", \");\n         sb.append(']');\n         return sb.toString();\n     }\n-        \n+\n+    private final void _appendNativeIds(StringBuilder sb)\n+    {\n+        Object objectId = _last.findObjectId(_appendOffset-1);\n+        if (objectId != null) {\n+            sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n+        }\n+        Object typeId = _last.findTypeId(_appendOffset-1);\n+        if (typeId != null) {\n+            sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonGenerator implementation: configuration\n     @Override\n     public void writeTypeId(Object id) {\n         _typeId = id;\n+        _hasNativeId = true;\n     }\n     \n     @Override\n     public void writeObjectId(Object id) {\n         _objectId = id;\n+        _hasNativeId = true;\n     }\n \n     /*\n     @Override\n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n     {\n-        if (_hasNativeTypeIds) {\n-            _copyTypeId(jp);\n-        }\n-        if (_hasNativeObjectIds) {\n-            _copyObjectId(jp);\n+        if (_mayHaveNativeIds) {\n+            _checkNativeIds(jp);\n         }\n         switch (jp.getCurrentToken()) {\n         case START_OBJECT:\n             throw new RuntimeException(\"Internal error: should never end up through this code path\");\n         }\n     }\n-\n-    protected final void _copyTypeId(JsonParser jp) throws IOException, JsonProcessingException\n-    {\n-        Object id = jp.getTypeId();\n-        if (id != null) {\n-            writeTypeId(id);\n-        }\n-    }\n-\n-    protected final void _copyObjectId(JsonParser jp) throws IOException, JsonProcessingException\n-    {\n-        // !!! TODO\n-        /*\n-        Object id = jp.getObjectId();\n-        if (id != null) {\n-            writeObjectId(id);\n-        }\n-        */\n-    }\n-    \n-    @Override\n-    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+    \n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n         JsonToken t = jp.getCurrentToken();\n \n         // Let's handle field-name separately first\n         if (t == JsonToken.FIELD_NAME) {\n+            if (_mayHaveNativeIds) {\n+                _checkNativeIds(jp);\n+            }\n             writeFieldName(jp.getCurrentName());\n             t = jp.nextToken();\n             // fall-through to copy the associated value\n         }\n \n+        if (_mayHaveNativeIds) {\n+            _checkNativeIds(jp);\n+        }\n+        \n         switch (t) {\n         case START_ARRAY:\n-            if (_hasNativeTypeIds) {\n-                _copyTypeId(jp);\n-            }\n-            if (_hasNativeObjectIds) {\n-                _copyObjectId(jp);\n-            }\n             writeStartArray();\n             while (jp.nextToken() != JsonToken.END_ARRAY) {\n                 copyCurrentStructure(jp);\n             writeEndArray();\n             break;\n         case START_OBJECT:\n-            if (_hasNativeTypeIds) {\n-                _copyTypeId(jp);\n-            }\n-            if (_hasNativeObjectIds) {\n-                _copyObjectId(jp);\n-            }\n             writeStartObject();\n             while (jp.nextToken() != JsonToken.END_OBJECT) {\n                 copyCurrentStructure(jp);\n             copyCurrentEvent(jp);\n         }\n     }\n+\n+    \n+    private final void _checkNativeIds(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        if ((_typeId = jp.getTypeId()) != null) {\n+            _hasNativeId = true;\n+        }\n+        if ((_objectId = jp.getObjectId()) != null) {\n+            _hasNativeId = true;\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n \n     protected final void _append(JsonToken type)\n     {\n-        Segment next = _last.append(_appendOffset, type);\n+        Segment next = _hasNativeId\n+                ? _last.append(_appendOffset, type, _objectId, _typeId)\n+                : _last.append(_appendOffset, type);\n         if (next == null) {\n             ++_appendOffset;\n         } else {\n \n     protected final void _append(JsonToken type, Object value)\n     {\n-        Segment next = _last.append(_appendOffset, type, value);\n+        Segment next = _hasNativeId\n+                ? _last.append(_appendOffset, type, value, _objectId, _typeId)\n+                : _last.append(_appendOffset, type, value);\n         if (next == null) {\n             ++_appendOffset;\n         } else {\n \n     protected final void _appendRaw(int rawType, Object value)\n     {\n-        Segment next = _last.appendRaw(_appendOffset, rawType, value);\n+        Segment next = _hasNativeId\n+                ? _last.appendRaw(_appendOffset, rawType, value, _objectId, _typeId)\n+                : _last.appendRaw(_appendOffset, rawType, value);\n         if (next == null) {\n             ++_appendOffset;\n         } else {\n             _appendOffset = 1;\n         }\n     }\n-    \n+\n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n     }\n          * @since 2.3\n          */\n         protected final boolean _hasNativeTypeIds;\n+\n+        /**\n+         * @since 2.3\n+         */\n+        protected final boolean _hasNativeObjectIds;\n+\n+        protected final boolean _hasNativeIds;\n         \n         /*\n         /**********************************************************\n          */\n \n         @Deprecated // since 2.3\n-        public Parser(Segment firstSeg, ObjectCodec codec) {\n-            this(firstSeg, codec, false);\n+        protected Parser(Segment firstSeg, ObjectCodec codec) {\n+            this(firstSeg, codec, false, false);\n         }\n \n         /**\n          * @since 2.3\n          */\n-        public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds)\n+        public Parser(Segment firstSeg, ObjectCodec codec,\n+                boolean hasNativeTypeIds,\n+                boolean hasNativeObjectIds)\n         {\n             super(0);\n             _segment = firstSeg;\n             _codec = codec;\n             _parsingContext = JsonReadContext.createRootContext(-1, -1);\n             _hasNativeTypeIds = hasNativeTypeIds;\n+            _hasNativeObjectIds = hasNativeObjectIds;\n+            _hasNativeIds = (hasNativeTypeIds | hasNativeObjectIds);\n         }\n \n         public void setLocation(JsonLocation l) {\n          */\n \n         @Override\n+        public boolean canReadObjectId() {\n+            return _hasNativeObjectIds;\n+        }\n+\n+        @Override\n         public boolean canReadTypeId() {\n             return _hasNativeTypeIds;\n         }\n \n         @Override\n-        public Object getTypeId() throws IOException, JsonParseException\n-        {\n-            if (!_hasNativeTypeIds) {\n-                return super.getTypeId();\n-            }\n-            // !! TODO\n-            return null;\n+        public Object getTypeId() {\n+            return _segment.findTypeId(_segmentPtr);\n+        }\n+\n+        @Override\n+        public Object getObjectId() {\n+            return _segment.findObjectId(_segmentPtr);\n         }\n         \n         /*\n \n         protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n \n+        /**\n+         * Lazily constructed Map for storing native type and object ids, if any\n+         */\n+        protected TreeMap<Integer,Object> _nativeIds;\n+        \n         public Segment() { }\n \n         // // // Accessors\n         }\n \n         public Segment next() { return _next; }\n+\n+        /**\n+         * Accessor for checking whether this segment may have native\n+         * type or object ids.\n+         */\n+        public boolean hasIds() {\n+            return _nativeIds != null;\n+        }\n         \n         // // // Mutators\n \n+        /*\n+\n+    protected final void _appendNativeIds(int offset)\n+    {\n+        Segment seg = _last;\n+        _hasNativeId = false;\n+        if (_objectId != null) {\n+            seg.assignObjectId(offset, _objectId);\n+            _objectId = null;\n+        }\n+        if (_typeId != null) {\n+            seg.assignTypeId(offset, _typeId);\n+            _typeId = null;\n+        }\n+    }\n+         */\n+        \n         public Segment append(int index, JsonToken tokenType)\n         {\n             if (index < TOKENS_PER_SEGMENT) {\n             return _next;\n         }\n \n+        public Segment append(int index, JsonToken tokenType,\n+                Object objectId, Object typeId)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType, objectId, typeId);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType, objectId, typeId);\n+            return _next;\n+        }\n+\n         public Segment append(int index, JsonToken tokenType, Object value)\n         {\n             if (index < TOKENS_PER_SEGMENT) {\n             return _next;\n         }\n \n+        public Segment append(int index, JsonToken tokenType, Object value,\n+                Object objectId, Object typeId)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType, value, objectId, typeId);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType, value, objectId, typeId);\n+            return _next;\n+        }\n+\n         public Segment appendRaw(int index, int rawTokenType, Object value)\n         {\n             if (index < TOKENS_PER_SEGMENT) {\n             _next.set(0, rawTokenType, value);\n             return _next;\n         }\n-        \n-        public void set(int index, JsonToken tokenType)\n+\n+        public Segment appendRaw(int index, int rawTokenType, Object value,\n+                Object objectId, Object typeId)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, rawTokenType, value, objectId, typeId);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, rawTokenType, value, objectId, typeId);\n+            return _next;\n+        }\n+\n+        private void set(int index, JsonToken tokenType)\n         {\n             /* Assumption here is that there are no overwrites, just appends;\n              * and so no masking is needed (nor explicit setting of null)\n             _tokenTypes |= typeCode;\n         }\n \n-        public void set(int index, JsonToken tokenType, Object value)\n+        private void set(int index, JsonToken tokenType,\n+                Object objectId, Object typeId)\n+        {\n+            long typeCode = tokenType.ordinal();\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+            assignNativeIds(index, objectId, typeId);\n+        }\n+\n+        private void set(int index, JsonToken tokenType, Object value)\n         {\n             _tokens[index] = value;\n             long typeCode = tokenType.ordinal();\n-            /* Assumption here is that there are no overwrites, just appends;\n-             * and so no masking is needed\n-             */\n             if (index > 0) {\n                 typeCode <<= (index << 2);\n             }\n             _tokenTypes |= typeCode;\n+        }\n+\n+        private void set(int index, JsonToken tokenType, Object value,\n+                Object objectId, Object typeId)\n+        {\n+            _tokens[index] = value;\n+            long typeCode = tokenType.ordinal();\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+            assignNativeIds(index, objectId, typeId);\n         }\n \n         private void set(int index, int rawTokenType, Object value)\n             }\n             _tokenTypes |= typeCode;\n         }\n+\n+        private void set(int index, int rawTokenType, Object value,\n+                Object objectId, Object typeId)\n+        {\n+            _tokens[index] = value;\n+            long typeCode = (long) rawTokenType;\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+            assignNativeIds(index, objectId, typeId);\n+        }\n+\n+        private final void assignNativeIds(int index,\n+                Object objectId, Object typeId)\n+        {\n+            if (_nativeIds == null) {\n+                _nativeIds = new TreeMap<Integer,Object>();\n+            }\n+            if (objectId != null) {\n+                _nativeIds.put(_objectIdIndex(index), objectId);\n+            }\n+            if (typeId != null) {\n+                _nativeIds.put(_typeIdIndex(index), typeId);\n+            }\n+        }\n+\n+        /**\n+         * @since 2.3\n+         */\n+        public Object findObjectId(int index) {\n+            return (_nativeIds == null) ? null : _nativeIds.get(_objectIdIndex(index));\n+        }\n+        \n+        /**\n+         * @since 2.3\n+         */\n+        public Object findTypeId(int index) {\n+            return (_nativeIds == null) ? null : _nativeIds.get(_typeIdIndex(index));\n+        }\n+\n+        private final int _typeIdIndex(int i) { return i+i; }\n+        private final int _objectIdIndex(int i) { return i+i+1; }\n     }\n }", "timestamp": 1376152652, "metainfo": ""}