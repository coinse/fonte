{"sha": "64ec9cfb151f26e85c0c206ce6aba063695e47cd", "log": "Cleanup of selector class files", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+package org.jsoup.select;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.nodes.Element;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Base combining (and, or) evaluator.\n+ */\n+abstract class CombiningEvaluator extends Evaluator {\n+    final List<Evaluator> evaluators;\n+\n+    CombiningEvaluator() {\n+        super();\n+        evaluators = new ArrayList<Evaluator>();\n+    }\n+\n+    CombiningEvaluator(Collection<Evaluator> evaluators) {\n+        this();\n+        this.evaluators.addAll(evaluators);\n+    }\n+\n+    static final class And extends CombiningEvaluator {\n+        And(Collection<Evaluator> evaluators) {\n+            super(evaluators);\n+        }\n+\n+        And(Evaluator... evaluators) {\n+            this(Arrays.asList(evaluators));\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element node) {\n+            for (Evaluator s : evaluators) {\n+                if (!s.matches(root, node))\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StringUtil.join(evaluators, \" \");\n+        }\n+    }\n+\n+    static final class Or extends CombiningEvaluator {\n+        Or(Collection<Evaluator> evaluators) {\n+            super(evaluators);\n+        }\n+\n+        public void add(Evaluator e) {\n+            evaluators.add(e);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element node) {\n+            for (Evaluator s : evaluators) {\n+                if (s.matches(root, node))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":or%s\", evaluators);\n+        }\n+    }\n+}\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n  * Evaluates that an element matches the selector.\n  */\n public abstract class Evaluator {\n-    protected Evaluator() {\n+    Evaluator() {\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.TokenQueue;\n-import org.jsoup.select.selectors.*;\n \n /**\n  * Parses a CSS selector into an Evaluator tree.\n         tq.consumeWhitespace();\n \n         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n-            evals.add(new RootSelector());\n+            evals.add(new StructuralEvaluator.Root());\n             combinator(tq.consume());\n         } else {\n             findElements();\n             boolean seenWhite = tq.consumeWhitespace();\n \n             if (tq.matchChomp(\",\")) { // group or\n-                OrSelector or = new OrSelector(evals);\n+                CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\n                 evals.clear();\n                 evals.add(or);\n                 while (!tq.isEmpty()) {\n         if (evals.size() == 1)\n             return evals.get(0);\n \n-        return new AndSelector(evals);\n+        return new CombiningEvaluator.And(evals);\n     }\n \n     private void combinator(char combinator) {\n         if (evals.size() == 1)\n             e = evals.get(0);\n         else\n-            e = new AndSelector(evals);\n+            e = new CombiningEvaluator.And(evals);\n         evals.clear();\n         Evaluator f = parse(subQuery);\n \n         if (combinator == '>')\n-            evals.add(BasicSelector.and(f, new ImmediateParentSelector(e)));\n+            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n         else if (combinator == ' ')\n-            evals.add(BasicSelector.and(f, new ParentSelector(e)));\n+            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n         else if (combinator == '+')\n-            evals.add(BasicSelector.and(f, new ImmediatePreviousSiblingSelector(e)));\n+            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n         else if (combinator == '~')\n-            evals.add(BasicSelector.and(f, new PreviousSiblingSelector(e)));\n+            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n         else\n             throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n     }\n         tq.consume(\":has\");\n         String subQuery = tq.chompBalanced('(', ')');\n         Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n-        evals.add(new HasSelector(parse(subQuery)));\n+        evals.add(new StructuralEvaluator.Has(parse(subQuery)));\n     }\n \n     // pseudo selector :contains(text), containsOwn(text)\n         String subQuery = tq.chompBalanced('(', ')');\n         Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n \n-        evals.add(new NotSelector(parse(subQuery)));\n+        evals.add(new StructuralEvaluator.Not(parse(subQuery)));\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+package org.jsoup.select;\n+\n+import org.jsoup.nodes.Element;\n+\n+/**\n+ * Base structural evaluator.\n+ */\n+abstract class StructuralEvaluator extends Evaluator {\n+    Evaluator evaluator;\n+\n+    static class Root extends Evaluator {\n+        public boolean matches(Element root, Element element) {\n+            return root == element;\n+        }\n+    }\n+\n+    static class Has extends StructuralEvaluator {\n+        public Has(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element element) {\n+            for (Element e : element.getAllElements()) {\n+                if (e != element && evaluator.matches(root, e))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        public String toString() {\n+            return String.format(\":has(%s)\", evaluator);\n+        }\n+    }\n+\n+    static class Not extends StructuralEvaluator {\n+        public Not(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element node) {\n+            return !evaluator.matches(root, node);\n+        }\n+\n+        public String toString() {\n+            return String.format(\":not%s\", evaluator);\n+        }\n+    }\n+\n+    static class Parent extends StructuralEvaluator {\n+        public Parent(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element element) {\n+            if (root == element)\n+                return false;\n+\n+            Element parent = element.parent();\n+            while (parent != root) {\n+                if (evaluator.matches(root, parent))\n+                    return true;\n+                parent = parent.parent();\n+            }\n+            return false;\n+        }\n+\n+        public String toString() {\n+            return String.format(\":parent%s\", evaluator);\n+        }\n+    }\n+\n+    static class ImmediateParent extends StructuralEvaluator {\n+        public ImmediateParent(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element element) {\n+            if (root == element)\n+                return false;\n+\n+            Element parent = element.parent();\n+            return parent != null && evaluator.matches(root, parent);\n+        }\n+    }\n+\n+    static class PreviousSibling extends StructuralEvaluator {\n+        public PreviousSibling(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element element) {\n+            if (root == element)\n+                return false;\n+\n+            Element prev = element.previousElementSibling();\n+\n+            while (prev != null) {\n+                if (evaluator.matches(root, prev))\n+                    return true;\n+\n+                prev = prev.previousElementSibling();\n+            }\n+            return false;\n+        }\n+\n+        public String toString() {\n+            return String.format(\":prev*%s\", evaluator);\n+        }\n+    }\n+\n+    static class ImmediatePreviousSibling extends StructuralEvaluator {\n+        public ImmediatePreviousSibling(Evaluator evaluator) {\n+            this.evaluator = evaluator;\n+        }\n+\n+        public boolean matches(Element root, Element element) {\n+            if (root == element)\n+                return false;\n+\n+            Element prev = element.previousElementSibling();\n+            return prev != null && evaluator.matches(root, prev);\n+        }\n+\n+        public String toString() {\n+            return String.format(\":prev%s\", evaluator);\n+        }\n+    }\n+}", "timestamp": 1309605126, "metainfo": ""}