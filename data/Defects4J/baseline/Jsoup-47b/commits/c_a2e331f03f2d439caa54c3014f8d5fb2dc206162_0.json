{"sha": "a2e331f03f2d439caa54c3014f8d5fb2dc206162", "log": "Merge pull request #491 from andyphillips404/master  Update to allow for specification of form post data charset.", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     public Connection parser(Parser parser);\n \n     /**\n+     * Sets the default post data character set for x-www-form-urlencoded post data\n+     * @param charset character set to encode post data\n+     * @return this Connection, for chaining\n+     */\n+    public Connection postDataCharset(String charset);\n+\n+    /**\n      * Execute the request as a GET, and parse the result.\n      * @return parsed Document\n      * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * Sets the post data character set for x-www-form-urlencoded post data\n+         * @param charset character set to encode post data\n+         * @return this Request, for chaining\n+         */\n+        public Request postDataCharset(String charset);\n+\n+        /**\n+         * Gets the post data character set for x-www-form-urlencoded post data\n+         * @return character set to encode post data\n+         */\n+        public String postDataCharset();\n+\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.cert.X509Certificate;\n \n     public Connection response(Connection.Response response) {\n         res = response;\n+        return this;\n+    }\n+\n+    public Connection postDataCharset(String charset) {\n+        req.postDataCharset(charset);\n         return this;\n     }\n \n         private boolean ignoreContentType = false;\n         private Parser parser;\n         private boolean validateTSLCertificates = true;\n+        private String postDataCharset = DataUtil.defaultCharset;\n \n         private Request() {\n             timeoutMilliseconds = 3000;\n \n         public Parser parser() {\n             return parser;\n+        }\n+\n+        public Connection.Request postDataCharset(String charset) {\n+            Validate.notNull(charset, \"Charset must not be null\");\n+            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n+            this.postDataCharset = charset;\n+            return this;\n+        }\n+\n+        public String postDataCharset() {\n+            return postDataCharset;\n         }\n     }\n \n                 bound = DataUtil.mimeBoundary();\n                 req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n             } else {\n-                req.header(CONTENT_TYPE, FORM_URL_ENCODED);\n+                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n             }\n             return bound;\n         }\n                     else\n                         first = false;\n \n-                    w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n+                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                     w.write('=');\n-                    w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                 }\n             }\n             w.close();\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n \n /**\n  * A Connection provides a convenient interface to fetch content from the web, and parse them into Documents.\n- * <p/>\n+ * <p>\n  * To get a new Connection, use {@link org.jsoup.Jsoup#connect(String)}. Connections contain {@link Connection.Request}\n  * and {@link Connection.Response} objects. The request objects are reusable as prototype requests.\n- * <p/>\n+ * </p>\n+ * <p>\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n  * or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n  * executed.\n+ * </p>\n  */\n public interface Connection {\n \n \n     /**\n      * Disable/enable TSL certificates validation for HTTPS requests.\n-     * <p/>\n+     * <p>\n      * By default this is <b>true</b>; all\n      * connections over HTTPS perform normal validation of certificates, and will abort requests if the provided\n      * certificate does not validate.\n-     * <p/>\n+     * </p>\n+     * <p>\n      * Some servers use expired, self-generated certificates; or your JDK may not\n      * support SNI hosts. In which case, you may want to enable this setting.\n-     * <p/> <b>Be careful</b> and understand why you need to disable these validations.\n+     * </p>\n+     * <p>\n+     * <b>Be careful</b> and understand why you need to disable these validations.\n+     * </p>\n      * @param value if should validate TSL (SSL) certificates. <b>true</b> by default.\n      * @return this Connection, for chaining\n      */\n     /**\n      * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n      * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n-     * <code>?name=jsoup&language=Java&language=English</code>\n+     * <code>{@literal ?name=jsoup&language=Java&language=English}</code>\n      * @param keyvals a set of key value pairs.\n      * @return this Connection, for chaining\n      */\n \n     /**\n      * Adds each of the supplied cookies to the request.\n-     * @param cookies map of cookie name -> value pairs\n+     * @param cookies map of cookie name {@literal ->} value pairs\n      * @return this Connection, for chaining\n      */\n     public Connection cookies(Map<String, String> cookies);\n \n         /**\n          * Get the value of a header. This is a simplified header model, where a header may only have one value.\n-         * <p/>\n+         * <p>\n          * Header names are case insensitive.\n+         * </p>\n          * @param name name of header (case insensitive)\n          * @return value of header, or null if not set.\n          * @see #hasHeader(String)\n \n         /**\n          * Get a cookie value by name from this request/response.\n-         * <p/>\n+         * <p>\n          * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n          * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n+         * </p>\n          * @param name name of cookie to retrieve.\n          * @return value of cookie, or null if not set\n          */\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n  * HTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted\n  * plain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a\n  * scrape.\n- * <p/>\n+ * <p>\n  * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n- * <p/>\n- * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:<br/>\n- * <code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code><br/>\n+ * </p>\n+ * <p>\n+ * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:</p>\n+ * <p><code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code></p>\n  * where <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class HtmlToPlainText {\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n                         TokenQueue cd = new TokenQueue(value);\n                         String cookieName = cd.chompTo(\"=\").trim();\n                         String cookieVal = cd.consumeTo(\";\").trim();\n-                        if (cookieVal == null)\n-                            cookieVal = \"\";\n                         // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                         // name not blank, value not null\n-                        if (cookieName != null && cookieName.length() > 0)\n+                        if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // only take the first instance of each header\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n /**\n  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n  * for integration with toolsets that use the W3C DOM.\n- * <p/>\n+ * <p>\n  * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.\n+ * </p>\n  */\n public class W3CDom {\n     protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n \n     /**\n      * Collapsible if it's a boolean attribute and value is empty or same as name\n+     * \n+     * @param out Outputsettings\n+     * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n         return (\"\".equals(value) || value.equalsIgnoreCase(key))\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n \n /**\n  * The attributes of an Element.\n- * <p/>\n+ * <p>\n  * Attributes are treated as a map: there can be only one value associated with an attribute key.\n- * <p/>\n+ * </p>\n+ * <p>\n  * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n  * lower-case.\n+ * </p>\n  * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n                 attributes = new LinkedHashMap<String, Attribute>(2);\n         }\n \n+        @Override\n         public Set<Entry<String, String>> entrySet() {\n             return new EntrySet();\n         }\n         }\n \n         private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n+\n+            @Override\n             public Iterator<Map.Entry<String, String>> iterator() {\n                 return new DatasetIterator();\n             }\n \n+           @Override\n             public int size() {\n                 int count = 0;\n                 Iterator iter = new DatasetIterator();\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n         /**\n          * Set the indent amount for pretty printing\n-         * @param indentAmount number of spaces to use for indenting each level. Must be >= 0.\n+         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n          * @return this, for chaining\n          */\n         public OutputSettings indentAmount(int indentAmount) {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n \n     /**\n      * Get a child element of this element, by its 0-based index number.\n-     * <p/>\n+     * <p>\n      * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n      * a filtered list of children that are elements, and the index is based on that filtered list.\n+     * </p>\n      * \n      * @param index the index number of the element to retrieve\n      * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n \n     /**\n      * Get this element's child elements.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n+     * </p>\n      * @return child elements. If this element has no children, returns an\n      * empty list.\n      * @see #childNodes()\n \n     /**\n      * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n      * @return child text nodes. If this element has no text nodes, returns an\n      * empty list.\n-     * <p/>\n+     * </p>\n      * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n      * <ul>\n      *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n \n     /**\n      * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n+     * </p>\n      * @return child data nodes. If this element has no data nodes, returns an\n      * empty list.\n      * @see #data()\n     /**\n      * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n      * may include this element, or any of its children.\n-     * <p/>\n+     * <p>\n      * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n      * multiple filters can be combined, e.g.:\n+     * </p>\n      * <ul>\n      * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n      * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n      * </ul>\n-     * <p/>\n+     * <p>\n      * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n-     *\n+     * </p>\n+     * \n      * @param cssQuery a {@link Selector} CSS-like query\n      * @return elements that match the query (empty if none match)\n      * @see org.jsoup.select.Selector\n \n     /**\n      * Get a CSS selector that will uniquely select this element.\n-     * <p/>If the element has an ID, returns #id;\n-     * otherwise returns the parent (if any) CSS selector, followed by '>',\n+     * <p>\n+     * If the element has an ID, returns #id;\n+     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n      * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n+     * </p>\n      *\n      * @return the CSS Path that can be used to retrieve the element in a selector.\n      */\n     /**\n      * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n      * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n-     * <p/>\n+     * <p>\n      * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n+     * </p>\n      * @return the next element, or null if there is no next element\n      * @see #previousElementSibling()\n      */\n \n     /**\n      * Gets the literal value of this element's \"class\" attribute, which may include multiple class names, space\n-     * separated. (E.g. on <code>&lt;div class=\"header gray\"></code> returns, \"<code>header gray</code>\")\n+     * separated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n      */\n     public String className() {\n     }\n \n     /**\n-     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\"}>},\n+     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\">},\n      * returns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\n      * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n      * @return set of classnames, empty if no class attribute\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n     /**\n      * Get the Character value of the named entity\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n-     * @return the Character value of the named entity (e.g. '<' or '&')\n+     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n      */\n     public static Character getCharacterByName(String name) {\n         return full.get(name);\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n             String name = el.attr(\"name\");\n             if (name.length() == 0) continue;\n+            String type = el.attr(\"type\");\n \n             if (\"select\".equals(el.tagName())) {\n                 Elements options = el.select(\"option[selected]\");\n                     if (option != null)\n                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n                 }\n+            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n+                // only add checkbox or radio if they have the checked attribute\n+                if (el.hasAttr(\"checked\"))\n+                    data.add(HttpConnection.KeyVal.create(name, el.val()));\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n             }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n     /**\n      * Get an attribute's value by its key.\n-     * <p/>\n+     * <p>\n      * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n      * which is a shortcut to the {@link #absUrl} method.\n-     * E.g.: <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * </p>\n+     * E.g.:\n+     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * \n      * @param attributeKey The attribute key.\n      * @return The attribute, or empty string if not present (to avoid nulls).\n      * @see #attributes()\n     }\n \n     /**\n-     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n-     * <code>&lt;img src></code>).\n-     * <p/>\n+     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href&gt;</code> or\n+     * <code>&lt;img src&gt;</code>).\n+     * <p>\n      * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n-     * <p/>\n+     * </p>\n+     * <p>\n      * If the attribute value is already absolute (i.e. it starts with a protocol, like\n      * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n      * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n      * absolute using that.\n-     * <p/>\n+     * </p>\n+     * <p>\n      * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n      * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n-     *\n+     * </p>\n+     * \n      * @param attributeKey The attribute key\n      * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n      * could not be made successfully into a URL.\n     /**\n      * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n      * the node but keeping its children.\n-     * <p/>\n-     * For example, with the input html:<br/>\n-     * {@code <div>One <span>Two <b>Three</b></span></div>}<br/>\n-     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:<br/>\n-     * {@code <div>One Two <b>Three</b></div>}<br/>\n+     * <p>\n+     * For example, with the input html:\n+     * </p>\n+     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n+     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n+     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n      * and the {@code \"Two \"} {@link TextNode} being returned.\n+     * \n      * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n      * @see #remove()\n      * @see #wrap(String)\n         Validate.isTrue(out.parentNode == this);\n         int index = out.siblingIndex();\n         childNodes.remove(index);\n-        reindexChildren();\n+        reindexChildren(index);\n         out.parentNode = null;\n     }\n \n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren();\n+        reindexChildren(index);\n     }\n \n     protected void reparentChild(Node child) {\n         child.setParentNode(this);\n     }\n     \n-    private void reindexChildren() {\n-        for (int i = 0; i < childNodes.size(); i++) {\n+    private void reindexChildren(int start) {\n+        for (int i = start; i < childNodes.size(); i++) {\n             childNodes.get(i).setSiblingIndex(i);\n         }\n     }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             indent(accum, depth, out);\n \n         boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n-                && !Element.preserveWhitespace((Element) parent());\n+                && !Element.preserveWhitespace(parent());\n         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n     }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            tb.processEndTag(\"noscript\");\n-            return tb.process(t);\n+            tb.insert(new Token.Character().data(t.toString()));\n+            return true;\n         }\n     },\n     AfterHead {\n                         return anyOtherEndTag(t, tb);\n                     } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n-                        OUTER:\n                         for (int i = 0; i < 8; i++) {\n                             Element formatEl = tb.getActiveFormattingElement(name);\n                             if (formatEl == null)\n                             // does that mean: int pos of format el in list?\n                             Element node = furthestBlock;\n                             Element lastNode = furthestBlock;\n-                            INNER:\n                             for (int j = 0; j < 3; j++) {\n                                 if (tb.onStack(node))\n                                     node = tb.aboveOnStack(node);\n                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                     tb.removeFromStack(node);\n-                                    continue INNER;\n+                                    continue;\n                                 } else if (node == formatEl)\n-                                    break INNER;\n+                                    break;\n \n                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                 tb.replaceActiveFormattingElement(node, replacement);\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n         Element body = doc.body();\n         List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n         Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n+        for (int i = nodes.length - 1; i > 0; i--) {\n+            nodes[i].remove();\n+        }\n         for (Node node : nodes) {\n             body.appendChild(node);\n         }\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n     /**\n      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n-     * <p/>\n+     * <p>\n      * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n-     *\n+     * </p>\n+     * \n      * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n      * @return The tag, either defined or new generic.\n      */\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n \n import java.util.Arrays;\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n /**\n  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n  that you are expecting; no junk, and no cross-site scripting attacks!\n- <p/>\n+ <p>\n  The HTML cleaner parses the input as HTML and then runs it through a white-list, so the output HTML can only contain\n  HTML that is allowed by the whitelist.\n- <p/>\n+ </p>\n+ <p>\n  It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the\n  canned white-lists only allow body contained tags.\n- <p/>\n+ </p>\n+ <p>\n  Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.\n+ </p>\n  */\n public class Cleaner {\n     private Whitelist whitelist;\n     /**\n      Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n      in the input HTML are allowed by the whitelist.\n-     <p/>\n+     <p>\n      This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n      using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n      to ensure enforced attributes are set correctly, and that the output is tidied.\n+     </p>\n      @param dirtyDocument document to test\n      @return true if no tags or attributes need to be removed; false if they do\n      */\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n \n /**\n  Whitelists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.\n- <p/>\n+ <p>\n  Start with one of the defaults:\n+ </p>\n  <ul>\n  <li>{@link #none}\n  <li>{@link #simpleText}\n  <li>{@link #basicWithImages}\n  <li>{@link #relaxed}\n  </ul>\n- <p/>\n+ <p>\n  If you need to allow more through (please be careful!), tweak a base whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #addTags}\n  <li>{@link #addAttributes}\n  <li>{@link #addEnforcedAttribute}\n  <li>{@link #addProtocols}\n  </ul>\n- <p/>\n+ <p>\n  You can remove any setting from an existing whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #removeTags}\n  <li>{@link #removeAttributes}\n  <li>{@link #removeEnforcedAttribute}\n  <li>{@link #removeProtocols}\n  </ul>\n- <p/>\n+ \n+ <p>\n  The cleaner and these whitelists assume that you want to clean a <code>body</code> fragment of HTML (to add user\n  supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the\n  document HTML around the cleaned body HTML, or create a whitelist that allows <code>html</code> and <code>head</code>\n  elements as appropriate.\n- <p/>\n+ </p>\n+ <p>\n  If you are going to extend a whitelist, please be very careful. Make sure you understand what attributes may lead to\n  XSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See \n  http://ha.ckers.org/xss.html for some XSS attack examples.\n+ </p>\n \n  @author Jonathan Hedley\n  */\n     }\n \n     /**\n+     <p>\n      This whitelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\n      ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n-     <p/>\n+     </p>\n+     <p>\n      Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n      <code>rel=nofollow</code> attribute.\n-     <p/>\n+     </p>\n+     <p>\n      Does not allow images.\n+     </p>\n \n      @return whitelist\n      */\n      This whitelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\n      code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\n      sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n-     <p/>\n+     <p>\n      Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n+     </p>\n \n      @return whitelist\n      */\n \n     /**\n      Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n      on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>addAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n      @param keys List of valid attributes for the tag\n \n     /**\n      Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n      attributes on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>removeAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for.\n      @param keys List of invalid attributes for the tag\n     /**\n      Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n      already has the attribute set, it will be overridden.\n-     <p/>\n+     <p>\n      E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n-     <code>&lt;a href=\"...\" rel=\"nofollow\"></code>\n+     <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n+     </p>\n \n      @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n      @param key   The attribute key\n      * Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute\n      * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\n      * e.g. {@code http://}.\n-     * <p />\n+     * <p>\n      * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when\n      * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\n      * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\n      * will be removed.\n+     * </p>\n      *\n      * @param preserve {@code true} to allow relative links, {@code false} (default) to deny\n      * @return this Whitelist, for chaining.\n     /**\n      Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\n      URLs with the defined protocol.\n-     <p/>\n+     <p>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n-     <p/>\n+     </p>\n+     <p>\n      To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n \n     /**\n      Remove allowed URL protocols for an element's URL attribute.\n-     <p/>\n+     <p>\n      E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n \n /**\n  A list of {@link Element}s, with methods that act on every element in the list.\n- <p/>\n+ <p>\n  To get an {@code Elements} object, use the {@link Element#select(String)} method.\n+ </p>\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Elements implements List<Element>, Cloneable {\n-    private List<Element> contents;\n-\n+public class Elements extends ArrayList<Element> {\n     public Elements() {\n-        contents = new ArrayList<Element>();\n     }\n \n     public Elements(int initialCapacity) {\n-        contents = new ArrayList<Element>(initialCapacity);\n+        super(initialCapacity);\n     }\n \n     public Elements(Collection<Element> elements) {\n-        contents = new ArrayList<Element>(elements);\n+        super(elements);\n     }\n     \n     public Elements(List<Element> elements) {\n-        contents = elements;\n+        super(elements);\n     }\n     \n     public Elements(Element... elements) {\n-        this(Arrays.asList(elements));\n+    \tsuper(Arrays.asList(elements));\n     }\n \n     /**\n      */\n     @Override\n \tpublic Elements clone() {\n-        Elements clone;\n-        try {\n-            clone = (Elements) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new RuntimeException(e);\n-        }\n-    \tList<Element> elements = new ArrayList<Element>();\n-        clone.contents = elements;\n-    \t\n-    \tfor(Element e : contents)\n-    \t\telements.add(e.clone());\n-\t\t\n+        Elements clone = new Elements(size());\n+\n+        for(Element e : this)\n+    \t\tclone.add(e.clone());\n     \t\n     \treturn clone;\n \t}\n      @see #hasAttr(String)\n      */\n     public String attr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return element.attr(attributeKey);\n         }\n      @return true if any of the elements have the attribute; false if none do.\n      */\n     public boolean hasAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return true;\n         }\n      * @return this\n      */\n     public Elements attr(String attributeKey, String attributeValue) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.attr(attributeKey, attributeValue);\n         }\n         return this;\n      * @return this (for chaining)\n      */\n     public Elements removeAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeAttr(attributeKey);\n         }\n         return this;\n      @return this\n      */\n     public Elements addClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.addClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements removeClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements toggleClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.toggleClass(className);\n         }\n         return this;\n      @return true if any do, false if none do\n      */\n     public boolean hasClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasClass(className))\n                 return true;\n         }\n      * @return this (for chaining)\n      */\n     public Elements val(String value) {\n-        for (Element element : contents)\n+        for (Element element : this)\n             element.val(value);\n         return this;\n     }\n      */\n     public String text() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\" \");\n             sb.append(element.text());\n     }\n \n     public boolean hasText() {\n-        for (Element element: contents) {\n+        for (Element element: this) {\n             if (element.hasText())\n                 return true;\n         }\n      */\n     public String html() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.html());\n      */\n     public String outerHtml() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.outerHtml());\n      * @see Element#tagName(String)\n      */\n     public Elements tagName(String tagName) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.tagName(tagName);\n         }\n         return this;\n      * @see Element#html(String)\n      */\n     public Elements html(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.html(html);\n         }\n         return this;\n      * @see Element#prepend(String)\n      */\n     public Elements prepend(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.prepend(html);\n         }\n         return this;\n      * @see Element#append(String)\n      */\n     public Elements append(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.append(html);\n         }\n         return this;\n      * @see Element#before(String)\n      */\n     public Elements before(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.before(html);\n         }\n         return this;\n      * @see Element#after(String)\n      */\n     public Elements after(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.after(html);\n         }\n         return this;\n      */\n     public Elements wrap(String html) {\n         Validate.notEmpty(html);\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.wrap(html);\n         }\n         return this;\n     /**\n      * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of\n      * dropping the elements but keeping their children.\n-     * <p/>\n+     * <p>\n      * This is useful for e.g removing unwanted formatting elements but keeping their contents.\n-     * <p/>\n-     * E.g. with HTML: {@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}<br/>\n-     * {@code doc.select(\"font\").unwrap();}<br/>\n-     * HTML = {@code <div>One <a href=\"/\">Two</a></div>}\n+     * </p>\n+     * \n+     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n+     * <p>{@code doc.select(\"font\").unwrap();}</p>\n+     * <p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n      *\n      * @return this (for chaining)\n      * @see Node#unwrap\n      */\n     public Elements unwrap() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.unwrap();\n         }\n         return this;\n      * @see #remove()\n      */\n     public Elements empty() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.empty();\n         }\n         return this;\n      * @see #empty()\n      */\n     public Elements remove() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.remove();\n         }\n         return this;\n      * @return Elements containing only the specified element, or, if that element did not exist, an empty list.\n      */\n     public Elements eq(int index) {\n-        return contents.size() > index ? new Elements(get(index)) : new Elements();\n+        return size() > index ? new Elements(get(index)) : new Elements();\n     }\n     \n     /**\n      */\n     public Elements parents() {\n         HashSet<Element> combo = new LinkedHashSet<Element>();\n-        for (Element e: contents) {\n+        for (Element e: this) {\n             combo.addAll(e.parents());\n         }\n         return new Elements(combo);\n      @return The first matched element, or <code>null</code> if contents is empty.\n      */\n     public Element first() {\n-        return contents.isEmpty() ? null : contents.get(0);\n+        return isEmpty() ? null : get(0);\n     }\n \n     /**\n      @return The last matched element, or <code>null</code> if contents is empty.\n      */\n     public Element last() {\n-        return contents.isEmpty() ? null : contents.get(contents.size() - 1);\n+        return isEmpty() ? null : get(size() - 1);\n     }\n \n     /**\n     public Elements traverse(NodeVisitor nodeVisitor) {\n         Validate.notNull(nodeVisitor);\n         NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n-        for (Element el: contents) {\n+        for (Element el: this) {\n             traversor.traverse(el);\n         }\n         return this;\n      */\n     public List<FormElement> forms() {\n         ArrayList<FormElement> forms = new ArrayList<FormElement>();\n-        for (Element el: contents)\n+        for (Element el: this)\n             if (el instanceof FormElement)\n                 forms.add((FormElement) el);\n         return forms;\n     }\n \n-    // implements List<Element> delegates:\n-    public int size() {return contents.size();}\n-\n-    public boolean isEmpty() {return contents.isEmpty();}\n-\n-    public boolean contains(Object o) {return contents.contains(o);}\n-\n-    public Iterator<Element> iterator() {return contents.iterator();}\n-\n-    public Object[] toArray() {return contents.toArray();}\n-\n-    public <T> T[] toArray(T[] a) {return contents.toArray(a);}\n-\n-    public boolean add(Element element) {return contents.add(element);}\n-\n-    public boolean remove(Object o) {return contents.remove(o);}\n-\n-    public boolean containsAll(Collection<?> c) {return contents.containsAll(c);}\n-\n-    public boolean addAll(Collection<? extends Element> c) {return contents.addAll(c);}\n-\n-    public boolean addAll(int index, Collection<? extends Element> c) {return contents.addAll(index, c);}\n-\n-    public boolean removeAll(Collection<?> c) {return contents.removeAll(c);}\n-\n-    public boolean retainAll(Collection<?> c) {return contents.retainAll(c);}\n-\n-    public void clear() {contents.clear();}\n-\n-    @Override\n-    public boolean equals(Object o) {return contents.equals(o);}\n-\n-    @Override\n-    public int hashCode() {return contents.hashCode();}\n-\n-    public Element get(int index) {return contents.get(index);}\n-\n-    public Element set(int index, Element element) {return contents.set(index, element);}\n-\n-    public void add(int index, Element element) {contents.add(index, element);}\n-\n-    public Element remove(int index) {return contents.remove(index);}\n-\n-    public int indexOf(Object o) {return contents.indexOf(o);}\n-\n-    public int lastIndexOf(Object o) {return contents.lastIndexOf(o);}\n-\n-    public ListIterator<Element> listIterator() {return contents.listIterator();}\n-\n-    public ListIterator<Element> listIterator(int index) {return contents.listIterator(index);}\n-\n-    public List<Element> subList(int fromIndex, int toIndex) {return contents.subList(fromIndex, toIndex);}\n }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n      *\n      * @param root    Root of the matching subtree\n      * @param element tested element\n+     * @return Returns <tt>true</tt> if the requirements are met or\n+     * <tt>false</tt> otherwise\n      */\n     public abstract boolean matches(Element root, Element element);\n \n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));\n+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n         }\n \n         @Override\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e < idx)\n+     * Evaluator for matching by sibling index number (e {@literal <} idx)\n      */\n     public static final class IndexLessThan extends IndexEvaluator {\n         public IndexLessThan(int index) {\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e > idx)\n+     * Evaluator for matching by sibling index number (e {@literal >} idx)\n      */\n     public static final class IndexGreaterThan extends IndexEvaluator {\n         public IndexGreaterThan(int index) {\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n \n /**\n  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.\n- * <p/>\n+ * <p>\n  * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.\n+ * </p>\n  */\n public class NodeTraversor {\n     private NodeVisitor visitor;\n--- a/src/main/java/org/jsoup/select/NodeVisitor.java\n+++ b/src/main/java/org/jsoup/select/NodeVisitor.java\n \n /**\n  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.\n- * <p/>\n+ * <p>\n  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first\n  * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to\n  * create a start tag for a node, and tail to create the end tag.\n+ * </p>\n  */\n public interface NodeVisitor {\n     /**\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n \n /**\n  * CSS-like element selector, that finds elements matching a query.\n- * <p/>\n+ * \n  * <h2>Selector syntax</h2>\n+ * <p>\n  * A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against\n  * elements, attributes, and attribute values).\n- * <p/>\n+ * </p>\n+ * <p>\n  * The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n  * is equivalent).\n- * <p/>\n- * <table>\n+ * </p>\n+ * <table summary=\"\">\n  * <tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n- * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n+ * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  * <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  * <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n- * <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n+ * <tr><td><code>E {@literal >} F</code></td><td>an F direct child of E</td><td><code>ol {@literal >} li</code></td></tr>\n  * <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<p><code>div:not(:has(div))</code> finds divs that do not contain divs.</p></td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n  * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n  * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n- * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div > p:first-child</code></td></tr>\n- * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol > li:last-child</code></td></tr>\n+ * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div {@literal >} p:first-child</code></td></tr>\n+ * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>\n  * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n- * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr > td:last-of-type</code></td></tr>\n+ * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>\n  * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>\n  * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>\n  * </table>\n- *\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  * @see Element#select(String)\n  */\n--- a/src/test/java/org/jsoup/TextUtil.java\n+++ b/src/test/java/org/jsoup/TextUtil.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TextUtil {\n+    public static final String LE = String.format(\"%n\");\n+\n     public static String stripNewlines(String text) {\n         text = text.replaceAll(\"\\\\n\\\\s*\", \"\");\n         return text;\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n public class StringUtilTest {\n \n     @Test public void join() {\n-        assertEquals(\"\", StringUtil.join(Arrays.<String>asList(\"\"), \" \"));\n-        assertEquals(\"one\", StringUtil.join(Arrays.<String>asList(\"one\"), \" \"));\n-        assertEquals(\"one two three\", StringUtil.join(Arrays.<String>asList(\"one\", \"two\", \"three\"), \" \"));\n+        assertEquals(\"\", StringUtil.join(Arrays.asList(\"\"), \" \"));\n+        assertEquals(\"one\", StringUtil.join(Arrays.asList(\"one\"), \" \"));\n+        assertEquals(\"one two three\", StringUtil.join(Arrays.asList(\"one\", \"two\", \"three\"), \" \"));\n     }\n \n     @Test public void padding() {\n--- a/src/test/java/org/jsoup/helper/W3CDomTest.java\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n \n import java.io.File;\n import java.io.IOException;\n+\n+import static org.jsoup.TextUtil.LE;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n         Document wDoc = w3c.fromJsoup(doc);\n         String out = w3c.asString(wDoc);\n         assertEquals(\n-                \"<html>\\n\" +\n-                        \"<head>\\n\" +\n-                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\" +\n-                        \"<title>W3c</title>\\n\" +\n-                        \"</head>\\n\" +\n-                        \"<body>\\n\" +\n-                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\\n\" +\n-                        \"<!-- comment -->\\n\" +\n-                        \"<invalid>What<script>alert('!')</script>\\n\" +\n-                        \"</invalid>\\n\" +\n-                        \"</body>\\n\" +\n-                        \"</html>\\n\"\n+                \"<html>\" + LE +\n+                        \"<head>\" + LE +\n+                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\" + LE +\n+                        \"<title>W3c</title>\" + LE +\n+                        \"</head>\" + LE +\n+                        \"<body>\" + LE +\n+                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\" + LE +\n+                        \"<!-- comment -->\" + LE +\n+                        \"<invalid>What<script>alert('!')</script>\" + LE +\n+                        \"</invalid>\" + LE +\n+                        \"</body>\" + LE +\n+                        \"</html>\" + LE\n                 , out);\n     }\n \n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n \n     @Test public void testNormalisesStructure() {\n         Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>\");\n-        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testClone() {\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import static org.jsoup.nodes.Entities.EscapeMode.*;\n import static org.junit.Assert.*;\n \n-import java.nio.charset.Charset;\n \n public class EntitiesTest {\n     @Test public void escape() {\n--- a/src/test/java/org/jsoup/nodes/FormElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/FormElementTest.java\n import org.jsoup.Jsoup;\n import org.junit.Test;\n \n-import java.io.IOException;\n-import java.util.Collection;\n import java.util.List;\n \n import static org.junit.Assert.*;\n \n     @Test public void createsFormData() {\n         String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n-                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea></form>\";\n+                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n+                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n+                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n+                \"</form>\";\n         Document doc = Jsoup.parse(html);\n         FormElement form = (FormElement) doc.select(\"form\").first();\n         List<Connection.KeyVal> data = form.formData();\n \n-        assertEquals(4, data.size());\n+        assertEquals(6, data.size());\n         assertEquals(\"one=two\", data.get(0).toString());\n         assertEquals(\"three=four\", data.get(1).toString());\n         assertEquals(\"three=five\", data.get(2).toString());\n         assertEquals(\"six=seven\", data.get(3).toString());\n+        assertEquals(\"seven=on\", data.get(4).toString());\n+        assertEquals(\"eight=\", data.get(5).toString());\n     }\n \n     @Test public void createsSubmitableConnection() {\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Elements;\n import org.jsoup.select.NodeVisitor;\n import org.junit.Test;\n \n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n \n /**\n     @Test public void testNoImagesInNoScriptInHead() {\n         // jsoup used to allow, but against spec if parsing with noscript\n         Document doc = Jsoup.parse(\"<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>\");\n-        assertEquals(\"<html><head><noscript></noscript></head><body><img src=\\\"foo\\\"><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><noscript>&lt;img src=\\\"foo\\\"&gt;</noscript></head><body><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testAFlowContents() {\n                 \"<!doctype \ufffd> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n     }\n+    \n+    @Test public void handlesManyChildren() {\n+        // Arrange\n+        StringBuilder longBody = new StringBuilder(500000);\n+        for (int i = 0; i < 25000; i++) {\n+            longBody.append(i).append(\"<br>\");\n+        }\n+        \n+        // Act\n+        long start = System.currentTimeMillis();\n+        Document doc = Parser.parseBodyFragment(longBody.toString(), \"\");\n+        \n+        // Assert\n+        assertEquals(50000, doc.body().childNodeSize());\n+        assertTrue(System.currentTimeMillis() - start < 1000);\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n-import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(\"div\", doc.select(\"div[k\" + s + \"]\").first().tagName());\n         assertEquals(\"div\", doc.select(\"div:containsOwn(\" + s + \")\").first().tagName());\n     }\n+    \n+    @Test\n+    public void selectClassWithSpace() {\n+        final String html = \"<div class=\\\"value\\\">class without space</div>\\n\"\n+                          + \"<div class=\\\"value \\\">class with space</div>\";\n+        \n+        Document doc = Jsoup.parse(html);\n+        \n+        Elements found = doc.select(\"div[class=value ]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value \\\"]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value\\\\ \\\"]\");\n+        assertEquals(0, found.size());\n+    }\n+    \n }", "timestamp": 1427667425, "metainfo": ""}