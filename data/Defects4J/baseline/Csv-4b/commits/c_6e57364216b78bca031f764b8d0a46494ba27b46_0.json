{"sha": "6e57364216b78bca031f764b8d0a46494ba27b46", "log": "Rename \"encapsulator\" to \"quoteChar\" so we have quoteChar and quotePolicy. Encapsulator makes me want to ask \"encapsulate what\"? fieldEncapsulator would be better but so verbose, quoteChar feels more to the point to me and provides symmetry with quotePolicy.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private static final long serialVersionUID = 1L;\n \n     private final char delimiter;\n-    private final Character encapsulator;\n+    private final Character quoteChar;\n+    private final Quote quotePolicy;\n     private final Character commentStart;\n     private final Character escape;\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n     private final boolean ignoreEmptyLines;\n     private final String lineSeparator; // for outputs\n     private final String[] header;\n-    private final Quote quotePolicy;\n \n     /**\n      * Starting format; used for creating other formats.\n      *\n      * @param delimiter\n      *            the char used for value separation\n-     * @param encapsulator\n+     * @param quoteChar\n      *            the char used as value encapsulation marker\n      * @param quotePolicy \n      *            the quote policy\n                     boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator, \n             final String[] header) {\n         this.delimiter = delimiter;\n-        this.encapsulator = encapsulator;\n+        this.quoteChar = encapsulator;\n         this.quotePolicy = quotePolicy;\n         this.commentStart = commentStart;\n         this.escape = escape;\n      * @throws IllegalStateException\n      */\n     void validate() throws IllegalStateException {\n-        if (encapsulator != null && delimiter == encapsulator) {\n-            throw new IllegalStateException(\"The encapsulator character and the delimiter cannot be the same ('\" + encapsulator + \"')\");\n+        if (quoteChar != null && delimiter == quoteChar) {\n+            throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n         }\n \n         if (escape != null && delimiter == escape) {\n                     \"')\");\n         }\n \n-        if (encapsulator != null && encapsulator == commentStart) {\n-            throw new IllegalStateException(\"The comment start character and the encapsulator cannot be the same ('\" + commentStart + \n+        if (quoteChar != null && quoteChar == commentStart) {\n+            throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \n                     \"')\");\n         }\n \n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n      * Returns the character used to encapsulate values containing special characters.\n      *\n-     * @return the encapsulator character\n-     */\n-    public Character getEncapsulator() {\n-        return encapsulator;\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified encapsulator character.\n-     *\n-     * @param encapsulator\n-     *            the encapsulator character\n-     * @return A copy of this format using the specified encapsulator character\n+     * @return the quoteChar character\n+     */\n+    public Character getQuoteChar() {\n+        return quoteChar;\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified quoteChar character.\n+     *\n+     * @param quoteChar\n+     *            the quoteChar character\n+     * @return A copy of this format using the specified quoteChar character\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n     }\n \n     /**\n-     * Returns a copy of this format using the specified encapsulator character.\n-     *\n-     * @param encapsulator\n-     *            the encapsulator character\n-     * @return A copy of this format using the specified encapsulator character\n+     * Returns a copy of this format using the specified quoteChar character.\n+     *\n+     * @param quoteChar\n+     *            the quoteChar character\n+     * @return A copy of this format using the specified quoteChar character\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n     public CSVFormat withEncapsulator(final Character encapsulator) {\n         if (isLineBreak(encapsulator)) {\n-            throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n+            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n-     * Returns whether an encapsulator has been defined.\n-     *\n-     * @return {@code true} if an encapsulator is defined\n+     * Returns whether an quoteChar has been defined.\n+     *\n+     * @return {@code true} if an quoteChar is defined\n      */\n     public boolean isEncapsulating() {\n-        return encapsulator != null;\n+        return quoteChar != null;\n     }\n \n     /**\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n      * @return A copy of this format with the specified empty line skipping behavior.\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(final char lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, String.valueOf(lineSeparator), header);\n     }\n \n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(final String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n         }\n         if (isEncapsulating()) {\n             sb.append(' ');\n-            sb.append(\"Encapsulator=<\").append(encapsulator).append('>');\n+            sb.append(\"Encapsulator=<\").append(quoteChar).append('>');\n         }\n         if (isCommentingEnabled()) {\n             sb.append(' ');\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         printDelimiter();\n \n         final char delim = format.getDelimiter();\n-        final char encapsulator = format.getEncapsulator();\n+        final char encapsulator = format.getQuoteChar();\n \n         if (len <= 0) {\n             // always quote an empty token that is the first\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         this.in = in;\n         this.delimiter = format.getDelimiter();\n         this.escape = mapNullToDisabled(format.getEscape());\n-        this.encapsulator = mapNullToDisabled(format.getEncapsulator());\n+        this.encapsulator = mapNullToDisabled(format.getQuoteChar());\n         this.commmentStart = mapNullToDisabled(format.getCommentStart());\n         this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n         format.withQuotePolicy(Quote.ALL);\n \n         assertEquals('!', format.getDelimiter());\n-        assertEquals('!', format.getEncapsulator().charValue());\n+        assertEquals('!', format.getQuoteChar().charValue());\n         assertEquals('!', format.getCommentStart().charValue());\n         assertEquals('!', format.getEscape().charValue());\n         assertEquals(CRLF, format.getLineSeparator());\n         final CSVFormat format = new CSVFormat('!', '!', null, '!', '!', true, true, CRLF, null);\n \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n-        assertEquals('?', format.withEncapsulator('?').getEncapsulator().charValue());\n+        assertEquals('?', format.withEncapsulator('?').getQuoteChar().charValue());\n         assertEquals('?', format.withCommentStart('?').getCommentStart().charValue());\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n         assertEquals('?', format.withEscape('?').getEscape().charValue());\n \n         assertNotNull(format);\n         assertEquals(\"delimiter\", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());\n-        assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getEncapsulator(), format.getEncapsulator());\n+        assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getQuoteChar(), format.getQuoteChar());\n         assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());\n         assertEquals(\"line separator\", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());\n         assertEquals(\"escape\", CSVFormat.DEFAULT.getEscape(), format.getEscape());\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n                 //noop: tkn.content.append(\"\");\n                 tkn.type = EORECORD;\n                 tkn.isReady = true;\n-            } else if (c == format.getEncapsulator()) {\n+            } else if (c == format.getQuoteChar()) {\n                 // consume encapsulated token\n                 encapsulatedTokenLexer(tkn, c);\n             } else if (isEndOfFile(c)) {\n \n             if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape());\n-            } else if (c == format.getEncapsulator()) {\n-                if (in.lookAhead() == format.getEncapsulator()) {\n+            } else if (c == format.getQuoteChar()) {\n+                if (in.lookAhead() == format.getQuoteChar()) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n                     c = in.read();\n                     tkn.content.append((char) c);", "timestamp": 1350190610, "metainfo": ""}