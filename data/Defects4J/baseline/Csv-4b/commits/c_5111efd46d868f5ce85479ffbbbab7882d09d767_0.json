{"sha": "5111efd46d868f5ce85479ffbbbab7882d09d767", "log": "Add direct lexer tests  ", "commit": "\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Basic test harness.\n- * \n+ *\n  * Requires test file to be downloaded separately.\n- * \n+ *\n  */\n @SuppressWarnings(\"boxing\")\n public class PerformanceTest {\n \n     private static final String[] PROPS = {\n-        \"java.version\",                  // Java Runtime Environment version \n-        \"java.vendor\",                   // Java Runtime Environment vendor \n-//        \"java.vm.specification.version\", // Java Virtual Machine specification version \n-//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor \n-//        \"java.vm.specification.name\",    // Java Virtual Machine specification name \n-        \"java.vm.version\",               // Java Virtual Machine implementation version \n-//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor \n-        \"java.vm.name\",                  // Java Virtual Machine implementation name \n-//        \"java.specification.version\",    // Java Runtime Environment specification version \n-//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor \n-//        \"java.specification.name\",       // Java Runtime Environment specification name \n-\n-        \"os.name\",                       // Operating system name \n-        \"os.arch\",                       // Operating system architecture \n-        \"os.version\",                    // Operating system version \n- \n+        \"java.version\",                  // Java Runtime Environment version\n+        \"java.vendor\",                   // Java Runtime Environment vendor\n+//        \"java.vm.specification.version\", // Java Virtual Machine specification version\n+//        \"java.vm.specification.vendor\",  // Java Virtual Machine specification vendor\n+//        \"java.vm.specification.name\",    // Java Virtual Machine specification name\n+        \"java.vm.version\",               // Java Virtual Machine implementation version\n+//        \"java.vm.vendor\",                // Java Virtual Machine implementation vendor\n+        \"java.vm.name\",                  // Java Virtual Machine implementation name\n+//        \"java.specification.version\",    // Java Runtime Environment specification version\n+//        \"java.specification.vendor\",     // Java Runtime Environment specification vendor\n+//        \"java.specification.name\",       // Java Runtime Environment specification name\n+\n+        \"os.name\",                       // Operating system name\n+        \"os.arch\",                       // Operating system architecture\n+        \"os.version\",                    // Operating system version\n+\n     };\n-    \n+\n     private static int max = 10;\n \n     private static int num = 0; // number of elapsed times recorded\n     private static long[] elapsedTimes = new long[max];\n-    \n+\n     private static final CSVFormat format = CSVFormat.EXCEL;\n \n     public static void main(String [] args) throws Exception {\n                 tests[i-1]=args[i];\n             }\n         } else {\n-            tests=new String[]{\"file\", \"split\", \"extb\", \"exts\", \"csv\"};\n+            tests=new String[]{\"file\", \"split\", \"extb\", \"exts\", \"csv\", \"lexreset\", \"lexnew\"};\n         }\n         for(String p : PROPS) {\n-            System.out.println(p+\"=\"+System.getProperty(p));            \n+            System.out.println(p+\"=\"+System.getProperty(p));\n         }\n         System.out.println(\"Max count: \"+max+\"\\n\");\n \n         for(String test : tests) {\n             if (\"file\".equals(test)) {\n-                testReadBigFile(false);                \n+                testReadBigFile(false);\n             } else if (\"split\".equals(test)) {\n-                testReadBigFile(true);                \n+                testReadBigFile(true);\n             } else if (\"csv\".equals(test)) {\n-                testParseCommonsCSV();                \n+                testParseCommonsCSV();\n+            } else if (\"lexreset\".equals(test)) {\n+                testCSVLexer(false, test);\n+            } else if (\"lexnew\".equals(test)) {\n+                testCSVLexer(true, test);\n             } else if (\"extb\".equals(test)) {\n-                testExtendedBuffer(false);                \n+                testExtendedBuffer(false);\n             } else if (\"exts\".equals(test)) {\n-                testExtendedBuffer(true);                \n+                testExtendedBuffer(true);\n             }\n         }\n     }\n                    } else if (read == '\\n') {\n                        lines++;\n                    }\n-               }               \n+               }\n            }\n            fields += lines; // EOL is a delimiter too\n            in.close();\n            Stats s = iterate(parser);\n            reader.close();\n            show(\"CSV\", s, t0);\n+       }\n+       show();\n+   }\n+\n+   private static void testCSVLexer(final boolean newToken, String test) throws Exception {\n+       Token token = new Token();\n+       for (int i = 0; i < max; i++) {\n+           final BufferedReader reader = getReader();\n+           Lexer lexer = new CSVLexer(format, new ExtendedBufferedReader(reader));\n+           int count = 0;\n+           int fields = 0;\n+           long t0 = System.currentTimeMillis();\n+           do {\n+               if (newToken) {\n+                   token = new Token();\n+               } else {\n+                   token.reset();\n+               }\n+               lexer.nextToken(token);\n+               switch(token.type) {\n+               case EOF:\n+                   break;\n+               case EORECORD:\n+                   fields++;\n+                   count++;\n+                   break;\n+               case INVALID:\n+                   throw new IOException(\"invalid parse sequence\");\n+               case TOKEN:\n+                   fields++;\n+                   break;\n+              }\n+\n+           } while (!token.type.equals(Token.Type.EOF));\n+           Stats s = new Stats(count, fields);\n+           reader.close();\n+           show(test, s, t0);\n        }\n        show();\n    }", "timestamp": 1332412151, "metainfo": ""}