{"sha": "67bbc35289bb3435eae0bd6f20cc6b15280e66e0", "log": "Rename ivars that were in the past tense to use the imperative style.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final char encapsulator;\n     private final char commentStart;\n     private final char escape;\n-    private final boolean surroundingSpacesIgnored; // Should leading/trailing spaces be ignored around values?\n-    private final boolean emptyLinesIgnored;\n+    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+    private final boolean ignoreEmptyLines;\n     private final String lineSeparator; // for outputs\n     private final String[] header;\n \n             PRISTINE.\n             withDelimiter(COMMA)\n             .withEncapsulator(DOUBLE_QUOTE)\n-            .withEmptyLinesIgnored(true)\n+            .withIgnoreEmptyLines(true)\n             .withLineSeparator(CRLF);\n \n     /**\n             PRISTINE\n             .withDelimiter(TAB)\n             .withEncapsulator(DOUBLE_QUOTE)\n-            .withSurroundingSpacesIgnored(true)\n-            .withEmptyLinesIgnored(true)\n+            .withIgnoreSurroundingSpaces(true)\n+            .withIgnoreEmptyLines(true)\n             .withLineSeparator(CRLF);\n \n     /**\n      *            the char used for comment identification\n      * @param escape\n      *            the char used to escape special characters in values\n-     * @param surroundingSpacesIgnored\n+     * @param ignoreSurroundingSpaces\n      *            <tt>true</tt> when whitespaces enclosing values should be ignored\n-     * @param emptyLinesIgnored\n+     * @param ignoreEmptyLines\n      *            <tt>true</tt> when the parser should skip empty lines\n      * @param lineSeparator\n      *            the line separator to use for output\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n         this.escape = escape;\n-        this.surroundingSpacesIgnored = surroundingSpacesIgnored;\n-        this.emptyLinesIgnored = emptyLinesIgnored;\n+        this.ignoreSurroundingSpaces = surroundingSpacesIgnored;\n+        this.ignoreEmptyLines = emptyLinesIgnored;\n         this.lineSeparator = lineSeparator;\n         this.header = header;\n         this.isEncapsulating = encapsulator != DISABLED;\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n         if (isLineBreak(encapsulator)) {\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n      * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n      *         value.\n      */\n-    public boolean isSurroundingSpacesIgnored() {\n-        return surroundingSpacesIgnored;\n+    public boolean getIgnoreSurroundingSpaces() {\n+        return ignoreSurroundingSpaces;\n     }\n \n     /**\n      * Returns a copy of this format with the specified trimming behavior.\n      *\n-     * @param surroundingSpacesIgnored\n+     * @param ignoreSurroundingSpaces\n      *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n      *            spaces as is.\n      * @return A copy of this format with the specified trimming behavior.\n      */\n-    public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+    public CSVFormat withIgnoreSurroundingSpaces(boolean ignoreSurroundingSpaces) {\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n      * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n      *         records.\n      */\n-    public boolean isEmptyLinesIgnored() {\n-        return emptyLinesIgnored;\n+    public boolean getIgnoreEmptyLines() {\n+        return ignoreEmptyLines;\n     }\n \n     /**\n      * Returns a copy of this format with the specified empty line skipping behavior.\n      *\n-     * @param emptyLinesIgnored\n+     * @param ignoreEmptyLines\n      *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n      *            <tt>false</tt> to translate empty lines to empty records.\n      * @return A copy of this format with the specified empty line skipping behavior.\n      */\n-    public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+    public CSVFormat withIgnoreEmptyLines(boolean ignoreEmptyLines) {\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     String[] getHeader() {\n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(String... header) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n-                emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, lineSeparator, header);\n     }\n \n     /**\n             sb.append(' ');\n             sb.append(\"CommentStart=<\").append(commentStart).append('>');\n         }\n-        if (isEmptyLinesIgnored()) {\n+        if (getIgnoreEmptyLines()) {\n             sb.append(\" EmptyLines:ignored\");\n         }\n-        if (isSurroundingSpacesIgnored()) {\n+        if (getIgnoreSurroundingSpaces()) {\n             sb.append(\" SurroundingSpaces:ignored\");\n         }\n         return sb.toString();\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         this.escape = format.getEscape();\n         this.encapsulator = format.getEncapsulator();\n         this.commmentStart = format.getCommentStart();\n-        this.surroundingSpacesIgnored = format.isSurroundingSpacesIgnored();\n-        this.emptyLinesIgnored = format.isEmptyLinesIgnored();\n+        this.surroundingSpacesIgnored = format.getIgnoreSurroundingSpaces();\n+        this.emptyLinesIgnored = format.getIgnoreEmptyLines();\n     }\n \n     int getLineNumber() {\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n             final String option = split[i];\n             String[] option_parts = option.split(\"=\",2);\n             if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n-                fmt = fmt.withEmptyLinesIgnored(Boolean.parseBoolean(option_parts[1]));\n+                fmt = fmt.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n-                fmt = fmt.withSurroundingSpacesIgnored(Boolean.parseBoolean(option_parts[1]));\n+                fmt = fmt.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n                 fmt = fmt.withCommentStart(option_parts[1].charAt(0));\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n         format.withCommentStart('?');\n         format.withLineSeparator(\"?\");\n         format.withEscape('?');\n-        format.withSurroundingSpacesIgnored(false);\n-        format.withEmptyLinesIgnored(false);\n+        format.withIgnoreSurroundingSpaces(false);\n+        format.withIgnoreEmptyLines(false);\n \n         assertEquals('!', format.getDelimiter());\n         assertEquals('!', format.getEncapsulator());\n         assertEquals('!', format.getEscape());\n         assertEquals(CSVFormat.CRLF, format.getLineSeparator());\n \n-        assertTrue(format.isSurroundingSpacesIgnored());\n-        assertTrue(format.isEmptyLinesIgnored());\n+        assertTrue(format.getIgnoreSurroundingSpaces());\n+        assertTrue(format.getIgnoreEmptyLines());\n     }\n \n     @Test\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n         assertEquals('?', format.withEscape('?').getEscape());\n \n-        assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored());\n-        assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());\n+        assertFalse(format.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n+        assertFalse(format.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n     }\n \n     @Test\n         assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());\n         assertEquals(\"line separator\", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());\n         assertEquals(\"escape\", CSVFormat.DEFAULT.getEscape(), format.getEscape());\n-        assertEquals(\"trim\", CSVFormat.DEFAULT.isSurroundingSpacesIgnored(), format.isSurroundingSpacesIgnored());\n-        assertEquals(\"empty lines\", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());\n+        assertEquals(\"trim\", CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces());\n+        assertEquals(\"empty lines\", CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines());\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n         c = in.readAgain();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n-        if (format.isEmptyLinesIgnored()) {\n+        if (format.getIgnoreEmptyLines()) {\n             while (eol\n                     && (lastChar == '\\n' || lastChar == '\\r' || lastChar == ExtendedBufferedReader.UNDEFINED)\n                     && !isEndOfFile(lastChar)) {\n         //  important: make sure a new char gets consumed in each iteration\n         while (!tkn.isReady && tkn.type != EOF) {\n             // ignore whitespaces at beginning of a token\n-            if (format.isSurroundingSpacesIgnored()) {\n+            if (format.getIgnoreSurroundingSpaces()) {\n                 while (isWhitespace(c) && !eol) {\n                     wsBuf.append((char) c);\n                     c = in.read();\n             } else {\n                 // next token must be a simple token\n                 // add removed blanks when not ignoring whitespace chars...\n-                if (!format.isSurroundingSpacesIgnored()) {\n+                if (!format.getIgnoreSurroundingSpaces()) {\n                     tkn.content.append(wsBuf);\n                 }\n                 simpleTokenLexer(tkn, c);\n             c = in.read();\n         }\n \n-        if (format.isSurroundingSpacesIgnored()) {\n+        if (format.getIgnoreSurroundingSpaces()) {\n             trimTrailingSpaces(tkn.content);\n         }\n \n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n     @Test\n     public void testNextToken1() throws IOException {\n         String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n                 \"\\n\"+\n                 \"# Final comment\\n\";       // 7\n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        assertTrue(\"Should ignore empty lines\", format.isEmptyLinesIgnored());\n+        assertTrue(\"Should ignore empty lines\", format.getIgnoreEmptyLines());\n \n         Lexer parser = getLexer(code, format);\n \n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withEmptyLinesIgnored(false);\n-        assertFalse(\"Should not ignore empty lines\", format.isEmptyLinesIgnored());\n+        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n+        assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n         Lexer parser = getLexer(code, format);\n \n         *       \\,,\n         */\n         String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n-        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withEmptyLinesIgnored(false);\n+        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withIgnoreEmptyLines(false);\n         assertTrue(format.isEscaping());\n         Lexer parser = getLexer(code, format);\n \n         *        a,  \" foo \" ,b\n         */\n         String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         for (String[] re : RESULT) {\n             assertArrayEquals(re, parser.getRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n \n \n         CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\\'').withEscape('/')\n-                               .withEmptyLinesIgnored(true).withLineSeparator(CSVFormat.CRLF);\n+                               .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();\n \n \n         CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEscape('/')\n-                .withEmptyLinesIgnored(true).withLineSeparator(CSVFormat.CRLF);\n+                .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n     }\n \n     private long parse(Reader in) throws IOException {\n-        CSVFormat format = CSVFormat.DEFAULT.withSurroundingSpacesIgnored(false);\n+        CSVFormat format = CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false);\n         long count = 0;\n         for (Object record : format.parse(in)) {\n             count++;", "timestamp": 1349966363, "metainfo": ""}