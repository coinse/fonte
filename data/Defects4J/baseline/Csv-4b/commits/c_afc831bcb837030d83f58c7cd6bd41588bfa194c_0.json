{"sha": "afc831bcb837030d83f58c7cd6bd41588bfa194c", "log": "Optimized ExtendedBufferedReader as suggested by Bob Smith in CSV-42 (improves the performance by 30%)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n     /** Undefined state for the lookahead char */\n     static final int UNDEFINED = -2;\n \n-    /** The lookahead chars */\n-    private int lookaheadChar = UNDEFINED;\n-\n     /** The last char returned */\n     private int lastChar = UNDEFINED;\n \n     /** The line counter */\n     private int lineCounter = 0;\n \n-    private CharBuffer line = new CharBuffer();\n-\n     /**\n      * Created extended buffered reader using default buffer-size\n      */\n     ExtendedBufferedReader(Reader r) {\n         super(r);\n-        /* note uh: do not fetch the first char here,\n-        *          because this might block the method!\n-        */\n     }\n \n-    /**\n-     * Reads the next char from the input stream.\n-     *\n-     * @return the next char or END_OF_STREAM if end of stream has been reached.\n-     */\n     @Override\n     public int read() throws IOException {\n-        // initialize the lookahead\n-        if (lookaheadChar == UNDEFINED) {\n-            lookaheadChar = super.read();\n-        }\n-        lastChar = lookaheadChar;\n-        if (super.ready()) {\n-            lookaheadChar = super.read();\n-        } else {\n-            lookaheadChar = UNDEFINED;\n-        }\n+        lastChar = super.read();\n+\n         if (lastChar == '\\n') {\n             lineCounter++;\n         }\n     }\n \n     /**\n-     * Returns the last read character again.\n-     *\n-     * @return the last read char or UNDEFINED\n+     * Returns the last character that was read as an integer (0 to 65535). This\n+     * will be the last character returned by any of the read methods. This will\n+     * not include a character read using the {@link #peek()} method. If no\n+     * character has been read then this will return {@link #UNDEFINED}. If the\n+     * end of the stream was reached on the last read then this will return\n+     * {@link #END_OF_STREAM}.\n+     * \n+     * @return the last character that was read\n      */\n     int readAgain() {\n         return lastChar;\n     }\n \n-    /**\n-     * Non-blocking reading of len chars into buffer buf starting\n-     * at bufferposition off.\n-     * <p/>\n-     * performs an iterative read on the underlying stream\n-     * as long as the following conditions hold:\n-     * - less than len chars have been read\n-     * - end of stream has not been reached\n-     * - next read is not blocking\n-     *\n-     * @return nof chars actually read or END_OF_STREAM\n-     */\n     @Override\n     public int read(char[] buf, int off, int len) throws IOException {\n-        // do not claim if len == 0\n         if (len == 0) {\n             return 0;\n         }\n-\n-        // init lookahead, but do not block !!\n-        if (lookaheadChar == UNDEFINED) {\n-            if (ready()) {\n-                lookaheadChar = super.read();\n-            } else {\n-                return -1;\n-            }\n-        }\n-        // 'first read of underlying stream'\n-        if (lookaheadChar == -1) {\n-            return -1;\n-        }\n-        // continue until the lookaheadChar would block\n-        int cOff = off;\n-        while (len > 0 && ready()) {\n-            if (lookaheadChar == -1) {\n-                // eof stream reached, do not continue\n-                return cOff - off;\n-            } else {\n-                buf[cOff++] = (char) lookaheadChar;\n-                if (lookaheadChar == '\\n') {\n+        \n+        int l = super.read(buf, off, len);\n+        \n+        if (l > 0) {\n+            lastChar = buf[off + l - 1];\n+            \n+            for (int i = off; i < off + l; i++) {\n+                if (buf[i] == '\\n') {\n                     lineCounter++;\n                 }\n-                lastChar = lookaheadChar;\n-                lookaheadChar = super.read();\n-                len--;\n             }\n+            \n+        } else if (l == -1) {\n+            lastChar = END_OF_STREAM;\n         }\n-        return cOff - off;\n+        \n+        return l;\n+    }\n+\n+    @Override\n+    public String readLine() throws IOException {\n+        String line = super.readLine();\n+\n+        if (line != null) {\n+            if (line.length() > 0) {\n+                lastChar = line.charAt(line.length() - 1);\n+            }\n+            lineCounter++;\n+        } else {\n+            lastChar = END_OF_STREAM;\n+        }\n+\n+        return line;\n     }\n \n     /**\n-     * @return A String containing the contents of the line, not\n-     *         including any line-termination characters, or null\n-     *         if the end of the stream has been reached\n-     */\n-    @Override\n-    public String readLine() throws IOException {\n-\n-        if (lookaheadChar == UNDEFINED) {\n-            lookaheadChar = super.read();\n-        }\n-\n-        line.clear(); //reuse\n-\n-        // return null if end of stream has been reached\n-        if (lookaheadChar == END_OF_STREAM) {\n-            return null;\n-        }\n-        // do we have a line termination already\n-        char laChar = (char) lookaheadChar;\n-        if (laChar == '\\n' || laChar == '\\r') {\n-            lastChar = lookaheadChar;\n-            lookaheadChar = super.read();\n-            // ignore '\\r\\n' as well\n-            if ((char) lookaheadChar == '\\n') {\n-                lastChar = lookaheadChar;\n-                lookaheadChar = super.read();\n-            }\n-            lineCounter++;\n-            return line.toString();\n-        }\n-\n-        // create the rest-of-line return and update the lookahead\n-        line.append(laChar);\n-        String restOfLine = super.readLine(); // TODO involves copying\n-        lastChar = lookaheadChar;\n-        lookaheadChar = super.read();\n-        if (restOfLine != null) {\n-            line.append(restOfLine);\n-        }\n-        lineCounter++;\n-        return line.toString();\n-    }\n-\n-    /**\n-     * Unsupported\n-     */\n-    @Override\n-    public long skip(long n) throws IllegalArgumentException, IOException {\n-        throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n-    }\n-\n-    /**\n-     * Returns the next char in the stream without consuming it.\n-     *\n-     * Remember the next char read by read(..) will always be\n-     * identical to lookAhead().\n-     *\n-     * @return the next char (without consuming it) or END_OF_STREAM\n+     * Returns the next character in the current reader without consuming it. So\n+     * the next call to {@link #read()} will still return this value.\n+     * \n+     * @return the next character\n+     * \n+     * @throws IOException if there is an error in reading\n      */\n     int lookAhead() throws IOException {\n-        if (lookaheadChar == UNDEFINED) {\n-            lookaheadChar = super.read();\n-        }\n-        return lookaheadChar;\n+        super.mark(1);\n+        int c = super.read();\n+        super.reset();\n+\n+        return c;\n     }\n-\n \n     /**\n      * Returns the nof line read\n      * @return the current-line-number (or -1)\n      */\n     int getLineNumber() {\n-        return lineCounter > -1 ? lineCounter : -1;\n+        return lineCounter;\n     }\n-\n-    /**\n-     * Unsupported.\n-     * @throws UnsupportedOperationException if invoked\n-     */\n-    @Override\n-    public boolean markSupported() {\n-        throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n-    }\n-\n }", "timestamp": 1331549235, "metainfo": ""}