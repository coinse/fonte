{"sha": "112774edae824e6e07ed9d64f637b4b7c19cea3b", "log": "Now implements Iterator   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.12 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.13 2002/04/28 04:36:27 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/04/28 04:36:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * An XPath evaluation context.\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.13 $ $Date: 2002/04/28 04:36:27 $\n  */\n-public abstract class EvalContext implements ExpressionContext {\n+public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n     protected RootContext rootContext;\n     protected int position = 0;\n     private boolean startedSetIteration = false;\n+    private boolean done = false;\n \n     public EvalContext(EvalContext parentContext){\n         this.parentContext = parentContext;\n         return position;\n     }\n \n+    /**\n+     * Returns true if there are mode nodes matching the context's constraints.\n+     */\n+    public boolean hasNext(){\n+        if (done){\n+            return false;\n+        }\n+        if (position == 0){\n+            while (nextSet()){\n+                if (nextNode()){\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns the next node pointer in the context\n+     */\n+    public Object next(){\n+        if (done || (position == 0 && !hasNext())){\n+            throw new NoSuchElementException();\n+        }\n+        NodePointer pointer = getCurrentNodePointer();\n+        if (!nextNode()){\n+            done = true;\n+            while (nextSet()){\n+                if (nextNode()){\n+                    done = false;\n+                    break;\n+                }\n+            }\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * Operation is not supported\n+     */\n+    public void remove(){\n+        throw new UnsupportedOperationException(\n+            \"JXPath iterators cannot remove nodes\");\n+    }\n+    \n     /**\n      * Returns the list of all Pointers in this context\n      */\n             reset();\n         }\n         List list = new ArrayList();\n-        while (next()) {\n+        while (nextNode()) {\n             list.add(getCurrentNodePointer());\n         }\n         if (pos != 0) {\n         }\n         List list = new ArrayList();\n         while (nextSet()){\n-            while (next()) {\n+            while (nextNode()) {\n                 list.add(getCurrentNodePointer());\n             }\n         }\n         }\n         List list = new ArrayList();\n         while (nextSet()){\n-            while (next()) {\n+            while (nextNode()) {\n                 list.add(getCurrentNodePointer().getValue());\n             }\n         }\n     }\n \n     /**\n-     * If the iteration has not started yet, starts the iteration and\n-     * returns the first encountered Pointer that matches the current\n-     * step's criteria.  Otherwise, returns the current pointer.\n+     * Returns the first encountered Pointer that matches the current\n+     * context's criteria.\n      */\n     public Pointer getSingleNodePointer(){\n         reset();\n         while(nextSet()){\n-            if (next()){\n+            if (nextNode()){\n                 return getCurrentNodePointer();\n             }\n         }\n         if (!startedSetIteration) {\n             startedSetIteration = true;\n             while (parentContext.nextSet()) {\n-                if (parentContext.next()) {\n+                if (parentContext.nextNode()) {\n                     return true;\n                 }\n             }\n \n         // In subsequent calls, we see if the parent context\n         // has any nodes left in the current set\n-        if (parentContext.next()) {\n+        if (parentContext.nextNode()) {\n             return true;\n         }\n \n         // If not, we look for the next set that contains\n         // at least one node\n         while (parentContext.nextSet()) {\n-            if (parentContext.next()) {\n+            if (parentContext.nextNode()) {\n                 return true;\n             }\n         }\n      * Returns true if there is another object in the current set.\n      * Switches the current position and node to the next object.\n      */\n-    public abstract boolean next();\n+    public abstract boolean nextNode();\n \n     /**\n      * Moves the current position to the specified index. Used with integer\n     public Object eval(Expression expression){\n         return eval(expression, true);\n     }\n-\n+    \n+    public Iterator iterate(Expression expression){\n+        Object result = eval(expression, false);\n+        if (result instanceof EvalContext){\n+            return new ValueIterator((EvalContext)result);\n+        }\n+        return ValueUtils.iterate(result);\n+    }\n+    \n+    public Iterator iteratePointers(Expression expression){\n+        Object result = eval(expression, false);\n+        if (result == null){\n+            return Collections.EMPTY_LIST.iterator();\n+        }\n+        if (result instanceof EvalContext){\n+            return (EvalContext)result;\n+        }\n+        return new PointerIterator(ValueUtils.iterate(result), \n+                    new QName(null, \"value\"), \n+                    getRootContext().getCurrentNodePointer().getLocale());\n+    }\n+    \n     /**\n      * Evaluates the expression. If the result is a node set, returns\n      * the whole set if firstMatch==false or the first element otherwise.\n      */\n-    public Object eval(Expression expression, boolean firstMatch){\n+    private Object eval(Expression expression, boolean firstMatch){\n         Object value = null;\n         switch (expression.getEvaluationMode()){\n             case Expression.EVALUATION_MODE_ONCE:\n             return coreFunction((CoreFunction)expression);\n \n         case Expression.OP_LOCATION_PATH:\n-            return path((LocationPath)expression, firstMatch);\n+            if (firstMatch){\n+                return getSingleNodePointerForPath((LocationPath)expression);\n+            }\n+            else {\n+                return path((LocationPath)expression);\n+            }\n \n         case Expression.OP_EXPRESSION_PATH:\n             return expressionPath((ExpressionPath)expression, firstMatch);\n     private Set valueSet(){\n         HashSet set = new HashSet();\n         while(nextSet()){\n-            while(next()){\n+            while(nextNode()){\n                 NodePointer pointer = getCurrentNodePointer();\n                 set.add(pointer.getValue());\n             }\n         }\n         else if (object instanceof EvalContext){\n             EvalContext ctx = (EvalContext)object;\n-            return ctx.nextSet() && ctx.next();\n+            return ctx.nextSet() && ctx.nextNode();\n         }\n         else if (object instanceof String){\n             return ((String)object).length() != 0;\n     }\n \n     /**\n-     * Walks a location path\n-     */\n-    protected Object path(LocationPath path, boolean firstMatch){\n-        Step steps[] = path.getSteps();\n-\n+     * Walks a location path and finds a single node that matches the path\n+     */\n+    protected Pointer getSingleNodePointerForPath(LocationPath path) {\n+        // Create a chain of contexts\n+        EvalContext rootContext;\n+        if (path.isAbsolute()) {\n+            rootContext = getRootContext();\n+        }\n+        else {\n+            rootContext = this;\n+        }\n+        return getSingleNodePointerForSteps(\n+                    new InitialContext(rootContext), path);\n+    }\n+    /**\n+     * Walks a location path and returns a context containing all\n+     * nodes matching the path\n+     */\n+    protected EvalContext path(LocationPath path){\n         // Create a chain of contexts\n         EvalContext rootContext;\n         if (path.isAbsolute()){\n         else {\n             rootContext = this;\n         }\n-        return evalSteps(new InitialContext(rootContext), path, firstMatch);\n+        return evalSteps(new InitialContext(rootContext), path);\n     }\n \n     /**\n                 context = new PredicateContext(context, predicates[j]);\n             }\n         }\n-        return evalSteps(context, path, firstMatch);\n-    }\n-\n-    /**\n-     * Given a root context, walks a path therefrom\n-     */\n-    private Object evalSteps(EvalContext context, Path path, boolean firstMatch){\n+        if (firstMatch){\n+            return getSingleNodePointerForSteps(context, path);\n+        }\n+        else {\n+            return evalSteps(context, path);\n+        }\n+    }\n+\n+    /**\n+     * Given a root context, walks a path therefrom and finds the \n+     * pointer to the first element matching the path.\n+     */\n+    private Pointer getSingleNodePointerForSteps(EvalContext context, Path path){\n         Step steps[] = path.getSteps();\n-\n-        if (firstMatch && steps.length != 0){\n-            boolean basic = path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE);\n-            if (basic){\n-                NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n-                return SimplePathInterpreter.interpretPath(this, ptr, steps);\n-            }\n+        if (steps.length == 0){\n+            return context.getSingleNodePointer();\n+        }\n+\n+        if (path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE)){\n+            NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n+            return SimplePathInterpreter.interpretPath(this, ptr, steps);\n+        }\n+        else {\n+            for (int i = 0; i < steps.length; i++){\n+                context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+                Expression predicates[] = steps[i].getPredicates();\n+                if (predicates != null){\n+                    for (int j = 0; j < predicates.length; j++){\n+                        context = new PredicateContext(context, predicates[j]);\n+                    }\n+                }\n+            }\n+    \n+            return context.getSingleNodePointer();\n+        }\n+    }\n+\n+    /**\n+     * Given a root context, walks a path therefrom and builds a context\n+     * that contains all nodes matching the path.\n+     */\n+    private EvalContext evalSteps(EvalContext context, Path path){\n+        Step steps[] = path.getSteps();\n+        if (steps.length == 0){\n+            return context;\n         }\n \n         for (int i = 0; i < steps.length; i++){\n             }\n         }\n \n-        if (firstMatch){\n-            Pointer ptr = context.getSingleNodePointer();\n-//            System.err.println(\"GETTING CTX POINTER: \" + context + \" \" + ptr);\n-            return ptr;\n-        }\n-        else {\n-            return context;\n-        }\n+        return context;\n     }\n \n     /**\n         int old = getCurrentPosition();\n         reset();\n         int count = 0;\n-        while(next()){\n+        while(nextNode()){\n             count++;\n         }\n \n         if (value instanceof EvalContext){\n             EvalContext ctx = (EvalContext)value;\n             while(ctx.nextSet()){\n-                while(ctx.next()){\n+                while(ctx.nextNode()){\n                     count++;\n                 }\n             }\n         Object set = eval(function.getArg1(), false);\n         if (set instanceof EvalContext){\n             EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.next()){\n+            if (ctx.nextSet() && ctx.nextNode()){\n                 String str = ctx.getCurrentNodePointer().getNamespaceURI();\n                 return str == null ? \"\" : str;\n             }\n         Object set = eval(function.getArg1(), false);\n         if (set instanceof EvalContext){\n             EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.next()){\n+            if (ctx.nextSet() && ctx.nextNode()){\n                 return ctx.getCurrentNodePointer().getName().getName();\n             }\n         }\n         Object set = eval(function.getArg1(), false);\n         if (set instanceof EvalContext){\n             EvalContext ctx = (EvalContext)set;\n-            if (ctx.nextSet() && ctx.next()){\n+            if (ctx.nextSet() && ctx.nextNode()){\n                 return ctx.getCurrentNodePointer().getExpandedName().toString();\n             }\n         }\n             double sum = 0.0;\n             EvalContext ctx = (EvalContext)v;\n             while (ctx.nextSet()){\n-                while (ctx.next()){\n+                while (ctx.nextNode()){\n                     sum += doubleValue(ctx.getCurrentNodePointer());\n                 }\n             }\n                 + function);\n         }\n     }\n+    \n+    public static class PointerIterator implements Iterator {\n+        private Iterator iterator;\n+        private QName qname;\n+        private Locale locale;\n+        \n+        public PointerIterator(Iterator it, QName qname, Locale locale){\n+            this.iterator = it;\n+            this.qname = qname;\n+            this.locale = locale;\n+        }\n+        \n+        public boolean hasNext(){\n+            return iterator.hasNext();\n+        }\n+        \n+        public Object next(){\n+            Object o = iterator.next();            \n+            return NodePointer.newNodePointer(qname, o, locale);\n+        }\n+        \n+        public void remove(){\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+    public static class ValueIterator implements Iterator {\n+        private Iterator iterator;\n+        \n+        public ValueIterator(Iterator it){\n+            this.iterator = it;\n+        }\n+        \n+        public boolean hasNext(){\n+            return iterator.hasNext();\n+        }\n+        \n+        public Object next(){\n+            Object o = iterator.next();\n+            if (o instanceof Pointer){\n+                return ((Pointer)o).getValue();\n+            }\n+            return o;\n+        }\n+        \n+        public void remove(){\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n }", "timestamp": 1019968587, "metainfo": ""}