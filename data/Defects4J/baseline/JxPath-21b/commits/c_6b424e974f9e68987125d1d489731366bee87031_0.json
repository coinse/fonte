{"sha": "6b424e974f9e68987125d1d489731366bee87031", "log": "Upgraded to JavaCC 3.0, enabled optimizations   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/parser/ParseException.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/ParseException.java\n-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 2.1 */\n+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */\n package org.apache.commons.jxpath.ri.parser;\n \n /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/SimpleCharStream.java\n+/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 3.0 */\n+package org.apache.commons.jxpath.ri.parser;\n+\n+/**\n+ * An implementation of interface CharStream, where the stream is assumed to\n+ * contain only ASCII characters (without unicode processing).\n+ */\n+\n+public class SimpleCharStream\n+{\n+  public static final boolean staticFlag = false;\n+  int bufsize;\n+  int available;\n+  int tokenBegin;\n+  public int bufpos = -1;\n+  protected int bufline[];\n+  protected int bufcolumn[];\n+\n+  protected int column = 0;\n+  protected int line = 1;\n+\n+  protected boolean prevCharIsCR = false;\n+  protected boolean prevCharIsLF = false;\n+\n+  protected java.io.Reader inputStream;\n+\n+  protected char[] buffer;\n+  protected int maxNextCharInd = 0;\n+  protected int inBuf = 0;\n+\n+  protected void ExpandBuff(boolean wrapAround)\n+  {\n+     char[] newbuffer = new char[bufsize + 2048];\n+     int newbufline[] = new int[bufsize + 2048];\n+     int newbufcolumn[] = new int[bufsize + 2048];\n+\n+     try\n+     {\n+        if (wrapAround)\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           System.arraycopy(buffer, 0, newbuffer,\n+                                             bufsize - tokenBegin, bufpos);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n+           bufcolumn = newbufcolumn;\n+\n+           maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n+        }\n+        else\n+        {\n+           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n+           buffer = newbuffer;\n+\n+           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n+           bufline = newbufline;\n+\n+           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n+           bufcolumn = newbufcolumn;\n+\n+           maxNextCharInd = (bufpos -= tokenBegin);\n+        }\n+     }\n+     catch (Throwable t)\n+     {\n+        throw new Error(t.getMessage());\n+     }\n+\n+\n+     bufsize += 2048;\n+     available = bufsize;\n+     tokenBegin = 0;\n+  }\n+\n+  protected void FillBuff() throws java.io.IOException\n+  {\n+     if (maxNextCharInd == available)\n+     {\n+        if (available == bufsize)\n+        {\n+           if (tokenBegin > 2048)\n+           {\n+              bufpos = maxNextCharInd = 0;\n+              available = tokenBegin;\n+           }\n+           else if (tokenBegin < 0)\n+              bufpos = maxNextCharInd = 0;\n+           else\n+              ExpandBuff(false);\n+        }\n+        else if (available > tokenBegin)\n+           available = bufsize;\n+        else if ((tokenBegin - available) < 2048)\n+           ExpandBuff(true);\n+        else\n+           available = tokenBegin;\n+     }\n+\n+     int i;\n+     try {\n+        if ((i = inputStream.read(buffer, maxNextCharInd,\n+                                    available - maxNextCharInd)) == -1)\n+        {\n+           inputStream.close();\n+           throw new java.io.IOException();\n+        }\n+        else\n+           maxNextCharInd += i;\n+        return;\n+     }\n+     catch(java.io.IOException e) {\n+        --bufpos;\n+        backup(0);\n+        if (tokenBegin == -1)\n+           tokenBegin = bufpos;\n+        throw e;\n+     }\n+  }\n+\n+  public char BeginToken() throws java.io.IOException\n+  {\n+     tokenBegin = -1;\n+     char c = readChar();\n+     tokenBegin = bufpos;\n+\n+     return c;\n+  }\n+\n+  protected void UpdateLineColumn(char c)\n+  {\n+     column++;\n+\n+     if (prevCharIsLF)\n+     {\n+        prevCharIsLF = false;\n+        line += (column = 1);\n+     }\n+     else if (prevCharIsCR)\n+     {\n+        prevCharIsCR = false;\n+        if (c == '\\n')\n+        {\n+           prevCharIsLF = true;\n+        }\n+        else\n+           line += (column = 1);\n+     }\n+\n+     switch (c)\n+     {\n+        case '\\r' :\n+           prevCharIsCR = true;\n+           break;\n+        case '\\n' :\n+           prevCharIsLF = true;\n+           break;\n+        case '\\t' :\n+           column--;\n+           column += (8 - (column & 07));\n+           break;\n+        default :\n+           break;\n+     }\n+\n+     bufline[bufpos] = line;\n+     bufcolumn[bufpos] = column;\n+  }\n+\n+  public char readChar() throws java.io.IOException\n+  {\n+     if (inBuf > 0)\n+     {\n+        --inBuf;\n+\n+        if (++bufpos == bufsize)\n+           bufpos = 0;\n+\n+        return buffer[bufpos];\n+     }\n+\n+     if (++bufpos >= maxNextCharInd)\n+        FillBuff();\n+\n+     char c = buffer[bufpos];\n+\n+     UpdateLineColumn(c);\n+     return (c);\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndColumn\n+   */\n+\n+  public int getColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  /**\n+   * @deprecated \n+   * @see #getEndLine\n+   */\n+\n+  public int getLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public int getEndColumn() {\n+     return bufcolumn[bufpos];\n+  }\n+\n+  public int getEndLine() {\n+     return bufline[bufpos];\n+  }\n+\n+  public int getBeginColumn() {\n+     return bufcolumn[tokenBegin];\n+  }\n+\n+  public int getBeginLine() {\n+     return bufline[tokenBegin];\n+  }\n+\n+  public void backup(int amount) {\n+\n+    inBuf += amount;\n+    if ((bufpos -= amount) < 0)\n+       bufpos += bufsize;\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    available = bufsize = buffersize;\n+    buffer = new char[buffersize];\n+    bufline = new int[buffersize];\n+    bufcolumn = new int[buffersize];\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.Reader dstream)\n+  {\n+     this(dstream, 1, 1, 4096);\n+  }\n+  public void ReInit(java.io.Reader dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+    inputStream = dstream;\n+    line = startline;\n+    column = startcolumn - 1;\n+\n+    if (buffer == null || buffersize != buffer.length)\n+    {\n+      available = bufsize = buffersize;\n+      buffer = new char[buffersize];\n+      bufline = new int[buffersize];\n+      bufcolumn = new int[buffersize];\n+    }\n+    prevCharIsLF = prevCharIsCR = false;\n+    tokenBegin = inBuf = maxNextCharInd = 0;\n+    bufpos = -1;\n+  }\n+\n+  public void ReInit(java.io.Reader dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public void ReInit(java.io.Reader dstream)\n+  {\n+     ReInit(dstream, 1, 1, 4096);\n+  }\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+  int startcolumn, int buffersize)\n+  {\n+     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     this(dstream, startline, startcolumn, 4096);\n+  }\n+\n+  public SimpleCharStream(java.io.InputStream dstream)\n+  {\n+     this(dstream, 1, 1, 4096);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                          int startcolumn, int buffersize)\n+  {\n+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);\n+  }\n+\n+  public void ReInit(java.io.InputStream dstream)\n+  {\n+     ReInit(dstream, 1, 1, 4096);\n+  }\n+  public void ReInit(java.io.InputStream dstream, int startline,\n+                                                           int startcolumn)\n+  {\n+     ReInit(dstream, startline, startcolumn, 4096);\n+  }\n+  public String GetImage()\n+  {\n+     if (bufpos >= tokenBegin)\n+        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n+     else\n+        return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n+                              new String(buffer, 0, bufpos + 1);\n+  }\n+\n+  public char[] GetSuffix(int len)\n+  {\n+     char[] ret = new char[len];\n+\n+     if ((bufpos + 1) >= len)\n+        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n+     else\n+     {\n+        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n+                                                          len - bufpos - 1);\n+        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n+     }\n+\n+     return ret;\n+  }\n+\n+  public void Done()\n+  {\n+     buffer = null;\n+     bufline = null;\n+     bufcolumn = null;\n+  }\n+\n+  /**\n+   * Method to adjust line and column numbers for the start of a token.<BR>\n+   */\n+  public void adjustBeginLineColumn(int newLine, int newCol)\n+  {\n+     int start = tokenBegin;\n+     int len;\n+\n+     if (bufpos >= tokenBegin)\n+     {\n+        len = bufpos - tokenBegin + inBuf + 1;\n+     }\n+     else\n+     {\n+        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n+     }\n+\n+     int i = 0, j = 0, k = 0;\n+     int nextColDiff = 0, columnDiff = 0;\n+\n+     while (i < len &&\n+            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n+     {\n+        bufline[j] = newLine;\n+        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n+        bufcolumn[j] = newCol + columnDiff;\n+        columnDiff = nextColDiff;\n+        i++;\n+     } \n+\n+     if (i < len)\n+     {\n+        bufline[j] = newLine++;\n+        bufcolumn[j] = newCol + columnDiff;\n+\n+        while (i++ < len)\n+        {\n+           if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n+              bufline[j] = newLine++;\n+           else\n+              bufline[j] = newLine;\n+        }\n+     }\n+\n+     line = bufline[j];\n+     column = bufcolumn[j];\n+  }\n+\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/parser/Token.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/Token.java\n-/* Generated By:JavaCC: Do not edit this line. Token.java Version 2.1 */\n+/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */\n package org.apache.commons.jxpath.ri.parser;\n \n /**\n   /**\n    * Returns the image.\n    */\n-  public final String toString()\n+  public String toString()\n   {\n      return image;\n   }\n--- a/src/java/org/apache/commons/jxpath/ri/parser/TokenMgrError.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/TokenMgrError.java\n-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 2.1 *\n+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 *\n  * \n  * !!!MODIFIED BY DMITRI PLOTNIKOV - DO NOT REGENERATE!!!\n  */\n     * Replaces unprintable characters by their espaced (or unicode escaped)\n     * equivalents in the given string\n     */\n-   \n-   // MADE PUBLIC - DMITRI PLOTNIKOV\n    public static final String addEscapes(String str) {\n       StringBuffer retval = new StringBuffer();\n       char ch;\n     *    curchar     : the offending character\n     * Note: You can customize the lexical error message by modifying this method.\n     */\n-   private static final String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n       return(\"Lexical error at line \" +\n            errorLine + \", column \" +\n            errorColumn + \".  Encountered: \" +\n \n    public char getCharacter(){\n     return character;\n-   }   \n+   }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParser.java\n   }\n \n   public XPathParserTokenManager token_source;\n-  JavaCharStream jj_input_stream;\n+  SimpleCharStream jj_input_stream;\n   public Token token, jj_nt;\n   private Token jj_scanpos, jj_lastpos;\n   private int jj_la;\n   private boolean jj_semLA;\n   private int jj_gen;\n   final private int[] jj_la1 = new int[39];\n-  final private int[] jj_la1_0 = {0xf8000000,0x78000000,0x0,0x0,0x78000000,0xf80000c0,0xc0,0x40,0xc0,0xc0,0xf8000000,0xf8000000,0x0,0x0,0x0,0x0,0x160000,0xf8000000,0x0,0xf81604c0,0x100,0xf80000c0,0x0,0xc0,0x8000000,0x10000000,0x1800,0x1800,0x1e000,0x1e000,0x200,0x400,0x60000000,0x60000000,0xf81604c0,0xf8000000,0xf8000000,0x0,0x80000000,};\n-  final private int[] jj_la1_1 = {0xffff0007,0x0,0xffff0000,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xffff0007,0xffffffff,0x0,0xfff8,0xfff8,0x0,0x0,0xffff0007,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xffff0007,0xffff0007,0x0,0x7,};\n-  final private int[] jj_la1_2 = {0x7fff,0x4000,0x3fff,0x8000,0x4000,0x14c7fff,0x0,0x0,0x0,0x0,0x1007fff,0x14c7fff,0x100000,0x0,0x0,0x400000,0x10000,0x7fff,0x800000,0x14d7fff,0x0,0x14c7fff,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x14d7fff,0x1007fff,0x1007fff,0x8000,0x0,};\n+  static private int[] jj_la1_0;\n+  static private int[] jj_la1_1;\n+  static private int[] jj_la1_2;\n+  static {\n+      jj_la1_0();\n+      jj_la1_1();\n+      jj_la1_2();\n+   }\n+   private static void jj_la1_0() {\n+      jj_la1_0 = new int[] {0xf8000000,0x78000000,0x0,0x0,0x78000000,0xf80000c0,0xc0,0x40,0xc0,0xc0,0xf8000000,0xf8000000,0x0,0x0,0x0,0x0,0x160000,0xf8000000,0x0,0xf81604c0,0x100,0xf80000c0,0x0,0xc0,0x8000000,0x10000000,0x1800,0x1800,0x1e000,0x1e000,0x200,0x400,0x60000000,0x60000000,0xf81604c0,0xf8000000,0xf8000000,0x0,0x80000000,};\n+   }\n+   private static void jj_la1_1() {\n+      jj_la1_1 = new int[] {0xffff0007,0x0,0xffff0000,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0xffff0007,0xffffffff,0x0,0xfff8,0xfff8,0x0,0x0,0xffff0007,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0xffff0007,0xffff0007,0x0,0x7,};\n+   }\n+   private static void jj_la1_2() {\n+      jj_la1_2 = new int[] {0x7fff,0x4000,0x3fff,0x8000,0x4000,0x14c7fff,0x0,0x0,0x0,0x0,0x1007fff,0x14c7fff,0x100000,0x0,0x0,0x400000,0x10000,0x7fff,0x800000,0x14d7fff,0x0,0x14c7fff,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x14d7fff,0x1007fff,0x1007fff,0x8000,0x0,};\n+   }\n   final private JJCalls[] jj_2_rtns = new JJCalls[6];\n   private boolean jj_rescan = false;\n   private int jj_gc = 0;\n \n   public XPathParser(java.io.InputStream stream) {\n-    jj_input_stream = new JavaCharStream(stream, 1, 1);\n+    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n     token_source = new XPathParserTokenManager(jj_input_stream);\n     token = new Token();\n     token.next = jj_nt = token_source.getNextToken();\n   }\n \n   public XPathParser(java.io.Reader stream) {\n-    jj_input_stream = new JavaCharStream(stream, 1, 1);\n+    jj_input_stream = new SimpleCharStream(stream, 1, 1);\n     token_source = new XPathParserTokenManager(jj_input_stream);\n     token = new Token();\n     token.next = jj_nt = token_source.getNextToken();\n     }\n   }\n \n-  final public ParseException generateParseException() {\n+  public ParseException generateParseException() {\n     jj_expentries.removeAllElements();\n     boolean[] la1tokens = new boolean[89];\n     for (int i = 0; i < 89; i++) {\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n static final long[] jjtoSkip = {\n    0x3eL, 0x0L, \n };\n-private JavaCharStream input_stream;\n+protected SimpleCharStream input_stream;\n private final int[] jjrounds = new int[13];\n private final int[] jjstateSet = new int[26];\n protected char curChar;\n-public XPathParserTokenManager(JavaCharStream stream)\n-{\n-   if (JavaCharStream.staticFlag)\n+public XPathParserTokenManager(SimpleCharStream stream)\n+{\n+   if (SimpleCharStream.staticFlag)\n       throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n    input_stream = stream;\n }\n-public XPathParserTokenManager(JavaCharStream stream, int lexState)\n+public XPathParserTokenManager(SimpleCharStream stream, int lexState)\n {\n    this(stream);\n    SwitchTo(lexState);\n }\n-public void ReInit(JavaCharStream stream)\n+public void ReInit(SimpleCharStream stream)\n {\n    jjmatchedPos = jjnewStateCnt = 0;\n    curLexState = defaultLexState;\n    for (i = 13; i-- > 0;)\n       jjrounds[i] = 0x80000000;\n }\n-public void ReInit(JavaCharStream stream, int lexState)\n+public void ReInit(SimpleCharStream stream, int lexState)\n {\n    ReInit(stream);\n    SwitchTo(lexState);\n       curLexState = lexState;\n }\n \n-private final Token jjFillToken()\n+protected Token jjFillToken()\n {\n    Token t = Token.newToken(jjmatchedKind);\n    t.kind = jjmatchedKind;\n int jjmatchedPos;\n int jjmatchedKind;\n \n-public final Token getNextToken() \n+public Token getNextToken() \n {\n   int kind;\n   Token specialToken = null;", "timestamp": 1052092139, "metainfo": ""}