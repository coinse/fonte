{"sha": "1a292f1cd08ec2272c3565e0197ec11772db28c0", "log": "javadocs; make relative PI calculation like other relative calcs; more efficient quote escaping; equals-compatible hashCode; all similar to changes on DOMNodePointer  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n     private String id;\n     private NamespaceResolver localNamespaceResolver;\n \n+    /** XML ns uri */\n     public static final String XML_NAMESPACE_URI =\n             \"http://www.w3.org/XML/1998/namespace\";\n+\n+    /** XMLNS ns uri */\n     public static final String XMLNS_NAMESPACE_URI =\n             \"http://www.w3.org/2000/xmlns/\";\n \n+    /**\n+     * Create a new JDOMNodePointer.\n+     * @param node pointed\n+     * @param locale Locale\n+     */\n     public JDOMNodePointer(Object node, Locale locale) {\n         super(null, locale);\n         this.node = node;\n     }\n \n+    /**\n+     * Create a new JDOMNodePointer.\n+     * @param node pointed\n+     * @param locale Locale\n+     * @param id String id\n+     */\n     public JDOMNodePointer(Object node, Locale locale, String id) {\n         super(null, locale);\n         this.node = node;\n         this.id = id;\n     }\n \n+    /**\n+     * Create a new JDOMNodePointer.\n+     * @param parent NodePointer\n+     * @param node pointed\n+     */\n     public JDOMNodePointer(NodePointer parent, Object node) {\n         super(parent);\n         this.node = node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n         return new JDOMNodeIterator(this, test, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return new JDOMAttributeIterator(this, name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator namespaceIterator() {\n         return new JDOMNamespaceIterator(this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer namespacePointer(String prefix) {\n         return new JDOMNamespacePointer(this, prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         return getNamespaceURI(node);\n     }\n \n+    /**\n+     * Get the ns uri of the specified node.\n+     * @param node Node to check\n+     * @return String\n+     */\n     private static String getNamespaceURI(Object node) {\n         if (node instanceof Element) {\n             Element element = (Element) node;\n         return null;\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n+    /**\n+     * {@inheritDoc}\n      */\n     public synchronized NamespaceResolver getNamespaceResolver() {\n         if (localNamespaceResolver == null) {\n         return localNamespaceResolver;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI(String prefix) {\n         if (prefix.equals(\"xml\")) {\n             return Namespace.XML_NAMESPACE.getURI();\n         return ns == null ? null : ns.getURI();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2)\n         return 0;\n     }\n \n-\n-    /**\n-     * @see org.apache.commons.jxpath.ri.model.NodePointer#getBaseValue()\n+    /**\n+     * {@inheritDoc}\n      */\n     public Object getBaseValue() {\n         return node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         if (node instanceof Element) {\n             return ((Element) node).getContent().size() == 0;\n     }\n \n     /**\n-     * @see org.apache.commons.jxpath.ri.model.NodePointer#getName()\n+     * {@inheritDoc}\n      */\n     public QName getName() {\n         String ns = null;\n     }\n \n     /**\n-     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n+     * {@inheritDoc}\n      */\n     public Object getImmediateNode() {\n         return node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         if (node instanceof Element) {\n             StringBuffer buf = new StringBuffer();\n         return result != null && trim ? result.trim() : result;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         if (node instanceof Text) {\n             String string = (String) TypeUtils.convert(value, String.class);\n         }\n     }\n \n+    /**\n+     * Add the specified content to this element.\n+     * @param content List\n+     */\n     private void addContent(List content) {\n         Element element = (Element) node;\n         int count = content.size();\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest test) {\n         return testNode(this, node, test);\n     }\n \n+    /**\n+     * Execute test against node on behalf of pointer. \n+     * @param pointer Pointer\n+     * @param node to test\n+     * @param test to execute\n+     * @return true if node passes test\n+     */\n     public static boolean testNode(\n         NodePointer pointer,\n         Object node,\n         return false;\n     }\n \n+    /**\n+     * Learn whether two strings are == or .equals()\n+     * @param s1 string 1\n+     * @param s2 string 2\n+     * @return true if equal\n+     */\n     private static boolean equalStrings(String s1, String s2) {\n         if (s1 == s2) {\n             return true;\n         return s1.equals(s2);\n     }\n \n+    /**\n+     * Get the prefix from a given node.\n+     * @param node to check\n+     * @return String\n+     */\n     public static String getPrefix(Object node) {\n         if (node instanceof Element) {\n             String prefix = ((Element) node).getNamespacePrefix();\n         return null;\n     }\n \n+    /**\n+     * Get the local name of the specified node.\n+     * @param node to check\n+     * @return String local name\n+     */\n     public static String getLocalName(Object node) {\n         if (node instanceof Element) {\n             return ((Element) node).getName();\n      * Returns true if the xml:lang attribute for the current node\n      * or its parent has the specified prefix <i>lang</i>.\n      * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n+     * @param lang to compare\n+     * @return true if this element uses the specified language.\n      */\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n         return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n+    /**\n+     * Get the language of this element.\n+     * @return String language\n+     */\n     protected String getLanguage() {\n         return findEnclosingAttribute(node, \"lang\", Namespace.XML_NAMESPACE);\n     }\n \n+    /**\n+     * Find the nearest occurrence of the specified attribute\n+     * on the specified and enclosing elements.\n+     * @param n current node\n+     * @param attrName attribute name\n+     * @param ns Namespace\n+     * @return attribute value\n+     */\n     protected static String findEnclosingAttribute(Object n, String attrName, Namespace ns) {\n         while (n != null) {\n             if (n instanceof Element) {\n         return null;\n     }\n \n+    /**\n+     * Get the parent of the specified node.\n+     * @param node to check\n+     * @return parent Element\n+     */\n     private static Element nodeParent(Object node) {\n         if (node instanceof Element) {\n             Object parent = ((Element) node).getParent();\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n                 + (index + 1) + \"]\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n             JXPathContext context, QName name, int index, Object value)\n     {\n         return ptr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n         if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         return it.getNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         Element parent = nodeParent(node);\n         if (parent == null) {\n         parent.getContent().remove(node);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n                 ']');\n         }\n         else if (node instanceof ProcessingInstruction) {\n-            String target = ((ProcessingInstruction) node).getTarget();\n-            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n+            buffer.append(\"/processing-instruction(\\'\").append(((ProcessingInstruction) node).getTarget()).append(\n                 \"')\");\n-            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n+            buffer.append('[').append(getRelativePositionOfPI()).append(\n                 ']');\n         }\n         return buffer.toString();\n     }\n \n+    /**\n+     * Return a string escaping single and double quotes.\n+     * @param string string to treat\n+     * @return string with any necessary changes made.\n+     */\n     private String escape(String string) {\n-        int index = string.indexOf('\\'');\n-        while (index != -1) {\n-            string =\n-                string.substring(0, index)\n-                    + \"&apos;\"\n-                    + string.substring(index + 1);\n-            index = string.indexOf('\\'');\n-        }\n-        index = string.indexOf('\\\"');\n-        while (index != -1) {\n-            string =\n-                string.substring(0, index)\n-                    + \"&quot;\"\n-                    + string.substring(index + 1);\n-            index = string.indexOf('\\\"');\n-        }\n-        return string;\n-    }\n-\n+        final char[] c = new char[] { '\\'', '\"' };\n+        final String[] esc = new String[] { \"&apos;\", \"&quot;\" };\n+        StringBuffer sb = null;\n+        for (int i = 0; sb == null && i < c.length; i++) {\n+            if (string.indexOf(c[i]) >= 0) {\n+                sb = new StringBuffer(string);\n+            }\n+        }\n+        if (sb == null) {\n+            return string;\n+        }\n+        for (int i = 0; i < c.length; i++) {\n+            if (string.indexOf(c[i]) < 0) {\n+                continue;\n+            }\n+            int pos = 0;\n+            while (pos < sb.length()) {\n+                if (sb.charAt(pos) == c[i]) {\n+                    sb.replace(pos, pos + 1, esc[i]);\n+                    pos += esc[i].length();\n+                } else {\n+                    pos++;\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Get relative position of this among like-named siblings.\n+     * @return 1..n\n+     */\n     private int getRelativePositionByName() {\n         if (node instanceof Element) {\n             Object parent = ((Element) node).getParent();\n         return 1;\n     }\n \n+    /**\n+     * Get relative position of this among all siblings.\n+     * @return 1..n\n+     */\n     private int getRelativePositionOfElement() {\n         Object parent = ((Element) node).getParent();\n         if (parent == null) {\n         return count;\n     }\n \n+    /**\n+     * Get the relative position of this among sibling text nodes.\n+     * @return 1..n\n+     */\n     private int getRelativePositionOfTextNode() {\n         Element parent;\n         if (node instanceof Text) {\n         return count;\n     }\n \n-    private int getRelativePositionOfPI(String target) {\n+    /**\n+     * Get the relative position of this among same-target processing instruction siblings.\n+     * @return 1..n\n+     */\n+    private int getRelativePositionOfPI() {\n+        String target = ((ProcessingInstruction) node).getTarget();\n         Element parent = (Element) ((ProcessingInstruction) node).getParent();\n         if (parent == null) {\n             return 1;\n         return count;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n-        return System.identityHashCode(node);\n-    }\n-\n+        return node.hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return node == other.node;\n     }\n \n+    /**\n+     * Get the AbstractFactory associated with the specified JXPathContext.\n+     * @param context JXPathContext\n+     * @return AbstractFactory\n+     */\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {", "timestamp": 1201996531, "metainfo": ""}