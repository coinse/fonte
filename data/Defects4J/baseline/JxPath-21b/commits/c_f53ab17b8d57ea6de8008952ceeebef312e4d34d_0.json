{"sha": "f53ab17b8d57ea6de8008952ceeebef312e4d34d", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n      * @return true if the object was successfully created\n      */\n     public boolean createObject(JXPathContext context, Pointer pointer,\n-                                Object parent, String name, int index)\n-    {\n+                                Object parent, String name, int index) {\n         return false;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/IdentityManager.java\n+++ b/src/java/org/apache/commons/jxpath/IdentityManager.java\n \n     /**\n      * Finds a node by its ID.\n+     * @param context JXPathContext\n+     * @param id String\n+     * @return Pointer\n      */\n     Pointer getPointerByID(JXPathContext context, String id);\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n  * @version $Revision$ $Date$\n  */\n public abstract class JXPathContext {\n+    private static JXPathContextFactory contextFactory;\n+    private static JXPathContext compilationContext;\n+\n+    private static final PackageFunctions GENERIC_FUNCTIONS =\n+        new PackageFunctions(\"\", null);\n+\n+    /** parent context */\n     protected JXPathContext parentContext;\n+    /** context bean */\n     protected Object contextBean;\n+    /**  variables */\n     protected Variables vars;\n+    /** functions */\n     protected Functions functions;\n+    /** AbstractFactory */\n     protected AbstractFactory factory;\n+    /** IdentityManager */\n+    protected IdentityManager idManager;\n+    /** KeyManager */\n+    protected KeyManager keyManager;\n+    /** decimal format map */\n+    protected HashMap decimalFormats;\n+\n     private Locale locale;\n     private boolean lenientSet = false;\n     private boolean lenient = false;\n-    protected IdentityManager idManager;\n-    protected KeyManager keyManager;\n-    protected HashMap decimalFormats;\n-\n-    private static JXPathContextFactory contextFactory;\n-    private static JXPathContext compilationContext;\n-\n-    private static final PackageFunctions GENERIC_FUNCTIONS =\n-        new PackageFunctions(\"\", null);\n \n     /**\n      * Creates a new JXPathContext with the specified object as the root node.\n+     * @param contextBean Object\n+     * @return JXPathContext\n      */\n     public static JXPathContext newContext(Object contextBean) {\n         return getContextFactory().newContext(null, contextBean);\n      * Creates a new JXPathContext with the specified bean as the root node and\n      * the specified parent context. Variables defined in a parent context can\n      * be referenced in XPaths passed to the child context.\n+     * @param parentContext parent context\n+     * @param contextBean Object\n+     * @return JXPathContext\n      */\n     public static JXPathContext newContext(\n-        JXPathContext parentContext,\n-        Object contextBean)\n-    {\n+            JXPathContext parentContext,\n+            Object contextBean) {\n         return getContextFactory().newContext(parentContext, contextBean);\n     }\n \n     /**\n      * Acquires a context factory and caches it.\n+     * @return JXPathContextFactory\n      */\n     private static JXPathContextFactory getContextFactory () {\n         if (contextFactory == null) {\n     }\n \n     /**\n-     * This  constructor should remain protected - it is to be overridden by\n+     * This constructor should remain protected - it is to be overridden by\n      * subclasses, but never explicitly invoked by clients.\n+     * @param parentContext parent context\n+     * @param contextBean Object\n      */\n     protected JXPathContext(JXPathContext parentContext, Object contextBean) {\n         this.parentContext = parentContext;\n \n     /**\n      * Returns the parent context of this context or null.\n+     * @return JXPathContext\n      */\n     public JXPathContext getParentContext() {\n         return parentContext;\n \n     /**\n      * Returns the JavaBean associated with this context.\n+     * @return Object\n      */\n     public Object getContextBean() {\n         return contextBean;\n \n     /**\n      * Returns a Pointer for the context bean.\n+     * @return Pointer\n      */\n     public abstract Pointer getContextPointer();\n \n      * The supplied pointer becomes the context pointer of the new context.\n      * The relative context inherits variables, extension functions, locale etc\n      * from the parent context.\n+     * @param pointer Pointer\n+     * @return JXPathContext\n      */\n     public abstract JXPathContext getRelativeContext(Pointer pointer);\n \n     /**\n      * Installs a custom implementation of the Variables interface.\n+     * @param vars Variables\n      */\n     public void setVariables(Variables vars) {\n         this.vars = vars;\n      * pool was specified with the <code>setVariables()</code> method,\n      * returns the default implementation of Variables,\n      * {@link BasicVariables BasicVariables}.\n+     * @return Variables\n      */\n     public Variables getVariables() {\n         if (vars == null) {\n \n     /**\n      * Install a library of extension functions.\n-     *\n+     * @param functions Functions\n      * @see FunctionLibrary\n      */\n     public void setFunctions(Functions functions) {\n \n     /**\n      * Returns the set of functions installed on the context.\n+     * @return Functions\n      */\n     public Functions getFunctions() {\n         if (functions != null) {\n      * Install an abstract factory that should be used by the\n      * <code>createPath()</code> and <code>createPathAndSetValue()</code>\n      * methods.\n+     * @param factory AbstractFactory\n      */\n     public void setFactory(AbstractFactory factory) {\n         this.factory = factory;\n      * Returns the AbstractFactory installed on this context.\n      * If none has been installed and this context has a parent context,\n      * returns the parent's factory.  Otherwise returns null.\n+     * @return AbstractFactory\n      */\n     public AbstractFactory getFactory() {\n         if (factory == null && parentContext != null) {\n      * attribute as well as the the lang() function will be\n      * affected by the locale.  By default, JXPath uses\n      * <code>Locale.getDefault()</code>\n+     * @param locale Locale\n      */\n     public synchronized void setLocale(Locale locale) {\n         this.locale = locale;\n      * Returns the locale set with setLocale. If none was set and\n      * the context has a parent, returns the parent's locale.\n      * Otherwise, returns Locale.getDefault().\n+     * @return Locale\n      */\n     public synchronized Locale getLocale() {\n         if (locale == null) {\n      * By default, JXPath uses the symbols for the current locale.\n      *\n      * @param name the format name or null for default format.\n-     */\n-    public synchronized void setDecimalFormatSymbols(\n-        String name,\n-        DecimalFormatSymbols symbols)\n-    {\n+     * @param symbols DecimalFormatSymbols\n+     */\n+    public synchronized void setDecimalFormatSymbols(String name,\n+            DecimalFormatSymbols symbols) {\n         if (decimalFormats == null) {\n             decimalFormats = new HashMap();\n         }\n     }\n \n     /**\n+     * Get the named DecimalFormatSymbols.\n+     * @param name key\n+     * @return DecimalFormatSymbols\n      * @see #setDecimalFormatSymbols(String, DecimalFormatSymbols)\n      */\n     public synchronized DecimalFormatSymbols getDecimalFormatSymbols(String name) {\n      * thrown.\n      * <p>\n      * By default, lenient = false\n+     * @param lenient flag\n      */\n     public synchronized void setLenient(boolean lenient) {\n         this.lenient = lenient;\n     }\n \n     /**\n+     * Learn whether this JXPathContext is lenient.\n+     * @return boolean\n      * @see #setLenient(boolean)\n      */\n     public synchronized boolean isLenient() {\n      * when you need to evaluate the same expression multiple times\n      * and there is a convenient place to cache CompiledExpression\n      * between invocations.\n+     * @param xpath to compile\n+     * @return CompiledExpression\n      */\n     public static CompiledExpression compile(String xpath) {\n         if (compilationContext == null) {\n     /**\n      * Overridden by each concrete implementation of JXPathContext\n      * to perform compilation. Is called by <code>compile()</code>.\n+     * @param xpath to compile\n+     * @return CompiledExpression\n      */\n     protected abstract CompiledExpression compilePath(String xpath);\n \n      * @return the found object\n      */\n     public Object selectSingleNode(String xpath) {\n-    \tPointer pointer = getPointer(xpath);\n+        Pointer pointer = getPointer(xpath);\n         return pointer == null ? null : pointer.getNode();\n     }\n \n      * @return a list of found objects\n      */\n     public List selectNodes(String xpath) {\n-    \tArrayList list = new ArrayList();\n-    \tIterator iterator = iteratePointers(xpath);\n-    \twhile (iterator.hasNext()) {\n-\t\t\tPointer pointer = (Pointer) iterator.next();\n-\t\t\tlist.add(pointer.getNode());\n-\t\t}\n-\t\treturn list;\n+        ArrayList list = new ArrayList();\n+        Iterator iterator = iteratePointers(xpath);\n+        while (iterator.hasNext()) {\n+            Pointer pointer = (Pointer) iterator.next();\n+            list.add(pointer.getNode());\n+        }\n+        return list;\n     }\n \n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n+     * @param xpath to evaluate\n+     * @return Object found\n      */\n     public abstract Object getValue(String xpath);\n \n     /**\n      * Evaluates the xpath, converts the result to the specified class and\n      * returns the resulting object.\n+     * @param xpath to evaluate\n+     * @param requiredType required type\n+     * @return Object found\n      */\n     public abstract Object getValue(String xpath, Class requiredType);\n \n      * <li>The xpath does not in fact describe an existing property\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n+     * @param xpath indicating position\n+     * @param value to set\n      */\n     public abstract void setValue(String xpath, Object value);\n \n      * <p>\n      * Will throw an exception if the AbstractFactory fails to create\n      * an instance for a path element.\n+     * @param xpath indicating destination to create\n+     * @return pointer to new location\n      */\n     public abstract Pointer createPath(String xpath);\n \n      * element.\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n+     * @param xpath indicating position to create\n+     * @param value to set\n+     * @return pointer to new location\n      */\n     public abstract Pointer createPathAndSetValue(String xpath, Object value);\n \n     /**\n      * Removes the element of the object graph described by the xpath.\n+     * @param xpath indicating position to remove\n      */\n     public abstract void removePath(String xpath);\n \n     /**\n      * Removes all elements of the object graph described by the xpath.\n+     * @param xpath indicating positions to remove\n      */\n     public abstract void removeAll(String xpath);\n \n      * Traverses the xpath and returns an Iterator of all results found\n      * for the path. If the xpath matches no properties\n      * in the graph, the Iterator will be empty, but not null.\n+     * @param xpath to iterate\n+     * @return Iterator<Object>\n      */\n     public abstract Iterator iterate(String xpath);\n \n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n      * in the graph, the pointer will be null.\n+     * @param xpath desired\n+     * @return Pointer\n      */\n     public abstract Pointer getPointer(String xpath);\n \n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n      * in the graph, the Iterator be empty, but not null.\n+     * @param xpath to iterate\n+     * @return Iterator<Pointer>\n      */\n     public abstract Iterator iteratePointers(String xpath);\n \n     /**\n      * Install an identity manager that will be used by the context\n      * to look up a node by its ID.\n+     * @param idManager IdentityManager to set\n      */\n     public void setIdentityManager(IdentityManager idManager) {\n         this.idManager = idManager;\n     /**\n      * Returns this context's identity manager. If none has been installed,\n      * returns the identity manager of the parent context.\n+     * @return IdentityManager\n      */\n     public IdentityManager getIdentityManager() {\n         if (idManager == null && parentContext != null) {\n      * Locates a Node by its ID.\n      *\n      * @param id is the ID of the sought node.\n+     * @return Pointer\n      */\n     public Pointer getPointerByID(String id) {\n         IdentityManager manager = getIdentityManager();\n     /**\n      * Install a key manager that will be used by the context\n      * to look up a node by a key value.\n+     * @param keyManager KeyManager\n      */\n     public void setKeyManager(KeyManager keyManager) {\n         this.keyManager = keyManager;\n     /**\n      * Returns this context's key manager. If none has been installed,\n      * returns the key manager of the parent context.\n+     * @return KeyManager\n      */\n     public KeyManager getKeyManager() {\n         if (keyManager == null && parentContext != null) {\n \n     /**\n      * Locates a Node by a key value.\n+     * @param key string\n+     * @param value string\n+     * @return Pointer found\n      */\n     public Pointer getPointerByKey(String key, String value) {\n         KeyManager manager = getKeyManager();\n \n     /**\n      * Locates a NodeSet by key/value.\n-     * @param key\n-     * @param value\n+     * @param key string\n+     * @param value object\n+     * @return NodeSet found\n      */\n     public NodeSet getNodeSetByKey(String key, Object value) {\n         KeyManager manager = getKeyManager();\n--- a/src/java/org/apache/commons/jxpath/Variables.java\n+++ b/src/java/org/apache/commons/jxpath/Variables.java\n \n     /**\n      * Returns true if the specified variable is declared.\n+     * @param varName variable name\n+     * @return boolean\n      */\n     boolean isDeclaredVariable(String varName);\n \n     /**\n      * Returns the value of the specified variable.\n-     * Throws IllegalArgumentException if there is no such variable.\n+     * @param varName variable name\n+     * @return Object value\n+     * @throws IllegalArgumentException if there is no such variable.\n      */\n     Object getVariable(String varName);\n \n      * Defines a new variable with the specified value or modifies\n      * the value of an existing variable.\n      * May throw UnsupportedOperationException.\n+     * @param varName variable name\n+     * @param value to declare\n      */\n     void declareVariable(String varName, Object value);\n \n--- a/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n     private Source source;\n \n     /**\n-     * @param xmlURL is a URL for an XML file. Use getClass().getResource\n-     * (resourceName) to load XML from a resource file.\n+     * Create a new XMLDocumentContainer.\n+     * @param xmlURL a URL for an XML file. Use getClass().getResource(resourceName)\n+     *               to load XML from a resource file.\n      */\n     public XMLDocumentContainer(URL xmlURL) {\n         this.xmlURL = xmlURL;\n         delegate = new DocumentContainer(xmlURL);\n     }\n \n+    /**\n+     * Create a new XMLDocumentContainer.\n+     * @param source XML source\n+     */\n     public XMLDocumentContainer(Source source) {\n         this.source = source;\n         if (source == null) {\n \n     /**\n      * Reads XML, caches it internally and returns the Document.\n+     * @return Object value\n      */\n     public Object getValue() {\n         if (document == null) {\n \n     /**\n      * Throws an UnsupportedOperationException\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException();\n--- a/src/java/org/apache/commons/jxpath/ri/Compiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Compiler.java\n \n     /**\n      * Produces an EXPRESSION object that represents a numeric constant.\n+     * @param value numeric String\n+     * @return Object\n      */\n     Object number(String value);\n \n     /**\n      * Produces an EXPRESSION object that represents a string constant.\n+     * @param value String literal\n+     * @return Object\n      */\n     Object literal(String value);\n \n     /**\n      * Produces an QNAME that represents a name with an optional prefix.\n+     * @param prefix String prefix\n+     * @param name String name\n+     * @return Object\n      */\n     Object qname(String prefix, String name);\n \n      * Produces an EXPRESSION object representing the sum of all argumens\n      *\n      * @param arguments are EXPRESSION objects\n+     * @return Object\n      */\n     Object sum(Object[] arguments);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object minus(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object multiply(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object divide(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object mod(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object lessThan(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object lessThanOrEqual(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object greaterThan(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object greaterThanOrEqual(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object equal(Object left, Object right);\n \n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n+     * @return Object\n      */\n     Object notEqual(Object left, Object right);\n \n      * Produces an EXPRESSION object representing unary negation of the argument\n      *\n      * @param argument is an EXPRESSION object\n+     * @return Object\n      */\n     Object minus(Object argument);\n \n      * Produces an EXPRESSION object representing variable reference\n      *\n      * @param qname is a QNAME object\n+     * @return Object\n      */\n     Object variableReference(Object qname);\n \n      *\n      * @param code is one of FUNCTION_... constants\n      * @param args are EXPRESSION objects\n+     * @return Object\n      */\n     Object function(int code, Object[] args);\n \n      *\n      * @param name is a QNAME object (function name)\n      * @param args are EXPRESSION objects\n+     * @return Object\n      */\n     Object function(Object name, Object[] args);\n \n      * all arguments\n      *\n      * @param arguments are EXPRESSION objects\n-     */\n-    Object and(Object arguments[]);\n+     * @return Object\n+     */\n+    Object and(Object[] arguments);\n \n     /**\n      * Produces an EXPRESSION object representing logical disjunction of\n      * all arguments\n      *\n      * @param arguments are EXPRESSION objects\n-     */\n-    Object or(Object arguments[]);\n+     * @return Object\n+     */\n+    Object or(Object[] arguments);\n \n     /**\n      * Produces an EXPRESSION object representing union of all node sets\n      *\n      * @param arguments are EXPRESSION objects\n+     * @return Object\n      */\n     Object union(Object[] arguments);\n \n      * Produces a NODE_TEST object that represents a node name test.\n      *\n      * @param qname is a QNAME object\n+     * @return Object\n      */\n     Object nodeNameTest(Object qname);\n \n      * Produces a NODE_TEST object that represents a node type test.\n      *\n      * @param nodeType is a NODE_TEST object\n+     * @return Object\n      */\n     Object nodeTypeTest(int nodeType);\n \n      * test.\n      *\n      * @param instruction is a NODE_TEST object\n+     * @return Object\n      */\n     Object processingInstructionTest(String instruction);\n \n      * @param axis is one of the AXIS_... constants\n      * @param nodeTest is a NODE_TEST object\n      * @param predicates are EXPRESSION objects\n+     * @return Object\n      */\n     Object step(int axis, Object nodeTest, Object[] predicates);\n \n      *\n      * @param absolute indicates whether the path is absolute\n      * @param steps are STEP objects\n+     * @return Object\n      */\n     Object locationPath(boolean absolute, Object[] steps);\n \n      * @param expression is an EXPRESSION object\n      * @param predicates are EXPRESSION objects\n      * @param steps are STEP objects\n+     * @return Object\n      */\n     Object expressionPath(\n         Object expression,\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n  * @version $Revision$ $Date$\n  */\n public class NamespaceResolver implements Cloneable {\n-    final protected NamespaceResolver parent;\n+    /** Parent NamespaceResolver */\n+    protected final NamespaceResolver parent;\n+    /** namespace map */\n     protected HashMap namespaceMap = new HashMap();\n+    /** reverse lookup map */\n     protected HashMap reverseMap;\n+    /** pointer */\n     protected NodePointer pointer;\n     private boolean sealed;\n \n     /**\n      * Find the namespace prefix for the specified namespace URI and NodePointer.\n-     * @param pointer\n-     * @param namespaceURI\n+     * @param pointer location\n+     * @param namespaceURI to check\n      * @return prefix if found\n      * @since JXPath 1.3\n      */\n \n     /**\n      * Create a new NamespaceResolver.\n-     * @param parent\n+     * @param parent NamespaceResolver\n      */\n     public NamespaceResolver(NamespaceResolver parent) {\n         this.parent = parent;\n \n     /**\n      * Get the nearest prefix found that matches an externally-registered namespace.\n-     * @param namespaceURI\n+     * @param namespaceURI the ns URI to check.\n      * @return String prefix if found.\n      * @since JXPath 1.3\n      */\n \n     /**\n      * Learn whether this NamespaceResolver has been sealed.\n-     * @return\n+     * @return boolean\n      */\n     public boolean isSealed() {\n         return sealed;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n     private NodePointer currentNodePointer;\n \n     /**\n+     * Create a new AttributeContext.\n      * @param parentContext represents the previous step on the path\n      * @param nodeTest is the name of the attribute we are looking for\n      */\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n     private boolean setStarted = false;\n     private NodePointer currentNodePointer;\n \n+    /**\n+     * Create a new ParentContext.\n+     * @param parentContext parent context\n+     * @param nodeTest test\n+     */\n     public ParentContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getCurrentPosition() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getDocumentOrder() {\n         return -1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         super.setPosition(position);\n         return position == 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         // Each set contains exactly one node: the parent\n         if (setStarted) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n     private NodePointer currentRootLocation;\n     private boolean reverse;\n \n+    /**\n+     * Create a new PrecedingOrFollowingContext.\n+     * @param parentContext parent context\n+     * @param nodeTest test\n+     * @param reverse whether to iterate in reverse order\n+     */\n     public PrecedingOrFollowingContext(\n         EvalContext parentContext,\n         NodeTest nodeTest,\n-        boolean reverse)\n-    {\n+        boolean reverse) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n         this.reverse = reverse;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getDocumentOrder() {\n         return reverse ? -1 : 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         stack = new Stack();\n         setStarted = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position < this.position) {\n             reset();\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n public class RootContext extends EvalContext {\n     private JXPathContextReferenceImpl jxpathContext;\n     private NodePointer pointer;\n-    private Object registers[];\n+    private Object[] registers;\n     private int availableRegister = 0;\n     public static final Object UNKNOWN_VALUE = new Object();\n     private static final int MAX_REGISTER = 4;\n \n-    public RootContext(\n-        JXPathContextReferenceImpl jxpathContext,\n-        NodePointer pointer)\n-    {\n+    /**\n+     * Create a new RootContext.\n+     * @param jxpathContext context\n+     * @param pointer pointer\n+     */\n+    public RootContext(JXPathContextReferenceImpl jxpathContext,\n+            NodePointer pointer) {\n         super(null);\n         this.jxpathContext = jxpathContext;\n         this.pointer = pointer;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public JXPathContext getJXPathContext() {\n         return jxpathContext;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public RootContext getRootContext() {\n         return this;\n     }\n \n+    /**\n+     * Get absolute root context\n+     * @return EvalContext\n+     */\n     public EvalContext getAbsoluteRootContext() {\n         return jxpathContext.getAbsoluteRootContext();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return pointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         return pointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getCurrentPosition() {\n         throw new UnsupportedOperationException();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         throw new UnsupportedOperationException();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextSet() {\n         throw new UnsupportedOperationException();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         throw new UnsupportedOperationException();\n     }\n \n+    /**\n+     * Get a context that points to the specified object.\n+     * @param constant object\n+     * @return EvalContext\n+     */\n     public EvalContext getConstantContext(Object constant) {\n         if (constant instanceof NodeSet) {\n             return new NodeSetContext(\n         return new InitialContext(new RootContext(jxpathContext, pointer));\n     }\n \n+    /**\n+     * Get variable context.\n+     * @param variableName variable name\n+     * @return EvalContext\n+     */\n     public EvalContext getVariableContext(QName variableName) {\n         return new InitialContext(\n             new RootContext(\n                 jxpathContext.getVariablePointer(variableName)));\n     }\n \n+    /**\n+     * Get the specified function from the context.\n+     * @param functionName QName\n+     * @param parameters Object[]\n+     * @return Function\n+     */\n     public Function getFunction(QName functionName, Object[] parameters) {\n         return jxpathContext.getFunction(functionName, parameters);\n     }\n \n+    /**\n+     * Get a registered value. \n+     * @param id int\n+     * @return Object\n+     */\n     public Object getRegisteredValue(int id) {\n         if (registers == null || id >= MAX_REGISTER || id == -1) {\n             return UNKNOWN_VALUE;\n         return registers[id];\n     }\n \n+    /**\n+     * Set the next registered value.\n+     * @param value Object\n+     * @return the id that can reclaim value.\n+     */\n     public int setRegisteredValue(Object value) {\n         if (registers == null) {\n             registers = new Object[MAX_REGISTER];\n         return availableRegister - 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return super.toString() + \":\" + pointer.asPath();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n \n     private Object value;\n \n+    /**\n+     * Create a new Constant.\n+     * @param number constant\n+     */\n     public Constant(Number number) {\n         this.value = number;\n     }\n \n+    /**\n+     * Create a new Constant.\n+     * @param string constant\n+     */\n     public Constant(String string) {\n         this.value = string;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return value;\n     }\n \n     /**\n-     * Returns the value of the constant.\n+     * {@inheritDoc}\n      */\n     public Object computeValue(EvalContext context) {\n         return value;\n \n     /**\n      * Returns false\n+     * @return false\n      */\n     public boolean isContextDependent() {\n         return false;\n \n     /**\n      * Returns false\n+     * @return false\n      */\n     public boolean computeContextDependent() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         if (value instanceof Number) {\n             return InfoSetUtil.stringValue(value);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n  */\n public abstract class CoreOperation extends Operation {\n \n-    public CoreOperation(Expression args[]) {\n+    /**\n+     * Create a new CoreOperation.\n+     * @param args Expression[]\n+     */\n+    public CoreOperation(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public abstract Object computeValue(EvalContext context);\n \n     /**\n      * Returns the XPath symbol for this operation, e.g. \"+\", \"div\", etc.\n+     * @return String symbol\n      */\n     public abstract String getSymbol();\n \n     /**\n      * Returns true if the operation is not sensitive to the order of arguments,\n      * e.g. \"=\", \"and\" etc, and false if it is, e.g. \"&lt;=\", \"div\".\n+     * @return boolean\n      */\n     protected abstract boolean isSymmetric();\n \n     /**\n      * Computes the precedence of the operation.\n+     * @return int precedence\n      */\n     protected abstract int getPrecedence();\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         if (args.length == 1) {\n             return getSymbol() + parenthesize(args[0], false);\n         return buffer.toString();\n     }\n \n+    /**\n+     * Wrap an expression in parens if necessary.\n+     * @param expression other Expression\n+     * @param left whether <code>expression</code> is left of this one.\n+     * @return String\n+     */\n     private String parenthesize(Expression expression, boolean left) {\n         String s = expression.toString();\n         if (!(expression instanceof CoreOperation)) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n public class CoreOperationLessThanOrEqual extends\n         CoreOperationRelationalExpression {\n \n+    /**\n+     * Create a new CoreOperationLessThanOrEqual.\n+     * @param arg1 left Expression\n+     * @param arg2 right Expression\n+     */\n     public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean evaluateCompare(int compare) {\n         return compare <= 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"<=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n  */\n public class CoreOperationMultiply extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationMultiply.\n+     * @param arg1 factor 1\n+     * @param arg2 factor 2\n+     */\n     public CoreOperationMultiply(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l * r);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 5;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"*\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n  */\n public class CoreOperationUnion extends CoreOperation {\n \n-    public CoreOperationUnion(Expression args[]) {\n+    /**\n+     * Create a new CoreOperationUnion.\n+     * @param args Expression[]\n+     */\n+    public CoreOperationUnion(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n-        EvalContext argCtxs[] = new EvalContext[args.length];\n+        EvalContext[] argCtxs = new EvalContext[args.length];\n         for (int i = 0; i < args.length; i++) {\n             Object value = args[i].compute(context);\n             if (value instanceof EvalContext) {\n         return new UnionContext(context.getRootContext(), argCtxs);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 7;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"|\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n  */\n public class NameAttributeTest extends CoreOperationEqual {\n \n+    /**\n+     * Create a new NameAttributeTest.\n+     * @param namePath Expression\n+     * @param nameValue Expression\n+     */\n     public NameAttributeTest(Expression namePath, Expression nameValue) {\n         super(namePath, nameValue);\n     }\n \n+    /**\n+     * Get the name test expression.\n+     * @return Expression\n+     */\n     public Expression getNameTestExpression() {\n         return args[1];\n     }\n \n     /**\n-     * @see Expression#computeContextDependent()\n+     * {@inheritDoc}\n      */\n     public boolean computeContextDependent() {\n         return true;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n  */\n public abstract class Operation extends Expression {\n \n-    protected Expression args[];\n+    /** Expression[] of arguments */\n+    protected Expression[] args;\n \n-    public Operation(Expression args[]) {\n+    /**\n+     * Create a new Operation.\n+     * @param args Expression[]\n+     */\n+    public Operation(Expression[] args) {\n         this.args = args;\n     }\n \n+    /**\n+     * Get the arguments.\n+     * @return Expression[]\n+     */\n     public Expression[] getArguments() {\n         return args;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean computeContextDependent() {\n         if (args != null) {\n             for (int i = 0; i < args.length; i++) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n public class ProcessingInstructionTest extends NodeTest {\n     private String target;\n \n+    /**\n+     * Create a new ProcessingInstructionTest.\n+     * @param target string\n+     */\n     public ProcessingInstructionTest(String target) {\n         this.target = target;\n     }\n \n+    /**\n+     * Get the target.\n+     * @return String\n+     */\n     public String getTarget() {\n         return target;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return \"processing-instruction('\" + target + \"')\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n \n     private QName varName;\n \n+    /**\n+     * Create a new VariableReference.\n+     * @param varName variable name\n+     */\n     public VariableReference(QName varName) {\n         this.varName = varName;\n     }\n \n+    /**\n+     * Get the variable name.\n+     * @return QName\n+     */\n     public QName getVariableName() {\n         return varName;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return \"$\" + varName;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isContextDependent() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean computeContextDependent() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n     /**\n      * Returns the value of the variable.\n+     * @param context EvalContext against which to compute the variable's value.\n+     * @return Object\n      */\n     public Object computeValue(EvalContext context) {\n         return context.getRootContext().getVariableContext(varName);\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n \n     /** Index for this NodePointer */\n     protected int index = WHOLE_COLLECTION;\n+\n     private boolean attribute = false;\n     private transient Object rootNode;\n     private NamespaceResolver namespaceResolver;\n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n+     * @param name QName\n+     * @param bean Object\n+     * @param locale Locale\n+     * @return NodePointer\n      */\n     public static NodePointer newNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale)\n-    {\n+        Locale locale) {\n         NodePointer pointer = null;\n         if (bean == null) {\n             pointer = new NullPointer(name, locale);\n     /**\n      * Allocates an new child NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n+     * @param parent pointer\n+     * @param name QName\n+     * @param bean Object\n+     * @return NodePointer\n      */\n     public static NodePointer newChildNodePointer(\n         NodePointer parent,\n         QName name,\n-        Object bean)\n-    {\n+        Object bean) {\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n                 + bean.getClass());\n     }\n \n+    /** Parent pointer */\n     protected NodePointer parent;\n+\n+    /** Locale */\n     protected Locale locale;\n-//    private NamespaceManager namespaceManager;\n-\n+\n+    /**\n+     * Create a new NodePointer.\n+     * @param parent Pointer\n+     */\n     protected NodePointer(NodePointer parent) {\n         this.parent = parent;\n     }\n \n+    /**\n+     * Create a new NodePointer.\n+     * @param parent Pointer\n+     * @param locale Locale\n+     */\n     protected NodePointer(NodePointer parent, Locale locale) {\n         this.parent = parent;\n         this.locale = locale;\n     }\n \n+    /**\n+     * Get the NamespaceResolver associated with this NodePointer.\n+     * @return NamespaceResolver\n+     */\n     public NamespaceResolver getNamespaceResolver() {\n         if (namespaceResolver == null && parent != null) {\n             namespaceResolver = parent.getNamespaceResolver();\n         return namespaceResolver;\n     }\n \n+    /**\n+     * Set the NamespaceResolver for this NodePointer.\n+     * @param namespaceResolver NamespaceResolver\n+     */\n     public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n         this.namespaceResolver = namespaceResolver;\n     }\n \n+    /**\n+     * Get the parent pointer.\n+     * @return NodePointer\n+     */\n     public NodePointer getParent() {\n         NodePointer pointer = parent;\n         while (pointer != null && pointer.isContainer()) {\n         return pointer;\n     }\n \n+    /**\n+     * Get the immediate parent pointer.\n+     * @return NodePointer\n+     */\n     public NodePointer getImmediateParentPointer() {\n         return parent;\n     }\n \n     /**\n      * Set to true if the pointer represents the \"attribute::\" axis.\n+     * @param attribute boolean\n      */\n     public void setAttribute(boolean attribute) {\n         this.attribute = attribute;\n \n     /**\n      * Returns true if the pointer represents the \"attribute::\" axis.\n+     * @return boolean\n      */\n     public boolean isAttribute() {\n         return attribute;\n \n     /**\n      * Returns true if this Pointer has no parent.\n+     * @return boolean\n      */\n     public boolean isRoot() {\n         return parent == null;\n \n     /**\n      * If true, this node does not have children\n+     * @return boolean\n      */\n     public abstract boolean isLeaf();\n \n     /**\n+     * Learn whether this pointer is considered to be a node.\n+     * @return boolean\n      * @deprecated Please use !isContainer()\n      */\n     public boolean isNode() {\n     }\n \n     /**\n-     * If true, this node is axiliary and can only be used as an intermediate in\n+     * If true, this node is auxiliary and can only be used as an intermediate in\n      * the chain of pointers.\n+     * @return boolean\n      */\n     public boolean isContainer() {\n         return false;\n      * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n      * is not indexed at all.\n      * Note: the index on NodePointer starts with 0, not 1.\n+     * @return int\n      */\n     public int getIndex() {\n         return index;\n     }\n \n+    /**\n+     * Set the index of this NodePointer.\n+     * @param index int\n+     */\n     public void setIndex(int index) {\n         this.index = index;\n     }\n     /**\n      * Returns <code>true</code> if the value of the pointer is an array or\n      * a Collection.\n+     * @return boolean\n      */\n     public abstract boolean isCollection();\n \n      * If the pointer represents a collection (or collection element),\n      * returns the length of the collection.\n      * Otherwise returns 1 (even if the value is null).\n+     * @return int\n      */\n     public abstract int getLength();\n \n      * By default, returns <code>getNode()</code>, can be overridden to\n      * return a \"canonical\" value, like for instance a DOM element should\n      * return its string value.\n+     * @return Object value\n      */\n     public Object getValue() {\n         NodePointer valuePointer = getValuePointer();\n      * <code>getValuePointer()</code> method should then open all those\n      * containers and return the pointer to the ultimate contents. It does so\n      * with the above recursion.\n+     * @return NodePointer\n      */\n     public NodePointer getValuePointer() {\n         NodePointer ivp = getImmediateValuePointer();\n      * If <em>address</em> is null, the pointer is not actual.\n      * (In JavaBeans) if <em>address</em> is not a property of the root bean,\n      * a Pointer for this path cannot be obtained at all - actual or otherwise.\n+     * @return boolean\n      */\n     public boolean isActual() {\n         return index == WHOLE_COLLECTION || index >= 0 && index < getLength();\n         JXPathContext context,\n         QName name,\n         int index,\n-        Object value)\n-    {\n+        Object value) {\n         throw new JXPathException(\"Cannot create an object for path \"\n                 + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n      * @param index child index.\n      * @return created NodePointer\n      */\n-    public NodePointer createChild(JXPathContext context, QName name, int index)\n-    {\n+    public NodePointer createChild(JXPathContext context, QName name, int index) {\n         throw new JXPathException(\"Cannot create an object for path \"\n                 + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith)\n-    {\n+        NodePointer startWith) {\n         NodePointer valuePointer = getValuePointer();\n         return valuePointer == null || valuePointer == this ? null\n                 : valuePointer.childIterator(test, reverse, startWith);\n      * @return Pointer found\n      */\n     public Pointer getPointerByKey(\n-        JXPathContext context,\n-        String key,\n-        String value)\n-    {\n+            JXPathContext context,\n+            String key,\n+            String value) {\n         return context.getPointerByKey(key, value);\n     }\n \n         NodePointer p1,\n         int depth1,\n         NodePointer p2,\n-        int depth2)\n-    {\n+        int depth2) {\n         if (depth1 < depth2) {\n             int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n             return r == 0 ? -1 : r;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n  */\n public class NullElementPointer extends CollectionPointer {\n \n+    /**\n+     * Create a new NullElementPointer.\n+     * @param parent parent pointer\n+     * @param index int\n+     */\n     public NullElementPointer(NodePointer parent, int index) {\n         super(parent, (Object) null);\n         this.index = index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * Get the property pointer for this.\n+     * @return PropertyPointer\n+     */\n     public PropertyPointer getPropertyPointer() {\n         return new NullPropertyPointer(this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getValuePointer() {\n         return new NullPointer(this, getName());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException(\n             \"Collection element does not exist: \" + this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isContainer() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         return parent.createChild(context, null, index);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         return parent.createChild(context, null, index, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return getImmediateParentPointer().hashCode() + index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n \n         NullElementPointer other = (NullElementPointer) object;\n         return getImmediateParentPointer() == other.getImmediateParentPointer()\n-            && index == other.index;\n+                && index == other.index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         NodePointer parent = getImmediateParentPointer();\n             }\n             else if (parent != null\n                     && parent.getImmediateParentPointer() != null\n-                    && parent.getImmediateParentPointer().getIndex() !=\n-                            WHOLE_COLLECTION)\n-            {\n+                    && parent.getImmediateParentPointer().getIndex() != WHOLE_COLLECTION) {\n                 buffer.append(\"/.\");\n             }\n             buffer.append(\"[\").append(index + 1).append(']');\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n  * @version $Revision$ $Date$\n  */\n public class ContainerPointerFactory implements NodePointerFactory {\n-\n+    /** factory order for this factory */\n     public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return CONTAINER_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(\n-        QName name,\n-        Object bean,\n-        Locale locale)\n-    {\n-        return bean instanceof Container ? new ContainerPointer((Container) bean, locale) : null;\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n+        return bean instanceof Container ? new ContainerPointer(\n+                (Container) bean, locale) : null;\n     }\n \n-    public NodePointer createNodePointer(\n-        NodePointer parent,\n-        QName name,\n-        Object bean)\n-    {\n-        return bean instanceof Container ? new ContainerPointer(parent, (Container) bean) : null;\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name,\n+            Object bean) {\n+        return bean instanceof Container ? new ContainerPointer(parent,\n+                (Container) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n     private boolean reverse;\n     private int position = 0;\n \n+    /**\n+     * Create a new DOMNodeIterator.\n+     * @param parent parent pointer\n+     * @param nodeTest test\n+     * @param reverse whether to iterate in reverse\n+     * @param startWith starting pointer\n+     */\n     public DOMNodeIterator(\n         NodePointer parent,\n         NodeTest nodeTest,\n         boolean reverse,\n-        NodePointer startWith)\n-    {\n+        NodePointer startWith) {\n         this.parent = parent;\n         this.node = (Node) parent.getNode();\n         if (startWith != null) {\n         this.reverse = reverse;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             setPosition(1);\n         return child == null ? null : new DOMNodePointer(parent, child);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         while (this.position < position) {\n             if (!next()) {\n         return true;\n     }\n \n+    /**\n+     * Set the previous position.\n+     * @return whether valid\n+     */\n     private boolean previous() {\n         position--;\n         if (!reverse) {\n         return child != null;\n     }\n \n+    /**\n+     * Set the next position.\n+     * @return whether valid\n+     */\n     private boolean next() {\n         position++;\n         if (!reverse) {\n         return child != null;\n     }\n \n+    /**\n+     * Test child.\n+     * @return result of the test\n+     */\n     private boolean testChild() {\n         return DOMNodePointer.testNode(child, nodeTest);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n     private List children;\n     private Object child;\n \n+    /**\n+     * Create a new JDOMNodeIterator.\n+     * @param parent pointer\n+     * @param nodeTest test\n+     * @param reverse whether to iterate in reverse\n+     * @param startWith starting pointer\n+     */\n     public JDOMNodeIterator(\n             NodePointer parent, NodeTest nodeTest,\n-            boolean reverse, NodePointer startWith)\n-    {\n+            boolean reverse, NodePointer startWith) {\n         this.parent = parent;\n         if (startWith != null) {\n             this.child = startWith.getNode();\n         this.reverse = reverse;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (child == null) {\n             if (!setPosition(1)) {\n         return new JDOMNodePointer(parent, child);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         while (this.position < position) {\n             if (!next()) {\n      * of xpaths - an iterator is always going forward, never backwards.\n      * So, this is implemented only for completeness and perhaps for\n      * those who use these iterators outside of XPath evaluation.\n+     * @return boolean\n      */\n     private boolean previous() {\n         position--;\n         return false;\n     }\n \n+    /**\n+     * Iterate to next pointer.\n+     * @return whether valid\n+     */\n     private boolean next() {\n         position++;\n         if (!reverse) {\n         }\n     }\n \n+    /**\n+     * Test a child node.\n+     * @return whether test passes.\n+     */\n     private boolean testChild() {\n         return JDOMNodePointer.testNode(parent, child, nodeTest);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith)\n-    {\n+        NodePointer startWith) {\n         return new JDOMNodeIterator(this, test, reverse, startWith);\n     }\n \n      */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2)\n-    {\n+        NodePointer pointer2) {\n         Object node1 = pointer1.getBaseValue();\n         Object node2 = pointer2.getBaseValue();\n         if (node1 == node2) {\n     public static boolean testNode(\n         NodePointer pointer,\n         Object node,\n-        NodeTest test)\n-    {\n+        NodeTest test) {\n         if (test == null) {\n             return true;\n         }\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index)\n-    {\n+        int index) {\n         if (index == WHOLE_COLLECTION) {\n             index = 0;\n         }\n      * {@inheritDoc}\n      */\n     public NodePointer createChild(\n-            JXPathContext context, QName name, int index, Object value)\n-    {\n+            JXPathContext context, QName name, int index, Object value) {\n         NodePointer ptr = createChild(context, name, index);\n         ptr.setValue(value);\n         return ptr;\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n  */\n public class JDOMPointerFactory implements NodePointerFactory {\n \n+    /** factory order constant */\n     public static final int JDOM_POINTER_FACTORY_ORDER = 110;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return JDOM_POINTER_FACTORY_ORDER;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n-            QName name, Object bean, Locale locale)\n-    {\n+            QName name, Object bean, Locale locale) {\n         if (bean instanceof Document) {\n             return new JDOMNodePointer(bean, locale);\n         }\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n-            NodePointer parent, QName name, Object bean)\n-    {\n+            NodePointer parent, QName name, Object bean) {\n         if (bean instanceof Document) {\n             return new JDOMNodePointer(parent, bean);\n         }\n--- a/src/java/org/apache/commons/jxpath/xml/XMLParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/XMLParser.java\n     /**\n      * Reads the supplied XML file and returns the resulting model,\n      * which is not necessarily DOM.\n+     * @param stream InputStream\n+     * @return Object\n      */\n     Object parseXML(InputStream stream);\n }", "timestamp": 1202054918, "metainfo": ""}