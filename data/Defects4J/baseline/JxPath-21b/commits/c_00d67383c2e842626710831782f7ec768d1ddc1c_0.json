{"sha": "00d67383c2e842626710831782f7ec768d1ddc1c", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n+++ b/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n     private List nodes;\n     private List values;\n \n+    /**\n+     * Add a pointer to this NodeSet.\n+     * @param pointer to add\n+     */\n     public void add(Pointer pointer) {\n         if (pointers.add(pointer)) {\n             clearCacheLists();\n         }\n     }\n \n+    /**\n+     * Add the specified NodeSet to this NodeSet.\n+     * @param nodeSet to add\n+     */\n     public void add(NodeSet nodeSet) {\n         if (pointers.addAll(nodeSet.getPointers())) {\n             clearCacheLists();\n         }\n     }\n \n+    /**\n+     * Remove a pointer from this NodeSet.\n+     * @param pointer to remove\n+     */\n     public void remove(Pointer pointer) {\n         if (pointers.remove(pointer)) {\n             clearCacheLists();\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public synchronized List getPointers() {\n         if (readOnlyPointers == null) {\n             readOnlyPointers = Collections.unmodifiableList(pointers);\n         return readOnlyPointers;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public synchronized List getNodes() {\n         if (nodes == null) {\n             nodes = new ArrayList();\n         return nodes;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public synchronized List getValues() {\n         if (values == null) {\n             values = new ArrayList();\n         return values;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return pointers.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/BasicVariables.java\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n         vars.remove(varName);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return vars.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/CompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/CompiledExpression.java\n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n+     * @param context to evaluate\n+     * @return Object\n      */\n     Object getValue(JXPathContext context);\n \n     /**\n      * Evaluates the xpath, converts the result to the specified class and\n      * returns the resulting object.\n+     * @param context to evaluate\n+     * @param requiredType return type\n+     * @return Object\n      */\n     Object getValue(JXPathContext context, Class requiredType);\n \n      * <li>The xpath does not in fact describe an existing property\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n+     * @param context base\n+     * @param value to set\n      */\n     void setValue(JXPathContext context, Object value);\n \n      * Creates intermediate elements of\n      * the path by invoking an AbstractFactory, which should first be\n      * installed on the context by calling \"setFactory\".\n+     * @param context base\n+     * @return Pointer created\n      */\n     Pointer createPath(JXPathContext context);\n \n      * element.\n      * <li>The property is not writable (no public, non-static set method)\n      * </ul>\n+     * @param context base\n+     * @param value to set\n+     * @return Pointer created\n      */\n     Pointer createPathAndSetValue(JXPathContext context, Object value);\n \n      * Traverses the xpath and returns a Iterator of all results found\n      * for the path. If the xpath matches no properties\n      * in the graph, the Iterator will not be null.\n+     * @param context base\n+     * @return Iterator\n      */\n     Iterator iterate(JXPathContext context);\n \n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n      * in the graph, the pointer will be null.\n+     * @param context base\n+     * @param xpath string\n+     * @return Pointer found\n      */\n     Pointer getPointer(JXPathContext context, String xpath);\n \n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n      * in the graph, the Iterator be empty, but not null.\n+     * @param context to iterate\n+     * @return Iterator<Pointer>\n      */\n     Iterator iteratePointers(JXPathContext context);\n \n     /**\n-     * Remove the graph element described by this expression\n+     * Remove the graph element described by this expression.\n+     * @param context base\n      */\n     void removePath(JXPathContext context);\n \n     /**\n-     * Remove all graph elements described by this expression\n+     * Remove all graph elements described by this expression.\n+     * @param context base\n      */\n     void removeAll(JXPathContext context);\n }\n--- a/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n \n     /**\n      * Returns a list of dynamic property names for the supplied object.\n+     * @param object to inspect\n+     * @return String[]\n      */\n     String[] getPropertyNames(Object object);\n \n     /**\n      * Returns the value of the specified dynamic property.\n+     * @param object to search\n+     * @param propertyName to retrieve\n+     * @return Object\n      */\n     Object getProperty(Object object, String propertyName);\n \n     /**\n      * Modifies the value of the specified dynamic property.\n+     * @param object to modify\n+     * @param propertyName to modify\n+     * @param value to set\n      */\n     void setProperty(Object object, String propertyName, Object value);\n }\n--- a/src/java/org/apache/commons/jxpath/ExpressionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ExpressionContext.java\n \n     /**\n      * Returns the current context position.\n+     * @return int\n      */\n     int getPosition();\n }\n--- a/src/java/org/apache/commons/jxpath/ExtendedKeyManager.java\n+++ b/src/java/org/apache/commons/jxpath/ExtendedKeyManager.java\n \n     /**\n      * Find a NodeSet by key/value.\n-     * @param context\n-     * @param key\n-     * @param value\n+     * @param context base\n+     * @param key String\n+     * @param value Object\n+     * @return NodeSet found\n      */\n     NodeSet getNodeSetByKey(JXPathContext context, String key, Object value);\n \n--- a/src/java/org/apache/commons/jxpath/Function.java\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n      *\n      * @param context can be used to acquire the context in which the\n      *    function is being evaluted.\n+     * @param parameters function arguments\n+     * @return Object result\n      */\n     Object invoke(ExpressionContext context, Object[] parameters);\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n \n     private static final long serialVersionUID = -4403564377958943239L;\n \n+    /**\n+     * Create a new JXPathAbstractFactoryException.\n+     * @param message exception message\n+     */\n     public JXPathAbstractFactoryException(String message) {\n         super(message);\n     }\n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n     private boolean atomic = false;\n     private Class clazz;\n-    private PropertyDescriptor propertyDescriptors[];\n+    private PropertyDescriptor[] propertyDescriptors;\n     private Class dynamicPropertyHandlerClass;\n     private HashMap propertyDescriptorMap;\n \n--- a/src/java/org/apache/commons/jxpath/JXPathException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathException.java\n      * Create a new <code>JXPathException</code> with the\n      * given <code>Exception</code> base cause and detail message.\n      *\n-     * @param e The exception to be encapsulated in a\n-     * JXPathException\n      * @param msg The detail message.\n+     * @param e The exception to be encapsulated in a JXPathException\n      */\n     public JXPathException(String msg, Throwable e) {\n         super(msg);\n \n     /**\n      * Same as {@link #getException() getException()}\n+     * @return The encapsulated exception, or null if there is none.\n      */\n     public Throwable getCause() {\n         return exception;\n--- a/src/java/org/apache/commons/jxpath/JXPathFunctionNotFoundException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathFunctionNotFoundException.java\n \n     private static final long serialVersionUID = -8875537628056117241L;\n \n+    /**\n+     * Create a new JXPathFunctionNotFoundException.\n+     * @param message exception message\n+     */\n     public JXPathFunctionNotFoundException(String message) {\n         super(message);\n     }\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n     /**\n      * Automatically creates and registers a JXPathBeanInfo object\n      * for the specified class. That object returns true to isAtomic().\n+     * @param beanClass to register\n      */\n     public static void registerAtomicClass(Class beanClass) {\n         byClass.put(beanClass, new JXPathBasicBeanInfo(beanClass, true));\n     /**\n      * Automatically creates and registers a JXPathBeanInfo object\n      * for the specified class. That object returns true to isDynamic().\n-     */\n-    public static void registerDynamicClass(\n-        Class beanClass,\n-        Class dynamicPropertyHandlerClass)\n-    {\n+     * @param beanClass to register\n+     * @param dynamicPropertyHandlerClass to handle beanClass\n+     */\n+    public static void registerDynamicClass(Class beanClass,\n+            Class dynamicPropertyHandlerClass) {\n         JXPathBasicBeanInfo bi =\n             new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass);\n         if (beanClass.isInterface()) {\n     }\n \n     /**\n-     * Creates  and registers a JXPathBeanInfo object for the supplied class. If\n+     * Creates and registers a JXPathBeanInfo object for the supplied class. If\n      * the class has already been registered, returns the registered\n      * JXPathBeanInfo object.\n      * <p>\n      * <li>Otherwise, an instance of {@link JXPathBasicBeanInfo\n      *     JXPathBasicBeanInfo}  is allocated.\n      * </ul>\n+     * @param beanClass whose info to get\n+     * @return JXPathBeanInfo\n      */\n     public static JXPathBeanInfo getBeanInfo(Class beanClass) {\n         JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass);\n     /**\n      * Find a dynamic bean info if available for any superclasses or\n      * interfaces.\n+     * @param beanClass to search for\n+     * @return JXPathBeanInfo\n      */\n     private static JXPathBeanInfo findDynamicBeanInfo(Class beanClass) {\n         JXPathBeanInfo beanInfo = null;\n             }\n         }\n \n-        Class interfaces[] = beanClass.getInterfaces();\n+        Class[] interfaces = beanClass.getInterfaces();\n         if (interfaces != null) {\n             for (int i = 0; i < interfaces.length; i++) {\n                 beanInfo = findDynamicBeanInfo(interfaces[i]);\n         return null;\n     }\n \n+    /**\n+     * find a JXPathBeanInfo instance for the specified class.\n+     * Similar to javax.beans property handler discovery; search for a\n+     * class with \"XBeanInfo\" appended to beanClass.name, then check\n+     * whether beanClass implements JXPathBeanInfo for itself.\n+     * Invokes the default constructor for any class it finds.\n+     * @param beanClass for which to look for an info provider\n+     * @return JXPathBeanInfo instance or null if none found\n+     */\n     private static synchronized JXPathBeanInfo findInformant(Class beanClass) {\n         String name = beanClass.getName() + \"XBeanInfo\";\n         try {\n      * Try to create an instance of a named class.\n      * First try the classloader of \"sibling\", then try the system\n      * classloader.\n+     * @param sibling Class\n+     * @param className to instantiate\n+     * @return new Object\n+     * @throws Exception if instantiation fails\n      */\n     private static Object instantiate(Class sibling, String className)\n-        throws Exception\n-    {\n+            throws Exception {\n \n         // First check with sibling's classloader (if any).\n         ClassLoader cl = sibling.getClassLoader();\n--- a/src/java/org/apache/commons/jxpath/JXPathTypeConversionException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathTypeConversionException.java\n \n     private static final long serialVersionUID = -4403564377958943239L;\n \n+    /**\n+     * Create a new JXPathTypeConversionException.\n+     * @param message exception text\n+     */\n     public JXPathTypeConversionException(String message) {\n         super(message);\n     }\n \n+    /**\n+     * Create a new JXPathTypeConversionException.\n+     * @param message exception text\n+     * @param ex underlying cause\n+     */\n     public JXPathTypeConversionException(String message, Exception ex) {\n         super(message, ex);\n     }\n--- a/src/java/org/apache/commons/jxpath/KeyManager.java\n+++ b/src/java/org/apache/commons/jxpath/KeyManager.java\n \n     /**\n      * Find a node by key/value.\n+     * @param context to search\n+     * @param keyName String\n+     * @param keyValue String\n+     * @return Pointer\n      */\n     Pointer getPointerByKey(\n         JXPathContext context,\n--- a/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n public class MapDynamicPropertyHandler implements DynamicPropertyHandler {\n \n     /**\n-     * Returns string representations of all keys in the map.\n+     * {@inheritDoc}\n      */\n     public String[] getPropertyNames(Object object) {\n         Map map = (Map) object;\n         Set set = map.keySet();\n-        String names[] = new String[set.size()];\n+        String[] names = new String[set.size()];\n         Iterator it = set.iterator();\n         for (int i = 0; i < names.length; i++) {\n             names[i] = String.valueOf(it.next());\n     }\n \n     /**\n-     * Returns the value for the specified key.\n+     * {@inheritDoc}\n      */\n     public Object getProperty(Object object, String propertyName) {\n         return ((Map) object).get(propertyName);\n     }\n \n     /**\n-     * Sets the specified key value.\n+     * {@inheritDoc}\n      */\n     public void setProperty(Object object, String propertyName, Object value) {\n         ((Map) object).put(propertyName, value);\n--- a/src/java/org/apache/commons/jxpath/NodeSet.java\n+++ b/src/java/org/apache/commons/jxpath/NodeSet.java\n \n     /**\n      * Returns a list of nodes.\n+     * @return List\n      */\n     List getNodes();\n \n     /**\n      * Returns a list of pointers for all nodes in the set.\n+     * @return List\n      */\n     List getPointers();\n \n     /**\n      * Returns a list of values of all contained pointers.\n+     * @return List\n      */\n     List getValues();\n \n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n \n     /**\n      * Returns the node this pointer is based on.\n-     * @return\n+     * @return Object\n      */\n     Object getRootNode();\n \n      * If an object in the pointer's path is a Dynamic Property object (like a\n      * Map), the asPath method generates an XPath that looks like this: <code>\"\n      * /departments[@name = 'HR']/employees[3]\"</code>.\n+     * @return String path\n      */\n     String asPath();\n \n     /**\n-     * Pointers are cloneable\n+     * Pointers are cloneable.\n+     * @return cloned Object\n      */\n     Object clone();\n }\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n  * @version $Revision$ $Date$\n  */\n public class ConstructorFunction implements Function {\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n \n     private Constructor constructor;\n-    private static final Object EMPTY_ARRAY[] = new Object[0];\n \n+    /**\n+     * Create a new ConstructorFunction.\n+     * @param constructor the constructor to call.\n+     */\n     public ConstructorFunction(Constructor constructor) {\n         this.constructor = constructor;\n     }\n \n     /**\n      * Converts parameters to suitable types and invokes the constructor.\n+     * @param context evaluation context\n+     * @param parameters constructor args\n+     * @return new instance\n      */\n     public Object invoke(ExpressionContext context, Object[] parameters) {\n         try {\n                 parameters = EMPTY_ARRAY;\n             }\n             int pi = 0;\n-            Class types[] = constructor.getParameterTypes();\n+            Class[] types = constructor.getParameterTypes();\n             if (types.length > 0\n                 && ExpressionContext.class.isAssignableFrom(types[0])) {\n                 pi = 1;\n--- a/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n     private static final Double ONE = new Double(1);\n     private static final Double NOT_A_NUMBER = new Double(Double.NaN);\n \n-\n     /**\n-     * Converts the supplied object to String\n+     * Converts the supplied object to String.\n+     * @param object to convert\n+     * @return String value\n      */\n     public static String stringValue(Object object) {\n         if (object instanceof String) {\n     }\n \n     /**\n-     * Converts the supplied object to Number\n+     * Converts the supplied object to Number.\n+     * @param object to convert\n+     * @return Number result\n      */\n     public static Number number(Object object) {\n         if (object instanceof Number) {\n     }\n \n     /**\n-     * Converts the supplied object to double\n+     * Converts the supplied object to double.\n+     * @param object to convert\n+     * @return double\n      */\n     public static double doubleValue(Object object) {\n         if (object instanceof Number) {\n     }\n \n     /**\n-     * Converts the supplied object to boolean\n+     * Converts the supplied object to boolean.\n+     * @param object to convert\n+     * @return boolean\n      */\n     public static boolean booleanValue(Object object) {\n         if (object instanceof Number) {\n             double value = ((Number) object).doubleValue();\n-            return value != 0 && value != -0 && !Double.isNaN(value);\n+            final int negZero = -0;\n+            return value != 0 && value != negZero && !Double.isNaN(value);\n         }\n         if (object instanceof Boolean) {\n             return ((Boolean) object).booleanValue();\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n import org.apache.commons.jxpath.Pointer;\n \n /**\n- *\n+ * RI of CompiledExpression.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n     private String xpath;\n     private Expression expression;\n \n+    /**\n+     * Create a new JXPathCompiledExpression.\n+     * @param xpath source\n+     * @param expression compiled\n+     */\n     public JXPathCompiledExpression(String xpath, Expression expression) {\n         this.xpath = xpath;\n         this.expression = expression;\n     }\n \n+    /**\n+     * Get the source expression.\n+     * @return String\n+     */\n     protected String getXPath() {\n         return xpath;\n     }\n \n+    /**\n+     * Get the compiled expression.\n+     * @return Expression\n+     */\n     protected Expression getExpression() {\n         return expression;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return xpath;\n     }\n \n     /**\n-     * @see CompiledExpression#getValue(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public Object getValue(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#getValue(JXPathContext, Class)\n+     * {@inheritDoc}\n      */\n     public Object getValue(JXPathContext context, Class requiredType) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#setValue(JXPathContext, Object)\n+     * {@inheritDoc}\n      */\n     public void setValue(JXPathContext context, Object value) {\n         ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#createPath(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public Pointer createPath(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#createPathAndSetValue(JXPathContext, Object)\n+     * {@inheritDoc}\n      */\n     public Pointer createPathAndSetValue(JXPathContext context, Object value) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#iterate(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public Iterator iterate(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#getPointer(JXPathContext, String)\n+     * {@inheritDoc}\n      */\n     public Pointer getPointer(JXPathContext context, String xpath) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#iteratePointers(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public Iterator iteratePointers(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n     }\n \n     /**\n-     * @see CompiledExpression#removePath(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public void removePath(JXPathContext context) {\n         ((JXPathContextReferenceImpl) context).removePath(xpath, expression);\n     }\n \n     /**\n-     * @see CompiledExpression#removeAll(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public void removeAll(JXPathContext context) {\n         ((JXPathContextReferenceImpl) context).removeAll(xpath, expression);\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n     private static Map compiled = new HashMap();\n     private static int cleanupCount = 0;\n \n+    private static NodePointerFactory[] nodeFactoryArray = null;\n+    // The frequency of the cache cleanup\n+    private static final int CLEANUP_THRESHOLD = 500;\n     private static final Vector nodeFactories = new Vector();\n-    private static NodePointerFactory nodeFactoryArray[] = null;\n+\n     static {\n         nodeFactories.add(new CollectionPointerFactory());\n         nodeFactories.add(new BeanPointerFactory());\n         createNodeFactoryArray();\n     }\n \n-    private Pointer rootPointer;\n-    private Pointer contextPointer;\n-\n-    protected NamespaceResolver namespaceResolver;\n-\n-    // The frequency of the cache cleanup\n-    private static final int CLEANUP_THRESHOLD = 500;\n-\n-    protected JXPathContextReferenceImpl(JXPathContext parentContext,\n-                                         Object contextBean)\n-    {\n-        this(parentContext, contextBean, null);\n-    }\n-\n-    public JXPathContextReferenceImpl(\n-        JXPathContext parentContext,\n-        Object contextBean,\n-        Pointer contextPointer)\n-    {\n-        super(parentContext, contextBean);\n-\n-        synchronized (nodeFactories) {\n-            createNodeFactoryArray();\n-        }\n-\n-        if (contextPointer != null) {\n-            this.contextPointer = contextPointer;\n-            this.rootPointer =\n-                NodePointer.newNodePointer(\n-                    new QName(null, \"root\"),\n-                    contextPointer.getRootNode(),\n-                    getLocale());\n-        }\n-        else {\n-            this.contextPointer =\n-                NodePointer.newNodePointer(\n-                    new QName(null, \"root\"),\n-                    contextBean,\n-                    getLocale());\n-            this.rootPointer = this.contextPointer;\n-        }\n-\n-        NamespaceResolver parentNR = null;\n-        if (parentContext instanceof JXPathContextReferenceImpl) {\n-            parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver();\n-        }\n-        namespaceResolver = new NamespaceResolver(parentNR);\n-        namespaceResolver\n-                .setNamespaceContextPointer((NodePointer) this.contextPointer);\n-    }\n-\n+    /**\n+     * Create the default node factory array.\n+     */\n     private static void createNodeFactoryArray() {\n         if (nodeFactoryArray == null) {\n             nodeFactoryArray =\n      * Call this with a custom NodePointerFactory to add support for\n      * additional types of objects.  Make sure the factory returns\n      * a name that puts it in the right position on the list of factories.\n+     * @param factory NodePointerFactory to add\n      */\n     public static void addNodePointerFactory(NodePointerFactory factory) {\n         synchronized (nodeFactories) {\n         }\n     }\n \n+    /**\n+     * Get the registered NodePointerFactories.\n+     * @return NodePointerFactory[]\n+     */\n     public static NodePointerFactory[] getNodePointerFactories() {\n         return nodeFactoryArray;\n     }\n \n+    /** Namespace resolver */\n+    protected NamespaceResolver namespaceResolver;\n+\n+    private Pointer rootPointer;\n+    private Pointer contextPointer;\n+\n+    /**\n+     * Create a new JXPathContextReferenceImpl.\n+     * @param parentContext parent context\n+     * @param contextBean Object\n+     */\n+    protected JXPathContextReferenceImpl(JXPathContext parentContext,\n+            Object contextBean) {\n+        this(parentContext, contextBean, null);\n+    }\n+\n+    /**\n+     * Create a new JXPathContextReferenceImpl.\n+     * @param parentContext parent context\n+     * @param contextBean Object\n+     * @param contextPointer context pointer\n+     */\n+    public JXPathContextReferenceImpl(JXPathContext parentContext,\n+            Object contextBean, Pointer contextPointer) {\n+        super(parentContext, contextBean);\n+\n+        synchronized (nodeFactories) {\n+            createNodeFactoryArray();\n+        }\n+\n+        if (contextPointer != null) {\n+            this.contextPointer = contextPointer;\n+            this.rootPointer =\n+                NodePointer.newNodePointer(\n+                    new QName(null, \"root\"),\n+                    contextPointer.getRootNode(),\n+                    getLocale());\n+        }\n+        else {\n+            this.contextPointer =\n+                NodePointer.newNodePointer(\n+                    new QName(null, \"root\"),\n+                    contextBean,\n+                    getLocale());\n+            this.rootPointer = this.contextPointer;\n+        }\n+\n+        NamespaceResolver parentNR = null;\n+        if (parentContext instanceof JXPathContextReferenceImpl) {\n+            parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver();\n+        }\n+        namespaceResolver = new NamespaceResolver(parentNR);\n+        namespaceResolver\n+                .setNamespaceContextPointer((NodePointer) this.contextPointer);\n+    }\n+\n     /**\n      * Returns a static instance of TreeCompiler.\n      *\n-     * Override this to return an aternate compiler.\n+     * Override this to return an alternate compiler.\n+     * @return Compiler\n      */\n     protected Compiler getCompiler() {\n         return COMPILER;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected CompiledExpression compilePath(String xpath) {\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Compile the given expression.\n+     * @param xpath to compile\n+     * @return Expression\n+     */\n     private Expression compileExpression(String xpath) {\n         Expression expr;\n \n     /**\n      * Traverses the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n+     * @param xpath expression\n+     * @return Object found\n      */\n     public Object getValue(String xpath) {\n         Expression expression = compileExpression(xpath);\n //        return null;\n //    }\n \n+    /**\n+     * Get the value indicated.\n+     * @param xpath String\n+     * @param expr Expression\n+     * @return Object\n+     */\n     public Object getValue(String xpath, Expression expr) {\n         Object result = expr.computeValue(getEvalContext());\n         if (result == null) {\n     /**\n      * Calls getValue(xpath), converts the result to the required type\n      * and returns the result of the conversion.\n+     * @param xpath expression\n+     * @param requiredType Class\n+     * @return Object\n      */\n     public Object getValue(String xpath, Class requiredType) {\n         Expression expr = compileExpression(xpath);\n         return getValue(xpath, expr, requiredType);\n     }\n \n+    /**\n+     * Get the value indicated.\n+     * @param xpath expression\n+     * @param expr compiled Expression\n+     * @param requiredType Class\n+     * @return Object\n+     */\n     public Object getValue(String xpath, Expression expr, Class requiredType) {\n         Object value = getValue(xpath, expr);\n         if (value != null && requiredType != null) {\n      * Traverses the xpath and returns a Iterator of all results found\n      * for the path. If the xpath matches no properties\n      * in the graph, the Iterator will not be null.\n+     * @param xpath expression\n+     * @return Iterator\n      */\n     public Iterator iterate(String xpath) {\n         return iterate(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Traverses the xpath and returns a Iterator of all results found\n+     * for the path. If the xpath matches no properties\n+     * in the graph, the Iterator will not be null.\n+     * @param xpath expression\n+     * @param expr compiled Expression\n+     * @return Iterator\n+     */\n     public Iterator iterate(String xpath, Expression expr) {\n         return expr.iterate(getEvalContext());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getPointer(String xpath) {\n         return getPointer(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Get a pointer to the specified path/expression.\n+     * @param xpath String\n+     * @param expr compiled Expression\n+     * @return Pointer\n+     */\n     public Pointer getPointer(String xpath, Expression expr) {\n         Object result = expr.computeValue(getEvalContext());\n         if (result instanceof EvalContext) {\n         return NodePointer.newNodePointer(null, result, getLocale());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(String xpath, Object value) {\n         setValue(xpath, compileExpression(xpath), value);\n     }\n \n+    /**\n+     * Set the value of xpath to value.\n+     * @param xpath path\n+     * @param expr compiled Expression\n+     * @param value Object\n+     */\n     public void setValue(String xpath, Expression expr, Object value) {\n         try {\n             setValue(xpath, expr, value, false);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer createPath(String xpath) {\n         return createPath(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Create the given path.\n+     * @param xpath String\n+     * @param expr compiled Expression\n+     * @return resulting Pointer\n+     */\n     public Pointer createPath(String xpath, Expression expr) {\n         try {\n             Object result = expr.computeValue(getEvalContext());\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer createPathAndSetValue(String xpath, Object value) {\n         return createPathAndSetValue(xpath, compileExpression(xpath), value);\n     }\n \n-    public Pointer createPathAndSetValue(\n-        String xpath,\n-        Expression expr,\n-        Object value)\n-    {\n+    /**\n+     * Create the given path setting its value to value.\n+     * @param xpath String\n+     * @param expr compiled Expression\n+     * @param value Object\n+     * @return resulting Pointer\n+     */\n+    public Pointer createPathAndSetValue(String xpath, Expression expr,\n+            Object value) {\n         try {\n             return setValue(xpath, expr, value, true);\n         }\n         }\n     }\n \n-    private Pointer setValue(\n-        String xpath,\n-        Expression expr,\n-        Object value,\n-        boolean create)\n-    {\n+    /**\n+     * Set the specified value.\n+     * @param xpath path\n+     * @param expr compiled Expression\n+     * @param value destination value\n+     * @param create whether to create missing node(s)\n+     * @return Pointer created\n+     */\n+    private Pointer setValue(String xpath, Expression expr, Object value,\n+            boolean create) {\n         Object result = expr.computeValue(getEvalContext());\n         Pointer pointer = null;\n \n     /**\n      * Checks if the path follows the JXPath restrictions on the type\n      * of path that can be passed to create... methods.\n+     * @param expr Expression to check\n      */\n     private void checkSimplePath(Expression expr) {\n         if (!(expr instanceof LocationPath)\n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n      * in the graph, the Iterator be empty, but not null.\n+     * @param xpath expression\n+     * @return Iterator\n      */\n     public Iterator iteratePointers(String xpath) {\n         return iteratePointers(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Traverses the xpath and returns an Iterator of Pointers.\n+     * A Pointer provides easy access to a property.\n+     * If the xpath matches no properties\n+     * in the graph, the Iterator be empty, but not null.\n+     * @param xpath expression\n+     * @param expr compiled Expression\n+     * @return Iterator\n+     */\n     public Iterator iteratePointers(String xpath, Expression expr) {\n         return expr.iteratePointers(getEvalContext());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void removePath(String xpath) {\n         removePath(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Remove the specified path.\n+     * @param xpath expression\n+     * @param expr compiled Expression\n+     */\n     public void removePath(String xpath, Expression expr) {\n         try {\n             NodePointer pointer = (NodePointer) getPointer(xpath, expr);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void removeAll(String xpath) {\n         removeAll(xpath, compileExpression(xpath));\n     }\n \n+    /**\n+     * Remove all matching nodes.\n+     * @param xpath expression\n+     * @param expr compiled Expression\n+     */\n     public void removeAll(String xpath, Expression expr) {\n         try {\n             ArrayList list = new ArrayList();\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public JXPathContext getRelativeContext(Pointer pointer) {\n         Object contextBean = pointer.getNode();\n         if (contextBean == null) {\n         return new JXPathContextReferenceImpl(this, contextBean, pointer);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getContextPointer() {\n         return contextPointer;\n     }\n \n+    /**\n+     * Get absolute root pointer.\n+     * @return NodePointer\n+     */\n     private NodePointer getAbsoluteRootPointer() {\n         return (NodePointer) rootPointer;\n     }\n \n+    /**\n+     * Get the evaluation context.\n+     * @return EvalContext\n+     */\n     private EvalContext getEvalContext() {\n         return new InitialContext(new RootContext(this,\n                 (NodePointer) getContextPointer()));\n     }\n \n+    /**\n+     * Get the absolute root context.\n+     * @return EvalContext\n+     */\n     public EvalContext getAbsoluteRootContext() {\n         return new InitialContext(new RootContext(this,\n                 getAbsoluteRootPointer()));\n     }\n \n+    /**\n+     * Get a VariablePointer for the given variable name.\n+     * @param name variable name\n+     * @return NodePointer\n+     */\n     public NodePointer getVariablePointer(QName name) {\n         return NodePointer.newNodePointer(name, VariablePointerFactory\n                 .contextWrapper(this), getLocale());\n     }\n \n+    /**\n+     * Get the named Function.\n+     * @param functionName name\n+     * @param parameters function args\n+     * @return Function\n+     */\n     public Function getFunction(QName functionName, Object[] parameters) {\n         String namespace = functionName.getPrefix();\n         String name = functionName.getName();\n             \"Undefined function: \" + functionName.toString());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void registerNamespace(String prefix, String namespaceURI) {\n         if (namespaceResolver.isSealed()) {\n             namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n         namespaceResolver.registerNamespace(prefix, namespaceURI);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI(String prefix) {\n         return namespaceResolver.getNamespaceURI(prefix);\n     }\n         return namespaceResolver.getPrefix(namespaceURI);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setNamespaceContextPointer(Pointer pointer) {\n         if (namespaceResolver.isSealed()) {\n             namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n         namespaceResolver.setNamespaceContextPointer((NodePointer) pointer);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getNamespaceContextPointer() {\n         return namespaceResolver.getNamespaceContextPointer();\n     }\n \n+    /**\n+     * Get the namespace resolver.\n+     * @return NamespaceResolver\n+     */\n     public NamespaceResolver getNamespaceResolver() {\n         namespaceResolver.seal();\n         return namespaceResolver;\n     /**\n      * Checks if existenceCheckClass exists on the class path. If so, allocates\n      * an instance of the specified class, otherwise returns null.\n-     */\n-    public static Object allocateConditionally(\n-            String className,\n-            String existenceCheckClassName)\n-    {\n+     * @param className to instantiate\n+     * @param existenceCheckClassName guard class\n+     * @return className instance\n+     */\n+    public static Object allocateConditionally(String className,\n+            String existenceCheckClassName) {\n         try {\n             try {\n                 Class.forName(existenceCheckClassName);\n--- a/src/java/org/apache/commons/jxpath/ri/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n     private String name;\n     private String qualifiedName;\n \n+    /**\n+     * Create a new QName.\n+     * @param qualifiedName value\n+     */\n     public QName(String qualifiedName) {\n         this.qualifiedName = qualifiedName;\n         int index = qualifiedName.indexOf(':');\n         name = index < 0 ? qualifiedName : qualifiedName.substring(index + 1);\n     }\n \n+    /**\n+     * Create a new QName.\n+     * @param prefix ns\n+     * @param localName String\n+     */\n     public QName(String prefix, String localName) {\n         this.prefix = prefix;\n         this.name = localName;\n         this.qualifiedName = prefix == null ? localName : prefix + ':' + localName;\n     }\n \n+    /**\n+     * Get the prefix of this QName.\n+     * @return String\n+     */\n     public String getPrefix() {\n         return prefix;\n     }\n \n+    /**\n+     * Get the local name.\n+     * @return String\n+     */\n     public String getName() {\n         return name;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return qualifiedName;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return name.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (this == object) {\n             return true;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n      * @param startFromParentLocation whether to start from parent location\n      * @param reverse whether to iterate in reverse\n      */\n-    public ChildContext(\n-        EvalContext parentContext,\n-        NodeTest nodeTest,\n-        boolean startFromParentLocation,\n-        boolean reverse)\n-    {\n+    public ChildContext(EvalContext parentContext, NodeTest nodeTest,\n+            boolean startFromParentLocation, boolean reverse) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n         this.startFromParentLocation = startFromParentLocation;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n     private Expression nameTestExpression;\n     private PropertyPointer dynamicPropertyPointer;\n \n+    /**\n+     * Create a new PredicateContext.\n+     * @param parentContext parent context\n+     * @param expression compiled Expression\n+     */\n     public PredicateContext(EvalContext parentContext, Expression expression) {\n         super(parentContext);\n         this.expression = expression;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         if (done) {\n             return false;\n                 // if the property is currently declared. Thus,\n                 // we'll need to perform a search.\n                 boolean ok = false;\n-                String names[] = dynamicPropertyPointer.getPropertyNames();\n+                String[] names = dynamicPropertyPointer.getPropertyNames();\n                 for (int i = 0; i < names.length; i++) {\n                     if (names[i].equals(propertyName)) {\n                         ok = true;\n     /**\n      * Used for an optimized access to dynamic properties using the\n      * \"map[@name = 'name']\" syntax\n+     * @return whether valid\n      */\n     private boolean setupDynamicPropertyPointer() {\n         if (nameTestExpression == null) {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (nameTestExpression == null) {\n             return setPositionStandard(position);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return parentContext.getCurrentNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         parentContext.reset();\n         done = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextSet() {\n         reset();\n         return parentContext.nextSet();\n     }\n \n+    /**\n+     * Basic setPosition\n+     * @param position to set\n+     * @return whether valid\n+     */\n     private boolean setPositionStandard(int position) {\n         if (this.position > position) {\n             reset();\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * EvalContext  that returns the current node from the parent context if the\n+ * EvalContext that returns the current node from the parent context if the\n  * test succeeds.\n  *\n  * @author Dmitri Plotnikov\n     private boolean startedSet = false;\n     private NodePointer nodePointer;\n \n+    /**\n+     * Create a new SelfContext.\n+     * @param parentContext EvalContext\n+     * @param nodeTest guard\n+     */\n     public SelfContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getSingleNodePointer() {\n         return parentContext.getSingleNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return nodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         startedSet = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position != 1) {\n             return false;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n         }\n \n         if (value instanceof Number) {\n-            return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1;\n+            final double round = 0.5;\n+            return (int) (InfoSetUtil.doubleValue(value) + round) - 1;\n         }\n         return InfoSetUtil.booleanValue(value) ? 0 : -1;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n      * @return String\n      */\n     protected Object functionSubstring(EvalContext context) {\n+        final int minArgs = 2;\n+        final int maxArgs = 3;\n+        assertArgRange(minArgs, maxArgs);\n         int ac = getArgumentCount();\n-        if (ac != 2 && ac != 3) {\n-            assertArgCount(2);\n-        }\n \n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n      * @return String\n      */\n     protected Object functionTranslate(EvalContext context) {\n-        assertArgCount(3);\n+        final int argCount = 3;\n+        assertArgCount(argCount);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n      * @return String\n      */\n     private Object functionFormatNumber(EvalContext context) {\n-        int ac = getArgumentCount();\n-        if (ac != 2 && ac != 3) {\n-            assertArgCount(2);\n-        }\n+        final int minArgs = 2;\n+        final int maxArgs = 3;\n+        assertArgRange(minArgs, maxArgs);\n \n         double number =\n             InfoSetUtil.doubleValue(getArg1().computeValue(context));\n             InfoSetUtil.stringValue(getArg2().computeValue(context));\n \n         DecimalFormatSymbols symbols = null;\n-        if (ac == 3) {\n+        if (getArgumentCount() == maxArgs) {\n             String symbolsName =\n                 InfoSetUtil.stringValue(getArg3().computeValue(context));\n             symbols =\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n  */\n public class CoreOperationGreaterThan extends CoreOperationRelationalExpression {\n \n+    /**\n+     * Create a new CoreOperationGreaterThan.\n+     * @param arg1 left operand\n+     * @param arg2 right operand\n+     */\n     public CoreOperationGreaterThan(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean evaluateCompare(int compare) {\n         return compare > 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \">\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n \n     /**\n      * Template method for subclasses to evaluate the result of a comparison.\n-     * @param compare result of comparison to evaluate \n+     * @param compare result of comparison to evaluate\n      * @return ultimate operation success/failure\n      */\n     protected abstract boolean evaluateCompare(int compare);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n public class ExpressionPath extends Path {\n \n     private Expression expression;\n-    private Expression predicates[];\n+    private Expression[] predicates;\n \n     private boolean basicKnown = false;\n     private boolean basic;\n \n-    public ExpressionPath(\n-        Expression expression,\n-        Expression[] predicates,\n-        Step[] steps)\n-    {\n+    /**\n+     * Create a new ExpressionPath.\n+     * @param expression Expression\n+     * @param predicates to execute\n+     * @param steps navigation\n+     */\n+    public ExpressionPath(Expression expression, Expression[] predicates,\n+            Step[] steps) {\n         super(steps);\n         this.expression = expression;\n         this.predicates = predicates;\n     }\n \n+    /**\n+     * Get the expression.\n+     * @return Expression\n+     */\n     public Expression getExpression() {\n         return expression;\n     }\n     /**\n      * Predicates are the expressions in brackets that may follow\n      * the root expression of the path.\n+     * @return Expression[]\n      */\n     public Expression[] getPredicates() {\n         return predicates;\n     /**\n      * Returns true if the root expression or any of the\n      * predicates or the path steps are context dependent.\n+     * @return boolean\n      */\n     public boolean computeContextDependent() {\n         if (expression.isContextDependent()) {\n     /**\n      * Recognized paths formatted as <code>$x[3]/foo[2]</code>.  The\n      * evaluation of such \"simple\" paths is optimized and streamlined.\n+     * @return boolean\n      */\n     public synchronized boolean isSimpleExpressionPath() {\n         if (!basicKnown) {\n         return basic;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         if (expression instanceof CoreOperation\n             }\n         }\n \n-        Step steps[] = getSteps();\n+        Step[] steps = getSteps();\n         if (steps != null) {\n             for (int i = 0; i < steps.length; i++) {\n                 buffer.append(\"/\");\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return expressionPath(context, false);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         return expressionPath(context, true);\n     }\n \n     /**\n      * Walks an expression path (a path that starts with an expression)\n-     */\n-    protected Object expressionPath(\n-        EvalContext evalContext,\n-        boolean firstMatch)\n-    {\n+     * @param evalContext base context\n+     * @param firstMatch whether to return the first match found\n+     * @return Object found\n+     */\n+    protected Object expressionPath(EvalContext evalContext, boolean firstMatch) {\n         Object value = expression.compute(evalContext);\n         EvalContext context;\n         if (value instanceof InitialContext) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n \n     private boolean absolute;\n \n+    /**\n+     * Create a new LocationPath.\n+     * @param absolute whether this is an absolute path\n+     * @param steps to evaluate\n+     */\n     public LocationPath(boolean absolute, Step[] steps) {\n         super(steps);\n         this.absolute = absolute;\n     }\n \n+    /**\n+     * Learn whether this LocationPath is absolute.\n+     * @return boolean\n+     */\n     public boolean isAbsolute() {\n         return absolute;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean computeContextDependent() {\n         return !absolute || super.computeContextDependent();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n-        Step steps[] = getSteps();\n+        Step[] steps = getSteps();\n         if (steps != null) {\n             for (int i = 0; i < steps.length; i++) {\n                 if (i > 0 || absolute) {\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n         return evalSteps(rootContext);\n     }\n \n-\n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n                 return \"comment\";\n             case Compiler.NODE_TYPE_PI :\n                 return \"processing-instruction\";\n+            default:\n+                return \"UNKNOWN\";\n         }\n-        return \"UNKNOWN\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n                 if (sb.charAt(pos) == c[i]) {\n                     sb.replace(pos, pos + 1, esc[i]);\n                     pos += esc[i].length();\n-                } else {\n+                }\n+                else {\n                     pos++;\n                 }\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n     private Object bean;\n     private JXPathBeanInfo beanInfo;\n \n-    public BeanPointer(\n-            QName name,\n-            Object bean,\n-            JXPathBeanInfo beanInfo,\n-            Locale locale)\n-    {\n+    /**\n+     * Create a new BeanPointer.\n+     * @param name is the name given to the first node\n+     * @param bean pointed\n+     * @param beanInfo JXPathBeanInfo\n+     * @param locale Locale\n+     */\n+    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo,\n+            Locale locale) {\n         super(null, locale);\n         this.name = name;\n         this.bean = bean;\n     }\n \n     /**\n+     * Create a new BeanPointer.\n+     * @param parent pointer\n      * @param name is the name given to the first node\n+     * @param bean pointed\n+     * @param beanInfo JXPathBeanInfo\n      */\n-    public BeanPointer(\n-            NodePointer parent,\n-            QName name,\n-            Object bean,\n-            JXPathBeanInfo beanInfo)\n-    {\n+    public BeanPointer(NodePointer parent, QName name, Object bean,\n+            JXPathBeanInfo beanInfo) {\n         super(parent);\n         this.name = name;\n         this.bean = bean;\n         this.beanInfo = beanInfo;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public PropertyPointer getPropertyPointer() {\n         return new BeanPropertyPointer(this, beanInfo);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return name;\n     }\n \n     /**\n-     * Returns the bean itself\n+     * {@inheritDoc}\n      */\n     public Object getBaseValue() {\n         return bean;\n     }\n \n     /**\n-     * Returns false\n+     * {@inheritDoc}\n+     * @return false\n      */\n     public boolean isCollection() {\n         return false;\n     }\n \n     /**\n-     * Returns 1.\n+     * {@inheritDoc}\n+     * @return 1\n      */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null\n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n     }\n \n     /**\n+     * {@inheritDoc}\n      * If the pointer has a parent, then parent's path.\n      * If the bean is null, \"null()\".\n      * If the bean is a primitive value, the value itself.\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n  */\n public class BeanPointerFactory implements NodePointerFactory {\n \n+    /** factory order constant */\n     public static final int BEAN_POINTER_FACTORY_ORDER = 900;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return BEAN_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(\n-        QName name,\n-        Object bean,\n-        Locale locale)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         return new BeanPointer(name, bean, bi, locale);\n     }\n \n-    public NodePointer createNodePointer(\n-        NodePointer parent,\n-        QName name,\n-        Object bean)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name,\n+            Object bean) {\n         if (bean == null) {\n             return new NullPointer(parent, name);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n  * @version $Revision$ $Date$\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n-\n-    public NodeIterator childIterator(\n-        NodeTest test,\n-        boolean reverse,\n-        NodePointer startWith)\n-    {\n+    private static final Object UNINITIALIZED = new Object();\n+\n+    private Object value = UNINITIALIZED;\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodeIterator childIterator(NodeTest test, boolean reverse,\n+            NodePointer startWith) {\n         if (test == null) {\n             return createNodeIterator(null, reverse, startWith);\n         }\n                 ? createNodeIterator(null, reverse, startWith) : null;\n     }\n \n-    public NodeIterator createNodeIterator(\n-                String property,\n-                boolean reverse,\n-                NodePointer startWith)\n-    {\n+    /**\n+     * Create a NodeIterator.\n+     * @param property property name\n+     * @param reverse whether to iterate in reverse\n+     * @param startWith first pointer to return\n+     * @return NodeIterator\n+     */\n+    public NodeIterator createNodeIterator(String property, boolean reverse,\n+            NodePointer startWith) {\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return new BeanAttributeIterator(this, name);\n     }\n \n+    /**\n+     * Create a new PropertyOwnerPointer.\n+     * @param parent parent pointer\n+     * @param locale Locale\n+     */\n     protected PropertyOwnerPointer(NodePointer parent, Locale locale) {\n         super(parent, locale);\n     }\n \n+    /**\n+     * Create a new PropertyOwnerPointer.\n+     * @param parent pointer\n+     */\n     protected PropertyOwnerPointer(NodePointer parent) {\n         super(parent);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setIndex(int index) {\n         if (this.index != index) {\n             super.setIndex(index);\n         }\n     }\n \n-    private static final Object UNINITIALIZED = new Object();\n-\n-    private Object value = UNINITIALIZED;\n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n             value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n         return value;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public abstract QName getName();\n \n     /**\n     /**\n      * Throws an exception if you try to change the root element, otherwise\n      * forwards the call to the parent pointer.\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         this.value = value;\n     public abstract PropertyPointer getPropertyPointer();\n \n     /**\n+     * Learn whether dynamic property declaration is supported.\n      * @return true if the property owner can set a property \"does not exist\".\n      *         A good example is a Map. You can always assign a value to any\n      *         key even if it has never been \"declared\".\n         return false;\n     }\n \n-    public int compareChildNodePointers(\n-        NodePointer pointer1,\n-        NodePointer pointer2)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int compareChildNodePointers(NodePointer pointer1,\n+            NodePointer pointer2) {\n         int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n         return r == 0 ? pointer1.getIndex() - pointer2.getIndex() : r;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n \n+    /**\n+     * Create a new DOMAttributePointer.\n+     * @param parent pointer\n+     * @param attr pointed\n+     */\n     public DOMAttributePointer(NodePointer parent, Attr attr) {\n         super(parent);\n         this.attr = attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(\n             DOMNodePointer.getPrefix(attr),\n             DOMNodePointer.getLocalName(attr));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         String prefix = DOMNodePointer.getPrefix(attr);\n         return prefix == null ? null : parent.getNamespaceURI(prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         String value = attr.getValue();\n         if (value == null || (value.equals(\"\") && !attr.getSpecified())) {\n         return value;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest nodeTest) {\n         return nodeTest == null\n             || ((nodeTest instanceof NodeTypeTest)\n \n     /**\n      * Sets the value of this attribute.\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         attr.getOwnerElement().removeAttributeNode(attr);\n     }\n \n     /**\n+     * {@inheritDoc}\n      */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof DOMAttributePointer\n                 && attr == ((DOMAttributePointer) object).attr;\n     }\n \n-    public int compareChildNodePointers(\n-        NodePointer pointer1,\n-        NodePointer pointer2)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int compareChildNodePointers(NodePointer pointer1,\n+            NodePointer pointer2) {\n         // Won't happen - attributes don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n import java.util.Locale;\n import java.util.Map;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.JXPathAbstractFactoryException;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n                     return nodeType == Node.COMMENT_NODE;\n                 case Compiler.NODE_TYPE_PI :\n                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n-            }\n-            return false;\n+                default:\n+                    return false;\n+            }\n         }\n         if (test instanceof ProcessingInstructionTest) {\n             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n     /**\n      * {@inheritDoc}\n      */\n-    public NodeIterator childIterator(\n-        NodeTest test,\n-        boolean reverse,\n-        NodePointer startWith)\n-    {\n+    public NodeIterator childIterator(NodeTest test, boolean reverse,\n+            NodePointer startWith) {\n         return new DOMNodeIterator(this, test, reverse, startWith);\n     }\n \n             String qname = \"xmlns:\" + prefix;\n             Node aNode = node;\n             if (aNode instanceof Document) {\n-                aNode = ((Document)aNode).getDocumentElement();\n+                aNode = ((Document) aNode).getDocumentElement();\n             }\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n     }\n \n     /**\n-     * Get the language attribute for this node. \n+     * Get the language attribute for this node.\n      * @return String language name\n      */\n     protected String getLanguage() {\n     /**\n      * {@inheritDoc}\n      */\n-    public NodePointer createChild(\n-        JXPathContext context,\n-        QName name,\n-        int index)\n-    {\n+    public NodePointer createChild(JXPathContext context, QName name, int index) {\n         if (index == WHOLE_COLLECTION) {\n             index = 0;\n         }\n         if (success) {\n             NodeTest nodeTest;\n             String prefix = name.getPrefix();\n-            String namespaceURI = prefix == null ? null :\n-                context.getNamespaceURI(prefix);\n+            String namespaceURI = prefix == null ? null : context\n+                    .getNamespaceURI(prefix);\n             nodeTest = new NodeNameTest(name, namespaceURI);\n \n             NodeIterator it = childIterator(nodeTest, false, null);\n     /**\n      * {@inheritDoc}\n      */\n-    public NodePointer createChild(JXPathContext context,\n-                QName name, int index, Object value)\n-    {\n+    public NodePointer createChild(JXPathContext context, QName name,\n+            int index, Object value) {\n         NodePointer ptr = createChild(context, name, index);\n         ptr.setValue(value);\n         return ptr;\n                 break;\n             case Node.DOCUMENT_NODE :\n                 // That'll be empty\n+                break;\n+            default:\n+                break;\n         }\n         return buffer.toString();\n     }\n             return text == null ? \"\" : trim ? text.trim() : text;\n         }\n         NodeList list = node.getChildNodes();\n-        StringBuffer buf = new StringBuffer(16);\n+        StringBuffer buf = new StringBuffer();\n         for (int i = 0; i < list.getLength(); i++) {\n             Node child = list.item(i);\n             buf.append(stringValue(child));\n     /**\n      * {@inheritDoc}\n      */\n-    public int compareChildNodePointers(\n-            NodePointer pointer1, NodePointer pointer2)\n-    {\n+    public int compareChildNodePointers(NodePointer pointer1,\n+            NodePointer pointer2) {\n         Node node1 = (Node) pointer1.getBaseValue();\n         Node node2 = (Node) pointer2.getBaseValue();\n         if (node1 == node2) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n     private QName name;\n     private DynaBean dynaBean;\n \n+    /**\n+     * Create a new DynaBeanPointer.\n+     * @param name is the name given to the first node\n+     * @param dynaBean pointed\n+     * @param locale Locale\n+     */\n     public DynaBeanPointer(QName name, DynaBean dynaBean, Locale locale) {\n         super(null, locale);\n         this.name = name;\n     }\n \n     /**\n+     * Create a new DynaBeanPointer.\n+     * @param parent pointer\n      * @param name is the name given to the first node\n+     * @param dynaBean pointed\n      */\n     public DynaBeanPointer(NodePointer parent, QName name, DynaBean dynaBean) {\n         super(parent);\n         this.dynaBean = dynaBean;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public PropertyPointer getPropertyPointer() {\n         return new DynaBeanPropertyPointer(this, dynaBean);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return name;\n     }\n \n     /**\n-     * Returns the bean itself\n+     * {@inheritDoc}\n      */\n     public Object getBaseValue() {\n         return dynaBean;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return dynaBean;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n     /**\n-     * Returns 1.\n+     * {@inheritDoc}\n      */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n     }\n \n     /**\n-     * If there's a parent - parent's path, otherwise \"/\".\n+     * {@inheritDoc}\n      */\n     public String asPath() {\n         return parent == null ? \"/\" : super.asPath();\n     }\n \n+    /**\n+     * Learn whether two objects are == || .equals().\n+     * @param o1 first object\n+     * @param o2 second object\n+     * @return boolean\n+     */\n     private static boolean equalObjects(Object o1, Object o2) {\n         return o1 == o2 || o1 != null && o1.equals(o2);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n  */\n public class DynaBeanPointerFactory implements NodePointerFactory {\n \n+    /** factory order constant */\n     public static final int DYNA_BEAN_POINTER_FACTORY_ORDER = 700;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return DYNA_BEAN_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(\n-            QName name, Object bean, Locale locale)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         return bean instanceof DynaBean ? new DynaBeanPointer(name, (DynaBean) bean, locale) : null;\n     }\n \n-    public NodePointer createNodePointer(\n-            NodePointer parent, QName name, Object bean)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name,\n+            Object bean) {\n         return bean instanceof DynaBean ? new DynaBeanPointer(parent, name, (DynaBean) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n     private String name;\n     private String[] names;\n \n+    /**\n+     * Create a new DynaBeanPropertyPointer.\n+     * @param parent pointer\n+     * @param dynaBean pointed\n+     */\n     public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) {\n         super(parent);\n         this.dynaBean = dynaBean;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return dynaBean.get(getPropertyName());\n     }\n \n     /**\n      * This type of node is auxiliary.\n+     * @return true\n      */\n     public boolean isContainer() {\n         return true;\n     }\n \n     /**\n-     * Number of the DP object's properties.\n+     * {@inheritDoc}\n      */\n     public int getPropertyCount() {\n         return getPropertyNames().length;\n     }\n \n     /**\n-     * Names of all properties, sorted alphabetically\n-     *\n-     * @todo do something about the sorting\n+     * {@inheritDoc}\n      */\n     public String[] getPropertyNames() {\n+        /* @todo do something about the sorting - LIKE WHAT? - MJB */\n         if (names == null) {\n             DynaClass dynaClass = dynaBean.getDynaClass();\n-            DynaProperty properties[] = dynaClass.getDynaProperties();\n+            DynaProperty[] properties = dynaClass.getDynaProperties();\n             int count = properties.length;\n             boolean hasClass = dynaClass.getDynaProperty(\"class\") != null;\n             if (hasClass) {\n     /**\n      * Returns the name of the currently selected property or \"*\"\n      * if none has been selected.\n+     * @return String\n      */\n     public String getPropertyName() {\n         if (name == null) {\n-            String names[] = getPropertyNames();\n+            String[] names = getPropertyNames();\n             name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : \"*\";\n         }\n         return name;\n \n     /**\n      * Select a property by name.\n+     * @param propertyName to select\n      */\n     public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n     /**\n      * Index of the currently selected property in the list of all\n      * properties sorted alphabetically.\n+     * @return int\n      */\n     public int getPropertyIndex() {\n         if (propertyIndex == UNSPECIFIED_PROPERTY) {\n-            String names[] = getPropertyNames();\n+            String[] names = getPropertyNames();\n             for (int i = 0; i < names.length; i++) {\n                 if (names[i].equals(name)) {\n                     propertyIndex = i;\n     /**\n      * Index a property by its index in the list of all\n      * properties sorted alphabetically.\n+     * @param index to set\n      */\n     public void setPropertyIndex(int index) {\n         if (propertyIndex != index) {\n      * the value of the index'th element of the collection represented by the\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n+     * @return Object\n      */\n     public Object getImmediateNode() {\n         String name = getPropertyName();\n     }\n \n     /**\n-     * Returns true if the bean has the currently selected property\n+     * Returns true if the bean has the currently selected property.\n+     * @return boolean\n      */\n     protected boolean isActualProperty() {\n         DynaClass dynaClass = dynaBean.getDynaClass();\n         return dynaClass.getDynaProperty(getPropertyName()) != null;\n     }\n \n+    /**\n+     * Learn whether the property referenced is an indexed property.\n+     * @return boolean\n+     */\n     protected boolean isIndexedProperty() {\n         DynaClass dynaClass = dynaBean.getDynaClass();\n         DynaProperty property = dynaClass.getDynaProperty(name);\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n      * represented by the property.\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         setValue(index, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             dynaBean.set(getPropertyName(), null);\n         }\n     }\n \n+    /**\n+     * Set an indexed value.\n+     * @param index to change\n+     * @param value to set\n+     */\n     private void setValue(int index, Object value) {\n         if (index == WHOLE_COLLECTION) {\n             dynaBean.set(getPropertyName(), convert(value, false));\n             Object baseValue = dynaBean.get(getPropertyName());\n             ValueUtils.setValue(baseValue, index, value);\n         }\n-   }\n-\n-\n+    }\n+\n+\n+    /**\n+     * Convert a value to the appropriate property type.\n+     * @param value to convert\n+     * @param element whether this should be a collection element.\n+     * @return conversion result\n+     */\n     private Object convert(Object value, boolean element) {\n         DynaClass dynaClass = (DynaClass) dynaBean.getDynaClass();\n         DynaProperty property = dynaClass.getDynaProperty(getPropertyName());\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n \n /**\n- * A  Pointer that points to an object with Dynamic Properties. It is used for\n+ * A Pointer that points to an object with Dynamic Properties. It is used for\n  * the first element of a path; following elements will by of type\n  * PropertyPointer.\n  *\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n     private List attributes;\n     private int position = 0;\n \n+    /**\n+     * Create a new JDOMAttributeIterator.\n+     * @param parent pointer\n+     * @param name test\n+     */\n     public JDOMAttributeIterator(NodePointer parent, QName name) {\n         this.parent = parent;\n         if (parent.getNode() instanceof Element) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n             (Attribute) attributes.get(index));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (attributes == null) {\n             return false;\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n     }\n \n     /**\n-     * Execute test against node on behalf of pointer. \n+     * Execute test against node on behalf of pointer.\n      * @param pointer Pointer\n      * @param node to test\n      * @param test to execute\n                     return node instanceof Comment;\n                 case Compiler.NODE_TYPE_PI :\n                     return node instanceof ProcessingInstruction;\n-            }\n-            return false;\n+                default:\n+                    return false;\n+            }\n         }\n         if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n             String testPI = ((ProcessingInstructionTest) test).getTarget();\n                 return 1;\n             }\n \n-            List children = ((Element)parent).getContent();\n+            List children = ((Element) parent).getContent();\n             int count = 0;\n             String name = ((Element) node).getQualifiedName();\n             for (int i = 0; i < children.size(); i++) {\n--- a/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n  */\n public class HttpSessionHandler extends ServletContextHandler {\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getProperty(Object bean, String property) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         return super.getProperty(handle.getServletContext(), property);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setProperty(Object bean, String property, Object value) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n--- a/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n     /**\n      * Returns a JXPathContext bound to the \"page\" scope. Caches that context\n      * within the PageContext itself.\n+     * @param pageContext as described\n+     * @return JXPathContext\n      */\n     public static JXPathContext getPageContext(PageContext pageContext) {\n         JXPathContext context =\n     /**\n      * Returns a JXPathContext bound to the \"request\" scope. Caches that context\n      * within the request itself.\n-     */\n-    public static JXPathContext getRequestContext(\n-        ServletRequest request,\n-        ServletContext servletContext)\n-    {\n+     * @param request as described\n+     * @param servletContext operative\n+     * @return JXPathContext\n+     */\n+    public static JXPathContext getRequestContext(ServletRequest request,\n+            ServletContext servletContext) {\n         JXPathContext context =\n             (JXPathContext) request.getAttribute(Constants.JXPATH_CONTEXT);\n         // If we are in an included JSP or Servlet, the request parameter\n     /**\n      * Returns a JXPathContext bound to the \"session\" scope. Caches that context\n      * within the session itself.\n-     */\n-    public static JXPathContext getSessionContext(\n-        HttpSession session,\n-        ServletContext servletContext)\n-    {\n+     * @param session as described\n+     * @param servletContext operative\n+     * @return JXPathContext\n+     */\n+    public static JXPathContext getSessionContext(HttpSession session,\n+            ServletContext servletContext) {\n         JXPathContext context =\n             (JXPathContext) session.getAttribute(Constants.JXPATH_CONTEXT);\n         if (context == null) {\n     /**\n      * Returns  a JXPathContext bound to the \"application\" scope. Caches that\n      * context within the servlet context itself.\n+     * @param servletContext operative\n+     * @return JXPathContext\n      */\n     public static JXPathContext getApplicationContext(\n-            ServletContext servletContext)\n-    {\n+            ServletContext servletContext) {\n         JXPathContext context =\n             (JXPathContext) servletContext.getAttribute(\n                 Constants.JXPATH_CONTEXT);\n--- a/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n  */\n public class PageContextHandler implements DynamicPropertyHandler {\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String[] getPropertyNames(Object pageContext) {\n         HashSet list = new HashSet();\n         Enumeration e =\n \n     /**\n      * Returns <code>pageContext.findAttribute(property)</code>.\n+     * @param pageContext to search\n+     * @param property name\n+     * @return Object value\n      */\n     public Object getProperty(Object pageContext, String property) {\n         return ((PageContext) pageContext).findAttribute(property);\n     }\n \n-    public void setProperty(\n-        Object pageContext,\n-        String property,\n-        Object value)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void setProperty(Object pageContext, String property, Object value) {\n         ((PageContext) pageContext).setAttribute(\n             property,\n             value,\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n public class PageScopeContext {\n     private PageContext pageContext;\n \n+    /**\n+     * Create a new PageScopeContext.\n+     * @param pageContext base\n+     */\n     public PageScopeContext(PageContext pageContext) {\n         this.pageContext = pageContext;\n     }\n \n     /**\n      * Returns attributes of the pageContext declared in the \"page\" scope.\n+     * @return Enumeration of attribute names\n      */\n     public Enumeration getAttributeNames() {\n         return pageContext.getAttributeNamesInScope(PageContext.PAGE_SCOPE);\n     }\n \n+    /**\n+     * Get the value of the specified attribute.\n+     * @param attribute name\n+     * @return Object\n+     */\n     public Object getAttribute(String attribute) {\n         return pageContext.getAttribute(attribute, PageContext.PAGE_SCOPE);\n     }\n \n+    /**\n+     * Set the specified attribute.\n+     * @param attribute to set\n+     * @param value to set\n+     */\n     public void setAttribute(String attribute, Object value) {\n         pageContext.setAttribute(attribute, value, PageContext.PAGE_SCOPE);\n     }\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n  */\n public class PageScopeContextHandler implements DynamicPropertyHandler {\n \n-    private static final String[] STRING_ARRAY = new String[0];\n+    private static final int DEFAULT_LIST_SIZE = 16;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String[] getPropertyNames(Object pageScope) {\n         Enumeration e = ((PageScopeContext) pageScope).getAttributeNames();\n-        ArrayList list = new ArrayList(16);\n+        ArrayList list = new ArrayList(DEFAULT_LIST_SIZE);\n         while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        return (String[]) list.toArray(STRING_ARRAY);\n+        return (String[]) list.toArray(new String[list.size()]);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getProperty(Object pageScope, String property) {\n         return ((PageScopeContext) pageScope).getAttribute(property);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setProperty(Object pageScope, String property, Object value) {\n         ((PageScopeContext) pageScope).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n  */\n public class ServletRequestHandler extends HttpSessionHandler {\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         super.collectPropertyNames(set, bean);\n         ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getProperty(Object bean, String property) {\n         ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         ServletRequest servletRequest = handle.getServletRequest();\n         return super.getProperty(bean, property);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setProperty(Object request, String property, Object value) {\n         ((ServletRequest) request).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n     /**\n      * Returns true if it can convert the supplied\n      * object to the specified class.\n+     * @param object to check\n+     * @param toType prospective destination class\n+     * @return boolean\n      */\n     public boolean canConvert(Object object, final Class toType) {\n         if (object == null) {\n      * Converts the supplied object to the specified\n      * type. Throws a runtime exception if the conversion is\n      * not possible.\n+     * @param object to convert\n+     * @param toType destination class\n+     * @return converted object\n      */\n     public Object convert(Object object, final Class toType) {\n         if (object == null) {\n                 try {\n                     return useType.getConstructor(new Class[] { boolean.class })\n                             .newInstance(new Object[] { object });\n-                } catch (Exception e) {\n+                }\n+                catch (Exception e) {\n                     throw new JXPathTypeConversionException(useType.getName(), e);\n                 }\n             }\n                 + object.getClass() + \" to \" + useType);\n     }\n \n+    /**\n+     * Convert null to a primitive type.\n+     * @param toType destination class\n+     * @return a wrapper\n+     */\n     protected Object convertNullToPrimitive(Class toType) {\n         if (toType == boolean.class) {\n             return Boolean.FALSE;\n         return null;\n     }\n \n+    /**\n+     * Convert a string to a primitive type.\n+     * @param object String\n+     * @param toType destination class\n+     * @return wrapper\n+     */\n     protected Object convertStringToPrimitive(Object object, Class toType) {\n         toType = TypeUtils.wrapPrimitive(toType);\n         if (toType == Boolean.class) {\n         return null;\n     }\n \n+    /**\n+     * Allocate a number of a given type and value.\n+     * @param type destination class\n+     * @param value double\n+     * @return Number\n+     */\n     protected Number allocateNumber(Class type, double value) {\n         type = TypeUtils.wrapPrimitive(type);\n         if (type == Byte.class) {\n                         .newInstance(\n                                 new Object[] { allocateNumber(initialValueType,\n                                         value) });\n-            } catch (Exception e) {\n+            }\n+            catch (Exception e) {\n                 throw new JXPathTypeConversionException(classname, e);\n             }\n         }\n         return null;\n     }\n \n+    /**\n+     * Learn whether this BasicTypeConverter can create a collection of the specified type.\n+     * @param type prospective destination class\n+     * @return boolean\n+     */\n     protected boolean canCreateCollection(Class type) {\n         if (!type.isInterface()\n                 && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) {\n             try {\n                 type.getConstructor(new Class[0]);\n                 return true;\n-            } catch (Exception e) {\n+            }\n+            catch (Exception e) {\n                 return false;\n             }\n         }\n         return type == List.class || type == Collection.class || type == Set.class;\n     }\n \n+    /**\n+     * Create a collection of a given type.\n+     * @param type destination class\n+     * @return Collection\n+     */\n     protected Collection allocateCollection(Class type) {\n         if (!type.isInterface()\n-            && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) {\n+                && ((type.getModifiers() & Modifier.ABSTRACT) == 0)) {\n             try {\n                 return (Collection) type.newInstance();\n             }\n                 \"Cannot create collection of type: \" + type);\n     }\n \n+    /**\n+     * Get an unmodifiable version of a collection.\n+     * @param collection to wrap\n+     * @return Collection\n+     */\n     protected Collection unmodifiableCollection(Collection collection) {\n         if (collection instanceof List) {\n             return Collections.unmodifiableList((List) collection);\n         return Collections.unmodifiableCollection(collection);\n     }\n \n+    /**\n+     * NodeSet implementation\n+     */\n     static final class ValueNodeSet implements NodeSet {\n         private List values;\n         private List pointers;\n \n+        /**\n+         * Create a new ValueNodeSet.\n+         * @param values to return\n+         */\n         public ValueNodeSet(List values) {\n            this.values = values;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public List getValues() {\n             return Collections.unmodifiableList(values);\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public List getNodes() {\n             return Collections.unmodifiableList(values);\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public List getPointers() {\n             if (pointers == null) {\n                 pointers = new ArrayList();\n         }\n     }\n \n+    /**\n+     * Value pointer\n+     */\n     static final class ValuePointer implements Pointer {\n         private Object bean;\n \n+        /**\n+         * Create a new ValuePointer.\n+         * @param object value\n+         */\n         public ValuePointer(Object object) {\n             this.bean = object;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object getValue() {\n             return bean;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object getNode() {\n             return bean;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object getRootNode() {\n             return bean;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public void setValue(Object value) {\n             throw new UnsupportedOperationException();\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object clone() {\n             return this;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public int compareTo(Object object) {\n             return 0;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public String asPath() {\n             if (bean == null) {\n                 return \"null()\";\n--- a/src/java/org/apache/commons/jxpath/util/KeyManagerUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/KeyManagerUtils.java\n  * @version $Revision$ $Date$\n  */\n public class KeyManagerUtils {\n+    /**\n+     * Adapt KeyManager to implement ExtendedKeyManager.\n+     */\n     private static class SingleNodeExtendedKeyManager implements\n             ExtendedKeyManager {\n         private KeyManager delegate;\n \n+        /**\n+         * Create a new SingleNodeExtendedKeyManager.\n+         * @param delegate KeyManager to wrap\n+         */\n         public SingleNodeExtendedKeyManager(KeyManager delegate) {\n             this.delegate = delegate;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public NodeSet getNodeSetByKey(JXPathContext context, String key,\n                 Object value) {\n             Pointer pointer = delegate.getPointerByKey(context, key, InfoSetUtil.stringValue(value));\n             return result;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Pointer getPointerByKey(JXPathContext context, String keyName,\n                 String keyValue) {\n             return delegate.getPointerByKey(context, keyName, keyValue);\n \n     /**\n      * Get an ExtendedKeyManager from the specified KeyManager.\n-     * @param keyManager\n+     * @param keyManager to adapt, if necessary\n      * @return <code>keyManager</code> if it implements ExtendedKeyManager\n      *         or a basic single-result ExtendedKeyManager that delegates to\n      *         <code>keyManager</code>.\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n                     return clazz.getDeclaredMethod(name, parameterTypes);\n                 }\n                 catch (NoSuchMethodException e) {\n+                    //ignore\n                 }\n             }\n         }\n                     interfaces[i].getDeclaredMethod(methodName, parameterTypes);\n             }\n             catch (NoSuchMethodException e) {\n+                //ignore\n             }\n             if (method != null) {\n                 break;\n--- a/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n  */\n public class JDOMParser extends XMLParser2 {\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object parseXML(InputStream stream) {\n         if (!isNamespaceAware()) {\n             throw new JXPathException(\"JDOM parser configuration error. JDOM \"\n--- a/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n+++ b/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public abstract class XMLParser2 implements XMLParser\n-{\n+public abstract class XMLParser2 implements XMLParser {\n     private boolean validating = false;\n     private boolean namespaceAware = true;\n     private boolean whitespace = false;\n     private boolean coalescing = false;\n \n     /**\n+     * Set whether the underlying parser should be validating.\n+     * @param validating flag\n      * @see DocumentBuilderFactory#setValidating(boolean)\n      */\n     public void setValidating(boolean validating) {\n     }\n \n     /**\n+     * Learn whether the underlying parser is validating.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isValidating()\n      */\n     public boolean isValidating() {\n     }\n \n     /**\n+     * Learn whether the underlying parser is ns-aware.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isNamespaceAware()\n      */\n     public boolean isNamespaceAware() {\n     }\n \n     /**\n+     * Set whether the underlying parser is ns-aware.\n+     * @param namespaceAware flag\n      * @see DocumentBuilderFactory#setNamespaceAware(boolean)\n      */\n     public void setNamespaceAware(boolean namespaceAware) {\n     }\n \n     /**\n+     * Set whether the underlying parser is ignoring whitespace.\n+     * @param whitespace flag\n      * @see DocumentBuilderFactory#setIgnoringElementContentWhitespace(boolean)\n      */\n     public void setIgnoringElementContentWhitespace(boolean whitespace) {\n     }\n \n     /**\n+     * Learn whether the underlying parser is ignoring whitespace.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isIgnoringElementContentWhitespace()\n      */\n     public boolean isIgnoringElementContentWhitespace() {\n     }\n \n     /**\n+     * Learn whether the underlying parser expands entity references.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isExpandEntityReferences()\n      */\n     public boolean isExpandEntityReferences() {\n     }\n \n     /**\n+     * Set whether the underlying parser expands entity references.\n+     * @param expandEntityRef flag\n      * @see DocumentBuilderFactory#setExpandEntityReferences(boolean)\n      */\n     public void setExpandEntityReferences(boolean expandEntityRef) {\n     }\n \n     /**\n+     * Learn whether the underlying parser ignores comments.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isIgnoringComments()\n      */\n     public boolean isIgnoringComments() {\n     }\n \n     /**\n+     * Set whether the underlying parser ignores comments.\n+     * @param ignoreComments flag\n      * @see DocumentBuilderFactory#setIgnoringComments(boolean)\n      */\n     public void setIgnoringComments(boolean ignoreComments) {\n     }\n \n     /**\n+     * Learn whether the underlying parser is coalescing.\n+     * @return boolean\n      * @see DocumentBuilderFactory#isCoalescing()\n      */\n     public boolean isCoalescing() {\n     }\n \n     /**\n+     * Set whether the underlying parser is coalescing.\n+     * @param coalescing flag\n      * @see DocumentBuilderFactory#setCoalescing(boolean)\n      */\n     public void setCoalescing(boolean coalescing) {\n         this.coalescing = coalescing;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public abstract Object parseXML(InputStream stream);\n }", "timestamp": 1202090653, "metainfo": ""}