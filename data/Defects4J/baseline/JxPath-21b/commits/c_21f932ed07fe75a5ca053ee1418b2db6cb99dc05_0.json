{"sha": "21f932ed07fe75a5ca053ee1418b2db6cb99dc05", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n      * it should create the collection. Then it should create the index'th\n      * element of the collection and return true.\n      * <p>\n-     * \n+     *\n      * @param context can be used to evaluate other XPaths, get to variables\n      * etc.\n      * @param pointer describes the location of the node to be created\n      * @param index is used if the pointer represents a collection element. You\n      * may need to expand or even create the collection to accommodate the new\n      * element.\n-     * \n+     *\n      * @return true if the object was successfully created\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, \n-                                Object parent, String name, int index) \n+    public boolean createObject(JXPathContext context, Pointer pointer,\n+                                Object parent, String name, int index)\n     {\n         return false;\n     }\n \n     /**\n      * Declare the specified variable\n-     * \n-     * @param context hosts variable pools. See \n+     *\n+     * @param context hosts variable pools. See\n      * {@link JXPathContext#getVariables() JXPathContext.getVariables()}\n      * @param name is the name of the variable without the \"$\" sign\n-     * \n+     *\n      * @return true if the variable was successfully defined\n      */\n     public boolean declareVariable(JXPathContext context, String name) {\n--- a/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n+++ b/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n import java.util.List;\n \n /**\n- * A simple implementation of NodeSet that behaves as a collection of pointers. \n+ * A simple implementation of NodeSet that behaves as a collection of pointers.\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n--- a/src/java/org/apache/commons/jxpath/BasicVariables.java\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n     public void undeclareVariable(String varName) {\n         vars.remove(varName);\n     }\n-    \n+\n     public String toString() {\n         return vars.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /**\n  * Extension functions provided by a Java class.\n  *\n- * Let's say, we declared a ClassFunction like this:\n+ * Let's say we declared a ClassFunction like this:\n  * <blockquote><pre>\n  *     new ClassFunctions(Integer.class, \"int\")\n  * </pre></blockquote>\n  * @version $Revision$ $Date$\n  */\n public class ClassFunctions implements Functions {\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n     private Class functionClass;\n     private String namespace;\n-    private static final Object[] EMPTY_ARRAY = new Object[0];\n \n+    /**\n+     * Create a new ClassFunctions.\n+     * @param functionClass Class providing the functions\n+     * @param namespace assigned ns\n+     */\n     public ClassFunctions(Class functionClass, String namespace) {\n         this.functionClass = functionClass;\n         this.namespace = namespace;\n      * @param namespace if it is not the namespace specified in the constructor,\n      *     the method returns null\n      * @param name is a function name or \"new\" for a constructor.\n+     * @param parameters Object[] of parameters\n      *\n      * @return a MethodFunction, a ConstructorFunction or null if there is no\n      *      such function.\n     public Function getFunction(\n         String namespace,\n         String name,\n-        Object[] parameters) \n-    {\n+        Object[] parameters) {\n         if (namespace == null) {\n             if (this.namespace != null) {\n                 return null;\n             }\n-        } else if (!namespace.equals(this.namespace)) {\n+        }\n+        else if (!namespace.equals(this.namespace)) {\n             return null;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/Container.java\n+++ b/src/java/org/apache/commons/jxpath/Container.java\n \n     /**\n      * Returns the contained value.\n+     * @return Object value\n      */\n     Object getValue();\n \n     /**\n      * Modifies the value contained by this container.  May throw\n      * UnsupportedOperationException.\n+     * @param value Object value to set.\n      */\n     void setValue(Object value);\n }\n--- a/src/java/org/apache/commons/jxpath/ExpressionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ExpressionContext.java\n  * This expression will find all nodes of the graph that are dates.\n  */\n public interface ExpressionContext {\n-    \n+\n     /**\n      * Get the JXPathContext in which this function is being evaluated.\n      *\n--- a/src/java/org/apache/commons/jxpath/Function.java\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n /**\n  * Extension function interface. Extension functions are grouped into\n  * {@link Functions Functions} objects, which are installed on\n- * JXPathContexts using the \n+ * JXPathContexts using the\n  * {@link JXPathContext#setFunctions JXPathContext.setFunctions()}\n  * call.\n  * <p>\n  * The Function interface can be implemented directly. However,\n  * most of the time JXPath's built-in implementations should suffice.\n- * See {@link ClassFunctions ClassFunctions} and \n+ * See {@link ClassFunctions ClassFunctions} and\n  * {@link PackageFunctions PackageFunctions}.\n  *\n  * @author Dmitri Plotnikov\n--- a/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n     public Function getFunction(\n         String namespace,\n         String name,\n-        Object[] parameters) \n+        Object[] parameters)\n     {\n         if (byNamespace == null) {\n             prepareCache();\n--- a/src/java/org/apache/commons/jxpath/Functions.java\n+++ b/src/java/org/apache/commons/jxpath/Functions.java\n /**\n  * A group of Function objects sharing a common namespace or a set of\n  * common namespaces. Use the classes\n- * {@link ClassFunctions ClassFunctions} and \n+ * {@link ClassFunctions ClassFunctions} and\n  * {@link PackageFunctions PackageFunctions}\n  * to register extension functions implemented as Java methods.\n  *\n     /**\n      * Returns all namespaces in which this function collection defines\n      * functions.\n+     * @return Set\n      */\n     Set getUsedNamespaces();\n \n     /**\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n+     * @param namespace ns\n+     * @param name function name\n+     * @param parameters Object[]\n+     * @return Function\n      */\n     Function getFunction(String namespace, String name, Object[] parameters);\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n /**\n  * Thrown when an AbstractFactory cannot generate an object for the requested\n  * path.\n- * \n+ *\n  * @author Dmitri Plotnikov\n  * @version $Revision: 155422 $ $Date: 2005-02-26 08:07:46 -0500 (Sat, 26 Feb 2005) $\n  */\n \n     public JXPathAbstractFactoryException(String message) {\n         super(message);\n-    }    \n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n  * elements:\n  *\n  * <pre><blockquote>\n- * String homeZipCode = \n+ * String homeZipCode =\n  *     (String) context.getValue(\"addresses[@name='home']/zipCode\");\n  * </blockquote></pre>\n  *\n  *\n  * <pre><blockquote>\n  * public class AddressFactory extends AbstractFactory {\n- *    public boolean createObject(JXPathContext context, \n+ *    public boolean createObject(JXPathContext context,\n  *               Pointer pointer, Object parent, String name, int index){\n  *     if ((parent instanceof Employee) &amp;&amp; name.equals(\"address\"){\n  *       ((Employee)parent).setAddress(new Address());\n  * <p>\n  * Here's how you can create new objects:\n  * <pre><blockquote>\n- * Book book = \n+ * Book book =\n  *    (Book) context.getValue(\n  *         \"org.apache.commons.jxpath.example.Book.new ('John Updike')\");\n  * </blockquote></pre>\n  *\n  * Here's how you can call static methods:\n  * <pre><blockquote>\n- *   Book book = \n- *    (Book) context.getValue( \n+ *   Book book =\n+ *    (Book) context.getValue(\n  *       \"org. apache.commons.jxpath.example.Book.getBestBook('John Updike')\");\n  * </blockquote></pre>\n  *\n  *\n  * See  <a href=\"http://www.w3schools.com/xpath\">XPath Tutorial by\n  * W3Schools</a><br>. Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path\n- * Language (XPath) Version 1.0</a><br><br> \n- * \n+ * Language (XPath) Version 1.0</a><br><br>\n+ *\n  * You will also find more information and examples in\n  * <a href=\"http://commons.apache.org/jxpath/users-guide.html\">\n  * JXPath User's Guide</a>\n \n     private static JXPathContextFactory contextFactory;\n     private static JXPathContext compilationContext;\n-    \n+\n     private static final PackageFunctions GENERIC_FUNCTIONS =\n         new PackageFunctions(\"\", null);\n \n      */\n     public static JXPathContext newContext(\n         JXPathContext parentContext,\n-        Object contextBean) \n+        Object contextBean)\n     {\n         return getContextFactory().newContext(parentContext, contextBean);\n     }\n \n     /**\n-     * Acquires a context factory and caches it. \n+     * Acquires a context factory and caches it.\n      */\n     private static JXPathContextFactory getContextFactory () {\n         if (contextFactory == null) {\n-            contextFactory = JXPathContextFactory.newInstance();            \n+            contextFactory = JXPathContextFactory.newInstance();\n         }\n         return contextFactory;\n     }\n-    \n+\n     /**\n      * This  constructor should remain protected - it is to be overridden by\n      * subclasses, but never explicitly invoked by clients.\n     public Object getContextBean() {\n         return contextBean;\n     }\n-    \n+\n     /**\n      * Returns a Pointer for the context bean.\n      */\n         }\n         return locale;\n     }\n-    \n+\n     /**\n      * Sets DecimalFormatSymbols for a given name. The DecimalFormatSymbols can\n      * be referenced as the third, optional argument in the invocation of\n      * <code>format-number (number,format,decimal-format-name)</code> function.\n      * By default, JXPath uses the symbols for the current locale.\n-     * \n+     *\n      * @param name the format name or null for default format.\n      */\n     public synchronized void setDecimalFormatSymbols(\n         String name,\n-        DecimalFormatSymbols symbols) \n+        DecimalFormatSymbols symbols)\n     {\n         if (decimalFormats == null) {\n             decimalFormats = new HashMap();\n         }\n         return (DecimalFormatSymbols) decimalFormats.get(name);\n     }\n-    \n+\n     /**\n      * If the context is in the lenient mode, then getValue() returns null\n      * for inexistent paths.  Otherwise, a path that does not map to\n      * produces the same result as <code>getValue()</code> on object models\n      * like JavaBeans, but a different result for DOM/JDOM etc., because it\n      * returns the Node itself, rather than its textual contents.\n-     * \n+     *\n      * @param xpath the xpath to be evaluated\n      * @return the found object\n      */\n     \tPointer pointer = getPointer(xpath);\n         return pointer == null ? null : pointer.getNode();\n     }\n-    \n-    /**\n-     * Finds all nodes that match the specified XPath. \n-     *   \n+\n+    /**\n+     * Finds all nodes that match the specified XPath.\n+     *\n      * @param xpath the xpath to be evaluated\n      * @return a list of found objects\n      */\n \t\t}\n \t\treturn list;\n     }\n-    \n+\n     /**\n      * Evaluates the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n \n     /**\n      * Registers a namespace prefix.\n-     * \n+     *\n      * @param prefix A namespace prefix\n      * @param namespaceURI A URI for that prefix\n      */\n         throw new UnsupportedOperationException(\n                 \"Namespace registration is not implemented by \" + getClass());\n     }\n-    \n+\n     /**\n      * Given a prefix, returns a registered namespace URI. If the requested\n      * prefix was not defined explicitly using the registerNamespace method,\n      * JXPathContext will then check the context node to see if the prefix is\n      * defined there. See\n      * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer}.\n-     * \n+     *\n      * @param prefix The namespace prefix to look up\n      * @return namespace URI or null if the prefix is undefined.\n      */\n         throw new UnsupportedOperationException(\n                 \"Namespace registration is not implemented by \" + getClass());\n     }\n-    \n+\n     /**\n      * Get the prefix associated with the specifed namespace URI.\n      * @param namespaceURI the ns URI to check.\n      * context where the namespaces are defined. By default,\n      * NamespaceContextPointer is the same as the Context Pointer, see\n      * {@link #getContextPointer() getContextPointer()}\n-     * \n+     *\n      * @param namespaceContextPointer The pointer to the context where prefixes used in\n      *        XPath expressions should be resolved.\n      */\n         throw new UnsupportedOperationException(\n                 \"Namespace registration is not implemented by \" + getClass());\n     }\n-    \n+\n     /**\n      * Returns the namespace context pointer set with\n      * {@link #setNamespaceContextPointer(Pointer) setNamespaceContextPointer()}\n      * or, if none has been specified, the context pointer otherwise.\n-     * \n+     *\n      * @return The namespace context pointer.\n      */\n     public Pointer getNamespaceContextPointer() {\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n         finding the default impl )\n     */\n     private static String factoryImplName = null;\n-    \n+\n+    /**\n+     * Create a new JXPathContextFactory.\n+     */\n     protected JXPathContextFactory () {\n \n     }\n      * <code>JXPathContextFactory</code> it can use the factory to\n      * obtain JXPathContext instances.\n      *\n-     * @exception JXPathFactoryConfigurationError if the implementation is not\n-     * available or cannot be instantiated.\n+     * @return JXPathContextFactory\n+     * @exception JXPathContextFactoryConfigurationError if the implementation\n+     *            is not available or cannot be instantiated.\n      */\n     public static JXPathContextFactory newInstance() {\n         if (factoryImplName == null) {\n     /**\n      * Creates a new instance of a JXPathContext using the\n      * currently configured parameters.\n-     *\n+     * @param parentContext parent context\n+     * @param contextBean Object bean\n+     * @return JXPathContext\n      * @exception JXPathContextFactoryConfigurationError if a JXPathContext\n-     * cannot be created which satisfies the configuration requested\n+     *            cannot be created which satisfies the configuration requested\n      */\n \n     public abstract JXPathContext newContext(\n         JXPathContext parentContext,\n-        Object contextBean)\n-        throws JXPathContextFactoryConfigurationError;\n+        Object contextBean);\n \n     // -------------------- private methods --------------------\n     // This code is duplicated in all factories.\n         }\n     }\n \n-    /** Private implementation method - will find the implementation\n-        class in the specified order.\n-        @param property    Property name\n-        @param defaultFactory Default implementation, if nothing else is found\n-        \n-        @return class name of the JXPathContextFactory\n-    */\n+    /**\n+     * Private implementation method - will find the implementation\n+     * class in the specified order.\n+     * @param property    Property name\n+     * @param defaultFactory Default implementation, if nothing else is found\n+     *\n+     * @return class name of the JXPathContextFactory\n+     */\n     private static String findFactory(String property, String defaultFactory) {\n         // Use the factory ID system property first\n         try {\n--- a/src/java/org/apache/commons/jxpath/JXPathException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathException.java\n \n public class JXPathException extends RuntimeException {\n     private static final long serialVersionUID = 4306409701468017766L;\n-    \n+\n     /** @serial */\n     private Throwable exception;\n \n--- a/src/java/org/apache/commons/jxpath/JXPathFunctionNotFoundException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathFunctionNotFoundException.java\n public class JXPathFunctionNotFoundException extends JXPathException {\n \n     private static final long serialVersionUID = -8875537628056117241L;\n-    \n+\n     public JXPathFunctionNotFoundException(String message) {\n         super(message);\n     }\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n      */\n     public static void registerDynamicClass(\n         Class beanClass,\n-        Class dynamicPropertyHandlerClass) \n+        Class dynamicPropertyHandlerClass)\n     {\n         JXPathBasicBeanInfo bi =\n             new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass);\n             if (beanInfo != null && beanInfo.isDynamic()) {\n                 return beanInfo;\n             }\n-            return findDynamicBeanInfo(sup);                \n+            return findDynamicBeanInfo(sup);\n         }\n         return null;\n     }\n      * classloader.\n      */\n     private static Object instantiate(Class sibling, String className)\n-        throws Exception \n+        throws Exception\n     {\n \n         // First check with sibling's classloader (if any).\n--- a/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n public class JXPathInvalidAccessException extends JXPathException {\n \n     private static final long serialVersionUID = -8875537628056117241L;\n-    \n+\n     public JXPathInvalidAccessException(String message) {\n         super(message);\n     }\n-    \n+\n     public JXPathInvalidAccessException(String message, Throwable ex) {\n         super(message, ex);\n     }\n--- a/src/java/org/apache/commons/jxpath/JXPathTypeConversionException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathTypeConversionException.java\n \n /**\n  * Thrown when JXPath cannot convert supplied value to the required type.\n- * \n+ *\n  * @author Dmitri Plotnikov\n  * @version $Revision: 155422 $ $Date: 2005-02-26 08:07:46 -0500 (Sat, 26 Feb 2005) $\n  */\n--- a/src/java/org/apache/commons/jxpath/NodeSet.java\n+++ b/src/java/org/apache/commons/jxpath/NodeSet.java\n  * function.  Alternatively, the function can declare the argument as\n  * a Collection (or List or Set), in which case it will be given a collection\n  * of <i>values</i> matching the path.\n- * \n+ *\n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n  * @version $Id$\n  */\n      * Returns a list of nodes.\n      */\n     List getNodes();\n-    \n+\n     /**\n      * Returns a list of pointers for all nodes in the set.\n      */\n     List getPointers();\n-    \n+\n     /**\n      * Returns a list of values of all contained pointers.\n      */\n     List getValues();\n-    \n+\n }\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n  * <code>\"java.util.Date.new()\"</code> and <code>\"length('foo')\"</code>\n  * without the explicit registration of any extension functions.\n  * </p>\n-\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n     private String namespace;\n     private static final Object[] EMPTY_ARRAY = new Object[0];\n \n+    /**\n+     * Create a new PackageFunctions.\n+     * @param classPrefix class prefix\n+     * @param namespace namespace String\n+     */\n     public PackageFunctions(String classPrefix, String namespace) {\n         this.classPrefix = classPrefix;\n         this.namespace = namespace;\n \n     /**\n      * Returns the namespace specified in the constructor\n+     * @return (singleton) namespace Set\n      */\n     public Set getUsedNamespaces() {\n         return Collections.singleton(namespace);\n     }\n \n     /**\n-     * Returns a Function, if any, for the specified namespace,\n+     * Returns a Function, if found, for the specified namespace,\n      * name and parameter types.\n      * <p>\n      * @param  namespace - if it is not the same as specified in the\n      * <li><b>subpackage.subpackage.Classname.methodname</b>, if looking for a\n      * static method of a class in a subpackage</li>\n      * </ul>\n-     *\n-     * @return  a MethodFunction, a ConstructorFunction or null if no function\n+     * @param parameters Object[] of parameters\n+     * @return a MethodFunction, a ConstructorFunction or null if no function\n      * is found\n      */\n     public Function getFunction(\n         String namespace,\n         String name,\n-        Object[] parameters) \n-    {\n+        Object[] parameters) {\n         if ((namespace == null && this.namespace != null)\n             || (namespace != null && !namespace.equals(this.namespace))) {\n             return null;\n                 if (method != null) {\n                     return new MethodFunction(method);\n                 }\n-                    \n+\n                 if (target instanceof NodeSet) {\n                     target = ((NodeSet) target).getPointers();\n                 }\n-                \n+\n                 method =\n                     MethodLookupUtils.lookupMethod(\n                         target.getClass(),\n                 if (method != null) {\n                     return new MethodFunction(method);\n                 }\n-                \n+\n                 if (target instanceof Collection) {\n                     Iterator iter = ((Collection) target).iterator();\n                     if (iter.hasNext()) {\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n \n     /**\n      * Returns the value of the object, property or collection element\n-     * this pointer represents. May convert the value to one of the \n+     * this pointer represents. May convert the value to one of the\n      * canonical InfoSet types: String, Number, Boolean, Set.\n-     * \n+     *\n      * For example, in the case of an XML element, getValue() will\n-     * return the text contained by the element rather than \n+     * return the text contained by the element rather than\n      * the element itself.\n      * @return Object value\n      */\n     /**\n      * Returns the raw value of the object, property or collection element\n      * this pointer represents.  Never converts the object to a\n-     * canonical type: returns it as is. \n-     * \n+     * canonical type: returns it as is.\n+     *\n      * For example, for an XML element, getNode() will\n      * return the element itself rather than the text it contains.\n      * @return Object node\n \n     /**\n      * Returns the node this pointer is based on.\n-     * @return  \n+     * @return\n      */\n     Object getRootNode();\n-    \n+\n     /**\n      * Returns a string that is a proper \"canonical\" XPath that corresponds to\n      * this pointer.  Consider this example:\n      * /departments[@name = 'HR']/employees[3]\"</code>.\n      */\n     String asPath();\n-    \n+\n     /**\n      * Pointers are cloneable\n      */\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n \n /**\n  * An XPath extension function implemented as an individual Java method.\n- * \n+ *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class MethodFunction implements Function {\n \n     private Method method;\n-    private static final Object EMPTY_ARRAY[] = new Object[0];\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n \n+    /**\n+     * Create a new MethodFunction.\n+     * @param method implementing Method\n+     */\n     public MethodFunction(Method method) {\n         this.method = ValueUtils.getAccessibleMethod(method);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object invoke(ExpressionContext context, Object[] parameters) {\n         try {\n             Object target;\n                     parameters = EMPTY_ARRAY;\n                 }\n                 int pi = 0;\n-                Class types[] = method.getParameterTypes();\n+                Class[] types = method.getParameterTypes();\n                 if (types.length >= 1\n                     && ExpressionContext.class.isAssignableFrom(types[0])) {\n                     pi = 1;\n             }\n             else {\n                 int pi = 0;\n-                Class types[] = method.getParameterTypes();\n+                Class[] types = method.getParameterTypes();\n                 if (types.length >= 1\n                     && ExpressionContext.class.isAssignableFrom(types[0])) {\n                     pi = 1;\n                     ex);\n         }\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return method.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n  * @version $Revision$ $Date$\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n+    /** parent context */\n     protected EvalContext parentContext;\n+\n+    /** root context */\n     protected RootContext rootContext;\n+\n+    /** position */\n     protected int position = 0;\n+\n     private boolean startedSetIteration = false;\n     private boolean done = false;\n     private boolean hasPerformedIteratorStep = false;\n     private Iterator pointerIterator;\n \n+    /**\n+     * Create a new EvalContext.\n+     * @param parentContext parent context\n+     */\n     public EvalContext(EvalContext parentContext) {\n         this.parentContext = parentContext;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getContextNodePointer() {\n         return getCurrentNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public JXPathContext getJXPathContext() {\n         return getRootContext().getJXPathContext();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n     public int getDocumentOrder() {\n         return parentContext != null && parentContext.isChildOrderingRequired() ? 1 : 0;\n     }\n-    \n+\n     /**\n      * Even if this context has the natural ordering and therefore does\n      * not require collecting and sorting all nodes prior to returning them,\n      * such operation may be required for any child context.\n+     * @return boolean\n      */\n     public boolean isChildOrderingRequired() {\n         // Default behavior: if this context needs to be ordered,\n \n     /**\n      * Returns true if there are mode nodes matching the context's constraints.\n+     * @return boolean\n      */\n     public boolean hasNext() {\n         if (pointerIterator != null) {\n \n     /**\n      * Returns the next node pointer in the context\n+     * @return Object\n      */\n     public Object next() {\n         if (pointerIterator != null) {\n \n     /**\n      * Operation is not supported\n+     * @throws UnsupportedOperationException\n      */\n     public void remove() {\n         throw new UnsupportedOperationException(\n             \"JXPath iterators cannot remove nodes\");\n     }\n \n+    /**\n+     * Construct an iterator.\n+     * @return whether the Iterator was constructed\n+     */\n     private boolean constructIterator() {\n         HashSet set = new HashSet();\n         ArrayList list = new ArrayList();\n         case -1:\n             Collections.sort(l, ReverseComparator.INSTANCE);\n             break;\n+        default:\n         }\n     }\n \n     /**\n      * Returns the list of all Pointers in this context for the current\n      * position of the parent context.\n+     * @return List\n      */\n     public List getContextNodeList() {\n         int pos = position;\n      * Returns the list of all Pointers in this context for all positions\n      * of the parent contexts.  If there was an ongoing iteration over\n      * this context, the method should not be called.\n+     * @return NodeSet\n      */\n     public NodeSet getNodeSet() {\n         if (position != 0) {\n         BasicNodeSet set = new BasicNodeSet();\n         while (nextSet()) {\n             while (nextNode()) {\n-                set.add((Pointer)getCurrentNodePointer().clone());\n+                set.add((Pointer) getCurrentNodePointer().clone());\n             }\n         }\n \n         return set;\n     }\n-    \n-    /**\n-     * Typically returns the NodeSet by calling getNodeSet(), \n+\n+    /**\n+     * Typically returns the NodeSet by calling getNodeSet(),\n      * but will be overridden for contexts that more naturally produce\n      * individual values, e.g. VariableContext\n+     * @return Object\n      */\n     public Object getValue() {\n         return getNodeSet();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         Pointer ptr = getContextNodePointer();\n         return ptr == null ? \"Empty expression context\" : \"Expression context [\" + getPosition()\n     /**\n      * Returns the root context of the path, which provides easy\n      * access to variables and functions.\n+     * @return RootContext\n      */\n     public RootContext getRootContext() {\n         if (rootContext == null) {\n         position = 0;\n     }\n \n+    /**\n+     * Get the current position.\n+     * @return int position.\n+     */\n     public int getCurrentPosition() {\n         return position;\n     }\n     /**\n      * Returns the first encountered Pointer that matches the current\n      * context's criteria.\n+     * @return Pointer\n      */\n     public Pointer getSingleNodePointer() {\n         reset();\n     /**\n      * Returns the current context node. Undefined before the beginning\n      * of the iteration.\n+     * @return NodePoiner\n      */\n     public abstract NodePointer getCurrentNodePointer();\n \n     /**\n      * Returns true if there is another sets of objects to interate over.\n      * Resets the current position and node.\n+     * @return boolean\n      */\n     public boolean nextSet() {\n         reset(); // Restart iteration within the set\n     /**\n      * Returns true if there is another object in the current set.\n      * Switches the current position and node to the next object.\n+     * @return boolean\n      */\n     public abstract boolean nextNode();\n \n      * predicates to quickly get to the n'th element of the node set.\n      * Returns false if the position is out of the node set range.\n      * You can call it with 0 as the position argument to restart the iteration.\n+     * @param position to set\n+     * @return boolean\n      */\n     public boolean setPosition(int position) {\n         this.position = position;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n     public String toString() {\n         return xpath;\n     }\n-    \n+\n     /**\n      * @see CompiledExpression#getValue(JXPathContext)\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n \n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathContextFactory;\n-import org.apache.commons.jxpath.JXPathContextFactoryConfigurationError;\n \n /**\n  * Default implementation of JXPathContextFactory.\n  */\n public class JXPathContextFactoryReferenceImpl extends JXPathContextFactory {\n \n+    /**\n+     * Create a new JXPathContextFactoryReferenceImpl.\n+     */\n     public JXPathContextFactoryReferenceImpl() {\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public JXPathContext newContext(\n         JXPathContext parentContext,\n-        Object contextBean)\n-        throws JXPathContextFactoryConfigurationError \n-    {\n+        Object contextBean) {\n         return new JXPathContextReferenceImpl(parentContext, contextBean);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n \n     /**\n      * Registers a namespace prefix.\n-     * \n+     *\n      * @param prefix A namespace prefix\n      * @param namespaceURI A URI for that prefix\n      */\n         namespaceMap.put(prefix, namespaceURI);\n         reverseMap = null;\n     }\n-    \n+\n     /**\n      * Register a namespace for the expression context.\n      * @param pointer the Pointer to set.\n         }\n         return pointer;\n     }\n-    \n+\n     /**\n      * Given a prefix, returns a registered namespace URI. If the requested\n      * prefix was not defined explicitly using the registerNamespace method,\n      * JXPathContext will then check the context node to see if the prefix is\n      * defined there. See\n      * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\n-     * \n+     *\n      * @param prefix The namespace prefix to look up\n      * @return namespace URI or null if the prefix is undefined.\n      */\n \n     /**\n      * Given a prefix, returns an externally registered namespace URI.\n-     * \n+     *\n      * @param prefix The namespace prefix to look up\n      * @return namespace URI or null if the prefix is undefined.\n      * @since JXPath 1.3\n     }\n \n     /**\n-     * Get the nearest prefix found that matches an externally-registered namespace. \n+     * Get the nearest prefix found that matches an externally-registered namespace.\n      * @param namespaceURI\n      * @return String prefix if found.\n      * @since JXPath 1.3\n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n     /**\n      * Parses the XPath expression. Throws a JXPathException in case\n      * of a syntax error.\n+     * @param expression to parse\n+     * @param compiler the compiler\n+     * @return parsed Object\n      */\n     public static Object parseExpression(\n         String expression,\n-        Compiler compiler) \n-    {\n+        Compiler compiler) {\n         synchronized (parser) {\n             parser.setCompiler(compiler);\n             Object expr = null;\n         }\n     }\n \n+    /**\n+     * Describe a parse position.\n+     * @param expression to parse\n+     * @param position parse position\n+     * @return String\n+     */\n     private static String describePosition(String expression, int position) {\n         if (position <= 0) {\n             return \"at the beginning of the expression\";\n             + addEscapes(expression.substring(0, position)) + \"'\";\n     }\n \n+    /**\n+     * Add escapes to the specified String.\n+     * @param string incoming String\n+     * @return String\n+     */\n     private static String addEscapes(String string) {\n         // Piggy-back on the code generated by JavaCC\n         return TokenMgrError.addEscapes(string);\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n     private boolean includeSelf;\n \n     /**\n+     * Create a new AncestorContext.\n      * @param parentContext represents the previous step on the path\n-     * @param  includeSelf differentiates between \"ancestor::\" and \"ancestor-\n-     * or-self::\" axes\n+     * @param  includeSelf differentiates between \"ancestor::\" and\n+     *                     \"ancestor-or-self::\" axes\n      * @param nodeTest is the name of the element(s) we are looking for\n      */\n     public AncestorContext(\n         EvalContext parentContext,\n         boolean includeSelf,\n-        NodeTest nodeTest) \n-    {\n+        NodeTest nodeTest) {\n         super(parentContext);\n         this.includeSelf = includeSelf;\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getDocumentOrder() {\n         return -1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n         EvalContext parentContext,\n         NodeTest nodeTest,\n         boolean startFromParentLocation,\n-        boolean reverse) \n+        boolean reverse)\n     {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n     private boolean includeSelf;\n     private static final NodeTest ELEMENT_NODE_TEST =\n             new NodeTypeTest(Compiler.NODE_TYPE_NODE);\n-                        \n+\n     public DescendantContext(\n             EvalContext parentContext,\n             boolean includeSelf,\n-            NodeTest nodeTest) \n+            NodeTest nodeTest)\n     {\n         super(parentContext);\n         this.includeSelf = includeSelf;\n                 }\n             }\n             else {\n-                // We get here only if the name test failed \n+                // We get here only if the name test failed\n                 // and the iterator ended\n                 stack.pop();\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n     public NodePointer getCurrentNodePointer() {\n         return nodePointer;\n     }\n-    \n+\n     public Object getValue() {\n         return nodePointer.getValue();\n     }\n-    \n+\n     public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NodeSetContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NodeSetContext.java\n     private boolean startedSet = false;\n     private NodeSet nodeSet;\n \n+    /**\n+     * Create a new NodeSetContext.\n+     * @param parentContext parent context\n+     * @param nodeSet associated NodeSet\n+     */\n     public NodeSetContext(EvalContext parentContext, NodeSet nodeSet) {\n         super(parentContext);\n         this.nodeSet = nodeSet;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeSet getNodeSet() {\n         return nodeSet;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return (NodePointer) nodeSet.getPointers().get(position - 1);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         super.setPosition(position);\n         return position >= 1 && position <= nodeSet.getPointers().size();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextSet() {\n         if (startedSet) {\n             return false;\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n     public PrecedingOrFollowingContext(\n         EvalContext parentContext,\n         NodeTest nodeTest,\n-        boolean reverse) \n+        boolean reverse)\n     {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n                         }\n                     }\n                     else {\n-                        // We get here only if the name test failed \n+                        // We get here only if the name test failed\n                         // and the iterator ended\n                         stack.pop();\n                     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n                 Object pred = nameTestExpression.computeValue(parentContext);\n                 String propertyName = InfoSetUtil.stringValue(pred);\n \n-                // At this point it would be nice to say: \n+                // At this point it would be nice to say:\n                 // dynamicPropertyPointer.setPropertyName(propertyName)\n                 // and then: dynamicPropertyPointer.isActual().\n                 // However some PropertyPointers, e.g. DynamicPropertyPointer\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n \n     public RootContext(\n         JXPathContextReferenceImpl jxpathContext,\n-        NodePointer pointer) \n+        NodePointer pointer)\n     {\n         super(null);\n         this.jxpathContext = jxpathContext;\n     public RootContext getRootContext() {\n         return this;\n     }\n-    \n+\n     public EvalContext getAbsoluteRootContext() {\n         return jxpathContext.getAbsoluteRootContext();\n     }\n     public NodePointer getCurrentNodePointer() {\n         return pointer;\n     }\n-    \n+\n     public Object getValue() {\n         return pointer;\n     }\n-    \n+\n     public int getCurrentPosition() {\n         throw new UnsupportedOperationException();\n     }\n                 new RootContext(jxpathContext, null),\n                 (NodeSet) constant);\n         }\n-                \n+\n         NodePointer pointer;\n         if (constant instanceof NodePointer) {\n             pointer = (NodePointer) constant;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n      * and a name test.  They can also optionally have predicates\n      * of type [@name=expression] or simply [expression] interpreted\n      * as an index.\n+     * @param context evaluation context\n+     * @param root root pointer\n+     * @param steps path steps\n+     * @return NodePointer\n      */\n     public static NodePointer interpretSimpleLocationPath(\n-            EvalContext context, NodePointer root, Step steps[])\n-    {\n+            EvalContext context, NodePointer root, Step[] steps) {\n //        PATH = createNullPointer(context, root, steps, 0).toString();  // Dbg\n         NodePointer pointer = doStep(context, root, steps, 0);\n //        return valuePointer(pointer);\n      * All steps must have the axis \"child::\" or \"attribute::\"\n      * and a name test.  They can also optionally have predicates\n      * of type [@name=...] or simply [...] interpreted as an index.\n+     * @param context evaluation context\n+     * @param root root pointer\n+     * @param predicates predicates corresponding to <code>steps</code>\n+     * @param steps path steps\n+     * @return NodePointer\n      */\n     public static NodePointer interpretSimpleExpressionPath(\n                 EvalContext context, NodePointer root,\n-                Expression predicates[], Step[] steps)\n-    {\n+                Expression[] predicates, Step[] steps) {\n //        PATH = createNullPointerForPredicates(context, root,\n //                    steps, -1, predicates, 0).toString();  // Debugging\n         NodePointer pointer =\n      * find nodes that match it,\n      * iterate over those nodes and\n      * for each of them call doStep again for subsequent steps.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     private static NodePointer doStep(\n             EvalContext context, NodePointer parent,\n-            Step steps[], int currentStep)\n-    {\n+            Step[] steps, int currentStep) {\n         if (parent == null) {\n             return null;\n         }\n \n         // Open all containers\n         parent = valuePointer(parent);\n-        \n+\n         Step step = steps[currentStep];\n-        Expression predicates[] = step.getPredicates();\n+        Expression[] predicates = step.getPredicates();\n \n         // Divide and conquer: the process is broken out into\n         // four major use cases.\n      * a perfect match, we should return the \"best quality\" pointer, which\n      * has the longest chain of steps mapping to existing nodes and the shortes\n      * tail of Null* pointers.\n+     * @param context evaluation context\n+     * @param parentPointer property owner pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     private static NodePointer doStepNoPredicatesPropertyOwner(\n                 EvalContext context, PropertyOwnerPointer parentPointer,\n-                Step[] steps, int currentStep)\n-    {\n+                Step[] steps, int currentStep) {\n         Step step = steps[currentStep];\n         NodePointer childPointer =\n             createChildPointerForStep(parentPointer, step);\n      * a perfect match, we should return the \"best quality\" pointer, which\n      * has the longest chain of steps mapping to existing nodes and the shortes\n      * tail of Null* pointers.\n+     * @param context evaluation context\n+     * @param parentPointer parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     private static NodePointer doStepNoPredicatesStandard(\n                 EvalContext context, NodePointer parentPointer,\n-                Step[] steps, int currentStep)\n-    {\n+                Step[] steps, int currentStep) {\n         Step step = steps[currentStep];\n \n         if (step.getAxis() == Compiler.AXIS_SELF) {\n      * A path that starts with a property owner. The method evaluates\n      * the first predicate in a special way and then forwards to\n      * a general predicate processing method.\n+     * @param context evaluation context\n+     * @param parentPointer parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     private static NodePointer doStepPredicatesPropertyOwner(\n             EvalContext context, PropertyOwnerPointer parentPointer,\n-            Step[] steps, int currentStep)\n-    {\n+            Step[] steps, int currentStep) {\n         Step step = steps[currentStep];\n-        Expression predicates[] = step.getPredicates();\n+        Expression[] predicates = step.getPredicates();\n \n         NodePointer childPointer =\n             createChildPointerForStep(parentPointer, step);\n             0);\n     }\n \n+    /**\n+     * Create the child pointer for a given step.\n+     * @param parentPointer parent pointer\n+     * @param step associated step\n+     * @return NodePointer\n+     */\n     private static NodePointer createChildPointerForStep(\n-                PropertyOwnerPointer parentPointer, Step step)\n-    {\n+                PropertyOwnerPointer parentPointer, Step step) {\n         int axis = step.getAxis();\n         if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n             QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n      * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n      * The method evaluates the first predicate in a special way and\n      * then forwards to a general predicate processing method.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     private static NodePointer doStepPredicatesStandard(\n             EvalContext context, NodePointer parent,\n-            Step[] steps, int currentStep)\n-    {\n+            Step[] steps, int currentStep) {\n         Step step = steps[currentStep];\n-        Expression predicates[] = step.getPredicates();\n+        Expression[] predicates = step.getPredicates();\n \n         int axis = step.getAxis();\n         if (axis == Compiler.AXIS_SELF) {\n     /**\n      * Evaluates predicates and proceeds with the subsequent steps\n      * of the path.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @param predicates predicate expressions\n+     * @param currentPredicate int predicate number\n+     * @return NodePointer\n      */\n     private static NodePointer doPredicate(\n                 EvalContext context, NodePointer parent,\n                 Step[] steps, int currentStep,\n-                Expression predicates[], int currentPredicate)\n-    {\n+                Expression[] predicates, int currentPredicate) {\n         if (currentPredicate == predicates.length) {\n             return doStep(context, parent, steps, currentStep + 1);\n         }\n             currentPredicate);\n     }\n \n+    /**\n+     * Execute a NameAttributeTest predicate\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep int step number\n+     * @param predicates predicates\n+     * @param currentPredicate int predicate number\n+     * @return NodePointer\n+     */\n     private static NodePointer doPredicateName(\n             EvalContext context, NodePointer parent,\n             Step[] steps, int currentStep,\n-            Expression[] predicates, int currentPredicate)\n-    {\n+            Expression[] predicates, int currentPredicate) {\n         Expression predicate = predicates[currentPredicate];\n         String key = keyFromPredicate(context, predicate);\n         NodePointer child = valuePointer(parent);\n     /**\n      * Called exclusively for standard InfoSet nodes, e.g. DOM nodes\n      * to evaluate predicate sequences like [@name=...][@name=...][index].\n+     * @param context evaluation context\n+     * @param parents List of parent pointers\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @param predicates predicates\n+     * @param currentPredicate int predicate number\n+     * @return NodePointer\n      */\n     private static NodePointer doPredicatesStandard(\n                 EvalContext context, List parents,\n                 Step[] steps, int currentStep,\n-                Expression predicates[], int currentPredicate)\n-    {\n+                Expression[] predicates, int currentPredicate) {\n         if (parents.size() == 0) {\n             return null;\n         }\n \n     /**\n      * Evaluate a subscript predicate: see if the node is a collection and\n-     * if the index is inside the collection\n+     * if the index is inside the collection.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @param predicates predicates\n+     * @param currentPredicate int predicate number\n+     * @return NodePointer\n      */\n     private static NodePointer doPredicateIndex(\n             EvalContext context, NodePointer parent,\n             Step[] steps, int currentStep,\n-            Expression[] predicates, int currentPredicate)\n-    {\n+            Expression[] predicates, int currentPredicate) {\n         Expression predicate = predicates[currentPredicate];\n         int index = indexFromPredicate(context, predicate);\n         NodePointer pointer = parent;\n     /**\n      * Extract an integer from a subscript predicate. The returned index\n      * starts with 0, even though the subscript starts with 1.\n+     * @param context evaluation context\n+     * @param predicate to evaluate\n+     * @return calculated index\n      */\n     private static int indexFromPredicate(\n         EvalContext context,\n-        Expression predicate) \n-    {\n+        Expression predicate) {\n         Object value = predicate.computeValue(context);\n         if (value instanceof EvalContext) {\n             value = ((EvalContext) value).getSingleNodePointer();\n     /**\n      * Extracts the string value of the expression from a predicate like\n      * [@name=expression].\n+     * @param context evaluation context\n+     * @param predicate predicate to evaluate\n+     * @return String key extracted\n      */\n     private static String keyFromPredicate(EvalContext context,\n-                Expression predicate) \n-    {\n+                Expression predicate) {\n         Expression expr =\n             ((NameAttributeTest) predicate).getNameTestExpression();\n         return InfoSetUtil.stringValue(expr.computeValue(context));\n      * For a pointer that matches an actual node, returns 0.\n      * For a pointer that does not match an actual node, but whose\n      * parent pointer does returns -1, etc.\n+     * @param pointer input pointer\n+     * @return int match quality code\n      */\n     private static int computeQuality(NodePointer pointer) {\n         int quality = PERFECT_MATCH;\n     /**\n      * Returns true if the pointer has an attribute called \"name\" and\n      * its value is equal to the supplied string.\n+     * @param pointer input pointer\n+     * @param name name to check\n+     * @return boolean\n      */\n     private static boolean isNameAttributeEqual(\n         NodePointer pointer,\n-        String name) \n-    {\n+        String name) {\n         NodeIterator it = pointer.attributeIterator(QNAME_NAME);\n         return it != null\n             && it.setPosition(1)\n     /**\n      * Returns true if the pointer is a collection and the index is\n      * withing the bounds of the collection.\n+     * @param pointer input pointer\n+     * @param index to check\n+     * @return boolean\n      */\n     private static boolean isCollectionElement(\n         NodePointer pointer,\n-        int index) \n-    {\n+        int index) {\n         return pointer.isActual()\n             && (index == 0\n                 || (pointer.isCollection()\n     /**\n      * For an intermediate pointer (e.g. PropertyPointer, ContainerPointer)\n      * returns a pointer for the contained value.\n+     * @param pointer input pointer\n+     * @return NodePointer\n      */\n     private static NodePointer valuePointer(NodePointer pointer) {\n         return pointer == null ? null : pointer.getValuePointer();\n      * Creates a \"null pointer\" that\n      * a) represents the requested path and\n      * b) can be used for creation of missing nodes in the path.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @return NodePointer\n      */\n     public static NodePointer createNullPointer(\n             EvalContext context, NodePointer parent, Step[] steps,\n-            int currentStep)\n-    {\n+            int currentStep) {\n         if (currentStep == steps.length) {\n             return parent;\n         }\n         }\n         // else { it is self::node() }\n \n-        Expression predicates[] = step.getPredicates();\n+        Expression[] predicates = step.getPredicates();\n         return createNullPointerForPredicates(\n             context,\n             parent,\n \n     /**\n      * Creates a \"null pointer\" that starts with predicates.\n+     * @param context evaluation context\n+     * @param parent parent pointer\n+     * @param steps path steps\n+     * @param currentStep step number\n+     * @param predicates predicates\n+     * @param currentPredicate int predicate number\n+     * @return NodePointer\n      */\n     private static NodePointer createNullPointerForPredicates(\n             EvalContext context, NodePointer parent,\n             Step[] steps, int currentStep,\n-            Expression predicates[], int currentPredicate)\n-    {\n+            Expression[] predicates, int currentPredicate) {\n         for (int i = currentPredicate; i < predicates.length; i++) {\n             Expression predicate = predicates[i];\n             if (predicate instanceof NameAttributeTest) {\n                     context, parent, steps, currentStep + 1);\n     }\n \n+    /**\n+     * Get a NodeIterator.\n+     * @param context evaluation context\n+     * @param pointer owning pointer\n+     * @param step triggering step\n+     * @return NodeIterator\n+     */\n     private static NodeIterator getNodeIterator(\n         EvalContext context,\n         NodePointer pointer,\n-        Step step) \n-    {\n+        Step step) {\n         if (step.getAxis() == Compiler.AXIS_CHILD) {\n             NodeTest nodeTest = step.getNodeTest();\n             QName qname = ((NodeNameTest) nodeTest).getNodeName();\n             ((NodeNameTest) step.getNodeTest()).getNodeName());\n     }\n \n+    /**\n+     * Learn whether <code>name</code> is a lang attribute.\n+     * @param name to compare\n+     * @return boolean\n+     */\n     private static boolean isLangAttribute(QName name) {\n         return name.getPrefix() != null\n             && name.getPrefix().equals(\"xml\")\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n  * @version $Revision$ $Date$\n  */\n public class UnionContext extends NodeSetContext {\n-    private EvalContext contexts[];\n+    private EvalContext[] contexts;\n     private boolean prepared;\n \n-    public UnionContext(EvalContext parentContext, EvalContext contexts[]) {\n+    /**\n+     * Create a new UnionContext.\n+     * @param parentContext parent context\n+     * @param contexts child contexts\n+     */\n+    public UnionContext(EvalContext parentContext, EvalContext[] contexts) {\n         super(parentContext, new BasicNodeSet());\n         this.contexts = contexts;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getDocumentOrder() {\n         return contexts.length > 1 ? 1 : super.getDocumentOrder();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (!prepared) {\n             prepared = true;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n      * @param functionCode int function code\n      * @param args argument Expressions\n      */\n-    public CoreFunction(int functionCode, Expression args[]) {\n+    public CoreFunction(int functionCode, Expression[] args) {\n         super(args);\n         this.functionCode = functionCode;\n     }\n                 return \"key\";\n             case Compiler.FUNCTION_FORMAT_NUMBER:\n                 return \"format-number\";\n-        }\n-        return \"unknownFunction\" + functionCode + \"()\";\n+            default:\n+                return \"unknownFunction\" + functionCode + \"()\";\n+        }\n     }\n \n     /**\n      * Returns true if any argument is context dependent or if\n      * the function is last(), position(), boolean(), local-name(),\n      * name(), string(), lang(), number().\n+     * @return boolean\n      */\n     public boolean computeContextDependent() {\n         if (super.computeContextDependent()) {\n             case Compiler.FUNCTION_CEILING:\n             case Compiler.FUNCTION_ROUND:\n                 return false;\n-                \n+\n             case Compiler.FUNCTION_FORMAT_NUMBER:\n-                return args != null && args.length == 2;                             \n-        }\n-\n-        return false;\n+                return args != null && args.length == 2;\n+            default:\n+                return false;\n+        }\n     }\n \n     /**\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getFunctionName());\n         buffer.append('(');\n-        Expression args[] = getArguments();\n+        Expression[] args = getArguments();\n         if (args != null) {\n             for (int i = 0; i < args.length; i++) {\n                 if (i > 0) {\n                 return functionKey(context);\n             case Compiler.FUNCTION_FORMAT_NUMBER :\n                 return functionFormatNumber(context);\n-        }\n-        return null;\n+            default:\n+                return null;\n+        }\n     }\n \n     /**\n             ec = (EvalContext) value;\n             if (ec.hasNext()) {\n                 value = ((NodePointer) ec.next()).getValue();\n-            } else { // empty context -> empty results\n+            }\n+            else { // empty context -> empty results\n                 return new NodeSetContext(context, new BasicNodeSet());\n             }\n         }\n             assertArgCount(2);\n         }\n         StringBuffer buffer = new StringBuffer();\n-        Expression args[] = getArguments();\n+        Expression[] args = getArguments();\n         for (int i = 0; i < args.length; i++) {\n             buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n         }\n     protected Object functionNormalizeSpace(EvalContext context) {\n         assertArgCount(1);\n         String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n-        char chars[] = s.toCharArray();\n+        char[] chars = s.toCharArray();\n         int out = 0;\n         int phase = 0;\n         for (int in = 0; in < chars.length; in++) {\n-            switch(chars[in]) {\n-                case 0x20:\n-                case 0x9:\n-                case 0xD:\n-                case 0xA:\n-                    if (phase == 0) {      // beginning\n-                        ;\n-                    }\n-                    else if (phase == 1) { // non-space\n+            switch (chars[in]) {\n+                case ' ':\n+                case '\\t':\n+                case '\\r':\n+                case '\\n':\n+                    if (phase == 1) { // non-space\n                         phase = 2;\n                         chars[out++] = ' ';\n                     }\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n-        char chars[] = s1.toCharArray();\n+        char[] chars = s1.toCharArray();\n         int out = 0;\n         for (int in = 0; in < chars.length; in++) {\n             char c = chars[in];\n             }\n             symbols = new DecimalFormatSymbols(locale);\n         }\n-        \n+\n         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance();\n         format.setDecimalFormatSymbols(symbols);\n         format.applyLocalizedPattern(pattern);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n  * @version $Revision$ $Date$\n  */\n public abstract class CoreOperation extends Operation {\n-        \n+\n     public CoreOperation(Expression args[]) {\n         super(args);\n     }\n     }\n \n     public abstract Object computeValue(EvalContext context);\n-    \n+\n     /**\n      * Returns the XPath symbol for this operation, e.g. \"+\", \"div\", etc.\n      */\n     public abstract String getSymbol();\n-    \n+\n     /**\n      * Returns true if the operation is not sensitive to the order of arguments,\n      * e.g. \"=\", \"and\" etc, and false if it is, e.g. \"&lt;=\", \"div\".\n      */\n     protected abstract boolean isSymmetric();\n-    \n+\n     /**\n      * Computes the precedence of the operation.\n      */\n     protected abstract int getPrecedence();\n-    \n+\n     public String toString() {\n         if (args.length == 1) {\n             return getSymbol() + parenthesize(args[0], false);\n         }\n         return buffer.toString();\n     }\n-    \n+\n     private String parenthesize(Expression expression, boolean left) {\n         String s = expression.toString();\n         if (!(expression instanceof CoreOperation)) {\n             return s;\n         }\n         return '(' + s + ')';\n-    }    \n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n         }\n         return Boolean.TRUE;\n     }\n-    \n+\n     protected int getPrecedence() {\n         return 1;\n     }\n     protected boolean isSymmetric() {\n         return true;\n     }\n-    \n+\n     public String getSymbol() {\n         return \"and\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n     protected boolean equal(\n         EvalContext context,\n         Expression left,\n-        Expression right) \n+        Expression right)\n     {\n         Object l = left.compute(context);\n         Object r = right.compute(context);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationDivide.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationDivide.java\n  */\n public class CoreOperationDivide extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationDivide.\n+     * @param arg1 dividend\n+     * @param arg2 divisor\n+     */\n     public CoreOperationDivide(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l / r);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 5;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"div\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMod.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMod.java\n  */\n public class CoreOperationMod extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationMod.\n+     * @param arg1 dividend\n+     * @param arg2 divisor\n+     */\n     public CoreOperationMod(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context));\n         long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l % r);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 5;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"mod\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l * r);\n     }\n-    \n+\n     protected int getPrecedence() {\n         return 5;\n     }\n     protected boolean isSymmetric() {\n         return true;\n     }\n-    \n+\n     public String getSymbol() {\n         return \"*\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNegate.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNegate.java\n  */\n public class CoreOperationNegate extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationNegate.\n+     * @param arg the Expression to negate\n+     */\n     public CoreOperationNegate(Expression arg) {\n         super(new Expression[] { arg });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         double a = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         return new Double(-a);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 6;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"-\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationOr.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationOr.java\n  */\n public class CoreOperationOr extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationOr.\n+     * @param args or'd Expression components\n+     */\n     public CoreOperationOr(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         for (int i = 0; i < args.length; i++) {\n             if (InfoSetUtil.booleanValue(args[i].computeValue(context))) {\n         }\n         return Boolean.FALSE;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"or\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l - r);\n     }\n-    \n+\n     protected int getPrecedence() {\n         return 4;\n     }\n     protected boolean isSymmetric() {\n         return false;\n     }\n-    \n+\n     public String getSymbol() {\n         return \"-\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n         }\n         return new UnionContext(context.getRootContext(), argCtxs);\n     }\n-    \n+\n     protected int getPrecedence() {\n         return 7;\n     }\n     protected boolean isSymmetric() {\n         return true;\n     }\n-    \n+\n     public String getSymbol() {\n         return \"|\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n  */\n public abstract class Expression {\n \n+    /** zero */\n     protected static final Double ZERO = new Double(0);\n+\n+    /** one */\n     protected static final Double ONE = new Double(1);\n+\n+    /** NaN */\n     protected static final Double NOT_A_NUMBER = new Double(Double.NaN);\n \n     private boolean contextDependencyKnown = false;\n     /**\n      * Returns true if this expression should be re-evaluated\n      * each time the current position in the context changes.\n-     */\n-    public boolean isContextDependent() {\n+     * @return boolean\n+     */\n+    public synchronized boolean isContextDependent() {\n         if (!contextDependencyKnown) {\n             contextDependent = computeContextDependent();\n             contextDependencyKnown = true;\n \n     /**\n      * Implemented by subclasses and result is cached by isContextDependent()\n+     * @return calculated context-dependentness as boolean\n      */\n     public abstract boolean computeContextDependent();\n \n     /**\n      * Evaluates the expression. If the result is a node set, returns\n      * the first element of the node set.\n+     * @param context evaluation context\n+     * @return Object\n      */\n     public abstract Object computeValue(EvalContext context);\n+\n+    /**\n+     * Evaluates the expression. If the result is a node set, returns\n+     * the first element of the node set.\n+     * @param context evaluation context\n+     * @return Object\n+     */\n     public abstract Object compute(EvalContext context);\n \n+    /**\n+     * Iterate over the values from the specified context.\n+     * @param context evaluation context\n+     * @return value Iterator\n+     */\n     public Iterator iterate(EvalContext context) {\n         Object result = compute(context);\n         if (result instanceof EvalContext) {\n         return ValueUtils.iterate(result);\n     }\n \n+    /**\n+     * Iterate over the pointers from the specified context.\n+     * @param context evaluation context\n+     * @return pointer Iterator\n+     */\n     public Iterator iteratePointers(EvalContext context) {\n         Object result = compute(context);\n         if (result == null) {\n                 context.getRootContext().getCurrentNodePointer().getLocale());\n     }\n \n+    /**\n+     * Pointer iterator\n+     */\n     public static class PointerIterator implements Iterator {\n         private Iterator iterator;\n         private QName qname;\n \n         //to what method does the following comment refer?\n         /**\n+         * Create a new PointerIterator\n+         * @param it underlying Iterator\n+         * @param qname name\n+         * @param locale Locale\n          * @deprecated Use the method that takes a NamespaceManager\n          */\n         public PointerIterator(Iterator it, QName qname, Locale locale) {\n             this.locale = locale;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object next() {\n             Object o = iterator.next();\n             return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);\n         }\n \n+        /**\n+         * Unsupported.\n+         */\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n     }\n \n+    /**\n+     * Value Iterator\n+     */\n     public static class ValueIterator implements Iterator {\n         private Iterator iterator;\n \n+        /**\n+         * Create a new ValueIterator.\n+         * @param it underlying Iterator, may contain pointers\n+         */\n         public ValueIterator(Iterator it) {\n             this.iterator = it;\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        /**\n+         * {@inheritDoc}\n+         */\n         public Object next() {\n             Object o = iterator.next();\n             return o instanceof Pointer ? ((Pointer) o).getValue() : o;\n         }\n \n+        /**\n+         * Unsupported.\n+         */\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n     public ExpressionPath(\n         Expression expression,\n         Expression[] predicates,\n-        Step[] steps) \n+        Step[] steps)\n     {\n         super(steps);\n         this.expression = expression;\n      */\n     protected Object expressionPath(\n         EvalContext evalContext,\n-        boolean firstMatch) \n+        boolean firstMatch)\n     {\n         Object value = expression.compute(evalContext);\n         EvalContext context;\n         if (value instanceof InitialContext) {\n-            // This is an optimization. We can avoid iterating through a \n+            // This is an optimization. We can avoid iterating through a\n             // collection if the context bean is in fact one.\n             context = (InitialContext) value;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n \n     private QName functionName;\n \n-    public ExtensionFunction(QName functionName, Expression args[]) {\n+    /**\n+     * Create a new ExtensionFunction.\n+     * @param functionName name of the function\n+     * @param args Expression[] of function args\n+     */\n+    public ExtensionFunction(QName functionName, Expression[] args) {\n         super(args);\n         this.functionName = functionName;\n     }\n \n+    /**\n+     * Get the function name\n+     * @return QName\n+     */\n     public QName getFunctionName() {\n         return functionName;\n     }\n     /**\n      * An extension function gets the current context, therefore it MAY be\n      * context dependent.\n+     * @return true\n      */\n     public boolean computeContextDependent() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(functionName);\n         buffer.append('(');\n-        Expression args[] = getArguments();\n+        Expression[] args = getArguments();\n         if (args != null) {\n             for (int i = 0; i < args.length; i++) {\n                 if (i > 0) {\n         buffer.append(')');\n         return buffer.toString();\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         Object[] parameters = null;\n         if (args != null) {\n         return result instanceof NodeSet ? new NodeSetContext(context,\n                 (NodeSet) result) : result;\n     }\n-    \n+\n+    /**\n+     * Convert any incoming context to a value.\n+     * @param object Object to convert\n+     * @return context value or <code>object</code> unscathed.\n+     */\n     private Object convert(Object object) {\n         return object instanceof EvalContext ? ((EvalContext) object).getValue() : object;\n-    }  \n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n     private QName qname;\n     private String namespaceURI;\n \n+    /**\n+     * Create a new NodeNameTest.\n+     * @param qname name to match\n+     */\n     public NodeNameTest(QName qname) {\n         this.qname = qname;\n     }\n-    \n+\n+    /**\n+     * Create a new NodeNameTest.\n+     * @param qname name to match\n+     * @param namespaceURI uri to match\n+     */\n     public NodeNameTest(QName qname, String namespaceURI) {\n         this.qname = qname;\n         this.namespaceURI = namespaceURI;\n     }\n \n+    /**\n+     * Get the node name.\n+     * @return QName\n+     */\n     public QName getNodeName() {\n         return qname;\n     }\n-    \n+\n+    /**\n+     * Get the ns URI.\n+     * @return String\n+     */\n     public String getNamespaceURI() {\n         return namespaceURI;\n     }\n-    \n+\n+    /**\n+     * Learn whether this is a wildcard test.\n+     * @return <code>true</code> if the node name is \"*\".\n+     */\n     public boolean isWildcard() {\n         return qname.getName().equals(\"*\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return qname.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n     private boolean basicKnown = false;\n     private boolean basic;\n \n+    /**\n+     * Create a new Path.\n+     * @param steps that compose the Path\n+     */\n     public Path(Step[] steps) {\n         this.steps = steps;\n     }\n \n+    /**\n+     * Get the steps.\n+     * @return Step[]\n+     */\n     public Step[] getSteps() {\n         return steps;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean computeContextDependent() {\n         if (steps != null) {\n             for (int i = 0; i < steps.length; i++) {\n     }\n \n     /**\n-     * Recognized  paths formatted as <code>foo/bar[3]/baz[@name = 'biz']\n-     * </code>.  The evaluation of such \"simple\" paths is optimized and\n+     * Recognizes paths formatted as <code>foo/bar[3]/baz[@name = 'biz']</code>.\n+     * The evaluation of such \"simple\" paths is optimized and\n      * streamlined.\n+     * @return <code>true</code> if this path is simple\n      */\n     public synchronized boolean isSimplePath() {\n         if (!basicKnown) {\n             basic = true;\n             Step[] steps = getSteps();\n             for (int i = 0; i < steps.length; i++) {\n-                if (!isSimpleStep(steps[i])){\n+                if (!isSimpleStep(steps[i])) {\n                     basic = false;\n                     break;\n                 }\n \n     /**\n      * A Step is \"simple\" if it takes one of these forms: \".\", \"/foo\",\n-     * \"@bar\", \"/foo[3]\". If there are predicates, they should be \n+     * \"@bar\", \"/foo[3]\". If there are predicates, they should be\n      * context independent for the step to still be considered simple.\n+     * @param step the step to check\n+     * @return boolean\n      */\n     protected boolean isSimpleStep(Step step) {\n         if (step.getAxis() == Compiler.AXIS_SELF) {\n         if (step.getAxis() == Compiler.AXIS_CHILD\n                 || step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n             NodeTest nodeTest = step.getNodeTest();\n-            if (!(nodeTest instanceof NodeNameTest)){\n+            if (!(nodeTest instanceof NodeNameTest)) {\n                 return false;\n             }\n             if (((NodeNameTest) nodeTest).isWildcard()) {\n         return false;\n     }\n \n-    protected boolean areBasicPredicates(Expression predicates[]) {\n+    /**\n+     * Learn whether the elements of the specified array are \"basic\" predicates.\n+     * @param predicates the Expression[] to check\n+     * @return boolean\n+     */\n+    protected boolean areBasicPredicates(Expression[] predicates) {\n         if (predicates != null && predicates.length != 0) {\n             boolean firstIndex = true;\n             for (int i = 0; i < predicates.length; i++) {\n     /**\n      * Given a root context, walks a path therefrom and finds the\n      * pointer to the first element matching the path.\n+     * @param context evaluation context\n+     * @return Pointer\n      */\n     protected Pointer getSingleNodePointerForSteps(EvalContext context) {\n         if (steps.length == 0) {\n      * fails, chop off another step and repeat. If it finds more than one\n      * location - return null.\n      * </p>\n+     * @param context evaluation context\n+     * @return Pointer\n      */\n     private Pointer searchForPath(EvalContext context) {\n         EvalContext ctx = buildContextChain(context, steps.length, true);\n         Pointer pointer = ctx.getSingleNodePointer();\n-        \n+\n         if (pointer != null) {\n             return pointer;\n         }\n-        \n+\n         for (int i = steps.length; --i > 0;) {\n             if (!isSimpleStep(steps[i])) {\n                 return null;\n     /**\n      * Given a root context, walks a path therefrom and builds a context\n      * that contains all nodes matching the path.\n+     * @param context evaluation context\n+     * @return EvaluationContext\n      */\n     protected EvalContext evalSteps(EvalContext context) {\n         return buildContextChain(context, steps.length, false);\n     }\n \n+    /**\n+     * Build a context from a chain of contexts.\n+     * @param context evaluation context\n+     * @param stepCount number of steps to descend\n+     * @param createInitialContext whether to create the initial context\n+     * @return created context\n+     */\n     private EvalContext buildContextChain(\n             EvalContext context,\n             int stepCount,\n-            boolean createInitialContext) \n-    {\n+            boolean createInitialContext) {\n         if (createInitialContext) {\n             context = new InitialContext(context);\n         }\n                     context,\n                     steps[i].getAxis(),\n                     steps[i].getNodeTest());\n-            Expression predicates[] = steps[i].getPredicates();\n+            Expression[] predicates = steps[i].getPredicates();\n             if (predicates != null) {\n                 for (int j = 0; j < predicates.length; j++) {\n                     if (j != 0) {\n         }\n         return context;\n     }\n-    \n+\n     /**\n      * Different axes are serviced by different contexts. This method\n      * allocates the right context for the supplied step.\n+     * @param context evaluation context\n+     * @param axis code\n+     * @param nodeTest node test\n+     * @return EvalContext\n      */\n     protected EvalContext createContextForStep(\n         EvalContext context,\n         int axis,\n-        NodeTest nodeTest) \n-    {\n+        NodeTest nodeTest) {\n         if (nodeTest instanceof NodeNameTest) {\n             QName qname = ((NodeNameTest) nodeTest).getNodeName();\n             String prefix = qname.getPrefix();\n             if (prefix != null) {\n                 String namespaceURI = context.getJXPathContext()\n-                        .getNamespaceURI(prefix); \n+                        .getNamespaceURI(prefix);\n                 nodeTest = new NodeNameTest(qname, namespaceURI);\n             }\n         }\n             return new ChildContext(context, nodeTest, true, true);\n         case Compiler.AXIS_SELF :\n             return new SelfContext(context, nodeTest);\n-        }\n-        return null; // Never happens\n+        default:\n+            return null; // Never happens\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n     private NodeTest nodeTest;\n     private Expression[] predicates;\n \n+    /**\n+     * Create a new Step.\n+     * @param axis axis code\n+     * @param nodeTest step test\n+     * @param predicates predicate expressions\n+     */\n     protected Step(int axis, NodeTest nodeTest, Expression[] predicates) {\n         this.axis = axis;\n         this.nodeTest = nodeTest;\n         this.predicates = predicates;\n     }\n \n+    /**\n+     * Get the axis code.\n+     * @return int\n+     */\n     public int getAxis() {\n         return axis;\n     }\n \n+    /**\n+     * Get the step test.\n+     * @return NodeTest\n+     */\n     public NodeTest getNodeTest() {\n         return nodeTest;\n     }\n \n+    /**\n+     * Get the predicates.\n+     * @return Expression[]\n+     */\n     public Expression[] getPredicates() {\n         return predicates;\n     }\n \n+    /**\n+     * Learn whether this step contains any predicate that is context dependent.\n+     * @return boolean\n+     */\n     public boolean isContextDependent() {\n         if (predicates != null) {\n             for (int i = 0; i < predicates.length; i++) {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         int axis = getAxis();\n         else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                 && nodeTest instanceof NodeTypeTest\n                 && ((NodeTypeTest) nodeTest).getNodeType()\n-                    == Compiler.NODE_TYPE_NODE \n+                    == Compiler.NODE_TYPE_NODE\n                 && (predicates == null || predicates.length == 0)) {\n             buffer.append(\"\");\n         }\n         return buffer.toString();\n     }\n \n+    /**\n+     * Decode an axis code to its name.\n+     * @param axis int code\n+     * @return String name.\n+     * @see Compiler\n+     * @see http://www.w3.org/TR/xpath#axes\n+     */\n     public static String axisToString(int axis) {\n         switch (axis) {\n             case Compiler.AXIS_SELF :\n                 return \"preceding-sibling\";\n             case Compiler.AXIS_DESCENDANT_OR_SELF :\n                 return \"descendant-or-self\";\n+            default:\n+                return \"UNKNOWN\";\n         }\n-        return \"UNKNOWN\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n     public Object expressionPath(\n         Object expression,\n         Object[] predicates,\n-        Object[] steps) \n+        Object[] steps)\n     {\n         return new ExpressionPath(\n             (Expression) expression,\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n \n /**\n  * Common superclass for Pointers of all kinds.  A NodePointer maps to\n- * a deterministic XPath that represents the location of a node in an \n+ * a deterministic XPath that represents the location of a node in an\n  * object graph. This XPath uses only simple axes: child, namespace and\n  * attribute and only simple, context-independent predicates.\n  *\n     private boolean attribute = false;\n     private transient Object rootNode;\n     private NamespaceResolver namespaceResolver;\n-    \n+\n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n      * NodePointerFactories until it finds one that can create a pointer.\n     public static NodePointer newNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale) \n+        Locale locale)\n     {\n         NodePointer pointer = null;\n         if (bean == null) {\n             pointer = new NullPointer(name, locale);\n             return pointer;\n         }\n-        \n+\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n         }\n         return namespaceResolver;\n     }\n-    \n+\n     public void setNamespaceResolver(NamespaceResolver namespaceResolver) {\n         this.namespaceResolver = namespaceResolver;\n     }\n-    \n+\n     public NodePointer getParent() {\n         NodePointer pointer = parent;\n         while (pointer != null && pointer.isContainer()) {\n         }\n         return pointer;\n     }\n-    \n+\n     public NodePointer getImmediateParentPointer() {\n         return parent;\n     }\n     public boolean isNode() {\n         return !isContainer();\n     }\n-     \n+\n     /**\n      * If true, this node is axiliary and can only be used as an intermediate in\n      * the chain of pointers.\n         if (valuePointer != this) {\n             return valuePointer.getValue();\n         }\n-        // Default behavior is to return the same as getNode() \n+        // Default behavior is to return the same as getNode()\n         return getNode();\n     }\n \n      * this method returns the pointer to the contents.\n      * Only an auxiliary (non-node) pointer can (and should) return a\n      * value pointer other than itself.\n-     * Note that you probably don't want to override \n+     * Note that you probably don't want to override\n      * <code>getValuePointer()</code> directly.  Override the\n      * <code>getImmediateValuePointer()</code> method instead.  The\n      * <code>getValuePointer()</code> method is calls\n \n     /**\n      * @see #getValuePointer()\n-     * \n+     *\n      * @return NodePointer is either <code>this</code> or a pointer\n      *   for the immediately contained value.\n      */\n     public NodePointer getImmediateValuePointer() {\n         return this;\n     }\n-    \n+\n     /**\n      * An actual pointer points to an existing part of an object graph, even\n      * if it is null. A non-actual pointer represents a part that does not exist\n         }\n         return rootNode;\n     }\n-    \n+\n     /**\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n             if (nodeName == null) {\n                 return false;\n             }\n-            \n+\n             String testPrefix = testName.getPrefix();\n             String nodePrefix = nodeName.getPrefix();\n             if (!equalStrings(testPrefix, nodePrefix)) {\n      *  set value.\n      *  @param context the owning JXPathContext\n      *  @param value the new value to set\n-     *  @return created NodePointer \n+     *  @return created NodePointer\n      */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         setValue(value);\n         JXPathContext context,\n         QName name,\n         int index,\n-        Object value) \n+        Object value)\n     {\n         throw new JXPathException(\"Cannot create an object for path \"\n                 + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n-    \n+\n     /**\n      * Called to create a non-existing attribute\n      * @param context the owning JXPathCOntext\n //     * Installs the supplied manager as the namespace manager for this node\n //     * pointer. The {@link #getNamespaceURI(String) getNamespaceURI(prefix)}\n //     * uses this manager to resolve namespace prefixes.\n-//     * \n+//     *\n //     * @param namespaceManager\n //     */\n //    public void setNamespaceManager(NamespaceManager namespaceManager) {\n //        this.namespaceManager = namespaceManager;\n //    }\n-//    \n+//\n //    public NamespaceManager getNamespaceManager() {\n //        if (namespaceManager != null) {\n //            return namespaceManager;\n //        }\n //        if (parent != null) {\n //            return parent.getNamespaceManager();\n-//        }        \n+//        }\n //        return null;\n //    }\n-//    \n+//\n     /**\n      * Returns a NodeIterator that iterates over all children or all children\n      * that match the given NodeTest, starting with the specified one.\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n+        NodePointer startWith)\n     {\n         NodePointer valuePointer = getValuePointer();\n         return valuePointer == null || valuePointer == this ? null\n     public Pointer getPointerByKey(\n         JXPathContext context,\n         String key,\n-        String value) \n+        String value)\n     {\n         return context.getPointerByKey(key, value);\n     }\n         return asPath();\n     }\n \n-    \n+\n     public int compareTo(Object object) {\n         if (object == this) {\n             return 0;\n         NodePointer p1,\n         int depth1,\n         NodePointer p2,\n-        int depth2) \n+        int depth2)\n     {\n         if (depth1 < depth2) {\n             int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n     private NodePointer valuePointer;\n     private boolean actual;\n \n+    /**\n+     * Create a new VariablePointer.\n+     * @param variables Variables instance\n+     * @param name variable name\n+     */\n     public VariablePointer(Variables variables, QName name) {\n         super(null);\n         this.variables = variables;\n         actual = true;\n     }\n \n+    /**\n+     * Create a new (non-actual) VariablePointer.\n+     * @param name variable name\n+     */\n     public VariablePointer(QName name) {\n         super(null);\n         this.name = name;\n         actual = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isContainer() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return name;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         if (!actual) {\n             throw new JXPathException(\"Undefined variable: \" + name);\n         }\n         return variables.getVariable(name.toString());\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n         return index == WHOLE_COLLECTION ? ValueUtils.getValue(value)\n                 : ValueUtils.getValue(value, index);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         if (!actual) {\n             throw new JXPathException(\"Cannot set undefined variable: \" + name);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return actual;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setIndex(int index) {\n         super.setIndex(index);\n         valuePointer = null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = null;\n         }\n         return valuePointer;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         if (actual) {\n             Object value = getBaseValue();\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (actual) {\n             setValue(value);\n         return ptr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         if (!actual) {\n             AbstractFactory factory = getAbstractFactory(context);\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n-    {\n+        int index) {\n         Object collection = createCollection(context, index);\n         if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) {\n             AbstractFactory factory = getAbstractFactory(context);\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n             JXPathContext context,\n-            QName name, \n+            QName name,\n             int index,\n-            Object value) \n-    {\n+            Object value) {\n         Object collection = createCollection(context, index);\n         ValueUtils.setValue(collection, index, value);\n         NodePointer cl = (NodePointer) clone();\n         return cl;\n     }\n \n+    /**\n+     * Create a collection.\n+     * @param context JXPathContext\n+     * @param index collection index\n+     * @return Object\n+     */\n     private Object createCollection(JXPathContext context, int index) {\n         createPath(context);\n \n         return collection;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         if (actual) {\n             if (index == WHOLE_COLLECTION) {\n         }\n     }\n \n+    /**\n+     * Assimilate the Variables instance associated with the specified context.\n+     * @param context JXPathContext to search\n+     */\n     protected void findVariables(JXPathContext context) {\n         valuePointer = null;\n         JXPathContext varCtx = context;\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return (actual ? System.identityHashCode(variables) : 0)\n             + name.hashCode()\n             + index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n             && index == other.index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('$');\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n-    {\n+        NodePointer startWith) {\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer namespacePointer(String name) {\n         return getValuePointer().namespacePointer(name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n+    /**\n+     * Find the AbstractFactory, if any, associated with the specified context.\n+     * @param context JXPathContext to search\n+     * @return AbstractFactory\n+     */\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {\n         return factory;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n-    {\n+        NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n \n         /**\n          * Get the original (unwrapped) context.\n-         * \n+         *\n          * @return JXPathContext.\n          */\n         public JXPathContext getContext() {\n \n     /*\n      * (non-Javadoc)\n-     * \n+     *\n      * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#createNodePointer(org.apache.commons.jxpath.ri.QName,\n      *      java.lang.Object, java.util.Locale)\n      */\n \n     /*\n      * (non-Javadoc)\n-     * \n+     *\n      * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#createNodePointer(org.apache.commons.jxpath.ri.model.NodePointer,\n      *      org.apache.commons.jxpath.ri.QName, java.lang.Object)\n      */\n \n     /*\n      * (non-Javadoc)\n-     * \n+     *\n      * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#getOrder()\n      */\n     public int getOrder() {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n     private int position = 0;\n     private boolean includeXmlLang;\n \n+    /**\n+     * Create a new BeanAttributeIterator.\n+     * @param parent parent pointer\n+     * @param name name of this bean\n+     */\n     public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) {\n         super(\n             parent,\n         this.parent = parent;\n         includeXmlLang =\n             (name.getPrefix() != null && name.getPrefix().equals(\"xml\"))\n-                && (name.getName().equals(\"lang\") \n+                && (name.getName().equals(\"lang\")\n                 || name.getName().equals(\"*\"));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         return includeXmlLang && position == 1 ? new LangAttributePointer(parent) : super.getNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         if (includeXmlLang) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n             QName name,\n             Object bean,\n             JXPathBeanInfo beanInfo,\n-            Locale locale) \n+            Locale locale)\n     {\n         super(null, locale);\n         this.name = name;\n             NodePointer parent,\n             QName name,\n             Object bean,\n-            JXPathBeanInfo beanInfo) \n+            JXPathBeanInfo beanInfo)\n     {\n         super(parent);\n         this.name = name;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n      */\n     public String[] getPropertyNames() {\n         if (names == null) {\n-            PropertyDescriptor pds[] = getPropertyDescriptors();\n+            PropertyDescriptor[] pds = getPropertyDescriptors();\n             names = new String[pds.length];\n             for (int i = 0; i < names.length; i++) {\n                 names[i] = pds[i].getName();\n         if (pd == null) {\n             return false;\n         }\n-        \n+\n         if (pd instanceof IndexedPropertyDescriptor) {\n             return true;\n         }\n-        \n+\n         int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n         if (hint == -1) {\n             return false;\n         if (hint == 1) {\n             return true;\n         }\n-        \n+\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n-    \n+\n     /**\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n         if (pd == null) {\n             return 1;\n         }\n-        \n+\n         if (pd instanceof IndexedPropertyDescriptor) {\n             return ValueUtils.getIndexedPropertyLength(\n                 getBean(),\n                 (IndexedPropertyDescriptor) pd);\n         }\n-        \n+\n         int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n         if (hint == -1) {\n             return 1;\n         }\n         return ValueUtils.getLength(getBaseValue());\n     }\n-    \n+\n     /**\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionAttributeNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionAttributeNodeIterator.java\n \n     private QName name;\n \n+    /**\n+     * Create a new CollectionAttributeNodeIterator.\n+     * @param pointer collection pointer\n+     * @param name attribute name\n+     */\n     public CollectionAttributeNodeIterator(\n         CollectionPointer pointer,\n-        QName name) \n-    {\n+        QName name) {\n         super(pointer, false, null);\n         this.name = name;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected NodeIterator getElementNodeIterator(NodePointer elementPointer) {\n         return elementPointer.attributeIterator(name);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionChildNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionChildNodeIterator.java\n \n     private NodeTest test;\n \n+    /**\n+     * Create a new CollectionChildNodeIterator.\n+     * @param pointer CollectionPointer\n+     * @param test child test\n+     * @param reverse iteration order\n+     * @param startWith starting pointer\n+     */\n     public CollectionChildNodeIterator(\n         CollectionPointer pointer,\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n-    {\n+        NodePointer startWith) {\n         super(pointer, reverse, startWith);\n         this.test = test;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected NodeIterator getElementNodeIterator(NodePointer elementPointer) {\n         return elementPointer.childIterator(test, false, null);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionNodeIterator.java\n public abstract class CollectionNodeIterator implements NodeIterator {\n     private CollectionPointer pointer;\n     private boolean reverse;\n-    private NodePointer startWith; \n+    private NodePointer startWith;\n     private int position;\n     private List collection;\n \n+    /**\n+     * Create a new CollectionNodeIterator.\n+     * @param pointer collection pointer\n+     * @param reverse iteration order\n+     * @param startWith starting pointer\n+     */\n     protected CollectionNodeIterator(\n         CollectionPointer pointer,\n         boolean reverse,\n-        NodePointer startWith) \n-    {\n+        NodePointer startWith) {\n         this.pointer = pointer;\n         this.reverse = reverse;\n         this.startWith = startWith;\n     }\n-    \n+\n     /**\n-     * Implemened by subclasses to produce child/attribute node iterators.\n+     * Implemented by subclasses to produce child/attribute node iterators.\n+     * @param elementPointer owning pointer\n+     * @return NodeIterator\n      */\n-    protected abstract NodeIterator \n+    protected abstract NodeIterator\n             getElementNodeIterator(NodePointer elementPointer);\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (collection == null) {\n             prepare();\n         }\n-        \n+\n         if (position < 1 || position > collection.size()) {\n             return false;\n         }\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             return null;\n         }\n         return (NodePointer) collection.get(position - 1);\n     }\n-    \n+\n+    /**\n+     * Prepare...\n+     */\n     private void prepare() {\n         collection = new ArrayList();\n         NodePointer ptr = (NodePointer) pointer.clone();\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale) \n+        Locale locale)\n     {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(bean, locale) : null;\n     }\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n-        Object bean) \n+        Object bean)\n     {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(parent, bean) : null;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n     public Object getImmediateNode() {\n         return null;\n     }\n-    \n+\n     public boolean isLeaf() {\n         return true;\n-    }    \n-    \n+    }\n+\n     public boolean isCollection() {\n         return false;\n     }\n     public NodePointer createPath(JXPathContext context) {\n         return parent.createChild(context, null, index);\n     }\n-    \n+\n     public NodePointer createPath(JXPathContext context, Object value) {\n         return parent.createChild(context, null, index, value);\n     }\n         }\n \n         NullElementPointer other = (NullElementPointer) object;\n-        return getImmediateParentPointer() == other.getImmediateParentPointer() \n+        return getImmediateParentPointer() == other.getImmediateParentPointer()\n             && index == other.index;\n     }\n \n     public int getLength() {\n         return 0;\n     }\n-    \n+\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         NodePointer parent = getImmediateParentPointer();\n             }\n             else if (parent != null\n                     && parent.getImmediateParentPointer() != null\n-                    && parent.getImmediateParentPointer().getIndex() != \n-                            WHOLE_COLLECTION) \n+                    && parent.getImmediateParentPointer().getIndex() !=\n+                            WHOLE_COLLECTION)\n             {\n                 buffer.append(\"/.\");\n             }\n         }\n \n         return buffer.toString();\n-    }    \n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n     private QName name;\n     private String id;\n \n+    /**\n+     * Create a new NullPointer.\n+     * @param name node name\n+     * @param locale Locale\n+     */\n     public NullPointer(QName name, Locale locale) {\n         super(null, locale);\n         this.name = name;\n     }\n \n     /**\n-     * Used for the root node\n+     * Used for the root node.\n+     * @param parent parent pointer\n+     * @param name node name\n      */\n     public NullPointer(NodePointer parent, QName name) {\n         super(parent);\n         this.name = name;\n     }\n \n+    /**\n+     * Create a new NullPointer.\n+     * @param locale Locale\n+     * @param id String\n+     */\n     public NullPointer(Locale locale, String id) {\n         super(null, locale);\n         this.id = id;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return name;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return null;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n-    }        \n+    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public PropertyPointer getPropertyPointer() {\n         return new NullPropertyPointer(this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (parent != null) {\n             return parent.createPath(context, value).getValuePointer();\n             \"Cannot create the root object: \" + asPath());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         if (parent != null) {\n             return parent.createPath(context).getValuePointer();\n             \"Cannot create the root object: \" + asPath());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n-    {\n+        int index) {\n         return createPath(context).createChild(context, name, index);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n-        QName name, \n+        QName name,\n         int index,\n-        Object value) \n-    {\n+        Object value) {\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return name == other.name || name != null && name.equals(other.name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         if (id != null) {\n             return \"id(\" + id + \")\";\n         return parent == null ? \"null()\" : super.asPath();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n \n     public boolean isLeaf() {\n         return true;\n-    }    \n+    }\n \n     public NodePointer getValuePointer() {\n         return new NullPointer(this,  new QName(getPropertyName()));\n             throw createBadFactoryException(context.getFactory());\n         }\n         // Consider these two use cases:\n-        // 1. The parent pointer of NullPropertyPointer is \n-        //    a PropertyOwnerPointer other than NullPointer. When we call \n+        // 1. The parent pointer of NullPropertyPointer is\n+        //    a PropertyOwnerPointer other than NullPointer. When we call\n         //    createPath on it, it most likely returns itself. We then\n         //    take a PropertyPointer from it and get the PropertyPointer\n         //    to expand the collection for the corresponding property.\n         // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n         //    When we call createPath, it may return a PropertyOwnerPointer\n         //    or it may return anything else, like a DOMNodePointer.\n-        //    In the former case we need to do exactly what we did in use \n-        //    case 1.  In the latter case, we simply request that the \n+        //    In the former case we need to do exactly what we did in use\n+        //    case 1.  In the latter case, we simply request that the\n         //    non-property pointer expand the collection by itself.\n         if (newParent instanceof PropertyOwnerPointer) {\n             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n         }\n         return newParent.createChild(context, getName(), index, value);\n     }\n-    \n+\n     public NodePointer createChild(\n             JXPathContext context,\n-            QName name, \n+            QName name,\n             int index)\n     {\n         return createPath(context).createChild(context, name, index);\n     }\n-        \n+\n     public NodePointer createChild(\n             JXPathContext context,\n-            QName name, \n+            QName name,\n             int index,\n-            Object value) \n+            Object value)\n     {\n         return createPath(context).createChild(context, name, index, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n \n     private boolean includeStart = false;\n \n+    /**\n+     * Create a new PropertyIterator.\n+     * @param pointer owning pointer\n+     * @param name property name\n+     * @param reverse iteration order\n+     * @param startWith beginning pointer\n+     */\n     public PropertyIterator(\n         PropertyOwnerPointer pointer,\n         String name,\n         boolean reverse,\n-        NodePointer startWith) \n-    {\n+        NodePointer startWith) {\n         propertyNodePointer =\n             (PropertyPointer) pointer.getPropertyPointer().clone();\n         this.name = name;\n             this.startIndex = -1;\n         }\n         if (startWith != null) {\n-            while (startWith != null \n+            while (startWith != null\n                     && startWith.getImmediateParentPointer() != pointer) {\n                 startWith = startWith.getImmediateParentPointer();\n             }\n         }\n     }\n \n+    /**\n+     * Get the property pointer.\n+     * @return NodePointer\n+     */\n     protected NodePointer getPropertyPointer() {\n         return propertyNodePointer;\n     }\n \n+    /**\n+     * Reset property iteration.\n+     */\n     public void reset() {\n         position = 0;\n         targetReady = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (name != null) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         return name == null ? setPositionAllProperties(position) : setPositionIndividualProperty(position);\n     }\n \n+    /**\n+     * Set position for an individual property.\n+     * @param position int position\n+     * @return whether this was a valid position\n+     */\n     private boolean setPositionIndividualProperty(int position) {\n         this.position = position;\n         if (position < 1) {\n         return true;\n     }\n \n+    /**\n+     * Set position for all properties\n+     * @param position int position\n+     * @return whether this was a valid position\n+     */\n     private boolean setPositionAllProperties(int position) {\n         this.position = position;\n         if (position < 1) {\n         return false;\n     }\n \n+    /**\n+     * Prepare for an individual property.\n+     * @param name property name\n+     */\n     protected void prepareForIndividualProperty(String name) {\n         targetReady = true;\n         empty = true;\n \n-        String names[] = propertyNodePointer.getPropertyNames();\n+        String[] names = propertyNodePointer.getPropertyNames();\n         if (!reverse) {\n             if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) {\n                 startPropertyIndex = 0;\n     }\n \n     /**\n-     * Computes length for the current pointer - ignores any exceptions\n+     * Computes length for the current pointer - ignores any exceptions.\n+     * @return length\n      */\n     private int getLength() {\n         int length;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n+        NodePointer startWith)\n     {\n         if (test == null) {\n             return createNodeIterator(null, reverse, startWith);\n     public NodeIterator createNodeIterator(\n                 String property,\n                 boolean reverse,\n-                NodePointer startWith) \n+                NodePointer startWith)\n     {\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n      * @return PropertyPointer\n      */\n     public abstract PropertyPointer getPropertyPointer();\n-    \n+\n     /**\n      * @return true if the property owner can set a property \"does not exist\".\n      *         A good example is a Map. You can always assign a value to any\n \n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n+        NodePointer pointer2)\n     {\n         int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n         return r == 0 ? pointer1.getIndex() - pointer2.getIndex() : r;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n     }\n \n     /**\n-     * Get the required AbstractFactory configured on the specified JXPathContext. \n+     * Get the required AbstractFactory configured on the specified JXPathContext.\n      * @param context JXPathContext\n      * @return AbstractFactory\n      * @throws JXPathException if no factory configured.\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n     private Container container;\n     private NodePointer valuePointer;\n \n+    /**\n+     * Create a new ContainerPointer.\n+     * @param container Container object\n+     * @param locale Locale\n+     */\n     public ContainerPointer(Container container, Locale locale) {\n         super(null, locale);\n         this.container = container;\n     }\n \n+    /**\n+     * Create a new ContainerPointer.\n+     * @param parent parent pointer\n+     * @param container Container object\n+     */\n     public ContainerPointer(NodePointer parent, Container container) {\n         super(parent);\n         this.container = container;\n \n     /**\n      * This type of node is auxiliary.\n+     * @return <code>true</code>.\n      */\n     public boolean isContainer() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return container;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         Object value = getBaseValue();\n         return value == null ? 1 : ValueUtils.getLength(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return getValuePointer().isLeaf();\n-    }    \n-\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION) {\n         return ValueUtils.getValue(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         // TODO: what if this is a collection?\n         container.setValue(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = getImmediateNode();\n         return valuePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(container) + index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return container == other.container && index == other.index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n-    {\n+        NodePointer startWith) {\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer namespacePointer(String namespace) {\n         return getValuePointer().namespacePointer(namespace);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n-    {\n+        NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI(String prefix) {\n         return getValuePointer().getNamespaceURI(prefix);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         return parent == null ? \"/\" : parent.asPath();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale) \n+        Locale locale)\n     {\n         return bean instanceof Container ? new ContainerPointer((Container) bean, locale) : null;\n     }\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n-        Object bean) \n+        Object bean)\n     {\n         return bean instanceof Container ? new ContainerPointer(parent, (Container) bean) : null;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n     public Object getBaseValue() {\n         return attr;\n     }\n-    \n+\n     public boolean isCollection() {\n         return false;\n     }\n-    \n+\n     public int getLength() {\n         return 1;\n-    }    \n+    }\n \n     public Object getImmediateNode() {\n         return attr;\n \n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n+        NodePointer pointer2)\n     {\n         // Won't happen - attributes don't have children\n         return 0;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n     private List attributes;\n     private int position = 0;\n \n+    /**\n+     * Create a new DOMNamespaceIterator.\n+     * @param parent parent pointer\n+     */\n     public DOMNamespaceIterator(NodePointer parent) {\n         this.parent = parent;\n         attributes = new ArrayList();\n         collectNamespaces(attributes, (Node) parent.getNode());\n     }\n \n+    /**\n+     * Collect namespaces from attribute nodes.\n+     * @param attributes attribute list\n+     * @param node target node\n+     */\n     private void collectNamespaces(List attributes, Node node) {\n         Node parent = node.getParentNode();\n         if (parent != null) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new NamespacePointer(parent, prefix, attr.getValue());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n         NodePointer parent,\n         NodeTest nodeTest,\n         boolean reverse,\n-        NodePointer startWith) \n+        NodePointer startWith)\n     {\n         this.parent = parent;\n         this.node = (Node) parent.getNode();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n public class DOMNodePointer extends NodePointer {\n \n     private static final long serialVersionUID = -8751046933894857319L;\n-    \n+\n     private Node node;\n     private Map namespaces;\n     private String defaultNamespace;\n     private String id;\n     private NamespaceResolver localNamespaceResolver;\n \n-    public static final String XML_NAMESPACE_URI = \n+    public static final String XML_NAMESPACE_URI =\n             \"http://www.w3.org/XML/1998/namespace\";\n-    public static final String XMLNS_NAMESPACE_URI = \n+    public static final String XMLNS_NAMESPACE_URI =\n             \"http://www.w3.org/2000/xmlns/\";\n \n     public DOMNodePointer(Node node, Locale locale) {\n         super(parent);\n         this.node = node;\n     }\n-    \n+\n     public boolean testNode(NodeTest test) {\n         return testNode(node, test);\n     }\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n+        NodePointer startWith)\n     {\n         return new DOMNodeIterator(this, test, reverse, startWith);\n     }\n         if (namespace == UNKNOWN_NAMESPACE) {\n             return null;\n         }\n-        \n+\n         // TBD: We are supposed to resolve relative URIs to absolute ones.\n         return namespace;\n     }\n             }\n         }\n     }\n-    \n+\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n+        int index)\n     {\n         if (index == WHOLE_COLLECTION) {\n             index = 0;\n         if (success) {\n             NodeTest nodeTest;\n             String prefix = name.getPrefix();\n-            String namespaceURI = prefix == null ? null : \n+            String namespaceURI = prefix == null ? null :\n                 context.getNamespaceURI(prefix);\n             nodeTest = new NodeNameTest(name, namespaceURI);\n \n                         + \"/\" + name + \"[\" + (index + 1) + \"]\");\n     }\n \n-    public NodePointer createChild(JXPathContext context, \n+    public NodePointer createChild(JXPathContext context,\n                 QName name, int index, Object value)\n     {\n         NodePointer ptr = createChild(context, name, index);\n         }\n         return count;\n     }\n-    \n+\n     private int getRelativePositionOfElement() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n         int index = name.lastIndexOf(':');\n         return index < 0 ? name : name.substring(index + 1);\n     }\n-    \n+\n     public static String getNamespaceURI(Node node) {\n         if (node instanceof Document) {\n             node = ((Document) node).getDocumentElement();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n  */\n public class DOMPointerFactory implements NodePointerFactory {\n \n+    /** factory order */\n     public static final int DOM_POINTER_FACTORY_ORDER = 100;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return DOM_POINTER_FACTORY_ORDER;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale) \n-    {\n+        Locale locale) {\n         return bean instanceof Node ? new DOMNodePointer((Node) bean, locale) : null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n-        Object bean) \n-    {\n+        Object bean) {\n         return bean instanceof Node ? new DOMNodePointer(parent, (Node) bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n  * <code>DynamicAttributeIterator</code> is different from a regular\n  * <code>BeanAttributeIterator</code> in that given a property name it\n  * will always find that property (albeit with a null value).\n- *  \n+ *\n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n  * @version $Id$\n  */\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n     private Object bean;\n     private DynamicPropertyHandler handler;\n \n+    /**\n+     * Create a new DynamicPointer.\n+     * @param name property name\n+     * @param bean owning bean\n+     * @param handler DynamicPropertyHandler\n+     * @param locale Locale\n+     */\n     public DynamicPointer(QName name, Object bean,\n-            DynamicPropertyHandler handler, Locale locale)\n-    {\n+            DynamicPropertyHandler handler, Locale locale) {\n         super(null, locale);\n         this.name = name;\n         this.bean = bean;\n         this.handler = handler;\n     }\n \n+    /**\n+     * Create a new DynamicPointer.\n+     * @param parent parent pointer\n+     * @param name property name\n+     * @param bean owning bean\n+     * @param handler DynamicPropertyHandler\n+     */\n     public DynamicPointer(NodePointer parent, QName name,\n-            Object bean, DynamicPropertyHandler handler)\n-    {\n+            Object bean, DynamicPropertyHandler handler) {\n         super(parent);\n         this.name = name;\n         this.bean = bean;\n         this.handler = handler;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public PropertyPointer getPropertyPointer() {\n         return new DynamicPropertyPointer(this, handler);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator createNodeIterator(\n-                String property, boolean reverse, NodePointer startWith)\n-    {\n+                String property, boolean reverse, NodePointer startWith) {\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return new DynamicAttributeIterator(this, name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return name;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isDynamicPropertyDeclarationSupported() {\n         return true;\n     }\n-    \n+\n     /**\n      * Returns the DP object iself.\n+     * @return Object\n      */\n     public Object getBaseValue() {\n         return bean;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n-    }    \n-    \n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n     /**\n      * Returns 1.\n+     * @return int\n      */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         return parent == null ? \"/\" : super.asPath();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(bean) + name.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n public class DynamicPropertyPointer extends PropertyPointer {\n \n     private static final long serialVersionUID = -5720585681149150822L;\n-    \n+\n     private DynamicPropertyHandler handler;\n     private String name;\n     private String[] names;\n \n     public DynamicPropertyPointer(\n             NodePointer parent,\n-            DynamicPropertyHandler handler) \n+            DynamicPropertyHandler handler)\n     {\n         super(parent);\n         this.handler = handler;\n                 handler.setProperty(getBean(), getPropertyName(), collection);\n             }\n         }\n-        \n+\n         return this;\n     }\n-    \n+\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (index == WHOLE_COLLECTION) {\n             handler.setProperty(getBean(), getPropertyName(), value);\n             handler.setProperty(bean, getPropertyName(), null);\n         }\n     }\n-    \n+\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getImmediateParentPointer().asPath());\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n     private String prefix;\n     private String namespaceURI;\n \n+    /**\n+     * Create a new JDOMNamespacePointer.\n+     * @param parent parent pointer\n+     * @param prefix ns prefix\n+     */\n     public JDOMNamespacePointer(NodePointer parent, String prefix) {\n         super(parent);\n         this.prefix = prefix;\n     }\n \n+    /**\n+     * Create a new JDOMNamespacePointer.\n+     * @param parent parent pointer\n+     * @param prefix ns prefix\n+     * @param namespaceURI ns URI\n+     */\n     public JDOMNamespacePointer(\n             NodePointer parent,\n             String prefix,\n-            String namespaceURI) \n-    {\n+            String namespaceURI) {\n         super(parent);\n         this.prefix = prefix;\n         this.namespaceURI = namespaceURI;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return null;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n-    }    \n+    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         return namespaceURI;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n+     * @param value Object value to set\n      */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException(\"Cannot modify a namespace\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return prefix.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof JDOMNamespacePointer && prefix.equals(((JDOMNamespacePointer) object).prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n-    {\n+        NodePointer pointer2) {\n         // Won't happen - namespaces don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n-        NodePointer startWith) \n+        NodePointer startWith)\n     {\n         return new JDOMNodeIterator(this, test, reverse, startWith);\n     }\n     public String getNamespaceURI() {\n         return getNamespaceURI(node);\n     }\n-    \n+\n     private static String getNamespaceURI(Object node) {\n         if (node instanceof Element) {\n             Element element = (Element) node;\n         }\n         Element element = null;\n         if (node instanceof Document) {\n-            element = ((Document) node).getRootElement(); \n+            element = ((Document) node).getRootElement();\n         }\n         if (node instanceof Element) {\n             element = (Element) node;\n \n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n+        NodePointer pointer2)\n     {\n         Object node1 = pointer1.getBaseValue();\n         Object node2 = pointer2.getBaseValue();\n     public boolean isCollection() {\n         return false;\n     }\n-    \n+\n     public int getLength() {\n         return 1;\n-    }    \n+    }\n \n     public boolean isLeaf() {\n         if (node instanceof Element) {\n                 }\n             }\n         }\n-    } \n-      \n+    }\n+\n     private void addContent(List content) {\n         Element element = (Element) node;\n         int count = content.size();\n             }\n         }\n     }\n-    \n+\n     public boolean testNode(NodeTest test) {\n         return testNode(this, node, test);\n     }\n-    \n+\n     public static boolean testNode(\n         NodePointer pointer,\n         Object node,\n-        NodeTest test) \n+        NodeTest test)\n     {\n         if (test == null) {\n             return true;\n         }\n         return null;\n     }\n-    \n+\n     public static String getLocalName(Object node) {\n         if (node instanceof Element) {\n             return ((Element) node).getName();\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n+        int index)\n     {\n         if (index == WHOLE_COLLECTION) {\n             index = 0;\n                 }\n                 String nsURI = getNamespaceURI();\n                 String ln = JDOMNodePointer.getLocalName(node);\n-                \n+\n                 if (nsURI == null) {\n                     buffer.append(ln);\n                     buffer.append('[');\n             if (!(parent instanceof Element)) {\n                 return 1;\n             }\n-            \n+\n             List children = ((Element)parent).getContent();\n             int count = 0;\n             String name = ((Element) node).getQualifiedName();\n         }\n         return 1;\n     }\n-    \n+\n     private int getRelativePositionOfElement() {\n         Object parent = ((Element) node).getParent();\n         if (parent == null) {\n--- a/src/java/org/apache/commons/jxpath/ri/parser/ParseException.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/ParseException.java\n         break;\n       }\n       retval += add_escapes(tok.image);\n-      tok = tok.next; \n+      tok = tok.next;\n     }\n     retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n     retval += \".\" + eol;\n    * The end of line string for this machine.\n    */\n   protected String eol = System.getProperty(\"line.separator\", \"\\n\");\n- \n+\n   /**\n    * Used to convert raw characters to their escaped version\n    * when these raw version cannot be used as part of an ASCII\n--- a/src/java/org/apache/commons/jxpath/ri/parser/SimpleCharStream.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/SimpleCharStream.java\n   }\n \n   /**\n-   * @deprecated \n+   * @deprecated\n    * @see #getEndColumn\n    */\n \n   }\n \n   /**\n-   * @deprecated \n+   * @deprecated\n    * @see #getEndLine\n    */\n \n         bufcolumn[j] = newCol + columnDiff;\n         columnDiff = nextColDiff;\n         i++;\n-     } \n+     }\n \n      if (i < len)\n      {\n--- a/src/java/org/apache/commons/jxpath/ri/parser/TokenMgrError.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/TokenMgrError.java\n /* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 *\n- * \n+ *\n  * !!!MODIFIED BY DMITRI PLOTNIKOV - DO NOT REGENERATE!!!\n  */\n package org.apache.commons.jxpath.ri.parser;\n    /**\n     * Returns a detailed message for the Error when it is thrown by the\n     * token manager to indicate a lexical error.\n-    * Parameters : \n+    * Parameters :\n     *    EOFSeen     : indicates if EOF caused the lexicl error\n     *    curLexState : lexical state in which this error occured\n     *    errorLine   : line number when the error occured\n    /**\n     * You can also modify the body of this method to customize your error messages.\n     * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n-    * of end-users concern, so you can return something like : \n+    * of end-users concern, so you can return something like :\n     *\n     *     \"Internal Error : Please file a bug report .... \"\n     *\n       position = errorColumn - 1;\n       character = curChar;\n    }\n-   \n+\n \n    private int position;\n    private char character;\n--- a/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n+++ b/src/java/org/apache/commons/jxpath/ri/parser/XPathParserTokenManager.java\n private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(0, old0, old1); \n+      return jjStartNfa_0(0, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(1, active0, active1);\n private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(1, old0, old1); \n+      return jjStartNfa_0(1, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(2, active0, active1);\n private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(2, old0, old1); \n+      return jjStartNfa_0(2, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(3, active0, active1);\n private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(3, old0, old1); \n+      return jjStartNfa_0(3, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(4, active0, active1);\n private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(4, old0, old1); \n+      return jjStartNfa_0(4, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(5, active0, active1);\n private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(5, old0, old1); \n+      return jjStartNfa_0(5, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(6, active0, active1);\n private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(6, old0, old1); \n+      return jjStartNfa_0(6, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(7, active0, active1);\n private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(7, old0, old1); \n+      return jjStartNfa_0(7, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(8, active0, active1);\n private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(8, old0, old1); \n+      return jjStartNfa_0(8, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(9, active0, active1);\n private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(9, old0, old1); \n+      return jjStartNfa_0(9, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(10, active0, active1);\n private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(10, old0, old1); \n+      return jjStartNfa_0(10, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(11, active0, active1);\n private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(11, old0, old1); \n+      return jjStartNfa_0(11, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(12, active0, active1);\n private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(12, old0, old1); \n+      return jjStartNfa_0(12, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(13, active0, active1);\n private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1)\n {\n    if (((active0 &= old0) | (active1 &= old1)) == 0L)\n-      return jjStartNfa_0(13, old0, old1); \n+      return jjStartNfa_0(13, old0, old1);\n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(14, active0, 0L);\n    }\n }\n static final int[] jjnextStates = {\n-   1, 2, 4, 5, \n+   1, 2, 4, 5,\n };\n private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n {\n    {\n       case 0:\n          return ((jjbitVec2[i2] & l2) != 0L);\n-      default : \n+      default :\n          if ((jjbitVec0[i1] & l1) != 0L)\n             return true;\n          return false;\n          return ((jjbitVec25[i2] & l2) != 0L);\n       case 215:\n          return ((jjbitVec26[i2] & l2) != 0L);\n-      default : \n+      default :\n          if ((jjbitVec3[i1] & l1) != 0L)\n             return true;\n          return false;\n          return ((jjbitVec25[i2] & l2) != 0L);\n       case 215:\n          return ((jjbitVec26[i2] & l2) != 0L);\n-      default : \n+      default :\n          if ((jjbitVec3[i1] & l1) != 0L)\n             return true;\n          return false;\n    }\n }\n public static final String[] jjstrLiteralImages = {\n-\"\", null, null, null, null, null, \"\\57\", \"\\57\\57\", \"\\174\", \"\\53\", \"\\55\", \n-\"\\75\", \"\\41\\75\", \"\\74\", \"\\74\\75\", \"\\76\", \"\\76\\75\", \"\\44\", null, null, null, null, \n-null, null, null, null, null, \"\\157\\162\", \"\\141\\156\\144\", \"\\155\\157\\144\", \n-\"\\144\\151\\166\", \"\\156\\157\\144\\145\", \"\\164\\145\\170\\164\", \"\\143\\157\\155\\155\\145\\156\\164\", \n-\"\\160\\162\\157\\143\\145\\163\\163\\151\\156\\147\\55\\151\\156\\163\\164\\162\\165\\143\\164\\151\\157\\156\", \"\\163\\145\\154\\146\\72\\72\", \"\\143\\150\\151\\154\\144\\72\\72\", \n-\"\\160\\141\\162\\145\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\72\\72\", \n-\"\\141\\164\\164\\162\\151\\142\\165\\164\\145\\72\\72\", \"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\72\\72\", \n-\"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\72\\72\", \"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\72\\72\", \n-\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\", \n-\"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\", \"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\", \n-\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\", \"\\154\\141\\163\\164\", \"\\160\\157\\163\\151\\164\\151\\157\\156\", \n-\"\\143\\157\\165\\156\\164\", \"\\151\\144\", \"\\153\\145\\171\", \"\\154\\157\\143\\141\\154\\55\\156\\141\\155\\145\", \n-\"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\55\\165\\162\\151\", \"\\156\\141\\155\\145\", \"\\163\\164\\162\\151\\156\\147\", \"\\143\\157\\156\\143\\141\\164\", \n-\"\\163\\164\\141\\162\\164\\163\\55\\167\\151\\164\\150\", \"\\143\\157\\156\\164\\141\\151\\156\\163\", \n-\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\142\\145\\146\\157\\162\\145\", \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\141\\146\\164\\145\\162\", \n-\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\", \"\\163\\164\\162\\151\\156\\147\\55\\154\\145\\156\\147\\164\\150\", \n-\"\\156\\157\\162\\155\\141\\154\\151\\172\\145\\55\\163\\160\\141\\143\\145\", \"\\164\\162\\141\\156\\163\\154\\141\\164\\145\", \"\\142\\157\\157\\154\\145\\141\\156\", \n-\"\\156\\157\\164\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\156\\165\\154\\154\", \n-\"\\154\\141\\156\\147\", \"\\156\\165\\155\\142\\145\\162\", \"\\163\\165\\155\", \"\\146\\154\\157\\157\\162\", \n-\"\\143\\145\\151\\154\\151\\156\\147\", \"\\162\\157\\165\\156\\144\", \"\\146\\157\\162\\155\\141\\164\\55\\156\\165\\155\\142\\145\\162\", \n+\"\", null, null, null, null, null, \"\\57\", \"\\57\\57\", \"\\174\", \"\\53\", \"\\55\",\n+\"\\75\", \"\\41\\75\", \"\\74\", \"\\74\\75\", \"\\76\", \"\\76\\75\", \"\\44\", null, null, null, null,\n+null, null, null, null, null, \"\\157\\162\", \"\\141\\156\\144\", \"\\155\\157\\144\",\n+\"\\144\\151\\166\", \"\\156\\157\\144\\145\", \"\\164\\145\\170\\164\", \"\\143\\157\\155\\155\\145\\156\\164\",\n+\"\\160\\162\\157\\143\\145\\163\\163\\151\\156\\147\\55\\151\\156\\163\\164\\162\\165\\143\\164\\151\\157\\156\", \"\\163\\145\\154\\146\\72\\72\", \"\\143\\150\\151\\154\\144\\72\\72\",\n+\"\\160\\141\\162\\145\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\72\\72\",\n+\"\\141\\164\\164\\162\\151\\142\\165\\164\\145\\72\\72\", \"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\72\\72\",\n+\"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\72\\72\", \"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\72\\72\",\n+\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\72\\72\", \"\\141\\156\\143\\145\\163\\164\\157\\162\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\",\n+\"\\146\\157\\154\\154\\157\\167\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\", \"\\160\\162\\145\\143\\145\\144\\151\\156\\147\\55\\163\\151\\142\\154\\151\\156\\147\\72\\72\",\n+\"\\144\\145\\163\\143\\145\\156\\144\\141\\156\\164\\55\\157\\162\\55\\163\\145\\154\\146\\72\\72\", \"\\154\\141\\163\\164\", \"\\160\\157\\163\\151\\164\\151\\157\\156\",\n+\"\\143\\157\\165\\156\\164\", \"\\151\\144\", \"\\153\\145\\171\", \"\\154\\157\\143\\141\\154\\55\\156\\141\\155\\145\",\n+\"\\156\\141\\155\\145\\163\\160\\141\\143\\145\\55\\165\\162\\151\", \"\\156\\141\\155\\145\", \"\\163\\164\\162\\151\\156\\147\", \"\\143\\157\\156\\143\\141\\164\",\n+\"\\163\\164\\141\\162\\164\\163\\55\\167\\151\\164\\150\", \"\\143\\157\\156\\164\\141\\151\\156\\163\",\n+\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\142\\145\\146\\157\\162\\145\", \"\\163\\165\\142\\163\\164\\162\\151\\156\\147\\55\\141\\146\\164\\145\\162\",\n+\"\\163\\165\\142\\163\\164\\162\\151\\156\\147\", \"\\163\\164\\162\\151\\156\\147\\55\\154\\145\\156\\147\\164\\150\",\n+\"\\156\\157\\162\\155\\141\\154\\151\\172\\145\\55\\163\\160\\141\\143\\145\", \"\\164\\162\\141\\156\\163\\154\\141\\164\\145\", \"\\142\\157\\157\\154\\145\\141\\156\",\n+\"\\156\\157\\164\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\156\\165\\154\\154\",\n+\"\\154\\141\\156\\147\", \"\\156\\165\\155\\142\\145\\162\", \"\\163\\165\\155\", \"\\146\\154\\157\\157\\162\",\n+\"\\143\\145\\151\\154\\151\\156\\147\", \"\\162\\157\\165\\156\\144\", \"\\146\\157\\162\\155\\141\\164\\55\\156\\165\\155\\142\\145\\162\",\n null, \"\\72\", \"\\50\", \"\\51\", \"\\56\", \"\\56\\56\", \"\\133\", \"\\135\", \"\\100\", \"\\54\", \"\\52\", };\n public static final String[] lexStateNames = {\n-   \"DEFAULT\", \n+   \"DEFAULT\",\n };\n static final long[] jjtoToken = {\n-   0xfffffffff817ffc1L, 0x1ffffffL, \n+   0xfffffffff817ffc1L, 0x1ffffffL,\n };\n static final long[] jjtoSkip = {\n-   0x3eL, 0x0L, \n+   0x3eL, 0x0L,\n };\n protected SimpleCharStream input_stream;\n private final int[] jjrounds = new int[13];\n int jjmatchedPos;\n int jjmatchedKind;\n \n-public Token getNextToken() \n+public Token getNextToken()\n {\n   int kind;\n   Token specialToken = null;\n \n   EOFLoop :\n   for (;;)\n-  {   \n-   try   \n-   {     \n+  {\n+   try\n+   {\n       curChar = input_stream.BeginToken();\n-   }     \n+   }\n    catch(java.io.IOException e)\n-   {        \n+   {\n       jjmatchedKind = 0;\n       matchedToken = jjFillToken();\n       return matchedToken;\n--- a/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n public class HttpSessionHandler extends ServletContextHandler {\n \n     protected void collectPropertyNames(HashSet set, Object bean) {\n-        HttpSessionAndServletContext handle = \n+        HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         super.collectPropertyNames(set, handle.getServletContext());\n         HttpSession session = handle.getSession();\n             }\n         }\n     }\n-    \n+\n     public Object getProperty(Object bean, String property) {\n-        HttpSessionAndServletContext handle = \n+        HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         HttpSession session = handle.getSession();\n         if (session != null) {\n     }\n \n     public void setProperty(Object bean, String property, Object value) {\n-        HttpSessionAndServletContext handle = \n+        HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         HttpSession session = handle.getSession();\n         if (session != null) {\n--- a/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n      */\n     public static JXPathContext getRequestContext(\n         ServletRequest request,\n-        ServletContext servletContext) \n+        ServletContext servletContext)\n     {\n         JXPathContext context =\n             (JXPathContext) request.getAttribute(Constants.JXPATH_CONTEXT);\n         // will represent the included URL, but the JXPathContext we have\n         // just acquired will represent the outer request.\n         if (context != null) {\n-            ServletRequestAndContext handle = \n+            ServletRequestAndContext handle =\n                 (ServletRequestAndContext) context.getContextBean();\n             if (handle.getServletRequest() == request) {\n                 return context;\n             }\n         }\n-        \n+\n         JXPathContext parentContext = null;\n         if (request instanceof HttpServletRequest) {\n             HttpSession session =\n                 parentContext = getApplicationContext(servletContext);\n             }\n         }\n-        ServletRequestAndContext handle = \n+        ServletRequestAndContext handle =\n             new ServletRequestAndContext(request, servletContext);\n         context = factory.newContext(parentContext, handle);\n         context.setVariables(\n      */\n     public static JXPathContext getSessionContext(\n         HttpSession session,\n-        ServletContext servletContext) \n+        ServletContext servletContext)\n     {\n         JXPathContext context =\n             (JXPathContext) session.getAttribute(Constants.JXPATH_CONTEXT);\n         if (context == null) {\n             JXPathContext parentContext = getApplicationContext(servletContext);\n-            HttpSessionAndServletContext handle = \n+            HttpSessionAndServletContext handle =\n                 new HttpSessionAndServletContext(session, servletContext);\n             context = factory.newContext(parentContext, handle);\n             context.setVariables(\n      * context within the servlet context itself.\n      */\n     public static JXPathContext getApplicationContext(\n-            ServletContext servletContext) \n+            ServletContext servletContext)\n     {\n         JXPathContext context =\n             (JXPathContext) servletContext.getAttribute(\n--- a/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n     public void setProperty(\n         Object pageContext,\n         String property,\n-        Object value) \n+        Object value)\n     {\n         ((PageContext) pageContext).setAttribute(\n             property,\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n  * @version $Revision$ $Date$\n  */\n public class PageScopeContextHandler implements DynamicPropertyHandler {\n-    \n+\n     private static final String[] STRING_ARRAY = new String[0];\n \n     public String[] getPropertyNames(Object pageScope) {\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n  * @version $Revision$ $Date$\n  */\n public class ServletContextHandler implements DynamicPropertyHandler {\n-    \n+\n     private static final String[] STRING_ARRAY = new String[0];\n \n     public String[] getPropertyNames(Object context) {\n         collectPropertyNames(list, context);\n         return (String[]) list.toArray(STRING_ARRAY);\n     }\n-    \n+\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         Enumeration e = ((ServletContext) bean).getAttributeNames();\n         while (e.hasMoreElements()) {\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class ServletRequestAndContext extends\n-        HttpSessionAndServletContext\n-{\n+public class ServletRequestAndContext extends HttpSessionAndServletContext {\n     private ServletRequest request;\n \n+    /**\n+     * Create a new ServletRequestAndContext.\n+     * @param request ServletRequest\n+     * @param context ServletContext\n+     */\n     public ServletRequestAndContext(ServletRequest request,\n-            ServletContext context) \n-    {\n+            ServletContext context) {\n         super(null, context);\n         this.request = request;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public HttpSession getSession() {\n         return request instanceof HttpServletRequest\n                 ? ((HttpServletRequest) request).getSession(false) : null;\n     }\n \n+    /**\n+     * Get the request.\n+     * @return ServletRequest\n+     */\n     public ServletRequest getServletRequest() {\n         return request;\n     }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n  * @version $Revision$ $Date$\n  */\n public class ServletRequestHandler extends HttpSessionHandler {\n-    \n+\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         super.collectPropertyNames(set, bean);\n-        ServletRequestAndContext handle = (ServletRequestAndContext) bean; \n+        ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         ServletRequest servletRequest = handle.getServletRequest();\n         Enumeration e = servletRequest.getAttributeNames();\n         while (e.hasMoreElements()) {\n             set.add(e.nextElement());\n         }\n     }\n-    \n-    public Object getProperty(Object bean, String property) { \n-        ServletRequestAndContext handle = (ServletRequestAndContext) bean; \n+\n+    public Object getProperty(Object bean, String property) {\n+        ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         ServletRequest servletRequest = handle.getServletRequest();\n         String[] strings = servletRequest.getParameterValues(property);\n         if (strings != null) {\n             }\n             return strings;\n         }\n-        \n+\n         Object object = servletRequest.getAttribute(property);\n         if (object != null) {\n             return object;\n         }\n-        \n+\n         return super.getProperty(bean, property);\n     }\n \n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n                 }\n                 return unmodifiableCollection(collection);\n             }\n-            if (length > 0) { \n+            if (length > 0) {\n                 Object value = Array.get(object, 0);\n                 return convert(value, useType);\n             }\n         }\n         return null;\n     }\n-    \n+\n     protected Number allocateNumber(Class type, double value) {\n         type = TypeUtils.wrapPrimitive(type);\n         if (type == Byte.class) {\n         public ValueNodeSet(List values) {\n            this.values = values;\n         }\n-        \n+\n         public List getValues() {\n             return Collections.unmodifiableList(values);\n         }\n-        \n+\n         public List getNodes() {\n             return Collections.unmodifiableList(values);\n         }\n-        \n+\n         public List getPointers() {\n             if (pointers == null) {\n                 pointers = new ArrayList();\n             return pointers;\n         }\n     }\n-    \n+\n     static final class ValuePointer implements Pointer {\n         private Object bean;\n \n         public ValuePointer(Object object) {\n             this.bean = object;\n         }\n-        \n+\n         public Object getValue() {\n             return bean;\n         }\n-        \n+\n         public Object getNode() {\n             return bean;\n         }\n-        \n+\n         public Object getRootNode() {\n             return bean;\n-        }        \n-        \n+        }\n+\n         public void setValue(Object value) {\n             throw new UnsupportedOperationException();\n         }\n-        \n+\n         public Object clone() {\n             return this;\n         }\n-        \n+\n         public int compareTo(Object object) {\n             return 0;\n         }\n-        \n+\n         public String asPath() {\n             if (bean == null) {\n                 return \"null()\";\n--- a/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n     private static final int APPROXIMATE_MATCH = 1;\n     private static final int EXACT_MATCH = 2;\n \n+    /**\n+     * Look up a constructor.\n+     * @param targetClass the class constructed\n+     * @param parameters arguments\n+     * @return Constructor found if any.\n+     */\n     public static Constructor lookupConstructor(\n         Class targetClass,\n-        Object[] parameters)  \n-    {\n+        Object[] parameters) {\n         boolean tryExact = true;\n         int count = parameters == null ? 0 : parameters.length;\n-        Class types[] = new Class[count];\n+        Class[] types = new Class[count];\n         for (int i = 0; i < count; i++) {\n             Object param = parameters[i];\n             if (param != null) {\n         return constructor;\n     }\n \n+    /**\n+     * Look up a static method.\n+     * @param targetClass the owning class\n+     * @param name method name\n+     * @param parameters method parameters\n+     * @return Method found if any\n+     */\n     public static Method lookupStaticMethod(\n         Class targetClass,\n         String name,\n-        Object[] parameters) \n-    {\n+        Object[] parameters) {\n         boolean tryExact = true;\n         int count = parameters == null ? 0 : parameters.length;\n-        Class types[] = new Class[count];\n+        Class[] types = new Class[count];\n         for (int i = 0; i < count; i++) {\n             Object param = parameters[i];\n             if (param != null) {\n         return method;\n     }\n \n+    /**\n+     * Look up a method.\n+     * @param targetClass owning class\n+     * @param name method name\n+     * @param parameters method parameters\n+     * @return Method found if any\n+     */\n     public static Method lookupMethod(\n         Class targetClass,\n         String name,\n-        Object[] parameters) \n-    {\n+        Object[] parameters) {\n         if (parameters == null\n             || parameters.length < 1\n             || parameters[0] == null) {\n \n         boolean tryExact = true;\n         int count = parameters.length - 1;\n-        Class types[] = new Class[count];\n-        Object arguments[] = new Object[count];\n+        Class[] types = new Class[count];\n+        Object[] arguments = new Object[count];\n         for (int i = 0; i < count; i++) {\n             Object param = parameters[i + 1];\n             arguments[i] = param;\n         return method;\n     }\n \n+    /**\n+     * Return a match code of objects to types.\n+     * @param types Class[] of expected types\n+     * @param parameters Object[] to attempt to match\n+     * @return int code\n+     */\n     private static int matchParameterTypes(\n-        Class types[],\n-        Object parameters[]) \n-    {\n+        Class[] types,\n+        Object[] parameters) {\n         int pi = 0;\n         if (types.length >= 1\n             && ExpressionContext.class.isAssignableFrom(types[0])) {\n         return totalMatch;\n     }\n \n+    /**\n+     * Return a match code between an object and type.\n+     * @param expected class to test\n+     * @param object object to test\n+     * @return int code\n+     */\n     private static int matchType(Class expected, Object object) {\n         if (object == null) {\n             return APPROXIMATE_MATCH;\n--- a/src/java/org/apache/commons/jxpath/util/TypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeConverter.java\n     /**\n      * Returns true if it can convert the supplied\n      * object to the specified class.\n+     * @param object object to test\n+     * @param toType target class\n+     * @return boolean\n      */\n     boolean canConvert(Object object, Class toType);\n \n      * Converts the supplied object to the specified\n      * type. Throws a runtime exception if the conversion is\n      * not possible.\n+     * @param object object to convert\n+     * @param toType target class\n+     * @return resulting Object\n      */\n     Object convert(Object object, Class toType);\n }\n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n \n     /**\n      * Install an alternative type converter.\n+     * @param converter new TypeConverter\n      */\n     public static synchronized void setTypeConverter(TypeConverter converter) {\n         typeConverter = converter;\n \n     /**\n      * Returns the current type converter.\n+     * @return TypeConverter\n      */\n     public static TypeConverter getTypeConverter() {\n         return typeConverter;\n     /**\n      * Returns true if the global converter can convert the supplied\n      * object to the specified type.\n+     * @param object object to test\n+     * @param toType target class\n+     * @return boolean\n      */\n     public static boolean canConvert(Object object, Class toType) {\n         return typeConverter.canConvert(object, toType);\n     /**\n      * Converts the supplied object to the specified type. May\n      * throw a RuntimeException.\n+     * @param object object to convert\n+     * @param toType target class\n+     * @return resulting Object\n      */\n     public static Object convert(Object object, Class toType) {\n         return typeConverter.convert(object, toType);\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n         }\n         return false;\n     }\n-    \n-    /**\n-     * Returns 1 if the type is a collection, \n+\n+    /**\n+     * Returns 1 if the type is a collection,\n      * -1 if it is definitely not\n      * and 0 if it may be a collection in some cases.\n      */\n         if (clazz.isArray()) {\n             return 1;\n         }\n-        \n+\n         if (Collection.class.isAssignableFrom(clazz)) {\n             return 1;\n         }\n-        \n+\n         if (clazz.isPrimitive()) {\n             return -1;\n         }\n-        \n+\n         if (clazz.isInterface()) {\n             return 0;\n         }\n-        \n+\n         if (Modifier.isFinal(clazz.getModifiers())) {\n             return -1;\n         }\n-                \n+\n         return 0;\n     }\n-    \n+\n     /**\n      * If there is a regular non-indexed read method for this property,\n      * uses this method to obtain the collection and then returns its\n      * length.\n      * Otherwise, attempts to guess the length of the collection by\n      * calling the indexed get method repeatedly.  The method is supposed\n-     * to throw an exception if the index is out of bounds. \n+     * to throw an exception if the index is out of bounds.\n      */\n     public static int getIndexedPropertyLength(\n         Object object,\n-        IndexedPropertyDescriptor pd) \n+        IndexedPropertyDescriptor pd)\n     {\n         if (pd.getReadMethod() != null) {\n             return getLength(getValue(object, pd));\n         }\n-        \n+\n         Method readMethod = pd.getIndexedReadMethod();\n         if (readMethod == null) {\n             throw new JXPathException(\n                 return i;\n             }\n         }\n-        \n+\n         throw new JXPathException(\n             \"Cannot determine the length of the indexed property \"\n                 + pd.getName());\n      */\n     public static Object getValue(\n         Object bean,\n-        PropertyDescriptor propertyDescriptor) \n+        PropertyDescriptor propertyDescriptor)\n     {\n         Object value;\n         try {\n     public static void setValue(\n         Object bean,\n         PropertyDescriptor propertyDescriptor,\n-        Object value) \n+        Object value)\n     {\n         try {\n             Method method =\n     public static Object getValue(\n         Object bean,\n         PropertyDescriptor propertyDescriptor,\n-        int index) \n+        int index)\n     {\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n                         bean,\n                         new Object[] { new Integer(index)});\n                 }\n-            }            \n+            }\n             catch (InvocationTargetException ex) {\n                 Throwable t = ex.getTargetException();\n                 if (t instanceof IndexOutOfBoundsException) {\n         Object bean,\n         PropertyDescriptor propertyDescriptor,\n         int index,\n-        Object value) \n+        Object value)\n     {\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n         }\n         return object;\n     }\n-    \n+\n     /**\n      * Returns a shared instance of the dynamic property handler class\n      * returned by <code>getDynamicPropertyHandlerClass()</code>.\n      */\n-    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) \n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz)\n     {\n         DynamicPropertyHandler handler =\n             (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz);\n         Class[] parameterTypes = method.getParameterTypes();\n         while (clazz != null) {\n             // Check the implemented interfaces and subinterfaces\n-            Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, \n+            Method aMethod = getAccessibleMethodFromInterfaceNest(clazz,\n                     name, parameterTypes);\n             if (aMethod != null) {\n                 return aMethod;\n             }\n-            \n+\n             clazz = clazz.getSuperclass();\n             if (clazz != null && Modifier.isPublic(clazz.getModifiers())) {\n                 try {\n                     return clazz.getDeclaredMethod(name, parameterTypes);\n-                } \n+                }\n                 catch (NoSuchMethodException e) {\n                     ;\n                 }\n     private static Method getAccessibleMethodFromInterfaceNest(\n         Class clazz,\n         String methodName,\n-        Class parameterTypes[]) \n+        Class parameterTypes[])\n     {\n \n         Method method = null;\n             if (method != null) {\n                 break;\n             }\n-            \n+\n             // Recursively check our parent interfaces\n             method =\n                 getAccessibleMethodFromInterfaceNest(\n--- a/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n  */\n public class DOMParser extends XMLParser2 {\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object parseXML(InputStream stream) {\n         try {\n             DocumentBuilderFactory factory =\n                     DocumentBuilderFactory.newInstance();\n-            \n+\n             factory.setValidating(isValidating());\n             factory.setNamespaceAware(isNamespaceAware());\n             factory.setIgnoringElementContentWhitespace(\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n  */\n public class DocumentContainer extends XMLParser2 implements Container {\n \n+    /** DOM constant */\n     public static final String MODEL_DOM = \"DOM\";\n+\n+    /** JDOM constant */\n     public static final String MODEL_JDOM = \"JDOM\";\n \n     private Object document;\n     /**\n      * Add an XML parser.  Parsers for the models \"DOM\" and \"JDOM\" are\n      * pre-registered.\n+     * @param model model name\n+     * @param parser parser\n      */\n     public static void registerXMLParser(String model, XMLParser parser) {\n         parsers.put(model, parser);\n     }\n \n     /**\n-     * Add a class of a custom XML parser. \n+     * Add a class of a custom XML parser.\n      * Parsers for the models \"DOM\" and \"JDOM\" are pre-registered.\n-     */    \n+     * @param model model name\n+     * @param parserClassName parser classname\n+     */\n     public static void registerXMLParser(String model, String parserClassName) {\n         parserClasses.put(model, parserClassName);\n     }\n     }\n \n     /**\n+     * Construct a new DocumentContainer.\n      * @param xmlURL is a URL for an XML file. Use getClass().getResource\n-     * (resourceName) to load XML from a resource file.\n+     *               (resourceName) to load XML from a resource file.\n      *\n      * @param model is one of the MODEL_* constants defined in this class. It\n-     *   determines which parser should be used to load the XML.\n+     *              determines which parser should be used to load the XML.\n      */\n     public DocumentContainer(URL xmlURL, String model) {\n         this.xmlURL = xmlURL;\n \n     /**\n      * Reads XML, caches it internally and returns the Document.\n+     * @return Object\n      */\n     public Object getValue() {\n         if (document == null) {\n \n     /**\n      * Parses XML using the parser for the specified model.\n+     * @param stream InputStream\n+     * @return Object\n      */\n     public Object parseXML(InputStream stream) {\n         XMLParser parser = getParser(model);\n     }\n \n     /**\n-     * Throws an UnsupportedOperationException\n+     * Throws an UnsupportedOperationException.\n+     * @param value value (not) to set\n      */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException();\n \n     /**\n      * Maps a model type to a parser.\n+     * @param model input model type\n+     * @return XMLParser\n      */\n-    private static final XMLParser getParser(String model) {\n+    private static XMLParser getParser(String model) {\n         XMLParser parser = (XMLParser) parsers.get(model);\n         if (parser == null) {\n             String className = (String) parserClasses.get(model);\n             }\n             try {\n                 Class clazz = Class.forName(className);\n-                parser = (XMLParser) clazz.newInstance();                \n+                parser = (XMLParser) clazz.newInstance();\n             }\n             catch (Exception ex) {\n                 throw new JXPathException(\n--- a/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n  * @version $Revision$ $Date$\n  */\n public class JDOMParser extends XMLParser2 {\n-    \n+\n     public Object parseXML(InputStream stream) {\n         if (!isNamespaceAware()) {\n             throw new JXPathException(\"JDOM parser configuration error. JDOM \"\n                     + \"does not support the namespaceAware=false setting.\");\n         }\n-        \n+\n         try {\n             SAXBuilder builder = new SAXBuilder();\n             builder.setExpandEntities(isExpandEntityReferences());\n--- a/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n+++ b/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public abstract class XMLParser2 implements XMLParser \n+public abstract class XMLParser2 implements XMLParser\n {\n     private boolean validating = false;\n     private boolean namespaceAware = true;\n     private boolean expandEntityRef = true;\n     private boolean ignoreComments = false;\n     private boolean coalescing = false;\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setValidating(boolean)\n      */\n     public void setValidating(boolean validating) {\n         this.validating = validating;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isValidating()\n      */\n     public boolean isValidating() {\n         return validating;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isNamespaceAware()\n      */\n     public boolean isNamespaceAware() {\n         return namespaceAware;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setNamespaceAware(boolean)\n      */\n     public void setNamespaceAware(boolean namespaceAware) {\n         this.namespaceAware = namespaceAware;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setIgnoringElementContentWhitespace(boolean)\n      */\n     public void setIgnoringElementContentWhitespace(boolean whitespace) {\n         this.whitespace = whitespace;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isIgnoringElementContentWhitespace()\n      */\n     public boolean isIgnoringElementContentWhitespace() {\n         return whitespace;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isExpandEntityReferences()\n      */\n     public boolean isExpandEntityReferences() {\n         return expandEntityRef;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setExpandEntityReferences(boolean)\n      */\n     public void setExpandEntityReferences(boolean expandEntityRef) {\n         this.expandEntityRef = expandEntityRef;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isIgnoringComments()\n      */\n     public boolean isIgnoringComments() {\n         return ignoreComments;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setIgnoringComments(boolean)\n      */\n     public void setIgnoringComments(boolean ignoreComments) {\n         this.ignoreComments = ignoreComments;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#isCoalescing()\n      */\n     public boolean isCoalescing() {\n         return coalescing;\n     }\n-    \n+\n     /**\n      * @see DocumentBuilderFactory#setCoalescing(boolean)\n      */\n     public void setCoalescing(boolean coalescing) {\n         this.coalescing = coalescing;\n     }\n-    \n+\n     public abstract Object parseXML(InputStream stream);\n }", "timestamp": 1197876568, "metainfo": ""}