{"sha": "790cc3b3b124ce58f14fb1036386280c52189d6c", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathNotFoundException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathNotFoundException.java\n  * @author Dmitri Plotnikov\n  * @version $Revision: 155422 $ $Date: 2005-02-26 08:07:46 -0500 (Sat, 26 Feb 2005) $\n  */\n-\n public class JXPathNotFoundException extends JXPathException {\n \n     private static final long serialVersionUID = -8875537628056117241L;\n \n+    /**\n+     * Create a new JXPathNotFoundException.\n+     * @param message exception detail\n+     */\n     public JXPathNotFoundException(String message) {\n         super(message);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n     private static final Double ZERO = new Double(0);\n     private int functionCode;\n \n+    /**\n+     * Create a new CoreFunction.\n+     * @param functionCode int function code\n+     * @param args argument Expressions\n+     */\n     public CoreFunction(int functionCode, Expression args[]) {\n         super(args);\n         this.functionCode = functionCode;\n     }\n \n+    /**\n+     * Get the function code.\n+     * @return int function code\n+     */\n     public int getFunctionCode() {\n         return functionCode;\n     }\n-    \n+\n+    /**\n+     * Get the name of this function.\n+     * @return String function name\n+     */\n     protected String getFunctionName() {\n         switch (functionCode) {\n             case Compiler.FUNCTION_LAST :\n         return \"unknownFunction\" + functionCode + \"()\";\n     }\n \n+    /**\n+     * Convenience method to return the first argument.\n+     * @return Expression\n+     */\n     public Expression getArg1() {\n         return args[0];\n     }\n \n+    /**\n+     * Convenience method to return the second argument.\n+     * @return Expression\n+     */\n     public Expression getArg2() {\n         return args[1];\n     }\n \n+    /**\n+     * Convenience method to return the third argument.\n+     * @return Expression\n+     */\n     public Expression getArg3() {\n         return args[2];\n     }\n \n+    /**\n+     * Return the number of argument Expressions.\n+     * @return int count\n+     */\n     public int getArgumentCount() {\n         if (args == null) {\n             return 0;\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getFunctionName());\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n     /**\n-     * Computes a built-in function\n+     * {@inheritDoc}\n      */\n     public Object computeValue(EvalContext context) {\n         switch (functionCode) {\n         return null;\n     }\n \n+    /**\n+     * last() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionLast(EvalContext context) {\n         assertArgCount(0);\n         // Move the position to the beginning and iterate through\n         return new Double(count);\n     }\n \n+    /**\n+     * position() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionPosition(EvalContext context) {\n         assertArgCount(0);\n         return new Integer(context.getCurrentPosition());\n     }\n \n+    /**\n+     * count() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionCount(EvalContext context) {\n         assertArgCount(1);\n         Expression arg1 = getArg1();\n         return new Double(count);\n     }\n \n+    /**\n+     * lang() implementation.\n+     * @param context evaluation context\n+     * @return Boolean\n+     */\n     protected Object functionLang(EvalContext context) {\n         assertArgCount(1);\n         String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * id() implementation.\n+     * @param context evaluation context\n+     * @return Pointer\n+     */\n     protected Object functionID(EvalContext context) {\n         assertArgCount(1);\n         String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return pointer.getPointerByID(jxpathContext, id);\n     }\n \n+    /**\n+     * key() implementation.\n+     * @param context evaluation context\n+     * @return various Object\n+     */\n     protected Object functionKey(EvalContext context) {\n         assertArgCount(2);\n         String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return new NodeSetContext(context, nodeSet);\n     }\n \n+    /**\n+     * namespace-uri() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionNamespaceURI(EvalContext context) {\n         if (getArgumentCount() == 0) {\n             NodePointer ptr = context.getCurrentNodePointer();\n         return \"\";\n     }\n \n+    /**\n+     * local-name() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionLocalName(EvalContext context) {\n         if (getArgumentCount() == 0) {\n             NodePointer ptr = context.getCurrentNodePointer();\n         return \"\";\n     }\n \n+    /**\n+     * name() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionName(EvalContext context) {\n         if (getArgumentCount() == 0) {\n             NodePointer ptr = context.getCurrentNodePointer();\n         return \"\";\n     }\n \n+    /**\n+     * string() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionString(EvalContext context) {\n         if (getArgumentCount() == 0) {\n             return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n         return InfoSetUtil.stringValue(getArg1().computeValue(context));\n     }\n \n+    /**\n+     * concat() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionConcat(EvalContext context) {\n         if (getArgumentCount() < 2) {\n             assertArgCount(2);\n         return buffer.toString();\n     }\n \n+    /**\n+     * starts-with() implementation.\n+     * @param context evaluation context\n+     * @return Boolean\n+     */\n     protected Object functionStartsWith(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * contains() implementation.\n+     * @param context evaluation context\n+     * @return Boolean\n+     */\n     protected Object functionContains(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * substring-before() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionSubstringBefore(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return s1.substring(0, index);\n     }\n \n+    /**\n+     * substring-after() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionSubstringAfter(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return s1.substring(index + s2.length());\n     }\n \n+    /**\n+     * substring() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionSubstring(EvalContext context) {\n         int ac = getArgumentCount();\n         if (ac != 2 && ac != 3) {\n         return s1.substring((int) from - 1, (int) (to - 1));\n     }\n \n+    /**\n+     * string-length() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionStringLength(EvalContext context) {\n         String s;\n         if (getArgumentCount() == 0) {\n         return new Double(s.length());\n     }\n \n+    /**\n+     * normalize-space() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionNormalizeSpace(EvalContext context) {\n         assertArgCount(1);\n         String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return new String(chars, 0, out);\n     }\n \n+    /**\n+     * translate() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     protected Object functionTranslate(EvalContext context) {\n         assertArgCount(3);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         return new String(chars, 0, out);\n     }\n \n+    /**\n+     * boolean() implementation.\n+     * @param context evaluation context\n+     * @return Boolean\n+     */\n     protected Object functionBoolean(EvalContext context) {\n         assertArgCount(1);\n         return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n             : Boolean.FALSE;\n     }\n \n+    /**\n+     * not() implementation.\n+     * @param context evaluation context\n+     * @return Boolean\n+     */\n     protected Object functionNot(EvalContext context) {\n         assertArgCount(1);\n         return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n             : Boolean.TRUE;\n     }\n \n+    /**\n+     * true() implementation.\n+     * @param context evaluation context\n+     * @return Boolean.TRUE\n+     */\n     protected Object functionTrue(EvalContext context) {\n         assertArgCount(0);\n         return Boolean.TRUE;\n     }\n \n+    /**\n+     * false() implementation.\n+     * @param context evaluation context\n+     * @return Boolean.FALSE\n+     */\n     protected Object functionFalse(EvalContext context) {\n         assertArgCount(0);\n         return Boolean.FALSE;\n     }\n \n+    /**\n+     * null() implementation.\n+     * @param context evaluation context\n+     * @return null\n+     */\n     protected Object functionNull(EvalContext context) {\n         assertArgCount(0);\n         return null;\n     }\n \n+    /**\n+     * number() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionNumber(EvalContext context) {\n         if (getArgumentCount() == 0) {\n             return InfoSetUtil.number(context.getCurrentNodePointer());\n         return InfoSetUtil.number(getArg1().computeValue(context));\n     }\n \n+    /**\n+     * sum() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionSum(EvalContext context) {\n         assertArgCount(1);\n         Object v = getArg1().compute(context);\n             \"Invalid argument type for 'sum': \" + v.getClass().getName());\n     }\n \n+    /**\n+     * floor() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionFloor(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.floor(v));\n     }\n \n+    /**\n+     * ceiling() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionCeiling(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.ceil(v));\n     }\n \n+    /**\n+     * round() implementation.\n+     * @param context evaluation context\n+     * @return Number\n+     */\n     protected Object functionRound(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.round(v));\n     }\n \n+    /**\n+     * format-number() implementation.\n+     * @param context evaluation context\n+     * @return String\n+     */\n     private Object functionFormatNumber(EvalContext context) {\n         int ac = getArgumentCount();\n         if (ac != 2 && ac != 3) {\n         return format.format(number);\n     }\n \n+    /**\n+     * Assert <code>count</code> args.\n+     * @param count int\n+     */\n     private void assertArgCount(int count) {\n         assertArgRange(count, count);\n     }\n \n+    /**\n+     * Assert at least <code>min</code>/at most <code>max</code> args.\n+     * @param min int\n+     * @param max int\n+     */\n     private void assertArgRange(int min, int max) {\n         int ct = getArgumentCount();\n         if (ct < min || ct > max) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAdd.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAdd.java\n  */\n public class CoreOperationAdd extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationAdd.\n+     * @param args Expression arguments to add together.\n+     */\n     public CoreOperationAdd(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         double s = 0.0;\n         for (int i = 0; i < args.length; i++) {\n         }\n         return new Double(s);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return 4;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"+\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n  */\n public class CoreOperationEqual extends CoreOperationCompare {\n \n+    /**\n+     * Create a new CoreOperationEqual\n+     * @param arg1 first comparison Expression\n+     * @param arg2 second comparison Expression\n+     */\n     public CoreOperationEqual(Expression arg1, Expression arg2) {\n         super(arg1, arg2);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n  */\n public class CoreOperationLessThan extends CoreOperationRelationalExpression {\n \n+    /**\n+     * Create a new CoreOperationLessThan.\n+     * @param arg1 left Expression\n+     * @param arg2 right Expression\n+     */\n     public CoreOperationLessThan(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean evaluateCompare(int compare) {\n         return compare < 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"<\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n \n     /**\n      * The factory order number determines its position between other factories.\n+     * @return int order\n      */\n     int getOrder();\n \n      * Create a NodePointer for the supplied object.  The node will represent\n      * the \"root\" object for a path.\n      *\n+     * @param name String node name\n+     * @param object child object\n+     * @param locale Locale\n      * @return  null if this factory does not recognize objects of the supplied\n      * type.\n      */\n     /**\n      * Create a NodePointer for the supplied child object.\n      * <p>\n+     * @param parent parent node\n+     * @param name String node name\n+     * @param object child object\n      * @return null if this factory does not recognize objects of the supplied\n      * type.\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n public class BeanPropertyPointer extends PropertyPointer {\n     private String propertyName;\n     private JXPathBeanInfo beanInfo;\n-    private PropertyDescriptor propertyDescriptors[];\n+    private PropertyDescriptor[] propertyDescriptors;\n     private PropertyDescriptor propertyDescriptor;\n     private String[] names;\n     private static final Object UNINITIALIZED = new Object();\n     private Object baseValue = UNINITIALIZED;\n     private Object value = UNINITIALIZED;\n-    \n-\n+\n+    /**\n+     * Create a new BeanPropertyPointer.\n+     * @param parent parent pointer\n+     * @param beanInfo describes the target property/ies.\n+     */\n     public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo) {\n         super(parent);\n         this.beanInfo = beanInfo;\n \n     /**\n      * This type of node is auxiliary.\n+     * @return true\n      */\n     public boolean isContainer() {\n         return true;\n     }\n \n     /**\n-     * Number of the bean's properties.\n+     * {@inheritDoc}\n      */\n     public int getPropertyCount() {\n         if (beanInfo.isAtomic()) {\n     }\n \n     /**\n-     * Names of all properties, sorted alphabetically\n+     * Get the names of all properties, sorted alphabetically\n+     * @return String[]\n      */\n     public String[] getPropertyNames() {\n         if (names == null) {\n     }\n \n     /**\n-     * Select a property by name\n+     * Select a property by name.\n+     * @param propertyName String name\n      */\n     public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n \n     /**\n      * Selects a property by its offset in the alphabetically sorted list.\n+     * @param index property index\n      */\n     public void setPropertyIndex(int index) {\n         if (propertyIndex != index) {\n     }\n \n     /**\n-     * The value of the currently selected property.\n+     * Get the value of the currently selected property.\n+     * @return Object value\n      */\n     public Object getBaseValue() {\n         if (baseValue == UNINITIALIZED) {\n         return baseValue;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setIndex(int index) {\n         if (this.index != index) {\n             // When dealing with a scalar, index == 0 is equivalent to\n      * the value of the index'th element of the collection represented by the\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n+     * @return Object\n      */\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n         return value;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isActualProperty() {\n         return getPropertyDescriptor() != null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null) {\n     /**\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n+     * @return int length\n      */\n     public int getLength() {\n         PropertyDescriptor pd = getPropertyDescriptor();\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n      * represented by the property.\n+     * @param value value to set\n      */\n     public void setValue(Object value) {\n         PropertyDescriptor pd = getPropertyDescriptor();\n     }\n \n     /**\n-     * @see PropertyPointer#createPath(JXPathContext)\n+     * {@inheritDoc}\n      */\n     public NodePointer createPath(JXPathContext context) {\n         if (getImmediateNode() == null) {\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             setValue(null);\n     }\n \n     /**\n-     * Name of the currently selected property.\n+     * Get the name of the currently selected property.\n+     * @return String property name\n      */\n     public String getPropertyName() {\n         if (propertyName == null) {\n     /**\n      * Finds the property descriptor corresponding to the current property\n      * index.\n+     * @return PropertyDescriptor\n      */\n     private PropertyDescriptor getPropertyDescriptor() {\n         if (propertyDescriptor == null) {\n                     beanInfo.getPropertyDescriptor(propertyName);\n             }\n             else {\n-                PropertyDescriptor propertyDescriptors[] =\n+                PropertyDescriptor[] propertyDescriptors =\n                     getPropertyDescriptors();\n                 if (inx >= 0 && inx < propertyDescriptors.length) {\n                     propertyDescriptor = propertyDescriptors[inx];\n         return propertyDescriptor;\n     }\n \n-    protected PropertyDescriptor[] getPropertyDescriptors() {\n+    /**\n+     * Get all PropertyDescriptors.\n+     * @return PropertyDescriptor[]\n+     */\n+    protected synchronized PropertyDescriptor[] getPropertyDescriptors() {\n         if (propertyDescriptors == null) {\n             propertyDescriptors = beanInfo.getPropertyDescriptors();\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n     private Object collection;\n     private NodePointer valuePointer;\n \n+    /**\n+     * Create a new CollectionPointer.\n+     * @param collection value\n+     * @param locale Locale\n+     */\n     public CollectionPointer(Object collection, Locale locale) {\n         super(null, locale);\n         this.collection = collection;\n     }\n \n+    /**\n+     * Create a new CollectionPointer.\n+     * @param parent parent NodePointer\n+     * @param collection value\n+     */\n     public CollectionPointer(NodePointer parent, Object collection) {\n         super(parent);\n         this.collection = collection;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return collection;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return ValueUtils.getLength(getBaseValue());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isContainer() {\n         return index != WHOLE_COLLECTION;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return index == WHOLE_COLLECTION ? ValueUtils.getValue(collection)\n                 : ValueUtils.getValue(collection, index);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         if (index == WHOLE_COLLECTION) {\n             parent.setValue(value);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setIndex(int index) {\n         super.setIndex(index);\n         valuePointer = null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getValuePointer() {\n         if (valuePointer == null) {\n             if (index == WHOLE_COLLECTION) {\n         return valuePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         Object collection = getBaseValue();\n         if (ValueUtils.getLength(collection) <= index) {\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         NodePointer ptr = createPath(context);\n         ptr.setValue(value);\n         return ptr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         int index,\n-        Object value) \n-    {\n+        Object value) {\n         NodePointer ptr = (NodePointer) clone();\n         ptr.setIndex(index);\n         return ptr.createPath(context, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n-    {\n+        int index) {\n         NodePointer ptr = (NodePointer) clone();\n         ptr.setIndex(index);\n         return ptr.createPath(context);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(collection) + index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return collection == other.collection && index == other.index;\n     }\n \n-    public NodeIterator childIterator(NodeTest test, \n-                boolean reverse, NodePointer startWith)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodeIterator childIterator(NodeTest test,\n+                boolean reverse, NodePointer startWith) {\n         if (index == WHOLE_COLLECTION) {\n             return new CollectionChildNodeIterator(\n                 this,\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return index == WHOLE_COLLECTION ? new CollectionAttributeNodeIterator(this, name)\n                 : getValuePointer().attributeIterator(name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator namespaceIterator() {\n         return index == WHOLE_COLLECTION ? null : getValuePointer().namespaceIterator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer namespacePointer(String namespace) {\n         return index == WHOLE_COLLECTION ? null : getValuePointer().namespacePointer(namespace);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest test) {\n         if (index == WHOLE_COLLECTION) {\n             if (test == null) {\n         return getValuePointer().testNode(test);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n-                NodePointer pointer1, NodePointer pointer2)\n-    {\n+                NodePointer pointer1, NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n \n     /**\n-     * Returns an XPath that maps to this Pointer.\n+     * {@inheritDoc}\n      */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n  * @version $Revision$ $Date$\n  */\n public class LangAttributePointer extends NodePointer {\n+    /**\n+     * Create a new LangAttributePointer.\n+     * @param parent parent pointer.\n+     */\n     public LangAttributePointer(NodePointer parent) {\n         super(parent);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(\"xml\", \"lang\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return parent.getLocale().toString().replace('_', '-');\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return getBaseValue();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n+     * @param value Object\n      */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException(\n     }\n \n     /**\n+     * {@inheritDoc}\n      */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         return object instanceof LangAttributePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest test) {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2)\n-    {\n+        NodePointer pointer2) {\n         // Won't happen - lang attributes don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n public abstract class PropertyPointer extends NodePointer {\n     public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n \n+    /** property index */\n     protected int propertyIndex = UNSPECIFIED_PROPERTY;\n+\n+    /** owning object */\n     protected Object bean;\n \n     /**\n      * Takes a javabean, a descriptor of a property of that object and\n      * an offset within that property (starting with 0).\n+     * @param parent parent pointer\n      */\n     public PropertyPointer(NodePointer parent) {\n         super(parent);\n     }\n \n+    /**\n+     * Get the property index.\n+     * @return int index\n+     */\n     public int getPropertyIndex() {\n         return propertyIndex;\n     }\n \n+    /**\n+     * Set the property index.\n+     * @param index property index\n+     */\n     public void setPropertyIndex(int index) {\n         if (propertyIndex != index) {\n             propertyIndex = index;\n         }\n     }\n \n+    /**\n+     * Get the parent bean.\n+     * @return Object\n+     */\n     public Object getBean() {\n         if (bean == null) {\n             bean = getImmediateParentPointer().getNode();\n         return bean;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(null, getPropertyName());\n     }\n \n+    /**\n+     * Get the property name.\n+     * @return String property name.\n+     */\n     public abstract String getPropertyName();\n \n+    /**\n+     * Set the property name.\n+     * @param propertyName property name to set.\n+     */\n     public abstract void setPropertyName(String propertyName);\n \n+    /**\n+     * Count the number of properties represented.\n+     * @return int\n+     */\n     public abstract int getPropertyCount();\n \n+    /**\n+     * Get the names of the included properties.\n+     * @return String[]\n+     */\n     public abstract String[] getPropertyNames();\n \n+    /**\n+     * Learn whether this pointer references an actual property.\n+     * @return true if actual\n+     */\n     protected abstract boolean isActualProperty();\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         if (!isActualProperty()) {\n             return false;\n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n             value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n         }\n         return value;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     /**\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n+     * @return int length\n      */\n     public int getLength() {\n         return ValueUtils.getLength(getBaseValue());\n     }\n \n-\n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n+     * @return NodePointer\n      */\n     public NodePointer getImmediateValuePointer() {\n         return NodePointer.newChildNodePointer(\n             getImmediateNode());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         if (getImmediateNode() == null) {\n             AbstractFactory factory = getAbstractFactory(context);\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         // If neccessary, expand collection\n         if (index != WHOLE_COLLECTION && index >= getLength()) {\n             createPath(context);\n         }\n-        setValue(value);            \n+        setValue(value);\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         int index,\n-        Object value) \n-    {\n+        Object value) {\n         PropertyPointer prop = (PropertyPointer) clone();\n         if (name != null) {\n             prop.setPropertyName(name.toString());\n         return prop.createPath(context, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n-        int index) \n-    {\n+        int index) {\n         PropertyPointer prop = (PropertyPointer) clone();\n         if (name != null) {\n             prop.setPropertyName(name.toString());\n         return prop.createPath(context);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return getImmediateParentPointer().hashCode() + propertyIndex + index;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return iThis == iOther;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n-    {\n+        NodePointer pointer2) {\n         return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n     }\n-    \n+\n+    /**\n+     * Get the required AbstractFactory configured on the specified JXPathContext. \n+     * @param context JXPathContext\n+     * @return AbstractFactory\n+     * @throws JXPathException if no factory configured.\n+     */\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n     private String prefix;\n     private String namespaceURI;\n \n+    /**\n+     * Create a new NamespacePointer.\n+     * @param parent parent pointer\n+     * @param prefix associated ns prefix.\n+     */\n     public NamespacePointer(NodePointer parent, String prefix) {\n         super(parent);\n         this.prefix = prefix;\n     }\n \n+    /**\n+     * Create a new NamespacePointer.\n+     * @param parent parent pointer\n+     * @param prefix associated ns prefix.\n+     * @param namespaceURI associated ns URI.\n+     */\n     public NamespacePointer(\n         NodePointer parent,\n         String prefix,\n-        String namespaceURI) \n-    {\n+        String namespaceURI) {\n         super(parent);\n         this.prefix = prefix;\n         this.namespaceURI = namespaceURI;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return null;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n-    }    \n+    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         return namespaceURI;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n+     * @param value Object\n      */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest nodeTest) {\n         return nodeTest == null\n             || ((nodeTest instanceof NodeTypeTest)\n                     == Compiler.NODE_TYPE_NODE);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return prefix.hashCode();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return prefix.equals(other.prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n-        NodePointer pointer2) \n-    {\n+        NodePointer pointer2) {\n         // Won't happen - namespaces don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n  */\n public class DynamicPointerFactory implements NodePointerFactory {\n \n+    /**\n+     * Factory order constant.\n+     */\n     public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return DYNAMIC_POINTER_FACTORY_ORDER;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n-        Locale locale) \n-    {\n+        Locale locale) {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         if (bi.isDynamic()) {\n             DynamicPropertyHandler handler =\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n-        Object bean) \n-    {\n+        Object bean) {\n         if (bean == null) {\n             return new NullPointer(parent, name);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n \n /**\n  * @deprecated - no longer needed, as it is identical to PropertyIterator.\n- * \n+ *\n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n  * @version $Id$\n  */\n public class DynamicPropertyIterator extends PropertyIterator {\n \n+    /**\n+     * Create a new DynamicPropertyIterator\n+     * @param pointer PropertyOwnerPointer\n+     * @param name String\n+     * @param reverse iteration order\n+     * @param startWith beginning child\n+     */\n     public DynamicPropertyIterator(\n             PropertyOwnerPointer pointer,\n             String name,\n             boolean reverse,\n-            NodePointer startWith) \n-    {\n+            NodePointer startWith) {\n         super(pointer, name, reverse, startWith);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n         this.attr = attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(\n             JDOMNodePointer.getPrefix(attr),\n             JDOMNodePointer.getLocalName(attr));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         String uri = attr.getNamespaceURI();\n         if (uri != null && uri.equals(\"\")) {\n         return uri;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         return attr.getValue();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n-     * Sets the value of this attribute.\n+     * {@inheritDoc}\n      */\n     public void setValue(Object value) {\n         attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         attr.getParent().removeAttribute(attr);\n     }\n \n     /**\n+     * {@inheritDoc}\n      */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         return buffer.toString();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof JDOMAttributePointer\n                 && ((JDOMAttributePointer) object).attr == attr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n             NodePointer pointer1,\n             NodePointer pointer2) {\n--- a/src/java/org/apache/commons/jxpath/servlet/HttpSessionAndServletContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/HttpSessionAndServletContext.java\n     private HttpSession session;\n     private ServletContext context;\n \n+    /**\n+     * Create a new HttpSessionAndServletContext.\n+     * @param session HttpSession\n+     * @param context ServletContext\n+     */\n     public HttpSessionAndServletContext(HttpSession session,\n             ServletContext context) {\n         this.session = session;\n         this.context = context;\n     }\n-    \n+\n+    /**\n+     * Get the session.\n+     * @return HttpSession\n+     */\n     public HttpSession getSession() {\n         return session;\n     }\n-    \n+\n+    /**\n+     * Get the ServletContext.\n+     * @return ServletContext\n+     */\n     public ServletContext getServletContext() {\n         return context;\n     }", "timestamp": 1197667879, "metainfo": ""}