{"sha": "d81c5a5f5d996971ab9b46a7a70124e456f7a878", "log": "javadoc + 1 refactoring  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n     private String id;\n     private NamespaceResolver localNamespaceResolver;\n \n+    /** XML namespace URI */\n     public static final String XML_NAMESPACE_URI =\n             \"http://www.w3.org/XML/1998/namespace\";\n+\n+    /** XMLNS namespace URI */\n     public static final String XMLNS_NAMESPACE_URI =\n             \"http://www.w3.org/2000/xmlns/\";\n \n+    /**\n+     * Create a new DOMNodePointer.\n+     * @param node pointed at\n+     * @param locale Locale\n+     */\n     public DOMNodePointer(Node node, Locale locale) {\n         super(null, locale);\n         this.node = node;\n     }\n \n+    /**\n+     * Create a new DOMNodePointer.\n+     * @param node pointed at\n+     * @param locale Locale\n+     * @param id string id\n+     */\n     public DOMNodePointer(Node node, Locale locale, String id) {\n         super(null, locale);\n         this.node = node;\n         this.id = id;\n     }\n \n+    /**\n+     * Create a new DOMNodePointer.\n+     * @param parent pointer\n+     * @param node pointed\n+     */\n     public DOMNodePointer(NodePointer parent, Node node) {\n         super(parent);\n         this.node = node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean testNode(NodeTest test) {\n         return testNode(node, test);\n     }\n \n+    /**\n+     * Test a Node.\n+     * @param node to test\n+     * @param test to execute\n+     * @return true if node passes test\n+     */\n     public static boolean testNode(Node node, NodeTest test) {\n         if (test == null) {\n             return true;\n         return false;\n     }\n \n+    /**\n+     * Test string equality.\n+     * @param s1 String 1\n+     * @param s2 String 2\n+     * @return true if == or .equals()\n+     */\n     private static boolean equalStrings(String s1, String s2) {\n         if (s1 == s2) {\n             return true;\n         return s1.equals(s2);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         String ln = null;\n         String ns = null;\n         return new QName(ns, ln);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI() {\n         return getNamespaceURI(node);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n         return new DOMNodeIterator(this, test, reverse, startWith);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator attributeIterator(QName name) {\n         return new DOMAttributeIterator(this, name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer namespacePointer(String prefix) {\n         return new NamespacePointer(this, prefix);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodeIterator namespaceIterator() {\n         return new DOMNamespaceIterator(this);\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.apache.commons.jxpath.ri.model.NodePointer#getNamespaceResolver()\n+    /**\n+     * {@inheritDoc}\n      */\n     public synchronized NamespaceResolver getNamespaceResolver() {\n         if (localNamespaceResolver == null) {\n         return localNamespaceResolver;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getNamespaceURI(String prefix) {\n         if (prefix == null || prefix.equals(\"\")) {\n             return getDefaultNamespaceURI();\n         return namespace;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getDefaultNamespaceURI() {\n         if (defaultNamespace == null) {\n             Node aNode = node;\n         return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return node;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return !node.hasChildNodes();\n     }\n      * Returns true if the xml:lang attribute for the current node\n      * or its parent has the specified prefix <i>lang</i>.\n      * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n+     * @param lang ns to test\n+     * @return boolean\n      */\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n                 : current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n+    /**\n+     * Find the nearest occurrence of the specified attribute\n+     * on the specified and enclosing elements.\n+     * @param n current node\n+     * @param attrName attribute name\n+     * @return attribute value\n+     */\n     protected static String findEnclosingAttribute(Node n, String attrName) {\n         while (n != null) {\n             if (n.getNodeType() == Node.ELEMENT_NODE) {\n         return null;\n     }\n \n+    /**\n+     * Get the language attribute for this node. \n+     * @return String language name\n+     */\n     protected String getLanguage() {\n         return findEnclosingAttribute(node, \"xml:lang\");\n     }\n      * a String, the contents of the node are replaced with this text.\n      * If the value is an Element or Document, the children of the\n      * node are replaced with the children of the passed node.\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         if (node.getNodeType() == Node.TEXT_NODE\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n                         + \"/\" + name + \"[\" + (index + 1) + \"]\");\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createChild(JXPathContext context,\n                 QName name, int index, Object value)\n     {\n         return ptr;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n         if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         return it.getNodePointer();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         Node parent = node.getParentNode();\n         if (parent == null) {\n         parent.removeChild(node);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n                 buffer.append(getRelativePositionOfTextNode()).append(']');\n                 break;\n             case Node.PROCESSING_INSTRUCTION_NODE :\n-                String target = ((ProcessingInstruction) node).getTarget();\n                 buffer.append(\"/processing-instruction(\\'\");\n-                buffer.append(target).append(\"')\");\n+                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                 buffer.append('[');\n-                buffer.append(getRelativePositionOfPI(target)).append(']');\n+                buffer.append(getRelativePositionOfPI()).append(']');\n                 break;\n             case Node.DOCUMENT_NODE :\n                 // That'll be empty\n         return buffer.toString();\n     }\n \n+    /**\n+     * Return a string escaping single and double quotes.\n+     * @param string string to treat\n+     * @return string with any necessary changes made.\n+     */\n     private String escape(String string) {\n         int index = string.indexOf('\\'');\n         while (index != -1) {\n         return string;\n     }\n \n+    /**\n+     * Get relative position of this among like-named siblings.\n+     * @return 1..n\n+     */\n     private int getRelativePositionByName() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n         return count;\n     }\n \n+    /**\n+     * Get relative position of this among all siblings.\n+     * @return 1..n\n+     */\n     private int getRelativePositionOfElement() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n         return count;\n     }\n \n+    /**\n+     * Get the relative position of this among sibling text nodes.\n+     * @return 1..n\n+     */\n     private int getRelativePositionOfTextNode() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n         return count;\n     }\n \n-    private int getRelativePositionOfPI(String target) {\n+    /**\n+     * Get the relative position of this among same-target processing instruction siblings.\n+     * @return 1..n\n+     */\n+    private int getRelativePositionOfPI() {\n         int count = 1;\n+        String target = ((ProcessingInstruction) node).getTarget();\n         Node n = node.getPreviousSibling();\n         while (n != null) {\n             if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n         return count;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int hashCode() {\n         return System.identityHashCode(node);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n     }\n \n+    /**\n+     * Get any prefix from the specified node.\n+     * @param node the node to check\n+     * @return String xml prefix\n+     */\n     public static String getPrefix(Node node) {\n         String prefix = node.getPrefix();\n         if (prefix != null) {\n         return index < 0 ? null : name.substring(0, index);\n     }\n \n+    /**\n+     * Get the local name of the specified node.\n+     * @param node node to check\n+     * @return String local name\n+     */\n     public static String getLocalName(Node node) {\n         String localName = node.getLocalName();\n         if (localName != null) {\n         return index < 0 ? name : name.substring(index + 1);\n     }\n \n+    /**\n+     * Get the ns uri of the specified node.\n+     * @param node Node to check\n+     * @return String ns uri\n+     */\n     public static String getNamespaceURI(Node node) {\n         if (node instanceof Document) {\n             node = ((Document) node).getDocumentElement();\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n         return stringValue(node);\n     }\n \n+    /**\n+     * Get the string value of the specified node.\n+     * @param node Node to check\n+     * @return String\n+     */\n     private String stringValue(Node node) {\n         int nodeType = node.getNodeType();\n         if (nodeType == Node.COMMENT_NODE) {\n \n     /**\n      * Locates a node by ID.\n+     * @param context starting context\n+     * @param id to find\n+     * @return Pointer\n      */\n     public Pointer getPointerByID(JXPathContext context, String id) {\n         Document document = node.getNodeType() == Node.DOCUMENT_NODE ? (Document) node\n                 : new DOMNodePointer(element, getLocale(), id);\n     }\n \n+    /**\n+     * Get the AbstractFactory associated with the specified JXPathContext.\n+     * @param context JXPathContext\n+     * @return AbstractFactory\n+     */\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {\n         return factory;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int compareChildNodePointers(\n             NodePointer pointer1, NodePointer pointer2)\n     {", "timestamp": 1201988059, "metainfo": ""}