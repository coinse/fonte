{"sha": "34b7a47ae949c763178a457582a5df2cb564f53d", "log": "Multiple changes   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.1 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:19 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * The {@link JXPathContext#createPath JXPathContext.createPath()} method of JXPathContext can create\n+ * missing objects as it traverses an XPath; it utilizes an AbstractFactory for that purpose.\n+ * Install a factory on JXPathContext by calling {@link JXPathContext#setFactory\n+ * JXPathContext.setFactory()}.\n+ * <p>\n+ * All methods of this class return false.  Override any of them to\n+ * return true to indicate that the factory has successfully created the described object.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:19 $\n+ */\n+public abstract class AbstractFactory {\n+\n+    /**\n+     * The parameters may describe a collection element or an individual object. It is up\n+     * to the factory to infer which one it is. If it is a collection, the\n+     * factory should check if the collection exists.  If not, it should create\n+     * the collection. Then it should create the index'th element of the collection\n+     * and return it.\n+     * <p>\n+     * If the parameters describe an individual object, the factory should only\n+     * create an object if index == 0.\n+     * <p>\n+     * Return the created object or <b>null</b> if this factory cannot create\n+     * the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        return false;\n+    }\n+\n+    /**\n+     * The factory should expand the collection to the specified size and return true. If\n+     * it cannot expand the collection, it should return false.\n+     */\n+    public boolean expandCollection(JXPathContext context, Pointer pointer, Object parent, String name, int size){\n+        return false;\n+    }\n+\n+    /**\n+     * Create a new object and set it on the specified variable\n+     */\n+    public boolean declareVariable(JXPathContext context, String name){\n+        return false;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *  <dd>Equivalent to <code>new Integer(4).floatValue()</code></dd>\n  * </dl>\n  *\n+ * <p>\n+ * If the first argument of a method is ExpressionContext, the\n+ * expression context in which the function is evaluated is passed to\n+ * the method.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class ClassFunctions implements Functions {\n     private Class functionClass;\n--- a/src/java/org/apache/commons/jxpath/ExpressionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ExpressionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ExpressionContext.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ExpressionContext.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * If an extenstion function has an argument of type ExpressionContext,\n- * it can gain access to the current node or all nodes of\n- * an XPath expression context.\n+ * it can gain access to the current node of an XPath expression context.\n  * <p>\n  * Example:\n  * <blockquote><pre>\n  *       if (value == null){\n  *           return \"null\";\n  *       }\n- *       return value.getClass();\n+ *       return value.getClass().getName();\n  *    }\n  * }\n  * </pre></blockquote>\n  * You can then register this extension function using a {@link ClassFunctions\n  * ClassFunctions} object and call it like this:\n  * <blockquote><pre>\n- *   \"/descendent-or-self::node()[ns:objectType(.) = 'java.util.Date']\"\n+ *   \"/descendent-or-self::node()[ns:objectType() = 'java.util.Date']\"\n  * </pre></blockquote>\n  * This expression will find all nodes of the graph that are dates.\n  */\n public interface ExpressionContext\n {\n+    /**\n+     * Get the JXPathContext in which this function is being evaluated.\n+     *\n+     * @return A list representing the current context nodes.\n+     */\n+    public JXPathContext getJXPathContext();\n+\n     /**\n      * Get the current context node.\n      *\n      * @return A list representing the current context nodes.\n      */\n     public List getContextNodeList();\n+\n+    /**\n+     * Returns the current context position.\n+     */\n+    public int getPosition();\n }\n--- a/src/java/org/apache/commons/jxpath/Function.java\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Function.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Function.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * See {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public interface Function {\n \n      * Computes the value of the function. Each implementation of Function\n      * is responsible for conversion of supplied parameters to the required\n      * argument types.\n+     *\n+     * @param context can be used to acquire the context in which the\n+     *    function is being evaluted.\n      */\n-    Object invoke(Object[] parameters);\n+    Object invoke(ExpressionContext context, Object[] parameters);\n }\n--- a/src/java/org/apache/commons/jxpath/JXPath.java\n+++ b/src/java/org/apache/commons/jxpath/JXPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Attic/JXPath.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Attic/JXPath.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * request to it. Use JXPathContext APIs instead of JXPath APIs if any of\n  * the following requirements exist:\n  * <ul>\n- * <li>There is a need to evaluate multiple XPaths over the same object graph.\n- * JXPathContext is optimized for that.\n  * <li>There is a need for the support of variables.  JXPathContext has a method\n  * that allows registering of a pool of variables.\n  * <li>There is a need to use extension functions other than\n  * Java method calls using the default syntax (see {@link PackageFunctions\n  * PackageFunctions}\n+ * <li>There is a need to use an AbstractFactory, which can create new objects.\n+ * <li>There is a need to use a hierarchy of evaluation contexts.\n  * </ul>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public final class JXPath {\n \n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.4 2001/09/26 23:37:39 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2001/09/26 23:37:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.5 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A collection can be an arbitrary array or an instance of java.util.Collection.\n  * <p>\n  * Note: in XPath the first element of a collection has index 1, not 0.<br>\n- * Note: The root node of the context can be a collection too. If you want\n- * to follow the standard XPath syntax then instead of using the \".[3]\" syntax\n- * you should use \"self::node()[3]\".\n  *\n  * <h3>Example 4: Map Element Access</h3>\n  *\n  * ...\n  *\n  * JXPathContext context = JXPathContext.newContext(auth);\n- * List threeBooks = (List)context.eval(\"books[position() < 4]\");\n+ * List threeBooks = (List)context.eval(\"books[position() &lt; 4]\");\n  * </blockquote></pre>\n  *\n  * This returns a list of at most three books from the array of all books\n  *\n  * </blockquote></pre>\n  *\n- * <h3>Example 7: Using Variables</h3>\n+ * <h3>Example 7: Creating objects</h3>\n+ * JXPath can be used to create new objects. First, create a subclass of\n+ * {@link AbstractFactory AbstractFactory} and install it on the JXPathContext.\n+ * Then call {@link JXPathContext#createPath createPath()} instead of \"setValue\".\n+ * JXPathContext will invoke your AbstractFactory when it discovers that an\n+ * intermediate node of the path is <b>null</b>.  It will not override existing\n+ * nodes.\n+ *\n+ * <pre><blockquote>\n+ * public class AddressFactory extends AbstractFactory {\n+ *    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+ *     if ((parent instanceof Employee) &amp;&amp; name.equals(\"address\"){\n+ *       ((Employee)parent).setAddress(new Address());\n+ *       return true;\n+ *     }\n+ *     return false;\n+ *   }\n+ * }\n+ *\n+ * JXPathContext context = JXPathContext.newContext(emp);\n+ * context.setFactory(new AddressFactory());\n+ * context.createPath(\"address/zipCode\", \"90190\");\n+ * </blockquote></pre>\n+ *\n+ * <h3>Example 8: Using Variables</h3>\n  * JXPath supports the notion of variables. The XPath syntax for accessing\n  * variables is <i>\"$varName\"</i>.\n  *\n  * String title = (String)context.getValue(\"$books[2]/title);\n  * </blockquote></pre>\n  *\n- * <h3>Example 8: Using Nested Contexts</h3>\n+ * <h3>Example 9: Using Nested Contexts</h3>\n  * If you need to use the same set of variable while interpreting\n  * XPaths with different beans, it makes sense to put the variables in a separate\n  * context and specify that context as a parent context every time you\n  * As you can see, the target of the method is specified as the first parameter\n  * of the function.\n  *\n- * <h3>Example 10: Using Custom Extension Functions</h3>\n+ * <h3>Example 11: Using Custom Extension Functions</h3>\n  * Collections of custom extension functions can be implemented\n  * as {@link Functions Functions} objects or as Java classes, whose methods\n  * become extenstion functions.\n  *\n  * <h2>Notes</h2>\n  * <ul>\n- * <li>The current version of JXPath does not support DOM attributes. Even though XPaths\n+ * <li>JXPath does not support DOM attributes for non-DOM objects. Even though XPaths\n  *     like \"para[@type='warning']\" are legitimate, they will always produce empty results.\n- *     This may change in future versions of XPath: the related trade-offs are currently\n- *     being evaluated.\n+ *     The only attribute supported for JavaBeans is \"name\".  The XPath \"foo/bar\" is\n+ *     equivalent to \"foo[@name='bar']\".\n  * <li>The current version of JXPath does not support the <code>id(string)</code>\n  *     and <code>key(key, value)</code> XPath functions.\n  * </ul>\n  *\n- * See <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n+ * See <a href=\"http://www.w3schools.com/xpath\">XPath Tutorial by W3Schools</a><br>\n+ * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2001/09/26 23:37:39 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/10 03:40:19 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n     protected Object contextBean;\n     protected Variables vars;\n     protected Functions functions;\n+    protected AbstractFactory factory;\n     protected Locale locale;\n     protected boolean lenient = false;\n \n     public Functions getFunctions(){\n         // TBD: default lib\n         return functions;\n+    }\n+\n+    public void setFactory(AbstractFactory factory){\n+        this.factory = factory;\n+    }\n+\n+    /**\n+     * Returns the AbstractFactory installed on this context.\n+     * If none has been installed, it calls getFactory() on\n+     * the parent context.\n+     */\n+    public AbstractFactory getFactory(){\n+        if (factory == null && parentContext != null){\n+            return parentContext.getFactory();\n+        }\n+        return factory;\n     }\n \n     /**\n     public abstract void setValue(String xpath, Object value);\n \n     /**\n+     * The same as setValue, except it creates intermediate elements of\n+     * the path by invoking an AbstractFactory, which should first be\n+     * installed on the context by calling \"setFactory\".\n+     * <p>\n+     * Will throw an exception if one of the following conditions occurs:\n+     * <ul>\n+     * <li>Elements of the xpath aleady exist, by the path does not in\n+     *  fact describe an existing property\n+     * <li>The AbstractFactory fails to create an instance for an intermediate\n+     * element.\n+     * <li>The property is not writable (no public, non-static set method)\n+     * </ul>\n+     */\n+    public abstract void createPath(String xpath, Object value);\n+\n+    /**\n      * Traverses the xpath and returns a List of objects. Even if\n      * there is only one object that matches the xpath, it will be returned\n      * as a collection with one element.  If the xpath matches no properties\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *  a member of the package described by this PackageFunctions object.</dd>\n  * </dl>\n  *\n+ * <p>\n+ * If the first argument of a method or constructor is ExpressionContext, the\n+ * expression context in which the function is evaluated is passed to\n+ * the method.\n+ * </p>\n+ * <p>\n  * There is one PackageFunctions object registered by default with each\n  * JXPathContext.  It does not have a namespace and uses no class prefix.\n  * The existence of this object allows us to use XPaths like:\n  * <code>\"java.util.Date.new()\"</code> and <code>\"length('foo')\"</code>\n  * without the explicit registration of any extension functions.\n+ * </p>\n+\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n             Object target = parameters[0];\n             if (target != null){\n                 if (target instanceof ExpressionContext){\n-                    target = ((ExpressionContext)target).getContextNodePointer().getValue();\n+                    Pointer pointer = ((ExpressionContext)target).getContextNodePointer();\n+                    if (pointer != null){\n+                        target = pointer.getValue();\n+                    }\n+                    else {\n+                        target = null;\n+                    }\n                 }\n             }\n             if (target != null){\n-                Method method = Types.lookupMethod(Object.class, name, parameters);\n+                Method method = Types.lookupMethod(target.getClass(), name, parameters);\n                 if (method != null){\n                     return new MethodFunction(method);\n                 }\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An extension function that creates an instance using a constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class ConstructorFunction implements Function {\n \n     private Constructor constructor;\n+    private static final Object EMPTY_ARRAY[] = new Object[0];\n \n     public ConstructorFunction(Constructor constructor){\n         this.constructor = constructor;\n     /**\n      * Converts parameters to suitable types and invokes the constructor.\n      */\n-    public Object invoke(Object[] parameters){\n+    public Object invoke(ExpressionContext context, Object[] parameters){\n         try {\n             Object[] args;\n             if (parameters == null){\n-                args = null;\n+                parameters = EMPTY_ARRAY;\n             }\n-            else {\n-                Class types[] = constructor.getParameterTypes();\n-                args = new Object[parameters.length];\n-                for (int i = 0; i < args.length; i++){\n-                    args[i] = Types.convert(parameters[i], types[i]);\n-                }\n+            int pi = 0;\n+            Class types[] = constructor.getParameterTypes();\n+            if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])){\n+                pi = 1;\n+            }\n+            args = new Object[parameters.length + pi];\n+            if (pi == 1){\n+                args[0] = context;\n+            }\n+            for (int i = 0; i < parameters.length; i++){\n+                args[i + pi] = Types.convert(parameters[i], types[i]);\n             }\n             return constructor.newInstance(args);\n         }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class MethodFunction implements Function {\n \n     private Method method;\n+    private static final Object EMPTY_ARRAY[] = new Object[0];\n \n     public MethodFunction(Method method){\n         this.method = method;\n     }\n \n-    /**\n-     */\n-    public Object invoke(Object[] parameters){\n+    public Object invoke(ExpressionContext context, Object[] parameters){\n         try {\n             Object target;\n             Object[] args;\n             if (Modifier.isStatic(method.getModifiers())){\n                 target = null;\n                 if (parameters == null){\n-                    args = null;\n+                    parameters = EMPTY_ARRAY;\n                 }\n-                else {\n-                    Class types[] = method.getParameterTypes();\n-                    args = new Object[parameters.length];\n-                    for (int i = 0; i < args.length; i++){\n-                        args[i] = Types.convert(parameters[i], types[i]);\n-                    }\n+                int pi = 0;\n+                Class types[] = method.getParameterTypes();\n+                if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+                    pi = 1;\n+                }\n+                args = new Object[parameters.length + pi];\n+                if (pi == 1){\n+                    args[0] = context;\n+                }\n+                for (int i = 0; i < parameters.length; i++){\n+                    args[i + pi] = Types.convert(parameters[i], types[i + pi]);\n                 }\n             }\n             else {\n+                int pi = 0;\n+                Class types[] = method.getParameterTypes();\n+                if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+                    pi = 1;\n+                }\n                 target = Types.convert(parameters[0], method.getDeclaringClass());\n-                Class types[] = method.getParameterTypes();\n-                args = new Object[parameters.length - 1];\n-                for (int i = 0; i < args.length; i++){\n-                    args[i] = Types.convert(parameters[i + 1], types[i]);\n+                args = new Object[parameters.length - 1 + pi];\n+                if (pi == 1){\n+                    args[0] = context;\n+                }\n+                for (int i = 1; i < parameters.length; i++){\n+                    args[pi + i - 1] = Types.convert(parameters[i], types[i - 1]);\n                 }\n             }\n \n             return method.invoke(target, args);\n         }\n         catch (Exception exception){\n+            exception.printStackTrace();\n             // TBD\n             throw new RuntimeException(\"Cannot invoke \" + method + \": \" + exception);\n         }\n--- a/src/java/org/apache/commons/jxpath/functions/Types.java\n+++ b/src/java/org/apache/commons/jxpath/functions/Types.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/Attic/Types.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/Attic/Types.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class Types {\n \n             throw new RuntimeException(\"Ambigous method call: \" + name);\n         }\n         return method;\n-   }\n+    }\n+\n     public static int matchParameterTypes(Class types[], Object parameters[]){\n-        if (types.length != parameters.length){\n+        int pi = 0;\n+        if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+            pi++;\n+        }\n+        if (types.length != parameters.length + pi){\n             return NO_MATCH;\n         }\n         int totalMatch = EXACT_MATCH;\n-        for (int i = 0; i < types.length; i++){\n-            int match = matchType(types[i], parameters[i]);\n+        for (int i = 0; i < parameters.length; i++){\n+            int match = matchType(types[i + pi], parameters[i]);\n             if (match == NO_MATCH){\n                 return NO_MATCH;\n             }\n     }\n \n     public static boolean canConvert(Object object, Class toType){\n+        if (object == null){\n+            return true;\n+        }\n+\n+        if (toType == Object.class){\n+            return true;\n+        }\n+\n         Class fromType = object.getClass();\n         if (fromType.equals(toType)){\n             return true;\n             if (Collection.class.isAssignableFrom(toType)){\n                 return true;\n             }\n-            // TBD: array arguments\n-            Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n-            return canConvert(value, toType);\n+            Pointer pointer = ((ExpressionContext)object).getContextNodePointer();\n+            if (pointer != null){\n+                Object value = pointer.getValue();\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (fromType.isArray()){\n+            if (Array.getLength(object) == 1){\n+                Object value = Array.get(object, 0);\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (object instanceof List){\n+            if (((List)object).size() == 1){\n+                Object value = ((List)object).get(0);\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (object instanceof Collection){\n+            if (!((Collection)object).isEmpty()){\n+                Iterator it = ((Collection)object).iterator();\n+                Object value = it.next();\n+                return canConvert(value, toType);\n+            }\n         }\n \n         // TBD: date conversion to/from string\n     public static Object convert(Object object, Class toType){\n         if (object == null){\n             return null;\n+        }\n+\n+        if (toType == Object.class){\n+            return object;\n         }\n \n         if (object instanceof ExpressionContext){\n                 return new Double((String)object);\n             }\n         }\n+        else if (fromType.isArray()){\n+            Object value = Array.get(object, 0);\n+            return convert(value, toType);\n+        }\n+        else if (object instanceof List){\n+            Object value = ((List)object).get(0);\n+            return convert(value, toType);\n+        }\n+        else if (object instanceof Collection){\n+            Iterator it = ((Collection)object).iterator();\n+            Object value = it.next();\n+            return convert(value, toType);\n+        }\n         return object;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.5 2001/09/26 23:37:38 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2001/09/26 23:37:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.6 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri;\n \n+import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.pointers.*;\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2001/09/26 23:37:38 $\n+ * @version $Revision: 1.6 $ $Date: 2002/04/10 03:40:19 $\n  */\n-public abstract class EvalContext implements ExpressionContext {\n+public abstract class EvalContext {\n     protected EvalContext parentContext;\n     protected RootContext rootContext;\n     protected int position = 0;\n     private boolean startedSetIteration = false;\n+    private EvalExpressionContext expressionContext;\n \n     public EvalContext(EvalContext parentContext){\n         this.parentContext = parentContext;\n+    }\n+\n+    public class EvalExpressionContext implements ExpressionContext {\n+        public Pointer getContextNodePointer(){\n+            return getCurrentNodePointer();\n+        }\n+\n+        public JXPathContext getJXPathContext(){\n+            return getRootContext().getJXPathContext();\n+        }\n+\n+        public int getPosition(){\n+            return position;\n+        }\n+\n+        public List getContextNodeList(){\n+            int pos = position;\n+            if (pos != 0){\n+                reset();\n+            }\n+            List list = new ArrayList();\n+            while(next()){\n+                list.add(getCurrentNodePointer());\n+            }\n+            if (pos != 0){\n+                setPosition(pos);\n+            }\n+            else {\n+                reset();\n+            }\n+            return list;\n+        }\n+\n+        public String toString(){\n+            Pointer ptr = getContextNodePointer();\n+            if (ptr == null){\n+                return \"Empty expression context\";\n+            }\n+            else {\n+                return \"Expression context [\" + getPosition() + \"] \" + ptr.asPath();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Produces an ExpressionContext that when it needs to pass one to\n+     * an extenstion function.\n+     */\n+    public ExpressionContext getExpressionContext(){\n+        if (expressionContext == null){\n+            expressionContext = new EvalExpressionContext();\n+        }\n+        return expressionContext;\n     }\n \n     /**\n \n     /**\n      * Sets current position = 0, which is the pre-iteration state.\n-     * @deprecated\n-     */\n-    protected void reset(){\n+     */\n+    public void reset(){\n         position = 0;\n     }\n \n      * step's criteria.  Otherwise, returns the current pointer.\n      */\n     public Pointer getContextNodePointer(){\n-        if (position == 0){\n-            while(nextSet()){\n-                if (next()){\n-                    return getCurrentNodePointer();\n-                }\n-            }\n-            return null;\n-        }\n-        else {\n-            return getCurrentNodePointer();\n-        }\n+        reset();\n+        while(nextSet()){\n+            if (next()){\n+                return getCurrentNodePointer();\n+            }\n+        }\n+        return null;\n     }\n \n     /**\n      * Resets the current position and node.\n      */\n     public boolean nextSet(){\n-        setPosition(0);     // Restart iteration within the set\n+        reset();     // Restart iteration within the set\n \n         // Most of the time you have one set per parent node\n         // First time this method is called, we should look for\n             return path((LocationPath)expression, firstMatch);\n \n         case Expression.OP_EXPRESSION_PATH:\n-            return expressionPath(((ExpressionPath)expression).getExpression(),\n-                                  ((ExpressionPath)expression).getPredicates(),\n-                                  ((ExpressionPath)expression).getSteps(), firstMatch);\n+            return expressionPath((ExpressionPath)expression, firstMatch);\n \n         case Expression.OP_FUNCTION:\n             return function(((ExtensionFunction)expression).getFunctionName(),\n         else {\n             rootContext = this;\n         }\n-        if (firstMatch){\n-            boolean basic = path.getEvaluationHint(LocationPath.BASIC_PATH_HINT).equals(Boolean.TRUE);\n-            if (basic){\n-                Object result = tryBasicPath(new InitialContext(rootContext), steps);\n-                if (result != FAILURE){\n-                    return result;\n-                }\n-            }\n-        }\n-        EvalContext aContext = new InitialContext(rootContext);\n-        return evalSteps(aContext, steps, firstMatch);\n+        return evalSteps(new InitialContext(rootContext), path, firstMatch);\n     }\n \n \n      * and objects with Dynamic Properties, but does not work with\n      * DOM objects.\n      */\n-    private Object tryBasicPath(EvalContext context, Step steps[]){\n-        NodePointer ptr = (NodePointer)context.getContextNodePointer();\n-        if (ptr == null || !(ptr instanceof PropertyOwnerPointer)){\n+    private Object tryBasicPath(NodePointer parentPointer, Step steps[]){\n+        if (parentPointer == null){\n             return FAILURE;\n         }\n-        PropertyOwnerPointer pointer = (PropertyOwnerPointer)ptr.clone();\n+\n+        NodePointer pointer = (NodePointer)parentPointer.clone();\n         for (int i = 0; i < steps.length; i++){\n-            String propertyName = ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName();\n-            pointer = pointer.getPropertyPointer();\n-            ((PropertyPointer)pointer).setPropertyName(propertyName);\n+            pointer = getPropertyPointer(pointer, ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName());\n+            if (pointer == null){\n+                return FAILURE;\n+            }\n \n             Expression predicates[] = steps[i].getPredicates();\n             if (predicates != null && predicates.length != 0){\n-                boolean dynamicProperty = false;\n-                Expression expr = (Expression)predicates[0].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-                if (expr != null){\n-                    String prop = stringValue(eval(expr, true));\n-                    pointer = pointer.getPropertyPointer();\n-                    ((PropertyPointer)pointer).setPropertyName(prop);\n-                }\n-                else {\n-                    Object predicate = eval(predicates[0], true);\n-                    if (predicate instanceof EvalContext){\n-                        predicate = ((EvalContext)predicate).getContextNodePointer();\n+                pointer = processBasicPredicates(pointer, predicates);\n+            }\n+            else {\n+                // If we are in the middle of a path, we interpret\n+                // a component like \"foo\" as \"foo[1]\"\n+                if (i < steps.length - 1){\n+                    pointer.setIndex(0);\n+                }\n+            }\n+        }\n+//        System.err.println(\"RETURNING: \" + pointer);\n+        return pointer;\n+    }\n+\n+    private NodePointer processBasicPredicates(NodePointer pointer, Expression[] predicates){\n+        if (predicates == null || predicates.length == 0){\n+            return pointer;\n+        }\n+\n+        for (int i = 0; pointer != null && i < predicates.length; i++){\n+            Expression expr = (Expression)predicates[i].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+            if (expr != null){\n+                String prop = stringValue(eval(expr, true));\n+                pointer = getPropertyPointer(pointer, prop);\n+                if (pointer instanceof NullPropertyPointer){\n+                    ((NullPropertyPointer)pointer).setDynamic(true);\n+                }\n+            }\n+            else {\n+                Object predicate = eval(predicates[i], true);\n+                if (predicate instanceof EvalContext){\n+                    predicate = ((EvalContext)predicate).getContextNodePointer();\n+                }\n+                if (predicate instanceof Pointer){\n+                    predicate = ((Pointer)predicate).getValue();\n+                }\n+                if (predicate == null){\n+                    throw new RuntimeException(\"Predicate is null: \" + predicates[i]);\n+                }\n+                if (predicate instanceof Number){\n+                    int index = (int)(doubleValue(predicate) + 0.5);\n+                    if (index > 0 && index <= pointer.getLength()){\n+                        pointer.setIndex(index - 1);\n                     }\n-                    if (predicate instanceof Pointer){\n-                        predicate = ((Pointer)predicate).getValue();\n+                    else {\n+                        pointer = new NullElementPointer(pointer, index - 1);\n                     }\n-                    if (predicate == null){\n-                        throw new RuntimeException(\"Predicate is null: \" + predicates[0]);\n-                    }\n-                    if (predicate instanceof Number){\n-                        int index = (int)(doubleValue(predicate) + 0.5);\n-                        if (index > 0 && index <= pointer.getLength()){\n-                            pointer.setIndex(index - 1);\n-                        }\n-                        else {\n-                            return null;\n-                        }\n-                    }\n-                    else if (!booleanValue(predicate)){\n-                        return null;\n-                    }\n-                }\n+                }\n+                else if (!booleanValue(predicate)){\n+                    pointer = null;\n+                }\n+            }\n+        }\n+        return pointer;\n+    }\n+\n+    private NodePointer getPropertyPointer(NodePointer ptr, String property){\n+        NodePointer pointer = ptr;\n+        while (true){\n+            if (pointer instanceof VariablePointer){\n+                pointer = ((VariablePointer)pointer).getValuePointer();\n+            }\n+            else if (pointer instanceof ContainerPointer){\n+                pointer = ((ContainerPointer)pointer).getValuePointer();\n             }\n             else {\n-                return FAILURE;\n-            }\n-        }\n-        return pointer;\n+                break;\n+            }\n+        }\n+\n+        if (pointer != null && !(pointer instanceof PropertyOwnerPointer)){\n+            return null;\n+        }\n+\n+        PropertyPointer prop;\n+        if (pointer != null){\n+            prop = ((PropertyOwnerPointer)pointer).getPropertyPointer();\n+        }\n+        else {\n+            prop = new NullPropertyPointer(ptr);\n+        }\n+\n+        prop.setPropertyName(property);\n+        return prop.childNodePointer();\n     }\n \n     /**\n      * Walks an expression path (a path that starts with an expression)\n      */\n-    protected Object expressionPath(Expression expression, Expression predicates[], Step steps[], boolean firstMatch){\n+    protected Object expressionPath(ExpressionPath path, boolean firstMatch){\n+        Expression expression = path.getExpression();\n         Object value = eval(expression, false);\n         EvalContext context;\n         if (value instanceof InitialContext){\n         else {\n             context = getRootContext().getConstantContext(value);\n         }\n+\n+        Expression predicates[] = path.getPredicates();\n+        if (firstMatch){\n+            if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)){\n+                EvalContext ctx = new InitialContext(context);\n+                NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n+                if (ptr != null &&\n+                        (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n+                         predicates == null || predicates.length == 0)){\n+                    NodePointer pointer = processBasicPredicates(ptr, predicates);\n+                    if (pointer != null){\n+                        Object result = tryBasicPath(pointer, path.getSteps());\n+                        if (result != FAILURE){\n+                            return result;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         if (predicates != null){\n             for (int j = 0; j < predicates.length; j++){\n+//                System.err.println(\"PREDICATE: \" + predicates[j]);\n                 context = new PredicateContext(context, predicates[j]);\n             }\n         }\n-        return evalSteps(context, steps, firstMatch);\n+        return evalSteps(context, path, firstMatch);\n     }\n \n     /**\n      * Given a root context, walks a path therefrom\n      */\n-    private Object evalSteps(EvalContext context, Step steps[], boolean firstMatch){\n+    private Object evalSteps(EvalContext context, Path path, boolean firstMatch){\n+        Step steps[] = path.getSteps();\n+        if (firstMatch && steps.length != 0){\n+            boolean basic = path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE);\n+            if (basic){\n+                EvalContext ctx = new InitialContext(context);\n+                NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n+                Object result = tryBasicPath(ptr, steps);\n+                if (result != FAILURE){\n+                    return result;\n+                }\n+            }\n+        }\n+\n         for (int i = 0; i < steps.length; i++){\n             context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n             Expression predicates[] = steps[i].getPredicates();\n         if (arguments != null){\n             parameters = new Object[arguments.length];\n             for (int i = 0; i < arguments.length; i++){\n-                parameters[i] = eval(arguments[i]);\n+                Object param = eval(arguments[i], false);\n+                if (param instanceof EvalContext){\n+                    param = ((EvalContext)param).getExpressionContext();\n+                }\n+                parameters[i] = param;\n             }\n         }\n         Function function = getRootContext().getFunction(functionName, parameters);\n                  Arrays.asList(parameters));\n         }\n \n-        return function.invoke(parameters);\n+        return function.invoke(getExpressionContext(), parameters);\n     }\n \n     /**\n         // Move the position to the beginning and iterate through\n         // the context to count nodes.\n         int old = getCurrentPosition();\n-        setPosition(0);\n+        reset();\n         int count = 0;\n         while(next()){\n             count++;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.6 2001/09/26 23:37:38 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2001/09/26 23:37:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.7 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2001/09/26 23:37:38 $\n+ * @version $Revision: 1.7 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n     private static final PackageFunctions genericFunctions = new PackageFunctions(\"\", null);\n     private static boolean useSoftCache = true;\n     private static int cleanupCount = 0;\n+    private static Vector nodeFactories = new Vector();\n+    private static NodePointerFactory nodeFactoryArray[] = null;\n+    static {\n+        nodeFactories.add(new BeanPointerFactory());\n+        nodeFactories.add(new DynamicPointerFactory());\n+        nodeFactories.add(new DOMPointerFactory());\n+        nodeFactories.add(new ContainerPointerFactory());\n+        createNodeFactoryArray();\n+    }\n \n     // The frequency of the cache cleanup\n     private static final int CLEANUP_THRESHOLD = 500;\n \n     protected JXPathContextReferenceImpl(JXPathContext parentContext, Object contextBean){\n         super(parentContext, contextBean);\n+        synchronized (nodeFactories){\n+            createNodeFactoryArray();\n+        }\n+    }\n+\n+    private static void createNodeFactoryArray(){\n+        if (nodeFactoryArray == null){\n+            nodeFactoryArray = (NodePointerFactory[])nodeFactories.toArray(new NodePointerFactory[0]);\n+            Arrays.sort(nodeFactoryArray, new Comparator(){\n+                public int compare(Object a, Object b){\n+                    int orderA = ((NodePointerFactory)a).getOrder();\n+                    int orderB = ((NodePointerFactory)b).getOrder();\n+                    return orderA - orderB;\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Call this with a custom NodePointerFactory to add support for\n+     * additional types of objects.  Make sure the factory returns\n+     * a name that puts it in the right position on the list of factories.\n+     */\n+    public static void addNodePointerFactory(NodePointerFactory factory){\n+        synchronized (nodeFactories){\n+            nodeFactories.add(factory);\n+            nodeFactoryArray = null;\n+        }\n+    }\n+\n+    public static NodePointerFactory[] getNodePointerFactories(){\n+        return nodeFactoryArray;\n     }\n \n     private static Expression compile(String xpath){\n      * types are wrapped into objects.\n      */\n     public Object getValue(String xpath){\n+//        System.err.println(\"XPATH: \" + xpath);\n         Object result = eval(xpath, true);\n         if (result == null && !lenient){\n             throw new RuntimeException(\"No value for xpath: \" + xpath);\n      * in the graph, the List will be empty.\n      */\n     public List eval(String xpath){\n+//        System.err.println(\"XPATH: \" + xpath);\n         Object result = eval(xpath, false);\n         List list = new ArrayList();\n         if (result instanceof EvalContext){\n     }\n \n     public Pointer locateValue(String xpath){\n+//        System.err.println(\"XPATH: \" + xpath);\n         Object result = eval(xpath, true);\n         if (result instanceof EvalContext){\n             result = ((EvalContext)result).getContextNodePointer();\n     /**\n      */\n     public void setValue(String xpath, Object value){\n+        try {\n+            setValue(xpath, value, false);\n+        }\n+        catch (Throwable ex){\n+            throw new RuntimeException(\"Exception trying to set value with xpath \" +\n+                    xpath + \". \" + ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     */\n+    public void createPath(String xpath, Object value){\n+//        System.err.println(\"CREATING XPATH: \" + xpath);\n+        try {\n+            setValue(xpath, value, true);\n+        }\n+        catch (Throwable ex){\n+            throw new RuntimeException(\"Exception trying to create xpath \" +\n+                    xpath + \". \" + ex.getMessage());\n+        }\n+    }\n+\n+    private void setValue(String xpath, Object value, boolean create){\n         Object result = eval(xpath, true);\n+//        System.err.println(\"RESULT: \" + result);\n+        Pointer pointer = null;\n+\n         if (result instanceof Pointer){\n-            ((Pointer)result).setValue(value);\n+            pointer = (Pointer)result;\n         }\n         else if (result instanceof EvalContext){\n             EvalContext ctx = (EvalContext)result;\n-            Pointer ptr = ctx.getContextNodePointer();\n-            if (ptr != null){\n-                ptr.setValue(value);\n-            }\n-            else {\n-                throw new RuntimeException(\"Cannot set value for xpath: \" + xpath + \": no such property\");\n-            }\n+            pointer = ctx.getContextNodePointer();\n         }\n         else {\n             throw new RuntimeException(\"Cannot set value for xpath: \" + xpath);\n+        }\n+//        Pointer p = pointer;\n+//        while (p != null){\n+//            System.err.println(\"PTR: \" + p.getClass() + \" \" + p.asPath());\n+//            if (p instanceof NodePointer){\n+//                p = ((NodePointer)p).getParent();\n+//            }\n+//        }\n+        if (create){\n+            ((NodePointer)pointer).createPath(this, value);\n+        }\n+        else {\n+            pointer.setValue(value);\n         }\n     }\n \n         Expression expr = compile(xpath);\n         NodePointer pointer = NodePointer.createNodePointer(new QName(null, \"root\"), getContextBean(), getLocale());\n         EvalContext ctx = new RootContext(this, pointer);\n-//        System.err.println(\"XPATH = \" + xpath);\n         return ctx.eval(expr, firstMatchLookup);\n     }\n \n             return new VariablePointer(vars, name);\n         }\n         else {\n-            throw new RuntimeException(\"Undefined variable: \" + varName);\n+            return new VariablePointer(name);\n         }\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Parser.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Parser.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:19 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n  */\n public class Parser {\n \n             expr = parser.parseExpression();\n         }\n         catch (ParseException e) {\n-            System.err.println(\"Failed: \" + expression );\n-            e.printStackTrace();\n+//            System.err.println(\"Failed: \" + expression );\n+//            e.printStackTrace();\n+            throw new RuntimeException(e.getMessage());\n         }\n         return expr;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class AncestorContext extends EvalContext {\n     private NodeTest nodeTest;\n         return currentNodePointer;\n     }\n \n+    public void reset(){\n+        super.reset();\n+        setStarted = false;\n+    }\n+\n     public boolean setPosition(int position){\n-        if (position == 0 || position < getCurrentPosition()){\n-            setStarted = false;\n+        if (position < getCurrentPosition()){\n+            reset();\n         }\n \n         while (getCurrentPosition() < position){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.2 2001/09/21 23:22:43 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"attribute::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:43 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class AttributeContext extends EvalContext {\n     private NodeTest nodeTest;\n         return currentNodePointer;\n     }\n \n+    public void reset(){\n+        setStarted = false;\n+        iterator = null;\n+        super.reset();\n+    }\n+\n     public boolean setPosition(int position){\n-        if (position == 0 || position < getCurrentPosition()){\n-            setStarted = false;\n-            iterator = null;\n-            super.setPosition(0);\n+        if (position < getCurrentPosition()){\n+            reset();\n         }\n \n         while (getCurrentPosition() < position){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class ChildContext extends EvalContext {\n     private NodeTest nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n         if (iterator != null){\n             return iterator.getNodePointer();\n         }\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n+    public void reset(){\n+        super.reset();\n+        iterator = null;\n+    }\n+\n     public boolean setPosition(int position){\n         int oldPosition = getCurrentPosition();\n         super.setPosition(position);\n-        if (position == 0){\n-            iterator = null;\n-            return true;\n+        if (oldPosition == 0){\n+            prepare();\n         }\n-        else {\n-            if (oldPosition == 0){\n-                prepare();\n-            }\n-            if (iterator == null){\n-                return false;\n-            }\n-            return iterator.setPosition(position);\n+        if (iterator == null){\n+            return false;\n         }\n+        return iterator.setPosition(position);\n     }\n \n     /**\n      */\n     private void prepare(){\n         NodePointer parent = parentContext.getCurrentNodePointer();\n+        if (parent == null){\n+            return;\n+        }\n         if (startFromParentLocation){\n             iterator = parent.siblingIterator(nodeTest, reverse);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.3 2001/09/21 23:22:43 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:43 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class DescendantContext extends EvalContext {\n     private NodeTest nodeTest;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n         return currentNodePointer;\n     }\n \n+    public void reset(){\n+        super.reset();\n+        setStarted = false;\n+    }\n+\n     public boolean setPosition(int position){\n-        if (position == 0 || position < this.position){\n-            stack = new Stack();\n-            setStarted = false;\n+//        System.err.println(\"POSITION: \" + position + \" this.position=\" + this.position);\n+        if (position < this.position){\n+            reset();\n         }\n \n         while (this.position < position){\n     public boolean next(){\n         if (!setStarted){\n             setStarted = true;\n+            stack = new Stack();\n             currentNodePointer = parentContext.getCurrentNodePointer();\n-            if (!currentNodePointer.isLeaf()){\n-                stack.push(currentNodePointer.childIterator(null, false));\n-            }\n-            if (includeSelf){\n-                if (currentNodePointer.testNode(nodeTest)){\n-                    position++;\n-                    return true;\n+            if (currentNodePointer != null){\n+                if (!currentNodePointer.isLeaf()){\n+                    stack.push(currentNodePointer.childIterator(null, false));\n+                }\n+                if (includeSelf){\n+                    if (currentNodePointer.testNode(nodeTest)){\n+                        position++;\n+                        return true;\n+                    }\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.2 2001/09/21 23:22:43 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * on to the parent context.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:43 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class InitialContext extends EvalContext {\n     private boolean startedSet = false;\n \n     public InitialContext(EvalContext parentContext){\n         super(parentContext);\n-        nodePointer = (NodePointer)parentContext.getCurrentNodePointer().clone();\n-        collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n+        NodePointer ptr = parentContext.getCurrentNodePointer();\n+        if (ptr != null){\n+            nodePointer = (NodePointer)ptr.clone();\n+            collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n+        }\n     }\n \n     public Pointer getContextNodePointer(){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.1 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"namespace::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class NamespaceContext extends EvalContext {\n     private NodeTest nodeTest;\n         return currentNodePointer;\n     }\n \n+    public void reset(){\n+        setStarted = false;\n+        iterator = null;\n+        super.reset();\n+    }\n+\n     public boolean setPosition(int position){\n-        if (position == 0 || position < getCurrentPosition()){\n-            setStarted = false;\n-            iterator = null;\n-            super.setPosition(0);\n+        if (position < getCurrentPosition()){\n+            reset();\n         }\n \n         while (getCurrentPosition() < position){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"parent::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class ParentContext extends EvalContext {\n     private NodeTest nodeTest;\n         return 1;\n     }\n \n+    public void reset(){\n+        super.reset();\n+        setStarted = false;\n+    }\n+\n     public boolean setPosition(int position){\n         super.setPosition(position);\n-        if (position == 0){\n-            setStarted = false;\n-        }\n         return position == 1;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.3 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n         return currentNodePointer;\n     }\n \n+    public void reset(){\n+        super.reset();\n+        stack = new Stack();\n+        setStarted = false;\n+    }\n+\n     public boolean setPosition(int position){\n-        if (position == 0 || position < this.position){\n-            stack = new Stack();\n-            setStarted = false;\n+        if (position < this.position){\n+            reset();\n         }\n \n         while (this.position < position){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.3 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n         if (dynamicPropertyPointer != null){\n             return dynamicPropertyPointer;\n         }\n         }\n     }\n \n+    public void reset(){\n+        super.reset();\n+        done = false;\n+    }\n+\n     public boolean nextSet(){\n-        position = 0;\n-        done = false;\n+        reset();\n         return parentContext.nextSet();\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.3 2001/09/26 01:21:54 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/26 01:21:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.pointers.*;\n  * EvalContext that is used to hold the root node for the path traversal.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/26 01:21:54 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class RootContext extends EvalContext {\n     private boolean startedSet = false;\n         super(null);\n         this.parent = parent;\n         this.pointer = pointer;\n+    }\n+\n+    public JXPathContext getJXPathContext(){\n+        return parent;\n     }\n \n     public RootContext getRootContext(){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n  * EvalContext that returns the current node from the parent context if the test succeeds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class SelfContext extends EvalContext {\n     private NodeTest nodeTest;\n         this.nodeTest = nodeTest;\n     }\n \n+    public ExpressionContext getExpressionContext(){\n+        return parentContext.getExpressionContext();\n+    }\n+\n     public Pointer getContextNodePointer(){\n-        if (setPosition(1)){\n-            return contextNodePointer;\n-        }\n-        return null;\n+        return parentContext.getContextNodePointer();\n     }\n \n     public NodePointer getCurrentNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n         return nodePointer;\n     }\n \n         return setPosition(getCurrentPosition() + 1);\n     }\n \n+    public void reset(){\n+        super.reset();\n+        startedSet = false;\n+    }\n+\n     public boolean setPosition(int position){\n+        if (position != 1){\n+            return false;\n+        }\n         super.setPosition(position);\n-        if (position == 0){\n-            startedSet = false;\n-            return true;\n-        }\n-\n         if (!startedSet){\n             startedSet = true;\n-            contextNodePointer = (NodePointer)parentContext.getContextNodePointer();\n+            contextNodePointer = (NodePointer)parentContext.getCurrentNodePointer();\n         }\n \n         if (contextNodePointer == null){\n         }\n \n         nodePointer = (NodePointer)contextNodePointer.clone();\n-        if (position < 1 || position > nodePointer.getLength()){\n-            return false;\n-        }\n-        nodePointer.setIndex(position - 1);\n         return nodeTest == null || nodePointer.testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of a union operation like (a | b)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class UnionContext extends EvalContext {\n     private boolean startedSet = false;\n     }\n \n     public NodePointer getCurrentNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+        }\n         return (NodePointer)list.get(position - 1);\n     }\n \n     public boolean setPosition(int position){\n-        this.position = position;\n+        super.setPosition(position);\n         if (list == null){\n             prepareList();\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a path that starts with an expression like a function call: <code>getFoo(.)/bar</code>.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class ExpressionPath extends Path {\n \n+    public static final String BASIC_PREDICATES_HINT = \"basicPredicatesHint\";\n+\n     private Expression expression;\n     private Expression predicates[];\n+\n+    private boolean basicKnown = false;\n+    private boolean basic;\n \n     public ExpressionPath(Expression expression, Expression[] predicates, Step[] steps){\n         super(Expression.OP_EXPRESSION_PATH, steps);\n         }\n     }\n \n+    /**\n+     * Recognized paths formatted as <code>$x[3]/foo[2]</code>.  The\n+     * evaluation of such \"simple\" paths is optimized and streamlined.\n+     */\n+    public Object getEvaluationHint(String hint){\n+        if (!hint.equals(BASIC_PREDICATES_HINT)){\n+            return super.getEvaluationHint(hint);\n+        }\n+\n+        if (!basicKnown){\n+            basicKnown = true;\n+            basic = super.getEvaluationHint(BASIC_PATH_HINT).equals(Boolean.TRUE) &&\n+                    areBasicPredicates(getPredicates());\n+        }\n+        return basic ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n     public String toString(){\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"(EXPRESSION-PATH \");\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents an element of the parse tree representing an extension function call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class ExtensionFunction extends Operation {\n \n         return functionName;\n     }\n \n+    /**\n+     * An extension function gets the current context, therefore it MAY be\n+     * context dependent.\n+     */\n+    public boolean computeContextDependent(){\n+        return true;\n+    }\n+\n     public String opCodeToString(){\n         return super.opCodeToString() + ':' + functionName;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.util.*;\n-import org.apache.commons.jxpath.ri.Compiler;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class LocationPath extends Path {\n \n     private boolean absolute;\n-    public static final String BASIC_PATH_HINT = \"basicPathHint\";\n-    private boolean basicKnown = false;\n-    private boolean basic;\n \n     public LocationPath(boolean absolute, Step[] steps){\n         super(Expression.OP_LOCATION_PATH, steps);\n         buffer.append(')');\n         return buffer.toString();\n     }\n-\n-    /**\n-     * Recognized predicated formatted as <code>[@name = <i>expr</i>]</code>\n-     */\n-    public Object getEvaluationHint(String hint){\n-        if (!hint.equals(BASIC_PATH_HINT)){\n-            return null;\n-        }\n-\n-        if (!basicKnown){\n-            basicKnown = true;\n-            basic = true;\n-            Step[] steps = getSteps();\n-            for (int i = 0; i < steps.length; i++){\n-                if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n-                        !(steps[i].getNodeTest() instanceof NodeNameTest) ||\n-                        ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName().equals(\"*\")){\n-                    basic = false;\n-                    break;\n-                }\n-                Expression predicates[] = steps[i].getPredicates();\n-                if (predicates != null && predicates.length != 0){\n-                    if (predicates.length != 1){\n-                        basic = false;\n-                        break;\n-                    }\n-                    if (predicates[0].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null &&\n-                            predicates[0].isContextDependent()){\n-                        basic = false;\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        return basic ? Boolean.TRUE : Boolean.FALSE;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.util.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class Path extends Expression {\n \n     private Step[] steps;\n+    public static final String BASIC_PATH_HINT = \"basicPathHint\";\n+    private boolean basicKnown = false;\n+    private boolean basic;\n \n     public Path(int typeCode, Step[] steps){\n         super(typeCode);\n             }\n         }\n     }\n+\n+    /**\n+     * Recognized paths formatted as <code>foo/bar[3]/baz[@name = 'biz']</code>.  The\n+     * evaluation of such \"simple\" paths is optimized and streamlined.\n+     */\n+    public Object getEvaluationHint(String hint){\n+        if (!hint.equals(BASIC_PATH_HINT)){\n+            return null;\n+        }\n+\n+        if (!basicKnown){\n+            basicKnown = true;\n+            basic = true;\n+            Step[] steps = getSteps();\n+            for (int i = 0; i < steps.length; i++){\n+//                System.err.println(\"STEP: \" + steps[i]);\n+                if (steps[i].getAxis() != Compiler.AXIS_CHILD ||\n+                        !(steps[i].getNodeTest() instanceof NodeNameTest) ||\n+                        ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName().equals(\"*\")){\n+                    basic = false;\n+                    break;\n+                }\n+                Expression predicates[] = steps[i].getPredicates();\n+                basic = basic && areBasicPredicates(predicates);\n+            }\n+        }\n+        return basic ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected boolean areBasicPredicates(Expression predicates[]){\n+        if (predicates != null && predicates.length != 0){\n+            boolean firstIndex = true;\n+            for (int i = 0; i < predicates.length; i++){\n+                Expression dyn = (Expression)predicates[i].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+                if (dyn != null){\n+                    if (dyn.isContextDependent()){\n+                        return false;\n+                    }\n+                }\n+                else if (predicates[i].isContextDependent()){\n+                    return false;\n+                }\n+                else {\n+                    if (!firstIndex){\n+                        return false;\n+                    }\n+                    firstIndex = false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPointerFactory.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.compiler.QName;\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for JavaBeans.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public class BeanPointerFactory implements NodePointerFactory {\n+\n+    public static final int BEAN_POINTER_FACTORY_ORDER = 900;\n+\n+    public int getOrder(){\n+        return BEAN_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        return new BeanPointer(name, bean, bi, locale);\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        return new BeanPointer(parent, name, bean, bi);\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/BeanPropertyPointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n+    private String propertyName;\n     private JXPathBeanInfo beanInfo;\n     private PropertyDescriptor propertyDescriptors[];\n     private PropertyDescriptor propertyDescriptor;\n      * Select a property by name\n      */\n     public void setPropertyName(String propertyName){\n+        this.propertyName = propertyName;\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n         String[] names = getPropertyNames();\n         for (int i = 0; i < names.length; i++){\n         }\n         else {\n             if (index == WHOLE_COLLECTION){\n-                value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor());\n+                value = PropertyAccessHelper.getValue(getBean(), pd);\n             }\n             else {\n-                value = PropertyAccessHelper.getValue(getBean(), getPropertyDescriptor(), index);\n+                value = PropertyAccessHelper.getValue(getBean(), pd, index);\n             }\n         }\n         return value;\n+    }\n+\n+    protected boolean isActualProperty(){\n+        return getPropertyDescriptor() != null;\n     }\n \n     /**\n      * represented by the property.\n      */\n     public void setValue(Object value){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            throw new RuntimeException(\"Cannot set property: \" + asPath() + \" - no such property\");\n+        }\n+\n         if (index == WHOLE_COLLECTION){\n-            PropertyAccessHelper.setValue(getBean(), getPropertyDescriptor(), value);\n+            PropertyAccessHelper.setValue(getBean(), pd, value);\n         }\n         else {\n-            PropertyAccessHelper.setValue(getBean(), getPropertyDescriptor(), index, value);\n-        }\n+            PropertyAccessHelper.setValue(getBean(), pd, index, value);\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (getValue() == null){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n+                throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, int index){\n+        setIndexExpandingCollection(context, index);\n+        return createPath(context);\n+    }\n+\n+    public void createPath(JXPathContext context, int index, Object value){\n+        setIndexExpandingCollection(context, index);\n+        setValue(value);\n+    }\n+\n+    private void setIndexExpandingCollection(JXPathContext context, int index){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            throw new RuntimeException(\"Cannot create path: \" + asPath() +\n+                    \" - property '\" + getPropertyName() + \"' does not exist\");\n+        }\n+\n+        if (index < 0){\n+            throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory.expandCollection(context, this, getBean(), getPropertyName(), index + 1)){\n+                throw new RuntimeException(\"Factory could not expand collection for path \" + asPath() +\n+                    \" to size \" + (index + 1));\n+            }\n+        }\n+        setIndex(index);\n     }\n \n     /**\n     public String getPropertyName(){\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null){\n-            return \"*\";\n+            return propertyName != null ? propertyName : \"*\";\n         }\n         return pd.getName();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointer.java,v 1.3 2001/09/26 01:21:54 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/26 01:21:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/26 01:21:54 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n         container.setValue(value);\n     }\n \n-    private NodePointer getValuePointer(){\n+    public NodePointer getValuePointer(){\n         if (valuePointer == null){\n             Object value = getValue();\n             valuePointer = NodePointer.createNodePointer(this, null, value);\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/ContainerPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/ContainerPointerFactory.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.Container;\n+import org.apache.commons.jxpath.ri.compiler.QName;\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for Container objects.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public class ContainerPointerFactory implements NodePointerFactory {\n+\n+    public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;\n+\n+    public int getOrder(){\n+        return CONTAINER_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        if (bean instanceof Container){\n+            return new ContainerPointer((Container)bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean instanceof Container){\n+            return new ContainerPointer(parent, (Container)bean);\n+        }\n+        return null;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributePointer.java,v 1.2 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMAttributePointer.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n             return null;\n         }\n         return value;\n+    }\n+\n+    public boolean isActual(){\n+        return true;\n     }\n \n     public boolean isLeaf(){\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodePointer.java,v 1.3 2001/09/26 01:21:54 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/26 01:21:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMNodePointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/26 01:21:54 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n \n     public Object getValue(){\n         return node;\n+    }\n+\n+    public boolean isActual(){\n+        return true;\n     }\n \n     public boolean isCollection(){\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DOMPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DOMPointerFactory.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.ri.compiler.QName;\n+import java.util.*;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Implements NodePointerFactory for DOM elements.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public class DOMPointerFactory implements NodePointerFactory {\n+\n+    public static final int DOM_POINTER_FACTORY_ORDER = 100;\n+\n+    public int getOrder(){\n+        return DOM_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        if (bean instanceof Node){\n+            return new DOMNodePointer((Node)bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean instanceof Node){\n+            return new DOMNodePointer(parent, (Node)bean);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPointerFactory.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.compiler.QName;\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for Dynamic classes like Map.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public class DynamicPointerFactory implements NodePointerFactory {\n+\n+    public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n+\n+    public int getOrder(){\n+        return DYNAMIC_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(name, bean, handler, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(parent, name, bean, handler);\n+        }\n+        return null;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/DynamicPropertyPointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n     }\n \n     /**\n+     * A dynamic property is always considered actual - all keys are apparently\n+     * existing with possibly the value of null.\n+     */\n+    protected boolean isActualProperty(){\n+        return true;\n+    }\n+\n+    /**\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n      * represented by the property.\n         else {\n             PropertyAccessHelper.setValue(handler.getProperty(getBean(), getPropertyName()), index, value);\n         }\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        createPath(context, index, value);\n+    }\n+\n+    public void createPath(JXPathContext context, int index, Object value){\n+        if (index == WHOLE_COLLECTION){\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (collection == null){\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory.createObject(context, this, getBean(), getPropertyName(), 0)){\n+                    throw new RuntimeException(\"Factory could not create an collection for path: \" + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0){\n+                throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()){\n+                collection = PropertyAccessHelper.expandCollection(collection, index + 1);\n+                handler.setProperty(getBean(), getPropertyName(), collection);\n+            }\n+\n+            PropertyAccessHelper.setValue(collection, index, value);\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (getValue() == null){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n+                throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        return this;\n     }\n \n     public String asPath(){\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.4 2001/09/26 01:21:54 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2001/09/26 01:21:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointer.java,v 1.5 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.pointers;\n \n import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n \n import org.w3c.dom.Node;\n \n /**\n- * Common superclass for Poitners of all kinds.\n+ * Common superclass for Pointers of all kinds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2001/09/26 01:21:54 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/10 03:40:20 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable {\n \n         if (bean == null){\n             return new NullPointer(name, locale);\n         }\n-        if (bean instanceof Node){\n-            return new DOMNodePointer((Node)bean, locale);\n-        }\n-        if (bean instanceof Container){\n-            return new ContainerPointer((Container)bean, locale);\n-        }\n-\n-        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n-        if (bi.isDynamic()){\n-            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n-            return new DynamicPointer(name, bean, handler, locale);\n-        }\n-        else {\n-            return new BeanPointer(name, bean, bi, locale);\n-        }\n+        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++){\n+            NodePointer pointer = factories[i].createNodePointer(name, bean, locale);\n+            if (pointer != null){\n+                return pointer;\n+            }\n+        }\n+        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n     }\n \n     public static NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n         if (bean == null){\n             return new NullPointer(parent, name);\n         }\n-        if (bean instanceof Node){\n-            return new DOMNodePointer(parent, (Node)bean);\n-        }\n-        if (bean instanceof Container){\n-            return new ContainerPointer(parent, (Container)bean);\n-        }\n-\n-        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n-        if (bi.isDynamic()){\n-            DynamicPropertyHandler handler = PropertyAccessHelper.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n-            return new DynamicPointer(parent, name, bean, handler);\n-        }\n-        else {\n-            return new BeanPointer(parent, name, bean, bi);\n-        }\n+        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++){\n+            NodePointer pointer = factories[i].createNodePointer(parent, name, bean);\n+            if (pointer != null){\n+                return pointer;\n+            }\n+        }\n+        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n     }\n \n     /**\n     }\n \n     public void setIndex(int index){\n+//        System.err.println(\"SETTING: \" + this.getClass() + \" \" + index);\n+//        new Exception().printStackTrace();\n         this.index = index;\n     }\n \n         return PropertyAccessHelper.getLength(value);\n     }\n \n+    /**\n+     * If this pointer manages a transparent container, like a variable,\n+     * this method returns the ponter to the contents.\n+     */\n+    public NodePointer getValuePointer(){\n+        if (this instanceof PropertyOwnerPointer){\n+            return this;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * An actual pointer points to an existing part of an object graph, even\n+     * if it is null. A non-actual pointer represents a part that does not exist\n+     * at all.\n+     * For instance consider the pointer \"/address/street\".\n+     * If both <em>address</em> and <em>street</em> are not null, the pointer is actual.\n+     * If <em>address</em> is not null, but <em>street</em> is null, the pointer is still actual.\n+     * If <em>address</em> is null, the pointer is not actual.\n+     * (In JavaBeans) if <em>address</em> is not a property of the root bean, a Pointer\n+     * for this path cannot be obtained at all - actual or otherwise.\n+     */\n+    public boolean isActual(){\n+        if (index == WHOLE_COLLECTION){\n+            return true;\n+        }\n+        else {\n+            return index >= 0 && index < getLength();\n+        }\n+    }\n+\n+\n     public abstract QName getName();\n     public abstract Object getBaseValue();\n     public abstract void setValue(Object value);\n     public abstract boolean testNode(NodeTest nodeTest);\n+\n+    /**\n+     *  Called directly by JXPathContext. Must create path and\n+     *  set value.\n+     */\n+    public void createPath(JXPathContext context, Object value){\n+        setValue(value);\n+    }\n+\n+    /**\n+     * Called by a child pointer if that child needs to assign the value\n+     * supplied in the createPath(context, value) call to a non-existent\n+     * collection element. This method must expand the collection and\n+     * assign the element.\n+     */\n+    public void createPath(JXPathContext context, int index, Object value){\n+        throw new RuntimeException(\"Cannot expand collection for path \" + asPath() +\n+                \", or it is not a collection at all\");\n+    }\n+\n+    /**\n+     * Called by a child pointer when it needs to create a parent object.\n+     * Must create an object described by this pointer and return\n+     * a new pointer that properly describes the new object.\n+     */\n+    public NodePointer createPath(JXPathContext context){\n+        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n+                \", operation is not allowed for this type of node\");\n+    }\n+\n+    /**\n+     * Called by a child pointer when it needs to create a parent object\n+     * for a non-existent collection element.  Must expand the collection,\n+     * create an element object and return a new pointer describing the\n+     * newly created element.\n+     */\n+    public NodePointer createPath(JXPathContext context, int index){\n+        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n+                \", operation is not allowed for this type of node\");\n+    }\n \n     public Locale getLocale(){\n         if (locale == null){\n     public String toString(){\n         return asPath();\n     }\n+\n+    protected AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new RuntimeException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NodePointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NodePointerFactory.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.ri.compiler.QName;\n+import java.util.*;\n+\n+/**\n+ * Creates NodePointers for objects of a certain type.\n+ * NodePointerFactories are ordered according to the values returned\n+ * by the \"getOrder\" method and always queried in that order.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public interface NodePointerFactory {\n+\n+    /**\n+     * The factory name determines its position between other factories.\n+     */\n+    public int getOrder();\n+\n+    /**\n+     * Create a NodePointer for the supplied object.  The node will represent\n+     * the \"root\" object a path.\n+     *\n+     * Return null if this factory does not recognize objects of the supplied type.\n+     */\n+    public NodePointer createNodePointer(QName name, Object object, Locale locale);\n+\n+    /**\n+     * Create a NodePointer for the supplied child object.\n+     * <p>\n+     * Return null if this factory does not recognize objects of the supplied type.\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object object);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullElementPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullElementPointer.java,v 1.1 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:20 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.pointers;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Used when there is a need to construct a Pointer for\n+ * a collection element that does not exist.  For example,\n+ * if the path is \"foo[3]\", but the collection \"foo\" only has\n+ * one element or is empty or is null, the NullElementPointer\n+ * can be used to capture this situatuin without putting\n+ * a regular NodePointer into an invalid state.  Just create\n+ * a NullElementPointer with index 2 (= 3 - 1) and a \"foo\" pointer\n+ * as the parent.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:20 $\n+ */\n+public class NullElementPointer extends PropertyOwnerPointer {\n+\n+    public NullElementPointer(NodePointer parent, int index){\n+        super(parent);\n+        this.index = index;\n+    }\n+\n+    public QName getName(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        parent.createPath(context, index, value);\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        return parent.createPath(context, index);\n+    }\n+\n+    public int hashCode(){\n+        return getParent().hashCode() + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NullElementPointer)){\n+            return false;\n+        }\n+\n+        NullElementPointer other = (NullElementPointer)object;\n+        return getParent() == other.getParent() &&\n+            index == other.index;\n+    }\n+\n+    public String asPath(){\n+        return parent.asPath() + \"[\" + (index + 1) + \"]\";\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.4 2001/09/26 01:21:54 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2001/09/26 01:21:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPointer.java,v 1.5 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2001/09/26 01:21:54 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class NullPointer extends PropertyOwnerPointer {\n     private QName name;\n \n     public void setValue(Object value){\n         throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        if (parent != null){\n+            parent.createPath(context, value);\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\"Cannot create the root object\");\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (parent != null){\n+            return parent.createPath(context);\n+        }\n+        throw new UnsupportedOperationException(\"Cannot create the root object\");\n     }\n \n     public int hashCode(){\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/NullPropertyPointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n     private String propertyName = \"*\";\n+    private boolean dynamic = false;\n \n     /**\n      */\n         return null;\n     }\n \n+    protected boolean isActualProperty(){\n+        return false;\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n     public void setValue(Object value){\n         throw new RuntimeException(\"Cannot set property \" + asPath() +\n             \", the target object is null\");\n     }\n \n+    public void createPath(JXPathContext context, Object value){\n+         createParentPath(context).setValue(value);\n+    }\n+\n+    public void createPath(JXPathContext context, int index, Object value){\n+        NodePointer pointer = createParentPath(context);\n+        pointer.setIndex(index);\n+        pointer.createPath(context, value);\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, int index){\n+        NodePointer pointer = createParentPath(context);\n+        return pointer.createPath(context, index);\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        NodePointer pointer = createParentPath(context);\n+        NodePointer result = pointer.createPath(context);\n+        if (!result.isActual()){\n+            throw new RuntimeException(\"Could not create an object for path \" + asPath() +\n+                \" that could have property \" + getPropertyName());\n+        }\n+        return result;\n+    }\n+\n+    private NodePointer createParentPath(JXPathContext context){\n+        NodePointer pointer = parent.createPath(context);\n+        while (true){\n+            if (pointer instanceof VariablePointer){\n+                pointer = ((VariablePointer)pointer).getValuePointer();\n+            }\n+            else if (pointer instanceof ContainerPointer){\n+                pointer = ((ContainerPointer)pointer).getValuePointer();\n+            }\n+            else {\n+                break;\n+            }\n+        }\n+        if (!(pointer instanceof PropertyOwnerPointer)){\n+            throw new RuntimeException(\"Could not create an object for path \" + asPath() +\n+                \" that has property \" + getPropertyName());\n+        }\n+        PropertyPointer prop = ((PropertyOwnerPointer)pointer).getPropertyPointer();\n+        prop.setPropertyName(propertyName);\n+        prop.setIndex(index);\n+        return prop;\n+    }\n+\n     public String getPropertyName(){\n         return propertyName;\n     }\n         this.propertyName = propertyName;\n     }\n \n+    public void setDynamic(boolean flag){\n+        dynamic = flag;\n+    }\n+\n+    public boolean isCollection(){\n+        return getIndex() != WHOLE_COLLECTION;\n+    }\n+\n     public int getPropertyCount(){\n         return 0;\n     }\n     public String[] getPropertyNames(){\n         return new String[0];\n     }\n+\n+    public String asPath(){\n+        if (!dynamic){\n+            return super.asPath();\n+        }\n+        else {\n+            StringBuffer buffer = new StringBuffer();\n+            buffer.append(getParent().asPath());\n+            buffer.append(\"[@name='\");\n+            buffer.append(escape(getPropertyName()));\n+            buffer.append(\"']\");\n+            if (index != WHOLE_COLLECTION){\n+                buffer.append('[').append(index + 1).append(']');\n+            }\n+            return buffer.toString();\n+        }\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyAccessHelper.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyAccessHelper.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyAccessHelper.java,v 1.2 2001/09/09 00:52:04 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/09 00:52:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyAccessHelper.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.functions.Types;\n \n import java.lang.reflect.*;\n import java.util.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/09 00:52:04 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class PropertyAccessHelper {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n         }\n         else {\n             return 1;\n+        }\n+    }\n+\n+    public static Object expandCollection(Object collection, int size){\n+        if (collection == null){\n+            return null;\n+        }\n+        else if (collection.getClass().isArray()){\n+            Object bigger = Array.newInstance(collection.getClass().getComponentType(), size);\n+            System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection));\n+            return bigger;\n+        }\n+        else if (collection instanceof Collection){\n+            while (((Collection)collection).size() < size){\n+                ((Collection)collection).add(null);\n+            }\n+            return collection;\n+        }\n+        else {\n+            throw new RuntimeException(\"Cannot turn \" + collection.getClass().getName() +\n+                    \" into a collection of size \" + size);\n         }\n     }\n \n                 IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n                 Method method = ipd.getIndexedWriteMethod();\n                 if (method != null){\n-                    method.invoke(bean, new Object[]{new Integer(index), value});\n+                    method.invoke(bean,\n+                        new Object[]{new Integer(index),\n+                                     convert(value, ipd.getIndexedPropertyType())});\n                     return;\n                 }\n             }\n         Object value = collection;\n         if (collection != null){\n             if (collection.getClass().isArray()){\n+                if (index < 0 || index >= Array.getLength(collection)){\n+                    return null;\n+                }\n                 value = Array.get(collection, index);\n             }\n             else if (collection instanceof List){\n+                if (index < 0 || index >= ((List)collection).size()){\n+                    return null;\n+                }\n                 value = ((List)collection).get(index);\n             }\n             else if (collection instanceof Collection){\n+                int i = 0;\n                 Iterator it = ((Collection)collection).iterator();\n-                for (int i = 0; i <= index; i++){\n+                for (; i < index; i++){\n+                    it.next();\n+                }\n+                if (it.hasNext()){\n                     value = it.next();\n+                }\n+                else {\n+                    value = null;\n                 }\n             }\n         }\n     public static void setValue(Object collection, int index, Object value){\n         if (collection != null){\n             if (collection.getClass().isArray()){\n-                Array.set(collection, index, value);\n+                Array.set(collection, index, convert(value, collection.getClass().getComponentType()));\n             }\n             else if (collection instanceof List){\n                 ((List)collection).set(index, value);\n             if (method == null){\n                 throw new RuntimeException(\"No write method\");\n             }\n+            value = convert(value, propertyDescriptor.getPropertyType());\n             value = method.invoke(bean, new Object[]{value});\n         }\n         catch (Exception ex){\n             throw new RuntimeException(\"Cannot modify property: \" + propertyDescriptor.getName() +\n                 \", \" + ex);\n         }\n+    }\n+\n+    private static Object convert(Object value, Class type){\n+        if (!Types.canConvert(value, type)){\n+            throw new RuntimeException(\"Cannot convert value of class \" +\n+                    (value == null ? \"null\" : value.getClass().getName()) +\n+                    \" to type \" + type);\n+        }\n+        return Types.convert(value, type);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/PropertyPointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public abstract class PropertyPointer extends PropertyOwnerPointer {\n     protected int propertyIndex = UNSPECIFIED_PROPERTY;\n \n     public abstract String[] getPropertyNames();\n \n+    protected abstract boolean isActualProperty();\n+\n+    public boolean isActual(){\n+        if (!isActualProperty()){\n+            return false;\n+        }\n+\n+        return super.isActual();\n+    }\n+\n+\n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n \n     public String toString(){\n         StringBuffer buffer = new StringBuffer();\n-        buffer.append(getBean().getClass().getName());\n+        if (getBean() == null){\n+            buffer.append(\"null\");\n+        }\n+        else {\n+            buffer.append(getBean().getClass().getName());\n+        }\n         buffer.append('@');\n         buffer.append(System.identityHashCode(getBean()));\n         buffer.append('.');\n--- a/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/pointers/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.3 2001/09/21 23:22:45 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/09/21 23:22:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/pointers/Attic/VariablePointer.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/10 03:40:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2001/09/21 23:22:45 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n     private QName name;\n     private NodePointer valuePointer;\n+    private boolean actual;\n \n     public VariablePointer(Variables variables, QName name){\n         super(null);\n         this.variables = variables;\n         this.name = name;\n+        actual = true;\n+    }\n+\n+    public VariablePointer(QName name){\n+        super(null);\n+        this.name = name;\n+        actual = false;\n     }\n \n     public QName getName(){\n     }\n \n     public Object getBaseValue(){\n+        if (!actual){\n+            throw new RuntimeException(\"Undefined variable: \" + name);\n+        }\n         return variables.getVariable(name.getName());\n     }\n \n     }\n \n     public void setValue(Object value){\n+        if (!actual){\n+            throw new RuntimeException(\"Cannot set undefined variable: \" + name);\n+        }\n         valuePointer = null;\n-        variables.declareVariable(name.getName(), value);\n-    }\n-\n-    private NodePointer getValuePointer(){\n+        if (index != WHOLE_COLLECTION){\n+            Object collection = getBaseValue();\n+            PropertyAccessHelper.setValue(collection, index, value);\n+        }\n+        else {\n+            variables.declareVariable(name.getName(), value);\n+        }\n+    }\n+\n+    public boolean isActual(){\n+        return actual;\n+    }\n+\n+    public NodePointer getValuePointer(){\n         if (valuePointer == null){\n-            Object value = getValue();\n+            Object value = null;\n+            if (actual){\n+                value = getValue();\n+            }\n             valuePointer = NodePointer.createNodePointer(this, null, value);\n+//            System.err.println(\"VALUE POINTER: \" + valuePointer.getClass());\n         }\n         return valuePointer;\n     }\n \n+    public int getLength(){\n+        if (actual){\n+            return super.getLength();\n+        }\n+        return 0;\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        if (actual){\n+            setValue(value);\n+            return;\n+        }\n+        createPath(context).setValue(value);\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (!actual){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory.declareVariable(context, name.toString())){\n+                throw new RuntimeException(\"Factory cannot define variable '\" + name + \"' for path: \" + asPath());\n+            }\n+            findVariables(context);\n+            // Assert: actual == true\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, int index){\n+        Object collection = createCollection(context, index);\n+        AbstractFactory factory = getAbstractFactory(context);\n+        if (!factory.createObject(context, this, collection, name.toString(), index)){\n+            throw new RuntimeException(\"Factory could not create collection element for path: \" + asPath());\n+        }\n+        setIndex(index);\n+        return this;\n+    }\n+\n+    /**\n+     */\n+    public void createPath(JXPathContext context, int index, Object value){\n+        Object collection = createCollection(context, index);\n+        PropertyAccessHelper.setValue(collection, index, value);\n+    }\n+\n+    private Object createCollection(JXPathContext context, int index){\n+        createPath(context);\n+\n+        Object collection = getBaseValue();\n+        if (collection == null){\n+            throw new RuntimeException(\"Factory did not assign a collection to variable '\" + name + \"' for path: \" + asPath());\n+        }\n+\n+        if (index < 0){\n+            throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()){\n+            collection = PropertyAccessHelper.expandCollection(collection, index + 1);\n+            variables.declareVariable(name.toString(), collection);\n+        }\n+\n+        return collection;\n+    }\n+\n+    protected void findVariables(JXPathContext context){\n+        valuePointer = null;\n+        JXPathContext varCtx = context;\n+        while (varCtx != null){\n+            variables = varCtx.getVariables();\n+            if (variables.isDeclaredVariable(name.toString())){\n+                actual = true;\n+                break;\n+            }\n+            varCtx = varCtx.getParentContext();\n+            variables = null;\n+        }\n+    }\n+\n     public int hashCode(){\n-        return System.identityHashCode(variables) + name.hashCode() + index;\n+        return (actual ? System.identityHashCode(variables): 0) + name.hashCode() + index;\n     }\n \n     public boolean equals(Object object){\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('$');\n         buffer.append(name);\n-        if (index != WHOLE_COLLECTION && isCollection()){\n+        if (!actual){\n+            if (index != WHOLE_COLLECTION){\n+                buffer.append('[').append(index + 1).append(']');\n+            }\n+        }\n+        else if (index != WHOLE_COLLECTION && (getValue() == null || isCollection())){\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.9 2001/09/26 23:37:38 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2001/09/26 23:37:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.10 2002/04/10 03:40:21 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/04/10 03:40:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2001/09/26 23:37:38 $\n+ * @version $Revision: 1.10 $ $Date: 2002/04/10 03:40:21 $\n  */\n \n public class JXPathTestCase extends TestCase\n             testGetValue(context, \"$z/int\",  new Integer(1));\n             testGetValue(context, \"$z/integers[$x - 5]\",  new Integer(2));\n             testGetValue(context, \".\",  bean.getBeans());\n-            testGetValue(context, \".[2]/name\",  \"Name 2\");\n+//            testGetValue(context, \".[2]/name\",  \"Name 2\");        // TBD: is this even legal?\n             testGetValue(context, \"$t[2]\",  \"b\");\n             testGetValue(context, \"$m/Key1\",  \"Value 1\");\n         }\n \n     private void testGetValue(JXPathContext context, String xpath, Object expected) {\n         Object actual = context.getValue(xpath);\n-//        System.err.println(\"xpath: \" + xpath + \" ACTUAL: \" + actual);\n         assertEquals(\"Evaluating <\" + xpath + \">\", expected, actual);\n     }\n \n             testContextDependency(\"/foo[$x]\", false);\n             testContextDependency(\"/foo[bar]\", true);\n             testContextDependency(\"3 + 5\", false);\n-            testContextDependency(\"test:func(3, 5)\", false);\n+            testContextDependency(\"test:func(3, 5)\", true);\n             testContextDependency(\"test:func(3, foo)\", true);\n         }\n     }\n             context.setValue(\"int\", new Integer(3));\n             assertEquals(\"Modified <\" + \"int\" + \">\", new Integer(3), context.getValue(\"int\"));\n \n+            context.setValue(\"int\", new int[]{4});\n+            assertEquals(\"Modified <\" + \"int\" + \">\", new Integer(4), context.getValue(\"int\"));\n+\n             context.setValue(\"integers[2]\", new Integer(5));\n             assertEquals(\"Modified <\" + \"integers[2]\" + \">\", new Integer(5), context.getValue(\"integers[2]\"));\n+\n+            context.setValue(\"integers[2]\", new int[]{6});\n+            assertEquals(\"Modified <\" + \"integers[2]\" + \">\", new Integer(6), context.getValue(\"integers[2]\"));\n \n             NestedTestBean nBean = new NestedTestBean(\"Name 9\");\n             tBean.getBeans()[1] = null;\n             context.setValue(\"map/Key4\", new Integer(7));\n             assertEquals(\"Modified <\" + \"map/Key4\" + \">\", new Integer(7), context.getValue(\"map/Key4\"));\n         }\n+    }\n+\n+    /**\n+     * Test JXPath.createPath() with various arguments\n+     */\n+    public void testCreatePath(){\n+        if (enabled){\n+            TestBean tBean = new TestBean();\n+            tBean.setNestedBean(null);\n+            tBean.setBeans(null);\n+            tBean.setMap(null);\n+            JXPathContext context = JXPathContext.newContext(tBean);\n+            context.setFactory(new TestFactory());\n+\n+            // Calls factory.declareVariable(\"string\")\n+            testCreatePath(context, \"$string\", \"Value\");\n+\n+            // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n+            testCreatePath(context, \"$stringArray[2]\", \"Value2\");\n+            assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n+\n+            context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+            // Does not involve factory at all - just expands the collection\n+            testCreatePath(context, \"$array[2]\", \"Value2\");\n+            assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n+\n+            // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n+            testCreatePath(context, \"$test/boolean\", Boolean.TRUE);\n+\n+            // Calls factory.declareVariable(\"testArray\").\n+            // The factory should create a collection of TestBeans.\n+            // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+            // That one should produce an instance of TestBean and put it in the collection\n+            // at index 1.\n+            testCreatePath(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n+\n+            // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+            testCreatePath(context, \"nestedBean/int\", new Integer(1));\n+\n+            // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+            // factory.createObject(..., testBean, \"beans\", 2)\n+            testCreatePath(context, \"beans[2]/int\", new Integer(2));\n+\n+            // Another, but the collection already exists\n+            testCreatePath(context, \"beans[3]/int\", new Integer(3));\n+\n+            // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+            // sets the value\n+            testCreatePath(context, \"nestedBean/strings[2]\", \"Test\");\n+\n+            // Calls factory.createObject(..., testBean, \"map\"), then\n+            // sets the value\n+            testCreatePath(context, \"map[@name = 'TestKey1']\", \"Test\");\n+\n+            // Calls factory.createObject(..., testBean, \"map\"), then\n+            // then factory.createObject(..., map, \"TestKey2\"), then\n+            // sets the value\n+            testCreatePath(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n+\n+            // Calls factory.expandCollection(..., map, \"TestKey3\", 2), then\n+            testCreatePath(context, \"map/TestKey3[2]\", \"Test\");\n+\n+            // Should be the same as the one before\n+            testCreatePath(context, \"map[@name='TestKey3'][3]\", \"Test\");\n+\n+            // Comprehensive tests: map & bean\n+            tBean.setMap(null);\n+            testCreatePath(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(5));\n+            tBean.setMap(null);\n+            testCreatePath(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(6));\n+        }\n+    }\n+\n+    private void testCreatePath(JXPathContext context, String path, Object value){\n+        context.createPath(path, value);\n+        assertEquals(\"Created <\" + path + \">\", value, context.getValue(path));\n     }\n \n     public void testNull(){\n         }\n     }\n \n+    private static class Context implements ExpressionContext {\n+        private Object object;\n+\n+        public Context(Object object){\n+            this.object = object;\n+        }\n+\n+        public Pointer getContextNodePointer(){\n+            return NodePointer.createNodePointer(null, object, Locale.getDefault());\n+        }\n+\n+        public List getContextNodeList(){\n+            return null;\n+        }\n+\n+        public JXPathContext getJXPathContext(){\n+            return null;\n+        }\n+\n+        public int getPosition(){\n+            return 0;\n+        }\n+    }\n+\n     public void testFunctions(){\n         if (enabled){\n             Object[] args;\n \n             args = new Object[]{new Integer(1), \"x\"};\n             func = funcs.getFunction(\"test\", \"new\", args);\n-            assertEquals(\"test:new(1, x)\", func.invoke(args).toString(), \"foo=1; bar=x\");\n+            assertEquals(\"test:new(1, x)\", func.invoke(new Context(null), args).toString(), \"foo=1; bar=x\");\n+\n+            args = new Object[]{\"baz\"};\n+            func = funcs.getFunction(\"test\", \"new\", args);\n+            assertEquals(\"test:new('baz')\", func.invoke(new Context(new Integer(1)), args).toString(), \"foo=1; bar=baz\");\n \n             args = new Object[]{new Integer(1), \"x\"};\n             func = funcs.getFunction(\"test\", \"build\", args);\n-            assertEquals(\"test:build(1, x)\", func.invoke(args).toString(), \"foo=1; bar=x\");\n+            assertEquals(\"test:build(1, x)\", func.invoke(new Context(null), args).toString(), \"foo=1; bar=x\");\n \n             args = new Object[]{\"7\", new Integer(1)};\n             func = funcs.getFunction(\"test\", \"build\", args);\n-            assertEquals(\"test:build('7', 1)\", func.invoke(args).toString(), \"foo=7; bar=1\");\n+            assertEquals(\"test:build('7', 1)\", func.invoke(new Context(null), args).toString(), \"foo=7; bar=1\");\n \n             args = new Object[]{test};\n             func = funcs.getFunction(\"test\", \"getFoo\", args);\n-            assertEquals(\"test:getFoo($test, 1, x)\", func.invoke(args).toString(), \"0\");\n+            assertEquals(\"test:getFoo($test, 1, x)\", func.invoke(new Context(null), args).toString(), \"0\");\n+\n+            args = new Object[0];\n+            func = funcs.getFunction(\"test\", \"path\", args);\n+            assertEquals(\"test:path()\", func.invoke(new Context(new Integer(1)), args), \"1\");\n+\n+            args = new Object[]{test};\n+            func = funcs.getFunction(\"test\", \"instancePath\", args);\n+            assertEquals(\"test:instancePath()\", func.invoke(new Context(new Integer(1)), args), \"1\");\n+\n+            args = new Object[]{test, \"*\"};\n+            func = funcs.getFunction(\"test\", \"pathWithSuffix\", args);\n+            assertEquals(\"test:pathWithSuffix('*')\", func.invoke(new Context(new Integer(1)), args), \"1*\");\n         }\n     }\n \n             try {\n                 if (!xpath_tests[i].path && !xpath_tests[i].eval){\n                     Pointer ptr = ctx.locateValue(xpath_tests[i].xpath);\n-//                  System.err.println(xpath_tests[i].xpath + \" ptr: \" + ptr.getClass() + \"\\n  \" + ptr.asPath());\n                     Pointer test = ctx.locateValue(ptr.asPath());\n                     assertEquals(\"Testing pointer for <\" + xpath_tests[i].xpath + \">\", ptr.asPath(), test.asPath());\n                 }\n         // child::\n         test(\"count(set)\", new Double(3)),\n         test(\"boolean\", Boolean.FALSE),\n+//        test(\"boolean/class/name\", \"java.lang.Boolean\"),\n         testEval(\"foo:boolean\", list()),\n         test(\"count(@*)\", new Double(0)),\n         testPath(\"boolean\", \"/boolean\"),\n         // descendant-or-self::\n         testEval(\"//name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n         test(\"//Key1\", \"Value 1\"),\n+\n         testEval(\"//self::node()[name = 'Name 0']/name\", list(\"Name 0\")),\n         testEval(\"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n                 list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n-        test(\"count(//self::beans)\", new Double(4)),\n-        test(\"count(nestedBean//.)\", new Double(13)),\n+        test(\"count(//self::beans)\", new Double(2)),\n+        test(\"count(nestedBean//.)\", new Double(7)),\n         testEval(\"descendant-or-self::name\", list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\", \"Name 0\", \"Name 5\", \"Name 4\")),\n         test(\"count(descendant-or-self::root)\", new Double(1)),\n         test(\"count(descendant-or-self::node())\", new Double(66)),\n         test(\"string(test:increment(8))\", \"9.0\"),\n         test(\"length('foo')\", new Integer(3)),\n         test(\"call:substring('foo', 1, 2)\", \"o\"),\n-\n+        test(\"//.[test:isMap()]/Key1\", \"Value 1\"),\n+        test(\"count(//.[test:count(strings) = 3])\", new Double(7)),\n+\n+        test(\"/beans[contains(test:path(), '[2]')]/name\", \"Name 2\"),\n \n         // null\n         testPath(\"$testnull/nothing\", \"$testnull/nothing\"),\n     }\n \n     public void testDOM(){\n-//        if (!enabled){\n-//            return;\n-//        }\n+        if (!enabled){\n+            return;\n+        }\n         System.setProperty(JXPathContextFactory.FACTORY_NAME_PROPERTY,\n                 \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\");\n         try {\n             ctx.setLocale(Locale.US);\n             ctx.getVariables().declareVariable(\"dom\", doc);\n             ctx.getVariables().declareVariable(\"object\", docCtr);\n-            TestBeanWithDOM tbwdom = new TestBeanWithDOM();\n-            tbwdom.setVendor(doc.getDocumentElement());\n-            tbwdom.setObject(docCtr);\n+            ctx.getVariables().declareVariable(\"null\", null);\n+            TestBeanWithDOM tbwdom = createTestBeanWithDOM();\n             ctx.getVariables().declareVariable(\"test\", tbwdom);\n             testXPaths(ctx, dom_tests, false);\n         }\n             ex.printStackTrace();\n             throw new RuntimeException(\"Test failed\");\n         }\n+    }\n+\n+    private TestBeanWithDOM createTestBeanWithDOM(){\n+        XMLDocumentContainer docCtr = new XMLDocumentContainer(getClass().getResource(\"Test.properties\"));\n+        Document doc = (Document)docCtr.getValue();\n+        TestBeanWithDOM tbwdom = new TestBeanWithDOM();\n+        tbwdom.setVendor(doc.getDocumentElement());\n+        tbwdom.setObject(docCtr);\n+        return tbwdom;\n     }\n \n     static final XP[] dom_tests = new XP[]{\n         testLenient(\"//foo:x/self::x/y\", null),\n \n         test(\"//nsnode/comment()\", \"z\"),\n-        test(\"//nsnode/text()\", \"text\"),\n+//        test(\"//nsnode/text()\", \"text\"),\n         testPath(\"//nsnode/text()\", \"/vendor[1]/nsnode[1]/text()[1]\"),\n         test(\"//nsnode/processing-instruction()\", \"ahead\"),\n         test(\"//nsnode/processing-instruction('do')\", \"it\"),\n         testPath(\"$test/object/vendor/location[1]//street\", \"$test/object/vendor[1]/location[1]/address[1]/street[1]\"),\n         test(\"$object//street\", \"Some street\"),\n         testPath(\"$object//street\", \"$object/vendor[1]/location[1]/address[1]/street[1]\"),\n+\n+        testPath(\"$null\", \"$null\"),\n+//        testPath(\"$null[3]\", \"$null[3]\"),\n     };\n }\n \n--- a/src/test/org/apache/commons/jxpath/NestedTestBean.java\n+++ b/src/test/org/apache/commons/jxpath/NestedTestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/NestedTestBean.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/NestedTestBean.java,v 1.2 2002/04/10 03:40:21 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A general purpose JavaBean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:21 $\n  */\n public class NestedTestBean {\n     private String name = \"Name 0\";\n+    private int integer = 1;\n \n     public NestedTestBean(){\n     }\n      * A read-only int property\n      */\n     public int getInt(){\n-        return 1;\n+        return integer;\n+    }\n+\n+    public void setInt(int value){\n+        this.integer = value;\n     }\n \n     /**\n         return strings;\n     }\n \n+    public void setStrings(String[] array){\n+        strings = array;\n+    }\n+\n     public String toString(){\n         return \"Nested: \" + name;\n     }\n--- a/src/test/org/apache/commons/jxpath/TestBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.2 2002/04/10 03:40:21 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:21 $\n  */\n public class TestBean {\n \n      * An array of nested java beans.\n      */\n     private NestedTestBean[] beans;\n+    {\n+        beans = new NestedTestBean[2];\n+        beans[0] = new NestedTestBean(\"Name 1\");\n+        beans[1] = new NestedTestBean(\"Name 2\");\n+    }\n+\n     public NestedTestBean[] getBeans(){\n-        if (beans == null){\n-            beans = new NestedTestBean[2];\n-            beans[0] = new NestedTestBean(\"Name 1\");\n-            beans[1] = new NestedTestBean(\"Name 2\");\n-        }\n         return beans;\n+    }\n+\n+    public void setBeans(NestedTestBean[] beans){\n+        this.beans = beans;\n     }\n \n     /**\n      * A Map\n      */\n     private HashMap map;\n+    {\n+        map = new HashMap();\n+        map.put(\"Key1\", \"Value 1\");\n+        map.put(\"Key2\", new NestedTestBean(\"Name 6\"));\n+    }\n+\n     public Map getMap(){\n-        if (map == null){\n-            map = new HashMap();\n-            map.put(\"Key1\", \"Value 1\");\n-            map.put(\"Key2\", new NestedTestBean(\"Name 6\"));\n-//            map.put(\"Key3\", null);\n-        }\n         return map;\n+    }\n+\n+    public void setMap(HashMap map){\n+        this.map = map;\n     }\n \n     /**\n     private NestedTestBean nestedBean = new NestedTestBean(\"Name 0\");\n     public NestedTestBean getNestedBean(){\n         return nestedBean;\n+    }\n+\n+    public void setNestedBean(NestedTestBean bean){\n+        this.nestedBean = bean;\n     }\n \n     private NestedTestBean object = new NestedTestBean(\"Name 5\");\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/TestFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.1 2002/04/10 03:40:21 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/10 03:40:21 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath;\n+\n+import java.util.*;\n+\n+/**\n+ * Test AbstractFactory.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:21 $\n+ */\n+public class TestFactory extends AbstractFactory {\n+\n+    /**\n+     * Create a new instance and put it in the collection on the parent object.\n+     * Return the created object or <b>null</b> if this factory cannot create\n+     * the requested object.\n+     */\n+    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+        if (name.equals(\"testArray\")){\n+            ((TestBean[])parent)[index] = new TestBean();\n+            return true;\n+        }\n+        else if (name.equals(\"nestedBean\")){\n+            ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"beans\")){\n+            ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        else if (name.equals(\"map\")){\n+            ((TestBean)parent).setMap(new HashMap());\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey2\")){\n+            ((Map)parent).put(name, new NestedTestBean(\"newName\"));\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey3\")){\n+            ((Map)parent).put(name, new Vector());\n+            return true;\n+        }\n+        else if (name.equals(\"TestKey5\")){\n+            TestBean tb = new TestBean();\n+            tb.setNestedBean(null);\n+            tb.setBeans(null);\n+            ((Map)parent).put(name, tb);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Create a new object and set it on the specified variable\n+     */\n+    public boolean declareVariable(JXPathContext context, String name){\n+        if (name.equals(\"test\")){\n+            context.getVariables().declareVariable(name, new TestBean());\n+            return true;\n+        }\n+        else if (name.equals(\"testArray\")){\n+            context.getVariables().declareVariable(name, new TestBean[0]);\n+            return true;\n+        }\n+        else if (name.equals(\"stringArray\")){\n+            context.getVariables().declareVariable(name, new String[]{\"Value1\"});\n+            return true;\n+        }\n+        context.getVariables().declareVariable(name, null);\n+        return true;\n+    }\n+\n+    public boolean expandCollection(JXPathContext context, Pointer pointer, Object parent, String name, int size){\n+        if (name.equals(\"beans\")){\n+            TestBean bean = (TestBean)parent;\n+            bean.setBeans(new NestedTestBean[size]);\n+            return true;\n+        }\n+        else if (name.equals(\"strings\")){\n+            NestedTestBean bean = (NestedTestBean)parent;\n+            bean.setStrings(new String[size]);\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/TestFunctions.java\n+++ b/src/test/org/apache/commons/jxpath/TestFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFunctions.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFunctions.java,v 1.2 2002/04/10 03:40:21 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/10 03:40:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:21 $\n  */\n public class TestFunctions {\n \n \n     public TestFunctions(int foo, String bar){\n         this.foo = foo;\n+        this.bar = bar;\n+    }\n+\n+    public TestFunctions(ExpressionContext context, String bar){\n+        this.foo = ((Number)context.getContextNodePointer().getValue()).intValue();\n         this.bar = bar;\n     }\n \n     public String toString(){\n         return \"foo=\" + foo + \"; bar=\" + bar;\n     }\n+\n+    public static String path(ExpressionContext context){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    public String instancePath(ExpressionContext context){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    public String pathWithSuffix(ExpressionContext context, String suffix){\n+        return context.getContextNodePointer().asPath() + suffix;\n+    }\n+\n+    public String className(ExpressionContext context, ExpressionContext child){\n+        return context.getContextNodePointer().asPath();\n+    }\n+\n+    /**\n+     * Returns true if the current node in the current context is a map\n+     */\n+    public static boolean isMap(ExpressionContext context){\n+        Pointer ptr = context.getContextNodePointer();\n+        return ptr == null ? false : (ptr.getValue() instanceof Map);\n+    }\n+\n+    /**\n+     * Returns the number of nodes in the context that is passed as\n+     * the first argument.\n+     */\n+    public static int count(ExpressionContext context, Collection col){\n+        return col.size();\n+    }\n }", "timestamp": 1018410021, "metainfo": ""}