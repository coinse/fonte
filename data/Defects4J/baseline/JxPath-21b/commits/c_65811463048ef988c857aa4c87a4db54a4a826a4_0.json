{"sha": "65811463048ef988c857aa4c87a4db54a4a826a4", "log": "findbugs  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n  * @version $Revision$ $Date$\n  */\n public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n+    private static final long serialVersionUID = -3863803443111484155L;\n+\n+    private static final Comparator PROPERTY_DESCRIPTOR_COMPARATOR = new Comparator() {\n+        public int compare(Object left, Object right) {\n+            return ((PropertyDescriptor) left).getName().compareTo(\n+                ((PropertyDescriptor) right).getName());\n+        }\n+    };\n+\n     private boolean atomic = false;\n     private Class clazz;\n-    private PropertyDescriptor[] propertyDescriptors;\n     private Class dynamicPropertyHandlerClass;\n-    private HashMap propertyDescriptorMap;\n+    private transient PropertyDescriptor[] propertyDescriptors;\n+    private transient HashMap propertyDescriptorMap;\n \n     /**\n      * Create a new JXPathBasicBeanInfo.\n                     PropertyDescriptor[] pds = bi.getPropertyDescriptors();\n                     PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length];\n                     System.arraycopy(pds, 0, descriptors, 0, pds.length);\n-                    Arrays.sort(descriptors, new Comparator() {\n-                        public int compare(Object left, Object right) {\n-                            return ((PropertyDescriptor) left).getName().compareTo(\n-                                ((PropertyDescriptor) right).getName());\n-                        }\n-                    });\n+                    Arrays.sort(descriptors, PROPERTY_DESCRIPTOR_COMPARATOR);\n                     propertyDescriptors = descriptors;\n                 }\n                 catch (IntrospectionException ex) {\n                 }\n             }\n         }\n-        return propertyDescriptors;\n+        if (propertyDescriptors.length == 0) {\n+            return propertyDescriptors;\n+        }\n+        PropertyDescriptor[] result = new PropertyDescriptor[propertyDescriptors.length];\n+        System.arraycopy(propertyDescriptors, 0, result, 0, propertyDescriptors.length);\n+        return result;\n     }\n \n     public synchronized PropertyDescriptor getPropertyDescriptor(String propertyName) {\n--- a/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n package org.apache.commons.jxpath;\n \n import java.beans.PropertyDescriptor;\n+import java.io.Serializable;\n \n /**\n  * JXPathBeanInfo  is similar to {@link java.beans.BeanInfo} in that it describes\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public interface JXPathBeanInfo  {\n+public interface JXPathBeanInfo extends Serializable {\n \n     /**\n      * Returns true if objects of this class are treated as atomic\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n                 }\n             }\n         }\n-        catch (Exception ex) {\n+        catch (IOException ex) {\n             if (debug) {\n                 ex.printStackTrace();\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n  */\n package org.apache.commons.jxpath.ri;\n \n+import java.io.Serializable;\n import java.util.HashMap;\n \n import org.apache.commons.jxpath.Pointer;\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class NamespaceResolver implements Cloneable {\n+public class NamespaceResolver implements Cloneable, Serializable {\n+    private static final long serialVersionUID = 1085590057838651311L;\n+\n     /** Parent NamespaceResolver */\n     protected final NamespaceResolver parent;\n     /** namespace map */\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n public class DescendantContext extends EvalContext {\n     private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private Stack stack;\n-    private NodePointer currentNodePointer;\n+    private Stack stack = null;\n+    private NodePointer currentNodePointer = null;\n     private boolean includeSelf;\n     private static final NodeTest ELEMENT_NODE_TEST =\n             new NodeTypeTest(Compiler.NODE_TYPE_NODE);\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n-            stack = new Stack();\n+            if (stack == null) {\n+                stack = new Stack();\n+            } else {\n+                stack.clear();\n+            }\n             currentNodePointer = parentContext.getCurrentNodePointer();\n             if (currentNodePointer != null) {\n                 if (!currentNodePointer.isLeaf()) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n     private boolean setStarted = false;\n-    private Stack stack;\n+    private Stack stack = null;\n     private NodePointer currentNodePointer;\n     private NodePointer currentRootLocation;\n     private boolean reverse;\n \n     public void reset() {\n         super.reset();\n-        stack = new Stack();\n         setStarted = false;\n     }\n \n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n+            if (stack == null) {\n+                stack = new Stack();\n+            } else {\n+                stack.clear();\n+            }\n             currentRootLocation = parentContext.getCurrentNodePointer();\n             NodePointer parent = currentRootLocation.getParent();\n             if (parent != null) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n             return true;\n         }\n \n-        switch(functionCode) {\n+        switch (functionCode) {\n             case Compiler.FUNCTION_LAST:\n             case Compiler.FUNCTION_POSITION:\n                 return true;\n             case Compiler.FUNCTION_LANG:\n             case Compiler.FUNCTION_NUMBER:\n                 return args == null || args.length == 0;\n+\n+            case Compiler.FUNCTION_FORMAT_NUMBER:\n+                return args != null && args.length == 2;\n \n             case Compiler.FUNCTION_COUNT:\n             case Compiler.FUNCTION_ID:\n             case Compiler.FUNCTION_FLOOR:\n             case Compiler.FUNCTION_CEILING:\n             case Compiler.FUNCTION_ROUND:\n-                return false;\n-\n-            case Compiler.FUNCTION_FORMAT_NUMBER:\n-                return args != null && args.length == 2;\n             default:\n                 return false;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n     protected int index = WHOLE_COLLECTION;\n \n     private boolean attribute = false;\n+    private NamespaceResolver namespaceResolver;\n     private transient Object rootNode;\n-    private NamespaceResolver namespaceResolver;\n \n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n     public boolean isLanguage(String lang) {\n         Locale loc = getLocale();\n         String name = loc.toString().replace('_', '-');\n-        return name.toUpperCase().startsWith(lang.toUpperCase());\n+        return name.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     private Object bean;\n-    private JXPathBeanInfo beanInfo;//TODO determine serialization strategy\n+    private JXPathBeanInfo beanInfo;\n \n     private static final long serialVersionUID = -8227317938284982440L;\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n  * @version $Revision$ $Date$\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n+    private static final long serialVersionUID = -6008991447676468786L;\n+\n+    private static final Object UNINITIALIZED = new Object();\n+\n     private String propertyName;\n     private JXPathBeanInfo beanInfo;\n-    private PropertyDescriptor[] propertyDescriptors;\n-    private PropertyDescriptor propertyDescriptor;//TODO determine proper serialization strategy\n-    private String[] names;\n-    private static final Object UNINITIALIZED = new Object();\n     private Object baseValue = UNINITIALIZED;\n     private Object value = UNINITIALIZED;\n-\n-    private static final long serialVersionUID = -6008991447676468786L;\n+    private transient String[] names;\n+    private transient PropertyDescriptor[] propertyDescriptors;\n+    private transient PropertyDescriptor propertyDescriptor;\n \n     /**\n      * Create a new BeanPropertyPointer.\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n     }\n \n     public NodePointer createPath(JXPathContext context) {\n-        Object collection = getBaseValue();\n-        if (ValueUtils.getLength(collection) <= index) {\n+        if (ValueUtils.getLength(getBaseValue()) <= index) {\n             collection = ValueUtils.expandCollection(getNode(), index + 1);\n         }\n         return this;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n import org.w3c.dom.Attr;\n \n /**\n- * A Pointer that points to a DOM node.\n+ * A Pointer that points to a DOM node. Because the underlying DOM Attr is not Serializable,\n+ * neither is this pointer class truly so.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class DOMAttributePointer extends NodePointer {\n-    private Attr attr;//TODO determine proper serialization strategy\n-\n     private static final long serialVersionUID = 1115085175427555951L;\n+    \n+    private Attr attr;\n \n     /**\n      * Create a new DOMAttributePointer.\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n import org.w3c.dom.ProcessingInstruction;\n \n /**\n- * A Pointer that points to a DOM node.\n+ * A Pointer that points to a DOM node. Because a DOM Node is not guaranteed Serializable,\n+ * a DOMNodePointer instance may likewise not be properly Serializable.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n         return current == null ? super.isLanguage(lang)\n-                : current.toUpperCase().startsWith(lang.toUpperCase());\n+                : current.toUpperCase(Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n \n \n /**\n- * A Pointer that points to a {@link DynaBean}.\n+ * A Pointer that points to a {@link DynaBean}.  If the target DynaBean is Serializable,\n+ * so should this instance be.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class DynaBeanPointer extends PropertyOwnerPointer {\n+    private static final long serialVersionUID = -9135052498044877965L;\n+\n     private QName name;\n     private DynaBean dynaBean;\n-\n-    private static final long serialVersionUID = -9135052498044877965L;\n \n     /**\n      * Create a new DynaBeanPointer.\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n- * Pointer pointing to a property of a {@link DynaBean}.\n+ * Pointer pointing to a property of a {@link DynaBean}. If the target DynaBean is\n+ * Serializable, so should this instance be.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n      */\n     public boolean isLanguage(String lang) {\n         String current = getLanguage();\n-        return current == null ? super.isLanguage(lang) : current.toUpperCase().startsWith(lang.toUpperCase());\n+        return current == null ? super.isLanguage(lang) : current.toUpperCase(\n+                Locale.ENGLISH).startsWith(lang.toUpperCase(Locale.ENGLISH));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n         while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        return (String[]) list.toArray(new String[0]);\n+        return (String[]) list.toArray(new String[list.size()]);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n      * Value pointer\n      */\n     static final class ValuePointer implements Pointer {\n+        private static final long serialVersionUID = -4817239482392206188L;\n+        \n         private Object bean;\n-\n-        private static final long serialVersionUID = -4817239482392206188L;\n \n         /**\n          * Create a new ValuePointer.\n--- a/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n+++ b/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n  */\n package org.apache.commons.jxpath.util;\n \n+import java.io.Serializable;\n import java.util.Comparator;\n \n /**\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public final class ReverseComparator implements Comparator {\n+public final class ReverseComparator implements Comparator, Serializable {\n+    private static final long serialVersionUID = -2795475743948616649L;\n+\n     /**\n      * Singleton reverse comparator instance.\n      */\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n                 throw new JXPathException(\"No write method\");\n             }\n             value = convert(value, propertyDescriptor.getPropertyType());\n-            value = method.invoke(bean, new Object[] { value });\n+            method.invoke(bean, new Object[] { value });\n         }\n         catch (Exception ex) {\n             throw new JXPathException(\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n  */\n package org.apache.commons.jxpath.xml;\n \n+import java.io.IOException;\n import java.io.InputStream;\n import java.net.URL;\n import java.util.HashMap;\n                     }\n                 }\n             }\n-            catch (Exception ex) {\n+            catch (IOException ex) {\n                 throw new JXPathException(\n                     \"Cannot read XML from: \" + xmlURL.toString(),\n                     ex);", "timestamp": 1213653588, "metainfo": ""}