{"sha": "cd0b3e7260bd6dbc87f0ae86308cf35d79e14d8f", "log": "Improved the Javadoc: - added external links to JDOM, BeanUtils, and JEE - added @links in the class and method documentations to improve the navigation - removed the @inheritDoc with no additional comments Added line feeds at the end of the source files Removed the old constructors and the suite() methods from the JUnit tests Updated the relocated artifacts in the POM Downgraded the dependency on JUnit to 3.8.1 Added PMD to the reports   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n     public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n+++ b/src/java/org/apache/commons/jxpath/BasicNodeSet.java\n import java.util.List;\n \n /**\n- * A simple implementation of NodeSet that behaves as a collection of pointers.\n+ * A simple implementation of {@link NodeSet} that behaves as a collection\n+ * of pointers.\n+ *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized List getPointers() {\n         if (readOnlyPointers == null) {\n             readOnlyPointers = Collections.unmodifiableList(pointers);\n         return readOnlyPointers;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized List getNodes() {\n         if (nodes == null) {\n             nodes = new ArrayList();\n         return nodes;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized List getValues() {\n         if (values == null) {\n             values = new ArrayList();\n         return values;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return pointers.toString();\n     }\n--- a/src/java/org/apache/commons/jxpath/BasicVariables.java\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n         vars.remove(varName);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return vars.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n  * </dl>\n  *\n  * <p>\n- * If the first argument of a method is ExpressionContext, the\n+ * If the first argument of a method is {@link ExpressionContext}, the\n  * expression context in which the function is evaluated is passed to\n  * the method.\n  *\n     }\n \n     /**\n-     * Returns a Function, if any, for the specified namespace,\n+     * Returns a {@link Function}, if any, for the specified namespace,\n      * name and parameter types.\n      *\n      * @param namespace if it is not the namespace specified in the constructor,\n--- a/src/java/org/apache/commons/jxpath/CompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/CompiledExpression.java\n /**\n  * Represents a compiled XPath. The interpretation of compiled XPaths\n  * may be faster, because it bypasses the compilation step. The reference\n- * implementation of JXPathContext also globally caches some of the\n+ * implementation of {@link JXPathContext} also globally caches some of the\n  * results of compilation, so the direct use of JXPathContext is not\n  * always less efficient than the use of CompiledExpression.\n  * <p>\n  * same expression multiple times and the CompiledExpression can be\n  * conveniently cached.\n  * <p>\n- * To acqure a CompiledExpression, call {@link JXPathContext#compile\n+ * To acquire a CompiledExpression, call {@link JXPathContext#compile\n  * JXPathContext.compile}\n  *\n  * @author Dmitri Plotnikov\n \n     /**\n      * Creates intermediate elements of\n-     * the path by invoking an AbstractFactory, which should first be\n-     * installed on the context by calling \"setFactory\".\n+     * the path by invoking an {@link AbstractFactory}, which should first be\n+     * installed on the context by calling {@link JXPathContext#setFactory}.\n      * @param context base\n      * @return Pointer created\n      */\n \n     /**\n      * The same as setValue, except it creates intermediate elements of\n-     * the path by invoking an AbstractFactory, which should first be\n-     * installed on the context by calling \"setFactory\".\n+     * the path by invoking an {@link AbstractFactory}, which should first be\n+     * installed on the context by calling {@link JXPathContext#setFactory}.\n      * <p>\n      * Will throw an exception if one of the following conditions occurs:\n      * <ul>\n--- a/src/java/org/apache/commons/jxpath/Container.java\n+++ b/src/java/org/apache/commons/jxpath/Container.java\n      * @param value Object value to set.\n      */\n     void setValue(Object value);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n      * @param value to set\n      */\n     void setProperty(Object object, String propertyName, Object value);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ExtendedKeyManager.java\n+++ b/src/java/org/apache/commons/jxpath/ExtendedKeyManager.java\n      */\n     NodeSet getNodeSetByKey(JXPathContext context, String key, Object value);\n \n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/Function.java\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n      * @return Object result\n      */\n     Object invoke(ExpressionContext context, Object[] parameters);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n import java.util.Set;\n \n /**\n- * An object that aggregates Functions objects into a group Functions object.\n- * Since JXPathContext can only register a single Functions object,\n- * FunctionLibrary should always be used to group all Functions objects\n+ * An object that aggregates {@link Functions} objects into a group Functions\n+ * object. Since {@link JXPathContext} can only register a single Functions\n+ * object, FunctionLibrary should always be used to group all Functions objects\n  * that need to be registered.\n  *\n  * @author Dmitri Plotnikov\n             }\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/Functions.java\n+++ b/src/java/org/apache/commons/jxpath/Functions.java\n      * @return Function\n      */\n     Function getFunction(String namespace, String name, Object[] parameters);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/IdentityManager.java\n+++ b/src/java/org/apache/commons/jxpath/IdentityManager.java\n package org.apache.commons.jxpath;\n \n /**\n- * A delegate of JXPathContext that implements the XPath <code>\"id()\"</code>\n+ * A delegate of {@link JXPathContext} that implements the XPath <code>\"id()\"</code>\n  * function. This delegate is only used when there is no default implementation\n  * of the <code>id()</code> function. For example, it is <i>not</i> used\n  * when the root of the context is a DOM Node.\n      * @return Pointer\n      */\n     Pointer getPointerByID(JXPathContext context, String id);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathAbstractFactoryException.java\n package org.apache.commons.jxpath;\n \n /**\n- * Thrown when an AbstractFactory cannot generate an object for the requested\n- * path.\n+ * Thrown when an {@link AbstractFactory} cannot generate an object for\n+ * the requested path.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision: 155422 $ $Date: 2005-02-26 08:07:46 -0500 (Sat, 26 Feb 2005) $\n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n  * advertised by JXPathBasicBeanInfo are the same as those advertised by\n  * BeanInfo for the corresponding class.\n  *\n- * See java.beans.BeanInfo, java.beans.Introspector\n+ * @see java.beans.BeanInfo\n+ * @see java.beans.Introspector\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         return dynamicPropertyHandlerClass != null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized PropertyDescriptor[] getPropertyDescriptors() {\n         if (propertyDescriptors == null) {\n             if (clazz == Object.class) {\n         return propertyDescriptors;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized PropertyDescriptor getPropertyDescriptor(String propertyName) {\n         if (propertyDescriptorMap == null) {\n             propertyDescriptorMap = new HashMap();\n         return dynamicPropertyHandlerClass;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"BeanInfo [class = \");\n         buffer.append(\"]\");\n         return buffer.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n import java.beans.PropertyDescriptor;\n \n /**\n- * JXPathBeanInfo  is similar to java.beans.BeanInfo in that it describes\n+ * JXPathBeanInfo  is similar to {@link java.beans.BeanInfo} in that it describes\n  * properties of a JavaBean class.  By default, JXPathBeanInfo classes are\n  * automatically generated by {@link JXPathIntrospector JXPathIntrospector}\n  * based on the java.beans.BeanInfo. As with JavaBeans, the user can supply an\n     /**\n      * Returns true if objects of this class are treated as atomic\n      * objects which have no properties of their own.\n-     * For example, java.lang.String and java.lang.Number are atomic.\n+     * For example, {@link String} and {@link Number} are atomic.\n      * @return boolean\n      */\n     boolean isAtomic();\n \n     /**\n      * Returns true if the objects of this class have dynamic properties\n-     * (e.g. java.util.Map). If this method returns true, getPropertyDescriptors\n-     * should return null and getDynamicPropertyHandlerClass should return\n+     * (e.g. java.util.Map). If this method returns true, {@link #getPropertyDescriptors}\n+     * should return null and {@link #getDynamicPropertyHandlerClass} should return\n      * a valid class name.  An object cannot have both static and dynamic\n      * properties at the same time.\n      * @return boolean\n \n     /**\n      * For dynamic objects, returns the class implementing\n-     * the DynamicPropertyHandler interface. That class can\n+     * the {@link DynamicPropertyHandler} interface. That class can\n      * be used to access dynamic properties.\n      * @return Class\n      */\n     Class getDynamicPropertyHandlerClass();\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n  * JXPathContext  allows alternative implementations. This is why instead of\n  * allocating JXPathContext directly, you should call a static\n  * <code>newContext</code> method.  This method will utilize the\n- * JXPathContextFactory API to locate a suitable implementation of JXPath.\n- * Bundled with JXPath comes a default implementation called Reference\n+ * {@link JXPathContextFactory} API to locate a suitable implementation of\n+ * JXPath. Bundled with JXPath comes a default implementation called Reference\n  * Implementation.\n  * </p>\n  *\n \n     /**\n      * Returns the variable pool associated with the context. If no such\n-     * pool was specified with the <code>setVariables()</code> method,\n+     * pool was specified with the {@link #setVariables} method,\n      * returns the default implementation of Variables,\n      * {@link BasicVariables BasicVariables}.\n      * @return Variables\n     }\n \n     /**\n-     * Sets DecimalFormatSymbols for a given name. The DecimalFormatSymbols can\n-     * be referenced as the third, optional argument in the invocation of\n+     * Sets {@link DecimalFormatSymbols} for a given name. The DecimalFormatSymbols\n+     * can be referenced as the third, optional argument in the invocation of\n      * <code>format-number (number,format,decimal-format-name)</code> function.\n      * By default, JXPath uses the symbols for the current locale.\n      *\n     public abstract void setValue(String xpath, Object value);\n \n     /**\n-     * Creates missing elements of the path by invoking an AbstractFactory,\n-     * which should first be installed on the context by calling \"setFactory\".\n+     * Creates missing elements of the path by invoking an {@link AbstractFactory},\n+     * which should first be installed on the context by calling {@link #setFactory}.\n      * <p>\n      * Will throw an exception if the AbstractFactory fails to create\n      * an instance for a path element.\n \n     /**\n      * The same as setValue, except it creates intermediate elements of\n-     * the path by invoking an AbstractFactory, which should first be\n-     * installed on the context by calling \"setFactory\".\n+     * the path by invoking an {@link AbstractFactory}, which should first be\n+     * installed on the context by calling {@link #setFactory}.\n      * <p>\n      * Will throw an exception if one of the following conditions occurs:\n      * <ul>\n                 \"Namespace registration is not implemented by \" + getClass());\n     }\n \n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n \n /**\n  * Defines a factory API that enables applications to obtain a\n- * JXPathContext instance.  To acquire a JXPathContext, first call the\n- * static <code>newInstance()</code> method of JXPathContextFactory.\n+ * {@link JXPathContext} instance.  To acquire a JXPathContext, first call the\n+ * static {@link #newInstance} method of JXPathContextFactory.\n  * This method returns a concrete JXPathContextFactory.\n- * Then call <code>newContext()</code> on that instance.  You will rarely\n+ * Then call {@link #newContext} on that instance.  You will rarely\n  * need to perform these steps explicitly: usually you can call one of the\n  * <code>JXPathContex.newContext</code> methods, which will perform these steps\n  * for you.\n \n         return defaultFactory;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactoryConfigurationError.java\n package org.apache.commons.jxpath;\n \n /**\n- * Thrown when a problem with configuration with the JXPathContextFactories\n+ * Thrown when a problem with configuration with the {@link JXPathContextFactory JXPathContextFactories}\n  * exists. This error will typically be thrown when the class of a\n  * factory specified in the system properties cannot be found\n  * or instantiated.\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class JXPathContextFactoryConfigurationError extends Error {\n \n     /** @serial */\n      * Create a new <code>JXPathContextFactoryConfigurationError</code> with no\n      * detail mesage.\n      */\n-\n      public JXPathContextFactoryConfigurationError() {\n          super();\n          this.exception = null;\n      *\n      * @param msg The error message for the exception.\n      */\n-\n     public JXPathContextFactoryConfigurationError(String msg) {\n         super(msg);\n         this.exception = null;\n      * @param e The exception to be encapsulated in a\n      * JXPathContextFactoryConfigurationError.\n      */\n-\n     public JXPathContextFactoryConfigurationError(Exception e) {\n         super(e.toString());\n         this.exception = e;\n      * JXPathContextFactoryConfigurationError\n      * @param msg The detail message.\n      */\n-\n     public JXPathContextFactoryConfigurationError(Exception e, String msg) {\n         super(msg);\n         this.exception = e;\n      *\n      * @return The error message.\n      */\n-\n     public String getMessage () {\n         String message = super.getMessage();\n         if (message == null && exception != null) {\n      *\n      * @return The encapsulated exception, or null if there is none.\n      */\n-\n     public Exception getException () {\n         return exception;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n     }\n \n     /**\n-     * Automatically creates and registers a JXPathBeanInfo object\n-     * for the specified class. That object returns true to isDynamic().\n+     * Automatically creates and registers a {@link JXPathBeanInfo} object\n+     * for the specified class. That object returns true to\n+     * {@link JXPathBeanInfo#isDynamic()}.\n+     *\n      * @param beanClass to register\n      * @param dynamicPropertyHandlerClass to handle beanClass\n      */\n         Class cls = Class.forName(className);\n         return cls.newInstance();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n package org.apache.commons.jxpath;\n \n /**\n- * Similary to InvocationTargetException in that it is thrown when\n- * JXPath cannot access properties, collection etc on the target object model.\n+ * Similary to {@link java.lang.reflect.InvocationTargetException} in that\n+ * it is thrown when JXPath cannot access properties, collection etc on the\n+ * target object model.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision: 155422 $ $Date: 2005-02-26 08:07:46 -0500 (Sat, 26 Feb 2005) $\n--- a/src/java/org/apache/commons/jxpath/KeyManager.java\n+++ b/src/java/org/apache/commons/jxpath/KeyManager.java\n package org.apache.commons.jxpath;\n \n /**\n- * A delegate of JXPathContext that implements the XPath <code>\"key()\"</code>\n+ * A delegate of {@link JXPathContext} that implements the XPath <code>\"key()\"</code>\n  * function.\n  *\n  * @author Dmitri Plotnikov\n \n     /**\n      * Find a node by key/value.\n+     *\n      * @param context to search\n      * @param keyName String\n      * @param keyValue String\n         JXPathContext context,\n         String keyName,\n         String keyValue);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n import java.util.Set;\n \n /**\n- * Implements the DynamicPropertyHandler interface for java.util.Map.\n+ * Implements the DynamicPropertyHandler interface for {@link java.util.Map}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class MapDynamicPropertyHandler implements DynamicPropertyHandler {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames(Object object) {\n         Map map = (Map) object;\n         Set set = map.keySet();\n         return names;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getProperty(Object object, String propertyName) {\n         return ((Map) object).get(propertyName);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object object, String propertyName, Object value) {\n         ((Map) object).put(propertyName, value);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n  * </dl>\n  *\n  * <p>\n- * If the first argument of a method or constructor is ExpressionContext, the\n- * expression context in which the function is evaluated is passed to\n+ * If the first argument of a method or constructor is {@link ExpressionContext},\n+ * the expression context in which the function is evaluated is passed to\n  * the method.\n  * </p>\n  * <p>\n     }\n \n     /**\n-     * Returns a Function, if found, for the specified namespace,\n+     * Returns a {@link Function}, if found, for the specified namespace,\n      * name and parameter types.\n      * <p>\n      * @param  namespace - if it is not the same as specified in the\n         }\n         return null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n      * @return cloned Object\n      */\n     Object clone();\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/Variables.java\n+++ b/src/java/org/apache/commons/jxpath/Variables.java\n      * @param varName is a variable name without the \"$\" sign\n      */\n     void undeclareVariable(String varName);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n  * read, parsed and traversed. If they are not - they won't be\n  * read at all.\n  *\n- * @deprecated 1.1 Please use org.apache.commons.jxpath.xml.DocumentContainer\n+ * @deprecated 1.1 Please use {@link DocumentContainer}\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n                 ex);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n         this.method = ValueUtils.getAccessibleMethod(method);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object invoke(ExpressionContext context, Object[] parameters) {\n         try {\n             Object target;\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return method.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/Compiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Compiler.java\n         Object expression,\n         Object[] predicates,\n         Object[] steps);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n         this.parentContext = parentContext;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getContextNodePointer() {\n         return getCurrentNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public JXPathContext getJXPathContext() {\n         return getRootContext().getJXPathContext();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n         return getNodeSet();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         Pointer ptr = getContextNodePointer();\n         return ptr == null ? \"Empty expression context\" : \"Expression context [\" + getPosition()\n         this.position = position;\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n         }\n         return object != null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n         return expression;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return xpath;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n                     getValue(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue(JXPathContext context, Class requiredType) {\n         return ((JXPathContextReferenceImpl) context).\n                     getValue(xpath, expression, requiredType);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(JXPathContext context, Object value) {\n         ((JXPathContextReferenceImpl) context).\n                     setValue(xpath, expression, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer createPath(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n                     createPath(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer createPathAndSetValue(JXPathContext context, Object value) {\n         return ((JXPathContextReferenceImpl) context).\n                     createPathAndSetValue(xpath, expression, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Iterator iterate(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n                     iterate(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getPointer(JXPathContext context, String xpath) {\n         return ((JXPathContextReferenceImpl) context).\n                     getPointer(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Iterator iteratePointers(JXPathContext context) {\n         return ((JXPathContextReferenceImpl) context).\n                     iteratePointers(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void removePath(JXPathContext context) {\n         ((JXPathContextReferenceImpl) context).removePath(xpath, expression);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void removeAll(JXPathContext context) {\n         ((JXPathContextReferenceImpl) context).removeAll(xpath, expression);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n     public JXPathContextFactoryReferenceImpl() {\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public JXPathContext newContext(\n         JXPathContext parentContext,\n         Object contextBean) {\n         return new JXPathContextReferenceImpl(parentContext, contextBean);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n         return COMPILER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected CompiledExpression compilePath(String xpath) {\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n         return expr.iterate(getEvalContext());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getPointer(String xpath) {\n         return getPointer(xpath, compileExpression(xpath));\n     }\n         return NodePointer.newNodePointer(null, result, getLocale());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(String xpath, Object value) {\n         setValue(xpath, compileExpression(xpath), value);\n     }\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer createPath(String xpath) {\n         return createPath(xpath, compileExpression(xpath));\n     }\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer createPathAndSetValue(String xpath, Object value) {\n         return createPathAndSetValue(xpath, compileExpression(xpath), value);\n     }\n         return expr.iteratePointers(getEvalContext());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void removePath(String xpath) {\n         removePath(xpath, compileExpression(xpath));\n     }\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void removeAll(String xpath) {\n         removeAll(xpath, compileExpression(xpath));\n     }\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public JXPathContext getRelativeContext(Pointer pointer) {\n         Object contextBean = pointer.getNode();\n         if (contextBean == null) {\n         return new JXPathContextReferenceImpl(this, contextBean, pointer);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getContextPointer() {\n         return contextPointer;\n     }\n             \"Undefined function: \" + functionName.toString());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void registerNamespace(String prefix, String namespaceURI) {\n         if (namespaceResolver.isSealed()) {\n             namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n         namespaceResolver.registerNamespace(prefix, namespaceURI);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI(String prefix) {\n         return namespaceResolver.getNamespaceURI(prefix);\n     }\n         return namespaceResolver.getPrefix(namespaceURI);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setNamespaceContextPointer(Pointer pointer) {\n         if (namespaceResolver.isSealed()) {\n             namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n         namespaceResolver.setNamespaceContextPointer((NodePointer) pointer);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getNamespaceContextPointer() {\n         return namespaceResolver.getNamespaceContextPointer();\n     }\n             throw new JXPathException(\"Cannot allocate \" + className, ex);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n+++ b/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * Namespace resolver for JXPathContextReferenceImpl.\n+ * Namespace resolver for {@link JXPathContextReferenceImpl}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     * @see java.lang.Object#clone()\n-     */\n     public Object clone() {\n         try {\n             NamespaceResolver result = (NamespaceResolver) super.clone();\n             return null;\n         }\n     }\n-\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n         // Piggy-back on the code generated by JavaCC\n         return TokenMgrError.addEscapes(string);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return qualifiedName;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return name.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (this == object) {\n             return true;\n         }\n         return qualifiedName.equals(((QName) object).qualifiedName);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getDocumentOrder() {\n         return -1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n             currentNodePointer = parentContext.getCurrentNodePointer();\n-            if (includeSelf) {\n-                if (currentNodePointer.testNode(nodeTest)) {\n-                    position++;\n-                    return true;\n-                }\n+            if (includeSelf && currentNodePointer.testNode(nodeTest)) {\n+                position++;\n+                return true;\n             }\n         }\n \n             }\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted) {\n         currentNodePointer = iterator.getNodePointer();\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n         this.reverse = reverse;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n-        if (position == 0) {\n-            if (!setPosition(1)) {\n-                return null;\n-            }\n+        if (position == 0 && !setPosition(1)) {\n+            return null;\n         }\n         return iterator == null ? null : iterator.getNodePointer();\n     }\n         return getCurrentNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         iterator = null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         int oldPosition = getCurrentPosition();\n         super.setPosition(position);\n         iterator = parent == null ? null : useParent.childIterator(nodeTest,\n                 reverse, startFromParentLocation ? parent : null);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isChildOrderingRequired() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n-        if (position == 0) {\n-            if (!setPosition(1)) {\n-                return null;\n-            }\n+        if (position == 0 && !setPosition(1)) {\n+            return null;\n         }\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position < this.position) {\n             reset();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n                             false,\n                             null));\n                 }\n-                if (includeSelf) {\n-                    if (currentNodePointer.testNode(nodeTest)) {\n-                        position++;\n-                        return true;\n-                    }\n+                if (includeSelf && currentNodePointer.testNode(nodeTest)) {\n+                    position++;\n+                    return true;\n                 }\n             }\n         }\n         }\n         return false;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getSingleNodePointer() {\n         return nodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return nodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         return nodePointer.getValue();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         if (collection) {\n         return position == 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextSet() {\n         if (started) {\n             return false;\n         started = true;\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position < getCurrentPosition()) {\n             reset();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n         if (!setStarted) {\n         currentNodePointer = iterator.getNodePointer();\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NodeSetContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NodeSetContext.java\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * A simple context that is based on a NodeSet.\n+ * A simple context that is based on a {@link NodeSet}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         this.nodeSet = nodeSet;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeSet getNodeSet() {\n         return nodeSet;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n-        if (position == 0) {\n-            if (!setPosition(1)) {\n-                return null;\n-            }\n+        if (position == 0 && !setPosition(1)) {\n+            return null;\n         }\n         return (NodePointer) nodeSet.getPointers().get(position - 1);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         super.setPosition(position);\n         return position >= 1 && position <= nodeSet.getPointers().size();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextSet() {\n         if (startedSet) {\n             return false;\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getCurrentPosition() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getDocumentOrder() {\n         return -1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         super.setPosition(position);\n         return position == 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         // Each set contains exactly one node: the parent\n         if (setStarted) {\n         }\n         return false;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n         this.reverse = reverse;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getDocumentOrder() {\n         return reverse ? -1 : 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         stack = new Stack();\n         setStarted = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position < this.position) {\n             reset();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n         }\n         return false;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         if (done) {\n             return false;\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (nameTestExpression == null) {\n             return setPositionStandard(position);\n         }\n         else {\n-            if (dynamicPropertyPointer == null) {\n-                if (!setupDynamicPropertyPointer()) {\n-                    return setPositionStandard(position);\n-                }\n+            if (dynamicPropertyPointer == null && !setupDynamicPropertyPointer()) {\n+                return setPositionStandard(position);\n             }\n             if (position < 1\n                 || position > dynamicPropertyPointer.getLength()) {\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n-        if (position == 0) {\n-            if (!setPosition(1)) {\n-                return null;\n-            }\n+        if (position == 0 && !setPosition(1)) {\n+            return null;\n         }\n         if (dynamicPropertyPointer != null) {\n             return dynamicPropertyPointer.getValuePointer();\n         return parentContext.getCurrentNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         parentContext.reset();\n         done = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextSet() {\n         reset();\n         return parentContext.nextSet();\n         }\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public JXPathContext getJXPathContext() {\n         return jxpathContext;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public RootContext getRootContext() {\n         return this;\n     }\n         return jxpathContext.getAbsoluteRootContext();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         return pointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         return pointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getCurrentPosition() {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextSet() {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         throw new UnsupportedOperationException();\n     }\n         return availableRegister - 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return super.toString() + \":\" + pointer.asPath();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n         this.nodeTest = nodeTest;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Pointer getSingleNodePointer() {\n         return parentContext.getSingleNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getCurrentNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return nodePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean nextNode() {\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void reset() {\n         super.reset();\n         startedSet = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (position != 1) {\n             return false;\n \n         return nodeTest == null || nodePointer.testNode(nodeTest);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n             && name.getPrefix().equals(\"xml\")\n             && name.getName().equals(\"lang\");\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n         this.contexts = contexts;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getDocumentOrder() {\n         return contexts.length > 1 ? 1 : super.getDocumentOrder();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (!prepared) {\n             prepared = true;\n         }\n         return super.setPosition(position);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n         this.value = string;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         return value;\n     }\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         if (value instanceof Number) {\n             return InfoSetUtil.stringValue(value);\n         }\n         return \"'\" + value + \"'\";\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getFunctionName());\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         switch (functionCode) {\n             case Compiler.FUNCTION_LAST :\n                     \"Incorrect number of arguments: \" + this);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public abstract Object computeValue(EvalContext context);\n \n     /**\n      */\n     protected abstract int getPrecedence();\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         if (args.length == 1) {\n             return getSymbol() + parenthesize(args[0], false);\n         }\n         return '(' + s + ')';\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAdd.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAdd.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"+\".\n+ * Implementation of {@link Expression} for the operation \"+\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         double s = 0.0;\n         for (int i = 0; i < args.length; i++) {\n         return new Double(s);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return ADD_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"+\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"and\".\n+ * Implementation of {@link Expression} for the operation \"and\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         for (int i = 0; i < args.length; i++) {\n             if (!InfoSetUtil.booleanValue(args[i].computeValue(context))) {\n         return Boolean.TRUE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return AND_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"and\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n         this.invert = invert;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return COMPARE_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationDivide.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationDivide.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"div\".\n+ * Implementation of {@link Expression} for the operation \"div\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l / r);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return MULTIPLY_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"div\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"=\".\n+ * Implementation of {@link Expression} for the operation \"=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(arg1, arg2);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"&gt;\".\n+ * Implementation of {@link Expression} for the operation \"&gt;\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean evaluateCompare(int compare) {\n         return compare > 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \">\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"&gt;=\".\n+ * Implementation of {@link Expression} for the operation \"&gt;=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean evaluateCompare(int compare) {\n         return compare >= 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \">=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"&lt;\".\n+ * Implementation of {@link Expression} for the operation \"&lt;\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean evaluateCompare(int compare) {\n         return compare < 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"<\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"&lt;=\".\n+ * Implementation of {@link Expression} for the operation \"&lt;=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean evaluateCompare(int compare) {\n         return compare <= 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"<=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMod.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMod.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"mod\".\n+ * Implementation of {@link Expression} for the operation \"mod\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context));\n         long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l % r);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return MULTIPLY_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"mod\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationMultiply.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"*\".\n+ * Implementation of {@link Expression} for the operation \"*\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l * r);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return MULTIPLY_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"*\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNegate.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNegate.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation unary \"-\".\n+ * Implementation of {@link Expression} for the operation unary \"-\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         double a = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         return new Double(-a);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return NEGATE_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"-\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n package org.apache.commons.jxpath.ri.compiler;\n \n /**\n- * Implementation of Expression for the operation \"!=\".\n+ * Implementation of {@link Expression} for the operation \"!=\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(arg1, arg2, true);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"!=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationOr.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationOr.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"or\".\n+ * Implementation of {@link Expression} for the operation \"or\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         for (int i = 0; i < args.length; i++) {\n             if (InfoSetUtil.booleanValue(args[i].computeValue(context))) {\n         return Boolean.FALSE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return OR_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"or\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public final Object computeValue(EvalContext context) {\n         return compute(args[0].compute(context), args[1].compute(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected final int getPrecedence() {\n         return RELATIONAL_EXPR_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected final boolean isSymmetric() {\n         return false;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * Implementation of Expression for the operation \"-\".\n+ * Implementation of {@link Expression} for the operation \"-\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(new Expression[] { arg1, arg2 });\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l - r);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return ADD_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"-\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationUnion.java\n import org.apache.commons.jxpath.ri.axes.UnionContext;\n \n /**\n- * Implementation of Expression for the operation \"|\".\n+ * Implementation of {@link Expression} for the operation \"|\".\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         super(args);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         EvalContext[] argCtxs = new EvalContext[args.length];\n         for (int i = 0; i < args.length; i++) {\n         return new UnionContext(context.getRootContext(), argCtxs);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected int getPrecedence() {\n         return UNION_PRECEDENCE;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getSymbol() {\n         return \"|\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n             this.locale = locale;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object next() {\n             Object o = iterator.next();\n             return o instanceof Pointer ? o : NodePointer.newNodePointer(qname, o, locale);\n             this.iterator = it;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object next() {\n             Object o = iterator.next();\n             return o instanceof Pointer ? ((Pointer) o).getValue() : o;\n             throw new UnsupportedOperationException();\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n         return basic;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         if (expression instanceof CoreOperation\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return expressionPath(context, false);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         return expressionPath(context, true);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(functionName);\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         Object[] parameters = null;\n         if (args != null) {\n     private Object convert(Object object) {\n         return object instanceof EvalContext ? ((EvalContext) object).getValue() : object;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n         return absolute;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean computeContextDependent() {\n         return !absolute || super.computeContextDependent();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         Step[] steps = getSteps();\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n         return evalSteps(rootContext);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object computeValue(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n         }\n         return getSingleNodePointerForSteps(rootContext);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.jxpath.ri.compiler;\n-\n \n /**\n  * Captures the <code>foo[@name=<i>expr</i>]</code> expression. These\n         return args[1];\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean computeContextDependent() {\n         return true;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n         return qname.getName().equals(\"*\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return qname.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTest.java\n  * @version $Revision$ $Date$\n  */\n public abstract class NodeTest {\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n         return nodeType;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return nodeTypeToString(nodeType) + \"()\";\n     }\n                 return \"UNKNOWN\";\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n         return args;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean computeContextDependent() {\n         if (args != null) {\n             for (int i = 0; i < args.length; i++) {\n         }\n         return false;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n         return steps;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean computeContextDependent() {\n         if (steps != null) {\n             for (int i = 0; i < steps.length; i++) {\n             return null; // Never happens\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n         return target;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return \"processing-instruction('\" + target + \"')\";\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         int axis = getAxis();\n                 return \"UNKNOWN\";\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n \n     private static final QName QNAME_NAME = new QName(null, \"name\");\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object number(String value) {\n         return new Constant(new Double(value));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object literal(String value) {\n         return new Constant(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object qname(String prefix, String name) {\n         return new QName(prefix, name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object sum(Object[] arguments) {\n         return new CoreOperationAdd(toExpressionArray(arguments));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object minus(Object left, Object right) {\n         return new CoreOperationSubtract(\n             (Expression) left,\n             (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object multiply(Object left, Object right) {\n         return new CoreOperationMultiply((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object divide(Object left, Object right) {\n         return new CoreOperationDivide((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object mod(Object left, Object right) {\n         return new CoreOperationMod((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object lessThan(Object left, Object right) {\n         return new CoreOperationLessThan((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object lessThanOrEqual(Object left, Object right) {\n         return new CoreOperationLessThanOrEqual(\n             (Expression) left,\n             (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object greaterThan(Object left, Object right) {\n         return new CoreOperationGreaterThan(\n             (Expression) left,\n             (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object greaterThanOrEqual(Object left, Object right) {\n         return new CoreOperationGreaterThanOrEqual(\n             (Expression) left,\n             (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object equal(Object left, Object right) {\n         return isNameAttributeTest((Expression) left)\n                 ? new NameAttributeTest((Expression) left, (Expression) right)\n                 : new CoreOperationEqual((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object notEqual(Object left, Object right) {\n         return new CoreOperationNotEqual((Expression) left, (Expression) right);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object minus(Object argument) {\n         return new CoreOperationNegate((Expression) argument);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object variableReference(Object qName) {\n         return new VariableReference((QName) qName);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object function(int code, Object[] args) {\n         return new CoreFunction(code, toExpressionArray(args));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object function(Object name, Object[] args) {\n         return new ExtensionFunction((QName) name, toExpressionArray(args));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object and(Object[] arguments) {\n         return new CoreOperationAnd(toExpressionArray(arguments));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object or(Object[] arguments) {\n         return new CoreOperationOr(toExpressionArray(arguments));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object union(Object[] arguments) {\n         return new CoreOperationUnion(toExpressionArray(arguments));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object locationPath(boolean absolute, Object[] steps) {\n         return new LocationPath(absolute, toStepArray(steps));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object expressionPath(Object expression, Object[] predicates,\n             Object[] steps) {\n         return new ExpressionPath(\n             toStepArray(steps));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object nodeNameTest(Object qname) {\n         return new NodeNameTest((QName) qname);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object nodeTypeTest(int nodeType) {\n         return new NodeTypeTest(nodeType);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object processingInstructionTest(String instruction) {\n         return new ProcessingInstructionTest(instruction);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object step(int axis, Object nodeTest, Object[] predicates) {\n         return new Step(\n             axis,\n         }\n         return true;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n         return varName;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return \"$\" + varName;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isContextDependent() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean computeContextDependent() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n     public Object computeValue(EvalContext context) {\n         return context.getRootContext().getVariableContext(varName);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java\n      * @return NodePointer\n      */\n     NodePointer getNodePointer();\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n      * @return Locale for this NodePointer\n      */\n     public Locale getLocale() {\n-        if (locale == null) {\n-            if (parent != null) {\n-                locale = parent.getLocale();\n-            }\n+        if (locale == null && parent != null) {\n+            locale = parent.getLocale();\n         }\n         return locale;\n     }\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String toString() {\n         return asPath();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareTo(Object object) {\n         if (object == this) {\n             return 0;\n             printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n \n     /**\n      * Create a NodePointer for the supplied child object.\n-     * <p>\n+     *\n      * @param parent parent node\n      * @param name String node name\n      * @param object child object\n         NodePointer parent,\n         QName name,\n         Object object);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n         actual = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isContainer() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         if (!actual) {\n             throw new JXPathException(\"Undefined variable: \" + name);\n         return variables.getVariable(name.toString());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n         return index == WHOLE_COLLECTION ? ValueUtils.getValue(value)\n                 : ValueUtils.getValue(value, index);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         if (!actual) {\n             throw new JXPathException(\"Cannot set undefined variable: \" + name);\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return actual;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setIndex(int index) {\n         super.setIndex(index);\n         valuePointer = null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = null;\n         return valuePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         if (actual) {\n             Object value = getBaseValue();\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (actual) {\n             setValue(value);\n         return ptr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         if (!actual) {\n             AbstractFactory factory = getAbstractFactory(context);\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n             JXPathContext context,\n             QName name,\n         return collection;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         if (actual) {\n             if (index == WHOLE_COLLECTION) {\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return (actual ? System.identityHashCode(variables) : 0)\n             + name.hashCode()\n             + index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n             && index == other.index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('$');\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer namespacePointer(String name) {\n         return getValuePointer().namespacePointer(name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n import org.apache.commons.jxpath.ri.QName;\n \n /**\n- * NodePointerFactory to create VariablePointers.\n+ * NodePointerFactory to create {@link VariablePointer VariablePointers}.\n  * @author Matt Benson\n  * @since JXPath 1.3\n  * @version $Revision$ $Date$\n         return new VariableContextWrapper(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(QName name, Object object,\n             Locale locale) {\n         if (object instanceof VariableContextWrapper) {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object object) {\n         return createNodePointer(name, object, null);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return VARIABLE_POINTER_FACTORY_ORDER;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n                 || name.getName().equals(\"*\"));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         return includeXmlLang && position == 1 ? new LangAttributePointer(parent) : super.getNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         if (includeXmlLang) {\n         }\n         return super.setPosition(position);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n /**\n  * A Pointer that points to a JavaBean or a collection. It is either\n  * the first element of a path or a pointer for a property value.\n- * Typically there is a BeanPropertyPointer between two BeanPointers\n+ * Typically there is a {@link BeanPropertyPointer} between two BeanPointers\n  * in the chain.\n  *\n  * @author Dmitri Plotnikov\n         this.beanInfo = beanInfo;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public PropertyPointer getPropertyPointer() {\n         return new BeanPropertyPointer(this, beanInfo);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return bean;\n     }\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null\n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         }\n         return \"/\";\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n     /** factory order constant */\n     public static final int BEAN_POINTER_FACTORY_ORDER = 900;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return BEAN_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         return new BeanPointer(name, bean, bi, locale);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object bean) {\n         if (bean == null) {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         return new BeanPointer(parent, name, bean, bi);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPropertyCount() {\n         if (beanInfo.isAtomic()) {\n             return 0;\n         return baseValue;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setIndex(int index) {\n         if (this.index != index) {\n             // When dealing with a scalar, index == 0 is equivalent to\n         return value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isActualProperty() {\n         return getPropertyDescriptor() != null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         PropertyDescriptor pd = getPropertyDescriptor();\n         if (pd == null) {\n         this.value = value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         if (getImmediateNode() == null) {\n             super.createPath(context);\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             setValue(null);\n         }\n         return propertyDescriptors;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionAttributeNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionAttributeNodeIterator.java\n         this.name = name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected NodeIterator getElementNodeIterator(NodePointer elementPointer) {\n         return elementPointer.attributeIterator(name);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionChildNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionChildNodeIterator.java\n         this.test = test;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected NodeIterator getElementNodeIterator(NodePointer elementPointer) {\n         return elementPointer.childIterator(test, false, null);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionNodeIterator.java\n     protected abstract NodeIterator\n             getElementNodeIterator(NodePointer elementPointer);\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (collection == null) {\n             prepare();\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             return null;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n         this.collection = collection;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return collection;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return ValueUtils.getLength(getBaseValue());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isContainer() {\n         return index != WHOLE_COLLECTION;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return index == WHOLE_COLLECTION ? ValueUtils.getValue(collection)\n                 : ValueUtils.getValue(collection, index);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         if (index == WHOLE_COLLECTION) {\n             parent.setValue(value);\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setIndex(int index) {\n         super.setIndex(index);\n         valuePointer = null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getValuePointer() {\n         if (valuePointer == null) {\n             if (index == WHOLE_COLLECTION) {\n         return valuePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         Object collection = getBaseValue();\n         if (ValueUtils.getLength(collection) <= index) {\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         NodePointer ptr = createPath(context);\n         ptr.setValue(value);\n         return ptr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return ptr.createPath(context, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return ptr.createPath(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return System.identityHashCode(collection) + index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return collection == other.collection && index == other.index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(NodeTest test,\n                 boolean reverse, NodePointer startWith) {\n         if (index == WHOLE_COLLECTION) {\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return index == WHOLE_COLLECTION ? new CollectionAttributeNodeIterator(this, name)\n                 : getValuePointer().attributeIterator(name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator namespaceIterator() {\n         return index == WHOLE_COLLECTION ? null : getValuePointer().namespaceIterator();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer namespacePointer(String namespace) {\n         return index == WHOLE_COLLECTION ? null : getValuePointer().namespacePointer(namespace);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest test) {\n         if (index == WHOLE_COLLECTION) {\n             if (test == null) {\n         return getValuePointer().testNode(test);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n                 NodePointer pointer1, NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         NodePointer parent = getImmediateParentPointer();\n         }\n         return buffer.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n     /** factory order constant */\n     public static final int COLLECTION_POINTER_FACTORY_ORDER = 10;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return COLLECTION_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(bean, locale) : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object bean) {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(parent, bean) : null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n         super(parent);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(\"xml\", \"lang\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return parent.getLocale().toString().replace('_', '-');\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return getBaseValue();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n+     * {@inheritDoc}\n+     *\n      * Throws UnsupportedOperationException.\n      * @param value Object\n      */\n                 \"Cannot change locale using the 'lang' attribute\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         return object instanceof LangAttributePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest test) {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         // Won't happen - lang attributes don't have children\n         return 0;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n         this.index = index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n         return new NullPropertyPointer(this);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getValuePointer() {\n         return new NullPointer(this, getName());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         throw new UnsupportedOperationException(\n             \"Collection element does not exist: \" + this);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isContainer() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         return parent.createChild(context, null, index);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         return parent.createChild(context, null, index, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return getImmediateParentPointer().hashCode() + index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n                 && index == other.index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         NodePointer parent = getImmediateParentPointer();\n \n         return buffer.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n         this.id = id;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public PropertyPointer getPropertyPointer() {\n         return new NullPropertyPointer(this);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (parent != null) {\n             return parent.createPath(context, value).getValuePointer();\n             \"Cannot create the root object: \" + asPath());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         if (parent != null) {\n             return parent.createPath(context).getValuePointer();\n             \"Cannot create the root object: \" + asPath());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return createPath(context).createChild(context, name, index);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return name == other.name || name != null && name.equals(other.name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         if (id != null) {\n             return \"id(\" + id + \")\";\n         return parent == null ? \"null()\" : super.asPath();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 0;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n         super(parent);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(propertyName);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setPropertyIndex(int index) {\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getValuePointer() {\n         return new NullPointer(this,  new QName(getPropertyName()));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected boolean isActualProperty() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isContainer() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         if (parent == null || parent.isContainer()) {\n             throw new JXPathInvalidAccessException(\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         NodePointer newParent = parent.createPath(context);\n         if (isAttribute()) {\n         return newParent.createChild(context, getName(), getIndex());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         NodePointer newParent = parent.createPath(context);\n         if (isAttribute()) {\n         return newParent.createChild(context, getName(), index, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(JXPathContext context, QName name, int index) {\n         return createPath(context).createChild(context, name, index);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(JXPathContext context, QName name,\n             int index, Object value) {\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getPropertyName() {\n         return propertyName;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setPropertyName(String propertyName) {\n         this.propertyName = propertyName;\n     }\n         byNameAttribute = true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return getIndex() != WHOLE_COLLECTION;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPropertyCount() {\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames() {\n         return new String[0];\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         if (!byNameAttribute) {\n             return super.asPath();\n                 + \" reported success creating object for path: \" + asPath()\n                 + \" but object was null.  Terminating to avoid stack recursion.\");\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * Iterates property values of an object pointed at with a PropertyOwnerPointer.\n+ * Iterates property values of an object pointed at with a {@link PropertyOwnerPointer}.\n  * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n  *\n  * @author Dmitri Plotnikov\n         targetReady = false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (name != null) {\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         return name == null ? setPositionAllProperties(position) : setPositionIndividualProperty(position);\n     }\n         }\n         return length;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n \n     private Object value = UNINITIALIZED;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(NodeTest test, boolean reverse,\n             NodePointer startWith) {\n         if (test == null) {\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return new BeanAttributeIterator(this, name);\n     }\n         super(parent);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setIndex(int index) {\n         if (this.index != index) {\n             super.setIndex(index);\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n             value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n         return value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public abstract QName getName();\n \n     /**\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(NodePointer pointer1,\n             NodePointer pointer2) {\n         int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n         return r == 0 ? pointer1.getIndex() - pointer2.getIndex() : r;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n         return bean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(null, getPropertyName());\n     }\n      */\n     protected abstract boolean isActualProperty();\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         if (!isActualProperty()) {\n             return false;\n \n     private Object value = UNINITIALIZED;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         if (value == UNINITIALIZED) {\n             value = index == WHOLE_COLLECTION ? ValueUtils.getValue(getBaseValue())\n         return value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n             getImmediateNode());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         if (getImmediateNode() == null) {\n             AbstractFactory factory = getAbstractFactory(context);\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         // If neccessary, expand collection\n         if (index != WHOLE_COLLECTION && index >= getLength()) {\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return prop.createPath(context, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n         return prop.createPath(context);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return getImmediateParentPointer().hashCode() + propertyIndex + index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return iThis == iOther;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n     }\n \n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n- * Transparent pointer to a Container. The getValue() method\n+ * Transparent pointer to a Container. The {@link #getValue()} method\n  * returns the contents of the container, rather than the container\n  * itself.\n  *\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return container;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         Object value = getBaseValue();\n         return value == null ? 1 : ValueUtils.getLength(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return getValuePointer().isLeaf();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION) {\n         return ValueUtils.getValue(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         // TODO: what if this is a collection?\n         container.setValue(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = getImmediateNode();\n         return valuePointer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return System.identityHashCode(container) + index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return container == other.container && index == other.index;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer namespacePointer(String namespace) {\n         return getValuePointer().namespacePointer(namespace);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI(String prefix) {\n         return getValuePointer().getNamespaceURI(prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         return parent == null ? \"/\" : parent.asPath();\n     }\n- }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n \n /**\n- * Implements NodePointerFactory for Container objects.\n+ * Implements NodePointerFactory for {@link Container} objects.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n     /** factory order for this factory */\n     public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return CONTAINER_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         return bean instanceof Container ? new ContainerPointer(\n                 (Container) bean, locale) : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object bean) {\n         return bean instanceof Container ? new ContainerPointer(parent,\n                 (Container) bean) : null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n         return element.getAttributeNode(name.getName());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n         this.attr = attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(\n             DOMNodePointer.getPrefix(attr),\n             DOMNodePointer.getLocalName(attr));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         String prefix = DOMNodePointer.getPrefix(attr);\n         return prefix == null ? null : parent.getNamespaceURI(prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         String value = attr.getValue();\n         if (value == null || (value.equals(\"\") && !attr.getSpecified())) {\n         return value;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest nodeTest) {\n         return nodeTest == null\n             || ((nodeTest instanceof NodeTypeTest)\n         attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         attr.getOwnerElement().removeAttributeNode(attr);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof DOMAttributePointer\n                 && attr == ((DOMAttributePointer) object).attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(NodePointer pointer1,\n             NodePointer pointer2) {\n         // Won't happen - attributes don't have children\n         return 0;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new NamespacePointer(parent, prefix, attr.getValue());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n         this.reverse = reverse;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             setPosition(1);\n         return child == null ? null : new DOMNodePointer(parent, child);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         while (this.position < position) {\n             if (!next()) {\n     private boolean testChild() {\n         return DOMNodePointer.testNode(child, nodeTest);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n         this.node = node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest test) {\n         return testNode(node, test);\n     }\n                     return false;\n             }\n         }\n-        if (test instanceof ProcessingInstructionTest) {\n-            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n-                String testPI = ((ProcessingInstructionTest) test).getTarget();\n-                String nodePI = ((ProcessingInstruction) node).getTarget();\n-                return testPI.equals(nodePI);\n-            }\n+        if (test instanceof ProcessingInstructionTest\n+                && node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n+            String testPI = ((ProcessingInstructionTest) test).getTarget();\n+            String nodePI = ((ProcessingInstruction) node).getTarget();\n+            return testPI.equals(nodePI);\n         }\n         return false;\n     }\n         return s1.equals(s2);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         String ln = null;\n         String ns = null;\n         return new QName(ns, ln);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         return getNamespaceURI(node);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(NodeTest test, boolean reverse,\n             NodePointer startWith) {\n         return new DOMNodeIterator(this, test, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return new DOMAttributeIterator(this, name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer namespacePointer(String prefix) {\n         return new NamespacePointer(this, prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator namespaceIterator() {\n         return new DOMNamespaceIterator(this);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized NamespaceResolver getNamespaceResolver() {\n         if (localNamespaceResolver == null) {\n             localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n         return localNamespaceResolver;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI(String prefix) {\n         if (prefix == null || prefix.equals(\"\")) {\n             return getDefaultNamespaceURI();\n         return namespace;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getDefaultNamespaceURI() {\n         if (defaultNamespace == null) {\n             Node aNode = node;\n         return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return !node.hasChildNodes();\n     }\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(JXPathContext context, QName name, int index) {\n         if (index == WHOLE_COLLECTION) {\n             index = 0;\n                         + \"/\" + name + \"[\" + (index + 1) + \"]\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(JXPathContext context, QName name,\n             int index, Object value) {\n         NodePointer ptr = createChild(context, name, index);\n         return ptr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n         if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         return it.getNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         Node parent = node.getParentNode();\n         if (parent == null) {\n         parent.removeChild(node);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n         return count;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return node.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof DOMNodePointer && node == ((DOMNodePointer) object).node;\n     }\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n                 : new DOMNodePointer(element, getLocale(), id);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(NodePointer pointer1,\n             NodePointer pointer2) {\n         Node node1 = (Node) pointer1.getBaseValue();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n     /** factory order */\n     public static final int DOM_POINTER_FACTORY_ORDER = 100;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return DOM_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n         return bean instanceof Node ? new DOMNodePointer((Node) bean, locale) : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n         Object bean) {\n         return bean instanceof Node ? new DOMNodePointer(parent, (Node) bean) : null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n         this.namespaceURI = namespaceURI;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         return namespaceURI;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n         throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest nodeTest) {\n         return nodeTest == null\n             || ((nodeTest instanceof NodeTypeTest)\n                     == Compiler.NODE_TYPE_NODE);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return prefix.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return prefix.equals(other.prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         // Won't happen - namespaces don't have children\n         return 0;\n     }\n- }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n \n \n /**\n- * A Pointer that points to a DynaBean.\n+ * A Pointer that points to a {@link DynaBean}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         this.dynaBean = dynaBean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public PropertyPointer getPropertyPointer() {\n         return new DynaBeanPropertyPointer(this, dynaBean);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return dynaBean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return dynaBean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return iThis == iOther && dynaBean == other.dynaBean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         return parent == null ? \"/\" : super.asPath();\n     }\n     private static boolean equalObjects(Object o1, Object o2) {\n         return o1 == o2 || o1 != null && o1.equals(o2);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n     /** factory order constant */\n     public static final int DYNA_BEAN_POINTER_FACTORY_ORDER = 700;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return DYNA_BEAN_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         return bean instanceof DynaBean ? new DynaBeanPointer(name, (DynaBean) bean, locale) : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object bean) {\n         return bean instanceof DynaBean ? new DynaBeanPointer(parent, name, (DynaBean) bean) : null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n- * Pointer pointing to a property of a DynaBean.\n+ * Pointer pointing to a property of a {@link DynaBean}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         this.dynaBean = dynaBean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return dynaBean.get(getPropertyName());\n     }\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPropertyCount() {\n         return getPropertyNames().length;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames() {\n         /* @todo do something about the sorting - LIKE WHAT? - MJB */\n         if (names == null) {\n         setValue(index, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             dynaBean.set(getPropertyName(), null);\n                             + type, ex);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n         super(parent, name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected void prepareForIndividualProperty(String name) {\n          ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);\n          super.prepareForIndividualProperty(name);\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n /**\n  * A Pointer that points to an object with Dynamic Properties. It is used for\n  * the first element of a path; following elements will by of type\n- * PropertyPointer.\n+ * {@link PropertyPointer}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n         this.handler = handler;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public PropertyPointer getPropertyPointer() {\n         return new DynamicPropertyPointer(this, handler);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator createNodeIterator(\n                 String property, boolean reverse, NodePointer startWith) {\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return new DynamicAttributeIterator(this, name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return name;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isDynamicPropertyDeclarationSupported() {\n         return true;\n     }\n         return bean;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         Object value = getNode();\n         return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         return parent == null ? \"/\" : super.asPath();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return System.identityHashCode(bean) + name.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         DynamicPointer other = (DynamicPointer) object;\n         return bean == other.bean && name.equals(other.name);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n      */\n     public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return DYNAMIC_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n         QName name,\n         Object bean,\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n         NodePointer parent,\n         QName name,\n         }\n         return null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context) {\n         // Ignore the name passed to us, use our own data\n         Object collection = getBaseValue();\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (index == WHOLE_COLLECTION) {\n             handler.setProperty(getBean(), getPropertyName(), value);\n         return this;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             removeKey();\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getImmediateParentPointer().asPath());\n         return buffer.toString();\n     }\n \n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n             (Attribute) attributes.get(index));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (attributes == null) {\n             return false;\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n         this.attr = attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(\n             JDOMNodePointer.getPrefix(attr),\n             JDOMNodePointer.getLocalName(attr));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         String uri = attr.getNamespaceURI();\n         if (uri != null && uri.equals(\"\")) {\n         return uri;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         return attr.getValue();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isActual() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         attr.getParent().removeAttribute(attr);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof JDOMAttributePointer\n                 && ((JDOMAttributePointer) object).attr == attr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n             NodePointer pointer1,\n             NodePointer pointer2) {\n         // Won't happen - attributes don't have children\n         return 0;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         if (namespaces == null) {\n             return false;\n         this.position = position;\n         return position >= 1 && position <= namespaces.size();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n         this.namespaceURI = namespaceURI;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         return new QName(prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         return namespaceURI;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         return true;\n     }\n         throw new UnsupportedOperationException(\"Cannot modify a namespace\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null) {\n         return buffer.toString();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return prefix.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         return object == this || object instanceof JDOMNamespacePointer && prefix.equals(((JDOMNamespacePointer) object).prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         // Won't happen - namespaces don't have children\n         return 0;\n     }\n- }\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n         this.reverse = reverse;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer getNodePointer() {\n         if (child == null) {\n             if (!setPosition(1)) {\n         return new JDOMNodePointer(parent, child);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getPosition() {\n         return position;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean setPosition(int position) {\n         while (this.position < position) {\n             if (!next()) {\n     private boolean testChild() {\n         return JDOMNodePointer.testNode(parent, child, nodeTest);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n         this.node = node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator childIterator(\n         NodeTest test,\n         boolean reverse,\n         return new JDOMNodeIterator(this, test, reverse, startWith);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator attributeIterator(QName name) {\n         return new JDOMAttributeIterator(this, name);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodeIterator namespaceIterator() {\n         return new JDOMNamespaceIterator(this);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer namespacePointer(String prefix) {\n         return new JDOMNamespacePointer(this, prefix);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI() {\n         return getNamespaceURI(node);\n     }\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized NamespaceResolver getNamespaceResolver() {\n         if (localNamespaceResolver == null) {\n             localNamespaceResolver = new NamespaceResolver(super.getNamespaceResolver());\n         return localNamespaceResolver;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String getNamespaceURI(String prefix) {\n         if (prefix.equals(\"xml\")) {\n             return Namespace.XML_NAMESPACE.getURI();\n         return ns == null ? null : ns.getURI();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compareChildNodePointers(\n         NodePointer pointer1,\n         NodePointer pointer2) {\n         return 0;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getBaseValue() {\n         return node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isCollection() {\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getLength() {\n         return 1;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isLeaf() {\n         if (node instanceof Element) {\n             return ((Element) node).getContent().size() == 0;\n         return true;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public QName getName() {\n         String ns = null;\n         String ln = null;\n         return new QName(ns, ln);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getImmediateNode() {\n         return node;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getValue() {\n         if (node instanceof Element) {\n             StringBuffer buf = new StringBuffer();\n         return result != null && trim ? result.trim() : result;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setValue(Object value) {\n         if (node instanceof Text) {\n             String string = (String) TypeUtils.convert(value, String.class);\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean testNode(NodeTest test) {\n         return testNode(this, node, test);\n     }\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n         JXPathContext context,\n         QName name,\n                 + (index + 1) + \"]\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createChild(\n             JXPathContext context, QName name, int index, Object value) {\n         NodePointer ptr = createChild(context, name, index);\n         return ptr;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n         if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         return it.getNodePointer();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void remove() {\n         Element parent = nodeParent(node);\n         if (parent == null) {\n         parent.getContent().remove(node);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String asPath() {\n         if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n         return count;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return node.hashCode();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         return node == other.node;\n     }\n \n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n     /** factory order constant */\n     public static final int JDOM_POINTER_FACTORY_ORDER = 110;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int getOrder() {\n         return JDOM_POINTER_FACTORY_ORDER;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n             QName name, Object bean, Locale locale) {\n         if (bean instanceof Document) {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public NodePointer createNodePointer(\n             NodePointer parent, QName name, Object bean) {\n         if (bean instanceof Document) {\n         }\n         return null;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/servlet/Constants.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/Constants.java\n public final class Constants {\n \n     /**\n-     * Variable name for ServletContext.\n+     * Variable name for {@link javax.servlet.ServletContext}.\n      */\n     public static final String APPLICATION_SCOPE = \"application\";\n \n     /**\n-     * Variable name for HttpSession.\n+     * Variable name for {@link javax.servlet.http.HttpSession}.\n      */\n     public static final String SESSION_SCOPE = \"session\";\n \n     /**\n-     * Variable name for ServletRequest.\n+     * Variable name for {@link javax.servlet.ServletRequest}.\n      */\n     public static final String REQUEST_SCOPE = \"request\";\n \n     /**\n-     * Variable name for PageContext.\n+     * Variable name for {@link javax.servlet.jsp.PageContext}.\n      */\n     public static final String PAGE_SCOPE = \"page\";\n \n     /**\n      * Attribute  name used in page context, requst, session, and servlet\n-     * context to store the corresponding JXPathContext.\n+     * context to store the corresponding {@link org.apache.commons.jxpath.JXPathContext}.\n      */\n     public static final String JXPATH_CONTEXT =\n         \"org.apache.commons.jxpath.JXPATH_CONTEXT\";\n--- a/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n \n import java.util.Enumeration;\n import java.util.HashSet;\n-\n import javax.servlet.http.HttpSession;\n \n import org.apache.commons.jxpath.JXPathException;\n \n /**\n- * Implementation of the DynamicPropertyHandler interface that provides\n- * access to attributes of a HttpSession.\n+ * Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}\n+ * interface that provides access to attributes of a @{link HttpSession}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class HttpSessionHandler extends ServletContextHandler {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getProperty(Object bean, String property) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n         return super.getProperty(handle.getServletContext(), property);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object bean, String property, Object value) {\n         HttpSessionAndServletContext handle =\n             (HttpSessionAndServletContext) bean;\n--- a/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n import org.apache.commons.jxpath.JXPathIntrospector;\n \n /**\n- * Static methods that allocate and cache JXPathContexts bound to PageContext,\n- * ServletRequest, HttpSession and ServletContext.\n- * <p>\n- * The JXPathContext returned by {@link #getPageContext getPageContext()}\n+ * Static methods that allocate and cache JXPathContexts bound to\n+ * {@link PageContext}, {@link ServletRequest}, {@link HttpSession}\n+ * and {@link ServletContext}.\n+ * <p>\n+ * The {@link JXPathContext} returned by {@link #getPageContext getPageContext()}\n  * provides access to all scopes via the PageContext.findAttribute()\n  * method.  Thus, an expression like \"foo\" will first look for the attribute\n  * named \"foo\" in the \"page\" context, then the \"request\" context, then\n--- a/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n         this.object = object;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isDeclaredVariable(String variable) {\n         return variable.equals(keyword);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getVariable(String variable) {\n         return isDeclaredVariable(variable) ? object : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void declareVariable(String variable, Object value) {\n         throw new UnsupportedOperationException(\n             \"Cannot declare new keyword variables.\");\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void undeclareVariable(String variable) {\n         throw new UnsupportedOperationException(\n             \"Cannot undeclare keyword variables.\");\n--- a/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n import org.apache.commons.jxpath.DynamicPropertyHandler;\n \n /**\n- * Implementation of the DynamicPropertyHandler interface that provides\n- * access to attributes of a PageContext in all scopes.\n+ * Implementation of the {@link DynamicPropertyHandler} interface that provides\n+ * access to attributes of a {@link PageContext} in all scopes.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class PageContextHandler implements DynamicPropertyHandler {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames(Object pageContext) {\n         HashSet list = new HashSet();\n         Enumeration e =\n         return ((PageContext) pageContext).findAttribute(property);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object pageContext, String property, Object value) {\n         ((PageContext) pageContext).setAttribute(\n             property,\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n import javax.servlet.jsp.PageContext;\n \n /**\n- * A lightweight wrapper for PageContext that restricts access\n+ * A lightweight wrapper for {@link PageContext} that restricts access\n  * to attributes of the \"page\" scope.  This object is needed so that\n  * XPath \"foo\" would lookup the attribute \"foo\" in all scopes, while\n  * \"$page/foo\" would only look in the \"page\" scope.\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n import org.apache.commons.jxpath.DynamicPropertyHandler;\n \n /**\n- * Implementation of the DynamicPropertyHandler interface that provides\n- * access to attributes of a PageScopeContext.\n+ * Implementation of the {@link DynamicPropertyHandler} interface that provides\n+ * access to attributes of a {@link PageScopeContext}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n \n     private static final int DEFAULT_LIST_SIZE = 16;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames(Object pageScope) {\n         Enumeration e = ((PageScopeContext) pageScope).getAttributeNames();\n         ArrayList list = new ArrayList(DEFAULT_LIST_SIZE);\n         return (String[]) list.toArray(new String[list.size()]);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getProperty(Object pageScope, String property) {\n         return ((PageScopeContext) pageScope).getAttribute(property);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object pageScope, String property, Object value) {\n         ((PageScopeContext) pageScope).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n import org.apache.commons.jxpath.DynamicPropertyHandler;\n \n /**\n- * Implementation of the DynamicPropertyHandler interface that provides\n- * access to attributes of a ServletContext.\n+ * Implementation of the {@link DynamicPropertyHandler} interface that provides\n+ * access to attributes of a {@link ServletContext}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n \n     private static final int DEFAULT_PROPERTY_COUNT = 16;\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public String[] getPropertyNames(Object context) {\n         HashSet list = new HashSet(DEFAULT_PROPERTY_COUNT);\n         collectPropertyNames(list, context);\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getProperty(Object context, String property) {\n         return ((ServletContext) context).getAttribute(property);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object context, String property, Object value) {\n         ((ServletContext) context).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestAndContext.java\n import javax.servlet.http.HttpSession;\n \n /**\n- * Just a structure to hold a ServletRequest and ServletContext together.\n+ * Just a structure to hold a {@link ServletRequest} and {@link ServletContext}\n+ * together.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n \n     /**\n      * Create a new ServletRequestAndContext.\n+     *\n      * @param request ServletRequest\n      * @param context ServletContext\n      */\n         this.request = request;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public HttpSession getSession() {\n         return request instanceof HttpServletRequest\n                 ? ((HttpServletRequest) request).getSession(false) : null;\n \n     /**\n      * Get the request.\n+     *\n      * @return ServletRequest\n      */\n     public ServletRequest getServletRequest() {\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n  */\n package org.apache.commons.jxpath.servlet;\n \n+import java.util.Arrays;\n import java.util.Enumeration;\n import java.util.HashSet;\n-\n import javax.servlet.ServletRequest;\n \n /**\n- * Implementation of the DynamicPropertyHandler interface that provides\n- * access to attributes and parameters of a ServletRequest.\n+ * Implementation of the {@link org.apache.commons.jxpath.DynamicPropertyHandler}\n+ * interface that provides access to attributes and parameters\n+ * of a {@link ServletRequest}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n public class ServletRequestHandler extends HttpSessionHandler {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         super.collectPropertyNames(set, bean);\n         ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object getProperty(Object bean, String property) {\n         ServletRequestAndContext handle = (ServletRequestAndContext) bean;\n         ServletRequest servletRequest = handle.getServletRequest();\n         String[] strings = servletRequest.getParameterValues(property);\n+\n         if (strings != null) {\n             if (strings.length == 0) {\n                 return null;\n         return super.getProperty(bean, property);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void setProperty(Object request, String property, Object value) {\n         ((ServletRequest) request).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n            this.values = values;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public List getValues() {\n             return Collections.unmodifiableList(values);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public List getNodes() {\n             return Collections.unmodifiableList(values);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public List getPointers() {\n             if (pointers == null) {\n                 pointers = new ArrayList();\n             this.bean = object;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object getValue() {\n             return bean;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object getNode() {\n             return bean;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object getRootNode() {\n             return bean;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public void setValue(Object value) {\n             throw new UnsupportedOperationException();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Object clone() {\n             return this;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public int compareTo(Object object) {\n             return 0;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public String asPath() {\n             if (bean == null) {\n                 return \"null()\";\n             return \"{object of type \" + bean.getClass().getName() + \"}\";\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/util/JXPath11CompatibleTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/JXPath11CompatibleTypeConverter.java\n import org.apache.commons.jxpath.NodeSet;\n \n /**\n- * TypeConverter implementation to circumvent automagic NodeSet decoding. Suggested by JIRA issue JXPATH-10.\n+ * TypeConverter implementation to circumvent automagic {@link NodeSet}\n+ * decoding. Suggested by JIRA issue JXPATH-10.\n  *\n  * @since JXPath 1.3\n  * @author Matt Benson\n  * @version $Revision$ $Date$\n  */\n public class JXPath11CompatibleTypeConverter extends BasicTypeConverter {\n-    /**\n-     * {@inheritDoc}\n-     */\n+\n     public boolean canConvert(Object object, Class toType) {\n         return object instanceof NodeSet ? toType.isInstance(object) : super.canConvert(object, toType);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object convert(Object object, Class toType) {\n         return object instanceof NodeSet && toType.isInstance(object) ? object : super.convert(object, toType);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/KeyManagerUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/KeyManagerUtils.java\n \n /**\n  * Utility class.\n+ *\n  * @author Matt Benson\n  * @since JXPath 1.3\n  * @version $Revision$ $Date$\n             this.delegate = delegate;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public NodeSet getNodeSetByKey(JXPathContext context, String key,\n                 Object value) {\n             Pointer pointer = delegate.getPointerByKey(context, key, InfoSetUtil.stringValue(value));\n             return result;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Pointer getPointerByKey(JXPathContext context, String keyName,\n                 String keyValue) {\n             return delegate.getPointerByKey(context, keyName, keyValue);\n--- a/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n \n         return NO_MATCH;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n+++ b/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n     private ReverseComparator() {\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int compare(Object o1, Object o2) {\n         return ((Comparable) o2).compareTo(o1);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/TypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeConverter.java\n package org.apache.commons.jxpath.util;\n \n /**\n- * A type converter can be installed on TypeUtils to introduce\n+ * A type converter can be installed on {@link TypeUtils} to introduce\n  * additional type conversions for JXPath. Most of\n- * the time BasicTypeConverter should be used as the superclass.\n+ * the time {@link BasicTypeConverter} should be used as the superclass.\n  *\n  * @see TypeUtils#setTypeConverter\n  *\n      * @return resulting Object\n      */\n     Object convert(Object object, Class toType);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n     public static Class wrapPrimitive(Class p) {\n         return p.isPrimitive() ? (Class) PRIMITIVE_TYPE_MAP.get(p) : p;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n         // Return whatever we have found\n         return (method);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n  */\n public class DOMParser extends XMLParser2 {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object parseXML(InputStream stream) {\n         try {\n             DocumentBuilderFactory factory =\n             throw new JXPathException(\"DOM parser error\", ex);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n         }\n         return parser;\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n  */\n public class JDOMParser extends XMLParser2 {\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Object parseXML(InputStream stream) {\n         if (!isNamespaceAware()) {\n             throw new JXPathException(\"JDOM parser configuration error. JDOM \"\n             throw new JXPathException(\"JDOM parser error\", ex);\n         }\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/XMLParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/XMLParser.java\n      * @return Object\n      */\n     Object parseXML(InputStream stream);\n-}\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n+++ b/src/java/org/apache/commons/jxpath/xml/XMLParser2.java\n \n /**\n  * The abstract superclass of XML parsers that produce DOM Documents.\n- * The features have the same defaults as DocumentBuilderFactory.\n+ * The features have the same defaults as {@link javax.xml.parsers.DocumentBuilderFactory}.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n     /**\n      * Set whether the underlying parser should be validating.\n      * @param validating flag\n-     * @see DocumentBuilderFactory#setValidating(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setValidating(boolean)\n      */\n     public void setValidating(boolean validating) {\n         this.validating = validating;\n     /**\n      * Learn whether the underlying parser is validating.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isValidating()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isValidating()\n      */\n     public boolean isValidating() {\n         return validating;\n     /**\n      * Learn whether the underlying parser is ns-aware.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isNamespaceAware()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isNamespaceAware()\n      */\n     public boolean isNamespaceAware() {\n         return namespaceAware;\n     /**\n      * Set whether the underlying parser is ns-aware.\n      * @param namespaceAware flag\n-     * @see DocumentBuilderFactory#setNamespaceAware(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setNamespaceAware(boolean)\n      */\n     public void setNamespaceAware(boolean namespaceAware) {\n         this.namespaceAware = namespaceAware;\n     /**\n      * Set whether the underlying parser is ignoring whitespace.\n      * @param whitespace flag\n-     * @see DocumentBuilderFactory#setIgnoringElementContentWhitespace(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setIgnoringElementContentWhitespace(boolean)\n      */\n     public void setIgnoringElementContentWhitespace(boolean whitespace) {\n         this.whitespace = whitespace;\n     /**\n      * Learn whether the underlying parser is ignoring whitespace.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isIgnoringElementContentWhitespace()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isIgnoringElementContentWhitespace()\n      */\n     public boolean isIgnoringElementContentWhitespace() {\n         return whitespace;\n     /**\n      * Learn whether the underlying parser expands entity references.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isExpandEntityReferences()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isExpandEntityReferences()\n      */\n     public boolean isExpandEntityReferences() {\n         return expandEntityRef;\n     /**\n      * Set whether the underlying parser expands entity references.\n      * @param expandEntityRef flag\n-     * @see DocumentBuilderFactory#setExpandEntityReferences(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setExpandEntityReferences(boolean)\n      */\n     public void setExpandEntityReferences(boolean expandEntityRef) {\n         this.expandEntityRef = expandEntityRef;\n     /**\n      * Learn whether the underlying parser ignores comments.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isIgnoringComments()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isIgnoringComments()\n      */\n     public boolean isIgnoringComments() {\n         return ignoreComments;\n     /**\n      * Set whether the underlying parser ignores comments.\n      * @param ignoreComments flag\n-     * @see DocumentBuilderFactory#setIgnoringComments(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setIgnoringComments(boolean)\n      */\n     public void setIgnoringComments(boolean ignoreComments) {\n         this.ignoreComments = ignoreComments;\n     /**\n      * Learn whether the underlying parser is coalescing.\n      * @return boolean\n-     * @see DocumentBuilderFactory#isCoalescing()\n+     * @see javax.xml.parsers.DocumentBuilderFactory#isCoalescing()\n      */\n     public boolean isCoalescing() {\n         return coalescing;\n     /**\n      * Set whether the underlying parser is coalescing.\n      * @param coalescing flag\n-     * @see DocumentBuilderFactory#setCoalescing(boolean)\n+     * @see javax.xml.parsers.DocumentBuilderFactory#setCoalescing(boolean)\n      */\n     public void setCoalescing(boolean coalescing) {\n         this.coalescing = coalescing;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public abstract Object parseXML(InputStream stream);\n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/BasicNodeSetTest.java\n+++ b/src/test/org/apache/commons/jxpath/BasicNodeSetTest.java\n     /** BasicNodeSet */\n     protected BasicNodeSet nodeSet;\n \n-    /**\n-     * Create a new BasicNodeSetTest.\n-     * \n-     * @param name testcase name\n-     */\n-    public BasicNodeSetTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n     protected void setUp() throws Exception {\n         super.setUp();\n         context = JXPathContext.newContext(new TestMixedModelBean());\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public abstract class JXPathTestCase extends TestCase {\n+\n     /**\n      * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n      */\n-    public JXPathTestCase(String name) {\n-        super(name);\n+    public JXPathTestCase() {\n         Locale.setDefault(Locale.US);\n     }\n     \n--- a/src/test/org/apache/commons/jxpath/ri/JXPathCompiledExpressionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/JXPathCompiledExpressionTest.java\n  */\n \n public class JXPathCompiledExpressionTest extends JXPathTestCase {\n-    \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public JXPathCompiledExpressionTest(String name) {\n-        super(name);\n-    }\n \n     public void testConstant() {\n         assertXPathExpression(\"1\", Constant.class);\n     }\n     \n     public void testCoreOperationAnd() {\n-        assertXPathExpression(\n-            \"2 and 4\",\n-            CoreOperationAnd.class);\n-\n-        assertXPathExpression(\n-            \"2 > 1 and 4 < 5\",\n-            CoreOperationAnd.class);            \n+        assertXPathExpression(\"2 and 4\", CoreOperationAnd.class);\n+        assertXPathExpression(\"2 > 1 and 4 < 5\", CoreOperationAnd.class);\n     }\n         \n     public void testCoreOperationOr() {\n-        assertXPathExpression(\n-            \"2 or 4\",\n-            CoreOperationOr.class);\n-\n-        assertXPathExpression(\n-            \"2 > 1 or 4 < 5\",\n-            CoreOperationOr.class);\n-\n-        assertXPathExpression(\n-            \"1 > 1 and 2 <= 2 or 3 = 4\",\n-            CoreOperationOr.class);\n+        assertXPathExpression(\"2 or 4\", CoreOperationOr.class);\n+        assertXPathExpression(\"2 > 1 or 4 < 5\", CoreOperationOr.class);\n+        assertXPathExpression(\"1 > 1 and 2 <= 2 or 3 = 4\", CoreOperationOr.class);\n     }\n \n     public void testCoreOperationEqual() {\n-        assertXPathExpression(\n-            \"2 = 4\",\n-            CoreOperationEqual.class);\n-\n-        assertXPathExpression(\n-            \"2 + 1 = 3\",\n-            CoreOperationEqual.class);\n+        assertXPathExpression(\"2 = 4\", CoreOperationEqual.class);\n+        assertXPathExpression(\"2 + 1 = 3\", CoreOperationEqual.class);\n     }\n     \n     public void testCoreOperationNameAttributeTest() {\n-        assertXPathExpression(\n-            \"@name = 'bar'\",\n-            NameAttributeTest.class);\n+        assertXPathExpression(\"@name = 'bar'\", NameAttributeTest.class);\n     }\n \n     public void testCoreOperationNotEqual() {\n-        assertXPathExpression(\n-            \"2 != 4\",\n-            CoreOperationNotEqual.class);\n-\n-        assertXPathExpression(\n-            \"2 + 1 != 3\",\n-            CoreOperationNotEqual.class);\n+        assertXPathExpression(\"2 != 4\", CoreOperationNotEqual.class);\n+        assertXPathExpression(\"2 + 1 != 3\", CoreOperationNotEqual.class);\n     }\n \n     public void testCoreOperationLessThan() {\n-        assertXPathExpression(\n-            \"3<4\",\n-            CoreOperationLessThan.class,\n-            \"3 < 4\");\n-\n-        assertXPathExpression(\n-            \"3<(2>=1)\",\n-            CoreOperationLessThan.class,\n-            \"3 < (2 >= 1)\");\n+        assertXPathExpression(\"3<4\", CoreOperationLessThan.class, \"3 < 4\");\n+        assertXPathExpression(\"3<(2>=1)\", CoreOperationLessThan.class, \"3 < (2 >= 1)\");\n     }\n     \n     public void testCoreOperationLessThanOrEqual() {\n-        assertXPathExpression(\n-            \"3<=4\",\n-            CoreOperationLessThanOrEqual.class,\n-            \"3 <= 4\");\n-\n-        assertXPathExpression(\n-            \"3<=(2>=1)\",\n-            CoreOperationLessThanOrEqual.class,\n-            \"3 <= (2 >= 1)\");\n+        assertXPathExpression(\"3<=4\", CoreOperationLessThanOrEqual.class, \"3 <= 4\");\n+        assertXPathExpression(\"3<=(2>=1)\", CoreOperationLessThanOrEqual.class, \"3 <= (2 >= 1)\");\n     }\n \n     public void testCoreOperationGreaterThan() {\n-        assertXPathExpression(\n-            \"3>4\",\n-            CoreOperationGreaterThan.class,\n-            \"3 > 4\");\n-\n-        assertXPathExpression(\n-            \"3>(2>=1)\",\n-            CoreOperationGreaterThan.class,\n-            \"3 > (2 >= 1)\");\n-\n-        assertXPathExpression(\n-            \"1 > (1 and 2 <= (2 or 3) = 4)\",\n-            CoreOperationGreaterThan.class);\n+        assertXPathExpression(\"3>4\", CoreOperationGreaterThan.class, \"3 > 4\");\n+        assertXPathExpression(\"3>(2>=1)\", CoreOperationGreaterThan.class, \"3 > (2 >= 1)\");\n+        assertXPathExpression(\"1 > (1 and 2 <= (2 or 3) = 4)\", CoreOperationGreaterThan.class);\n     }\n     \n     public void testCoreOperationGreaterThanOrEqual() {\n-        assertXPathExpression(\n-            \"3>=4\",\n-            CoreOperationGreaterThanOrEqual.class,\n-            \"3 >= 4\");\n-\n-        assertXPathExpression(\n-            \"3>=(2>=1)\",\n-            CoreOperationGreaterThanOrEqual.class,\n-            \"3 >= (2 >= 1)\");\n+        assertXPathExpression(\"3>=4\", CoreOperationGreaterThanOrEqual.class, \"3 >= 4\");\n+        assertXPathExpression(\"3>=(2>=1)\", CoreOperationGreaterThanOrEqual.class, \"3 >= (2 >= 1)\");\n     }\n \n     public void testCoreOperationDivide() {\n-        assertXPathExpression(\n-            \"2 div 4\",\n-            CoreOperationDivide.class);\n-\n-        assertXPathExpression(\n-            \"2|3 div -3\",\n-            CoreOperationDivide.class,\n-            \"2 | 3 div -3\");\n+        assertXPathExpression(\"2 div 4\", CoreOperationDivide.class);\n+        assertXPathExpression(\"2|3 div -3\", CoreOperationDivide.class, \"2 | 3 div -3\");\n     }\n \n     public void testCoreOperationMod() {\n-        assertXPathExpression(\n-            \"2 mod 4\",\n-            CoreOperationMod.class);\n-\n-        assertXPathExpression(\n-            \"2|3 mod -3\",\n-            CoreOperationMod.class,\n-            \"2 | 3 mod -3\");\n+        assertXPathExpression(\"2 mod 4\", CoreOperationMod.class);\n+        assertXPathExpression(\"2|3 mod -3\", CoreOperationMod.class, \"2 | 3 mod -3\");\n     }\n \n     public void testCoreOperationMultiply() {\n-        assertXPathExpression(\n-            \"2*4\",\n-            CoreOperationMultiply.class,\n-            \"2 * 4\");\n-            \n-        assertXPathExpression(\n-            \"2*(3 + 1)\",\n-            CoreOperationMultiply.class,\n-            \"2 * (3 + 1)\");\n+        assertXPathExpression(\"2*4\", CoreOperationMultiply.class, \"2 * 4\");\n+        assertXPathExpression(\"2*(3 + 1)\", CoreOperationMultiply.class, \"2 * (3 + 1)\");\n     }\n     \n     public void testCoreOperationMinus() {\n-        assertXPathExpression(\n-            \"1 - 1\",\n-            CoreOperationSubtract.class);\n-            \n-        assertXPathExpression(\n-            \"1 - 1 - 2\",\n-            CoreOperationSubtract.class);\n-            \n-        assertXPathExpression(\n-            \"1 - (1 - 2)\",\n-            CoreOperationSubtract.class);\n+        assertXPathExpression(\"1 - 1\", CoreOperationSubtract.class);\n+        assertXPathExpression(\"1 - 1 - 2\", CoreOperationSubtract.class);\n+        assertXPathExpression(\"1 - (1 - 2)\", CoreOperationSubtract.class);\n     }\n     \n     public void testCoreOperationSum() {\n-        assertXPathExpression(\n-            \"3 + 1 + 4\", \n-            CoreOperationAdd.class);\n-            \n-        assertXPathExpression(\n-            \"(3 + 1) + 4\",\n-            CoreOperationAdd.class,\n-            \"3 + 1 + 4\");\n-            \n-        assertXPathExpression(\n-            \"3 + (1 + 4)\",\n-            CoreOperationAdd.class,\n-            \"3 + 1 + 4\");\n-            \n-        assertXPathExpression(\n-            \"3 + -1\", \n-            CoreOperationAdd.class, \n-            \"3 + -1\");\n-            \n-        assertXPathExpression(\n-            \"2*-3 + -1\",\n-            CoreOperationAdd.class,\n-            \"2 * -3 + -1\");\n+        assertXPathExpression(\"3 + 1 + 4\", CoreOperationAdd.class);\n+        assertXPathExpression(\"(3 + 1) + 4\", CoreOperationAdd.class, \"3 + 1 + 4\");\n+        assertXPathExpression(\"3 + (1 + 4)\", CoreOperationAdd.class, \"3 + 1 + 4\");\n+        assertXPathExpression(\"3 + -1\", CoreOperationAdd.class, \"3 + -1\");\n+        assertXPathExpression(\"2*-3 + -1\", CoreOperationAdd.class, \"2 * -3 + -1\");\n     }\n     \n     public void testCoreOperationUnaryMinus() {\n     }\n \n     public void testCoreOperationUnion() {\n-        assertXPathExpression(\n-            \"3 | 1 | 4\",\n-            CoreOperationUnion.class);\n+        assertXPathExpression(\"3 | 1 | 4\", CoreOperationUnion.class);\n     }\n     \n     public void testExpressionPath() {\n-        assertXPathExpression(\n-            \"$x/foo/bar\",\n-            ExpressionPath.class);        \n-        assertXPathExpression(\n-            \"(2 + 2)/foo/bar\",\n-            ExpressionPath.class);        \n-        assertXPathExpression(\n-            \"$x[3][2 + 2]/foo/bar\",\n-            ExpressionPath.class);        \n+        assertXPathExpression(\"$x/foo/bar\", ExpressionPath.class);\n+        assertXPathExpression(\"(2 + 2)/foo/bar\", ExpressionPath.class);\n+        assertXPathExpression(\"$x[3][2 + 2]/foo/bar\", ExpressionPath.class);\n     }\n     \n     public void testExtensionFunction() {\n-        assertXPathExpression(\n-            \"my:function(3, other.function())\",\n-            ExtensionFunction.class);        \n+        assertXPathExpression(\"my:function(3, other.function())\", ExtensionFunction.class);\n     }\n  \n     public void testLocationPathAxisSelf() {\n-        assertXPathExpression(\n-            \"self::foo:bar\",\n-            LocationPath.class);\n-                 \n-        assertXPathExpression(\n-            \".\",\n-            LocationPath.class);     \n+        assertXPathExpression(\"self::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\".\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisChild() {\n-        assertXPathExpression(\n-            \"child::foo:bar\",\n-            LocationPath.class,\n-            \"foo:bar\");\n-                 \n-        assertXPathExpression(\n-            \"foo:bar\",\n-            LocationPath.class);\n-                 \n-        assertXPathExpression(\n-            \"/foo:bar\",\n-            LocationPath.class);\n-                 \n-        assertXPathExpression(\n-            \"/foo/bar\",\n-            LocationPath.class);     \n-\n-        assertXPathExpression(\n-            \"*\",\n-            LocationPath.class);\n-                 \n-        assertXPathExpression(\n-            \"foo:*\",\n-            LocationPath.class);\n-                 \n+        assertXPathExpression(\"child::foo:bar\", LocationPath.class, \"foo:bar\");\n+        assertXPathExpression(\"foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"/foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"/foo/bar\", LocationPath.class);\n+        assertXPathExpression(\"*\", LocationPath.class);\n+        assertXPathExpression(\"foo:*\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisParent() {\n-        assertXPathExpression(\n-            \"parent::foo:bar\",\n-            LocationPath.class);\n-                 \n-        assertXPathExpression(\n-            \"..\",\n-            LocationPath.class);     \n+        assertXPathExpression(\"parent::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"..\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisAttribute() {\n-        assertXPathExpression(\n-            \"attribute::foo:bar\",\n-            LocationPath.class,\n-            \"@foo:bar\");\n-\n-        assertXPathExpression(\n-            \"@foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"../@foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"@*\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"@*[last()]\",\n-            LocationPath.class);\n+        assertXPathExpression(\"attribute::foo:bar\", LocationPath.class, \"@foo:bar\");\n+        assertXPathExpression(\"@foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"../@foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"@*\", LocationPath.class);\n+        assertXPathExpression(\"@*[last()]\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisDescendant() {\n-        assertXPathExpression(\n-            \"descendant::foo:bar\",\n-            LocationPath.class);\n+        assertXPathExpression(\"descendant::foo:bar\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisDescendantOrSelf() {\n-        assertXPathExpression(\n-            \"descendant-or-self::foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"//foo\", \n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"foo//bar\", \n-            LocationPath.class);\n+        assertXPathExpression(\"descendant-or-self::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"//foo\", LocationPath.class);\n+        assertXPathExpression(\"foo//bar\", LocationPath.class);\n     }\n     \n     public void testLocationPathAxisOther() {\n-        assertXPathExpression(\n-            \"ancestor::foo:bar\",\n-            LocationPath.class);\n-            \n-        assertXPathExpression(\n-            \"ancestor-or-self::foo:bar\",\n-            LocationPath.class);\n-            \n-        assertXPathExpression(\n-            \"namespace::foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"preceding::foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"preceding-sibling::foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"following::foo:bar\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"following-sibling::foo:bar\",\n-            LocationPath.class);\n+        assertXPathExpression(\"ancestor::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"ancestor-or-self::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"namespace::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"preceding::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"preceding-sibling::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"following::foo:bar\", LocationPath.class);\n+        assertXPathExpression(\"following-sibling::foo:bar\", LocationPath.class);\n     }\n     \n     public void testLocationPathNodeTest() {\n-        assertXPathExpression(\n-            \"node()\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"text()\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"comment()\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"processing-instruction()\",\n-            LocationPath.class);\n-\n-        assertXPathExpression(\n-            \"processing-instruction('test')\",\n-            LocationPath.class);\n+        assertXPathExpression(\"node()\", LocationPath.class);\n+        assertXPathExpression(\"text()\", LocationPath.class);\n+        assertXPathExpression(\"comment()\", LocationPath.class);\n+        assertXPathExpression(\"processing-instruction()\", LocationPath.class);\n+        assertXPathExpression(\"processing-instruction('test')\", LocationPath.class);\n     }\n     \n     public void testVariableReference() {\n-        assertXPathExpression(\n-            \"$x\",\n-            VariableReference.class);                \n-\n-        assertXPathExpression(\n-            \"$x:y\",\n-            VariableReference.class);\n+        assertXPathExpression(\"$x\", VariableReference.class);\n+        assertXPathExpression(\"$x:y\", VariableReference.class);\n     }\n     \n     /**\n      * class, converts the expression to string and checks that the string\n      * matches the expected one.\n      */\n-    private void assertXPathExpression(\n-        String xpath,\n-        Class expectedClass,\n-        String expected) \n-    {\n-        JXPathCompiledExpression expression =\n-            (JXPathCompiledExpression) JXPathContext.compile(xpath);\n+    private void assertXPathExpression(String xpath, Class expectedClass, String expected) {\n+        JXPathCompiledExpression expression = (JXPathCompiledExpression) JXPathContext.compile(xpath);\n         \n-        assertEquals(\n-            \"Expression class for \" + xpath,\n-            expectedClass,\n-            expression.getExpression().getClass());\n-            \n-        assertEquals(\n-            \"Expression toString() for \" + xpath,\n-            expected,\n-            expression.getExpression().toString());\n-    }\n-    \n-    private void assertXPathExpression(\n-        String xpath,\n-        Class expectedClass) \n-    {\n+        assertEquals(\"Expression class for \" + xpath, expectedClass, expression.getExpression().getClass());\n+        assertEquals(\"Expression toString() for \" + xpath, expected, expression.getExpression().toString());\n+    }\n+    \n+    private void assertXPathExpression(String xpath, Class expectedClass) {\n         assertXPathExpression(xpath, expectedClass, xpath);\n     }\n     \n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/StressTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/StressTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class StressTest extends TestCase {\n     \n     private static final int THREAD_COUNT = 50;\n     private static JXPathContext context;\n     private static int count;\n     private static Throwable exception;\n-        \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public StressTest(String name) {\n-        super(name);\n-    }\n \n     public void testThreads() throws Throwable {\n         context = JXPathContext.newContext(null, new Double(100));\n             }\n         }\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/axes/RecursiveAxesTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/RecursiveAxesTest.java\n     private RecursiveBean bean;\n     private JXPathContext context;\n \n-    public RecursiveAxesTest(String name) {\n-        super(name);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(RecursiveAxesTest.class);\n-    }\n-\n     protected void setUp() throws Exception {\n         bean = new RecursiveBean(\"zero\");\n         RecursiveBean bean1 = new RecursiveBean(\"one\");\n             \"/first/first/second\");\n     }\n }\n-\n--- a/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n     private TestBeanWithNode bean;\n     private JXPathContext context;\n \n-    /**\n-     * Constructor for SimplePathInterpreterTest.\n-     */\n-    public SimplePathInterpreterTest(String name) {\n-        super(name);\n-    }\n-\n-    public static void main(String[] args) {\n-        junit.textui.TestRunner.run(SimplePathInterpreterTest.class);\n-    }\n-\n-    /**\n-     * @see TestCase#setUp()\n-     */\n     protected void setUp() throws Exception {\n         bean = TestBeanWithNode.createTestBeanWithDOM();\n         HashMap submap = new HashMap();\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class ContextDependencyTest extends JXPathTestCase {\n-    public ContextDependencyTest(String name) {\n-        super(name);\n-    }\n \n     public void testContextDependency() {\n         testContextDependency(\"1\", false);\n     }\n \n     public void testContextDependency(String xpath, boolean expected) {\n-        Expression expr =\n-            (Expression) Parser.parseExpression(xpath, new TreeCompiler());\n+        Expression expr = (Expression) Parser.parseExpression(xpath, new TreeCompiler());\n \n-        assertEquals(\n-            \"Context dependency <\" + xpath + \">\",\n-            expected,\n-            expr.isContextDependent());\n+        assertEquals(\"Context dependency <\" + xpath + \">\", expected, expr.isContextDependent());\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class CoreFunctionTest extends JXPathTestCase {\n     private JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public CoreFunctionTest(String name) {\n-        super(name);\n-    }\n \n     public void setUp() {\n         if (context == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class CoreOperationTest extends JXPathTestCase {\n     private JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public CoreOperationTest(String name) {\n-        super(name);\n-    }\n \n     public void setUp() {\n         if (context == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n import java.util.List;\n import java.util.Locale;\n \n-import junit.textui.TestRunner;\n-\n import org.apache.commons.jxpath.ClassFunctions;\n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Function;\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class ExtensionFunctionTest extends JXPathTestCase {\n     private Functions functions;\n     private JXPathContext context;\n     private TestBean testBean;\n     private TypeConverter typeConverter;\n-\n-    public static void main(String[] args) {\n-        TestRunner.run(ExtensionFunctionTest.class);\n-    }\n-    \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public ExtensionFunctionTest(String name) {\n-        super(name);\n-    }\n \n     public void setUp() {\n         if (context == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class VariableTest extends JXPathTestCase {\n     private JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public VariableTest(String name) {\n-        super(name);\n-    }\n \n     public void setUp() {\n         if (context == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public abstract class BeanModelTestCase extends JXPathTestCase {\n     private JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public BeanModelTestCase(String name) {\n-        super(name);\n-    }\n \n     public void setUp() {\n //        if (context == null) {\n--- a/src/test/org/apache/commons/jxpath/ri/model/EmbeddedColonMapKeysTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/EmbeddedColonMapKeysTest.java\n public class EmbeddedColonMapKeysTest extends JXPathTestCase {\n     private JXPathContext context;\n \n-    /*\n-     * (non-Javadoc)\n-     * \n-     * @see junit.framework.TestCase#setUp()\n-     */\n     protected void setUp() throws Exception {\n         super.setUp();\n         HashMap m = new HashMap();\n         m.put(\"foo:key\", \"value\");\n         context = JXPathContext.newContext(m);\n         context.setLenient(true);\n-    }\n-\n-    /**\n-     * Create a new EmbeddedColonMapKeysTest.\n-     */\n-    public EmbeddedColonMapKeysTest(String name) {\n-        super(name);\n     }\n \n     public void testSelectNodes() throws Exception {\n--- a/src/test/org/apache/commons/jxpath/ri/model/EmptyCollectionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/EmptyCollectionTest.java\n         }\n     }\n \n-    /**\n-     * Construct a new EmptyCollectionTest instance.\n-     */\n-    public EmptyCollectionTest(String s) {\n-        super(s);\n-    }\n-\n     public void testEmptyList() {\n         assertXPathPointerIterator(JXPathContext.newContext(Collections.EMPTY_LIST), \"/*\",\n                 Collections.EMPTY_LIST);\n--- a/src/test/org/apache/commons/jxpath/ri/model/ExternalXMLNamespaceTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/ExternalXMLNamespaceTest.java\n  */\n public class ExternalXMLNamespaceTest extends JXPathTestCase {\n     protected JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public ExternalXMLNamespaceTest(String name) {\n-        super(name);\n-    }\n \n     protected DocumentContainer createDocumentContainer(String model) {\n         DocumentContainer result = new DocumentContainer(JXPathTestCase.class\n         doTestCreateAndSetAttribute(DocumentContainer.MODEL_DOM);\n     }\n \n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n import java.util.Map;\n import java.util.Vector;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-import junit.textui.TestRunner;\n-\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathTestCase;\n import org.apache.commons.jxpath.Pointer;\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class MixedModelTest extends JXPathTestCase {\n     private JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public MixedModelTest(String name) {\n-        super(name);\n-    }\n-\n-    public static void main(String[] args) {\n-        TestRunner.run(new MixedModelTest(\"testContainerWithCollection\"));\n-    }\n-    \n-    /**\n-     * Return the tests included in this test suite.\n-     */\n-    public static Test suite() {\n-        return (new TestSuite(MixedModelTest.class));\n-    }\n \n     public void setUp() {\n         TestMixedModelBean bean = new TestMixedModelBean();\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n public abstract class XMLModelTestCase extends JXPathTestCase {\n     protected JXPathContext context;\n \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public XMLModelTestCase(String name) {\n-        super(name);\n-    }\n-\n     public void setUp() {\n         if (context == null) {\n             DocumentContainer docCtr = createDocumentContainer();\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"document\", docCtr.getValue());\n             vars.declareVariable(\"container\", docCtr);\n-            vars.declareVariable(\n-                \"element\",\n-                context.getPointer(\"vendor/location/address/street\").getNode());\n+            vars.declareVariable(\"element\", context.getPointer(\"vendor/location/address/street\").getNode());\n         }\n     }\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLPreserveSpaceTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLPreserveSpaceTest.java\n  */\n public class XMLPreserveSpaceTest extends JXPathTestCase {\n     protected JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public XMLPreserveSpaceTest(String name) {\n-        super(name);\n-    }\n \n     protected DocumentContainer createDocumentContainer(String model) {\n         return new DocumentContainer(JXPathTestCase.class\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLSpaceTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLSpaceTest.java\n  */\n public class XMLSpaceTest extends JXPathTestCase {\n     protected JXPathContext context;\n-\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public XMLSpaceTest(String name) {\n-        super(name);\n-    }\n \n     protected DocumentContainer createDocumentContainer(String model) {\n         return new DocumentContainer(JXPathTestCase.class\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/BadlyImplementedFactoryTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BadlyImplementedFactoryTest.java\n \n     private JXPathContext context;\n \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public BadlyImplementedFactoryTest(String name) {\n-        super(name);\n-    }\n-\n     public void setUp() {\n         context = JXPathContext.newContext(new HashMap());\n         context.setFactory(new AbstractFactory() {\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n  */\n package org.apache.commons.jxpath.ri.model.beans;\n \n-import junit.framework.TestSuite;\n-\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.TestBean;\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class BeanModelTest extends BeanModelTestCase {\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public BeanModelTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * Return the tests included in this test suite.\n-     */\n-    public static TestSuite suite() {\n-        return (new TestSuite(BeanModelTest.class));\n-    }\n \n     protected Object createContextBean() {\n         return new TestBean();\n--- a/src/test/org/apache/commons/jxpath/ri/model/container/ContainerModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/container/ContainerModelTest.java\n import java.util.List;\n import java.util.Map;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-import junit.textui.TestRunner;\n-\n import org.apache.commons.jxpath.Container;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathTestCase;\n \n public class ContainerModelTest extends JXPathTestCase {\n \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public ContainerModelTest(String name) {\n-        super(name);\n-    }\n-\n-    public static void main(String[] args) {\n-        TestRunner.run(suite());\n-    }\n-    \n-    /**\n-     * Return the tests included in this test suite.\n-     */\n-    public static Test suite() {\n-        return (new TestSuite(ContainerModelTest.class));\n-    }\n-\n-    \n     private class ArrayContainer implements Container\n     {\n         private String[] array = new String[]{\"foo\", \"bar\"};\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n  */\n package org.apache.commons.jxpath.ri.model.dom;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.xml.DocumentContainer;\n+\n import org.w3c.dom.Attr;\n import org.w3c.dom.Document;\n import org.w3c.dom.Element;\n  */\n \n public class DOMModelTest extends XMLModelTestCase {\n-    \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public DOMModelTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * Return the tests included in this test suite.\n-     */\n-    public static Test suite() {\n-        return (new TestSuite(DOMModelTest.class));\n-    }\n \n     protected String getModel() {\n         return DocumentContainer.MODEL_DOM;\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java\n  */\n package org.apache.commons.jxpath.ri.model.dynabeans;\n \n-import junit.framework.TestSuite;\n-\n import org.apache.commons.beanutils.WrapDynaBean;\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.TestBean;\n  */\n \n public class DynaBeanModelTest extends BeanModelTestCase {\n-    public DynaBeanModelTest(String name) {\n-        super(name);\n-    }\n-\n-    public static TestSuite suite() {\n-        return new TestSuite(DynaBeanModelTest.class);\n-//        TestSuite s = new TestSuite();\n-//        s.addTest(new DynaBeanModelTest(\"testAxisParent\"));\n-//        return s;\n-    }\n \n     protected Object createContextBean() {\n         return new WrapDynaBean(new TestBean());\n     protected AbstractFactory getAbstractFactory() {\n         return new TestDynaBeanFactory();\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n public class DynamicPropertiesModelTest extends JXPathTestCase {\n     private JXPathContext context;\n \n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public DynamicPropertiesModelTest(String name) {\n-        super(name);\n-    }\n-\n     public void setUp() {\n         if (context == null) {\n             context = JXPathContext.newContext(new TestBean());\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n \n import java.util.List;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.xml.DocumentContainer;\n+\n import org.jdom.Attribute;\n import org.jdom.CDATA;\n import org.jdom.Document;\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class JDOMModelTest extends XMLModelTestCase {\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public JDOMModelTest(String name) {\n-        super(name);\n-    }\n-\n-    /**\n-     * Return the tests included in this test suite.\n-     */\n-    public static Test suite() {\n-        return (new TestSuite(JDOMModelTest.class));\n-    }\n \n     protected String getModel() {\n         return DocumentContainer.MODEL_JDOM;\n--- a/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java\n+++ b/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-\n public class BasicTypeConverterTest extends TestCase {\n-    /**\n-     * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n-     */\n-    public BasicTypeConverterTest(String name) {\n-        super(name);\n-    }\n \n     public void testPrimitiveToString() {\n         assertConversion(new Integer(1), String.class, \"1\");", "timestamp": 1209750406, "metainfo": ""}