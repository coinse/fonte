{"sha": "cdfbbfb11a27aadeb7d3902a236fe0f261d87cd1", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n \n     /**\n      * Add functions to the library\n+     * @param functions to add\n      */\n     public void addFunctions(Functions functions) {\n         allFunctions.add(functions);\n \n     /**\n      * Remove functions from the library.\n+     * @param functions to remove\n      */\n     public void removeFunctions(Functions functions) {\n         allFunctions.remove(functions);\n     /**\n      * Returns a set containing all namespaces used by the aggregated\n      * Functions.\n+     * @return Set<String>\n      */\n     public Set getUsedNamespaces() {\n         if (byNamespace == null) {\n     /**\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n+     * @param namespace function namespace\n+     * @param name function name\n+     * @param parameters parameters\n+     * @return Function found\n      */\n-    public Function getFunction(\n-        String namespace,\n-        String name,\n-        Object[] parameters)\n-    {\n+    public Function getFunction(String namespace, String name,\n+            Object[] parameters) {\n         if (byNamespace == null) {\n             prepareCache();\n         }\n         return null;\n     }\n \n+    /**\n+     * Prepare the cache.\n+     */\n     private void prepareCache() {\n         byNamespace = new HashMap();\n         int count = allFunctions.size();\n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n     }\n \n     /**\n-     * For  a dynamic class, returns the corresponding DynamicPropertyHandler\n+     * For a dynamic class, returns the corresponding DynamicPropertyHandler\n      * class.\n+     * @return Class\n      */\n     public Class getDynamicPropertyHandlerClass() {\n         return dynamicPropertyHandlerClass;\n--- a/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n      * Returns true if objects of this class are treated as atomic\n      * objects which have no properties of their own.\n      * For example, java.lang.String and java.lang.Number are atomic.\n+     * @return boolean\n      */\n     boolean isAtomic();\n \n      * should return null and getDynamicPropertyHandlerClass should return\n      * a valid class name.  An object cannot have both static and dynamic\n      * properties at the same time.\n+     * @return boolean\n      */\n     boolean isDynamic();\n \n     /**\n      * Returns a list of property descriptors for the beans described by this\n      * bean info object.  Returns null for atomic beans.\n+     * @return PropertyDescriptor[]\n      */\n     PropertyDescriptor[] getPropertyDescriptors();\n \n     /**\n      * Returns a PropertyDescriptor for the specified name or null if there\n      * is no such property.\n+     * @param propertyName property name\n+     * @return PropertyDescriptor\n      */\n     PropertyDescriptor getPropertyDescriptor(String propertyName);\n \n      * For dynamic objects, returns the class implementing\n      * the DynamicPropertyHandler interface. That class can\n      * be used to access dynamic properties.\n+     * @return Class\n      */\n     Class getDynamicPropertyHandlerClass();\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathInvalidAccessException.java\n \n     private static final long serialVersionUID = -8875537628056117241L;\n \n+    /**\n+     * Create a new JXPathInvalidAccessException.\n+     * @param message exception message\n+     */\n     public JXPathInvalidAccessException(String message) {\n         super(message);\n     }\n \n+    /**\n+     * Create a new JXPathInvalidAccessException.\n+     * @param message exception message\n+     * @param ex precipitating exception\n+     */\n     public JXPathInvalidAccessException(String message, Throwable ex) {\n         super(message, ex);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n     private static final NodeTest ELEMENT_NODE_TEST =\n             new NodeTypeTest(Compiler.NODE_TYPE_NODE);\n \n-    public DescendantContext(\n-            EvalContext parentContext,\n-            boolean includeSelf,\n-            NodeTest nodeTest)\n-    {\n+    /**\n+     * Create a new DescendantContext.\n+     * @param parentContext parent context\n+     * @param includeSelf whether to include this node\n+     * @param nodeTest test\n+     */\n+    public DescendantContext(EvalContext parentContext, boolean includeSelf,\n+            NodeTest nodeTest) {\n         super(parentContext);\n         this.includeSelf = includeSelf;\n         this.nodeTest = nodeTest;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isChildOrderingRequired() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return currentNodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (position < this.position) {\n             reset();\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n     /**\n      * Checks if we are reentering a bean we have already seen and if so\n      * returns true to prevent infinite recursion.\n+     * @return boolean\n      */\n     private boolean isRecursive() {\n         Object node = currentNodePointer.getNode();\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n     private boolean collection;\n     private NodePointer nodePointer;\n \n+    /**\n+     * Create a new InitialContext.\n+     * @param parentContext parent context\n+     */\n     public InitialContext(EvalContext parentContext) {\n         super(parentContext);\n         nodePointer =\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Pointer getSingleNodePointer() {\n         return nodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getCurrentNodePointer() {\n         return nodePointer;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getValue() {\n         return nodePointer.getValue();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         if (collection) {\n         return position == 1;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean nextSet() {\n         if (started) {\n             return false;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n     }\n \n     /**\n-     * Get a registered value. \n+     * Get a registered value.\n      * @param id int\n      * @return Object\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationAnd.java\n  */\n public class CoreOperationAnd extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationAnd.\n+     * @param args to combine\n+     */\n     public CoreOperationAnd(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         for (int i = 0; i < args.length; i++) {\n             if (!InfoSetUtil.booleanValue(args[i].computeValue(context))) {\n         return Boolean.TRUE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return AND_PRECEDENCE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"and\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\n public abstract class CoreOperationCompare extends CoreOperation {\n     private boolean invert;\n \n+    /**\n+     * Create a new CoreOperationCompare.\n+     * @param arg1 left operand\n+     * @param arg2 right operand\n+     */\n     public CoreOperationCompare(Expression arg1, Expression arg2) {\n         this(arg1, arg2, false);\n     }\n \n+    /**\n+     * Create a new CoreOperationCompare.\n+     * @param arg1 left operand\n+     * @param arg2 right operand\n+     * @param invert whether to invert (not) the comparison\n+     */\n     protected CoreOperationCompare(Expression arg1, Expression arg2, boolean invert) {\n         super(new Expression[] { arg1, arg2 });\n         this.invert = invert;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return COMPARE_PRECEDENCE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return true;\n     }\n \n     /**\n-     * Compares two values\n-     */\n-    protected boolean equal(\n-        EvalContext context,\n-        Expression left,\n-        Expression right)\n-    {\n+     * Compares two values.\n+     * @param context evaluation context\n+     * @param left operand\n+     * @param right operand\n+     * @return whether left = right in XPath terms\n+     */\n+    protected boolean equal(EvalContext context, Expression left,\n+            Expression right) {\n         Object l = left.compute(context);\n         Object r = right.compute(context);\n \n         return equal(l, r);\n     }\n \n+    /**\n+     * Learn whether it contains value.\n+     * @param it Iterator to check\n+     * @param value for which to look\n+     * @return whether value was found\n+     */\n     protected boolean contains(Iterator it, Object value) {\n         while (it.hasNext()) {\n             Object element = it.next();\n         return false;\n     }\n \n+    /**\n+     * Learn whether lit intersects rit.\n+     * @param lit left Iterator\n+     * @param rit right Iterator\n+     * @return boolean\n+     */\n     protected boolean findMatch(Iterator lit, Iterator rit) {\n         HashSet left = new HashSet();\n         while (lit.hasNext()) {\n         return false;\n     }\n \n+    /**\n+     * Learn whether l equals r in XPath terms.\n+     * @param l left operand\n+     * @param r right operand\n+     * @return whether l = r\n+     */\n     protected boolean equal(Object l, Object r) {\n         if (l instanceof Pointer) {\n             l = ((Pointer) l).getValue();\n         boolean result;\n         if (l instanceof Boolean || r instanceof Boolean) {\n             result = l == r || InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r);\n-        } else if (l instanceof Number || r instanceof Number) {\n+        }\n+        else if (l instanceof Number || r instanceof Number) {\n             //if either side is NaN, no comparison returns true:\n             double ld = InfoSetUtil.doubleValue(l);\n             if (Double.isNaN(ld)) {\n                 return false;\n             }\n             result = ld == rd;\n-        } else {\n+        }\n+        else {\n             if (l instanceof String || r instanceof String) {\n                 l = InfoSetUtil.stringValue(l);\n                 r = InfoSetUtil.stringValue(r);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java\n public class CoreOperationGreaterThanOrEqual extends\n         CoreOperationRelationalExpression {\n \n+    /**\n+     * Create a new CoreOperationGreaterThanOrEqual.\n+     * @param arg1 operand 1\n+     * @param arg2 operand 2\n+     */\n     public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean evaluateCompare(int compare) {\n         return compare >= 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \">=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java\n  */\n public class CoreOperationNotEqual extends CoreOperationCompare {\n \n+    /**\n+     * Create a new CoreOperationNotEqual.\n+     * @param arg1 left operand\n+     * @param arg2 right operand\n+     */\n     public CoreOperationNotEqual(Expression arg1, Expression arg2) {\n         super(arg1, arg2, true);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"!=\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n  */\n public abstract class CoreOperationRelationalExpression extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationRelationalExpression.\n+     * @param args arguments\n+     */\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public final Object computeValue(EvalContext context) {\n         return compute(args[0].compute(context), args[1].compute(context))\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected final int getPrecedence() {\n         return RELATIONAL_EXPR_PRECEDENCE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected final boolean isSymmetric() {\n         return false;\n     }\n \n+    /**\n+     * Template method for subclasses to evaluate the result of a comparison.\n+     * @param compare result of comparison to evaluate \n+     * @return ultimate operation success/failure\n+     */\n     protected abstract boolean evaluateCompare(int compare);\n \n+    /**\n+     * Compare left to right.\n+     * @param left left operand\n+     * @param right right operand\n+     * @return operation success/failure\n+     */\n     private boolean compute(Object left, Object right) {\n         left = reduce(left);\n         right = reduce(right);\n         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n     }\n \n+    /**\n+     * Reduce an operand for comparison.\n+     * @param o Object to reduce\n+     * @return reduced operand\n+     */\n     private Object reduce(Object o) {\n         if (o instanceof SelfContext) {\n             o = ((EvalContext) o).getSingleNodePointer();\n         return o;\n     }\n \n+    /**\n+     * Learn whether any element returned from an Iterator matches a given value.\n+     * @param it Iterator\n+     * @param value to look for\n+     * @return whether a match was found\n+     */\n     private boolean containsMatch(Iterator it, Object value) {\n         while (it.hasNext()) {\n             Object element = it.next();\n         return false;\n     }\n \n+    /**\n+     * Learn whether there is an intersection between two Iterators.\n+     * @param lit left Iterator\n+     * @param rit right Iterator\n+     * @return whether a match was found\n+     */\n     private boolean findMatch(Iterator lit, Iterator rit) {\n         HashSet left = new HashSet();\n         while (lit.hasNext()) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationSubtract.java\n  */\n public class CoreOperationSubtract extends CoreOperation {\n \n+    /**\n+     * Create a new CoreOperationSubtract.\n+     * @param arg1 minuend\n+     * @param arg2 subtrahend\n+     */\n     public CoreOperationSubtract(Expression arg1, Expression arg2) {\n         super(new Expression[] { arg1, arg2 });\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object computeValue(EvalContext context) {\n         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n         return new Double(l - r);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected int getPrecedence() {\n         return ADD_PRECEDENCE;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isSymmetric() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getSymbol() {\n         return \"-\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n public class NodeTypeTest extends NodeTest {\n     private int nodeType;\n \n+    /**\n+     * Create a new NodeTypeTest.\n+     * @param nodeType to match\n+     */\n     public NodeTypeTest(int nodeType) {\n         this.nodeType = nodeType;\n     }\n \n+    /**\n+     * Get the nodeType.\n+     * @return int\n+     */\n     public int getNodeType() {\n         return nodeType;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return nodeTypeToString(nodeType) + \"()\";\n     }\n \n+    /**\n+     * Render the given node type as a String.\n+     * @param code int\n+     * @return String\n+     */\n     public static String nodeTypeToString(int code) {\n         switch (code) {\n             case Compiler.NODE_TYPE_NODE :\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n \n     private static final QName QNAME_NAME = new QName(null, \"name\");\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object number(String value) {\n         return new Constant(new Double(value));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object literal(String value) {\n         return new Constant(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object qname(String prefix, String name) {\n         return new QName(prefix, name);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object sum(Object[] arguments) {\n         return new CoreOperationAdd(toExpressionArray(arguments));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object minus(Object left, Object right) {\n         return new CoreOperationSubtract(\n             (Expression) left,\n             (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object multiply(Object left, Object right) {\n         return new CoreOperationMultiply((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object divide(Object left, Object right) {\n         return new CoreOperationDivide((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object mod(Object left, Object right) {\n         return new CoreOperationMod((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object lessThan(Object left, Object right) {\n         return new CoreOperationLessThan((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object lessThanOrEqual(Object left, Object right) {\n         return new CoreOperationLessThanOrEqual(\n             (Expression) left,\n             (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object greaterThan(Object left, Object right) {\n         return new CoreOperationGreaterThan(\n             (Expression) left,\n             (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object greaterThanOrEqual(Object left, Object right) {\n         return new CoreOperationGreaterThanOrEqual(\n             (Expression) left,\n             (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object equal(Object left, Object right) {\n         return isNameAttributeTest((Expression) left)\n                 ? new NameAttributeTest((Expression) left, (Expression) right)\n                 : new CoreOperationEqual((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object notEqual(Object left, Object right) {\n         return new CoreOperationNotEqual((Expression) left, (Expression) right);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object minus(Object argument) {\n         return new CoreOperationNegate((Expression) argument);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object variableReference(Object qName) {\n         return new VariableReference((QName) qName);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object function(int code, Object[] args) {\n         return new CoreFunction(code, toExpressionArray(args));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object function(Object name, Object[] args) {\n         return new ExtensionFunction((QName) name, toExpressionArray(args));\n     }\n \n-    public Object and(Object arguments[]) {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object and(Object[] arguments) {\n         return new CoreOperationAnd(toExpressionArray(arguments));\n     }\n \n-    public Object or(Object arguments[]) {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object or(Object[] arguments) {\n         return new CoreOperationOr(toExpressionArray(arguments));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object union(Object[] arguments) {\n         return new CoreOperationUnion(toExpressionArray(arguments));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object locationPath(boolean absolute, Object[] steps) {\n         return new LocationPath(absolute, toStepArray(steps));\n     }\n \n-    public Object expressionPath(\n-        Object expression,\n-        Object[] predicates,\n-        Object[] steps)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object expressionPath(Object expression, Object[] predicates,\n+            Object[] steps) {\n         return new ExpressionPath(\n             (Expression) expression,\n             toExpressionArray(predicates),\n             toStepArray(steps));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object nodeNameTest(Object qname) {\n         return new NodeNameTest((QName) qname);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object nodeTypeTest(int nodeType) {\n         return new NodeTypeTest(nodeType);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object processingInstructionTest(String instruction) {\n         return new ProcessingInstructionTest(instruction);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object step(int axis, Object nodeTest, Object[] predicates) {\n         return new Step(\n             axis,\n             toExpressionArray(predicates));\n     }\n \n+    /**\n+     * Get an Object[] as an Expression[].\n+     * @param array Object[]\n+     * @return Expression[]\n+     */\n     private Expression[] toExpressionArray(Object[] array) {\n-        Expression expArray[] = null;\n+        Expression[] expArray = null;\n         if (array != null) {\n             expArray = new Expression[array.length];\n             for (int i = 0; i < expArray.length; i++) {\n         return expArray;\n     }\n \n+    /**\n+     * Get an Object[] as a Step[].\n+     * @param array Object[]\n+     * @return Step[]\n+     */\n     private Step[] toStepArray(Object[] array) {\n-        Step stepArray[] = null;\n+        Step[] stepArray = null;\n         if (array != null) {\n             stepArray = new Step[array.length];\n             for (int i = 0; i < stepArray.length; i++) {\n         return stepArray;\n     }\n \n+    /**\n+     * Learn whether arg is a name attribute test.\n+     * @param arg Expression to test\n+     * @return boolean\n+     */\n     private boolean isNameAttributeTest(Expression arg) {\n         if (!(arg instanceof LocationPath)) {\n             return false;\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointerFactory.java\n  * @version $Revision$ $Date$\n  */\n public class VariablePointerFactory implements NodePointerFactory {\n+    /** factory order constant */\n     public static final int VARIABLE_POINTER_FACTORY_ORDER = 890;\n \n     /**\n      * Node value wrapper to trigger a VariablePointerFactory.\n      */\n-    public static class VariableContextWrapper {\n+    public static final class VariableContextWrapper {\n         private final JXPathContext context;\n \n+        /**\n+         * Create a new VariableContextWrapper.\n+         * @param context to wrap\n+         */\n         private VariableContextWrapper(JXPathContext context) {\n             this.context = context;\n         }\n         return new VariableContextWrapper(context);\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#createNodePointer(org.apache.commons.jxpath.ri.QName,\n-     *      java.lang.Object, java.util.Locale)\n+    /**\n+     * {@inheritDoc}\n      */\n     public NodePointer createNodePointer(QName name, Object object,\n             Locale locale) {\n         return null;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#createNodePointer(org.apache.commons.jxpath.ri.model.NodePointer,\n-     *      org.apache.commons.jxpath.ri.QName, java.lang.Object)\n+    /**\n+     * {@inheritDoc}\n      */\n     public NodePointer createNodePointer(NodePointer parent, QName name,\n             Object object) {\n         return createNodePointer(name, object, null);\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see org.apache.commons.jxpath.ri.model.NodePointerFactory#getOrder()\n+    /**\n+     * {@inheritDoc}\n      */\n     public int getOrder() {\n         return VARIABLE_POINTER_FACTORY_ORDER;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n  */\n public class CollectionPointerFactory implements NodePointerFactory {\n \n+    /** factory order constant */\n     public static final int COLLECTION_POINTER_FACTORY_ORDER = 10;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getOrder() {\n         return COLLECTION_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(\n-        QName name,\n-        Object bean,\n-        Locale locale)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale) {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(bean, locale) : null;\n     }\n \n-    public NodePointer createNodePointer(\n-        NodePointer parent,\n-        QName name,\n-        Object bean)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name,\n+            Object bean) {\n         return ValueUtils.isCollection(bean) ? new CollectionPointer(parent, bean) : null;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n     private boolean byNameAttribute = false;\n \n     /**\n+     * Create a new NullPropertyPointer.\n+     * @param parent pointer\n      */\n     public NullPropertyPointer(NodePointer parent) {\n         super(parent);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public QName getName() {\n         return new QName(propertyName);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setPropertyIndex(int index) {\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getLength() {\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getBaseValue() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getImmediateNode() {\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isLeaf() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getValuePointer() {\n         return new NullPointer(this,  new QName(getPropertyName()));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     protected boolean isActualProperty() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isActual() {\n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isContainer() {\n         return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setValue(Object value) {\n         if (parent == null || parent.isContainer()) {\n             throw new JXPathInvalidAccessException(\n                     + asPath()\n                     + \", the target object is null\");\n         }\n-        if (parent instanceof PropertyOwnerPointer &&\n-                ((PropertyOwnerPointer) parent).\n-                    isDynamicPropertyDeclarationSupported()){\n+        if (parent instanceof PropertyOwnerPointer\n+                && ((PropertyOwnerPointer) parent)\n+                        .isDynamicPropertyDeclarationSupported()) {\n             // If the parent property owner can create\n             // a property automatically - let it do so\n             PropertyPointer propertyPointer =\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         NodePointer newParent = parent.createPath(context);\n         if (isAttribute()) {\n         return newParent.createChild(context, getName(), getIndex());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         NodePointer newParent = parent.createPath(context);\n         if (isAttribute()) {\n         return newParent.createChild(context, getName(), index, value);\n     }\n \n-    public NodePointer createChild(\n-            JXPathContext context,\n-            QName name,\n-            int index)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createChild(JXPathContext context, QName name, int index) {\n         return createPath(context).createChild(context, name, index);\n     }\n \n-    public NodePointer createChild(\n-            JXPathContext context,\n-            QName name,\n-            int index,\n-            Object value)\n-    {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public NodePointer createChild(JXPathContext context, QName name,\n+            int index, Object value) {\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String getPropertyName() {\n         return propertyName;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setPropertyName(String propertyName) {\n         this.propertyName = propertyName;\n     }\n \n+    /**\n+     * Set the name attribute.\n+     * @param attributeValue value to set\n+     */\n     public void setNameAttributeValue(String attributeValue) {\n         this.propertyName = attributeValue;\n         byNameAttribute = true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isCollection() {\n         return getIndex() != WHOLE_COLLECTION;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPropertyCount() {\n         return 0;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String[] getPropertyNames() {\n         return new String[0];\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         if (!byNameAttribute) {\n             return super.asPath();\n         return buffer.toString();\n     }\n \n+    /**\n+     * Return a string escaping single and double quotes.\n+     * @param string string to treat\n+     * @return string with any necessary changes made.\n+     */\n     private String escape(String string) {\n-        int index = string.indexOf('\\'');\n-        while (index != -1) {\n-            string =\n-                string.substring(0, index)\n-                    + \"&apos;\"\n-                    + string.substring(index + 1);\n-            index = string.indexOf('\\'');\n-        }\n-        index = string.indexOf('\\\"');\n-        while (index != -1) {\n-            string =\n-                string.substring(0, index)\n-                    + \"&quot;\"\n-                    + string.substring(index + 1);\n-            index = string.indexOf('\\\"');\n-        }\n-        return string;\n-    }\n-\n+        final char[] c = new char[] { '\\'', '\"' };\n+        final String[] esc = new String[] { \"&apos;\", \"&quot;\" };\n+        StringBuffer sb = null;\n+        for (int i = 0; sb == null && i < c.length; i++) {\n+            if (string.indexOf(c[i]) >= 0) {\n+                sb = new StringBuffer(string);\n+            }\n+        }\n+        if (sb == null) {\n+            return string;\n+        }\n+        for (int i = 0; i < c.length; i++) {\n+            if (string.indexOf(c[i]) < 0) {\n+                continue;\n+            }\n+            int pos = 0;\n+            while (pos < sb.length()) {\n+                if (sb.charAt(pos) == c[i]) {\n+                    sb.replace(pos, pos + 1, esc[i]);\n+                    pos += esc[i].length();\n+                }\n+                else {\n+                    pos++;\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Create a \"bad factory\" JXPathAbstractFactoryException for the specified AbstractFactory.\n+     * @param factory AbstractFactory\n+     * @return JXPathAbstractFactoryException\n+     */\n     private JXPathAbstractFactoryException createBadFactoryException(AbstractFactory factory) {\n         return new JXPathAbstractFactoryException(\"Factory \" + factory\n                 + \" reported success creating object for path: \" + asPath()\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n     private List attributes;\n     private int position = 0;\n \n+    /**\n+     * Create a new DOMAttributeIterator.\n+     * @param parent pointer\n+     * @param name to test\n+     */\n     public DOMAttributeIterator(NodePointer parent, QName name) {\n         this.parent = parent;\n         this.name = name;\n         }\n     }\n \n+    /**\n+     * Test an attribute.\n+     * @param attr to test\n+     * @return whether test succeeded\n+     */\n     private boolean testAttr(Attr attr) {\n         String nodePrefix = DOMNodePointer.getPrefix(attr);\n         String nodeLocalName = DOMNodePointer.getLocalName(attr);\n         return false;\n     }\n \n+    /**\n+     * Test whether two strings are == or .equals()\n+     * @param s1 first string\n+     * @param s2 second string\n+     * @return boolean\n+     */\n     private static boolean equalStrings(String s1, String s2) {\n         return s1 == s2 || s1 != null && s1.equals(s2);\n     }\n \n+    /**\n+     * Get the named attribute.\n+     * @param element to search\n+     * @param name to match\n+     * @return Attr found\n+     */\n     private Attr getAttribute(Element element, QName name) {\n         String testPrefix = name.getPrefix();\n         String testNS = null;\n         return element.getAttributeNode(name.getName());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n  */\n public class DynamicAttributeIterator extends BeanAttributeIterator {\n \n+    /**\n+     * Create a new DynamicAttributeIterator.\n+     * @param parent pointer\n+     * @param name to match properties\n+     */\n     public DynamicAttributeIterator(PropertyOwnerPointer parent, QName name) {\n         super(parent, name);\n     }\n \n-     protected void prepareForIndividualProperty(String name) {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    protected void prepareForIndividualProperty(String name) {\n          ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);\n          super.prepareForIndividualProperty(name);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n     private String[] names;\n     private String requiredPropertyName;\n \n-    public DynamicPropertyPointer(\n-            NodePointer parent,\n-            DynamicPropertyHandler handler)\n-    {\n+    /**\n+     * Create a new DynamicPropertyPointer.\n+     * @param parent pointer\n+     * @param handler DynamicPropertyHandler\n+     */\n+    public DynamicPropertyPointer(NodePointer parent,\n+            DynamicPropertyHandler handler) {\n         super(parent);\n         this.handler = handler;\n     }\n+\n     /**\n      * This type of node is auxiliary.\n+     * @return true\n      */\n     public boolean isContainer() {\n         return true;\n \n     /**\n      * Number of the DP object's properties.\n+     * @return int\n      */\n     public int getPropertyCount() {\n         return getPropertyNames().length;\n     }\n \n     /**\n-     * Names of all properties, sorted alphabetically\n+     * Names of all properties, sorted alphabetically.\n+     * @return String[]\n      */\n     public String[] getPropertyNames() {\n         if (names == null) {\n-            String allNames[] = handler.getPropertyNames(getBean());\n+            String[] allNames = handler.getPropertyNames(getBean());\n             names = new String[allNames.length];\n             for (int i = 0; i < names.length; i++) {\n                 names[i] = allNames[i];\n     /**\n      * Returns the name of the currently selected property or \"*\"\n      * if none has been selected.\n+     * @return String\n      */\n     public String getPropertyName() {\n         if (name == null) {\n-            String names[] = getPropertyNames();\n+            String[] names = getPropertyNames();\n             name = propertyIndex >= 0 && propertyIndex < names.length ? names[propertyIndex] : \"*\";\n         }\n         return name;\n      * adds this name to the object's property name list. It does not\n      * set the property value though. In order to set the property\n      * value, call setValue().\n+     * @param propertyName to set\n      */\n     public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n     /**\n      * Index of the currently selected property in the list of all\n      * properties sorted alphabetically.\n+     * @return int\n      */\n     public int getPropertyIndex() {\n         if (propertyIndex == UNSPECIFIED_PROPERTY) {\n-            String names[] = getPropertyNames();\n+            String[] names = getPropertyNames();\n             for (int i = 0; i < names.length; i++) {\n                 if (names[i].equals(name)) {\n                     setPropertyIndex(i);\n     /**\n      * Index a property by its index in the list of all\n      * properties sorted alphabetically.\n+     * @param index to set\n      */\n     public void setPropertyIndex(int index) {\n         if (propertyIndex != index) {\n     /**\n      * Returns the value of the property, not an element of the collection\n      * represented by the property, if any.\n+     * @return Object\n      */\n     public Object getBaseValue() {\n         return handler.getProperty(getBean(), getPropertyName());\n      * the value of the index'th element of the collection represented by the\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n+     * @return Object\n      */\n     public Object getImmediateNode() {\n         Object value;\n     /**\n      * A dynamic property is always considered actual - all keys are apparently\n      * existing with possibly the value of null.\n+     * @return boolean\n      */\n     protected boolean isActualProperty() {\n         return true;\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n      * represented by the property.\n+     * @param value to set\n      */\n     public void setValue(Object value) {\n         if (index == WHOLE_COLLECTION) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context) {\n         // Ignore the name passed to us, use our own data\n         Object collection = getBaseValue();\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         if (index == WHOLE_COLLECTION) {\n             handler.setProperty(getBean(), getPropertyName(), value);\n         return this;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             removeKey();\n         }\n     }\n \n+    /**\n+     * Remove the current property.\n+     */\n     private void removeKey() {\n         Object bean = getBean();\n         if (bean instanceof Map) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getImmediateParentPointer().asPath());\n         return buffer.toString();\n     }\n \n+    /**\n+     * Escape string.\n+     * @param string s\n+     * @return String\n+     */\n     private String escape(String string) {\n         int index = string.indexOf('\\'');\n         while (index != -1) {\n         return string;\n     }\n \n+    /**\n+     * Get abstractFactory from context.\n+     * @param context to search\n+     * @return AbstractFactory\n+     */\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n  */\n public class ServletContextHandler implements DynamicPropertyHandler {\n \n-    private static final String[] STRING_ARRAY = new String[0];\n+    private static final int DEFAULT_PROPERTY_COUNT = 16;\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String[] getPropertyNames(Object context) {\n-        HashSet list = new HashSet(16);\n+        HashSet list = new HashSet(DEFAULT_PROPERTY_COUNT);\n         collectPropertyNames(list, context);\n-        return (String[]) list.toArray(STRING_ARRAY);\n+        return (String[]) list.toArray(new String[list.size()]);\n     }\n \n+    /**\n+     * Collect the property names from bean, storing in set.\n+     * @param set destination\n+     * @param bean to read\n+     */\n     protected void collectPropertyNames(HashSet set, Object bean) {\n         Enumeration e = ((ServletContext) bean).getAttributeNames();\n         while (e.hasMoreElements()) {\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Object getProperty(Object context, String property) {\n         return ((ServletContext) context).getAttribute(property);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void setProperty(Object context, String property, Object value) {\n         ((ServletContext) context).setAttribute(property, value);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n+++ b/src/java/org/apache/commons/jxpath/util/ReverseComparator.java\n  * @author Dmitri Plotnikov\n  * @version $Revision$ $Date$\n  */\n-public class ReverseComparator implements Comparator {\n+public final class ReverseComparator implements Comparator {\n     /**\n      * Singleton reverse comparator instance.\n      */\n     public static final Comparator INSTANCE = new ReverseComparator();\n \n+    /**\n+     * Create a new ReverseComparator.\n+     */\n     private ReverseComparator() {\n     }\n \n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n     private static final int UNKNOWN_LENGTH_MAX_COUNT = 16000;\n \n     /**\n-     * Returns true if the object is an array or a Collection\n+     * Returns true if the object is an array or a Collection.\n+     * @param value to test\n+     * @return boolean\n      */\n     public static boolean isCollection(Object value) {\n         if (value == null) {\n      * Returns 1 if the type is a collection,\n      * -1 if it is definitely not\n      * and 0 if it may be a collection in some cases.\n+     * @param clazz to test\n+     * @return int\n      */\n     public static int getCollectionHint(Class clazz) {\n         if (clazz.isArray()) {\n      * Otherwise, attempts to guess the length of the collection by\n      * calling the indexed get method repeatedly.  The method is supposed\n      * to throw an exception if the index is out of bounds.\n-     */\n-    public static int getIndexedPropertyLength(\n-        Object object,\n-        IndexedPropertyDescriptor pd)\n-    {\n+     * @param object collection\n+     * @param pd IndexedPropertyDescriptor\n+     * @return int\n+     */\n+    public static int getIndexedPropertyLength(Object object,\n+            IndexedPropertyDescriptor pd) {\n         if (pd.getReadMethod() != null) {\n             return getLength(getValue(object, pd));\n         }\n     /**\n      * Returns the length of the supplied collection. If the supplied object\n      * is not a collection, returns 1. If collection is null, returns 0.\n+     * @param collection to check\n+     * @return int\n      */\n     public static int getLength(Object collection) {\n         if (collection == null) {\n      * Returns an iterator for the supplied collection. If the argument\n      * is null, returns an empty iterator. If the argument is not\n      * a collection, returns an iterator that produces just that one object.\n+     * @param collection to iterate\n+     * @return Iterator\n      */\n     public static Iterator iterate(Object collection) {\n         if (collection == null) {\n     /**\n      * Grows the collection if necessary to the specified size. Returns\n      * the new, expanded collection.\n+     * @param collection to expand\n+     * @param size desired size\n+     * @return collection or array\n      */\n     public static Object expandCollection(Object collection, int size) {\n         if (collection == null) {\n             return null;\n+        }\n+        if (size < getLength(collection)) {\n+            throw new JXPathException(\"adjustment of \" + collection\n+                    + \" to size \" + size + \" is not an expansion\");\n         }\n         if (collection.getClass().isArray()) {\n             Object bigger =\n     }\n \n     /**\n-     * Returns the index'th element from the supplied collection.\n+     * Remove the index'th element from the supplied collection.\n+     * @param collection to edit\n+     * @param index int\n+     * @return the resulting collection\n      */\n     public static Object remove(Object collection, int index) {\n         collection = getValue(collection);\n         if (collection == null) {\n             return null;\n+        }\n+        if (index >= getLength(collection)) {\n+            throw new JXPathException(\"No such element at index \" + index);\n         }\n         if (collection.getClass().isArray()) {\n             int length = Array.getLength(collection);\n \n     /**\n      * Returns the index'th element of the supplied collection.\n+     * @param collection to read\n+     * @param index int\n+     * @return collection[index]\n      */\n     public static Object getValue(Object collection, int index) {\n         collection = getValue(collection);\n     /**\n      * Modifies the index'th element of the supplied collection.\n      * Converts the value to the required type if necessary.\n+     * @param collection to edit\n+     * @param index to replace\n+     * @param value new value\n      */\n     public static void setValue(Object collection, int index, Object value) {\n         collection = getValue(collection);\n             }\n             else if (collection instanceof Collection) {\n                 throw new UnsupportedOperationException(\n-                    \"Cannot set value of an element of a \"\n-                        + collection.getClass().getName());\n+                        \"Cannot set value of an element of a \"\n+                                + collection.getClass().getName());\n             }\n         }\n     }\n     /**\n      * Returns the value of the bean's property represented by\n      * the supplied property descriptor.\n-     */\n-    public static Object getValue(\n-        Object bean,\n-        PropertyDescriptor propertyDescriptor)\n-    {\n+     * @param bean to read\n+     * @param propertyDescriptor indicating what to read\n+     * @return Object value\n+     */\n+    public static Object getValue(Object bean,\n+            PropertyDescriptor propertyDescriptor) {\n         Object value;\n         try {\n             Method method =\n     /**\n      * Modifies the value of the bean's property represented by\n      * the supplied property descriptor.\n-     */\n-    public static void setValue(\n-        Object bean,\n-        PropertyDescriptor propertyDescriptor,\n-        Object value)\n-    {\n+     * @param bean to read\n+     * @param propertyDescriptor indicating what to read\n+     * @param value to set\n+     */\n+    public static void setValue(Object bean,\n+            PropertyDescriptor propertyDescriptor, Object value) {\n         try {\n             Method method =\n                 getAccessibleMethod(propertyDescriptor.getWriteMethod());\n         }\n     }\n \n+    /**\n+     * Convert value to type.\n+     * @param value Object\n+     * @param type destination\n+     * @return conversion result\n+     */\n     private static Object convert(Object value, Class type) {\n         try {\n             return TypeUtils.convert(value, type);\n     /**\n      * Returns the index'th element of the bean's property represented by\n      * the supplied property descriptor.\n-     */\n-    public static Object getValue(\n-        Object bean,\n-        PropertyDescriptor propertyDescriptor,\n-        int index)\n-    {\n+     * @param bean to read\n+     * @param propertyDescriptor indicating what to read\n+     * @param index int\n+     * @return Object\n+     */\n+    public static Object getValue(Object bean,\n+            PropertyDescriptor propertyDescriptor, int index) {\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n                 IndexedPropertyDescriptor ipd =\n      * Modifies the index'th element of the bean's property represented by\n      * the supplied property descriptor. Converts the value to the required\n      * type if necessary.\n-     */\n-    public static void setValue(\n-        Object bean,\n-        PropertyDescriptor propertyDescriptor,\n-        int index,\n-        Object value)\n-    {\n+     * @param bean to edit\n+     * @param propertyDescriptor indicating what to set\n+     * @param index int\n+     * @param value to set\n+     */\n+    public static void setValue(Object bean,\n+            PropertyDescriptor propertyDescriptor, int index, Object value) {\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n                 IndexedPropertyDescriptor ipd =\n     /**\n      * If the parameter is a container, opens the container and\n      * return the contents.  The method is recursive.\n+     * @param object to read\n+     * @return Object\n      */\n     public static Object getValue(Object object) {\n         while (object instanceof Container) {\n     /**\n      * Returns a shared instance of the dynamic property handler class\n      * returned by <code>getDynamicPropertyHandlerClass()</code>.\n-     */\n-    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz)\n-    {\n+     * @param clazz to handle\n+     * @return DynamicPropertyHandler\n+     */\n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) {\n         DynamicPropertyHandler handler =\n             (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz);\n         if (handler == null) {\n      * can be found, return <code>null</code>.\n      *\n      * @param method The method that we wish to call\n+     * @return Method\n      */\n     public static Method getAccessibleMethod(Method method) {\n \n                     return clazz.getDeclaredMethod(name, parameterTypes);\n                 }\n                 catch (NoSuchMethodException e) {\n-                    ;\n                 }\n             }\n         }\n         return null;\n     }\n-\n \n     /**\n      * Return an accessible method (that is, one that can be invoked via\n      * @param clazz Parent class for the interfaces to be checked\n      * @param methodName Method name of the method we wish to call\n      * @param parameterTypes The parameter type signatures\n-     */\n-    private static Method getAccessibleMethodFromInterfaceNest(\n-        Class clazz,\n-        String methodName,\n-        Class parameterTypes[])\n-    {\n+     * @return Method\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest(Class clazz,\n+            String methodName, Class[] parameterTypes) {\n \n         Method method = null;\n \n         // Check the implemented interfaces of the parent class\n-        Class interfaces[] = clazz.getInterfaces();\n+        Class[] interfaces = clazz.getInterfaces();\n         for (int i = 0; i < interfaces.length; i++) {\n \n             // Is this interface public?\n                     interfaces[i].getDeclaredMethod(methodName, parameterTypes);\n             }\n             catch (NoSuchMethodException e) {\n-                ;\n             }\n             if (method != null) {\n                 break;", "timestamp": 1202069964, "metainfo": ""}