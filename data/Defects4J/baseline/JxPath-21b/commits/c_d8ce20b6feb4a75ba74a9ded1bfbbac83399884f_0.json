{"sha": "d8ce20b6feb4a75ba74a9ded1bfbbac83399884f", "log": "checkstyle  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathInvalidSyntaxException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathInvalidSyntaxException.java\n public class JXPathInvalidSyntaxException extends JXPathException {\n     private static final long serialVersionUID = 504555366032561816L;\n \n+    /**\n+     * Create a new JXPathInvalidSyntaxException.\n+     * @param message relevant message\n+     */\n     public JXPathInvalidSyntaxException(String message) {\n         super(message);\n     }\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n      * For example, in the case of an XML element, getValue() will\n      * return the text contained by the element rather than \n      * the element itself.\n+     * @return Object value\n      */\n     Object getValue();\n \n      * \n      * For example, for an XML element, getNode() will\n      * return the element itself rather than the text it contains.\n+     * @return Object node\n      */\n     Object getNode();\n \n     /**\n      * Modifies the value of the object, property or collection element\n      * this pointer represents.\n+     * @param value value to set\n      */\n     void setValue(Object value);\n \n     /**\n-     * Returns the node this pointer is based on. \n+     * Returns the node this pointer is based on.\n+     * @return  \n      */\n     Object getRootNode();\n     \n--- a/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java\n  */\n public interface NodeIterator {\n \n+    /**\n+     * Get the current iterator position.\n+     * @return int position\n+     */\n     int getPosition();\n \n     /**\n-     * Sets the new current position and returns true if there a node\n-     * at that position.\n+     * Set the new current position.\n+     * @param position the position to set\n+     * @return <code>true</code> if there is a node at <code>position</code>.\n      */\n     boolean setPosition(int position);\n \n+    /**\n+     * Get the NodePointer at the current position.\n+     * @return NodePointer\n+     */\n     NodePointer getNodePointer();\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n  */\n public abstract class NodePointer implements Pointer {\n \n+    /** Whole collection index. */\n     public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n+\n+    /** Constant to indicate unknown namespace */\n+    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n+\n+    /** Index for this NodePointer */\n     protected int index = WHOLE_COLLECTION;\n-    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n     private boolean attribute = false;\n     private transient Object rootNode;\n     private NamespaceResolver namespaceResolver;\n \n     /**\n      * Returns the name of this node. Can be null.\n+     * @return QName\n      */\n     public abstract QName getName();\n \n      * Returns the value represented by the pointer before indexing.\n      * So, if the node represents an element of a collection, this\n      * method returns the collection itself.\n+     * @return Object value\n      */\n     public abstract Object getBaseValue();\n \n     /**\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n-     *\n+     * @return Object node value\n      * @deprecated 1.1 Please use getNode()\n      */\n     public Object getNodeValue() {\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type. Opens containers, properties etc and returns\n      * the ultimate contents.\n+     * @return Object node\n      */\n     public Object getNode() {\n         return getValuePointer().getImmediateNode();\n     }\n-    \n+\n+    /**\n+     * Get the root node.\n+     * @return Object value of this pointer's root (top parent).\n+     */\n     public Object getRootNode() {\n         if (rootNode == null) {\n             rootNode = parent == null ? getImmediateNode() : parent.getRootNode();\n     /**\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n+     * @return Object node\n      */\n     public abstract Object getImmediateNode();\n \n     /**\n      * Converts the value to the required type and changes the corresponding\n      * object to that value.\n+     * @param value the value to set\n      */\n     public abstract void setValue(Object value);\n \n     /**\n      * Compares two child NodePointers and returns a positive number,\n      * zero or a positive number according to the order of the pointers.\n+     * @param pointer1 first pointer to be compared\n+     * @param pointer2 second pointer to be compared\n+     * @return int per Java comparison conventions\n      */\n     public abstract int compareChildNodePointers(\n             NodePointer pointer1, NodePointer pointer2);\n \n     /**\n      * Checks if this Pointer matches the supplied NodeTest.\n+     * @param test the NodeTest to execute\n+     * @return true if a match\n      */\n     public boolean testNode(NodeTest test) {\n         if (test == null) {\n                 && ((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE && isNode();\n     }\n \n+    /**\n+     * Compare two strings, either of which may be null, for equality.\n+     * @param s1 the first String to compare\n+     * @param s2 the second String to compare\n+     * @return true if both Strings are null, same or equal\n+     */\n     private static boolean equalStrings(String s1, String s2) {\n         return s1 == s2 || s1 != null && s1.equals(s2);\n     }\n     /**\n      *  Called directly by JXPathContext. Must create path and\n      *  set value.\n+     *  @param context the owning JXPathContext\n+     *  @param value the new value to set\n+     *  @return created NodePointer \n      */\n     public NodePointer createPath(JXPathContext context, Object value) {\n         setValue(value);\n      * Called by a child pointer when it needs to create a parent object.\n      * Must create an object described by this pointer and return\n      * a new pointer that properly describes the new object.\n+     * @param context the owning JXPathContext\n+     * @return created NodePointer\n      */\n     public NodePointer createPath(JXPathContext context) {\n         return this;\n      * supplied in the createPath(context, value) call to a non-existent\n      * node. This method may have to expand the collection in order to assign\n      * the element.\n+     * @param context the owning JXPathCOntext\n+     * @param name the QName at which a child should be created\n+     * @param index child index.\n+     * @param value node value to set\n+     * @return created NodePointer\n      */\n     public NodePointer createChild(\n         JXPathContext context,\n      * non-existent collection element. It may have to expand the collection,\n      * then create an element object and return a new pointer describing the\n      * newly created element.\n+     * @param context the owning JXPathCOntext\n+     * @param name the QName at which a child should be created\n+     * @param index child index.\n+     * @return created NodePointer\n      */\n     public NodePointer createChild(JXPathContext context, QName name, int index)\n     {\n     \n     /**\n      * Called to create a non-existing attribute\n+     * @param context the owning JXPathCOntext\n+     * @param name the QName at which an attribute should be created\n+     * @return created NodePointer\n      */\n     public NodePointer createAttribute(JXPathContext context, QName name) {\n         throw new JXPathException(\"Cannot create an attribute for path \"\n     /**\n      * If the Pointer has a parent, returns the parent's locale; otherwise\n      * returns the locale specified when this Pointer was created.\n+     * @return Locale for this NodePointer\n      */\n     public Locale getLocale() {\n         if (locale == null) {\n     }\n \n     /**\n-     * Returns true if the selected locale name starts\n+     * Check whether our locale matches the specified language.\n+     * @param lang String language to check\n+     * @return true if the selected locale name starts\n      * with the specified prefix <i>lang</i>, case-insensitive.\n      */\n     public boolean isLanguage(String lang) {\n     /**\n      * Returns a NodeIterator that iterates over all children or all children\n      * that match the given NodeTest, starting with the specified one.\n+     * @param test NodeTest to filter children\n+     * @param reverse specified iteration direction\n+     * @param startWith the NodePointer to start with\n+     * @return NodeIterator\n      */\n     public NodeIterator childIterator(\n         NodeTest test,\n      * Returns a NodeIterator that iterates over all attributes of the current\n      * node matching the supplied node name (could have a wildcard).\n      * May return null if the object does not support the attributes.\n+     * @param qname the attribute name to test\n+     * @return NodeIterator\n      */\n     public NodeIterator attributeIterator(QName qname) {\n         NodePointer valuePointer = getValuePointer();\n      * Returns a NodeIterator that iterates over all namespaces of the value\n      * currently pointed at.\n      * May return null if the object does not support the namespaces.\n+     * @return NodeIterator\n      */\n     public NodeIterator namespaceIterator() {\n         return null;\n      * Returns a NodePointer for the specified namespace. Will return null\n      * if namespaces are not supported.\n      * Will return UNKNOWN_NAMESPACE if there is no such namespace.\n+     * @param namespace incoming namespace\n+     * @return NodePointer for <code>namespace</code>\n      */\n     public NodePointer namespacePointer(String namespace) {\n         return null;\n \n     /**\n      * Decodes a namespace prefix to the corresponding URI.\n+     * @param prefix prefix to decode\n+     * @return String uri\n      */\n     public String getNamespaceURI(String prefix) {\n         return null;\n \n     /**\n      * Returns the namespace URI associated with this Pointer.\n+     * @return String uri\n      */\n     public String getNamespaceURI() {\n         return null;\n     /**\n      * Returns true if the supplied prefix represents the\n      * default namespace in the context of the current node.\n+     * @param prefix the prefix to check\n+     * @return <code>true</code> if prefix is default\n      */\n     protected boolean isDefaultNamespace(String prefix) {\n         if (prefix == null) {\n         return namespace != null && namespace.equals(getDefaultNamespaceURI());\n     }\n \n+    /**\n+     * Get the default ns uri\n+     * @return String uri\n+     */\n     protected String getDefaultNamespaceURI() {\n         return null;\n     }\n \n     /**\n      * Locates a node by ID.\n+     * @param context JXPathContext owning context\n+     * @param id String id\n+     * @return Pointer found\n      */\n     public Pointer getPointerByID(JXPathContext context, String id) {\n         return context.getPointerByID(id);\n \n     /**\n      * Locates a node by key and value.\n+     * @param context owning JXPathContext\n+     * @param key key to search for\n+     * @param value value to match\n+     * @return Pointer found\n      */\n     public Pointer getPointerByKey(\n         JXPathContext context,\n \n     /**\n      * Find a NodeSet by key/value.\n-     * @param context\n-     * @param key\n-     * @param value\n-     * @return NodeSet\n+     * @param context owning JXPathContext\n+     * @param key key to search for\n+     * @param value value to match\n+     * @return NodeSet found\n      */\n     public NodeSet getNodeSetByKey(JXPathContext context, String key, Object value) {\n         return context.getNodeSetByKey(key, value);\n \n     /**\n      * Returns an XPath that maps to this Pointer.\n+     * @return String xpath expression\n      */\n     public String asPath() {\n         // If the parent of this node is a container, it is responsible\n         return buffer.toString();\n     }\n \n+    /**\n+     * Clone this NodePointer.\n+     * @return cloned NodePointer\n+     */\n     public Object clone() {\n         try {\n             NodePointer ptr = (NodePointer) super.clone();\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public String toString() {\n         return asPath();\n     }\n \n+    \n     public int compareTo(Object object) {\n         if (object == this) {\n             return 0;\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n public class JDOMAttributePointer extends NodePointer {\n     private Attribute attr;\n \n+    /**\n+     * Create a JDOMAttributePointer.\n+     * @param parent NodePointer parent\n+     * @param attr JDOM Attribute\n+     */\n     public JDOMAttributePointer(NodePointer parent, Attribute attr) {\n         super(parent);\n         this.attr = attr;\n \n     public Object getValue() {\n         return attr.getValue();\n-    }    \n-    \n+    }\n+\n     public Object getBaseValue() {\n         return attr;\n     }\n-    \n+\n     public boolean isCollection() {\n         return false;\n     }\n \n     public int getLength() {\n         return 1;\n-    }    \n+    }\n \n     public Object getImmediateNode() {\n         return attr;\n \n     public int compareChildNodePointers(\n             NodePointer pointer1,\n-            NodePointer pointer2) \n-    {\n+            NodePointer pointer2) {\n         // Won't happen - attributes don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n     private Set prefixes;\n     private int position = 0;\n \n+    /**\n+     * Create a new JDOMNamespaceIterator.\n+     * @param parent the parent NodePointer.\n+     */\n     public JDOMNamespaceIterator(NodePointer parent) {\n         this.parent = parent;\n         Object node = parent.getNode();\n         if (node instanceof Document) {\n-            node = ((Document)node).getRootElement();\n+            node = ((Document) node).getRootElement();\n         }\n         if (node instanceof Element) {\n             namespaces = new ArrayList();\n         }\n     }\n \n+    /**\n+     * Collect the namespaces from a JDOM Element.\n+     * @param element the source Element\n+     */\n     private void collectNamespaces(Element element) {\n         Namespace ns = element.getNamespace();\n         if (ns != null && !prefixes.contains(ns.getPrefix())) {\n                 prefixes.add(ns.getPrefix());\n             }\n         }\n-        Object parent = element.getParent();\n-        if (parent instanceof Element) {\n-            collectNamespaces((Element)parent);\n+        Object elementParent = element.getParent();\n+        if (elementParent instanceof Element) {\n+            collectNamespaces((Element) elementParent);\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public NodePointer getNodePointer() {\n         if (position == 0) {\n             if (!setPosition(1)) {\n         return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int getPosition() {\n         return position;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean setPosition(int position) {\n         if (namespaces == null) {\n             return false;", "timestamp": 1196894911, "metainfo": ""}