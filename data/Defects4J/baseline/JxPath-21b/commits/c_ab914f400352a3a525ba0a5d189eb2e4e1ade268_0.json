{"sha": "ab914f400352a3a525ba0a5d189eb2e4e1ade268", "log": "Documentation clean-up and removal of deprecated methods   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.3 2002/04/24 03:29:33 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 03:29:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.4 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * return true to indicate that the factory has successfully created the described object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 03:29:33 $\n+ * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:22 $\n  */\n public abstract class AbstractFactory {\n \n     }\n \n     /**\n-     * Create a new object and set it on the specified variable\n+     * Declare the specified variable\n      * \n      * @param context hosts variable pools. See {@link JXPathContext#getVariables() \n      *        JXPathContext.getVariables()}\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.4 2002/04/24 03:29:33 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 03:29:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.5 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.functions.ConstructorFunction;\n import org.apache.commons.jxpath.functions.MethodFunction;\n-import org.apache.commons.jxpath.util.TypeUtils;\n+import org.apache.commons.jxpath.util.MethodLookupUtils;\n \n /**\n  * Extension functions provided by a Java class.\n  * the method.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 03:29:33 $\n+ * @version $Revision: 1.5 $ $Date: 2002/06/16 03:22:22 $\n  */\n public class ClassFunctions implements Functions {\n     private Class functionClass;\n \n     /**\n      * Returns a set of one namespace - the one specified in the constructor.\n-     * \n+     *\n      * @returns a singleton\n      */\n     public Set getUsedNamespaces(){\n     /**\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n-     * \n+     *\n      * @param namespace if it is not the namespace specified in the constructor,\n      *     the method returns null\n      * @param name is a function name or \"new\" for a constructor.\n-     * \n+     *\n      * @return a MethodFunction, a ConstructorFunction or null if there is no\n      *      such function.\n      */\n \n         if (name.equals(\"new\")) {\n             Constructor constructor =\n-                TypeUtils.lookupConstructor(functionClass, parameters);\n+                MethodLookupUtils.lookupConstructor(functionClass, parameters);\n             if (constructor != null) {\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n-            Method method = TypeUtils.lookupStaticMethod(functionClass, name, parameters);\n+            Method method = MethodLookupUtils.\n+                lookupStaticMethod(functionClass, name, parameters);\n             if (method != null) {\n                 return new MethodFunction(method);\n             }\n \n-            method = TypeUtils.lookupMethod(functionClass, name, parameters);\n+            method = MethodLookupUtils.\n+                lookupMethod(functionClass, name, parameters);\n             if (method != null) {\n                 return new MethodFunction(method);\n             }\n--- a/src/java/org/apache/commons/jxpath/CompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/CompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/CompiledExpression.java,v 1.2 2002/05/08 23:05:05 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/05/08 23:05:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/CompiledExpression.java,v 1.3 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * JXPathContext.compile}\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/05/08 23:05:05 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:22 $\n  */\n public interface CompiledExpression {\n \n     void setValue(JXPathContext context, Object value);\n \n     /**\n+     * Creates intermediate elements of\n+     * the path by invoking an AbstractFactory, which should first be\n+     * installed on the context by calling \"setFactory\".\n+     */\n+    Pointer createPath(JXPathContext context);\n+\n+    /**\n      * The same as setValue, except it creates intermediate elements of\n      * the path by invoking an AbstractFactory, which should first be\n      * installed on the context by calling \"setFactory\".\n      * </ul>\n      */\n     Pointer createPathAndSetValue(JXPathContext context, Object value);\n-\n-    /**\n-     * @deprecated switch to createPathAndSetValue\n-     */\n-    void createPath(JXPathContext context, Object value);\n \n     /**\n      * Traverses the xpath and returns a Iterator of all results found\n--- a/src/java/org/apache/commons/jxpath/Container.java\n+++ b/src/java/org/apache/commons/jxpath/Container.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Container.java,v 1.2 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Container.java,v 1.3 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * mechanism transparent to JXPath.  For example, if property\n  * \"foo\" of the context node has a Container as its value,\n  * the XPath \"foo\" will produce the contents of that Container,\n- * not the container itself.\n+ * rather than the container itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:41 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:22 $\n  */\n public interface Container {\n \n--- a/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/DynamicPropertyHandler.java,v 1.2 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * <ol>\n  * <li>Build an implementation of the DynamicPropertyHandler interface\n  * for the desired collection type.</li>\n- * <li>Invoke static method {@link JXPathIntrospector#registerDynamicClass\n+ * <li>Invoke the static method {@link JXPathIntrospector#registerDynamicClass\n  * JXPathIntrospector.registerDynamicClass(class, handlerClass)}</li>\n  * </ol>\n  * JXPath allows access to dynamic properties using these three formats:\n  * </ul>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2002/06/16 03:22:22 $\n  */\n public interface DynamicPropertyHandler {\n \n--- a/src/java/org/apache/commons/jxpath/Functions.java\n+++ b/src/java/org/apache/commons/jxpath/Functions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Functions.java,v 1.2 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Functions.java,v 1.3 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.Set;\n \n /**\n- * A group of Function objects sharing a common namespace. Use classes\n+ * A group of Function objects sharing a common namespace or a set of\n+ * common namespaces. Use the classes\n  * {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}\n  * to register extension functions implemented as Java methods.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:41 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:22 $\n  */\n public interface Functions {\n \n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.4 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * See java.beans.BeanInfo, java.beans.Introspector\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:22 $\n  */\n public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n     private boolean atomic = false;\n                 propertyNames[i] = pds[i].getName();\n             }\n         }\n-//        int inx = Arrays.binarySearch(propertyNames, propertyName);\n-//        if (inx < 0){\n-//            return null;\n-//        }\n+\n         for (int i = 0; i < propertyNames.length; i++){\n             if (propertyNames[i] == propertyName){\n                 return propertyDescriptors[i];\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.10 2002/06/08 22:47:24 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/06/08 22:47:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.11 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * allocating JXPathContext directly, you should call a static <code>newContext</code>\n  * method.  This method will utilize the JXPathContextFactory API to locate\n  * a suitable implementation of JXPath.\n- * JXPath comes bundled with a default implementation called Reference Implementation.\n+ * Bundled with JXPath comes a default implementation called\n+ * Reference Implementation.\n  * </p>\n  *\n  * <h2>JXPath Interprets XPath Syntax on Java Object Graphs</h2>\n  *     like \"para[@type='warning']\" are legitimate, they will always produce empty results.\n  *     The only attribute supported for JavaBeans is \"name\".  The XPath \"foo/bar\" is\n  *     equivalent to \"foo[@name='bar']\".\n- * <li>The current version of JXPath does not support the <code>id(string)</code>\n- *     and <code>key(key, value)</code> XPath functions.\n  * </ul>\n  *\n  * See <a href=\"http://www.w3schools.com/xpath\">XPath Tutorial by W3Schools</a><br>\n- * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath) Version 1.0 </a>\n+ * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath)\n+ *    Version 1.0 </a><br><br>\n+ * You will also find more information and examples in\n+ * <a href=\"http://jakarta.apache.org/commons/jxpath/users-guide.html\">\n+ * JXPath User's Guide</a>\n+ *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/06/08 22:47:24 $\n+ * @version $Revision: 1.11 $ $Date: 2002/06/16 03:22:22 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n     private static JXPathContext compilationContext;\n \n     /**\n-     * Creates a new JXPathContext with the specified bean as the root node.\n+     * Creates a new JXPathContext with the specified object as the root node.\n      */\n     public static JXPathContext newContext(Object contextBean){\n         return JXPathContextFactory.newInstance().newContext(null, contextBean);\n      */\n     public abstract Pointer getContextPointer();\n \n+    /**\n+     * Installs a custom implementation of the Variables interface.\n+     */\n     public void setVariables(Variables vars){\n         this.vars = vars;\n     }\n \n     /**\n      * Returns the variable pool associated with the context. If no such\n-     * pool was specified during the construction of the context,\n-     * returns the default implementation of Variables, {@link BasicVariables BasicVariables}.\n+     * pool was specified with the <code>setVariables()</code> method,\n+     * returns the default implementation of Variables,\n+     * {@link BasicVariables BasicVariables}.\n      */\n     public Variables getVariables(){\n         if (vars == null){\n         return vars;\n     }\n \n+    /**\n+     * Install a library of extension functions.\n+     *\n+     * @see FunctionLibrary\n+     */\n     public void setFunctions(Functions functions){\n         this.functions = functions;\n     }\n \n+    /**\n+     * Returns the set of functions installed on the context.\n+     */\n     public Functions getFunctions(){\n-        // TBD: default lib\n         return functions;\n     }\n \n+    /**\n+     * Install an abstract factory that should be used by the\n+     * <code>createPath()</code> and <code>createPathAndSetValue()</code>\n+     * methods.\n+     */\n     public void setFactory(AbstractFactory factory){\n         this.factory = factory;\n     }\n \n     /**\n      * Returns the AbstractFactory installed on this context.\n-     * If none has been installed, it calls getFactory() on\n-     * the parent context.\n+     * If none has been installed and this context has a parent context,\n+     * returns the parent's factory.  Otherwise returns null.\n      */\n     public AbstractFactory getFactory(){\n         if (factory == null && parentContext != null){\n     }\n \n     /**\n-     * Returns the locale set with setLocale or Locale.getDefault()\n-     * by default.\n+     * Returns the locale set with setLocale. If none was set and\n+     * the context has a parent, returns the parent's locale.\n+     * Otherwise, returns Locale.getDefault().\n      */\n     protected Locale getLocale(){\n         if (locale == null){\n \n     /**\n      * Overridden by each concrete implementation of JXPathContext\n-     * to perform compilation.\n+     * to perform compilation. Is called by <code>compile()</code>.\n      */\n     protected abstract CompiledExpression compilePath(String xpath);\n \n      * </ul>\n      */\n     public abstract void setValue(String xpath, Object value);\n-\n \n     /**\n      * Creates missing elements of the path by invoking an AbstractFactory,\n     public abstract void removeAll(String xpath);\n \n     /**\n-     * @deprecated please use createPathAndSetValue(xpath, value)\n-     */\n-    public void createPath(String xpath, Object value){\n-        createPathAndSetValue(xpath, value);\n-    }\n-\n-    /**\n-     * @deprecated Please use iterate\n-     */\n-    public List eval(String xpath){\n-        ArrayList list = new ArrayList();\n-        Iterator it = iterate(xpath);\n-        while (it.hasNext()){\n-            list.add(it.next());\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Traverses the xpath and returns a Iterator of all results found\n+     * Traverses the xpath and returns an Iterator of all results found\n      * for the path. If the xpath matches no properties\n-     * in the graph, the Iterator will not be null.\n+     * in the graph, the Iterator will be empty, but not null.\n      */\n     public abstract Iterator iterate(String xpath);\n-\n-\n-    /**\n-     * @deprecated Please use getPointer(String xpath)\n-     */\n-    public Pointer locateValue(String xpath){\n-        return getPointer(xpath);\n-    }\n \n     /**\n      * Traverses the xpath and returns a Pointer.\n     public abstract Pointer getPointer(String xpath);\n \n     /**\n-     * @deprecated Please use iteratePointers\n-     */\n-    public List locate(String xpath){\n-        ArrayList list = new ArrayList();\n-        Iterator it = iteratePointers(xpath);\n-        while (it.hasNext()){\n-            list.add(it.next());\n-        }\n-        return list;\n-    }\n-\n-    /**\n      * Traverses the xpath and returns an Iterator of Pointers.\n      * A Pointer provides easy access to a property.\n      * If the xpath matches no properties\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.5 2002/04/26 03:28:36 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/04/26 03:28:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.6 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.functions.ConstructorFunction;\n import org.apache.commons.jxpath.functions.MethodFunction;\n-import org.apache.commons.jxpath.util.TypeUtils;\n+import org.apache.commons.jxpath.util.MethodLookupUtils;\n \n /**\n  * Extension functions provided by Java classes.  The class prefix specified\n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/04/26 03:28:36 $\n+ * @version $Revision: 1.6 $ $Date: 2002/06/16 03:22:22 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n                 }\n             }\n             if (target != null) {\n-                Method method = TypeUtils.lookupMethod(target.getClass(), name, parameters);\n+                Method method = MethodLookupUtils.\n+                    lookupMethod(target.getClass(), name, parameters);\n                 if (method != null) {\n                     return new MethodFunction(method);\n                 }\n \n         if (methodName.endsWith(\"new\")) {\n             Constructor constructor =\n-                TypeUtils.lookupConstructor(functionClass, parameters);\n+                MethodLookupUtils.lookupConstructor(functionClass, parameters);\n             if (constructor != null) {\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n             Method method =\n-                TypeUtils.lookupStaticMethod(functionClass, methodName, parameters);\n+                MethodLookupUtils.\n+                    lookupStaticMethod(functionClass, methodName, parameters);\n             if (method != null) {\n                 return new MethodFunction(method);\n             }\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 03:29:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.3 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n /**\n  * Pointers represent locations of objects and their properties\n  * in Java object graphs. JXPathContext has methods\n- * ({@link JXPathContext#locate(java.lang.String) locate()}\n- * and ({@link JXPathContext#locateValue(java.lang.String) locateValue()}\n- * that, given an XPath, produce Pointers for the objects or properties\n- * described the the path. For example, <code>ctx.locateValue(\"foo/bar\")</code>\n+ * ({@link JXPathContext#getPointer(java.lang.String) getPointer()}\n+ * and ({@link JXPathContext#iteratePointers(java.lang.String) iteratePointers()},\n+ * which, given an XPath, produce Pointers for the objects or properties\n+ * described the the path. For example, <code>ctx.getPointer(\"foo/bar\")</code>\n  * will produce a Pointer that can get and set the property \"bar\" of\n  * the object which is the value of the property \"foo\" of the root object.\n- * The value of <code>ctx.locateValue(\"aMap/aKey[3]\")</code> will be a pointer\n+ * The value of <code>ctx.getPointer(\"aMap/aKey[3]\")</code> will be a pointer\n  * to the 3'rd element of the array, which is the value for the key \"aKey\" of\n  * the map, which is the value of the property \"aMap\" of the root object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:22 $\n  */\n public interface Pointer {\n \n     void setValue(Object value);\n \n     /**\n-     * Returns a string that is a proper XPath that corresponds to\n+     * Returns a string that is a proper \"canonical\" XPath that corresponds to\n      * this pointer.  Consider this example:\n-     * <p><code>Pointer ptr = ctx.locateValue(\"//employees[firstName = 'John']\")</code>\n+     * <p><code>Pointer ptr = ctx.getPointer(\"//employees[firstName = 'John']\")</code>\n      * <p>The value of <code>ptr.asPath()</code> will look something like\n      * <code>\"/departments[2]/employees[3]\"</code>, so, basically, it represents the\n      * concrete location(s) of the result of a search performed by JXPath.\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.15 2002/05/29 00:41:33 dmitri Exp $\n- * $Revision: 1.15 $\n- * $Date: 2002/05/29 00:41:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.16 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2002/05/29 00:41:33 $\n+ * @version $Revision: 1.16 $ $Date: 2002/06/16 03:22:21 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n     }\n \n     /**\n-     * Returns the list of all Pointers in this context\n+     * Returns the list of all Pointers in this context for the current\n+     * position of the parent context.\n      */\n     public List getContextNodeList() {\n         int pos = position;\n     }\n \n     /**\n-     * Returns the list of all node values in this context\n+     * Returns the list of all Pointers in this context for all positions\n+     * of the parent contexts.\n      */\n     public List getPointerList() {\n         int pos = position;\n         return list;\n     }\n \n-    /**\n-     * Returns the list of all node values in this context\n-     */\n-    public List getValueList() {\n-        int pos = position;\n-        if (pos != 0) {\n-            reset();\n-        }\n-        List list = new ArrayList();\n-        while (nextSet()){\n-            while (nextNode()) {\n-                list.add(getCurrentNodePointer().getValue());\n-            }\n-        }\n-        if (pos != 0) {\n-            setPosition(pos);\n-        }\n-        else {\n-            reset();\n-        }\n-        return list;\n-    }\n-\n     public String toString() {\n         Pointer ptr = getContextNodePointer();\n         if (ptr == null) {\n             return \"Expression context [\" + getPosition() + \"] \" + ptr.asPath();\n         }\n     }\n+\n     /**\n      * Returns the root context of the path, which provides easy\n      * access to variables and functions.\n--- a/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java,v 1.2 2002/06/08 22:43:15 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/08 22:43:15 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java,v 1.3 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n+ * Type conversions, XPath style.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/06/08 22:43:15 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class InfoSetUtil {\n \n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.3 2002/06/09 01:58:41 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/06/09 01:58:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.4 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/06/09 01:58:41 $\n+ * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class JXPathCompiledExpression implements CompiledExpression {\n \n     }\n \n     /**\n-     * @see CompiledExpression#createPath(JXPathContext, Object)\n+     * @see CompiledExpression#createPath(JXPathContext)\n+     */\n+    public Pointer createPath(JXPathContext context) {\n+        return ((JXPathContextReferenceImpl)context).\n+                    createPath(xpath, expression);\n+    }\n+\n+    /**\n+     * @see CompiledExpression#createPathAndSetValue(JXPathContext, Object)\n      */\n     public Pointer createPathAndSetValue(JXPathContext context, Object value) {\n         return ((JXPathContextReferenceImpl)context).\n                     createPathAndSetValue(xpath, expression, value);\n-    }\n-\n-    /**\n-     * @deprecated use createPathAndSetValue\n-     */\n-    public void createPath(JXPathContext context, Object value) {\n-        createPathAndSetValue(context, value);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/jxpath/ri/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/QName.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/QName.java,v 1.3 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri;\n \n /**\n+ * A qualified name: a combination of an optional namespace prefix\n+ * and an local name.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class QName {\n     private String prefix;\n \n         return true;\n     }\n-\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java,v 1.3 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java,v 1.4 2002/06/16 03:22:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/16 03:22:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:22 $\n  */\n public class PropertyIterator implements NodeIterator {\n     private boolean empty = false;\n \n         String names[] = propertyNodePointer.getPropertyNames();\n         if (!reverse){\n-//            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n             if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n                 startPropertyIndex = 0;\n             }\n             }\n         }\n         else {\n-//            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n             if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n                 startPropertyIndex = names.length - 1;\n             }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.1 2002/06/12 21:02:05 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/06/12 21:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.2 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.*;\n \n /**\n- * The default delegate of JXPathContext that is used for type conversion.\n+ * The default implementation of TypeConverter.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/06/12 21:02:05 $\n+ * @version $Revision: 1.2 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class BasicTypeConverter implements TypeConverter {\n \n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.7 2002/06/12 21:02:05 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/06/12 21:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.8 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Global type conversion utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/06/12 21:02:05 $\n+ * @version $Revision: 1.8 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class TypeUtils {\n     private static TypeConverter typeConverter = new BasicTypeConverter();\n     }\n \n     /**\n-     * @deprecated Use MethodLookupUtils\n+     * Returns true if the global converter can convert the supplied\n+     * object to the specified type.\n      */\n-    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n-        return MethodLookupUtils.lookupConstructor(targetClass, parameters);\n-    }\n-\n-    /**\n-     * @deprecated Use MethodLookupUtils\n-     */\n-    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n-        return MethodLookupUtils.lookupStaticMethod(targetClass, name, parameters);\n-    }\n-\n-    /**\n-     * @deprecated Use MethodLookupUtils\n-     */\n-    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n-        return MethodLookupUtils.lookupMethod(targetClass, name, parameters);\n-    }\n-\n     public static boolean canConvert(Object object, Class toType){\n         return typeConverter.canConvert(object, toType);\n     }\n \n+    /**\n+     * Converts the supplied object to the specified type. May\n+     * throw a RuntimeException.\n+     */\n     public static Object convert(Object object, Class toType){\n         return typeConverter.convert(object, toType);\n     }\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.5 2002/05/08 23:03:28 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/05/08 23:03:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.6 2002/06/16 03:22:21 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/06/16 03:22:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.DynamicPropertyHandler;\n \n /**\n+ * Collection and property access utilities.\n+ *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/05/08 23:03:28 $\n+ * @version $Revision: 1.6 $ $Date: 2002/06/16 03:22:21 $\n  */\n public class ValueUtils {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n \n-    public static boolean isCollection(PropertyDescriptor propertyDescriptor){\n-        return false;\n-    }\n-\n-    public static boolean isCollection(PropertyDescriptor propertyDescriptor, Object value){\n-        return isCollection(value);\n-    }\n-\n+    /**\n+     * Returns true if the object is an array or a Collection\n+     */\n     public static boolean isCollection(Object value){\n         if (value == null){\n             return false;\n         return false;\n     }\n \n-    public static int getLength(Object bean, PropertyDescriptor propertyDescriptor){\n-        Object obj = getValue(bean, propertyDescriptor);\n-        return getLength(obj);\n-    }\n-\n+    /**\n+     * Returns the length of the supplied collection. If the supplied object\n+     * is not a collection, returns 1. If collection is null, returns 0.\n+     */\n     public static int getLength(Object collection){\n         if (collection == null){\n             return 0;\n         }\n     }\n \n+    /**\n+     * Returns an iterator for the supplied collection. If the argument\n+     * is null, returns an empty iterator. If the argument is not\n+     * a collection, returns an iterator that produces just that one object.\n+     */\n     public static Iterator iterate(Object collection){\n         if (collection == null){\n             return Collections.EMPTY_LIST.iterator();\n         }\n     }\n \n+    /**\n+     * Grows the collection if necessary to the specified size. Returns\n+     * the new, expanded collection.\n+     */\n     public static Object expandCollection(Object collection, int size){\n         if (collection == null){\n             return null;\n         }\n         else if (collection.getClass().isArray()){\n-            Object bigger = Array.newInstance(collection.getClass().getComponentType(), size);\n-            System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection));\n+            Object bigger = Array.newInstance(\n+                  collection.getClass().getComponentType(), size);\n+            System.arraycopy(\n+                  collection, 0, bigger, 0, Array.getLength(collection));\n             return bigger;\n         }\n         else if (collection instanceof Collection){\n         }\n     }\n \n+    /**\n+     * Returns the index'th element from the supplied collection.\n+     */\n     public static Object remove(Object collection, int index){\n         if (collection == null){\n             return null;\n         }\n         else if (collection.getClass().isArray()){\n             int length = Array.getLength(collection);\n-            Object smaller = Array.newInstance(collection.getClass().getComponentType(), length-1);\n+            Object smaller = Array.newInstance(\n+                  collection.getClass().getComponentType(), length-1);\n             if (index > 0){\n                 System.arraycopy(collection, 0, smaller, 0, index);\n             }\n         }\n     }\n \n-    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index){\n+    /**\n+     * Returns the index'th element of the supplied collection.\n+     */\n+    public static Object getValue(Object collection, int index){\n+        Object value = collection;\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                if (index < 0 || index >= Array.getLength(collection)){\n+                    return null;\n+                }\n+                value = Array.get(collection, index);\n+            }\n+            else if (collection instanceof List){\n+                if (index < 0 || index >= ((List)collection).size()){\n+                    return null;\n+                }\n+                value = ((List)collection).get(index);\n+            }\n+            else if (collection instanceof Collection){\n+                int i = 0;\n+                Iterator it = ((Collection)collection).iterator();\n+                for (; i < index; i++){\n+                    it.next();\n+                }\n+                if (it.hasNext()){\n+                    value = it.next();\n+                }\n+                else {\n+                    value = null;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Modifies the index'th element of the supplied collection.\n+     * Converts the value to the required type if necessary.\n+     */\n+    public static void setValue(Object collection, int index, Object value){\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                Array.set(collection, index,\n+                    convert(value, collection.getClass().getComponentType()));\n+            }\n+            else if (collection instanceof List){\n+                ((List)collection).set(index, value);\n+            }\n+            else if (collection instanceof Collection){\n+                throw new UnsupportedOperationException(\n+                        \"Cannot set value of an element of a \" +\n+                        collection.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the value of the bean's property represented by\n+     * the supplied property descriptor.\n+     */\n+    public static Object getValue(Object bean,\n+                    PropertyDescriptor propertyDescriptor){\n+        Object value;\n+        try {\n+            Method method =\n+                getAccessibleMethod(propertyDescriptor.getReadMethod());\n+            if (method == null){\n+                throw new JXPathException(\"No read method\");\n+            }\n+            value = method.invoke(bean, new Object[0]);\n+        }\n+        catch (Exception ex){\n+            throw new JXPathException(\n+                \"Cannot access property: \" + propertyDescriptor.getName(), ex);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Modifies the value of the bean's property represented by\n+     * the supplied property descriptor.\n+     */\n+    public static void setValue(Object bean,\n+            PropertyDescriptor propertyDescriptor, Object value){\n+        try {\n+            Method method =\n+                getAccessibleMethod(propertyDescriptor.getWriteMethod());\n+            if (method == null){\n+                throw new JXPathException(\"No write method\");\n+            }\n+            value = convert(value, propertyDescriptor.getPropertyType());\n+            value = method.invoke(bean, new Object[]{value});\n+        }\n+        catch (Exception ex){\n+            ex.printStackTrace();\n+            throw new JXPathException(\n+                \"Cannot modify property: \" + propertyDescriptor.getName(), ex);\n+        }\n+    }\n+\n+    private static Object convert(Object value, Class type){\n+        try {\n+            return TypeUtils.convert(value, type);\n+        }\n+        catch (Exception ex){\n+            throw new JXPathException(\"Cannot convert value of class \" +\n+                    (value == null ? \"null\" : value.getClass().getName()) +\n+                    \" to type \" + type, ex);\n+        }\n+    }\n+\n+    /**\n+     * Returns the index'th element of the bean's property represented by\n+     * the supplied property descriptor.\n+     */\n+    public static Object getValue(Object bean,\n+            PropertyDescriptor propertyDescriptor, int index){\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n             Object value;\n             try {\n-                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                IndexedPropertyDescriptor ipd =\n+                    (IndexedPropertyDescriptor)propertyDescriptor;\n                 Method method = ipd.getIndexedReadMethod();\n                 if (method != null){\n                     return method.invoke(bean, new Object[]{new Integer(index)});\n                     ex);\n             }\n         }\n+\n         // We will fall through if there is no indexed read\n \n         return getValue(getValue(bean, propertyDescriptor), index);\n     }\n \n-    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value){\n+    /**\n+     * Modifies the index'th element of the bean's property represented by\n+     * the supplied property descriptor. Converts the value to the required\n+     * type if necessary.\n+     */\n+    public static void setValue(Object bean,\n+              PropertyDescriptor propertyDescriptor, int index, Object value){\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n             try {\n-                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                IndexedPropertyDescriptor ipd =\n+                      (IndexedPropertyDescriptor)propertyDescriptor;\n                 Method method = ipd.getIndexedWriteMethod();\n                 if (method != null){\n                     method.invoke(bean,\n                 }\n             }\n             catch (Exception ex){\n-                throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n-                    \", \" + ex.getMessage());\n+                throw new RuntimeException(\"Cannot access property: \" +\n+                    propertyDescriptor.getName() + \", \" + ex.getMessage());\n             }\n         }\n         // We will fall through if there is no indexed read\n         setValue(getValue(bean, propertyDescriptor), index, value);\n     }\n \n-    public static Object getValue(Object collection, int index){\n-        Object value = collection;\n-        if (collection != null){\n-            if (collection.getClass().isArray()){\n-                if (index < 0 || index >= Array.getLength(collection)){\n-                    return null;\n-                }\n-                value = Array.get(collection, index);\n-            }\n-            else if (collection instanceof List){\n-                if (index < 0 || index >= ((List)collection).size()){\n-                    return null;\n-                }\n-                value = ((List)collection).get(index);\n-            }\n-            else if (collection instanceof Collection){\n-                int i = 0;\n-                Iterator it = ((Collection)collection).iterator();\n-                for (; i < index; i++){\n-                    it.next();\n-                }\n-                if (it.hasNext()){\n-                    value = it.next();\n-                }\n-                else {\n-                    value = null;\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-\n-    public static void setValue(Object collection, int index, Object value){\n-        if (collection != null){\n-            if (collection.getClass().isArray()){\n-                Array.set(collection, index, convert(value, collection.getClass().getComponentType()));\n-            }\n-            else if (collection instanceof List){\n-                ((List)collection).set(index, value);\n-            }\n-            else if (collection instanceof Collection){\n-                throw new UnsupportedOperationException(\"Cannot set value of an element of a \" +\n-                        collection.getClass().getName());\n-            }\n-        }\n-    }\n-\n-    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor){\n-        Object value;\n-        try {\n-            Method method = getAccessibleMethod(propertyDescriptor.getReadMethod());\n-            if (method == null){\n-                throw new JXPathException(\"No read method\");\n-            }\n-            value = method.invoke(bean, new Object[0]);\n-        }\n-        catch (Exception ex){\n-            throw new JXPathException(\n-                \"Cannot access property: \" + propertyDescriptor.getName(), ex);\n-        }\n-        return value;\n-    }\n-\n-    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value){\n-        try {\n-            Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod());\n-            if (method == null){\n-                throw new JXPathException(\"No write method\");\n-            }\n-            value = convert(value, propertyDescriptor.getPropertyType());\n-            value = method.invoke(bean, new Object[]{value});\n-        }\n-        catch (Exception ex){\n-            ex.printStackTrace();\n-            throw new JXPathException(\n-                \"Cannot modify property: \" + propertyDescriptor.getName(), ex);\n-        }\n-    }\n-\n-    private static Object convert(Object value, Class type){\n-        try {\n-            return TypeUtils.convert(value, type);\n-        }\n-        catch (Exception ex){\n-            throw new JXPathException(\"Cannot convert value of class \" +\n-                    (value == null ? \"null\" : value.getClass().getName()) +\n-                    \" to type \" + type, ex);\n-        }\n-    }\n-\n     /**\n      * Returns a shared instance of the dynamic property handler class\n      * returned by <code>getDynamicPropertyHandlerClass()</code>.\n      */\n-    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) {\n-        DynamicPropertyHandler handler = (DynamicPropertyHandler)dynamicPropertyHandlerMap.get(clazz);\n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz){\n+        DynamicPropertyHandler handler =\n+            (DynamicPropertyHandler)dynamicPropertyHandlerMap.get(clazz);\n         if (handler == null){\n             try {\n                 handler = (DynamicPropertyHandler)clazz.newInstance();\n     // -------------------------------------------------------- Private Methods\n     //\n     //  The rest of the code in this file was copied FROM\n-    //  org.apache.commons.beanutils.PropertyUtil. We don't want to introduce a dependency\n-    //  on BeanUtils yet - DP.\n+    //  org.apache.commons.beanutils.PropertyUtil. We don't want to introduce\n+    //  a dependency on BeanUtils yet - DP.\n     //\n \n     /**", "timestamp": 1024197742, "metainfo": ""}