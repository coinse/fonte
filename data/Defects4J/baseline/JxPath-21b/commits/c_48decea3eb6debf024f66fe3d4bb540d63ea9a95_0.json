{"sha": "48decea3eb6debf024f66fe3d4bb540d63ea9a95", "log": "trailing ws  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n  * limitations under the License.\n  */\n package org.apache.commons.jxpath.ri;\n-\n \n import java.lang.ref.SoftReference;\n import java.util.ArrayList;\n  * @version $Revision$ $Date$\n  */\n public class JXPathContextReferenceImpl extends JXPathContext {\n-    \n-    /**\n-     * Change this to <code>false</code> to disable soft caching of \n-     * CompiledExpressions. \n+\n+    /**\n+     * Change this to <code>false</code> to disable soft caching of\n+     * CompiledExpressions.\n      */\n     public static final boolean USE_SOFT_CACHE = true;\n-    \n+\n     private static final Compiler COMPILER = new TreeCompiler();\n     private static Map compiled = new HashMap();\n     private static int cleanupCount = 0;\n-    \n+\n     private static Vector nodeFactories = new Vector();\n     private static NodePointerFactory nodeFactoryArray[] = null;\n     static {\n \n     private Pointer rootPointer;\n     private Pointer contextPointer;\n-    \n+\n     protected NamespaceResolver namespaceResolver;\n \n     // The frequency of the cache cleanup\n     private static final int CLEANUP_THRESHOLD = 500;\n \n     protected JXPathContextReferenceImpl(JXPathContext parentContext,\n-                                         Object contextBean) \n+                                         Object contextBean)\n     {\n         this(parentContext, contextBean, null);\n     }\n     public JXPathContextReferenceImpl(\n         JXPathContext parentContext,\n         Object contextBean,\n-        Pointer contextPointer) \n+        Pointer contextPointer)\n     {\n         super(parentContext, contextBean);\n \n         synchronized (nodeFactories) {\n             createNodeFactoryArray();\n         }\n-                \n+\n         if (contextPointer != null) {\n             this.contextPointer = contextPointer;\n             this.rootPointer =\n                     getLocale());\n             this.rootPointer = this.contextPointer;\n         }\n-        \n+\n         NamespaceResolver parentNR = null;\n         if (parentContext instanceof JXPathContextReferenceImpl) {\n             parentNR = ((JXPathContextReferenceImpl) parentContext).getNamespaceResolver();\n \n     /**\n      * Returns a static instance of TreeCompiler.\n-     * \n+     *\n      * Override this to return an aternate compiler.\n      */\n     protected Compiler getCompiler() {\n         return COMPILER;\n     }\n-    \n+\n     protected CompiledExpression compilePath(String xpath) {\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n //            }\n //            return\n //        }\n-        \n+\n         return getValue(xpath, expression);\n     }\n \n //        if (node == null) {\n //            return null;\n //        }\n-//        \n+//\n //        List vars = expression.getUsedVariables();\n //        if (vars != null) {\n //            return null;\n //        }\n-//        \n+//\n //        return node;\n //    }\n \n //            return bean;\n //        }\n //        if (bean instanceof Node) {\n-//            return (Node)bean;            \n+//            return (Node)bean;\n //        }\n-//        \n+//\n //        if (bean instanceof Container) {\n //            bean = ((Container)bean).getValue();\n //            return getNativeContextNode(bean);\n //        }\n-//        \n+//\n //        return null;\n //    }\n \n                 // is going to have isActual == false, but its parent,\n                 // which is a non-node pointer identifying the bean property,\n                 // will return isActual() == true.\n-                NodePointer parent = \n+                NodePointer parent =\n                     ((NodePointer) result).getImmediateParentPointer();\n                 if (parent == null\n                     || !parent.isContainer()\n     public Pointer createPathAndSetValue(\n         String xpath,\n         Expression expr,\n-        Object value) \n+        Object value)\n     {\n         try {\n             return setValue(xpath, expr, value, true);\n         String xpath,\n         Expression expr,\n         Object value,\n-        boolean create) \n+        boolean create)\n     {\n         Object result = expr.computeValue(getEvalContext());\n         Pointer pointer = null;\n             if (create) {\n                 checkSimplePath(expr);\n             }\n-            \n+\n             // This should never happen\n             throw new JXPathException(\"Cannot set value for xpath: \" + xpath);\n         }\n         }\n         return new JXPathContextReferenceImpl(this, contextBean, pointer);\n     }\n-    \n+\n     public Pointer getContextPointer() {\n         return contextPointer;\n     }\n         throw new JXPathFunctionNotFoundException(\n             \"Undefined function: \" + functionName.toString());\n     }\n-    \n+\n     public void registerNamespace(String prefix, String namespaceURI) {\n-        if (namespaceResolver.isSealed()) {            \n+        if (namespaceResolver.isSealed()) {\n             namespaceResolver = (NamespaceResolver) namespaceResolver.clone();\n         }\n         namespaceResolver.registerNamespace(prefix, namespaceURI);\n     }\n-    \n+\n     public String getNamespaceURI(String prefix) {\n         return namespaceResolver.getNamespaceURI(prefix);\n     }\n         }\n         namespaceResolver.setNamespaceContextPointer((NodePointer) pointer);\n     }\n-    \n+\n     public Pointer getNamespaceContextPointer() {\n         return namespaceResolver.getNamespaceContextPointer();\n     }\n         namespaceResolver.seal();\n         return namespaceResolver;\n     }\n-    \n+\n     /**\n      * Checks if existenceCheckClass exists on the class path. If so, allocates\n      * an instance of the specified class, otherwise returns null.\n      */\n     public static Object allocateConditionally(\n             String className,\n-            String existenceCheckClassName) \n+            String existenceCheckClassName)\n     {\n         try {\n             try {", "timestamp": 1184690312, "metainfo": ""}