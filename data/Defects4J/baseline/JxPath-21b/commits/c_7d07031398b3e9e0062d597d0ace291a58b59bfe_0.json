{"sha": "7d07031398b3e9e0062d597d0ace291a58b59bfe", "log": "Added support for relative contexts   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.14 2003/01/29 18:15:17 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2003/01/29 18:15:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.15 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2003/01/29 18:15:17 $\n+ * @version $Revision: 1.15 $ $Date: 2003/02/19 00:59:52 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n     }\n \n     /**\n-     * Creates  a new JXPathContext with the specified bean as the root node and\n+     * Creates a new JXPathContext with the specified bean as the root node and\n      * the specified parent context. Variables defined in a parent context can\n      * be referenced in XPaths passed to the child context.\n      */\n      * Returns a Pointer for the context bean.\n      */\n     public abstract Pointer getContextPointer();\n+\n+    /**\n+     * Returns a JXPathContext that is relative to the current JXPathContext.\n+     * The supplied pointer becomes the context pointer of the new context.\n+     * The relative context inherits variables, extension functions, locale etc\n+     * from the parent context.\n+     */\n+    public abstract JXPathContext getRelativeContext(Pointer pointer);\n \n     /**\n      * Installs a custom implementation of the Variables interface.\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.6 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n+import java.io.Serializable;\n+\n /**\n  * Pointers represent locations of objects and their properties\n  * in Java object graphs. JXPathContext has methods\n  * object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.6 $ $Date: 2003/02/19 00:59:52 $\n  */\n-public interface Pointer {\n+public interface Pointer extends Cloneable, Comparable, Serializable {\n \n     /**\n      * Returns the value of the object, property or collection element\n     void setValue(Object value);\n \n     /**\n+     * Returns the node this pointer is based on. \n+     */\n+    Object getRootNode();\n+    \n+    /**\n      * Returns a string that is a proper \"canonical\" XPath that corresponds to\n      * this pointer.  Consider this example:\n      * <p><code>Pointer  ptr = ctx.getPointer(\"//employees[firstName = 'John']\")\n      * /departments[@name = 'HR']/employees[3]\"</code>.\n      */\n     String asPath();\n+    \n+    /**\n+     * Pointers are cloneable\n+     */\n+    Object clone();\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.27 2003/02/18 18:11:37 dmitri Exp $\n- * $Revision: 1.27 $\n- * $Date: 2003/02/18 18:11:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.28 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.28 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.PackageFunctions;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.Variables;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n import org.apache.commons.jxpath.ri.axes.RootContext;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import org.apache.commons.jxpath.ri.compiler.LocationPath;\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.27 $ $Date: 2003/02/18 18:11:37 $\n+ * @version $Revision: 1.28 $ $Date: 2003/02/19 00:59:52 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext {\n+    \n+    /**\n+     * Change this to <code>false</code> to disable soft caching of CompiledExpressions. \n+     */\n+    public static final boolean USE_SOFT_CACHE = true;\n     \n     private static final Compiler COMPILER = new TreeCompiler();\n     private static Map compiled = new HashMap();\n     private static final PackageFunctions GENERIC_FUNCTIONS =\n         new PackageFunctions(\"\", null);\n-    private static final boolean USE_SOFT_CACHE = true;\n     private static int cleanupCount = 0;\n+    \n     private static Vector nodeFactories = new Vector();\n     private static NodePointerFactory nodeFactoryArray[] = null;\n     static {\n         createNodeFactoryArray();\n     }\n \n-    private NodePointer rootPointer;\n+    private Pointer rootPointer;\n+    private Pointer contextPointer;\n \n     // The frequency of the cache cleanup\n     private static final int CLEANUP_THRESHOLD = 500;\n     protected JXPathContextReferenceImpl(JXPathContext parentContext,\n                                          Object contextBean) \n     {\n+        this(parentContext, contextBean, null);\n+    }\n+\n+    public JXPathContextReferenceImpl(\n+        JXPathContext parentContext,\n+        Object contextBean,\n+        Pointer contextPointer) \n+    {\n         super(parentContext, contextBean);\n+\n         synchronized (nodeFactories) {\n             createNodeFactoryArray();\n+        }\n+                \n+        if (contextPointer != null) {\n+            this.contextPointer = contextPointer;\n+            this.rootPointer =\n+                NodePointer.newNodePointer(\n+                    new QName(null, \"root\"),\n+                    contextPointer.getRootNode(),\n+                    getLocale());\n+        }\n+        else {\n+            this.contextPointer =\n+                NodePointer.newNodePointer(\n+                    new QName(null, \"root\"),\n+                    contextBean,\n+                    getLocale());\n+            this.rootPointer = this.contextPointer;\n         }\n     }\n \n             });\n         }\n     }\n+    \n     /**\n      * Call this with a custom NodePointerFactory to add support for\n      * additional types of objects.  Make sure the factory returns\n         return nodeFactoryArray;\n     }\n \n+    /**\n+     * Returns a static instance of TreeCompiler.\n+     * \n+     * Override this to return an aternate compiler.\n+     */\n+    protected Compiler getCompiler(){\n+        return COMPILER;\n+        \n+    }\n+    \n     protected CompiledExpression compilePath(String xpath) {\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n \n-    private static Expression compileExpression(String xpath) {\n+    private Expression compileExpression(String xpath) {\n         Expression expr;\n         if (USE_SOFT_CACHE) {\n             expr = null;\n                 expr = (Expression) ref.get();\n             }\n             if (expr == null) {\n-                expr = (Expression) Parser.parseExpression(xpath, COMPILER);\n+                expr =\n+                    (Expression) Parser.parseExpression(xpath, getCompiler());\n                 compiled.put(xpath, new SoftReference(expr));\n                 if (cleanupCount++ >= CLEANUP_THRESHOLD) {\n                     cleanupCache();\n         else {\n             expr = (Expression) compiled.get(xpath);\n             if (expr == null) {\n-                expr = (Expression) Parser.parseExpression(xpath, COMPILER);\n+                expr =\n+                    (Expression) Parser.parseExpression(xpath, getCompiler());\n                 compiled.put(xpath, expr);\n             }\n         }\n     }\n \n     public Object getValue(String xpath, Expression expr) {\n-        Object result = expr.computeValue(getRootContext());\n+        Object result = expr.computeValue(getEvalContext());\n         if (result instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) result;\n             result = ctx.getSingleNodePointer();\n     }\n \n     public Iterator iterate(String xpath, Expression expr) {\n-        return expr.iterate(getRootContext());\n+        return expr.iterate(getEvalContext());\n     }\n \n     public Pointer getPointer(String xpath) {\n     }\n \n     public Pointer getPointer(String xpath, Expression expr) {\n-        Object result = expr.computeValue(getRootContext());\n+        Object result = expr.computeValue(getEvalContext());\n         if (result instanceof EvalContext) {\n             result = ((EvalContext) result).getSingleNodePointer();\n         }\n \n     public Pointer createPath(String xpath, Expression expr) {\n         try {\n-            Object result = expr.computeValue(getRootContext());\n+            Object result = expr.computeValue(getEvalContext());\n             Pointer pointer = null;\n \n             if (result instanceof Pointer) {\n         Object value,\n         boolean create) \n     {\n-        Object result = expr.computeValue(getRootContext());\n-        //        System.err.println(\"RESULT: \" + result);\n+        Object result = expr.computeValue(getEvalContext());\n         Pointer pointer = null;\n \n         if (result instanceof Pointer) {\n     }\n \n     public Iterator iteratePointers(String xpath, Expression expr) {\n-        return expr.iteratePointers(getRootContext());\n+        return expr.iteratePointers(getEvalContext());\n     }\n \n     public void removePath(String xpath) {\n     public void removeAll(String xpath, Expression expr) {\n         try {\n             ArrayList list = new ArrayList();\n-            Iterator it = expr.iterate(getRootContext());\n+            Iterator it = expr.iterate(getEvalContext());\n             while (it.hasNext()) {\n                 list.add(it.next());\n             }\n         }\n     }\n \n+    public JXPathContext getRelativeContext(Pointer pointer){\n+        Object contextBean = pointer.getNode();\n+        if (contextBean == null) {\n+            throw new JXPathException(\n+                \"Cannot create a relative context for a non-existent node: \"\n+                    + pointer);\n+        }\n+        return new JXPathContextReferenceImpl(this, contextBean, pointer);\n+    }\n+    \n     public synchronized Pointer getContextPointer() {\n-        if (rootPointer == null) {\n-            rootPointer = NodePointer.newNodePointer(new QName(null, \"root\"),\n-                getContextBean(), getLocale());\n-        }\n-        return (Pointer) rootPointer.clone();\n-    }\n-\n-    private EvalContext getRootContext() {\n-        return new RootContext(this, (NodePointer) getContextPointer());\n+        return (Pointer) contextPointer.clone();\n+    }\n+\n+    private synchronized NodePointer getAbsoluteRootPointer() {\n+        return (NodePointer) rootPointer.clone();\n+    }\n+\n+    private EvalContext getEvalContext() {\n+        return new InitialContext(\n+            new RootContext(this, (NodePointer) getContextPointer()));\n+    }\n+\n+    public EvalContext getAbsoluteRootContext() {\n+        return new InitialContext(\n+            new RootContext(this, getAbsoluteRootPointer()));\n     }\n \n     public NodePointer getVariablePointer(QName name) {\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.9 2003/01/11 05:41:23 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2003/01/11 05:41:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.10 2003/02/19 00:59:51 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/02/19 00:59:51 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that is used to hold the root node for the path traversal.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:23 $\n+ * @version $Revision: 1.10 $ $Date: 2003/02/19 00:59:51 $\n  */\n public class RootContext extends EvalContext {\n-    private boolean startedSet = false;\n-    private boolean started = false;\n-    private JXPathContextReferenceImpl parent;\n+    private JXPathContextReferenceImpl jxpathContext;\n     private NodePointer pointer;\n     private Object registers[];\n     private int availableRegister = 0;\n     public static final Object UNKNOWN_VALUE = new Object();\n     private static final int MAX_REGISTER = 4;\n \n-    public RootContext(JXPathContextReferenceImpl parent, NodePointer pointer) {\n+    public RootContext(\n+        JXPathContextReferenceImpl jxpathContext,\n+        NodePointer pointer) \n+    {\n         super(null);\n-        this.parent = parent;\n+        this.jxpathContext = jxpathContext;\n         this.pointer = pointer;\n     }\n \n     public JXPathContext getJXPathContext() {\n-        return parent;\n+        return jxpathContext;\n     }\n \n     public RootContext getRootContext() {\n         return this;\n+    }\n+    \n+    public EvalContext getAbsoluteRootContext() {\n+        return jxpathContext.getAbsoluteRootContext();\n     }\n \n     public NodePointer getCurrentNodePointer() {\n     }\n \n     public int getCurrentPosition() {\n-        return 1;\n+        throw new UnsupportedOperationException();\n     }\n \n     public boolean nextNode() {\n-        if (started) {\n-            return false;\n-        }\n-        started = true;\n-        return true;\n+        throw new UnsupportedOperationException();\n     }\n \n     public boolean nextSet() {\n-        if (startedSet) {\n-            return false;\n-        }\n-        startedSet = true;\n-        return true;\n+        throw new UnsupportedOperationException();\n     }\n \n     public boolean setPosition(int position) {\n-        return position == 1;\n+        throw new UnsupportedOperationException();\n     }\n \n     public EvalContext getConstantContext(Object constant) {\n             pointer =\n                 NodePointer.newNodePointer(new QName(null, \"\"), constant, null);\n         }\n-        return new InitialContext(new RootContext(parent, pointer));\n+        return new InitialContext(new RootContext(jxpathContext, pointer));\n     }\n \n     public EvalContext getVariableContext(QName variableName) {\n         return new InitialContext(\n-            new RootContext(parent, parent.getVariablePointer(variableName)));\n+            new RootContext(\n+                jxpathContext,\n+                jxpathContext.getVariablePointer(variableName)));\n     }\n \n     public Function getFunction(QName functionName, Object[] parameters) {\n-        return parent.getFunction(functionName, parameters);\n+        return jxpathContext.getFunction(functionName, parameters);\n     }\n \n     public Object getRegisteredValue(int id) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.7 2003/01/19 23:59:24 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/19 23:59:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.8 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/19 23:59:24 $\n+ * @version $Revision: 1.8 $ $Date: 2003/02/19 00:59:52 $\n  */\n public class LocationPath extends Path {\n \n         // Create a chain of contexts\n         EvalContext rootContext;\n         if (isAbsolute()) {\n-            rootContext = context.getRootContext();\n+            rootContext = context.getRootContext().getAbsoluteRootContext();\n         }\n         else {\n-            rootContext = context;\n+            rootContext = new InitialContext(context);\n         }\n-        return evalSteps(new InitialContext(rootContext));\n+        return evalSteps(rootContext);\n     }\n \n \n         // Create a chain of contexts\n         EvalContext rootContext;\n         if (isAbsolute()) {\n-            rootContext = context.getRootContext();\n+            rootContext = context.getRootContext().getAbsoluteRootContext();\n         }\n         else {\n-            rootContext = context;\n+            rootContext = new InitialContext(context);\n         }\n-        return getSingleNodePointerForSteps(new InitialContext(rootContext));\n+        return getSingleNodePointerForSteps(rootContext);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.15 2003/01/11 05:41:24 dmitri Exp $\n- * $Revision: 1.15 $\n- * $Date: 2003/01/11 05:41:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.16 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * attribute and only simple, context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2003/01/11 05:41:24 $\n+ * @version $Revision: 1.16 $ $Date: 2003/02/19 00:59:52 $\n  */\n-public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n+public abstract class NodePointer implements Pointer {\n \n     public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n     protected int index = WHOLE_COLLECTION;\n     public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n     private boolean attribute = false;\n+    private transient Object rootNode;\n \n     /**\n      * Allocates an entirely new NodePointer by iterating through all installed\n         return getValuePointer().getImmediateNode();\n     }\n     \n+    public Object getRootNode(){\n+        if (rootNode == null) {\n+            if (parent != null){\n+                rootNode = parent.getRootNode();\n+            }\n+            else {\n+                rootNode = getImmediateNode();\n+            }\n+        }\n+        return rootNode;\n+    }\n+    \n     /**\n      * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.5 2003/02/07 00:51:40 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/02/07 00:51:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.6 2003/02/19 00:59:53 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/02/19 00:59:53 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * The default implementation of TypeConverter.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2003/02/07 00:51:40 $\n+ * @version $Revision: 1.6 $ $Date: 2003/02/19 00:59:53 $\n  */\n public class BasicTypeConverter implements TypeConverter {\n \n         public Object getNode() {\n             return bean;\n         }\n+        \n+        public Object getRootNode() {\n+            return bean;\n+        }        \n+        \n         public void setValue(Object value) {\n             throw new UnsupportedOperationException();\n+        }\n+        \n+        public Object clone(){\n+            return this;\n+        }\n+        \n+        public int compareTo(Object object) {\n+            return 0;\n         }\n         \n         public String asPath() {\n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.10 2003/02/18 18:11:37 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/02/18 18:11:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.11 2003/02/19 00:59:52 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/02/19 00:59:52 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2003/02/18 18:11:37 $\n+ * @version $Revision: 1.11 $ $Date: 2003/02/19 00:59:52 $\n  */\n \n public abstract class BeanModelTestCase extends JXPathTestCase {\n             null,\n             context.getValue(\"nestedBean\"));\n     }\n+    \n+    public void testRelativeContextRelativePath() {\n+        JXPathContext relative =\n+            context.getRelativeContext(context.getPointer(\"nestedBean\"));\n+        \n+        assertXPathValueAndPointer(relative, \n+            \"int\", \n+            new Integer(1), \n+            \"/nestedBean/int\");\n+    }\n+\n+    public void testRelativeContextAbsolutePath() {\n+        JXPathContext relative =\n+            context.getRelativeContext(context.getPointer(\"nestedBean\"));\n+        \n+        assertXPathValueAndPointer(relative, \n+            \"/integers[2]\", \n+            new Integer(2), \n+            \"/integers[2]\");\n+    }\n+\n+    public void testRelativeContextParent() {\n+        JXPathContext relative =\n+            context.getRelativeContext(context.getPointer(\"nestedBean\"));\n+        \n+        assertXPathValueAndPointer(relative, \n+            \"../integers[2]\", \n+            new Integer(2), \n+            \"/integers[2]\");\n+    }\n }", "timestamp": 1045616393, "metainfo": ""}