{"sha": "885fb67a4ecf7c64696d679762b8a28489ead61f", "log": "Addressed cache synchronization issue   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.32 2003/05/04 23:51:59 dmitri Exp $\n- * $Revision: 1.32 $\n- * $Date: 2003/05/04 23:51:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.33 2003/08/24 01:52:09 dmitri Exp $\n+ * $Revision: 1.33 $\n+ * $Date: 2003/08/24 01:52:09 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Vector;\n+import java.util.Map.Entry;\n \n import org.apache.commons.jxpath.CompiledExpression;\n import org.apache.commons.jxpath.Function;\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.32 $ $Date: 2003/05/04 23:51:59 $\n+ * @version $Revision: 1.33 $ $Date: 2003/08/24 01:52:09 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext {\n     \n \n     private Expression compileExpression(String xpath) {\n         Expression expr;\n-        if (USE_SOFT_CACHE) {\n-            expr = null;\n-            SoftReference ref = (SoftReference) compiled.get(xpath);\n-            if (ref != null) {\n-                expr = (Expression) ref.get();\n-            }\n-            if (expr == null) {\n-                expr =\n-                    (Expression) Parser.parseExpression(xpath, getCompiler());\n-                synchronized (compiled) {\n-                    compiled.put(xpath, new SoftReference(expr));\n+\n+        synchronized (compiled) {\n+            if (USE_SOFT_CACHE) {\n+                expr = null;\n+                SoftReference ref = (SoftReference) compiled.get(xpath);\n+                if (ref != null) {\n+                    expr = (Expression) ref.get();\n                 }\n+            }\n+            else {\n+                expr = (Expression) compiled.get(xpath);\n+            }\n+        }\n+\n+        if (expr != null) {\n+            return expr;\n+        }\n+\n+        expr = (Expression) Parser.parseExpression(xpath, getCompiler());\n+\n+        synchronized (compiled) {\n+            if (USE_SOFT_CACHE) {\n                 if (cleanupCount++ >= CLEANUP_THRESHOLD) {\n-                    cleanupCache();\n+                    Iterator it = compiled.entrySet().iterator();\n+                    while (it.hasNext()) {\n+                        Entry me = (Entry) it.next();\n+                        if (((SoftReference) me.getValue()).get() == null) {\n+                            it.remove();\n+                        }\n+                    }\n+                    cleanupCount = 0;\n                 }\n-            }\n-        }\n-        else {\n-            expr = (Expression) compiled.get(xpath);\n-            if (expr == null) {\n-                expr =\n-                    (Expression) Parser.parseExpression(xpath, getCompiler());\n+                compiled.put(xpath, new SoftReference(expr));\n+            }\n+            else {\n                 compiled.put(xpath, expr);\n             }\n         }\n+\n         return expr;\n-    }\n-\n-    private static void cleanupCache() {\n-        synchronized (compiled) {\n-            Iterator it = compiled.entrySet().iterator();\n-            while (it.hasNext()) {\n-                Map.Entry me = (Map.Entry) it.next();\n-                if (((SoftReference) me.getValue()).get() == null) {\n-                    it.remove();\n-                }\n-            }\n-            cleanupCount = 0;\n-        }\n     }\n \n     /**", "timestamp": 1061689929, "metainfo": ""}