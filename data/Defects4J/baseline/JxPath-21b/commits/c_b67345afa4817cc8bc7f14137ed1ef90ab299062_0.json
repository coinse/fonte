{"sha": "b67345afa4817cc8bc7f14137ed1ef90ab299062", "log": "[JXPATH-127] Change dynamic classloading to consult context ClassLoader  ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.util.Properties;\n+\n+import org.apache.commons.jxpath.util.ClassLoaderUtil;\n \n /**\n  * Defines a factory API that enables applications to obtain a\n \n         JXPathContextFactory factoryImpl;\n         try {\n-            Class clazz = Class.forName(factoryImplName);\n+            Class clazz = ClassLoaderUtil.getClass(factoryImplName, true);\n             factoryImpl = (JXPathContextFactory) clazz.newInstance();\n         }\n         catch (ClassNotFoundException cnfe) {\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n import java.util.Date;\n import java.util.Map;\n import java.util.HashMap;\n+\n+import org.apache.commons.jxpath.util.ClassLoaderUtil;\n \n /**\n  * JXPathIntrospector  maintains a registry of {@link JXPathBeanInfo\n                 return cls.newInstance();\n             }\n             catch (Exception ex) { //NOPMD\n-                // Just drop through and try the system classloader.\n-            }\n-        }\n-\n-        // Now try the bootstrap classloader.\n-        Class cls = Class.forName(className);\n+                // Just drop through and use the ClassLoaderUtil.\n+            }\n+        }\n+\n+        // Now try the ClassLoaderUtil.\n+        Class cls = ClassLoaderUtil.getClass(className);\n         return cls.newInstance();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n \n import org.apache.commons.jxpath.functions.ConstructorFunction;\n import org.apache.commons.jxpath.functions.MethodFunction;\n+import org.apache.commons.jxpath.util.ClassLoaderUtil;\n import org.apache.commons.jxpath.util.MethodLookupUtils;\n import org.apache.commons.jxpath.util.TypeUtils;\n \n \n         Class functionClass;\n         try {\n-            functionClass = Class.forName(className);\n+            functionClass = ClassLoaderUtil.getClass(className, true);\n         }\n         catch (ClassNotFoundException ex) {\n             throw new JXPathException(\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n import org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory;\n import org.apache.commons.jxpath.ri.model.dynamic.DynamicPointerFactory;\n import org.apache.commons.jxpath.util.ReverseComparator;\n+import org.apache.commons.jxpath.util.ClassLoaderUtil;\n import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n             String existenceCheckClassName) {\n         try {\n             try {\n-                Class.forName(existenceCheckClassName);\n+                ClassLoaderUtil.getClass(existenceCheckClassName, true);\n             }\n             catch (ClassNotFoundException ex) {\n                 return null;\n             }\n-            Class cls = Class.forName(className);\n+            Class cls = ClassLoaderUtil.getClass(className, true);\n             return cls.newInstance();\n         }\n         catch (Exception ex) {\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/ClassLoaderUtil.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Port of class loading methods from <code>org.apache.commons.lang.ClassUtils</code> from \n+ * the Apache Commons Lang Component. Some adjustments made to remove dependency on \n+ * <code>org.apache.commons.lang.StringUtils</code>. Also modified to fall back on the\n+ * current class loader when an attempt to load a class with the context class loader\n+ * results in a <code>java.lang.ClassNotFoundException</code>. \n+ * \n+ * @see org.apache.commons.lang.ClassUtils\n+ * \n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Alban Peignier\n+ * @author Tomasz Blachowicz\n+ * @author John Trimble\n+ */\n+public class ClassLoaderUtil {\n+  /**\n+   * Maps a primitive class name to its corresponding abbreviation used in array class names.\n+   */\n+  private static Map abbreviationMap = new HashMap();\n+\n+  /**\n+   * Maps an abbreviation used in array class names to corresponding primitive class name.\n+   */\n+  private static Map reverseAbbreviationMap = new HashMap();\n+  \n+  /**\n+   * Add primitive type abbreviation to maps of abbreviations.\n+   * \n+   * @param primitive Canonical name of primitive type\n+   * @param abbreviation Corresponding abbreviation of primitive type\n+   */\n+  private static void addAbbreviation(String primitive, String abbreviation) {\n+      abbreviationMap.put(primitive, abbreviation);\n+      reverseAbbreviationMap.put(abbreviation, primitive);\n+  }\n+  \n+  /**\n+   * Feed abbreviation maps\n+   */\n+  static {\n+      addAbbreviation(\"int\", \"I\");\n+      addAbbreviation(\"boolean\", \"Z\");\n+      addAbbreviation(\"float\", \"F\");\n+      addAbbreviation(\"long\", \"J\");\n+      addAbbreviation(\"short\", \"S\");\n+      addAbbreviation(\"byte\", \"B\");\n+      addAbbreviation(\"double\", \"D\");\n+      addAbbreviation(\"char\", \"C\");\n+  }\n+  \n+  // Class loading\n+  // ----------------------------------------------------------------------\n+  /**\n+   * Returns the class represented by <code>className</code> using the\n+   * <code>classLoader</code>.  This implementation supports names like\n+   * \"<code>java.lang.String[]</code>\" as well as \"<code>[Ljava.lang.String;</code>\".\n+   *\n+   * @param classLoader  the class loader to use to load the class\n+   * @param className  the class name\n+   * @param initialize  whether the class must be initialized\n+   * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+   * @throws ClassNotFoundException if the class is not found\n+   */\n+  public static Class getClass(\n+          ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n+      Class clazz;\n+      if (abbreviationMap.containsKey(className)) {\n+          String clsName = \"[\" + abbreviationMap.get(className);\n+          clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n+      } else {\n+          clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n+      }\n+      return clazz;\n+  }\n+\n+  /**\n+   * Returns the (initialized) class represented by <code>className</code>\n+   * using the <code>classLoader</code>.  This implementation supports names\n+   * like \"<code>java.lang.String[]</code>\" as well as\n+   * \"<code>[Ljava.lang.String;</code>\".\n+   *\n+   * @param classLoader  the class loader to use to load the class\n+   * @param className  the class name\n+   * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+   * @throws ClassNotFoundException if the class is not found\n+   */\n+  public static Class getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+      return getClass(classLoader, className, true);\n+  }\n+\n+  /**\n+   * Returns the (initialized) class represented by <code>className</code>\n+   * using the current thread's context class loader. This implementation\n+   * supports names like \"<code>java.lang.String[]</code>\" as well as\n+   * \"<code>[Ljava.lang.String;</code>\".\n+   *\n+   * @param className  the class name\n+   * @return the class represented by <code>className</code> using the current thread's context class loader\n+   * @throws ClassNotFoundException if the class is not found\n+   */\n+  public static Class getClass(String className) throws ClassNotFoundException {\n+      return getClass(className, true);\n+  }\n+\n+  /**\n+   * Returns the class represented by <code>className</code> using the\n+   * current thread's context class loader. This implementation supports\n+   * names like \"<code>java.lang.String[]</code>\" as well as\n+   * \"<code>[Ljava.lang.String;</code>\".\n+   *\n+   * @param className  the class name\n+   * @param initialize  whether the class must be initialized\n+   * @return the class represented by <code>className</code> using the current thread's context class loader\n+   * @throws ClassNotFoundException if the class is not found\n+   */\n+  public static Class getClass(String className, boolean initialize) throws ClassNotFoundException {\n+      ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n+      ClassLoader currentCL = ClassLoaderUtil.class.getClassLoader();\n+      if( contextCL != null ) {\n+          try {\n+              return getClass(contextCL, className, initialize);\n+          } catch( ClassNotFoundException e ) {\n+              // ignore this exception and try the current class loader.\n+          }\n+      }\n+      return getClass(currentCL, className, initialize);\n+  }\n+  \n+  /**\n+   * Converts a class name to a JLS style class name.\n+   *\n+   * @param className  the class name\n+   * @return the converted name\n+   */\n+  private static String toCanonicalName(String className) {\n+      if (className == null) {\n+          throw new RuntimeException(\"Argument className was null.\");\n+      } else if (className.endsWith(\"[]\")) {\n+          StringBuffer classNameBuffer = new StringBuffer();\n+          while (className.endsWith(\"[]\")) {\n+              className = className.substring(0, className.length() - 2);\n+              classNameBuffer.append(\"[\");\n+          }\n+          String abbreviation = (String) abbreviationMap.get(className);\n+          if (abbreviation != null) {\n+              classNameBuffer.append(abbreviation);\n+          } else {\n+              classNameBuffer.append(\"L\").append(className).append(\";\");\n+          }\n+          className = classNameBuffer.toString();\n+      }\n+      return className;\n+  }\n+}\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n \n import org.apache.commons.jxpath.Container;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.util.ClassLoaderUtil;\n \n /**\n  * An XML document container reads and parses XML only when it is\n                 throw new JXPathException(\"Unsupported XML model: \" + model);\n             }\n             try {\n-                Class clazz = Class.forName(className);\n+                Class clazz = ClassLoaderUtil.getClass(className, true);\n                 parser = (XMLParser) clazz.newInstance();\n             }\n             catch (Exception ex) {\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/util/ClassLoaderUtilTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests org.apache.commons.jxpath.util.ClassLoaderUtil.\n+ * \n+ * @author John Trimble\n+ */\n+public class ClassLoaderUtilTest extends TestCase {\n+  \n+  // These must be string literals, and not populated by calling getName() on\n+  // the respective classes, since the tests below will load this class in a\n+  // special class loader which may be unable to load those classes.\n+  private static final String TEST_CASE_CLASS_NAME = \"org.apache.commons.jxpath.util.ClassLoaderUtilTest\";\n+  private static final String EXAMPLE_CLASS_NAME = \"org.apache.commons.jxpath.util.ClassLoadingExampleClass\";\n+  \n+  private ClassLoader orginalContextClassLoader;\n+  \n+  /**\n+   * Setup for the tests.\n+   */\n+  public void setUp() {\n+    this.orginalContextClassLoader = Thread.currentThread().getContextClassLoader();\n+  }\n+  \n+  /**\n+   * Cleanup for the tests.\n+   */\n+  public void tearDown() {\n+    Thread.currentThread().setContextClassLoader(this.orginalContextClassLoader);\n+  }\n+  \n+  /**\n+   * Tests that JXPath cannot dynamically load a class, which is not visible to\n+   * its class loader, when the context class loader is null.\n+   */\n+  public void testClassLoadFailWithoutContextClassLoader() {\n+    Thread.currentThread().setContextClassLoader(null);\n+    ClassLoader cl = new TestClassLoader(getClass().getClassLoader());\n+    executeTestMethodUnderClassLoader(cl, \"callExampleMessageMethodAndAssertClassNotFoundJXPathException\");\n+  }\n+  \n+  /**\n+   * Tests that JXPath can dynamically load a class, which is not visible to \n+   * its class loader, when the context class loader is set and can load the\n+   * class.\n+   */\n+  public void testClassLoadSuccessWithContextClassLoader() {\n+    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());\n+    ClassLoader cl = new TestClassLoader(getClass().getClassLoader());\n+    executeTestMethodUnderClassLoader(cl, \"callExampleMessageMethodAndAssertSuccess\");\n+  }\n+  \n+  /**\n+   * Tests that JXPath will use its class loader to dynamically load a \n+   * requested class when the context class loader is set but unable to load\n+   * the class.\n+   */\n+  public void testCurrentClassLoaderFallback() {\n+    ClassLoader cl = new TestClassLoader(getClass().getClassLoader());\n+    Thread.currentThread().setContextClassLoader(cl);\n+    callExampleMessageMethodAndAssertSuccess();\n+  }\n+  \n+  /**\n+   * Tests that JXPath can dynamically load a class, which is visible to\n+   * its class loader, when there is no context class loader set.\n+   */\n+  public void testClassLoadSuccessWithoutContextClassLoader() {\n+    Thread.currentThread().setContextClassLoader(null);\n+    callExampleMessageMethodAndAssertSuccess();\n+  }\n+  \n+  /**\n+   * Performs a basic query that requires a class be loaded dynamically by\n+   * JXPath and asserts the dynamic class load fails.\n+   */\n+  public static void callExampleMessageMethodAndAssertClassNotFoundJXPathException() {\n+    JXPathContext context = JXPathContext.newContext(new Object());\n+    try {\n+      context.selectSingleNode(EXAMPLE_CLASS_NAME+\".getMessage()\");\n+      fail(\"We should not be able to load \"+EXAMPLE_CLASS_NAME+\".\");\n+    } catch( Exception e ) {\n+      assertTrue( e instanceof JXPathException );\n+    }\n+  }\n+  \n+  /**\n+   * Performs a basic query that requires a class be loaded dynamically by\n+   * JXPath and asserts the dynamic class load succeeds.\n+   */\n+  public static void callExampleMessageMethodAndAssertSuccess() {\n+    JXPathContext context = JXPathContext.newContext(new Object());\n+    Object value;\n+    try {\n+      value = context.selectSingleNode(EXAMPLE_CLASS_NAME+\".getMessage()\");\n+      assertEquals(\"an example class\", value);\n+    } catch( Exception e ) {\n+      fail(e.getMessage());\n+    }\n+  }\n+  \n+  /**\n+   * Loads this class through the given class loader and then invokes the \n+   * indicated no argument static method of the class.\n+   * \n+   * @param cl the class loader under which to invoke the method.\n+   * @param methodName the name of the static no argument method on this class\n+   * to invoke.\n+   */\n+  private void executeTestMethodUnderClassLoader(ClassLoader cl, String methodName) {\n+    Class testClass = null;\n+    try {\n+      testClass = cl.loadClass(TEST_CASE_CLASS_NAME);\n+    } catch (ClassNotFoundException e) {\n+      fail(e.getMessage());\n+    }\n+    Method testMethod = null;\n+    try {\n+      testMethod = testClass.getMethod(methodName, null);\n+    } catch (SecurityException e) {\n+      fail(e.getMessage());\n+    } catch (NoSuchMethodException e) {\n+      fail(e.getMessage());\n+    }\n+    \n+    try {\n+      testMethod.invoke(null, null);\n+    } catch (IllegalArgumentException e) {\n+      fail(e.getMessage());\n+    } catch (IllegalAccessException e) {\n+      fail(e.getMessage());\n+    } catch (InvocationTargetException e) {\n+      if( e.getCause() instanceof RuntimeException ) {\n+        // Allow the runtime exception to propagate up.\n+        throw (RuntimeException) e.getCause();\n+      }\n+    }\n+  }\n+  \n+  /**\n+   * A simple class loader which delegates all class loading to its parent \n+   * with two exceptions. First, attempts to load the class \n+   * <code>org.apache.commons.jxpath.util.ClassLoaderUtilTest</code> will\n+   * always result in a ClassNotFoundException. Second, loading the class\n+   * <code>org.apache.commons.jxpath.util.ClassLoadingExampleClass</code> will \n+   * result in the class being loaded by this class loader, regardless of \n+   * whether the parent can/has loaded it. \n+   *\n+   */\n+  private static class TestClassLoader extends ClassLoader {\n+    private Class testCaseClass = null;\n+    \n+    public TestClassLoader(ClassLoader classLoader) {\n+      super(classLoader);\n+    }\n+\n+    public synchronized Class loadClass(String name, boolean resolved) throws ClassNotFoundException {\n+      if( EXAMPLE_CLASS_NAME.equals(name) ) {\n+        throw new ClassNotFoundException();\n+      }\n+      else if( TEST_CASE_CLASS_NAME.equals(name) ) {\n+        if( testCaseClass == null ) {\n+          URL clazzUrl = this.getParent().getResource(\"org/apache/commons/jxpath/util/ClassLoaderUtilTest.class\");\n+          \n+          ByteArrayOutputStream out = new ByteArrayOutputStream();\n+          InputStream in = null;\n+          try {\n+            in = clazzUrl.openStream();\n+            byte[] buffer = new byte[2048];\n+            for( int read = in.read(buffer); read > -1; read = in.read(buffer) ) {\n+              out.write(buffer, 0, read);\n+            }\n+          } catch( IOException e ) {\n+            throw new ClassNotFoundException(\"Could not read class from resource \"+clazzUrl+\".\", e);\n+          } finally {\n+            try { in.close(); } catch( Exception e ) { }\n+            try { out.close(); } catch( Exception e ) { }\n+          }\n+          \n+          byte[] clazzBytes = out.toByteArray();\n+          this.testCaseClass = this.defineClass(TEST_CASE_CLASS_NAME, clazzBytes, 0, clazzBytes.length);\n+        }\n+        return this.testCaseClass;\n+      }\n+      return this.getParent().loadClass(name);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/util/ClassLoadingExampleClass.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+/**\n+ * Test class for <code>org.apache.commons.jxpath.util.ClassLoaderUtilTest\n+ * </code> test case.\n+ * \n+ * @author John Trimble\n+ */\n+public class ClassLoadingExampleClass {\n+  public static String getMessage() { return \"an example class\"; }\n+}", "timestamp": 1267156546, "metainfo": ""}