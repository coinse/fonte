{"sha": "727432fe12821b9e25e2c5a1758076ad83b098eb", "log": "Added Benjamin Walstrum's contribution of DoubleMetaphone, added Benjamin to the contributors   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/language/DoubleMetaphone.java,v 1.1 2003/06/11 03:23:26 tobrien Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/06/11 03:23:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.codec.language;\n+\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * DoubleMetaphone Java Implementation\n+ * From the algorithm by Lawrence Philips\n+ * \n+ * Original Article <a \n+ * href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\">\n+ * http://www.cuj.com/documents/s=8038/cuj0006philips/</a>\n+ * Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\">\n+ * ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a>\n+ * \n+ * @author <a href=\"mailto:ben@walstrum.com\">Benjamin Walstrum</a>\n+ */\n+public class DoubleMetaphone implements StringEncoder {\n+\n+    private static final String VOWELS = \"AEIOUY\";\n+    private static final String[] SILENT_START = \n+    { \"GN\", \"KN\", \"PN\", \"WR\", \"PS\" };\n+    private static final String[] L_R_N_M_B_H_F_V_W_SPACE = \n+    { \"L\", \"R\", \"N\", \"M\", \"B\", \"H\", \"F\", \"V\", \"W\", \" \" };\n+    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = \n+    { \"ES\", \"EP\", \"EB\", \"EL\", \"EY\", \"IB\", \"IL\", \"IN\", \"IE\", \"EI\", \"ER\" };\n+    private static final String[] L_T_K_S_N_M_B_Z = \n+    { \"L\", \"T\", \"K\", \"S\", \"N\", \"M\", \"B\", \"Z\" };\n+\n+    private int maxCodeLen = 4;\n+\n+    public DoubleMetaphone() {\n+        super();\n+    }\n+    \n+    /**\n+     * Encode a value with Double Metaphone\n+     */\n+    public String doubleMetaphone(String value) {\n+        return doubleMetaphone(value, false);\n+    }\n+    \n+    /**\n+     * Encode a value with Double Metaphone, optionally using the alternate\n+     * encoding.\n+     */\n+    public String doubleMetaphone(String value, boolean alternate) {\n+        value = cleanInput(value);\n+        if (value == null) {\n+            return null;\n+        }\n+        \n+        boolean slavoGermanic = isSlavoGermanic(value);\n+        int index = isSilentStart(value) ? 1 : 0;\n+        \n+        DoubleMetaphoneResult result = new DoubleMetaphoneResult(maxCodeLen);\n+        \n+        while (!result.isComplete() && index <= value.length() - 1) {\n+            switch (value.charAt(index)) {\n+            case 'A':\n+            case 'E':\n+            case 'I':\n+            case 'O':\n+            case 'U':\n+            case 'Y':\n+                index = handleAEIOUY(value, result, index);\n+                break;\n+            case 'B':\n+                result.append('P');\n+                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n+                break;\n+            case '\u00c7':\n+                result.append('S');\n+                index++;\n+                break;\n+            case 'C':\n+                index = handleC(value, result, index);\n+                break;\n+            case 'D':\n+                index = handleD(value, result, index);\n+                break;\n+            case 'F':\n+                result.append('F');\n+                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n+                break;\n+            case 'G':\n+                index = handleG(value, result, index, slavoGermanic);\n+                break;\n+            case 'H':\n+                index = handleH(value, result, index);\n+                break;\n+            case 'J':\n+                index = handleJ(value, result, index, slavoGermanic);\n+                break;\n+            case 'K':\n+                result.append('K');\n+                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n+                break;\n+            case 'L':\n+                index = handleL(value, result, index);\n+                break;\n+            case 'M':\n+                result.append('M');\n+                index = conditionM0(value, index) ? index + 2 : index + 1;\n+                break;\n+            case 'N':\n+                result.append('N');\n+                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n+                break;\n+            case '\u00d1':\n+                result.append('N');\n+                index++;\n+                break;\n+            case 'P':\n+                index = handleP(value, result, index);\n+                break;\n+            case 'Q':\n+                result.append('K');\n+                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n+                break;\n+            case 'R':\n+                index = handleR(value, result, index, slavoGermanic);\n+                break;\n+            case 'S':\n+                index = handleS(value, result, index, slavoGermanic);\n+                break;\n+            case 'T':\n+                index = handleT(value, result, index);\n+                break;\n+            case 'V':\n+                result.append('F');\n+                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n+                break;\n+            case 'W':\n+                index = handleW(value, result, index);\n+                break;\n+            case 'X':\n+                index = handleX(value, result, index);\n+                break;\n+            case 'Z':\n+                index = handleZ(value, result, index, slavoGermanic);\n+                break;\n+            default:\n+                index++;\n+                break;\n+            }\n+        }\n+\n+        return alternate ? result.getAlternate() : result.getPrimary();\n+    }\n+    \n+    /**\n+     * Encode the value using DoubleMetaphone.  It will only work if \n+     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\n+     */\n+    public Object encode(Object obj) throws EncoderException {\n+        Object result;\n+\n+        if (!(obj instanceof String)) {\n+            throw new EncoderException(\"Parameter supplied to Metaphone \" \n+                                       + \"encode is not of type \" \n+                                       + \"java.lang.String\"); \n+        } else {\n+            return doubleMetaphone((String) obj);\n+        }\n+    }\n+\n+    /**\n+     * Encode the value using DoubleMetaphone\n+     */\n+    public String encode(String value) throws EncoderException {\n+        return (doubleMetaphone(value));   \n+    }\n+\n+    /**\n+     * Check if the Double Metaphone values of two <code>String</code> values\n+     * are equal\n+     */\n+    public boolean isDoubleMetaphoneEqual(String value1, String value2) {\n+        return isDoubleMetaphoneEqual(value1, value2, false);\n+    }\n+    \n+    /**\n+     * Check if the Double Metaphone values of two <code>String</code> values\n+     * are equal, optionally using the alternate value\n+     */\n+    public boolean isDoubleMetaphoneEqual(String value1, String value2, boolean \n+                                          alternate) {\n+        return doubleMetaphone(value1, alternate).equals(doubleMetaphone\n+                                                         (value2, alternate));\n+    }\n+    \n+    /**\n+     * Returns the maxCodeLen.\n+     * @return int\n+     */\n+    public int getMaxCodeLen() {\n+        return maxCodeLen;\n+    }\n+\n+    /**\n+     * Sets the maxCodeLen.\n+     * @param maxCodeLen The maxCodeLen to set\n+     */\n+    public void setMaxCodeLen(int maxCodeLen) {\n+        this.maxCodeLen = maxCodeLen;\n+    }\n+\n+    //-- BEGIN HANDLERS --//\n+\n+    /**\n+     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases\n+     */\n+    private int handleAEIOUY(String value, DoubleMetaphoneResult result, int \n+                             index) {\n+        if (index == 0) {\n+            result.append('A');\n+        }\n+        return index + 1;\n+    }\n+    \n+    /**\n+     * Handles 'C' cases\n+     */\n+    private int handleC(String value, DoubleMetaphoneResult result, int index) {\n+        if (conditionC0(value, index)) {  // very confusing, moved out\n+            result.append('K');\n+            index += 2;\n+        } else if (index == 0 && contains(value, index, 6, \"CAESAR\")) {\n+            result.append('S');\n+            index += 2;\n+        } else if (contains(value, index, 2, \"CH\")) {\n+            index = handleCH(value, result, index);\n+        } else if (contains(value, index, 2, \"CZ\") && \n+                   !contains(value, index - 2, 4, \"WICZ\")) {\n+            //-- \"Czerny\" --//\n+            result.append('S', 'X');\n+            index += 2;\n+        } else if (contains(value, index + 1, 3, \"CIA\")) {\n+            //-- \"focaccia\" --//\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 2, \"CC\") && \n+                   !(index == 1 && charAt(value, 0) == 'M')) {\n+            //-- double \"cc\" but not \"McClelland\" --//\n+            return handleCC(value, result, index);\n+        } else if (contains(value, index, 2, \"CK\", \"CG\", \"CQ\")) {\n+            result.append('K');\n+            index += 2;\n+        } else if (contains(value, index, 2, \"CI\", \"CE\", \"CY\")) {\n+            //-- Italian vs. English --//\n+            if (contains(value, index, 3, \"CIO\", \"CIE\", \"CIA\")) {\n+                result.append('S', 'X');\n+            } else {\n+                result.append('S');\n+            }\n+            index += 2;\n+        } else {\n+            result.append('K');\n+            if (contains(value, index + 1, 2, \" C\", \" Q\", \" G\")) { \n+                //-- Mac Caffrey, Mac Gregor --//\n+                index += 3;\n+            } else if (contains(value, index + 1, 1, \"C\", \"K\", \"Q\") && \n+                       !contains(value, index + 1, 2, \"CE\", \"CI\")) {\n+                index += 2;\n+            } else {\n+                index++;\n+            }\n+        }\n+        \n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'CC' cases\n+     */\n+    private int handleCC(String value, DoubleMetaphoneResult result, int index) \n+    {\n+        if (contains(value, index + 2, 1, \"I\", \"E\", \"H\") && \n+            !contains(value, index + 2, 2, \"HU\")) {\n+            //-- \"bellocchio\" but not \"bacchus\" --//\n+            if ((index == 1 && charAt(value, index - 1) == 'A') || \n+                contains(value, index - 1, 5, \"UCCEE\", \"UCCES\")) {\n+                //-- \"accident\", \"accede\", \"succeed\" --//\n+                result.append(\"KS\");\n+            } else {\n+                //-- \"bacci\", \"bertucci\", other Italian --//\n+                result.append('X');\n+            }\n+            index += 3;\n+        } else {    // Pierce's rule\n+            result.append('K');\n+            index += 2;\n+        }\n+        \n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'CH' cases\n+     */\n+    private int handleCH(String value, DoubleMetaphoneResult result, int index) \n+    {\n+        if (index > 0 && contains(value, index, 4, \"CHAE\")) {   // Michael\n+            result.append('K', 'X');\n+            return index + 2;\n+        } else if (conditionCH0(value, index)) {\n+            //-- Greek roots (\"chemistry\", \"chorus\", etc.) --//\n+            result.append('K');\n+            return index + 2;\n+        } else if (conditionCH1(value, index)) {\n+            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\n+            result.append('K');\n+            return index + 2;\n+        } else {\n+            if (index > 0) {\n+                if (contains(value, 0, 2, \"MC\")) {\n+                    result.append('K');\n+                } else {\n+                    result.append('X', 'K');\n+                }\n+            } else {\n+                result.append('X');\n+            }\n+            return index + 2;\n+        }\n+    }\n+\n+    /**\n+     * Handles 'D' cases\n+     */\n+    private int handleD(String value, DoubleMetaphoneResult result, int index) {\n+        if (contains(value, index, 2, \"DG\")) {\n+            //-- \"Edge\" --//\n+            if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n+                result.append('J');\n+                index += 3;\n+                //-- \"Edgar\" --//\n+            } else {\n+                result.append(\"TK\");\n+                index += 2;\n+            }\n+        } else if (contains(value, index, 2, \"DT\", \"DD\")) {\n+            result.append('T');\n+            index += 2;\n+        } else {\n+            result.append('T');\n+            index++;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'G' cases\n+     */\n+    private int handleG(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (charAt(value, index + 1) == 'H') {\n+            index = handleGH(value, result, index);\n+        } else if (charAt(value, index + 1) == 'N') {\n+            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n+                result.append(\"KN\", \"N\");\n+            } else if (!contains(value, index + 2, 2, \"EY\") && \n+                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n+                result.append(\"N\", \"KN\");\n+            } else {\n+                result.append(\"KN\");\n+            }\n+            index = index + 2;\n+        } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n+            result.append(\"KL\", \"L\");\n+            index += 2;\n+        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains\n+                                  (value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n+            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n+            result.append('K', 'J');\n+            index += 2;\n+        } else if ((contains(value, index + 1, 2, \"ER\") || charAt(value, index \n+                                                                  + 1) == 'Y') &&\n+                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n+                   !contains(value, index - 1, 1, \"E\", \"I\") && \n+                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n+            //-- -ger-, -gy- --//\n+            result.append('K', 'J');\n+            index += 2;\n+        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n+                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n+            //-- Italian \"biaggi\" --//\n+            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, \n+                                                                   3, \"SCH\")) ||\n+                contains(value, index + 1, 2, \"ET\")) {\n+                //-- obvious germanic --//\n+                result.append('K');\n+            } else if (contains(value, index + 1, 4, \"IER\")) {\n+                result.append('J');\n+            } else {\n+                result.append('J', 'K');\n+            }\n+            index += 2;\n+        } else if (charAt(value, index + 1) == 'G') {\n+            index += 2;\n+            result.append('K');\n+        } else {\n+            index++;\n+            result.append('K');\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'GH' cases\n+     */\n+    private int handleGH(String value, DoubleMetaphoneResult result, int index) \n+    {\n+        if (index > 0 && !isVowel(charAt(value, index - 1))) {\n+            result.append('K');\n+            index += 2;\n+        } else if (index == 0) {\n+            if (charAt(value, index + 2) == 'I') {\n+                result.append('J');\n+            } else {\n+                result.append('K');\n+            }\n+            index += 2;\n+        } else if ((index > 1 && contains(value, index - 2, 1, \"B\", \"H\", \"D\")) \n+                   ||\n+                   (index > 2 && contains(value, index - 3, 1, \"B\", \"H\", \"D\")) \n+                   ||\n+                   (index > 3 && contains(value, index - 4, 1, \"B\", \"H\"))) {\n+            //-- Parker's rule (with some further refinements) - \"hugh\"\n+            index += 2;\n+        } else {\n+            if (index > 2 && charAt(value, index - 1) == 'U' && \n+                contains(value, index - 3, 1, \"C\", \"G\", \"L\", \"R\", \"T\")) {\n+                //-- \"laugh\", \"McLaughlin\", \"cough\", \"gough\", \"rough\", \"tough\"\n+                result.append('F');\n+            } else if (index > 0 && charAt(value, index - 1) != 'I') {\n+                result.append('K');\n+            }\n+            index += 2;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'H' cases\n+     */\n+    private int handleH(String value, DoubleMetaphoneResult result, int index) {\n+        //-- only keep if first & before vowel or between 2 vowels --//\n+        if ((index == 0 || isVowel(charAt(value, index - 1))) && \n+            isVowel(charAt(value, index + 1))) {\n+            result.append('H');\n+            index += 2;\n+            //-- also takes car of \"HH\" --//\n+        } else {\n+            index++;\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'J' cases\n+     */\n+    private int handleJ(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (contains(value, index, 4, \"JOSE\") || contains(value, 0, 4, \"SAN \")) \n+            {\n+                //-- obvious Spanish, \"Jose\", \"San Jacinto\" --//\n+                if ((index == 0 && (charAt(value, index + 4) == ' ') || \n+                     value.length() == 4) || contains(value, 0, 4, \"SAN \")) {\n+                    result.append('H');\n+                } else {\n+                    result.append('J', 'H');\n+                }\n+                index++;\n+            } else {\n+                if (index == 0 && !contains(value, index, 4, \"JOSE\")) {\n+                    result.append('J', 'A');\n+                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && \n+                           (charAt(value, index + 1) == 'A' || \n+                            charAt(value, index + 1) == 'O')) {\n+                    result.append('J', 'H');\n+                } else if (index == value.length() - 1) {\n+                    result.append('J', ' ');\n+                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !\n+                           contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {\n+                    result.append('J');\n+                }\n+\n+                if (charAt(value, index + 1) == 'J') {\n+                    index += 2;\n+                } else {\n+                    index++;\n+                }\n+            }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'L' cases\n+     */\n+    private int handleL(String value, DoubleMetaphoneResult result, int index) {\n+        result.append('L');\n+        if (charAt(value, index + 1) == 'L') {\n+            if (conditionL0(value, index)) {\n+                result.appendAlternate(' ');\n+            }\n+            index += 2;\n+        } else {\n+            index++;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'P' cases\n+     */\n+    private int handleP(String value, DoubleMetaphoneResult result, int index) {\n+        if (charAt(value, index + 1) == 'H') {\n+            result.append('F');\n+            index += 2;\n+        } else {\n+            result.append('P');\n+            index = contains(value, index + 1, 1, \"P\", \"B\") ? index + 2 : index \n+                + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'R' cases\n+     */\n+    private int handleR(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (index == value.length() - 1 && !slavoGermanic && \n+            contains(value, index - 2, 2, \"IE\") && \n+            !contains(value, index - 4, 2, \"ME\", \"MA\")) {\n+            result.appendAlternate('R');\n+        } else {\n+            result.append('R');\n+        }\n+        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\n+    }\n+\n+    /**\n+     * Handles 'S' cases\n+     */\n+    private int handleS(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (contains(value, index - 1, 3, \"ISL\", \"YSL\")) {\n+            //-- special cases \"island\", \"isle\", \"carlisle\", \"carlysle\" --//\n+            index++;\n+        } else if (index == 0 && contains(value, index, 5, \"SUGAR\")) {\n+            //-- special case \"sugar-\" --//\n+            result.append('X', 'S');\n+            index++;\n+        } else if (contains(value, index, 2, \"SH\")) {\n+            if (contains(value, index + 1, 4, \"HEIM\", \"HOEK\", \"HOLM\", \"HOLZ\")) {\n+                //-- germanic --//\n+                result.append('S');\n+            } else {\n+                result.append('X');\n+            }\n+            index += 2;\n+        } else if (contains(value, index, 3, \"SIO\", \"SIA\") || contains(value, \n+                                                                       index, 4, \"SIAN\")) {\n+            //-- Italian and Armenian --//\n+            if (slavoGermanic) {\n+                result.append('S');\n+            } else {\n+                result.append('S', 'X');\n+            }\n+            index += 3;\n+        } else if ((index == 0 && contains(value, index + 1, \n+                                           1, \"M\", \"N\", \"L\", \"W\")) || contains(value, index + 1, 1, \"Z\")) {\n+            //-- german & anglicisations, e.g. \"smith\" match \"schmidt\", \"snider\" match \"schneider\" --//\n+                //-- also, -sz- in slavic language altho in hungarian it is pronounced \"s\" --//\n+                result.append('S', 'X');\n+            index = contains(value, index + 1, 1, \"Z\") ? index + 2 : index + 1;\n+        } else if (contains(value, index, 2, \"SC\")) {\n+            index = handleSC(value, result, index);\n+        } else {\n+            if (index == value.length() - 1 && contains(value, index - 2, \n+                                                        2, \"AI\", \"OI\")){\n+                //-- french e.g. \"resnais\", \"artois\" --//\n+                result.appendAlternate('S');\n+            } else {\n+                result.append('S');\n+            }\n+            index = contains(value, index + 1, 1, \"S\", \"Z\") ? index + 2 : index \n+                + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'SC' cases\n+     */\n+    private int handleSC(String value, DoubleMetaphoneResult result, int index) \n+    {\n+        if (charAt(value, index + 2) == 'H') {\n+            //-- Schlesinger's rule --//\n+            if (contains(value, index + 3, \n+                         2, \"OO\", \"ER\", \"EN\", \"UY\", \"ED\", \"EM\")) {\n+                //-- Dutch origin, e.g. \"school\", \"schooner\" --//\n+                if (contains(value, index + 3, 2, \"ER\", \"EN\")) {\n+                    //-- \"schermerhorn\", \"schenker\" --//\n+                    result.append(\"X\", \"SK\");\n+                } else {\n+                    result.append(\"SK\");\n+                }\n+            } else {\n+                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, \n+                                                                       3) != 'W') {\n+                    result.append('X', 'S');\n+                } else {\n+                    result.append('X');\n+                }\n+            }\n+        } else if (contains(value, index + 2, 1, \"I\", \"E\", \"Y\")) {\n+            result.append('S');\n+        } else {\n+            result.append(\"SK\");\n+        }\n+        return index + 3;\n+    }\n+\n+    /**\n+     * Handles 'T' cases\n+     */\n+    private int handleT(String value, DoubleMetaphoneResult result, int index) {\n+        if (contains(value, index, 4, \"TION\")) {\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 3, \"TIA\", \"TCH\")) {\n+            result.append('X');\n+            index += 3;\n+        } else if (contains(value, index, 2, \"TH\") || contains(value, index, \n+                                                               3, \"TTH\")) {\n+            if (contains(value, index + 2, 2, \"OM\", \"AM\") || \n+                //-- special case \"thomas\", \"thames\" or germanic --//\n+                contains(value, 0, 4, \"VAN \", \"VON \") || \n+                contains(value, 0, 3, \"SCH\")) {\n+                result.append('T');\n+            } else {\n+                result.append('0', 'T');\n+            }\n+            index += 2;\n+        } else {\n+            result.append('T');\n+            index = contains(value, index + 1, 1, \"T\", \"D\") ? index + 2 : index \n+                + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'W' cases\n+     */\n+    private int handleW(String value, DoubleMetaphoneResult result, int index) {\n+        if (contains(value, index, 2, \"WR\")) {\n+            //-- can also be in middle of word --//\n+            result.append('R');\n+            index += 2;\n+        } else {\n+            if (index == 0 && (isVowel(charAt(value, index + 1)) || \n+                               contains(value, index, 2, \"WH\"))) {\n+                if (isVowel(charAt(value, index + 1))) {\n+                    //-- Wasserman should match Vasserman --//\n+                    result.append('A', 'F');\n+                } else {\n+                    //-- need Uomo to match Womo --//\n+                    result.append('A');\n+                }\n+                index++;\n+            } else if ((index == value.length() - 1 && isVowel(charAt(value, \n+                                                                      index - 1))) ||\n+                       contains(value, index - 1, \n+                                5, \"EWSKI\", \"EWSKY\", \"OWSKI\", \"OWSKY\") ||\n+                       contains(value, 0, 3, \"SCH\")) {\n+                //-- Arnow should match Arnoff --//\n+                result.appendAlternate('F');\n+                index++;\n+            } else if (contains(value, index, 4, \"WICZ\", \"WITZ\")) {\n+                //-- Polish e.g. \"filipowicz\" --//\n+                result.append(\"TS\", \"FX\");\n+                index += 4;\n+            } else {\n+                index++;\n+            }\n+        }\n+        return index;\n+    }\n+    \n+    /**\n+     * Handles 'X' cases\n+     */\n+    private int handleX(String value, DoubleMetaphoneResult result, int index) {\n+        if (index == 0) {\n+            result.append('S');\n+            index++;\n+        } else {\n+            if (!((index == value.length() - 1) && \n+                  (contains(value, index - 3, 3, \"IAU\", \"EAU\") || \n+                   contains(value, index - 2, 2, \"AU\", \"OU\")))) {\n+                //-- French e.g. breaux --//\n+                result.append(\"KS\");\n+            }\n+            index = contains(value, index + 1, 1, \"C\", \"X\") ? index + 2 : index \n+                + 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Handles 'Z' cases\n+     */\n+    private int handleZ(String value, DoubleMetaphoneResult result, int index, \n+                        boolean slavoGermanic) {\n+        if (charAt(value, index + 1) == 'H') {\n+            //-- Chinese pinyin e.g. \"zhao\" or Angelina \"Zhang\" --//\n+            result.append('J');\n+            index += 2;\n+        } else {\n+            if (contains(value, index + 1, 2, \"ZO\", \"ZI\", \"ZA\") || \n+                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\n+                result.append(\"S\", \"TS\");\n+            } else {\n+                result.append('S');\n+            }\n+            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\n+        }\n+        return index;\n+    }\n+\n+    //-- BEGIN CONDITIONS --//\n+\n+    /**\n+     * Complex condition 0 for 'C'\n+     */\n+    private boolean conditionC0(String value, int index) {\n+        if (contains(value, index, 4, \"CHIA\")) {\n+            return true;\n+        } else if (index <= 1) {\n+            return false;\n+        } else if (isVowel(charAt(value, index - 2))) {\n+            return false;\n+        } else if (!contains(value, index - 1, 3, \"ACH\")) {\n+            return false;\n+        } else {\n+            char c = charAt(value, index + 2);\n+            if ((c != 'I' && c != 'E') || contains(value, index - 2, \n+                                                   6, \"BACHER\", \"MACHER\" )) {\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'CH'\n+     */\n+    private boolean conditionCH0(String value, int index) {\n+        if (index != 0) {\n+            return false;\n+        } else if (!contains(value, index + 1, 5, \"HARAC\", \"HARIS\") && \n+                   !contains(value, index + 1, 3, \"HOR\", \"HYM\", \"HIA\", \"HEM\")) {\n+            return false;\n+        } else if (contains(value, 0, 5, \"CHORE\")) {\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 1 for 'CH'\n+     */\n+    private boolean conditionCH1(String value, int index) {\n+        return ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, \n+                                                                   3, \"SCH\")) ||\n+                contains(value, index - 2, 6, \"ORCHES\", \"ARCHIT\", \"ORCHID\") ||\n+                contains(value, index + 2, 1, \"T\", \"S\") ||\n+                ((contains(value, index - 1, 1, \"A\", \"O\", \"U\", \"E\") || index == \n+                  0) &&\n+                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index \n+                  + 1 == value.length() - 1)));\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'L'\n+     */\n+    private boolean conditionL0(String value, int index) {\n+        if (index == value.length() - 3 && \n+            contains(value, index - 1, 4, \"ILLO\", \"ILLA\", \"ALLE\")) {\n+            return true;\n+        } else if ((contains(value, index - 1, 2, \"AS\", \"OS\") || \n+                    contains(value, value.length() - 1, 1, \"A\", \"O\")) &&\n+                   contains(value, index - 1, 4, \"ALLE\")) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Complex condition 0 for 'M'\n+     */\n+    private boolean conditionM0(String value, int index) {\n+        if (charAt(value, index + 1) == 'M') {\n+            return true;\n+        } else {\n+            return contains(value, index - 1, 3, \"UMB\") &&\n+                ((index + 1) == value.length() - 1 || \n+                 contains(value, index + 2, 2, \"ER\"));\n+        }\n+    }\n+    \n+    //-- BEGIN HELPER FUNCTIONS --//\n+\n+    /**\n+     * Determines whether or not a value is of slavo-germanic orgin.  A value is\n+     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\n+     */\n+    private boolean isSlavoGermanic(String value) {\n+        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || \n+            value.indexOf(\"CZ\") > -1 || value.indexOf(\"WITZ\") > -1;\n+    }\n+\n+    /**\n+     * Determines whether or not a character is a vowel or not\n+     */\n+    private boolean isVowel(char ch) {\n+        return VOWELS.indexOf(ch) != -1;\n+    }\n+\n+    /**\n+     * Determines whether or not the value starts with a silent letter.  It will\n+     * return <code>true</code> if the value starts with any of 'GN', 'KN',\n+     * 'PN', 'WR' or 'PS'.\n+     */    \n+    private boolean isSilentStart(String value) {\n+        boolean result = false;\n+        for (int i = 0; i < SILENT_START.length; i++) {\n+            if (value.startsWith(SILENT_START[i])) {\n+                result = true;\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Cleans the input\n+     */    \n+    private String cleanInput(String input) {\n+        if (input == null) {\n+            return null;\n+        } else {\n+            input = input.trim();\n+            if (input.length() == 0) {\n+                return null;\n+            } else {\n+                return input.toUpperCase();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the character at index <code>index</code> if available, otherwise it\n+     * returns <code>Character.MIN_VALUE</code> so that there is some sort of a\n+     * default\n+     */    \n+    protected char charAt(String value, int index) {\n+        if (index < 0 || index >= value.length()) {\n+            return Character.MIN_VALUE;\n+        } else {\n+            return value.charAt(index);\n+        }\n+    }\n+\n+    /**\n+     * Shortcut method with 1 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria) {\n+        return contains(value, start, length, \n+                        new String[] { criteria });\n+    }\n+\n+    /**\n+     * Shortcut method with 2 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2 });\n+    }\n+\n+    /**\n+     * Shortcut method with 3 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3 });\n+    }\n+\n+    /**\n+     * Shortcut method with 4 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4 });\n+    }\n+\n+    /**\n+     * Shortcut method with 5 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4, \n+                                    String criteria5) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4, criteria5 });\n+    }\n+\n+    /**\n+     * Shortcut method with 6 criteria\n+     */    \n+    private static boolean contains(String value, int start, int length, \n+                                    String criteria1, String criteria2, \n+                                    String criteria3, String criteria4, \n+                                    String criteria5, String criteria6) {\n+        return contains(value, start, length, \n+                        new String[] { criteria1, criteria2, criteria3, \n+                                       criteria4, criteria5, criteria6 });\n+    }\n+    \n+    /**\n+     * Determines whether <code>value</code> contains any of the criteria \n+     starting\n+     * at index <code>start</code> and matching up to length <code>length</code>\n+     */    \n+    protected static boolean contains(String value, int start, int length, \n+                                      String[] criteria) {\n+        boolean result = false;\n+        if (start >= 0 && start + length <= value.length()) {\n+            String target = value.substring(start, start + length);\n+\n+            for (int i = 0; i < criteria.length; i++) {\n+                if (target.equals(criteria[i])) {\n+                    result = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    //-- BEGIN INNER CLASSES --//\n+    \n+    /**\n+     * Inner class for storing results, since there is the optional alternate\n+     * encoding.\n+     */\n+    public class DoubleMetaphoneResult {\n+\n+        private StringBuffer primary = new StringBuffer(maxCodeLen);\n+        private StringBuffer alternate = new StringBuffer(maxCodeLen);\n+        private int maxLength;\n+\n+        public DoubleMetaphoneResult(int maxLength) {\n+            this.maxLength = maxLength;\n+        }\n+\n+        public void append(char value) {\n+            appendPrimary(value);\n+            appendAlternate(value);\n+        }\n+\n+        public void append(char primary, char alternate) {\n+            appendPrimary(primary);\n+            appendAlternate(alternate);\n+        }\n+\n+        public void appendPrimary(char value) {\n+            if (primary.length() < maxLength) {\n+                primary.append(value);\n+            }\n+        }\n+\n+        public void appendAlternate(char value) {\n+            if (alternate.length() < maxLength) {\n+                alternate.append(value);\n+            }\n+        }\n+\n+        public void append(String value) {\n+            appendPrimary(value);\n+            appendAlternate(value);\n+        }\n+\n+        public void append(String primary, String alternate) {\n+            appendPrimary(primary);\n+            appendAlternate(alternate);\n+        }\n+\n+        public void appendPrimary(String value) {\n+            int addChars = maxLength - primary.length();\n+            if (value.length() <= addChars) {\n+                primary.append(value);\n+            } else {\n+                primary.append(value.substring(0, addChars));\n+            }\n+        }\n+\n+        public void appendAlternate(String value) {\n+            int addChars = maxLength - alternate.length();\n+            if (value.length() <= addChars) {\n+                alternate.append(value);\n+            } else {\n+                alternate.append(value.substring(0, addChars));\n+            }\n+        }\n+\n+        public String getPrimary() {\n+            return primary.toString();\n+        }\n+\n+        public String getAlternate() {\n+            return alternate.toString();\n+        }\n+\n+        public boolean isComplete() {\n+            return primary.length() >= maxLength && \n+                alternate.length() >= maxLength;\n+        }\n+    }\n+}", "timestamp": 1055301806, "metainfo": ""}