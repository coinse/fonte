{"sha": "f9df51847e354190206432ba87661586e6dc814d", "log": "iterator for all Option instances parsed   ", "commit": "\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n     /** the unrecognised options/arguments */\n     private List args    = new LinkedList();\n \n-    /** the recognised options */\n-    private Map  options = new HashMap();\n+    /** the processed options */\n+    private Map options = new HashMap();\n+\n+    /** Map of unique options for ease to get complete list of options */\n+    private Map hashcodeMap = new HashMap();\n \n     /** the processed options */\n     private Option[] optionsArray;\n      */\n     public Object getOptionObject( String opt ) {\n         String res = getOptionValue( opt );\n-        Object type = ((Option)options.get( opt )).getType();\n+        \n+        Object type = ((Option)((List)options.get(opt)).iterator().next()).getType();\n         return res == null ? null : TypeHandler.createValue(res, type);\n     }\n \n      * @return Value of the argument if option is set, and has an argument, else null.\n      */\n     public String getOptionValue( String opt ) {\n-        return (String)((Option)options.get( opt )).getValue();\n+        String[] values = getOptionValues(opt);\n+        return (values == null) ? null : values[0];\n     }\n \n     /** <p>Retrieve the argument, if any,  of an option.</p>\n      * @return An array of values if the option is set, and has an argument, else null.\n      */\n     public String[] getOptionValues( String opt ) {\n-        return (String[])((Option)options.get( opt )).getValues();\n+        List values = new java.util.ArrayList();\n+\n+        List opts = (List)options.get( opt );\n+        Iterator iter = opts.iterator();\n+\n+        while( iter.hasNext() ) {\n+            Option optt = (Option)iter.next();\n+            values.addAll( optt.getValuesList() );\n+        }\n+        return (values.size() == 0) ? null : (String[])values.toArray(new String[]{});\n     }\n \n     /** <p>Retrieves the array of values, if any, of an option.</p>\n         return args;\n     }\n     \n-    /** <p>Dump state, suitable for debugging.</p>\n+    /** \n+     * jkeyes\n+     * - commented out until it is implemented properly\n+     * <p>Dump state, suitable for debugging.</p>\n      *\n      * @return Stringified form of this object\n      */\n+    /*\n     public String toString() {\n         StringBuffer buf = new StringBuffer();\n         \n         \n         return buf.toString();\n     }\n-    \n+    */\n+\n     /**\n      * <p>Add left-over unrecognized option/argument.</p>\n      *\n      * @param opt the processed option\n      */\n     void setOpt( Option opt ) {\n-        options.put( opt.getOpt(), opt );\n+        hashcodeMap.put( new Integer( opt.hashCode() ), opt );\n+\n+        if( options.get( opt.getOpt() ) != null ) {\n+            ((java.util.List)options.get( opt.getOpt() )).add( opt );\n+        }\n+        else {\n+            options.put( opt.getOpt(), new java.util.ArrayList() );\n+            ((java.util.List)options.get( opt.getOpt() ) ).add( opt );\n+        }\n     }\n \n     /**\n      * members of this {@link CommandLine}\n      */\n     public Iterator iterator( ) {\n-        return options.values().iterator();\n+        return hashcodeMap.values().iterator();\n     }\n \n     /**\n      * @return an array of the processed {@link Option}s.\n      */\n     public Option[] getOptions( ) {\n-        Collection processed = options.values();\n+        Collection processed = hashcodeMap.values();\n \n         // reinitialise array\n         optionsArray = new Option[ processed.size() ];\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.4 2002/08/04 23:04:52 jkeyes Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/04 23:04:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.5 2002/08/14 22:27:39 jkeyes Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/08/14 22:27:39 $\n  *\n  * ====================================================================\n  *\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.ListIterator;\n+import java.util.Map;\n \n /**\n  * GnuParser parses the command line arguments using the GNU style.\n     private CommandLine cmd;\n \n     /** required options subset of options */\n-    private Collection requiredOptions;\n+    private Map requiredOptions;\n \n     /**\n      * Parse the arguments according to the specified options.\n                 break;\n             }\n             // its a value\n-            else {\n-                char sep = opt.getValueSeparator();\n-                \n-                if( sep > 0 ) {\n-                    int findex;\n-                    while( ( findex = var.indexOf( sep ) ) != -1 ) {\n-                        String val = var.substring( 0, findex );\n-                        var = var.substring( findex + 1);\n-                        if( !opt.addValue( val ) ) {\n-                            iter.previous();\n-                            return;\n-                        }\n-                    }\n-                    if( !opt.addValue( var ) ) {\n-                        iter.previous();\n-                        return;\n-                    };\n-                }\n-                else if( !opt.addValue( var ) ) {\n-                    iter.previous();\n-                    return;\n-                }\n+            else if( !opt.addValue( var ) ) {\n+                iter.previous();\n+                return;\n             }\n         }\n     }\n         // if there are required options that have not been\n         // processsed\n         if( requiredOptions.size() > 0 ) {\n-            Iterator iter = requiredOptions.iterator();\n+            Iterator iter = requiredOptions.values().iterator();\n             StringBuffer buff = new StringBuffer();\n \n             // loop through the required options\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n  * @version $Revision: 1.6 $\n  */\n \n-public class Option {\n+public class Option implements Cloneable {\n     \n     /** opt the single character representation of the option */\n     private String opt = null;\n             case UNINITIALIZED:\n                 return false;\n             case UNLIMITED_VALUES:\n+                if( getValueSeparator() > 0 ) {\n+                    int index = 0;\n+                    while( (index = value.indexOf( getValueSeparator() ) ) != -1 ) {\n+                        this.values.add( value.substring( 0, index ) );\n+                        value = value.substring( index+1 );\n+                    }\n+                }\n                 this.values.add( value );\n                 return true;\n             default:\n+                if( getValueSeparator() > 0 ) {\n+                    int index = 0;\n+                    while( (index = value.indexOf( getValueSeparator() ) ) != -1 ) {\n+                        if( values.size() > numberOfArgs-1 ) {\n+                            return false;\n+                        }\n+                        this.values.add( value.substring( 0, index ) );\n+                        value = value.substring( index+1 );\n+                    }\n+                }\n                 if( values.size() > numberOfArgs-1 ) {\n                     return false;\n                 }\n     public String[] getValues() {\n         return this.values.size()==0 ? null : (String[])this.values.toArray(new String[]{});\n     }\n+\n+    public java.util.List getValuesList() {\n+        return this.values;\n+    }\n+\n+    public Object clone() {\n+        Option option = new Option( getOpt(), getDescription() );\n+        option.setArgs( getArgs() );\n+        option.setRequired( isRequired() );\n+        option.setLongOpt( getLongOpt() );\n+        option.setType( getType() );\n+        option.setValueSeparator( getValueSeparator() );\n+        return option;\n+    }\n }\n--- a/src/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n     private HashMap optionMap = new HashMap();\n \n     /** the name of the selected option */\n-    private Option selected;\n+    private String selected;\n \n     /**\n      * add <code>opt</code> to this group\n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if ( this.selected == null || this.selected.equals( opt ) ) {\n-            this.selected = opt;\n+\n+        if ( this.selected == null || this.selected.equals( opt.getOpt() ) ) {\n+            this.selected = opt.getOpt();\n         }\n         else {\n             throw new AlreadySelectedException( \"an option from this group has \" + \n     /**\n      * @return the selected option name\n      */\n-    public Option getSelected() {\n+    public String getSelected() {\n         return selected;\n     }\n-\n-    /**\n-     * @return the usage string for this option group\n-     */\n-    /*\n-    public String usageString()\n-    {\n-        StringBuffer buff = new StringBuffer();\n-\n-        buff.append( \"<\\n\");\n-\n-        Iterator oiter = getOptions().iterator();\n-\n-        while( oiter.hasNext() )\n-        {\n-            Option option = (Option)oiter.next();\n-            Collection names = option.getNames();\n-\n-            Iterator iter = names.iterator();\n-\n-            while( iter.hasNext() )\n-            {\n-                buff.append( option.getPrefix() );\n-                buff.append( iter.next() );\n-                if( iter.hasNext() )\n-                {\n-                    buff.append( \" | \" );\n-                }\n-            }\n-            buff.append( \" \" );\n-            buff.append( option.getDescription( ) );\n-            if ( oiter.hasNext() )\n-            {\n-                buff.append( \"\\n  or\\n\" );\n-            }\n-        }\n-        buff.append( \"\\n>\");\n-        buff.append( \"\\n\" );\n-        return buff.toString();\n-    }\n-    */\n \n     /**\n      * <p>Returns the stringified version of this OptionGroup.</p>\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n         while( options.hasNext() ) {\n             Option option = (Option)options.next();\n             addOption( option );\n-            optionGroups.put( option, group );\n+\n+            optionGroups.put( option.getOpt(), group );\n         }\n \n         return this;\n      *\n      * @return Collection of required options\n      */\n-    public Collection getRequiredOptions() {\n-        return requiredOpts.values();\n+    public Map getRequiredOptions() {\n+        return requiredOpts;\n     }\n     \n     /** <p>Retrieve the named {@link Option}</p>\n      * @param opt short single-character name of the {@link Option}\n      * @return the option represented by opt\n      */\n-    public Option getOption(String opt) {\n+    public Option getOption( String opt ) {\n+\n+        Option option = null;\n \n         // short option\n         if( opt.length() == 1 ) {\n-            return (Option) shortOpts.get( \"-\" + opt );\n+            option = (Option)shortOpts.get( \"-\" + opt );\n         }\n         // long option\n         else if( opt.startsWith( \"--\" ) ) {\n-            return (Option) longOpts.get( opt );\n+            option = (Option)longOpts.get( opt );\n         }\n         // a just-in-case\n         else {\n-            return (Option) shortOpts.get( opt );\n+            option = (Option)shortOpts.get( opt );\n+        }\n+\n+        return (option == null) ? null : (Option)option.clone();\n+    }\n+\n+    boolean hasOption(String opt) {\n+\n+        // short option\n+        if( opt.length() == 1 ) {\n+            return shortOpts.containsKey( \"-\" + opt );\n+        }\n+        // long option\n+        else if( opt.startsWith( \"--\" ) ) {\n+            return longOpts.containsKey( opt );\n+        }\n+        // a just-in-case\n+        else {\n+            return shortOpts.containsKey( opt );\n         }\n     }\n \n      * of an OptionGroup, otherwise return null\n      */\n     public OptionGroup getOptionGroup( Option opt ) {\n-        return (OptionGroup)optionGroups.get( opt );\n+        return (OptionGroup)optionGroups.get( opt.getOpt() );\n     }\n     \n     /** <p>Dump state, suitable for debugging.</p>\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.5 2002/08/04 23:04:52 jkeyes Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/08/04 23:04:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.6 2002/08/14 22:27:39 jkeyes Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/08/14 22:27:39 $\n  *\n  * ====================================================================\n  *\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.ListIterator;\n+import java.util.Map;\n import java.util.Iterator;\n \n /**\n     private CommandLine cmd;\n \n     /** required options subset of options */\n-    private Collection requiredOptions;\n+    private Map requiredOptions;\n \n     /**\n      * Parse the arguments according to the specified options.\n                     // iterate over each character in the token\n                     for ( int i = 1 ; i < token.length() ; ++i ) {\n \n+                        String argname = String.valueOf( token.charAt(i) );\n                         // retrieve the associated option\n-                        Option opt = (Option) options.getOption( \n-                            String.valueOf( token.charAt(i) ) );\n+                        boolean hasOption = options.hasOption( argname );\n                         \n+                        Option opt = null;\n+\n                         // if there is an associated option\n-                        if ( opt != null ) {\n+                        if ( hasOption ) {\n+                            opt = options.getOption( argname );\n \n                             // if the option requires an argument value\n                             if ( opt.hasArg() ) {\n                                     throw new MissingArgumentException( \"Missing argument value for \" + opt.getOpt() );\n                                 }\n \n+                                /*\n                                 String var = token.substring(i+1);\n                                 char sep = opt.getValueSeparator();\n \n                                     // add the argument value\n                                     opt.addValue( token.substring(i+1) );\n                                 }\n+                                */\n+                                opt.addValue( token.substring(i+1) );\n \n                                 // set the option \n                                 cmd.setOpt( opt );\n     throws ParseException\n     {\n         // get the option represented by arg\n-        Option opt = (Option) options.getOption( arg );\n+        Option opt = null;//(Option) options.getOption( arg );\n+\n+        boolean hasOption = options.hasOption( arg );\n \n         // if there is no option throw an UnrecognisedOptionException\n-        if( opt == null ) {\n+        if( !hasOption ) {\n             throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n+        }\n+        else {\n+            opt = (Option) options.getOption( arg );\n         }\n \n         // if the option is a required option remove the option from\n         // the requiredOptions list\n         if ( opt.isRequired() ) {\n-            requiredOptions.remove( opt );\n+            requiredOptions.remove( \"-\" + opt.getOpt() );\n         }\n \n         // if the option is in an OptionGroup make that option the selected\n             }\n             // its a value\n             else {\n+                /*\n                 char sep = opt.getValueSeparator();\n                 \n                 if( sep > 0 ) {\n                     iter.previous();\n                     return;\n                 }\n+                */\n+                if( !opt.addValue( var ) ) {\n+                    iter.previous();\n+                    break;\n+                }\n             }\n         }\n     }\n         // if there are required options that have not been\n         // processsed\n         if( requiredOptions.size() > 0 ) {\n-            Iterator iter = requiredOptions.iterator();\n+            Iterator iter = requiredOptions.values().iterator();\n             StringBuffer buff = new StringBuffer();\n \n             // loop through the required options\n--- a/src/test/org/apache/commons/cli/ApplicationTest.java\n+++ b/src/test/org/apache/commons/cli/ApplicationTest.java\n         options.addOption( \"buildfile\", true, \"use given buildfile\" );\n         options.addOption( OptionBuilder.withDescription( \"use value for given property\" )\n                                         .hasArgs()\n+                                        .withValueSeparator()\n                                         .create( 'D' ) );\n                            //, null, true, , false, true );\n         options.addOption( \"find\", true, \"search for buildfile towards the root of the filesystem and use it\" );\n \n             // check multiple values\n             String[] opts = line.getOptionValues( \"D\" );\n-            assertEquals( opts[0], \"property=value\" );\n-            assertEquals( opts[1], \"property1=value1\" );\n+            assertEquals( \"property\", opts[0] );\n+            assertEquals( \"value\", opts[1] );\n+            assertEquals( \"property1\", opts[2] );\n+            assertEquals( \"value1\", opts[3] );\n \n             // check single value\n             assertEquals( line.getOptionValue( \"buildfile\"), \"mybuild.xml\" );\n--- a/src/test/org/apache/commons/cli/ValuesTest.java\n+++ b/src/test/org/apache/commons/cli/ValuesTest.java\n                         .create( 'i' ) );\n \n         opts.addOption( OptionBuilder.withLongOpt( \"j\" )\n-                        .hasArgs( 2 )\n+                        .hasArgs( )\n                         .withDescription( \"set -j\")\n                         .withValueSeparator( '=' )\n                         .create( 'j' ) );\n \n     public void testExtraArgs()\n     {\n-        String[] args = new String[] { \"arg1\", \"arg2\", \"arg3\", \"key=value\" };\n-        assertTrue( _cmdline.getArgs().length == 4 );         \n+        String[] args = new String[] { \"arg1\", \"arg2\", \"arg3\" };\n+        assertTrue( _cmdline.getArgs().length == 3 );         \n         assertTrue( Arrays.equals( args, _cmdline.getArgs() ) );\n     }\n \n     {\n         // tests the char methods of CommandLine that delegate to\n         // the String methods\n-        String[] values = new String[] { \"key\", \"value\" };\n+        String[] values = new String[] { \"key\", \"value\", \"key\", \"value\" };\n         assertTrue( _cmdline.hasOption( \"j\" ) );\n         assertTrue( _cmdline.hasOption( 'j' ) );\n-        assertTrue( _cmdline.getOptionValues( \"j\" ).length == 2);\n-        assertTrue( _cmdline.getOptionValues( 'j' ).length == 2);\n+        assertTrue( _cmdline.getOptionValues( \"j\" ).length == 4);\n+        assertTrue( _cmdline.getOptionValues( 'j' ).length == 4);\n         assertTrue( Arrays.equals( values, _cmdline.getOptionValues( \"j\" ) ) );\n         assertTrue( Arrays.equals( values, _cmdline.getOptionValues( 'j' ) ) );\n \n         assertTrue( Arrays.equals( values, _cmdline.getOptionValues( 'm' ) ) );\n     }\n \n+    /**\n+     * jkeyes - commented out this test as the new architecture\n+     * breaks this type of functionality.  I have left the test \n+     * here in case I get a brainwave on how to resolve this.\n+     */\n+    /*\n     public void testGetValue()\n     {\n         // the 'm' option\n         catch( IndexOutOfBoundsException exp ) {\n \n         }\n-\n-    }\n+    }\n+    */\n }", "timestamp": 1029364060, "metainfo": ""}