{"sha": "7fb448fe0afe4fe9d49e9a05e7e208ebe06b2fee", "log": "Implemented definition time defaults: Option - added defaults(WriteableCommandLine) WriteableCommandLine - added setDefaultValues(Option,List) WriteableCommandLine - added setDefaultSwitch(Option,Boolean) Argument - add defaults(WriteableCommandLine,Option) CommandLineDefaultsTest - test the defaults in combination Parser - now applys the defaults before processing Implemented new methods   ", "commit": "\n--- a/src/java/org/apache/commons/cli2/Argument.java\n+++ b/src/java/org/apache/commons/cli2/Argument.java\n         final ListIterator args,\n         final Option option)\n             throws OptionException;\n+    \n+    /**\n+     * Adds defaults to a CommandLine.\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store defaults in.\n+     * @param option\n+     *            The Option to store the defaults against.\n+     */\n+    void defaultValues(final WriteableCommandLine commandLine, final Option option);\n \n     /**\n      * Performs any necessary validation on the values added to the\n--- a/src/java/org/apache/commons/cli2/Option.java\n+++ b/src/java/org/apache/commons/cli2/Option.java\n         final WriteableCommandLine commandLine,\n         final ListIterator args)\n         throws OptionException;\n+    \n+    /**\n+     * Adds defaults to a CommandLine.\n+     * \n+     * Any defaults for this option are applied as well as the defaults for \n+     * any contained options\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store defaults in\n+     */\n+    void defaults(final WriteableCommandLine commandLine);\n \n     /**\n      * Indicates whether this Option will be able to process the particular\n--- a/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n  * limitations under the License.\n  */\n package org.apache.commons.cli2;\n+\n+import java.util.List;\n \n /**\n  * A CommandLine that detected values and options can be written to.\n      * @param value the value to add\n      */\n     void addValue(final Option option, final Object value);\n+\n+    /**\n+     * Sets the default values for an Option in the CommandLine\n+     * @param option the Option to add to\n+     * @param defaultValues the defaults for the option\n+     */\n+    void setDefaultValues(final Option option, final List defaultValues);\n     \n     /**\n      * Adds a switch value to an Option in the CommandLine.\n      * @throws IllegalStateException if the switch has already been added\n      */\n     void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n+    \n+    /**\n+     * Sets the default state for a Switch in the CommandLine.\n+     * @param option the Option to add to\n+     * @param defaultSwitch the defaults state for ths switch\n+     */\n+    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n     \n     /**\n      * Adds a property value to a name in the CommandLine.\n--- a/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n     private Argument argument;\n     private Group children;\n     private int id;\n+    private Boolean switchDefault;\n \n     /**\n      * Creates a new SwitchBuilder using defaults.\n                 required,\n                 argument,\n                 children,\n-                id);\n+                id,\n+                switchDefault);\n \n         reset();\n \n         argument = null;\n         children = null;\n         id = 0;\n+        switchDefault = null;\n     }\n \n     /**\n         this.id = newId;\n         return this;\n     }\n+    \n+    /**\n+     * Sets the default state for this switch\n+     * \n+     * @param switchDefault the default state\n+     * @return this SwitchBuilder\n+     */\n+    public final SwitchBuilder withSwitchDefault(final Boolean switchDefault) {\n+        this.switchDefault = switchDefault;\n+        return this;\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/commandline/Parser.java\n+++ b/src/java/org/apache/commons/cli2/commandline/Parser.java\n     public CommandLine parse(final String[] arguments) throws OptionException {\n \n         final List argumentList = new LinkedList(Arrays.asList(arguments));\n-        final ListIterator iterator = argumentList.listIterator();\n         final WriteableCommandLine commandLine =\n             new WriteableCommandLineImpl(group, new ArrayList());\n+        \n+        // pick up any defaults from the model\n+        group.defaults(commandLine);\n \n+        final ListIterator iterator = argumentList.listIterator();\n         while (group.canProcess(iterator)) {\n             group.process(commandLine, iterator);\n         }\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.apache.commons.cli2.Argument;\n-import org.apache.commons.cli2.CommandLine;\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.WriteableCommandLine;\n \n     private final Map nameToOption = new HashMap();\n     private final Map values = new HashMap();\n     private final Map switches = new HashMap();\n-    private final Map defaults = new HashMap();\n+    private final Map defaultValues = new HashMap();\n+    private final Map defaultSwitches = new HashMap();\n     private final List normalised;\n     private final Set prefixes;\n-\n-    private CommandLine defaultCommandLine = null;\n \n     /**\n      * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n \n     public boolean hasOption(final Option option) {\n         final boolean present = options.contains(option);\n-        if (!present && defaultCommandLine != null) {\n-            return defaultCommandLine.hasOption(option);\n-        }\n-        else {\n-            return present;\n-        }\n+        return present;\n     }\n     \n     public Option getOption(final String trigger) {\n         return (Option)nameToOption.get(trigger);\n     }\n \n-    //TODO Document the order of values and defaults\n     public List getValues(final Option option, final List defaultValues) {\n \n         // First grab the command line values\n         List valueList = (List)values.get(option);\n \n-        // Secondly try alternate CommandLines\n-        if ((valueList == null || valueList.isEmpty())\n-        && defaultCommandLine != null) {\n-            valueList = defaultCommandLine.getValues(option, null);\n-        }\n-\n-        // Thirdly try the defaults supplied to the method\n+        // Secondly try the defaults supplied to the method\n         if (valueList == null || valueList.isEmpty()) {\n             valueList = defaultValues;\n         }\n \n-        // Fourthly try the option's default values\n+        // Thirdly try the option's default values\n         if (valueList == null || valueList.isEmpty()) {\n-            valueList = (List)this.defaults.get(option);\n+            valueList = (List)this.defaultValues.get(option);\n         }\n \n         // Finally use an empty list\n         // First grab the command line values\n         Boolean bool = (Boolean)switches.get(option);\n \n-        // Secondly try alternate CommandLines\n-        if (bool == null && defaultCommandLine != null) {\n-            bool = defaultCommandLine.getSwitch(option);\n-        }\n-\n-        // Thirdly try the defaults supplied to the method\n+        // Secondly try the defaults supplied to the method\n         if (bool == null) {\n             bool = defaultValue;\n         }\n \n-        // Fourthly try the option's default values\n-        //????\n+        // Thirdly try the option's default values\n+        if (bool == null) {\n+            bool = (Boolean)this.defaultSwitches.get(option);\n+        }\n \n         return bool;\n     }\n     }\n \n     public Set getProperties() {\n-        if (defaultCommandLine == null) {\n-            return Collections.unmodifiableSet(properties.keySet());\n-        }\n-        else {\n-            final Set props = new HashSet();\n-            props.addAll(properties.keySet());\n-            props.addAll(defaultCommandLine.getProperties());\n-            return Collections.unmodifiableSet(props);\n-        }\n+        return Collections.unmodifiableSet(properties.keySet());\n     }\n     \n     public boolean looksLikeOption(final String trigger) {\n     public Set getOptionTriggers() {\n         return Collections.unmodifiableSet(nameToOption.keySet());\n     }\n+\n+    public void setDefaultValues(final Option option, final List defaults) {\n+        if (defaults==null) {\n+            defaultValues.remove(option);\n+        }\n+        else {\n+            defaultValues.put(option, defaults);\n+        }\n+    }\n+\n+    public void setDefaultSwitch(final Option option, final Boolean defaultSwitch) {\n+        if (defaultSwitch==null) {\n+            defaultSwitches.remove(defaultSwitch);\n+        }\n+        else {\n+            defaultSwitches.put(option, defaultSwitch);\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n         final char subsequentSeparator,\n         final Validator validator,\n         final String consumeRemaining,\n-        final List defaultValues,\n+        final List valueDefaults,\n         final int id) {\n         \n         super(id,false);\n         this.subsequentSplit = subsequentSeparator != NUL;\n         this.validator = validator;\n         this.consumeRemaining = consumeRemaining;\n-        this.defaultValues = defaultValues;\n+        this.defaultValues = valueDefaults;\n \n         if (minimum > maximum) {\n             throw new IllegalArgumentException(\n                 resources.getMessage(\"cli.error.minimum.exceeds.maximum\"));\n         }\n \n-        if (defaultValues != null) {\n-            if (defaultValues.size() < minimum) {\n+        if (valueDefaults != null) {\n+            if (valueDefaults.size() < minimum) {\n                 throw new IllegalArgumentException(\n                     resources.getMessage(\"cli.error.too.few.defaults\"));\n             }\n \n-            if (defaultValues.size() > maximum) {\n+            if (valueDefaults.size() > maximum) {\n                 throw new IllegalArgumentException(\n                     resources.getMessage(\"cli.error.too.many.defaults\"));\n             }\n     public boolean isRequired() {\n         return getMinimum()>0;\n     }\n+    \n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+        defaultValues(commandLine,this);\n+    }\n+    \n+    public void defaultValues(final WriteableCommandLine commandLine, final Option option) {\n+        commandLine.setDefaultValues(option, defaultValues);\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n     public boolean isRequired() {\n         return getMinimum()>0;\n     }\n+    \n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+        \n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            option.defaults(commandLine);\n+        }\n+        \n+        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            option.defaults(commandLine);\n+        }\n+    }\n }\n \n class ReverseStringComparator implements Comparator {\n--- a/src/java/org/apache/commons/cli2/option/OptionImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/OptionImpl.java\n \n import org.apache.commons.cli2.DisplaySetting;\n import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n \n /**\n  * A base implementation of Option providing limited ground work for further\n     public boolean isRequired() {\n         return required;\n     }\n+    \n+    public void defaults(final WriteableCommandLine commandLine) {\n+        // nothing to do normally\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/option/ParentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ParentImpl.java\n \t\t\treturn found;\n \t\t}\n \t}\n+    \n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+        \n+        if(argument!=null) {\n+            argument.defaultValues(commandLine,this);\n+        }\n+        \n+        if(children!=null) {\n+            children.defaults(commandLine);\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/option/Switch.java\n+++ b/src/java/org/apache/commons/cli2/option/Switch.java\n     private final String preferredName;\n     private final Set aliases;\n     private final Set prefixes;\n+    private final Boolean defaultSwitch;\n \n     /**\n      * Creates a new Switch with the specified parameters\n         final boolean required,\n         final Argument argument,\n         final Group children,\n-        final int id) {\n+        final int id,\n+        final Boolean switchDefault) {\n         super(argument, children, description, id, required);\n \n         if (enabledPrefix == null) {\n         newPrefixes.add(enabledPrefix);\n         newPrefixes.add(disabledPrefix);\n         this.prefixes = Collections.unmodifiableSet(newPrefixes);\n-\n+        \n+        this.defaultSwitch = switchDefault;\n     }\n \n     public void processParent(\n     public String getPreferredName() {\n         return enabledPrefix + preferredName;\n     }\n+    \n+    public void defaults(final WriteableCommandLine commandLine) {\n+        commandLine.setDefaultSwitch(this, defaultSwitch);\n+    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/cli2/CommandLineDefaultsTest.java\n+/**\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.SwitchBuilder;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * Tests the interaction of command line values and defaults supplied in different ways.\n+ * \n+ * Tests marked _Parsed involve values parsed from a command line.\n+ * \n+ * Tests marked _Method involve defaults supplied in the query method.\n+ * \n+ * Tests marked _Option involce defaults specified in the model.\n+ * \n+ * @author Rob Oxspring\n+ */\n+public class CommandLineDefaultsTest extends TestCase {\n+    \n+    /*\n+     * utils to grab the default from the method \n+     */\n+    \n+    private Object methodSwitch(WriteableCommandLine cl, Option o, Boolean bool) {\n+        return cl.getSwitch(o, bool);\n+    }\n+\n+    private Object methodSwitchNull(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, null);\n+    }\n+\n+    private Object methodSwitchOff(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, Boolean.FALSE);\n+    }\n+\n+    private Object methodSwitchOn(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, Boolean.TRUE);\n+    }\n+\n+    private Object methodValueMissing(WriteableCommandLine cl, Option o) {\n+        return cl.getValue(o);\n+    }\n+\n+    private Object methodValuePresent(WriteableCommandLine cl, Option o) {\n+        return cl.getValue(o, \"method\");\n+    }\n+\n+    /*\n+     * utils to grab the default from the option model \n+     */\n+    \n+    private Option optionSwitch(Boolean bool) {\n+        return new SwitchBuilder().withName(\"switch\").withSwitchDefault(bool)\n+                .create();\n+    }\n+\n+    private Option optionSwitchNull() {\n+        return optionSwitch(null);\n+    }\n+\n+    private Option optionSwitchOff() {\n+        return optionSwitch(Boolean.FALSE);\n+    }\n+\n+    private Option optionSwitchOn() {\n+        return optionSwitch(Boolean.TRUE);\n+    }\n+\n+    private Option optionValueMissing() {\n+        return new ArgumentBuilder().create();\n+    }\n+\n+    private Option optionValuePresent() {\n+        return new ArgumentBuilder().withDefaults(\n+                Arrays.asList(new String[] { \"option\" })).create();\n+    }\n+\n+    /*\n+     * utils to grab the input from the command line \n+     */\n+    \n+    private WriteableCommandLine parsedSwitch(Option o, Boolean bool) {\n+        final List args;\n+        if (bool == null) {\n+            args = Collections.EMPTY_LIST;\n+        } else {\n+            args = Collections\n+                    .singletonList(String.valueOf(bool).toLowerCase());\n+        }\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o, args);\n+        o.defaults(cl);\n+        if (bool != null) {\n+            cl.addSwitch(o, bool.booleanValue());\n+        }\n+        return cl;\n+    }\n+\n+    private WriteableCommandLine parsedSwitchNull(Option o) {\n+        return parsedSwitch(o, null);\n+    }\n+\n+    private WriteableCommandLine parsedSwitchOn(Option o) {\n+        return parsedSwitch(o, Boolean.TRUE);\n+    }\n+\n+    private WriteableCommandLine parsedValueMissing(Option o) {\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o,\n+                Collections.EMPTY_LIST);\n+        o.defaults(cl);\n+        return cl;\n+    }\n+\n+    private WriteableCommandLine parsedValuePresent(Option o) {\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o, Arrays\n+                .asList(new String[] { \"parsed\" }));\n+        o.defaults(cl);\n+        cl.addValue(o, \"parsed\");\n+        return cl;\n+    }\n+    \n+    /*\n+     * tests\n+     */\n+\n+    public void testSwitch_Method() {\n+        final Option o = optionSwitchNull();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchOn(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Method_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchOn(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Option() {\n+        final Option o = optionSwitchOn();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed() {\n+        final Option o = optionSwitchNull();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Method() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Method_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchOff(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testValues() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertNull(v);\n+    }\n+\n+    public void testValues_Method() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"method\", v);\n+    }\n+\n+    public void testValues_Method_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"method\", v);\n+    }\n+\n+    public void testValues_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"option\", v);\n+    }\n+\n+    public void testValues_Parsed() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Method() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Method_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/SwitchTest.java\n+++ b/src/test/org/apache/commons/cli2/option/SwitchTest.java\n             true,\n             null,\n             null,\n-            'd');\n+            'd',\n+            null);\n     }\n \n     /*", "timestamp": 1094511486, "metainfo": ""}