{"sha": "234ae35d4fc177e27e25269c2774e20f444b8a58", "log": "- rewrote i18n code - externalised error strings   ", "commit": "\n--- a/src/java/org/apache/commons/cli2/OptionException.java\n+++ b/src/java/org/apache/commons/cli2/OptionException.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n /**\n  * A problem found while dealing with command line options.\n  */\n-public class OptionException extends Exception {\n-\n+public class OptionException\n+    extends Exception {\n     /**\n      * The settings used when displaying the related Option.\n-     * \n+     *\n      * @see DisplaySetting\n      */\n-    public static final Set HELP_SETTINGS = \n-        Collections.unmodifiableSet(\n-            Collections.singleton(\n-                DisplaySetting.DISPLAY_PROPERTY_OPTION));\n+    public static final Set HELP_SETTINGS =\n+        Collections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n+\n+    /** resource helper instance */\n+    private static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n \n     /** The Option the exception relates to */\n     private final Option option;\n-    \n+\n     /** The message explaining the Exception */\n     private final String message;\n \n-    /** resource helper instance */\n-    private static final ResourceHelper helper =\n-        ResourceHelper.getResourceHelper(OptionException.class);\n-    \n     /**\n      * Creates a new OptionException.\n-     * \n+     *\n      * @param option\n      *            The Option the exception relates to\n      */\n     public OptionException(final Option option) {\n         this(option, null, null);\n     }\n-    \n+\n     /**\n      * Creates a new OptionException.\n      * @param option the Option the exception relates to\n      * @param messageKey the id of the message to display\n      */\n-    public OptionException(final Option option, final String messageKey) {\n+    public OptionException(final Option option,\n+                           final String messageKey) {\n         this(option, messageKey, null);\n     }\n \n      * @param messageKey the id of the message to display\n      * @param value a value to display with the message\n      */\n-    public OptionException(\n-            final Option option, \n-            final String messageKey, \n-            final String value) {\n-        \n+    public OptionException(final Option option,\n+                           final String messageKey,\n+                           final String value) {\n         this.option = option;\n-        \n+\n         if (messageKey != null) {\n             final StringBuffer buffer = new StringBuffer();\n+\n             if (value != null) {\n                 buffer.append(helper.getMessage(messageKey, value));\n-            }\n-            else {\n+            } else {\n                 buffer.append(helper.getMessage(messageKey));\n             }\n+\n             buffer.append(\" \");\n \n             option.appendUsage(buffer, HELP_SETTINGS, null);\n             message = buffer.toString();\n-        }\n-        else {\n+        } else {\n             message = \"\";\n         }\n     }\n-    \n+\n     /**\n      * Gets the Option the exception relates to\n-     * \n+     *\n      * @return The related Option\n      */\n     public Option getOption() {\n         return option;\n     }\n-    \n+\n     public String getMessage() {\n         return message;\n     }\n--- a/src/java/org/apache/commons/cli2/builder/CommandBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/CommandBuilder.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.option.Command;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Builds Command instances\n  */\n public class CommandBuilder {\n-\n     /** the preferred name of the command */\n     private String preferredName;\n \n     /**\n      * Creates a new <code>Command</code> instance using the properties of the\n      * <code>CommandBuilder</code>.\n-     * \n+     *\n      * @return the new Command instance\n      */\n     public Command create() {\n-\n         // check we have a valid name\n         if (preferredName == null) {\n-            throw new IllegalStateException(\"Options must have at least one name\");\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n         }\n \n         // build the command\n         final Command option =\n-            new Command(\n-                preferredName,\n-                description,\n-                aliases,\n-                required,\n-                argument,\n-                children,\n-                id);\n+            new Command(preferredName, description, aliases, required, argument, children, id);\n \n         // reset the builder\n         reset();\n     }\n \n     /**\n-     * Resets the CommandBuilder to the defaults for a new Command. \n-     * \n+     * Resets the CommandBuilder to the defaults for a new Command.\n+     *\n      * This method is called automatically at the end of the\n      * {@link #create() create} method.\n      */\n         argument = null;\n         children = null;\n         id = 0;\n+\n         return this;\n     }\n \n     /**\n-     * Specifies the name for the next <code>Command</code> \n+     * Specifies the name for the next <code>Command</code>\n      * that is created.  The first name is used as the preferred\n-     * display name for the <code>Command</code> and then \n+     * display name for the <code>Command</code> and then\n      * later names are used as aliases.\n-     * \n+     *\n      * @param name the name for the next <code>Command</code>\n      * that is created.\n      * @return this <code>CommandBuilder</code>.\n     public CommandBuilder withName(final String name) {\n         if (preferredName == null) {\n             preferredName = name;\n-        }\n-        else {\n+        } else {\n             aliases.add(name);\n         }\n \n \n     /**\n      * Specifies the description for the next <code>Command</code>\n-     * that is created.  This description is used to produce \n+     * that is created.  This description is used to produce\n      * help documentation for the <code>Command</code>.\n-     * \n-     * @param newDescription the description for the next \n+     *\n+     * @param newDescription the description for the next\n      * <code>Command</code> that is created.\n      * @return this <code>CommandBuilder</code>.\n      */\n     public CommandBuilder withDescription(final String newDescription) {\n         this.description = newDescription;\n+\n         return this;\n     }\n \n      */\n     public CommandBuilder withRequired(final boolean newRequired) {\n         this.required = newRequired;\n+\n         return this;\n     }\n \n     /**\n-     * Specifies the children for the next <code>Command</code> \n+     * Specifies the children for the next <code>Command</code>\n      * that is created.\n-     * \n+     *\n      * @param newChildren the child options for the next <code>Command</code>\n      * that is created.\n      * @return this <code>CommandBuilder</code>.\n      */\n     public CommandBuilder withChildren(final Group newChildren) {\n         this.children = newChildren;\n+\n         return this;\n     }\n \n     /**\n-     * Specifies the argument for the next <code>Command</code> \n+     * Specifies the argument for the next <code>Command</code>\n      * that is created.\n-     * \n-     * @param newArgument the argument for the next <code>Command</code> \n+     *\n+     * @param newArgument the argument for the next <code>Command</code>\n      * that is created.\n      * @return this <code>CommandBuilder</code>.\n      */\n     public CommandBuilder withArgument(final Argument newArgument) {\n         this.argument = newArgument;\n+\n         return this;\n     }\n \n     /**\n      * Specifies the id for the next <code>Command</code> that is created.\n-     * \n+     *\n      * @param newId the id for the next <code>Command</code> that is created.\n      * @return this <code>CommandBuilder</code>.\n      */\n     public final CommandBuilder withId(final int newId) {\n         this.id = newId;\n+\n         return this;\n     }\n }\n--- a/src/java/org/apache/commons/cli2/builder/DefaultOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/DefaultOptionBuilder.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Builds DefaultOption instances.\n  */\n public class DefaultOptionBuilder {\n-\n     private final String shortPrefix;\n     private final String longPrefix;\n     private final boolean burstEnabled;\n-\n     private String preferredName;\n     private Set aliases;\n     private Set burstAliases;\n     private boolean required;\n-\n     private String description;\n     private Argument argument;\n     private Group children;\n      * @see DefaultOption#DEFAULT_BURST_ENABLED\n      */\n     public DefaultOptionBuilder() {\n-        this(\n-            DefaultOption.DEFAULT_SHORT_PREFIX,\n-            DefaultOption.DEFAULT_LONG_PREFIX,\n-            DefaultOption.DEFAULT_BURST_ENABLED);\n+        this(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\n+             DefaultOption.DEFAULT_BURST_ENABLED);\n     }\n \n     /**\n      * @param shortPrefix the prefix to use for short options\n      * @param longPrefix the prefix to use for long options\n      * @param burstEnabled whether to allow gnu style bursting\n-     * @throws IllegalArgumentException if either prefix is less than on \n+     * @throws IllegalArgumentException if either prefix is less than on\n      *                                  character long\n      */\n-    public DefaultOptionBuilder(\n-        final String shortPrefix,\n-        final String longPrefix,\n-        final boolean burstEnabled) throws IllegalArgumentException{\n-        \n-        if (shortPrefix == null || shortPrefix.length() == 0) {\n-            throw new IllegalArgumentException(\"shortPrefix should be at least 1 character long\");\n-        }\n-        if (longPrefix == null || longPrefix.length() == 0) {\n-            throw new IllegalArgumentException(\"longPrefix should be at least 1 character long\");\n-        }\n-        \n+    public DefaultOptionBuilder(final String shortPrefix,\n+                                final String longPrefix,\n+                                final boolean burstEnabled)\n+        throws IllegalArgumentException {\n+        if ((shortPrefix == null) || (shortPrefix.length() == 0)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n+        }\n+\n+        if ((longPrefix == null) || (longPrefix.length() == 0)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n+        }\n+\n         this.shortPrefix = shortPrefix;\n         this.longPrefix = longPrefix;\n         this.burstEnabled = burstEnabled;\n      * @return the new instance\n      * @throws IllegalStateException if no names have been supplied\n      */\n-    public DefaultOption create() throws IllegalStateException {\n+    public DefaultOption create()\n+        throws IllegalStateException {\n         if (preferredName == null) {\n-            throw new IllegalStateException(\"Options must have at least one name\");\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n         }\n \n         final DefaultOption option =\n-            new DefaultOption(\n-                shortPrefix,\n-                longPrefix,\n-                burstEnabled,\n-                preferredName,\n-                description,\n-                aliases,\n-                burstAliases,\n-                required,\n-                argument,\n-                children,\n-                id);\n+            new DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\n+                              aliases, burstAliases, required, argument, children, id);\n \n         reset();\n \n         return option;\n     }\n-    \n+\n     /**\n      * Resets the builder\n      */\n         argument = null;\n         children = null;\n         id = 0;\n+\n         return this;\n     }\n \n     /**\n      * Use this short option name. The first name is used as the preferred\n      * display name for the Command and then later names are used as aliases.\n-     * \n+     *\n      * @param shortName the name to use\n      * @return this builder\n      */\n \n         if (preferredName == null) {\n             preferredName = name;\n-        }\n-        else {\n+        } else {\n             aliases.add(name);\n         }\n \n-        if (burstEnabled && name.length() == shortPrefix.length() + 1) {\n+        if (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\n             burstAliases.add(name);\n         }\n \n     /**\n      * Use this long option name.  The first name is used as the preferred\n      * display name for the Command and then later names are used as aliases.\n-     * \n+     *\n      * @param longName the name to use\n      * @return this builder\n      */\n     public DefaultOptionBuilder withLongName(final String longName) {\n         final String name = longPrefix + longName;\n+\n         if (preferredName == null) {\n             preferredName = name;\n-        }\n-        else {\n+        } else {\n             aliases.add(name);\n         }\n+\n         return this;\n     }\n \n      */\n     public DefaultOptionBuilder withDescription(final String newDescription) {\n         this.description = newDescription;\n+\n         return this;\n     }\n \n      */\n     public DefaultOptionBuilder withRequired(final boolean newRequired) {\n         this.required = newRequired;\n+\n         return this;\n     }\n \n      */\n     public DefaultOptionBuilder withChildren(final Group newChildren) {\n         this.children = newChildren;\n+\n         return this;\n     }\n \n      */\n     public DefaultOptionBuilder withArgument(final Argument newArgument) {\n         this.argument = newArgument;\n+\n         return this;\n     }\n \n     /**\n      * Sets the id\n-     * \n+     *\n      * @param newId\n      *            the id of the DefaultOption\n      * @return this DefaultOptionBuilder\n      */\n     public final DefaultOptionBuilder withId(final int newId) {\n         this.id = newId;\n+\n         return this;\n     }\n }\n--- a/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.option.Switch;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Builds Switch instance.\n  */\n public class SwitchBuilder {\n-\n     private final String enabledPrefix;\n     private final String disabledPrefix;\n-\n     private String description;\n     private String preferredName;\n     private Set aliases;\n      * Creates a new SwitchBuilder\n      * @param enabledPrefix the prefix to use for enabling the option\n      * @param disabledPrefix the prefix to use for disabling the option\n-     * @throws IllegalArgumentException if either prefix is less than 1 \n+     * @throws IllegalArgumentException if either prefix is less than 1\n      *                                  character long or the prefixes match\n      */\n-    public SwitchBuilder(\n-        final String enabledPrefix,\n-        final String disabledPrefix) throws IllegalArgumentException {\n-        if (enabledPrefix == null || enabledPrefix.length() < 1) {\n-            throw new IllegalArgumentException(\"enabledPrefix should be at least 1 character long\");\n+    public SwitchBuilder(final String enabledPrefix,\n+                         final String disabledPrefix)\n+        throws IllegalArgumentException {\n+        if ((enabledPrefix == null) || (enabledPrefix.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_ENABLED_PREFIX));\n         }\n-        if (disabledPrefix == null || disabledPrefix.length() < 1) {\n-            throw new IllegalArgumentException(\"disabledPrefix should be at least 1 character long\");\n+\n+        if ((disabledPrefix == null) || (disabledPrefix.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_DISABLED_PREFIX));\n         }\n+\n         if (enabledPrefix.equals(disabledPrefix)) {\n-            throw new IllegalArgumentException(\"disabledPrefix and enabledPrefix should be different\");\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_IDENTICAL_PREFIXES));\n         }\n+\n         this.enabledPrefix = enabledPrefix;\n         this.disabledPrefix = disabledPrefix;\n         reset();\n     }\n-    \n+\n     /**\n      * Creates a new Switch instance\n      * @return a new Switch instance\n      */\n     public Switch create() {\n         final Switch option =\n-            new Switch(\n-                enabledPrefix,\n-                disabledPrefix,\n-                preferredName,\n-                aliases,\n-                description,\n-                required,\n-                argument,\n-                children,\n-                id,\n-                switchDefault);\n+            new Switch(enabledPrefix, disabledPrefix, preferredName, aliases, description,\n+                       required, argument, children, id, switchDefault);\n \n         reset();\n \n         children = null;\n         id = 0;\n         switchDefault = null;\n+\n         return this;\n     }\n \n      */\n     public SwitchBuilder withDescription(final String newDescription) {\n         this.description = newDescription;\n+\n         return this;\n     }\n \n     /**\n      * Use this option name. The first name is used as the preferred\n      * display name for the Command and then later names are used as aliases.\n-     * \n+     *\n      * @param name the name to use\n      * @return this builder\n      */\n     public SwitchBuilder withName(final String name) {\n         if (preferredName == null) {\n             preferredName = name;\n-        }\n-        else {\n+        } else {\n             aliases.add(name);\n         }\n \n      */\n     public SwitchBuilder withRequired(final boolean newRequired) {\n         this.required = newRequired;\n+\n         return this;\n     }\n \n      */\n     public SwitchBuilder withArgument(final Argument newArgument) {\n         this.argument = newArgument;\n+\n         return this;\n     }\n \n      */\n     public SwitchBuilder withChildren(final Group newChildren) {\n         this.children = newChildren;\n+\n         return this;\n     }\n \n     /**\n      * Sets the id\n-     * \n+     *\n      * @param newId\n      *            the id of the Switch\n      * @return this SwitchBuilder\n      */\n     public final SwitchBuilder withId(final int newId) {\n         this.id = newId;\n+\n         return this;\n     }\n-    \n+\n     /**\n      * Sets the default state for this switch\n-     * \n+     *\n      * @param newSwitchDefault the default state\n      * @return this SwitchBuilder\n      */\n     public final SwitchBuilder withSwitchDefault(final Boolean newSwitchDefault) {\n         this.switchDefault = newSwitchDefault;\n+\n         return this;\n     }\n }\n--- a/src/java/org/apache/commons/cli2/commandline/CommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/CommandLineImpl.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n \n import org.apache.commons.cli2.CommandLine;\n import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Instances of CommandLine represent a command line that has been processed\n  * according to the definition supplied to the parser.\n  */\n public abstract class CommandLineImpl implements CommandLine {\n-\n     public final boolean hasOption(final String trigger) {\n         return hasOption(getOption(trigger));\n     }\n \n     public final List getValues(final String trigger) {\n-        return getValues(getOption(trigger),Collections.EMPTY_LIST);\n+        return getValues(getOption(trigger), Collections.EMPTY_LIST);\n     }\n \n-    public final List getValues(final String trigger, final List defaultValues) {\n+    public final List getValues(final String trigger,\n+                                final List defaultValues) {\n         return getValues(getOption(trigger), defaultValues);\n     }\n \n     }\n \n     public final Object getValue(final String trigger) {\n-        return getValue(getOption(trigger),null);\n+        return getValue(getOption(trigger), null);\n     }\n \n-    public final Object getValue(final String trigger, final Object defaultValue) {\n+    public final Object getValue(final String trigger,\n+                                 final Object defaultValue) {\n         return getValue(getOption(trigger), defaultValue);\n     }\n \n         return getValue(option, null);\n     }\n \n-    public final Object getValue(final Option option, final Object defaultValue) {\n+    public final Object getValue(final Option option,\n+                                 final Object defaultValue) {\n+        final List values;\n \n-        final List values;\n         if (defaultValue == null) {\n             values = getValues(option);\n-        }\n-        else {\n+        } else {\n             values = getValues(option, Collections.singletonList(defaultValue));\n         }\n \n         if (values.size() > 1) {\n-            throw new IllegalStateException(\"More than one value was supplied\");\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES));\n         }\n \n         if (values.isEmpty()) {\n         return getSwitch(getOption(trigger), null);\n     }\n \n-    public final Boolean getSwitch(\n-        final String trigger,\n-        final Boolean defaultValue) {\n+    public final Boolean getSwitch(final String trigger,\n+                                   final Boolean defaultValue) {\n         return getSwitch(getOption(trigger), defaultValue);\n     }\n \n     }\n \n     public final String getProperty(final String property) {\n-        return getProperty(property,null);\n+        return getProperty(property, null);\n     }\n \n     public final int getOptionCount(final String trigger) {\n         }\n \n         int count = 0;\n+\n         for (Iterator i = getOptions().iterator(); i.hasNext();) {\n             if (option.equals(i.next())) {\n                 ++count;\n--- a/src/java/org/apache/commons/cli2/commandline/Parser.java\n+++ b/src/java/org/apache/commons/cli2/commandline/Parser.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n package org.apache.commons.cli2.commandline;\n \n import java.io.IOException;\n+\n import java.util.LinkedList;\n import java.util.List;\n import java.util.ListIterator;\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n import org.apache.commons.cli2.util.HelpFormatter;\n \n /**\n  * A class that implements the <code>Parser</code> interface can parse a\n  * String array according to the {@link Group}specified and return a\n  * {@link CommandLine}.\n- * \n+ *\n  * @author John Keyes (john at integralsource.com)\n  */\n public class Parser {\n \n     /**\n      * Parse the arguments according to the specified options and properties.\n-     * \n+     *\n      * @param arguments\n      *            the command line arguments\n-     * \n+     *\n      * @return the list of atomic option and value tokens\n      * @throws OptionException\n      *             if there are any problems encountered while parsing the\n      *             command line tokens.\n      */\n-    public CommandLine parse(final String[] arguments) throws OptionException {\n-        \n+    public CommandLine parse(final String[] arguments)\n+        throws OptionException {\n         // build a mutable list for the arguments\n         final List argumentList = new LinkedList();\n-        \n+\n         // copy the arguments into the new list\n         for (int i = 0; i < arguments.length; i++) {\n             final String argument = arguments[i];\n-            \n+\n             // ensure non intern'd strings are used \n             // so that == comparisons work as expected\n             argumentList.add(new String(argument));\n         }\n-        \n+\n         // wet up a command line for this group\n-        final WriteableCommandLine commandLine =\n-            new WriteableCommandLineImpl(group, argumentList);\n-        \n+        final WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n+\n         // pick up any defaults from the model\n         group.defaults(commandLine);\n-        \n+\n         // process the options as far as possible\n         final ListIterator iterator = argumentList.listIterator();\n         Object previous = null;\n+\n         while (group.canProcess(commandLine, iterator)) {\n-            \n             // peek at the next item and backtrack\n             final Object next = iterator.next();\n             iterator.previous();\n-            \n+\n             // if we have just tried to process this instance\n-            if(next==previous) {\n+            if (next == previous) {\n                 // abort\n                 break;\n             }\n+\n             // remember previous\n             previous = next;\n-            \n+\n             group.process(commandLine, iterator);\n         }\n-        \n+\n         // if there are more arguments we have a problem\n         if (iterator.hasNext()) {\n-            final String arg = (String)iterator.next();\n-            throw new OptionException(group, \"cli.error.unexpected\", arg);\n+            final String arg = (String) iterator.next();\n+            throw new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n         }\n-        \n+\n         // no need to validate if the help option is present\n         if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\n             group.validate(commandLine);\n         }\n-        \n+\n         return commandLine;\n     }\n \n      * Parse the arguments according to the specified options and properties and\n      * displays the usage screen if the CommandLine is not valid or the help\n      * option was specified.\n-     * \n+     *\n      * @param arguments the command line arguments\n      * @return a valid CommandLine or null if the parse was unsuccessful\n      * @throws IOException if an error occurs while formatting help\n      */\n     public CommandLine parseAndHelp(final String[] arguments)\n         throws IOException {\n-\n         helpFormatter.setGroup(group);\n \n         try {\n             // attempt to parse the command line\n             final CommandLine commandLine = parse(arguments);\n-            if (!commandLine.hasOption(helpOption)\n-                && !commandLine.hasOption(helpTrigger)) {\n \n+            if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\n                 return commandLine;\n             }\n-        }\n-        catch (final OptionException oe) {\n+        } catch (final OptionException oe) {\n             // display help regarding the exception\n             helpFormatter.setException(oe);\n         }\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * A WriteableCommandLine implementation allowing Options to write their\n  * processed information to a CommandLine.\n  */\n-public class WriteableCommandLineImpl extends CommandLineImpl implements WriteableCommandLine {\n-\n+public class WriteableCommandLineImpl\n+    extends CommandLineImpl implements WriteableCommandLine {\n     private final Properties properties = new Properties();\n     private final List options = new ArrayList();\n     private final Map nameToOption = new HashMap();\n      * @param rootOption the CommandLine's root Option\n      * @param arguments the arguments this CommandLine represents\n      */\n-    public WriteableCommandLineImpl(final Option rootOption, final List arguments) {\n+    public WriteableCommandLineImpl(final Option rootOption,\n+                                    final List arguments) {\n         this.prefixes = rootOption.getPrefixes();\n         this.normalised = arguments;\n     }\n     public void addOption(Option option) {\n         options.add(option);\n         nameToOption.put(option.getPreferredName(), option);\n+\n         for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n             nameToOption.put(i.next(), option);\n         }\n     }\n \n-    public void addValue(final Option option, final Object value) {\n+    public void addValue(final Option option,\n+                         final Object value) {\n         if (option instanceof Argument) {\n             addOption(option);\n         }\n-        List valueList = (List)values.get(option);\n+\n+        List valueList = (List) values.get(option);\n+\n         if (valueList == null) {\n             valueList = new ArrayList();\n             values.put(option, valueList);\n         }\n+\n         valueList.add(value);\n     }\n \n-    public void addSwitch(final Option option, final boolean value) {\n+    public void addSwitch(final Option option,\n+                          final boolean value) {\n         addOption(option);\n+\n         if (switches.containsKey(option)) {\n-            throw new IllegalStateException(\"Switch already set\");\n-        }\n-        else {\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n+        } else {\n             switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n         }\n     }\n \n     public boolean hasOption(final Option option) {\n         final boolean present = options.contains(option);\n+\n         return present;\n     }\n-    \n+\n     public Option getOption(final String trigger) {\n-        return (Option)nameToOption.get(trigger);\n-    }\n-\n-    public List getValues(final Option option, final List defaultValues) {\n-\n+        return (Option) nameToOption.get(trigger);\n+    }\n+\n+    public List getValues(final Option option,\n+                          final List defaultValues) {\n         // First grab the command line values\n-        List valueList = (List)values.get(option);\n+        List valueList = (List) values.get(option);\n \n         // Secondly try the defaults supplied to the method\n-        if (valueList == null || valueList.isEmpty()) {\n+        if ((valueList == null) || valueList.isEmpty()) {\n             valueList = defaultValues;\n         }\n \n         // Thirdly try the option's default values\n-        if (valueList == null || valueList.isEmpty()) {\n-            valueList = (List)this.defaultValues.get(option);\n+        if ((valueList == null) || valueList.isEmpty()) {\n+            valueList = (List) this.defaultValues.get(option);\n         }\n \n         // Finally use an empty list\n \n         return valueList;\n     }\n-    \n-    public Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+\n+    public Boolean getSwitch(final Option option,\n+                             final Boolean defaultValue) {\n         // First grab the command line values\n-        Boolean bool = (Boolean)switches.get(option);\n+        Boolean bool = (Boolean) switches.get(option);\n \n         // Secondly try the defaults supplied to the method\n         if (bool == null) {\n \n         // Thirdly try the option's default values\n         if (bool == null) {\n-            bool = (Boolean)this.defaultSwitches.get(option);\n+            bool = (Boolean) this.defaultSwitches.get(option);\n         }\n \n         return bool;\n     }\n \n-    public void addProperty(final String property, final String value) {\n+    public void addProperty(final String property,\n+                            final String value) {\n         properties.setProperty(property, value);\n     }\n-    \n-    public String getProperty(final String property, final String defaultValue) {\n-        return properties.getProperty(property,defaultValue);\n+\n+    public String getProperty(final String property,\n+                              final String defaultValue) {\n+        return properties.getProperty(property, defaultValue);\n     }\n \n     public Set getProperties() {\n         return Collections.unmodifiableSet(properties.keySet());\n     }\n-    \n+\n     public boolean looksLikeOption(final String trigger) {\n         for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n-            final String prefix = (String)i.next();\n+            final String prefix = (String) i.next();\n+\n             if (trigger.startsWith(prefix)) {\n                 return true;\n             }\n         final StringBuffer buffer = new StringBuffer();\n \n         // need to add group header\n-\n         for (final Iterator i = normalised.iterator(); i.hasNext();) {\n-            final String arg = (String)i.next();\n+            final String arg = (String) i.next();\n+\n             if (arg.indexOf(' ') >= 0) {\n                 buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n-            }\n-            else {\n+            } else {\n                 buffer.append(arg);\n             }\n+\n             if (i.hasNext()) {\n                 buffer.append(' ');\n             }\n \n         return buffer.toString();\n     }\n-    \n+\n     public List getOptions() {\n         return Collections.unmodifiableList(options);\n     }\n         return Collections.unmodifiableSet(nameToOption.keySet());\n     }\n \n-    public void setDefaultValues(final Option option, final List defaults) {\n-        if (defaults==null) {\n+    public void setDefaultValues(final Option option,\n+                                 final List defaults) {\n+        if (defaults == null) {\n             defaultValues.remove(option);\n-        }\n-        else {\n+        } else {\n             defaultValues.put(option, defaults);\n         }\n     }\n \n-    public void setDefaultSwitch(final Option option, final Boolean defaultSwitch) {\n-        if (defaultSwitch==null) {\n+    public void setDefaultSwitch(final Option option,\n+                                 final Boolean defaultSwitch) {\n+        if (defaultSwitch == null) {\n             defaultSwitches.remove(defaultSwitch);\n-        }\n-        else {\n+        } else {\n             defaultSwitches.put(option, defaultSwitch);\n         }\n     }\n-    \n+\n     public List getNormalised() {\n         return Collections.unmodifiableList(normalised);\n     }\n-    \n }\n--- a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n import org.apache.commons.cli2.resource.ResourceHelper;\n import org.apache.commons.cli2.validation.InvalidArgumentException;\n import org.apache.commons.cli2.validation.Validator;\n /**\n  * An implementation of an Argument.\n  */\n-public class ArgumentImpl extends OptionImpl implements Argument {\n-\n+public class ArgumentImpl\n+    extends OptionImpl implements Argument {\n+    private static final char NUL = '\\0';\n+\n+    /**\n+     * The default value for the initial separator char.\n+     */\n+    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n+\n+    /**\n+     * The default value for the subsequent separator char.\n+     */\n+    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n+\n+    /**\n+     * The default token to indicate that remaining arguments should be consumed\n+     * as values.\n+     */\n+    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n     private final String name;\n     private final String description;\n     private final int minimum;\n     private final Validator validator;\n     private final String consumeRemaining;\n     private final List defaultValues;\n-    private final ResourceHelper resources \n-        = ResourceHelper.getResourceHelper(ArgumentImpl.class);\n-\n-    private static final char NUL = '\\0';\n-    \n-    /**\n-     * The default value for the initial separator char.\n-     */\n-    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n-    \n-    /**\n-     * The default value for the subsequent separator char.\n-     */\n-    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n-    \n-    /**\n-     * The default token to indicate that remaining arguments should be consumed\n-     * as values.\n-     */\n-    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n+    private final ResourceHelper resources = ResourceHelper.getResourceHelper();\n \n     /**\n      * Creates a new Argument instance.\n-     * \n+     *\n      * @param name\n      *            The name of the argument\n      * @param description\n      *            The values to be used if none are specified.\n      * @param id\n      *            The id of the option, 0 implies automatic assignment.\n-     * \n+     *\n      * @see OptionImpl#OptionImpl(int,boolean)\n      */\n-    public ArgumentImpl(\n-        final String name,\n-        final String description,\n-        final int minimum,\n-        final int maximum,\n-        final char initialSeparator,\n-        final char subsequentSeparator,\n-        final Validator validator,\n-        final String consumeRemaining,\n-        final List valueDefaults,\n-        final int id) {\n-        \n-        super(id,false);\n+    public ArgumentImpl(final String name,\n+                        final String description,\n+                        final int minimum,\n+                        final int maximum,\n+                        final char initialSeparator,\n+                        final char subsequentSeparator,\n+                        final Validator validator,\n+                        final String consumeRemaining,\n+                        final List valueDefaults,\n+                        final int id) {\n+        super(id, false);\n \n         this.name = (name == null) ? \"arg\" : name;\n         this.description = description;\n         this.defaultValues = valueDefaults;\n \n         if (minimum > maximum) {\n-            throw new IllegalArgumentException(\n-                resources.getMessage(\"cli.error.minimum.exceeds.maximum\"));\n-        }\n-\n-        if (valueDefaults != null && valueDefaults.size() > 0) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n+        }\n+\n+        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n             if (valueDefaults.size() < minimum) {\n-                throw new IllegalArgumentException(\n-                    resources.getMessage(\"cli.error.too.few.defaults\"));\n+                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n             }\n \n             if (valueDefaults.size() > maximum) {\n-                throw new IllegalArgumentException(\n-                    resources.getMessage(\"cli.error.too.many.defaults\"));\n+                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n             }\n         }\n     }\n         return name;\n     }\n \n-    public void processValues(\n-        final WriteableCommandLine commandLine,\n-        final ListIterator arguments,\n-        final Option option)\n+    public void processValues(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments,\n+                              final Option option)\n         throws OptionException {\n-        int argumentCount = commandLine.getValues(option,Collections.EMPTY_LIST).size();\n-        while (arguments.hasNext() && argumentCount < maximum) {\n-\n-            final String allValues =\n-                stripBoundaryQuotes((String)arguments.next());\n-            \n+        int argumentCount = commandLine.getValues(option, Collections.EMPTY_LIST).size();\n+\n+        while (arguments.hasNext() && (argumentCount < maximum)) {\n+            final String allValues = stripBoundaryQuotes((String) arguments.next());\n+\n             // should we ignore things that look like options?\n             if (allValues.equals(consumeRemaining)) {\n-                while (arguments.hasNext() && argumentCount < maximum) {\n+                while (arguments.hasNext() && (argumentCount < maximum)) {\n                     ++argumentCount;\n                     commandLine.addValue(option, arguments.next());\n                 }\n             // does it look like an option?\n             else if (commandLine.looksLikeOption(allValues)) {\n                 arguments.previous();\n+\n                 break;\n             }\n             // should we split the string up?\n             else if (subsequentSplit) {\n                 final StringTokenizer values =\n-                    new StringTokenizer(\n-                        allValues,\n-                        String.valueOf(subsequentSepatator));\n+                    new StringTokenizer(allValues, String.valueOf(subsequentSepatator));\n \n                 arguments.remove();\n \n-                while (values.hasMoreTokens() && argumentCount < maximum) {\n+                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                     ++argumentCount;\n+\n                     final String token = values.nextToken();\n                     commandLine.addValue(option, token);\n                     arguments.add(token);\n                 }\n \n                 if (values.hasMoreTokens()) {\n-                    throw new OptionException(\n-                        option,\n-                        \"cli.error.unexpected.value\",\n-                        values.nextToken());\n+                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                              values.nextToken());\n                 }\n             }\n             // it must be a value as it is\n         }\n     }\n \n-    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n         return true;\n     }\n \n         return Collections.EMPTY_SET;\n     }\n \n-    public void process(WriteableCommandLine commandLine, ListIterator args)\n+    public void process(WriteableCommandLine commandLine,\n+                        ListIterator args)\n         throws OptionException {\n         processValues(commandLine, args, this);\n     }\n     public char getInitialSeparator() {\n         return this.initialSeparator;\n     }\n-    \n+\n     public Set getTriggers() {\n         return Collections.EMPTY_SET;\n     }\n         validate(commandLine, this);\n     }\n \n-    public void validate(\n-        final WriteableCommandLine commandLine,\n-        final Option option)\n+    public void validate(final WriteableCommandLine commandLine,\n+                         final Option option)\n         throws OptionException {\n-\n         final List values = commandLine.getValues(option);\n \n         if (values.size() < minimum) {\n-            throw new OptionException(option, \"cli.error.missing.values\");\n+            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n         }\n \n         if (values.size() > maximum) {\n-            throw new OptionException(\n-                option,\n-                \"cli.error.unexpected.value\",\n-                (String)values.get(maximum));\n+            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                      (String) values.get(maximum));\n         }\n \n         if (validator != null) {\n             try {\n                 validator.validate(values);\n-            }\n-            catch (InvalidArgumentException ive) {\n-                throw new OptionException(\n-                        option, \n-                        \"cli.error.unexpected.value\", \n-                        ive.getMessage());\n-            }\n-        }\n-    }\n-\n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n-\n+            } catch (InvalidArgumentException ive) {\n+                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                          ive.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         // do we display the outer optionality\n-        final boolean optional =\n-            helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n \n         // allow numbering if multiple args\n         final boolean numbered =\n-            maximum > 1\n-                && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n-\n-        final boolean bracketed =\n-            helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+\n+        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n \n         // if infinite args are allowed then crop the list\n-        final int max = maximum == Integer.MAX_VALUE ? 2 : maximum;\n+        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n \n         int i = 0;\n+\n         // for each argument\n         while (i < max) {\n             // if we're past the first add a space\n             if (i > 0) {\n                 buffer.append(' ');\n             }\n+\n             // if the next arg is optional\n-            if (i >= minimum && (optional || i > 0)) {\n+            if ((i >= minimum) && (optional || (i > 0))) {\n                 buffer.append('[');\n             }\n+\n             if (bracketed) {\n                 buffer.append('<');\n             }\n+\n             // add name\n             buffer.append(name);\n             ++i;\n+\n             // if numbering\n             if (numbered) {\n                 buffer.append(i);\n             }\n+\n             if (bracketed) {\n                 buffer.append('>');\n             }\n         }\n+\n         // if infinite args are allowed\n         if (maximum == Integer.MAX_VALUE) {\n             // append elipsis\n             buffer.append(\" ...\");\n         }\n+\n         // for each argument\n         while (i > 0) {\n             --i;\n+\n             // if the next arg is optional\n-            if (i >= minimum && (optional || i > 0)) {\n+            if ((i >= minimum) && (optional || (i > 0))) {\n                 buffer.append(']');\n             }\n         }\n         return description;\n     }\n \n-    public List helpLines(\n-        final int depth,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n         final HelpLine helpLine = new HelpLineImpl(this, depth);\n+\n         return Collections.singletonList(helpLine);\n     }\n \n     /**\n      * If there are any leading or trailing quotes remove them from the\n      * specified token.\n-     * \n+     *\n      * @param token\n      *            the token to strip leading and trailing quotes\n-     * \n+     *\n      * @return String the possibly modified token\n      */\n     public String stripBoundaryQuotes(String token) {\n         if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n             return token;\n         }\n-        \n+\n         if (token.startsWith(\"\\\"\")) {\n             token = token.substring(1, token.length());\n         }\n \n         return token;\n     }\n-    \n+\n     public boolean isRequired() {\n-        return getMinimum()>0;\n-    }\n-    \n+        return getMinimum() > 0;\n+    }\n+\n     public void defaults(final WriteableCommandLine commandLine) {\n         super.defaults(commandLine);\n-        defaultValues(commandLine,this);\n-    }\n-    \n-    public void defaultValues(final WriteableCommandLine commandLine, final Option option) {\n+        defaultValues(commandLine, this);\n+    }\n+\n+    public void defaultValues(final WriteableCommandLine commandLine,\n+                              final Option option) {\n         commandLine.setDefaultValues(option, defaultValues);\n     }\n }\n--- a/src/java/org/apache/commons/cli2/option/Command.java\n+++ b/src/java/org/apache/commons/cli2/option/Command.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Represents a cvs \"update\" style command line option.\n- * \n+ *\n  * Like all Parents, Commands can have child options and can be part of\n  * Arguments\n  */\n-public class Command extends ParentImpl {\n-\n+public class Command\n+    extends ParentImpl {\n     /** The display name for the command */\n     private final String preferredName;\n \n \n     /**\n      * Creates a new Command instance.\n-     * \n+     *\n      * @param preferredName\n      *            The name normally used to refer to the Command\n      * @param description\n      *            The Group of child options for this Command\n      * @param id\n      *            A unique id for the Command\n-     * \n+     *\n      * @see ParentImpl#ParentImpl(Argument, Group, String, int, boolean)\n      */\n-    public Command(\n-        final String preferredName,\n-        final String description,\n-        final Set aliases,\n-        final boolean required,\n-        final Argument argument,\n-        final Group children,\n-        final int id) {\n-\n+    public Command(final String preferredName,\n+                   final String description,\n+                   final Set aliases,\n+                   final boolean required,\n+                   final Argument argument,\n+                   final Group children,\n+                   final int id) {\n         super(argument, children, description, id, required);\n \n         // check the preferred name is valid\n-        if (preferredName == null || preferredName.length() < 1) {\n-            throw new IllegalArgumentException(\"preferredName must be at least 1 character\");\n+        if ((preferredName == null) || (preferredName.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n         }\n \n         this.preferredName = preferredName;\n \n         // gracefully and defensively handle aliases\n-        this.aliases = (aliases == null) \n-            ? Collections.EMPTY_SET \n-            : Collections.unmodifiableSet(new HashSet(aliases));\n+        this.aliases =\n+            (aliases == null) ? Collections.EMPTY_SET\n+                              : Collections.unmodifiableSet(new HashSet(aliases));\n \n         // populate the triggers Set\n         final Set newTriggers = new HashSet();\n         this.triggers = Collections.unmodifiableSet(newTriggers);\n     }\n \n-    public void processParent(\n-        final WriteableCommandLine commandLine,\n-        final ListIterator arguments)\n+    public void processParent(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments)\n         throws OptionException {\n-\n         // grab the argument to process\n-        final String arg = (String)arguments.next();\n+        final String arg = (String) arguments.next();\n \n         // if we can process it\n         if (canProcess(commandLine, arg)) {\n-\n             // then note the option\n             commandLine.addOption(this);\n \n             // normalise the argument list\n             arguments.set(preferredName);\n-        }\n-        else {\n-            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n         }\n     }\n \n     public void validate(WriteableCommandLine commandLine)\n         throws OptionException {\n         if (isRequired() && !commandLine.hasOption(this)) {\n-            throw new OptionException(this,\"cli.error.missing.required\", getPreferredName());\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n         }\n \n         super.validate(commandLine);\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n-\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         // do we display optionality\n         final boolean optional =\n             !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n-        final boolean displayAliases =\n-            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n \n         if (optional) {\n             buffer.append('[');\n         }\n+\n         buffer.append(preferredName);\n \n         if (displayAliases && !aliases.isEmpty()) {\n             Collections.sort(list);\n \n             for (final Iterator i = list.iterator(); i.hasNext();) {\n-                final String alias = (String)i.next();\n+                final String alias = (String) i.next();\n                 buffer.append(alias);\n+\n                 if (i.hasNext()) {\n                     buffer.append(',');\n                 }\n             }\n+\n             buffer.append(')');\n         }\n \n--- a/src/java/org/apache/commons/cli2/option/DefaultOption.java\n+++ b/src/java/org/apache/commons/cli2/option/DefaultOption.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n \n /**\n  * A Parent implementation representing normal options.\n  */\n-public class DefaultOption extends ParentImpl {\n-\n+public class DefaultOption\n+    extends ParentImpl {\n     /**\n      * The default token used to prefix a short option\n      */\n     public static final String DEFAULT_SHORT_PREFIX = \"-\";\n-    \n+\n     /**\n      * The default token used to prefix a long option\n      */\n     public static final String DEFAULT_LONG_PREFIX = \"--\";\n-    \n+\n     /**\n      * The default value for the burstEnabled constructor parameter\n      */\n     public static final boolean DEFAULT_BURST_ENABLED = true;\n-\n     private final String preferredName;\n     private final Set aliases;\n     private final Set burstAliases;\n     private final Set triggers;\n     private final Set prefixes;\n-\n     private final String shortPrefix;\n     private final boolean burstEnabled;\n-\n     private final int burstLength;\n \n     /**\n      * Creates a new DefaultOption\n-     * \n+     *\n      * @param shortPrefix the prefix used for short options\n      * @param longPrefix the prefix used for long options\n      * @param burstEnabled should option bursting be enabled\n      * @param children the Group children belonging to this Parent, ot null\n      * @param id the unique identifier for this Option\n      * @throws IllegalArgumentException if the preferredName or an alias isn't\n-     *     prefixed with shortPrefix or longPrefix \n-     */\n-    public DefaultOption(\n-        final String shortPrefix,\n-        final String longPrefix,\n-        final boolean burstEnabled,\n-        final String preferredName,\n-        final String description,\n-        final Set aliases,\n-        final Set burstAliases,\n-        final boolean required,\n-        final Argument argument,\n-        final Group children,\n-        final int id) {\n+     *     prefixed with shortPrefix or longPrefix\n+     */\n+    public DefaultOption(final String shortPrefix,\n+                         final String longPrefix,\n+                         final boolean burstEnabled,\n+                         final String preferredName,\n+                         final String description,\n+                         final Set aliases,\n+                         final Set burstAliases,\n+                         final boolean required,\n+                         final Argument argument,\n+                         final Group children,\n+                         final int id) {\n         super(argument, children, description, id, required);\n \n         this.shortPrefix = shortPrefix;\n         this.burstLength = shortPrefix.length() + 1;\n \n         this.preferredName = preferredName;\n-        this.aliases = (aliases == null) \n-            ? Collections.EMPTY_SET\n-            : Collections.unmodifiableSet(new HashSet(aliases));\n-\n-        this.burstAliases = (burstAliases == null)\n-            ? Collections.EMPTY_SET\n-            : Collections.unmodifiableSet(new HashSet(burstAliases));\n+        this.aliases =\n+            (aliases == null) ? Collections.EMPTY_SET\n+                              : Collections.unmodifiableSet(new HashSet(aliases));\n+\n+        this.burstAliases =\n+            (burstAliases == null) ? Collections.EMPTY_SET\n+                                   : Collections.unmodifiableSet(new HashSet(burstAliases));\n \n         final Set newTriggers = new HashSet();\n         newTriggers.add(preferredName);\n         newPrefixes.add(shortPrefix);\n         newPrefixes.add(longPrefix);\n         this.prefixes = Collections.unmodifiableSet(newPrefixes);\n-        \n+\n         checkPrefixes(newPrefixes);\n     }\n \n-    public boolean canProcess(final WriteableCommandLine commandLine, final String argument) {\n-        return argument != null\n-            && (super.canProcess(commandLine, argument)\n-                || (argument.length() >= burstLength\n-                    && burstAliases.contains(argument.substring(0, burstLength))));\n-    }\n-\n-    public void processParent(\n-        WriteableCommandLine commandLine,\n-        ListIterator arguments)\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String argument) {\n+        return (argument != null) &&\n+               (super.canProcess(commandLine, argument) ||\n+               ((argument.length() >= burstLength) &&\n+               burstAliases.contains(argument.substring(0, burstLength))));\n+    }\n+\n+    public void processParent(WriteableCommandLine commandLine,\n+                              ListIterator arguments)\n         throws OptionException {\n-\n-        final String argument = (String)arguments.next();\n+        final String argument = (String) arguments.next();\n \n         if (triggers.contains(argument)) {\n             commandLine.addOption(this);\n             arguments.set(preferredName);\n-        }\n-        else if (burstEnabled && argument.length() >= burstLength) {\n+        } else if (burstEnabled && (argument.length() >= burstLength)) {\n             final String burst = argument.substring(0, burstLength);\n \n             if (burstAliases.contains(burst)) {\n                 arguments.set(preferredName);\n \n                 if (getArgument() == null) {\n-                    arguments.add(\n-                        shortPrefix + argument.substring(burstLength));\n-                }\n-                else {\n+                    arguments.add(shortPrefix + argument.substring(burstLength));\n+                } else {\n                     arguments.add(argument.substring(burstLength));\n                 }\n \n                 arguments.previous();\n+            } else {\n+                throw new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n             }\n-            else {\n-                throw new OptionException(this, \"cli.error.burst\", argument);\n-            }\n-        }\n-        else {\n-            throw new OptionException(this, \"cli.error.unexpected\", argument);\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n         }\n     }\n \n     public void validate(WriteableCommandLine commandLine)\n         throws OptionException {\n         if (isRequired() && !commandLine.hasOption(this)) {\n-            throw new OptionException(this,\"cli.error.missing.required\", getPreferredName());\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n         }\n \n         super.validate(commandLine);\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n-\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         // do we display optionality\n         final boolean optional =\n             !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n-        final boolean displayAliases =\n-            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n \n         if (optional) {\n             buffer.append('[');\n         }\n+\n         buffer.append(preferredName);\n \n         if (displayAliases && !aliases.isEmpty()) {\n             Collections.sort(list);\n \n             for (final Iterator i = list.iterator(); i.hasNext();) {\n-                final String alias = (String)i.next();\n+                final String alias = (String) i.next();\n                 buffer.append(alias);\n+\n                 if (i.hasNext()) {\n                     buffer.append(',');\n                 }\n             }\n+\n             buffer.append(')');\n         }\n \n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n \n /**\n  * An implementation of Group\n  */\n-public class GroupImpl extends OptionImpl implements Group {\n-\n+public class GroupImpl\n+    extends OptionImpl implements Group {\n     private final String name;\n     private final String description;\n     private final List options;\n \n     /**\n      * Creates a new GroupImpl using the specified parameters.\n-     * \n+     *\n      * @param options the Options and Arguments that make up the Group\n      * @param name the name of this Group, or null\n      * @param description a description of this Group\n      * @param minimum the minimum number of Options for a valid CommandLine\n      * @param maximum the maximum number of Options for a valid CommandLine\n      */\n-    public GroupImpl(\n-        final List options,\n-        final String name,\n-        final String description,\n-        final int minimum,\n-        final int maximum) \n-    {\n-        super(0,false);\n+    public GroupImpl(final List options,\n+                     final String name,\n+                     final String description,\n+                     final int minimum,\n+                     final int maximum) {\n+        super(0, false);\n \n         this.name = name;\n         this.description = description;\n \n         // anonymous Argument temporary storage\n         final List newAnonymous = new ArrayList();\n-        \n+\n         // map (key=trigger & value=Option) temporary storage\n-        final SortedMap newOptionMap =\n-            new TreeMap(ReverseStringComparator.getInstance());\n+        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n \n         // prefixes temporary storage\n         final Set newPrefixes = new HashSet();\n-        \n+\n         // process the options\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n-            \n             final Option option = (Option) i.next();\n \n             if (option instanceof Argument) {\n                 i.remove();\n                 newAnonymous.add(option);\n-            } \n-            else {\n+            } else {\n                 final Set triggers = option.getTriggers();\n-                \n+\n                 for (Iterator j = triggers.iterator(); j.hasNext();) {\n                     newOptionMap.put(j.next(), option);\n                 }\n                 newPrefixes.addAll(option.getPrefixes());\n             }\n         }\n-        \n+\n         this.anonymous = Collections.unmodifiableList(newAnonymous);\n         this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n         this.prefixes = Collections.unmodifiableSet(newPrefixes);\n     }\n \n-    public boolean canProcess(final WriteableCommandLine commandLine, String arg) {\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              String arg) {\n         if (arg == null) {\n             return false;\n         }\n \n         // filter\n         final Map tailMap = optionMap.tailMap(arg);\n-        \n+\n         // check if bursting is required\n-        for (final Iterator iter = tailMap.values().iterator();\n-            iter.hasNext();) {\n-            \n+        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n             final Option option = (Option) iter.next();\n+\n             if (option.canProcess(commandLine, arg)) {\n                 return true;\n             }\n         }\n-        \n-        if(commandLine.looksLikeOption(arg)) {\n+\n+        if (commandLine.looksLikeOption(arg)) {\n             return false;\n         }\n-        \n+\n         // anonymous argument(s) means we can process it\n         if (anonymous.size() > 0) {\n             return true;\n         return optionMap.keySet();\n     }\n \n-    public void process(\n-        final WriteableCommandLine commandLine,\n-        final ListIterator arguments)\n+    public void process(final WriteableCommandLine commandLine,\n+                        final ListIterator arguments)\n         throws OptionException {\n-        \n         String previous = null;\n \n         // [START process each command line token\n         while (arguments.hasNext()) {\n-            \n             // grab the next argument\n-            final String arg = (String)arguments.next();\n-            \n+            final String arg = (String) arguments.next();\n+\n             // if we have just tried to process this instance\n-            if(arg==previous) {\n+            if (arg == previous) {\n                 // rollback and abort\n                 arguments.previous();\n+\n                 break;\n             }\n+\n             // remember last processed instance\n             previous = arg;\n-            \n-            final Option opt = (Option)optionMap.get(arg);\n+\n+            final Option opt = (Option) optionMap.get(arg);\n \n             // option found\n             if (opt != null) {\n             // [START option NOT found\n             else {\n                 // it might be an anonymous argument continue search\n-                \n                 // [START argument may be anonymous\n                 if (commandLine.looksLikeOption(arg)) {\n-                    \n                     // narrow the search\n                     final Collection values = optionMap.tailMap(arg).values();\n-                    \n+\n                     boolean foundMemberOption = false;\n+\n                     for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                         final Option option = (Option) i.next();\n-                        \n+\n                         if (option.canProcess(commandLine, arg)) {\n-                        \tfoundMemberOption = true;\n+                            foundMemberOption = true;\n                             arguments.previous();\n                             option.process(commandLine, arguments);\n                         }\n                     }\n+\n                     // back track and abort this group if necessary\n-                    if(!foundMemberOption) {\n-                    \targuments.previous();\n-                    \treturn;\n+                    if (!foundMemberOption) {\n+                        arguments.previous();\n+\n+                        return;\n                     }\n                 } // [END argument may be anonymous\n-                \n+\n                 // [START argument is NOT anonymous\n                 else {\n                     // move iterator back, current value not used\n \n                     // if there are no anonymous arguments then this group can't\n                     // process the argument\n-                    if(anonymous.isEmpty()){\n+                    if (anonymous.isEmpty()) {\n                         break;\n                     }\n \n                     // TODO: why do we iterate over all anonymous arguments?\n                     // canProcess will always return true?\n                     for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n-                        final Argument argument = (Argument)i.next();\n+                        final Argument argument = (Argument) i.next();\n+\n                         if (argument.canProcess(commandLine, arguments)) {\n                             argument.process(commandLine, arguments);\n                         }\n \n     public void validate(final WriteableCommandLine commandLine)\n         throws OptionException {\n-\n         // number of options found\n         int present = 0;\n-        \n+\n         // reference to first unexpected option\n         Option unexpected = null;\n-        \n+\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n+\n             // if the child option is required then validate it\n-            if(option.isRequired()){\n+            if (option.isRequired()) {\n                 option.validate(commandLine);\n             }\n-            if(option instanceof Group){\n-            \toption.validate(commandLine);\n-            }\n+\n+            if (option instanceof Group) {\n+                option.validate(commandLine);\n+            }\n+\n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n+\n                     break;\n                 }\n+\n                 option.validate(commandLine);\n             }\n         }\n \n         // too many options\n         if (unexpected != null) {\n-            throw new OptionException(\n-                this,\n-                \"cli.error.unexpected\",\n-                unexpected.getPreferredName());\n-        }\n-        \n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n+                                      unexpected.getPreferredName());\n+        }\n+\n         // too few option\n         if (present < minimum) {\n-            throw new OptionException(this, \"cli.error.missing.option\");\n+            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n         }\n \n         // validate each anonymous argument\n         for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n-            final Option option = (Option)i.next();\n+            final Option option = (Option) i.next();\n             option.validate(commandLine);\n         }\n     }\n         return description;\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         appendUsage(buffer, helpSettings, comp, \"|\");\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp,\n-        final String separator) {\n-\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp,\n+                            final String separator) {\n         final Set helpSettingsCopy = new HashSet(helpSettings);\n \n         final boolean optional =\n-            minimum == 0\n-                && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n \n         final boolean expanded =\n-            name == null\n-                || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n \n         final boolean named =\n-            !expanded\n-                || (name != null\n-                    && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n-\n-        final boolean arguments =\n-            helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n-\n-        final boolean outer =\n-            helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n+            !expanded ||\n+            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n+\n+        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n \n         helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n \n         if (named) {\n             buffer.append(name);\n         }\n+\n         if (both) {\n             buffer.append(\" (\");\n         }\n+\n         if (expanded) {\n             final Set childSettings;\n-            if (!helpSettingsCopy\n-                .contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n+\n+            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                 childSettings = DisplaySetting.NONE;\n-            }\n-            else {\n+            } else {\n                 childSettings = new HashSet(helpSettingsCopy);\n                 childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n             }\n \n             // grab a list of the group's options.\n             final List list;\n+\n             if (comp == null) {\n                 // default to using the initial order\n                 list = options;\n-            }\n-            else {\n+            } else {\n                 // sort options if comparator is supplied\n                 list = new ArrayList(options);\n                 Collections.sort(list, comp);\n \n             // for each option.\n             for (final Iterator i = list.iterator(); i.hasNext();) {\n-                final Option option = (Option)i.next();\n+                final Option option = (Option) i.next();\n \n                 // append usage information\n                 option.appendUsage(buffer, childSettings, comp);\n                 }\n             }\n         }\n+\n         if (both) {\n             buffer.append(')');\n         }\n+\n         if (optional && outer) {\n             buffer.append(']');\n         }\n+\n         if (arguments) {\n             for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                 buffer.append(' ');\n-                final Option option = (Option)i.next();\n+\n+                final Option option = (Option) i.next();\n                 option.appendUsage(buffer, helpSettingsCopy, comp);\n             }\n         }\n+\n         if (optional && !outer) {\n             buffer.append(']');\n-\n-        }\n-    }\n-\n-    public List helpLines(\n-        final int depth,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+        }\n+    }\n+\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n         final List helpLines = new ArrayList();\n+\n         if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n             final HelpLine helpLine = new HelpLineImpl(this, depth);\n             helpLines.add(helpLine);\n         }\n+\n         if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n-\n             // grab a list of the group's options.\n             final List list;\n+\n             if (comp == null) {\n                 // default to using the initial order\n                 list = options;\n-            }\n-            else {\n+            } else {\n                 // sort options if comparator is supplied\n                 list = new ArrayList(options);\n                 Collections.sort(list, comp);\n \n             // for each option\n             for (final Iterator i = list.iterator(); i.hasNext();) {\n-                final Option option = (Option)i.next();\n-                helpLines.addAll(\n-                    option.helpLines(depth + 1, helpSettings, comp));\n-            }\n-        }\n+                final Option option = (Option) i.next();\n+                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+\n         if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n             for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n-                final Option option = (Option)i.next();\n-                helpLines.addAll(\n-                    option.helpLines(depth + 1, helpSettings, comp));\n-            }\n-        }\n+                final Option option = (Option) i.next();\n+                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+\n         return helpLines;\n     }\n-    \n+\n     /**\n      * Gets the member Options of thie Group.\n      * Note this does not include any Arguments\n      * @return only the non Argument Options of the Group\n      */\n-    public List getOptions(){\n-    \treturn options;\n-    }\n-    \n+    public List getOptions() {\n+        return options;\n+    }\n+\n     /**\n      * Gets the anonymous Arguments of this Group.\n      * @return the Argument options of this Group\n      */\n-    public List getAnonymous(){\n-    \treturn anonymous;\n-    }\n-\t\n-\tpublic Option findOption(final String trigger) {\n-\t\tfinal Iterator i = getOptions().iterator();\n-\t\twhile(i.hasNext()){\n-\t\t\tfinal Option option = (Option)i.next();\n-\t\t\tfinal Option found = option.findOption(trigger);\n-\t\t\tif(found!=null){\n-\t\t\t\treturn found;\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\treturn null;\n-\t}\n-\t\n-\tpublic int getMinimum() {\n-\t\treturn minimum;\n-\t}\n-\t\n-\tpublic int getMaximum() {\n-\t\treturn maximum;\n-\t}\n+    public List getAnonymous() {\n+        return anonymous;\n+    }\n+\n+    public Option findOption(final String trigger) {\n+        final Iterator i = getOptions().iterator();\n+\n+        while (i.hasNext()) {\n+            final Option option = (Option) i.next();\n+            final Option found = option.findOption(trigger);\n+\n+            if (found != null) {\n+                return found;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public int getMinimum() {\n+        return minimum;\n+    }\n+\n+    public int getMaximum() {\n+        return maximum;\n+    }\n \n     public boolean isRequired() {\n-        return getMinimum()>0;\n-    }\n-    \n+        return getMinimum() > 0;\n+    }\n+\n     public void defaults(final WriteableCommandLine commandLine) {\n         super.defaults(commandLine);\n-        \n+\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n             option.defaults(commandLine);\n         }\n-        \n+\n         for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n             option.defaults(commandLine);\n     }\n }\n \n+\n class ReverseStringComparator implements Comparator {\n     private static final Comparator instance = new ReverseStringComparator();\n+\n+    private ReverseStringComparator() {\n+        // just making sure nobody else creates one\n+    }\n \n     /**\n      * Gets a singleton instance of a ReverseStringComparator\n         return instance;\n     }\n \n-    private ReverseStringComparator() {\n-        // just making sure nobody else creates one\n-    }\n-\n-    public int compare(final Object o1, final Object o2) {\n-        final String s1 = (String)o1;\n-        final String s2 = (String)o2;\n+    public int compare(final Object o1,\n+                       final Object o2) {\n+        final String s1 = (String) o1;\n+        final String s2 = (String) o2;\n \n         return -s1.compareTo(s2);\n     }\n--- a/src/java/org/apache/commons/cli2/option/OptionImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/OptionImpl.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.DisplaySetting;\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Option implementations.\n  */\n public abstract class OptionImpl implements Option {\n-\n     private final int id;\n     private final boolean required;\n \n      * @param id the unique id of this Option\n      * @param required true iff this Option must be present\n      */\n-    public OptionImpl(final int id, final boolean required) {\n+    public OptionImpl(final int id,\n+                      final boolean required) {\n         this.id = id;\n         this.required = required;\n     }\n \n-    public boolean canProcess(final WriteableCommandLine commandLine, final ListIterator arguments) {\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments) {\n         if (arguments.hasNext()) {\n-            final String argument = (String)arguments.next();\n+            final String argument = (String) arguments.next();\n             arguments.previous();\n+\n             return canProcess(commandLine, argument);\n-        }\n-        else {\n+        } else {\n             return false;\n         }\n     }\n     public String toString() {\n         final StringBuffer buffer = new StringBuffer();\n         appendUsage(buffer, DisplaySetting.ALL, null);\n+\n         return buffer.toString();\n     }\n \n \n     public boolean equals(final Object thatObj) {\n         if (thatObj instanceof OptionImpl) {\n-            final OptionImpl that = (OptionImpl)thatObj;\n+            final OptionImpl that = (OptionImpl) thatObj;\n \n-            return getId() == that.getId()\n-\t\t\t\t&& equals(getPreferredName(),that.getPreferredName())\n-\t\t\t\t&& equals(getDescription(),that.getDescription())\n-\t\t\t\t&& equals(getPrefixes(),that.getPrefixes())\n-\t\t\t\t&& equals(getTriggers(),that.getTriggers());\n-        }\n-        else {\n+            return (getId() == that.getId()) &&\n+                   equals(getPreferredName(), that.getPreferredName()) &&\n+                   equals(getDescription(), that.getDescription()) &&\n+                   equals(getPrefixes(), that.getPrefixes()) &&\n+                   equals(getTriggers(), that.getTriggers());\n+        } else {\n             return false;\n         }\n     }\n \n-\tprivate boolean equals(Object left, Object right) {\n-\t\tif(left==null && right==null){\n-\t\t\treturn true;\n-\t\t}\n-\t\telse if(left==null || right==null){\n-\t\t\treturn false;\n-\t\t}\n-\t\telse{\n-\t\t\treturn left.equals(right);\n-\t\t}\n-\t}\n+    private boolean equals(Object left,\n+                           Object right) {\n+        if ((left == null) && (right == null)) {\n+            return true;\n+        } else if ((left == null) || (right == null)) {\n+            return false;\n+        } else {\n+            return left.equals(right);\n+        }\n+    }\n \n-\tpublic int hashCode() {\n+    public int hashCode() {\n         int hashCode = getId();\n-        hashCode = hashCode * 37 + getPreferredName().hashCode();\n+        hashCode = (hashCode * 37) + getPreferredName().hashCode();\n+\n         if (getDescription() != null) {\n-            hashCode = hashCode * 37 + getDescription().hashCode();\n+            hashCode = (hashCode * 37) + getDescription().hashCode();\n         }\n-        hashCode = hashCode * 37 + getPrefixes().hashCode();\n-        hashCode = hashCode * 37 + getTriggers().hashCode();\n+\n+        hashCode = (hashCode * 37) + getPrefixes().hashCode();\n+        hashCode = (hashCode * 37) + getTriggers().hashCode();\n+\n         return hashCode;\n     }\n-    \n-\tpublic Option findOption(String trigger) {\n-\t\tif(getTriggers().contains(trigger)){\n-\t\t\treturn this;\n-\t\t}\n-\t\telse{\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+\n+    public Option findOption(String trigger) {\n+        if (getTriggers().contains(trigger)) {\n+            return this;\n+        } else {\n+            return null;\n+        }\n+    }\n \n     public boolean isRequired() {\n         return required;\n     }\n-    \n+\n     public void defaults(final WriteableCommandLine commandLine) {\n         // nothing to do normally\n     }\n-    \n+\n     protected void checkPrefixes(final Set prefixes) {\n-        \n         // nothing to do if empty prefix list\n-        if(prefixes.isEmpty()) {\n+        if (prefixes.isEmpty()) {\n             return;\n         }\n-        \n+\n         // check preferred name\n         checkPrefix(prefixes, getPreferredName());\n-        \n+\n         // check triggers\n         this.getTriggers();\n+\n         for (final Iterator i = getTriggers().iterator(); i.hasNext();) {\n             checkPrefix(prefixes, (String) i.next());\n         }\n     }\n \n-    private void checkPrefix(final Set prefixes, final String trigger) {\n+    private void checkPrefix(final Set prefixes,\n+                             final String trigger) {\n         for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n             String prefix = (String) i.next();\n-            if(trigger.startsWith(prefix)) {\n+\n+            if (trigger.startsWith(prefix)) {\n                 return;\n             }\n         }\n-        \n-        final ResourceHelper helper = \n-            ResourceHelper.getResourceHelper(OptionImpl.class);\n-        final String message = \n-            helper.getMessage(\"cli.error.trigger.needs.prefix\",\n-                    trigger,prefixes.toString());\n+\n+        final ResourceHelper helper = ResourceHelper.getResourceHelper();\n+        final String message =\n+            helper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\n+                              prefixes.toString());\n         throw new IllegalArgumentException(message);\n     }\n-    \n-    \n }\n--- a/src/java/org/apache/commons/cli2/option/PropertyOption.java\n+++ b/src/java/org/apache/commons/cli2/option/PropertyOption.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.HelpLine;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n \n /**\n  * Handles the java style \"-Dprop=value\" opions\n  */\n-public class PropertyOption extends OptionImpl {\n-\n+public class PropertyOption\n+    extends OptionImpl {\n     public static final String DEFAULT_OPTION_STRING = \"-D\";\n     public static final String DEFAULT_DESCRIPTION =\n         \"Passes properties and values to the application\";\n \n+    /**\n+     * A default PropertyOption instance\n+     */\n+    public static final PropertyOption INSTANCE = new PropertyOption();\n     private final String optionString;\n     private final String description;\n     private final Set prefixes;\n      * @param description the description of the Option\n      * @param id the id of the Option\n      */\n-    public PropertyOption(\n-        final String optionString,\n-        final String description,\n-        final int id) {\n-        super(id,false);\n+    public PropertyOption(final String optionString,\n+                          final String description,\n+                          final int id) {\n+        super(id, false);\n         this.optionString = optionString;\n         this.description = description;\n         this.prefixes = Collections.singleton(optionString);\n     }\n \n-    /**\n-     * A default PropertyOption instance\n-     */\n-    public static final PropertyOption INSTANCE = new PropertyOption();\n-\n-    public boolean canProcess(final WriteableCommandLine commandLine, final String argument) {\n-        return argument != null\n-            && argument.startsWith(optionString)\n-            && argument.length() > optionString.length();\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String argument) {\n+        return (argument != null) && argument.startsWith(optionString) &&\n+               (argument.length() > optionString.length());\n     }\n \n     public Set getPrefixes() {\n         return prefixes;\n     }\n \n-    public void process(\n-        final WriteableCommandLine commandLine,\n-        final ListIterator arguments)\n+    public void process(final WriteableCommandLine commandLine,\n+                        final ListIterator arguments)\n         throws OptionException {\n-\n-        final String arg = (String)arguments.next();\n+        final String arg = (String) arguments.next();\n \n         if (!canProcess(commandLine, arg)) {\n-            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n         }\n \n         final int propertyStart = optionString.length();\n         final int equalsIndex = arg.indexOf('=', propertyStart);\n         final String property;\n         final String value;\n+\n         if (equalsIndex < 0) {\n             property = arg.substring(propertyStart);\n             value = \"true\";\n-        }\n-        else {\n+        } else {\n             property = arg.substring(propertyStart, equalsIndex);\n             value = arg.substring(equalsIndex + 1);\n         }\n+\n         commandLine.addProperty(property, value);\n     }\n \n         // PropertyOption needs no validation\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        final boolean display = helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n \n-        final boolean display =\n-            helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n-\n-        final boolean bracketed =\n-            helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n \n         if (display) {\n             buffer.append(optionString);\n+\n             if (bracketed) {\n                 buffer.append('<');\n             }\n+\n             buffer.append(\"property\");\n+\n             if (bracketed) {\n                 buffer.append('>');\n             }\n+\n             buffer.append(\"=\");\n+\n             if (bracketed) {\n                 buffer.append('<');\n             }\n+\n             buffer.append(\"value\");\n+\n             if (bracketed) {\n                 buffer.append('>');\n             }\n         return description;\n     }\n \n-    public List helpLines(\n-        final int depth,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n         if (helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION)) {\n             final HelpLine helpLine = new HelpLineImpl(this, depth);\n+\n             return Collections.singletonList(helpLine);\n-        }\n-        else {\n+        } else {\n             return Collections.EMPTY_LIST;\n         }\n     }\n--- a/src/java/org/apache/commons/cli2/option/SourceDestArgument.java\n+++ b/src/java/org/apache/commons/cli2/option/SourceDestArgument.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * An Argument implementation that allows a variable size Argument to precede a\n  * <code>cp</code> command where a number of source can be specified with\n  * exactly one destination specfied at the end.\n  */\n-public class SourceDestArgument extends ArgumentImpl {\n-    private static int sum(final int a, final int b) {\n-        return Math.max(a, Math.max(b, a + b));\n-    }\n-\n+public class SourceDestArgument\n+    extends ArgumentImpl {\n     private final Argument source;\n     private final Argument dest;\n \n     /**\n      * Creates a SourceDestArgument using defaults where possible.\n-     * \n+     *\n      * @param source the variable size Argument\n      * @param dest the fixed size Argument\n      */\n-    public SourceDestArgument(\n-        final Argument source,\n-        final Argument dest) {\n-        this(\n-            source,\n-            dest,\n-            DEFAULT_INITIAL_SEPARATOR,\n-            DEFAULT_SUBSEQUENT_SEPARATOR,\n-            DEFAULT_CONSUME_REMAINING,\n-            null);\n+    public SourceDestArgument(final Argument source,\n+                              final Argument dest) {\n+        this(source, dest, DEFAULT_INITIAL_SEPARATOR, DEFAULT_SUBSEQUENT_SEPARATOR,\n+             DEFAULT_CONSUME_REMAINING, null);\n     }\n \n     /**\n      * Creates a SourceDestArgument using the specified parameters.\n-     * \n+     *\n      * @param source the variable size Argument\n      * @param dest the fixed size Argument\n      * @param initialSeparator the inistial separator to use\n      * @param subsequentSeparator the subsequent separator to use\n-     * @param consumeRemaining the token triggering consume remaining behaviour \n+     * @param consumeRemaining the token triggering consume remaining behaviour\n      * @param defaultValues the default values for the SourceDestArgument\n      */\n-    public SourceDestArgument(\n-        final Argument source,\n-        final Argument dest,\n-        final char initialSeparator,\n-        final char subsequentSeparator,\n-        final String consumeRemaining,\n-        final List defaultValues) {\n-        super(\n-            \"SourceDestArgument\",\n-            null,\n-            sum(source.getMinimum(), dest.getMinimum()),\n-            sum(source.getMaximum(), dest.getMaximum()),\n-            initialSeparator,\n-            subsequentSeparator,\n-            null,\n-            consumeRemaining,\n-            defaultValues,\n-            0);\n+    public SourceDestArgument(final Argument source,\n+                              final Argument dest,\n+                              final char initialSeparator,\n+                              final char subsequentSeparator,\n+                              final String consumeRemaining,\n+                              final List defaultValues) {\n+        super(\"SourceDestArgument\", null, sum(source.getMinimum(), dest.getMinimum()),\n+              sum(source.getMaximum(), dest.getMaximum()), initialSeparator, subsequentSeparator,\n+              null, consumeRemaining, defaultValues, 0);\n \n         this.source = source;\n         this.dest = dest;\n \n         if (dest.getMinimum() != dest.getMaximum()) {\n-            throw new IllegalArgumentException(\"The dest argument must enforce a fixed number of values\");\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES));\n         }\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n+    private static int sum(final int a,\n+                           final int b) {\n+        return Math.max(a, Math.max(b, a + b));\n+    }\n \n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         final int length = buffer.length();\n \n         source.appendUsage(buffer, helpSettings, comp);\n         dest.appendUsage(buffer, helpSettings, comp);\n     }\n \n-    public List helpLines(int depth, Set helpSettings, Comparator comp) {\n+    public List helpLines(int depth,\n+                          Set helpSettings,\n+                          Comparator comp) {\n         final List helpLines = new ArrayList();\n         helpLines.addAll(source.helpLines(depth, helpSettings, comp));\n         helpLines.addAll(dest.helpLines(depth, helpSettings, comp));\n+\n         return helpLines;\n     }\n \n-    public void validate(WriteableCommandLine commandLine, Option option)\n+    public void validate(WriteableCommandLine commandLine,\n+                         Option option)\n         throws OptionException {\n-\n         final List values = commandLine.getValues(option);\n \n         final int limit = values.size() - dest.getMinimum();\n         int count = 0;\n \n         final Iterator i = values.iterator();\n+\n         while (count++ < limit) {\n             commandLine.addValue(source, i.next());\n         }\n+\n         while (i.hasNext()) {\n             commandLine.addValue(dest, i.next());\n         }\n         dest.validate(commandLine, dest);\n     }\n \n-    public boolean canProcess(final WriteableCommandLine commandLine, final String arg) {\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n         return source.canProcess(commandLine, arg) || dest.canProcess(commandLine, arg);\n     }\n }\n--- a/src/java/org/apache/commons/cli2/option/Switch.java\n+++ b/src/java/org/apache/commons/cli2/option/Switch.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.OptionException;\n import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * A Parent implementation representing normal switch options.\n- * For example: <code>+d|-d</code> or <code>--enable-x|--disable-x</code>. \n+ * For example: <code>+d|-d</code> or <code>--enable-x|--disable-x</code>.\n  */\n-public class Switch extends ParentImpl {\n+public class Switch\n+    extends ParentImpl {\n+    /** i18n */\n+    public static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n \n     /**\n      * The default prefix for enabled switches\n      */\n     public static final String DEFAULT_ENABLED_PREFIX = \"+\";\n-    \n+\n     /**\n      * The default prefix for disabled switches\n      */\n     public static final String DEFAULT_DISABLED_PREFIX = \"-\";\n-\n     private final String enabledPrefix;\n     private final String disabledPrefix;\n     private final Set triggers;\n      * @param children the Group children belonging to this Parent, ot null\n      * @param id the unique identifier for this Option\n      * @throws IllegalArgumentException if the preferredName or an alias isn't\n-     *     prefixed with enabledPrefix or disabledPrefix \n+     *     prefixed with enabledPrefix or disabledPrefix\n      */\n-    public Switch(\n-        final String enabledPrefix,\n-        final String disabledPrefix,\n-        final String preferredName,\n-        final Set aliases,\n-        final String description,\n-        final boolean required,\n-        final Argument argument,\n-        final Group children,\n-        final int id,\n-        final Boolean switchDefault) {\n+    public Switch(final String enabledPrefix,\n+                  final String disabledPrefix,\n+                  final String preferredName,\n+                  final Set aliases,\n+                  final String description,\n+                  final boolean required,\n+                  final Argument argument,\n+                  final Group children,\n+                  final int id,\n+                  final Boolean switchDefault) {\n         super(argument, children, description, id, required);\n \n         if (enabledPrefix == null) {\n-            throw new IllegalArgumentException(\"enabledPrefix must be supplied\");\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_NO_ENABLED_PREFIX));\n         }\n \n         if (disabledPrefix == null) {\n-            throw new IllegalArgumentException(\"enabledPrefix must be supplied\");\n+            throw new IllegalArgumentException(ResourceConstants.SWITCH_NO_DISABLED_PREFIX);\n         }\n \n         if (enabledPrefix.startsWith(disabledPrefix)) {\n-            throw new IllegalArgumentException(\"The enabledPrefix cannot start the same as disabledPrefix\");\n+            throw new IllegalArgumentException(ResourceConstants.SWITCH_ENABLED_STARTS_WITH_DISABLED);\n         }\n \n         if (disabledPrefix.startsWith(enabledPrefix)) {\n-            throw new IllegalArgumentException(\"The disabledPrefix cannot start the same as enabledPrefix\");\n+            throw new IllegalArgumentException(ResourceConstants.SWITCH_DISABLED_STARTWS_WITH_ENABLED);\n         }\n \n         this.enabledPrefix = enabledPrefix;\n         this.disabledPrefix = disabledPrefix;\n         this.preferredName = preferredName;\n \n-        if (preferredName == null || preferredName.length() < 1) {\n-            throw new IllegalArgumentException(\"preferredName must be at least 1 character\");\n+        if ((preferredName == null) || (preferredName.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT);\n         }\n \n         final Set newTriggers = new HashSet();\n \n         if (aliases == null) {\n             this.aliases = Collections.EMPTY_SET;\n-        }\n-        else {\n+        } else {\n             this.aliases = Collections.unmodifiableSet(new HashSet(aliases));\n+\n             for (final Iterator i = aliases.iterator(); i.hasNext();) {\n-                final String alias = (String)i.next();\n+                final String alias = (String) i.next();\n                 newTriggers.add(enabledPrefix + alias);\n                 newTriggers.add(disabledPrefix + alias);\n             }\n         newPrefixes.add(enabledPrefix);\n         newPrefixes.add(disabledPrefix);\n         this.prefixes = Collections.unmodifiableSet(newPrefixes);\n-        \n+\n         this.defaultSwitch = switchDefault;\n-        \n+\n         checkPrefixes(newPrefixes);\n     }\n \n-    public void processParent(\n-        final WriteableCommandLine commandLine,\n-        final ListIterator arguments)\n+    public void processParent(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments)\n         throws OptionException {\n-\n-        final String arg = (String)arguments.next();\n+        final String arg = (String) arguments.next();\n \n         if (canProcess(commandLine, arg)) {\n             if (arg.startsWith(enabledPrefix)) {\n                 commandLine.addSwitch(this, true);\n                 arguments.set(enabledPrefix + preferredName);\n             }\n+\n             if (arg.startsWith(disabledPrefix)) {\n                 commandLine.addSwitch(this, false);\n                 arguments.set(disabledPrefix + preferredName);\n             }\n-        }\n-        else {\n-            throw new OptionException(this, \"cli.error.unexpected\", arg);\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n         }\n     }\n \n     public void validate(WriteableCommandLine commandLine)\n         throws OptionException {\n         if (isRequired() && !commandLine.hasOption(this)) {\n-            throw new OptionException(this,\"cli.error.missing.required\", getPreferredName());\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n         }\n \n         super.validate(commandLine);\n     }\n \n-    public void appendUsage(\n-        final StringBuffer buffer,\n-        final Set helpSettings,\n-        final Comparator comp) {\n-\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n         // do we display optionality\n         final boolean optional =\n             !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n-        final boolean displayAliases =\n-            helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n-        final boolean disabled =\n-            helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+        final boolean disabled = helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n         final boolean enabled =\n-            !disabled\n-                || helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+            !disabled || helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n         final boolean both = disabled && enabled;\n \n         if (optional) {\n             buffer.append('[');\n         }\n+\n         if (enabled) {\n             buffer.append(enabledPrefix).append(preferredName);\n         }\n+\n         if (both) {\n             buffer.append('|');\n         }\n+\n         if (disabled) {\n             buffer.append(disabledPrefix).append(preferredName);\n         }\n             Collections.sort(list);\n \n             for (final Iterator i = list.iterator(); i.hasNext();) {\n-                final String alias = (String)i.next();\n+                final String alias = (String) i.next();\n \n                 if (enabled) {\n                     buffer.append(enabledPrefix).append(alias);\n                 }\n+\n                 if (both) {\n                     buffer.append('|');\n                 }\n+\n                 if (disabled) {\n                     buffer.append(disabledPrefix).append(alias);\n                 }\n                     buffer.append(',');\n                 }\n             }\n+\n             buffer.append(')');\n         }\n \n     public String getPreferredName() {\n         return enabledPrefix + preferredName;\n     }\n-    \n+\n     public void defaults(final WriteableCommandLine commandLine) {\n         commandLine.setDefaultSwitch(this, defaultSwitch);\n     }\n--- /dev/null\n+++ b/src/java/org/apache/commons/cli2/resource/ResourceConstants.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.resource;\n+\n+public abstract class ResourceConstants {\n+    public static final String CLASSVALIDATOR_BAD_CLASSNAME = \"ClassValidator.bad.classname\";\n+    public static final String CLASSVALIDATOR_CLASS_NOTFOUND = \"ClassValidator.class.notfound\";\n+    public static final String CLASSVALIDATOR_CLASS_ACCESS = \"ClassValidator.class.access\";\n+    public static final String CLASSVALIDATOR_CLASS_CREATE = \"ClassValidator.class.create\";\n+    public static final String DATEVALIDATOR_DATE_OUTOFRANGE = \"DateValidator.date.OutOfRange\";\n+    public static final String URLVALIDATOR_MALFORMED_URL = \"URLValidator.malformed.URL\";\n+    public static final String NUMBERVALIDATOR_NUMBER_OUTOFRANGE =\n+        \"NumberValidator.number.OutOfRange\";\n+    public static final String ARGUMENT_UNEXPECTED_VALUE = \"Argument.unexpected.value\";\n+    public static final String ARGUMENT_MIN_EXCEEDS_MAX = \"Argument.minimum.exceeds.maximum\";\n+    public static final String ARGUMENT_TOO_FEW_DEFAULTS = \"Argument.too.few.defaults\";\n+    public static final String ARGUMENT_TOO_MANY_DEFAULTS = \"Argument.too.many.defaults\";\n+    public static final String ARGUMENT_MISSING_VALUES = \"Argument.missing.values\";\n+    public static final String ARGUMENT_TOO_MANY_VALUES = \"Argument.too.many.values\";\n+    public static final String OPTION_TRIGGER_NEEDS_PREFIX = \"Option.trigger.needs.prefix\";\n+    public static final String OPTION_MISSING_REQUIRED = \"Option.missing.required\";\n+    public static final String OPTION_NO_NAME = \"Option.no.name\";\n+    public static final String OPTION_ILLEGAL_LONG_PREFIX = \"Option.illegal.long.prefix\";\n+    public static final String OPTION_ILLEGAL_SHORT_PREFIX = \"Option.illegal.short.prefix\";\n+    public static final String UNEXPECTED_TOKEN = \"Unexpected.token\";\n+    public static final String MISSING_OPTION = \"Missing.option\";\n+    public static final String CANNOT_BURST = \"Cannot.burst\";\n+    public static final String COMMAND_PREFERRED_NAME_TOO_SHORT = \"Command.preferredName.too.short\";\n+    public static final String SWITCH_ILLEGAL_ENABLED_PREFIX = \"Option.illegal.enabled.prefix\";\n+    public static final String SWITCH_ILLEGAL_DISABLED_PREFIX = \"Option.illegal.disabled.prefix\";\n+    public static final String SWITCH_IDENTICAL_PREFIXES = \"Option.identical.prefixes\";\n+    public static final String SWITCH_ALREADY_SET = \"Switch.already.set\";\n+    public static final String SWITCH_NO_ENABLED_PREFIX = \"Switch.no.enabledPrefix\";\n+    public static final String SWITCH_NO_DISABLED_PREFIX = \"Switch.no.disabledPrefix\";\n+    public static final String SWITCH_ENABLED_STARTS_WITH_DISABLED =\n+        \"Switch.enabled.startsWith.disabled\";\n+    public static final String SWITCH_DISABLED_STARTWS_WITH_ENABLED =\n+        \"Switch.disabled.startsWith.enabled\";\n+    public static final String SWITCH_PREFERRED_NAME_TOO_SHORT = \"Switch.preferredName.too.short\";\n+    public static final String SOURCE_DEST_MUST_ENFORCE_VALUES = \"SourceDest.must.enforce.values\";\n+    public static final String HELPFORMATTER_GUTTER_TOO_LONG = \"HelpFormatter.gutter.too.long\";\n+    public static final String HELPFORMATTER_WIDTH_TOO_NARROW = \"HelpFormatter.width.too.narrow\";\n+    public static final String ENUM_ILLEGAL_VALUE = \"Enum.illegal.value\";\n+}\n--- a/src/java/org/apache/commons/cli2/resource/ResourceHelper.java\n+++ b/src/java/org/apache/commons/cli2/resource/ResourceHelper.java\n package org.apache.commons.cli2.resource;\n \n import java.text.MessageFormat;\n-import java.util.HashMap;\n-import java.util.Map;\n+\n+import java.util.Locale;\n import java.util.MissingResourceException;\n import java.util.ResourceBundle;\n \n  * @author John Keyes\n  */\n public class ResourceHelper {\n+    /** system property */\n+    private static final String PROP_LOCALE = \"org.apache.commons.cli2.resource.bundle\";\n+\n+    /** default package name */\n+    private static final String DEFAULT_BUNDLE =\n+        \"org.apache.commons.cli2.resource.CLIMessageBundle_en_US\";\n+    private static ResourceHelper helper;\n \n     /** resource bundle */\n     private ResourceBundle bundle;\n \n-    /** default bundle name */\n-    private static final String DEFAULT_BUNDLE = \"messages\";\n+    /**\n+     * Create a new ResourceHelper for the specified class.\n+     *\n+     * @param clazz the Class that requires some resources\n+     */\n+    private ResourceHelper() {\n+        String bundleName = System.getProperty(PROP_LOCALE);\n \n-    /** cache */\n-    private static Map cache = new HashMap(13);\n-    \n+        if (bundleName == null) {\n+            bundleName = DEFAULT_BUNDLE;\n+        }\n+\n+        int firstUnderscore = bundleName.indexOf('_');\n+        int secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n+\n+        String language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\n+        String country = bundleName.substring(secondUnderscore + 1);\n+\n+        Locale locale = new Locale(language, country);\n+\n+        // initialize the bundle\n+        try {\n+            bundle = ResourceBundle.getBundle(bundleName, locale);\n+        } catch (MissingResourceException exp) {\n+            bundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n+        }\n+    }\n+\n     /**\n      * Gets the ResourceHelper appropriate to the specified class.\n      * @param clazz the class to get resources for\n      * @return a ResourceHelper\n      */\n-    public static ResourceHelper getResourceHelper(final Class clazz) {\n-\n-        if (cache.containsKey(clazz)) {\n-            return (ResourceHelper)cache.get(clazz);\n+    public static ResourceHelper getResourceHelper() {\n+        if (helper == null) {\n+            helper = new ResourceHelper();\n         }\n \n-        return new ResourceHelper(clazz);\n-    }\n-\n-    /**\n-     * Create a new ResourceHelper for the specified class.\n-     * \n-     * @param clazz the Class that requires some resources\n-     */\n-    private ResourceHelper(final Class clazz) {\n-\n-        // get the name of the class\n-        final String className = clazz.getName();\n-\n-        // discover the package name\n-        final String packageName =\n-            className.substring(0, className.lastIndexOf(\".\") + 1);\n-\n-        final String bundleName = packageName + DEFAULT_BUNDLE;\n-\n-        // initialize the bundle\n-        try {\n-            bundle = ResourceBundle.getBundle(bundleName);\n-        }\n-        catch (MissingResourceException e) {\n-            //TODO Handle missing resources nicely\n-            bundle = null;\n-        }\n-\n-        // cache bundle\n-        cache.put(bundleName, bundle);\n+        return helper;\n     }\n \n     /**\n      * Returns the message for the specified key.\n-     * \n+     *\n      * @param key the unique identifier of the message\n      * @return String the formatted String\n      */\n     public String getMessage(final String key) {\n-        return getMessage(key, new Object[] {});\n+        return getMessage(key, new Object[] {  });\n     }\n \n     /**\n      * Returns the message for the specified key and argument.\n-     * \n+     *\n      * @param key the unique identifier of the message\n      * @param value the argument value\n      * @return String the formatted String\n      */\n-    public String getMessage(final String key, final Object value) {\n+    public String getMessage(final String key,\n+                             final Object value) {\n         return getMessage(key, new Object[] { value });\n     }\n \n     /**\n      * Returns the message for the specified key and arguments.\n-     * \n+     *\n      * @param key the unique identifier of the message\n      * @param value1 an argument value\n      * @param value2 an argument value\n      * @return String the formatted String\n      */\n-    public String getMessage(\n-        final String key,\n-        final Object value1,\n-        final Object value2) {\n-\n+    public String getMessage(final String key,\n+                             final Object value1,\n+                             final Object value2) {\n         return getMessage(key, new Object[] { value1, value2 });\n     }\n \n     /**\n      * Returns the message for the specified key and arguments.\n-     * \n+     *\n      * @param key the unique identifier of the message\n      * @param value1 an argument value\n      * @param value2 an argument value\n      * @param value3 an argument value\n-     * \n+     *\n      * @return String the formatted String\n      */\n-    public String getMessage(\n-        final String key,\n-        final Object value1,\n-        final Object value2,\n-        final Object value3) {\n-\n+    public String getMessage(final String key,\n+                             final Object value1,\n+                             final Object value2,\n+                             final Object value3) {\n         return getMessage(key, new Object[] { value1, value2, value3 });\n     }\n \n     /**\n      * Returns the message for the specified key and arguments.\n-     * \n+     *\n      * @param key the unique identifier of the message\n      * @param values argument values\n      * @return String the formatted String\n      */\n-    public String getMessage(final String key, final Object[] values) {\n+    public String getMessage(final String key,\n+                             final Object[] values) {\n         final String msgFormatStr = bundle.getString(key);\n         final MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n \n--- a/src/java/org/apache/commons/cli2/util/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli2/util/HelpFormatter.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import java.io.IOException;\n import java.io.PrintWriter;\n import java.io.Writer;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n import org.apache.commons.cli2.HelpLine;\n import org.apache.commons.cli2.Option;\n import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * Presents on screen help based on the application's Options\n  */\n public class HelpFormatter {\n-\n     /**\n      * The default screen width\n      */\n      * The default screen furniture left of screen\n      */\n     public static final String DEFAULT_GUTTER_LEFT = \"\";\n-    \n+\n     /**\n      * The default screen furniture right of screen\n      */\n     public static final String DEFAULT_GUTTER_CENTER = \"    \";\n-    \n+\n     /**\n      * The default screen furniture between columns\n      */\n     /**\n      * The default DisplaySettings used to select the elements to display in the\n      * displayed line of full usage information.\n-     * \n+     *\n      * @see DisplaySetting\n      */\n     public static final Set DEFAULT_FULL_USAGE_SETTINGS;\n-    \n-    /**\n-     * The default DisplaySettings used to select the elements of usage per help \n+\n+    /**\n+     * The default DisplaySettings used to select the elements of usage per help\n      * line in the main body of help\n-     * \n+     *\n      * @see DisplaySetting\n      */\n     public static final Set DEFAULT_LINE_USAGE_SETTINGS;\n-    \n+\n     /**\n      * The default DisplaySettings used to select the help lines in the main\n-     * body of help \n+     * body of help\n      */\n     public static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n \n \n         final Set displayUsage = new HashSet(DisplaySetting.ALL);\n         displayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n-        DEFAULT_DISPLAY_USAGE_SETTINGS =\n-            Collections.unmodifiableSet(displayUsage);\n+        DEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n     }\n \n     private Set fullUsageSettings = new HashSet(DEFAULT_FULL_USAGE_SETTINGS);\n     private OptionException exception = null;\n     private Group group;\n     private Comparator comparator = null;\n-\n     private String divider = null;\n-\n     private String header = null;\n     private String footer = null;\n-\n     private String shellCommand = \"\";\n-\n     private PrintWriter out = new PrintWriter(System.out);\n+\n     //or should this default to .err?\n-\n     private final String gutterLeft;\n     private final String gutterCenter;\n     private final String gutterRight;\n-\n     private final int pageWidth;\n \n     /**\n      * Creates a new HelpFormatter using the defaults\n      */\n     public HelpFormatter() {\n-        this(\n-            DEFAULT_GUTTER_LEFT,\n-            DEFAULT_GUTTER_CENTER,\n-            DEFAULT_GUTTER_RIGHT,\n-            DEFAULT_FULL_WIDTH);\n+        this(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n     }\n \n     /**\n      * @param gutterRight the string marking right of screen\n      * @param fullWidth the width of the screen\n      */\n-    public HelpFormatter(\n-        final String gutterLeft,\n-        final String gutterCenter,\n-        final String gutterRight,\n-        final int fullWidth) {\n-        \n+    public HelpFormatter(final String gutterLeft,\n+                         final String gutterCenter,\n+                         final String gutterRight,\n+                         final int fullWidth) {\n         // default the left gutter to empty string\n         this.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n \n \n         // calculate the available page width\n         this.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n-        \n+\n         // check available page width is valid\n-        int availableWidth = fullWidth - pageWidth + this.gutterCenter.length(); \n-        if ( availableWidth < 2 ) {\n-            throw new IllegalArgumentException(\n-                \"The gutter strings leave no space for output! \"\n-                    + \"Supply shorter gutters or more width.\");\n-        }\n-    }\n-    \n+        int availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n+\n+        if (availableWidth < 2) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n+        }\n+    }\n+\n     /**\n      * Prints the Option help.\n      * @throws IOException if an error occurs\n      */\n-    public void print() throws IOException {\n+    public void print()\n+        throws IOException {\n         printHeader();\n         printException();\n         printUsage();\n     }\n \n     /**\n-     * Prints any error message. \n+     * Prints any error message.\n      * @throws IOException if an error occurs\n      */\n-    public void printException() throws IOException {\n+    public void printException()\n+        throws IOException {\n         if (exception != null) {\n             printDivider();\n             printWrapped(exception.getMessage());\n     }\n \n     /**\n-     * Prints detailed help per option. \n+     * Prints detailed help per option.\n      * @throws IOException if an error occurs\n      */\n-    public void printHelp() throws IOException {\n+    public void printHelp()\n+        throws IOException {\n         printDivider();\n \n         final Option option;\n-        if (exception != null && exception.getOption() != null) {\n+\n+        if ((exception != null) && (exception.getOption() != null)) {\n             option = exception.getOption();\n-        }\n-        else {\n+        } else {\n             option = group;\n         }\n \n         // grab the HelpLines to display\n         final List helpLines = option.helpLines(0, displaySettings, comparator);\n-        \n+\n         // calculate the maximum width of the usage strings\n         int usageWidth = 0;\n+\n         for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n-            final HelpLine helpLine = (HelpLine)i.next();\n+            final HelpLine helpLine = (HelpLine) i.next();\n             final String usage = helpLine.usage(lineUsageSettings, comparator);\n             usageWidth = Math.max(usageWidth, usage.length());\n         }\n-        \n+\n         // build a blank string to pad wrapped descriptions\n         final StringBuffer blankBuffer = new StringBuffer();\n+\n         for (int i = 0; i < usageWidth; i++) {\n             blankBuffer.append(' ');\n         }\n-        \n+\n         // determine the width available for descriptions\n-        final int descriptionWidth = Math.max(1,\n-            pageWidth - gutterCenter.length() - usageWidth);\n-        \n+        final int descriptionWidth = Math.max(1, pageWidth - gutterCenter.length() - usageWidth);\n+\n         // display each HelpLine\n         for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n-            \n             // grab the HelpLine\n-            final HelpLine helpLine = (HelpLine)i.next();\n-            \n+            final HelpLine helpLine = (HelpLine) i.next();\n+\n             // wrap the description\n-            final List descList =\n-                wrap(helpLine.getDescription(), descriptionWidth);\n+            final List descList = wrap(helpLine.getDescription(), descriptionWidth);\n             final Iterator descriptionIterator = descList.iterator();\n \n             // display usage + first line of description\n             printGutterLeft();\n             pad(helpLine.usage(lineUsageSettings, comparator), usageWidth, out);\n             out.print(gutterCenter);\n-            pad((String)descriptionIterator.next(), descriptionWidth, out);\n+            pad((String) descriptionIterator.next(), descriptionWidth, out);\n             printGutterRight();\n             out.println();\n \n             // display padding + remaining lines of description\n             while (descriptionIterator.hasNext()) {\n                 printGutterLeft();\n+\n                 //pad(helpLine.getUsage(),usageWidth,out);\n                 out.print(blankBuffer);\n                 out.print(gutterCenter);\n-                pad((String)descriptionIterator.next(), descriptionWidth, out);\n+                pad((String) descriptionIterator.next(), descriptionWidth, out);\n                 printGutterRight();\n                 out.println();\n             }\n         }\n+\n         printDivider();\n     }\n \n     /**\n-     * Prints a single line of usage information (wrapping if necessary) \n+     * Prints a single line of usage information (wrapping if necessary)\n      * @throws IOException if an error occurs\n      */\n-    public void printUsage() throws IOException {\n+    public void printUsage()\n+        throws IOException {\n         printDivider();\n+\n         final StringBuffer buffer = new StringBuffer(\"Usage:\\n\");\n         buffer.append(shellCommand).append(' ');\n         group.appendUsage(buffer, fullUsageSettings, comparator, \" \");\n     }\n \n     /**\n-     * Prints a header string if necessary \n+     * Prints a header string if necessary\n      * @throws IOException if an error occurs\n      */\n-    public void printHeader() throws IOException {\n+    public void printHeader()\n+        throws IOException {\n         if (header != null) {\n             printDivider();\n             printWrapped(header);\n     }\n \n     /**\n-     * Prints a footer string if necessary \n+     * Prints a footer string if necessary\n      * @throws IOException if an error occurs\n      */\n-    public void printFooter() throws IOException {\n+    public void printFooter()\n+        throws IOException {\n         if (footer != null) {\n             printWrapped(footer);\n             printDivider();\n \n     /**\n      * Prints a string wrapped if necessary\n-     * @param text the string to wrap \n+     * @param text the string to wrap\n      * @throws IOException if an error occurs\n      */\n     protected void printWrapped(final String text)\n         throws IOException {\n-        for (final Iterator i = wrap(text, pageWidth).iterator();\n-            i.hasNext();\n-            ) {\n+        for (final Iterator i = wrap(text, pageWidth).iterator(); i.hasNext();) {\n             printGutterLeft();\n-            pad((String)i.next(), pageWidth, out);\n+            pad((String) i.next(), pageWidth, out);\n             printGutterRight();\n             out.println();\n         }\n     }\n \n     /**\n-     * Prints the left gutter string \n+     * Prints the left gutter string\n      */\n     public void printGutterLeft() {\n         if (gutterLeft != null) {\n     }\n \n     /**\n-     * Prints the right gutter string \n+     * Prints the right gutter string\n      */\n     public void printGutterRight() {\n         if (gutterRight != null) {\n         }\n     }\n \n-    protected static void pad(\n-        final String text,\n-        final int width,\n-        final Writer writer)\n+    protected static void pad(final String text,\n+                              final int width,\n+                              final Writer writer)\n         throws IOException {\n         final int left;\n-        \n+\n         // write the text and record how many characters written\n         if (text == null) {\n             left = 0;\n-        }\n-        else {\n+        } else {\n             writer.write(text);\n             left = text.length();\n         }\n         }\n     }\n \n-    protected static List wrap(final String text, final int width) {\n-        \n+    protected static List wrap(final String text,\n+                               final int width) {\n         // check for valid width\n-        if(width<1){\n-            throw new IllegalArgumentException(\"width must be positive\");\n-        }\n-        \n+        if (width < 1) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,\n+                                                                                             new Object[] {\n+                                                                                                 new Integer(width)\n+                                                                                             }));\n+        }\n+\n         // handle degenerate case\n         if (text == null) {\n             return Collections.singletonList(\"\");\n         while (left < chars.length) {\n             // sync left and right indeces\n             int right = left;\n-            \n+\n             // move right until we run out of characters, width or find a newline\n-            while (right < chars.length && chars[right] != '\\n' && right<left+width+1) {\n+            while ((right < chars.length) && (chars[right] != '\\n') &&\n+                       (right < (left + width + 1))) {\n                 right++;\n             }\n-            \n+\n             // if a newline was found\n-            if (right<chars.length && chars[right] == '\\n') {\n+            if ((right < chars.length) && (chars[right] == '\\n')) {\n                 // record the substring\n                 final String line = new String(chars, left, right - left);\n                 lines.add(line);\n+\n                 // move to the end of the substring\n                 left = right + 1;\n+\n                 if (left == chars.length) {\n                     lines.add(\"\");\n                 }\n+\n                 // restart the loop\n                 continue;\n             }\n-            \n+\n             // move to the next ideal wrap point \n-            right = left + width - 1;\n-            \n+            right = (left + width) - 1;\n+\n             // if we have run out of characters\n             if (chars.length <= right) {\n                 // record the substring\n-                final String line =\n-                    new String(chars, left, chars.length - left);\n+                final String line = new String(chars, left, chars.length - left);\n                 lines.add(line);\n-                \n+\n                 // abort the loop\n                 break;\n             }\n-            \n+\n             // back track the substring end until a space is found\n-            while (right >= left && chars[right] != ' ') {\n+            while ((right >= left) && (chars[right] != ' ')) {\n                 right--;\n             }\n \n                 // record the substring to space\n                 final String line = new String(chars, left, right - left);\n                 lines.add(line);\n-                \n+\n                 // absorb all the spaces before next substring\n-                while (right < chars.length && chars[right] == ' ') {\n+                while ((right < chars.length) && (chars[right] == ' ')) {\n                     right++;\n                 }\n+\n                 left = right;\n-                \n+\n                 // restart the loop\n                 continue;\n             }\n \n             // move to the wrap position irrespective of spaces\n             right = Math.min(left + width, chars.length);\n-            \n+\n             // record the substring\n             final String line = new String(chars, left, right - left);\n             lines.add(line);\n-            \n+\n             // absorb any the spaces before next substring\n-            while (right < chars.length && chars[right] == ' ') {\n+            while ((right < chars.length) && (chars[right] == ' ')) {\n                 right++;\n             }\n+\n             left = right;\n         }\n \n     public void setComparator(Comparator comparator) {\n         this.comparator = comparator;\n     }\n-    \n+\n     /**\n      * The DisplaySettings used to select the help lines in the main body of\n      * help\n-     * \n+     *\n      * @param displaySettings the settings to use\n      * @see DisplaySetting\n      */\n     public void setDivider(String divider) {\n         this.divider = divider;\n     }\n-    \n+\n     /**\n      * Sets the exception to document\n      * @param exception the exception that occured\n \n     /**\n      * The DisplaySettings used to select the elements to display in the\n-     * displayed line of full usage information. \n+     * displayed line of full usage information.\n      * @see DisplaySetting\n      * @param fullUsageSettings\n      */\n     }\n \n     /**\n-     * Sets the DisplaySettings used to select elements in the per helpline \n+     * Sets the DisplaySettings used to select elements in the per helpline\n      * usage strings.\n      * @see DisplaySetting\n      * @param lineUsageSettings the DisplaySettings to use\n     }\n \n     /**\n-     * @return the command used to execute the application  \n+     * @return the command used to execute the application\n      */\n     public String getShellCommand() {\n         return shellCommand;\n--- a/src/java/org/apache/commons/cli2/validation/ClassValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/ClassValidator.java\n import java.util.List;\n import java.util.ListIterator;\n \n+import org.apache.commons.cli2.resource.ResourceConstants;\n import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * validator.setInstance(true);\n  *\n  * ArgumentBuilder builder = new ArgumentBuilder();\n- * Argument logger = \n+ * Argument logger =\n  *     builder.withName(\"logger\");\n  *            .withValidator(validator);\n  * </pre>\n- * \n+ *\n  * @author John Keyes\n  */\n public class ClassValidator implements Validator {\n-\n     /** i18n */\n-    private static final ResourceHelper resources =\n-        ResourceHelper.getResourceHelper(ClassValidator.class);\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n \n     /** whether the class argument is loadable */\n     private boolean loadable;\n-    \n+\n     /** whether to create an instance of the class */\n     private boolean instance;\n \n     /**\n      * Validate each argument value in the specified List against this instances\n      * permitted attributes.\n-     * \n+     *\n      * If a value is valid then it's <code>String</code> value in the list is\n      * replaced with it's <code>Class</code> value or instance.\n-     * \n+     *\n      * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n      */\n-    public void validate(final List values) throws InvalidArgumentException {\n-\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n         for (final ListIterator i = values.listIterator(); i.hasNext();) {\n-            final String name = (String)i.next();\n+            final String name = (String) i.next();\n \n             if (!isPotentialClassName(name)) {\n-                throw new InvalidArgumentException(\n-                    resources.getMessage(\n-                        \"ClassValidator.error.bad.classname\",\n-                        name));\n+                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_BAD_CLASSNAME,\n+                                                                        name));\n             }\n \n             if (loadable || instance) {\n                 final ClassLoader theLoader = getClassLoader();\n+\n                 try {\n                     final Class clazz = theLoader.loadClass(name);\n+\n                     if (instance) {\n                         i.set(clazz.newInstance());\n-                    }\n-                    else {\n+                    } else {\n                         i.set(clazz);\n                     }\n-                }\n-                catch (final ClassNotFoundException exp) {\n-                    throw new InvalidArgumentException(\n-                        resources.getMessage(\n-                            \"ClassValidator.error.class.notfound\",\n-                            name));\n-                }\n-                catch (final IllegalAccessException exp) {\n-                    throw new InvalidArgumentException(\n-                        resources.getMessage(\n-                            \"ClassValidator.error.class.access\",\n-                            name,\n-                            exp.getMessage()));\n-                }\n-                catch (final InstantiationException exp) {\n-                    throw new InvalidArgumentException(\n-                        resources.getMessage(\n-                            \"ClassValidator.error.class.create\",\n-                            name));\n+                } catch (final ClassNotFoundException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_NOTFOUND,\n+                                                                            name));\n+                } catch (final IllegalAccessException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_ACCESS,\n+                                                                            name, exp.getMessage()));\n+                } catch (final InstantiationException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_CREATE,\n+                                                                            name));\n                 }\n             }\n         }\n      * Specifies whether the argument value must represent a\n      * class that is loadable.\n      *\n-     * @param loadable whether the argument value must \n+     * @param loadable whether the argument value must\n      * represent a class that is loadable.\n      */\n     public void setLoadable(boolean loadable) {\n         if (loader == null) {\n             loader = getClass().getClassLoader();\n         }\n-        \n+\n         return loader;\n     }\n \n      * Specifies whether the argument value must represent a\n      * class that can be instantiated.\n      *\n-     * @param instance whether the argument value must \n+     * @param instance whether the argument value must\n      * represent a class that can be instantiated.\n      */\n     public void setInstance(boolean instance) {\n \n         for (int i = 0; i < chars.length; ++i) {\n             final char c = chars[i];\n+\n             if (expectingStart) {\n                 if (!Character.isJavaIdentifierStart(c)) {\n                     return false;\n                 }\n+\n                 expectingStart = false;\n-            }\n-            else {\n+            } else {\n                 if (c == '.') {\n                     expectingStart = true;\n-                }\n-                else if (!Character.isJavaIdentifierPart(c)) {\n+                } else if (!Character.isJavaIdentifierPart(c)) {\n                     return false;\n                 }\n             }\n         }\n+\n         return !expectingStart;\n     }\n-\n }\n--- a/src/java/org/apache/commons/cli2/validation/DateValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/DateValidator.java\n \n import java.text.DateFormat;\n import java.text.ParsePosition;\n+\n import java.util.Date;\n import java.util.List;\n import java.util.ListIterator;\n \n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n /**\n  * The <code>DateValidator</code> validates the argument values\n  * are date or time value(s).\n  *\n  * The following example shows how to validate that\n- * an argument value(s) is a Date of the following \n+ * an argument value(s) is a Date of the following\n  * type: d/M/yy (see {@link java.text.DateFormat}).\n  *\n  * <pre>\n  * DateFormat date = new SimpleDateFormat(\"d/M/yy\");\n  * ...\n  * ArgumentBuilder builder = new ArgumentBuilder();\n- * Argument dateFormat = \n+ * Argument dateFormat =\n  *     builder.withName(\"date\");\n  *            .withValidator(new DateValidator(dateFormat));\n  * </pre>\n  *\n  * The following example shows how to validate that\n- * an argument value(s) is a time of the following \n+ * an argument value(s) is a time of the following\n  * type: HH:mm:ss (see {@link java.text.DateFormat}).\n  *\n  * <pre>\n  * DateFormat timeFormat = new SimpleDateFormat(\"HH:mm:ss\");\n  * ...\n  * ArgumentBuilder builder = new ArgumentBuilder();\n- * Argument time = \n+ * Argument time =\n  *     builder.withName(\"time\");\n  *            .withValidator(new DateValidator(timeFormat));\n  * </pre>\n- * \n+ *\n  * @author John Keyes\n  *\n  * @see java.text.DateFormat\n  */\n public class DateValidator implements Validator {\n+    /** i18n */\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n \n     /** an array of permitted DateFormats */\n     private DateFormat[] formats;\n     private Date maximum;\n \n     /**\n+     * Creates a Validator for the default date/time format\n+     */\n+    public DateValidator() {\n+        this(DateFormat.getInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for the specified DateFormat.\n+     *\n+     * @param format\n+     *            a DateFormat which dates must conform to\n+     */\n+    public DateValidator(final DateFormat format) {\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Creates a Validator for the List of specified DateFormats.\n+     *\n+     * @param formats\n+     *            a List of DateFormats which dates must conform to\n+     */\n+    public DateValidator(final List formats) {\n+        setFormats(formats);\n+    }\n+\n+    /**\n      * Creates a Validator for dates.\n-     * \n+     *\n      * @return DateValidator a Validator for dates\n      */\n     public static DateValidator getDateInstance() {\n \n     /**\n      * Creates a Validator for times.\n-     * \n+     *\n      * @return DateValidator a Validator for times\n      */\n     public static DateValidator getTimeInstance() {\n \n     /**\n      * Creates a Validator for date/times\n-     * \n+     *\n      * @return DateValidator a Validator for date/times\n      */\n     public static DateValidator getDateTimeInstance() {\n     }\n \n     /**\n-     * Creates a Validator for the default date/time format\n-     */\n-    public DateValidator() {\n-        this(DateFormat.getInstance());\n-    }\n-\n-    /**\n-     * Creates a Validator for the specified DateFormat.\n-     * \n-     * @param format\n-     *            a DateFormat which dates must conform to\n-     */\n-    public DateValidator(final DateFormat format) {\n-        setFormat(format);\n-    }\n-\n-    /**\n-     * Creates a Validator for the List of specified DateFormats.\n-     * \n-     * @param formats\n-     *            a List of DateFormats which dates must conform to\n-     */\n-    public DateValidator(final List formats) {\n-    \tsetFormats(formats);\n-    }\n-\n-    /**\n      * Validate each String value in the specified List against this instances\n      * permitted DateFormats.\n-     * \n+     *\n      * If a value is valid then it's <code>String</code> value in the list is\n      * replaced with it's <code>Date</code> value.\n-     * \n+     *\n      * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n      */\n-    public void validate(final List values) throws InvalidArgumentException {\n-\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n         // for each value\n         for (final ListIterator i = values.listIterator(); i.hasNext();) {\n-\n-            final String value = (String)i.next();\n+            final String value = (String) i.next();\n \n             Date date = null;\n \n             final ParsePosition pp = new ParsePosition(0);\n \n             // for each permitted DateFormat\n-            for (int f = 0; f < this.formats.length && date == null; ++f) {\n-\n+            for (int f = 0; (f < this.formats.length) && (date == null); ++f) {\n                 // reset the parse position\n                 pp.setIndex(0);\n \n \n             // if the date is outside the bounds\n             if (isDateEarlier(date) || isDateLater(date)) {\n-                throw new InvalidArgumentException(\"Out of range: \" + value);\n+                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                                                                        value));\n             }\n \n             // replace the value in the list with the actual Date\n \n     /**\n      * Returns the maximum date permitted.\n-     * \n+     *\n      * @return Date the maximum date permitted. If no maximum date has been\n      *         specified then return <code>null</code>.\n      */\n \n     /**\n      * Sets the maximum Date to the specified value.\n-     * \n+     *\n      * @param maximum\n      *            the maximum Date permitted\n      */\n \n     /**\n      * Returns the minimum date permitted.\n-     * \n+     *\n      * @return Date the minimum date permitted. If no minimum date has been\n      *         specified then return <code>null</code>.\n      */\n \n     /**\n      * Sets the minimum Date to the specified value.\n-     * \n+     *\n      * @param minimum\n      *            the minimum Date permitted\n      */\n \n     /**\n      * Returns whether the specified Date is later than the maximum date.\n-     * \n+     *\n      * @param date\n      *            the Date to evaluate\n-     * \n+     *\n      * @return boolean whether <code>date</code> is earlier than the maximum\n      *         date\n      */\n     private boolean isDateLater(Date date) {\n-        return maximum != null && date.getTime() > maximum.getTime();\n+        return (maximum != null) && (date.getTime() > maximum.getTime());\n     }\n \n     /**\n      * Returns whether the specified Date is earlier than the minimum date.\n-     * \n+     *\n      * @param date\n      *            the Date to evaluate\n-     * \n+     *\n      * @return boolean whether <code>date</code> is earlier than the minimum\n      *         date\n      */\n     private boolean isDateEarlier(Date date) {\n-        return minimum != null && date.getTime() < minimum.getTime();\n-    }\n-    \n+        return (minimum != null) && (date.getTime() < minimum.getTime());\n+    }\n+\n     /**\n      * Sets the date format permitted.\n-     * \n-     * @param format \n+     *\n+     * @param format\n      *              the format to use\n      */\n     public void setFormat(final DateFormat format) {\n-    \tsetFormats(new DateFormat[]{format});\n-    }\n-    \n+        setFormats(new DateFormat[] { format });\n+    }\n+\n     /**\n      * Sets the date formats permitted.\n-     * \n-     * @param formats \n+     *\n+     * @param formats\n      *               the List of DateFormats to use\n      */\n     public void setFormats(final List formats) {\n-    \tsetFormats((DateFormat[])formats.toArray(new DateFormat[formats.size()]));\n-    }\n-    \n+        setFormats((DateFormat[]) formats.toArray(new DateFormat[formats.size()]));\n+    }\n+\n     /**\n      * Sets the date formats permitted.\n-     * \n-     * @param formats \n+     *\n+     * @param formats\n      *               the array of DateFormats to use\n      */\n     public void setFormats(final DateFormat[] formats) {\n-    \tthis.formats = formats;\n-    }\n-    \n+        this.formats = formats;\n+    }\n+\n     /**\n      * Gets the date formats permitted.\n      *\n      * @return the permitted formats\n      */\n     public DateFormat[] getFormats() {\n-    \treturn this.formats;\n-    }\n-    \n+        return this.formats;\n+    }\n }\n--- a/src/java/org/apache/commons/cli2/validation/EnumValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/EnumValidator.java\n import java.util.List;\n import java.util.Set;\n \n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n /**\n  * The <code>EnumValidator</code> validates the string argument\n  * values are valid.\n  * values.add(\"blue\");\n  * ...\n  * ArgumentBuilder builder = new ArgumentBuilder();\n- * Argument color = \n+ * Argument color =\n  *     builder.withName(\"color\");\n  *            .withValidator(new EnumValidator(values));\n  * </pre>\n- * \n+ *\n  * @author John Keyes\n  */\n public class EnumValidator implements Validator {\n-\n     /** List of permitted values */\n     private Set validValues;\n \n     /**\n      * Creates a new EnumValidator for the specified values.\n-     * \n+     *\n      * @param values The list of permitted values\n      */\n     public EnumValidator(final Set values) {\n \n     /**\n      * Validate the list of values against the list of permitted values.\n-     * \n+     *\n      * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n      */\n-    public void validate(final List values) throws InvalidArgumentException {\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n         for (final Iterator iter = values.iterator(); iter.hasNext();) {\n-            final String value = (String)iter.next();\n+            final String value = (String) iter.next();\n \n             if (!this.validValues.contains(value)) {\n-                throw new InvalidArgumentException(\n-                    \"'\"\n-                        + value\n-                        + \"' is not allowed.  Permitted values are:\"\n-                        + getValuesAsString());\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,\n+                                                                                                 new Object[] {\n+                                                                                                     value,\n+                                                                                                     getValuesAsString()\n+                                                                                                 }));\n             }\n         }\n     }\n \n     /**\n      * Returns the permitted values in a comma separated String\n-     * \n+     *\n      * @return String formatted list of values\n      */\n-    private String getValuesAsString() {\n+    String getValuesAsString() {\n         final StringBuffer buff = new StringBuffer();\n \n         buff.append(\"[\");\n \n-        for (final Iterator iter = this.validValues.iterator();\n-            iter.hasNext();\n-            ) {\n-\n+        for (final Iterator iter = this.validValues.iterator(); iter.hasNext();) {\n             buff.append(\"'\").append(iter.next()).append(\"'\");\n \n             if (iter.hasNext()) {\n--- a/src/java/org/apache/commons/cli2/validation/NumberValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/NumberValidator.java\n \n import java.text.NumberFormat;\n import java.text.ParsePosition;\n+\n import java.util.List;\n import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * The <code>NumberValidator</code> validates the string argument\n  * the {@link java.util.List} of values is replaced with the\n  * {@link java.lang.Number} instance.\n  *\n- * A maximum and minimum value can also be specified using \n- * the {@link #setMaximum setMaximum}, and the \n+ * A maximum and minimum value can also be specified using\n+ * the {@link #setMaximum setMaximum}, and the\n  * {@link #setMinimum setMinimum} methods.\n  *\n  * The following example shows how to limit the valid values\n  * ArgumentBuilder builder = new ArgumentBuilder();\n  * NumberValidator validator = NumberValidator.getIntegerInstance();\n  * validator.setMaximum(new Integer(100));\n- * \n- * Argument age = \n+ *\n+ * Argument age =\n  *     builder.withName(\"age\");\n  *            .withValidator(validator);\n  * </pre>\n- * \n+ *\n  * @author Rob Oxspring\n  * @author John Keyes\n  */\n public class NumberValidator implements Validator {\n-\n-    /**\n-     * Returns a <code>NumberValidator</code> for a currency format \n-     * for the current default locale.\n-     * @return a <code>NumberValidator</code> for a currency format \n-     * for the current default locale.\n-     */\n-    public static NumberValidator getCurrencyInstance() {\n-        return new NumberValidator(NumberFormat.getCurrencyInstance());\n-    }\n-\n-    /**\n-     * Returns a <code>NumberValidator</code> for an integer number format \n-     * for the current default locale.\n-     * @return a <code>NumberValidator</code> for an integer number format \n-     * for the current default locale.\n-     */\n-    public static NumberValidator getIntegerInstance() {\n-        final NumberFormat format = NumberFormat.getNumberInstance();\n-        format.setParseIntegerOnly(true);\n-        return new NumberValidator(format);\n-    }\n-\n-    /**\n-     * Returns a <code>NumberValidator</code> for a percentage format \n-     * for the current default locale.\n-     * @return a <code>NumberValidator</code> for a percentage format \n-     * for the current default locale.\n-     */\n-    public static NumberValidator getPercentInstance() {\n-        return new NumberValidator(NumberFormat.getPercentInstance());\n-    }\n-\n-    /**\n-     * Returns a <code>NumberValidator</code> for a general-purpose \n-     * number format for the current default locale.\n-     * @return a <code>NumberValidator</code> for a general-purpose \n-     * number format for the current default locale.\n-     */\n-    public static NumberValidator getNumberInstance() {\n-        return new NumberValidator(NumberFormat.getNumberInstance());\n-    }\n-\n     /** the <code>NumberFormat</code> being used. */\n     private NumberFormat format;\n \n     /** the lower bound for argument values. */\n     private Number minimum = null;\n-    \n+\n     /** the upper bound for argument values */\n     private Number maximum = null;\n \n     }\n \n     /**\n+     * Returns a <code>NumberValidator</code> for a currency format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for a currency format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getCurrencyInstance() {\n+        return new NumberValidator(NumberFormat.getCurrencyInstance());\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for an integer number format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for an integer number format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getIntegerInstance() {\n+        final NumberFormat format = NumberFormat.getNumberInstance();\n+        format.setParseIntegerOnly(true);\n+\n+        return new NumberValidator(format);\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for a percentage format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for a percentage format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getPercentInstance() {\n+        return new NumberValidator(NumberFormat.getPercentInstance());\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for a general-purpose\n+     * number format for the current default locale.\n+     * @return a <code>NumberValidator</code> for a general-purpose\n+     * number format for the current default locale.\n+     */\n+    public static NumberValidator getNumberInstance() {\n+        return new NumberValidator(NumberFormat.getNumberInstance());\n+    }\n+\n+    /**\n      * Validate the list of values against the list of permitted values.\n      * If a value is valid, replace the string in the <code>values</code>\n      * {@link java.util.List} with the {@link java.lang.Number} instance.\n-     * \n+     *\n      * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n      */\n-    public void validate(final List values) throws InvalidArgumentException {\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n         for (final ListIterator i = values.listIterator(); i.hasNext();) {\n             final String value = (String) i.next();\n \n             final ParsePosition pp = new ParsePosition(0);\n             final Number number = format.parse(value, pp);\n+\n             if (pp.getIndex() < value.length()) {\n                 throw new InvalidArgumentException(value);\n             }\n \n-            if ((minimum != null\n-                && number.doubleValue() < minimum.doubleValue())\n-                || (maximum != null\n-                    && number.doubleValue() > maximum.doubleValue())) {\n-                throw new InvalidArgumentException(\"Out of range: \" + value);\n+            if (((minimum != null) && (number.doubleValue() < minimum.doubleValue())) ||\n+                    ((maximum != null) && (number.doubleValue() > maximum.doubleValue()))) {\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                                                                                 new Object[] {\n+                                                                                                     value\n+                                                                                                 }));\n             }\n \n             i.set(number);\n     protected void setFormat(NumberFormat format) {\n         this.format = format;\n     }\n-    \n+\n     /**\n      * Return the maximum value allowed for an argument value.\n      *\n--- a/src/java/org/apache/commons/cli2/validation/UrlValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/UrlValidator.java\n \n import java.net.MalformedURLException;\n import java.net.URL;\n+\n import java.util.List;\n import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * The <code>UrlValidator</code> validates the string argument\n  * the {@link java.util.List} of values is replaced with the\n  * {@link java.net.URL} instance.\n  *\n- * URLs can also be validated based on their scheme by using \n+ * URLs can also be validated based on their scheme by using\n  * the {@link #setProtocol setProtocol} method, or by using the specified\n  * {@link #UrlValidator(java.lang.String) constructor}.\n  *\n  * <pre>\n  * ...\n  * ArgumentBuilder builder = new ArgumentBuilder();\n- * Argument site = \n+ * Argument site =\n  *     builder.withName(\"site\");\n  *            .withValidator(new URLValidator(\"https\"));\n  * </pre>\n- * \n+ *\n  * @author Rob Oxspring\n  * @author John Keyes\n  */\n public class UrlValidator implements Validator {\n-\n     /** allowed protocol */\n     private String protocol = null;\n \n      * Validate the list of values against the list of permitted values.\n      * If a value is valid, replace the string in the <code>values</code>\n      * {@link java.util.List} with the { java.net.URL} instance.\n-     * \n+     *\n      * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n      */\n-    public void validate(final List values) throws InvalidArgumentException {\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n         for (final ListIterator i = values.listIterator(); i.hasNext();) {\n-            final String name = (String)i.next();\n+            final String name = (String) i.next();\n+\n             try {\n                 final URL url = new URL(name);\n \n-                if (protocol != null && !protocol.equals(url.getProtocol())) {\n+                if ((protocol != null) && !protocol.equals(url.getProtocol())) {\n                     throw new InvalidArgumentException(name);\n                 }\n \n                 i.set(url);\n-            }\n-            catch (final MalformedURLException mue) {\n-                throw new InvalidArgumentException(\n-                    \"Cannot understand url: \" + name);\n+            } catch (final MalformedURLException mue) {\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,\n+                                                                                                 new Object[] {\n+                                                                                                     name\n+                                                                                                 }));\n             }\n         }\n     }\n     public void setProtocol(String protocol) {\n         this.protocol = protocol;\n     }\n-\n }\n--- a/src/test/org/apache/commons/cli2/CommandLineTestCase.java\n+++ b/src/test/org/apache/commons/cli2/CommandLineTestCase.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.option.OptionTestCase;\n import org.apache.commons.cli2.option.PropertyOption;\n import org.apache.commons.cli2.option.SwitchTest;\n-\n-public abstract class CommandLineTestCase extends CLITestCase {\n-\t\n-\tprotected abstract CommandLine createCommandLine();\n-\t\n-\tpublic final Option present = new DefaultOptionBuilder().withLongName(\"present\").withLongName(\"alsopresent\").create();\n-\tpublic final Option missing = new DefaultOptionBuilder().withLongName(\"missing\").create();\n-\tpublic final Option multiple = new DefaultOptionBuilder().withLongName(\"multiple\").create();\n-\tpublic final Option bool = new DefaultOptionBuilder().withLongName(\"bool\").create();\n-\t\n-\tpublic final Option root = new GroupBuilder().withOption(present).withOption(missing).withOption(multiple).withOption(bool).create();\n-\t\n-\tprivate CommandLine commandLine;\n-\t\n-\t/*\n-\t * @see TestCase#setUp()\n-\t */\n-\tpublic void setUp() throws Exception {\n-\t\tsuper.setUp();\n-\t\tcommandLine = createCommandLine();\n-\t}\n-\t/*\n-\t * Class to test for boolean hasOption(String)\n-\t */\n-\tpublic final void testHasOptionString() {\n-\t\tassertTrue(commandLine.hasOption(\"--present\"));\n-\t\tassertTrue(commandLine.hasOption(\"--alsopresent\"));\n-\t\tassertFalse(commandLine.hasOption(\"--missing\"));\n-\t}\n-\t\n-\t/*\n-\t * Class to test for boolean hasOption(Option)\n-\t */\n-\tpublic final void testHasOptionOption() {\n-\t\tassertTrue(commandLine.hasOption(present));\n-\t\tassertFalse(commandLine.hasOption(missing));\n-\t}\n-\tpublic final void testGetOption() {\n-\t\tassertSame(present,commandLine.getOption(\"--present\"));\n-\t\tassertSame(present,commandLine.getOption(\"--alsopresent\"));\n-\t\t//TODO decide whether the following assertion is valid\n-\t\t//assertSame(missing,commandLine.getOption(\"--missing\"));\n-\t}\n-\t/*\n-\t * Class to test for List getValues(String)\n-\t */\n-\tpublic final void testGetValuesString() {\n-\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--present\"));\n-\t\tassertListContentsEqual(list(\"value 1\",\"value 2\",\"value 3\"),commandLine.getValues(\"--multiple\"));\n-\t\tassertTrue(commandLine.getValues(\"--missing\").isEmpty());\n-\t}\n-\t/*\n-\t * Class to test for List getValues(String, List)\n-\t */\n-\tpublic final void testGetValuesStringList() {\n-\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--present\",null));\n-\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(\"--alsopresent\",null));\n-\t\tassertSame(commandLine.getValues(\"--missing\",Collections.EMPTY_LIST),Collections.EMPTY_LIST);\n-\t\tfinal List def = Collections.singletonList(\"default value\");\n-\t\tassertSame(def,commandLine.getValues(\"--missing\",def));\n-\t}\n-\t/*\n-\t * Class to test for List getValues(Option)\n-\t */\n-\tpublic final void testGetValuesOption() {\n-\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(present));\n-\t\tassertTrue(commandLine.getValues(missing).isEmpty());\n-\t}\n-\t/*\n-\t * Class to test for List getValues(Option, List)\n-\t */\n-\tpublic final void testGetValuesOptionList() {\n-\t\tassertListContentsEqual(list(\"present value\"),commandLine.getValues(present));\n-\t\tassertSame(commandLine.getValues(missing,Collections.EMPTY_LIST),Collections.EMPTY_LIST);\n-\t\tfinal List defs = Collections.singletonList(\"custom default\");\n-\t\tassertSame(defs,commandLine.getValues(missing,defs));\n-\t}\n-\t/*\n-\t * Class to test for Object getValue(String)\n-\t */\n-\tpublic final void testGetValueString() {\n-\t\tassertEquals(\"present value\",commandLine.getValue(\"--present\"));\n-\t\tassertEquals(\"present value\",commandLine.getValue(\"--alsopresent\"));\n-\t\tassertNull(commandLine.getValue(\"--missing\"));\n-\t\ttry{\n-\t\t\tcommandLine.getValue(\"--multiple\");\n-\t\t\tfail(\"expected IllegalStateException\");\n-\t\t}\n-\t\tcatch(IllegalStateException e){\n-\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n-\t\t}\n-\t}\n-\t/*\n-\t * Class to test for Object getValue(String, Object)\n-\t */\n-\tpublic final void testGetValueStringObject() {\n-\t\tassertEquals(\"present value\",commandLine.getValue(\"--present\",\"default value\"));\n-\t\tassertEquals(\"present value\",commandLine.getValue(\"--alsopresent\",\"default value\"));\n-\t\tassertEquals(\"default value\",commandLine.getValue(\"--missing\",\"default value\"));\n-\t\ttry{\n-\t\t\tcommandLine.getValue(\"--multiple\");\n-\t\t\tfail(\"expected IllegalStateException\");\n-\t\t}\n-\t\tcatch(IllegalStateException e){\n-\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n-\t\t}\n-\t}\n-\t/*\n-\t * Class to test for Object getValue(Option)\n-\t */\n-\tpublic final void testGetValueOption() {\n-\t\tassertEquals(\"present value\",commandLine.getValue(present));\n-\t\tassertNull(commandLine.getValue(missing));\n-\t\ttry{\n-\t\t\tcommandLine.getValue(multiple);\n-\t\t\tfail(\"expected IllegalStateException\");\n-\t\t}\n-\t\tcatch(IllegalStateException e){\n-\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n-\t\t}\n-\t}\n-\t/*\n-\t * Class to test for Object getValue(Option, Object)\n-\t */\n-\tpublic final void testGetValueOptionObject() {\n-\t\tassertEquals(\"present value\",commandLine.getValue(present,\"default value\"));\n-\t\tassertEquals(\"default value\",commandLine.getValue(missing,\"default value\"));\n-\t\ttry{\n-\t\t\tcommandLine.getValue(multiple);\n-\t\t\tfail(\"expected IllegalStateException\");\n-\t\t}\n-\t\tcatch(IllegalStateException e){\n-\t\t\tassertEquals(\"More than one value was supplied\",e.getMessage());\n-\t\t}\n-\t}\n-\t/*\n-\t * Class to test for Boolean getSwitch(String)\n-\t */\n-\tpublic final void testGetSwitchString() {\n-\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(\"--bool\"));\n-\t\tassertNull(commandLine.getSwitch(\"--missing\"));\n-\t}\n-\t/*\n-\t * Class to test for Boolean getSwitch(String, Boolean)\n-\t */\n-\tpublic final void testGetSwitchStringBoolean() {\n-\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(\"--bool\",Boolean.FALSE));\n-\t\tassertEquals(Boolean.FALSE,commandLine.getSwitch(\"--missing\",Boolean.FALSE));\n-\t}\n-\t/*\n-\t * Class to test for Boolean getSwitch(Option)\n-\t */\n-\tpublic final void testGetSwitchOption() {\n-\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(bool));\n-\t\tassertNull(commandLine.getSwitch(missing));\n-\t}\n-\t/*\n-\t * Class to test for Boolean getSwitch(Option, Boolean)\n-\t */\n-\tpublic final void testGetSwitchOptionBoolean() {\n-\t\tassertEquals(Boolean.TRUE,commandLine.getSwitch(bool,Boolean.FALSE));\n-\t\tassertEquals(Boolean.FALSE,commandLine.getSwitch(missing,Boolean.FALSE));\n-\t}\n-\t/*\n-\t * Class to test for String getProperty(String)\n-\t */\n-\tpublic final void testGetPropertyString() {\n-\t\tassertEquals(\"present property\",commandLine.getProperty(\"present\"));\n-\t\tassertNull(commandLine.getProperty(\"missing\"));\n-\t}\n-\t/*\n-\t * Class to test for String getProperty(String, String)\n-\t */\n-\tpublic final void testGetPropertyStringString() {\n-\t\tassertEquals(\"present property\",commandLine.getProperty(\"present\",\"default property\"));\n-\t\tassertEquals(\"default property\",commandLine.getProperty(\"missing\",\"default property\"));\n-\t}\n-\tpublic final void testGetProperties() {\n-\t\tassertTrue(commandLine.getProperties().containsAll(list(\"present\")));\n-\t}\n-\t/*\n-\t * Class to test for int getOptionCount(String)\n-\t */\n-\tpublic final void testGetOptionCountString() {\n-\t\t// one option, one switch\n-\t\tassertTrue(1<=commandLine.getOptionCount(\"--present\"));\n-\t\tassertTrue(1<=commandLine.getOptionCount(\"--bool\"));\n-\t\tassertEquals(0,commandLine.getOptionCount(\"--missing\"));\n-\t}\n-\t/*\n-\t * Class to test for int getOptionCount(Option)\n-\t */\n-\tpublic final void testGetOptionCountOption() {\n-\t\t// one option, one switch\n-\t\tassertTrue(1<=commandLine.getOptionCount(present));\n-\t\tassertTrue(1<=commandLine.getOptionCount(bool));\n-\t\tassertEquals(0,commandLine.getOptionCount(missing));\n-\t}\n-\tpublic final void testGetOptions() {\n-\t\t//TODO Implement getOptions().\n-\t}\n-\tpublic final void testGetOptionTriggers() {\n-\t\t//TODO Implement getOptionTriggers().\n-\t}\n-\t\n-\t\n-\t// OLD TESTS FOLLOW\n-\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public abstract class CommandLineTestCase\n+    extends CLITestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    public final Option present =\n+        new DefaultOptionBuilder().withLongName(\"present\").withLongName(\"alsopresent\").create();\n+    public final Option missing = new DefaultOptionBuilder().withLongName(\"missing\").create();\n+    public final Option multiple = new DefaultOptionBuilder().withLongName(\"multiple\").create();\n+    public final Option bool = new DefaultOptionBuilder().withLongName(\"bool\").create();\n+    public final Option root =\n+        new GroupBuilder().withOption(present).withOption(missing).withOption(multiple)\n+                          .withOption(bool).create();\n+    private CommandLine commandLine;\n+\n+    protected abstract CommandLine createCommandLine();\n+\n+    /*\n+     * @see TestCase#setUp()\n+     */\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+        commandLine = createCommandLine();\n+    }\n+\n+    /*\n+     * Class to test for boolean hasOption(String)\n+     */\n+    public final void testHasOptionString() {\n+        assertTrue(commandLine.hasOption(\"--present\"));\n+        assertTrue(commandLine.hasOption(\"--alsopresent\"));\n+        assertFalse(commandLine.hasOption(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for boolean hasOption(Option)\n+     */\n+    public final void testHasOptionOption() {\n+        assertTrue(commandLine.hasOption(present));\n+        assertFalse(commandLine.hasOption(missing));\n+    }\n+\n+    public final void testGetOption() {\n+        assertSame(present, commandLine.getOption(\"--present\"));\n+        assertSame(present, commandLine.getOption(\"--alsopresent\"));\n+\n+        //TODO decide whether the following assertion is valid\n+        //assertSame(missing,commandLine.getOption(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for List getValues(String)\n+     */\n+    public final void testGetValuesString() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\"));\n+        assertListContentsEqual(list(\"value 1\", \"value 2\", \"value 3\"),\n+                                commandLine.getValues(\"--multiple\"));\n+        assertTrue(commandLine.getValues(\"--missing\").isEmpty());\n+    }\n+\n+    /*\n+     * Class to test for List getValues(String, List)\n+     */\n+    public final void testGetValuesStringList() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\", null));\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--alsopresent\", null));\n+        assertSame(commandLine.getValues(\"--missing\", Collections.EMPTY_LIST),\n+                   Collections.EMPTY_LIST);\n+\n+        final List def = Collections.singletonList(\"default value\");\n+        assertSame(def, commandLine.getValues(\"--missing\", def));\n+    }\n+\n+    /*\n+     * Class to test for List getValues(Option)\n+     */\n+    public final void testGetValuesOption() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));\n+        assertTrue(commandLine.getValues(missing).isEmpty());\n+    }\n+\n+    /*\n+     * Class to test for List getValues(Option, List)\n+     */\n+    public final void testGetValuesOptionList() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));\n+        assertSame(commandLine.getValues(missing, Collections.EMPTY_LIST), Collections.EMPTY_LIST);\n+\n+        final List defs = Collections.singletonList(\"custom default\");\n+        assertSame(defs, commandLine.getValues(missing, defs));\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(String)\n+     */\n+    public final void testGetValueString() {\n+        assertEquals(\"present value\", commandLine.getValue(\"--present\"));\n+        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\"));\n+        assertNull(commandLine.getValue(\"--missing\"));\n+\n+        try {\n+            commandLine.getValue(\"--multiple\");\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(String, Object)\n+     */\n+    public final void testGetValueStringObject() {\n+        assertEquals(\"present value\", commandLine.getValue(\"--present\", \"default value\"));\n+        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\", \"default value\"));\n+        assertEquals(\"default value\", commandLine.getValue(\"--missing\", \"default value\"));\n+\n+        try {\n+            commandLine.getValue(\"--multiple\");\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(Option)\n+     */\n+    public final void testGetValueOption() {\n+        assertEquals(\"present value\", commandLine.getValue(present));\n+        assertNull(commandLine.getValue(missing));\n+\n+        try {\n+            commandLine.getValue(multiple);\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(Option, Object)\n+     */\n+    public final void testGetValueOptionObject() {\n+        assertEquals(\"present value\", commandLine.getValue(present, \"default value\"));\n+        assertEquals(\"default value\", commandLine.getValue(missing, \"default value\"));\n+\n+        try {\n+            commandLine.getValue(multiple);\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(String)\n+     */\n+    public final void testGetSwitchString() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\"));\n+        assertNull(commandLine.getSwitch(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(String, Boolean)\n+     */\n+    public final void testGetSwitchStringBoolean() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\", Boolean.FALSE));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"--missing\", Boolean.FALSE));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(Option)\n+     */\n+    public final void testGetSwitchOption() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool));\n+        assertNull(commandLine.getSwitch(missing));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(Option, Boolean)\n+     */\n+    public final void testGetSwitchOptionBoolean() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool, Boolean.FALSE));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(missing, Boolean.FALSE));\n+    }\n+\n+    /*\n+     * Class to test for String getProperty(String)\n+     */\n+    public final void testGetPropertyString() {\n+        assertEquals(\"present property\", commandLine.getProperty(\"present\"));\n+        assertNull(commandLine.getProperty(\"missing\"));\n+    }\n+\n+    /*\n+     * Class to test for String getProperty(String, String)\n+     */\n+    public final void testGetPropertyStringString() {\n+        assertEquals(\"present property\", commandLine.getProperty(\"present\", \"default property\"));\n+        assertEquals(\"default property\", commandLine.getProperty(\"missing\", \"default property\"));\n+    }\n+\n+    public final void testGetProperties() {\n+        assertTrue(commandLine.getProperties().containsAll(list(\"present\")));\n+    }\n+\n+    /*\n+     * Class to test for int getOptionCount(String)\n+     */\n+    public final void testGetOptionCountString() {\n+        // one option, one switch\n+        assertTrue(1 <= commandLine.getOptionCount(\"--present\"));\n+        assertTrue(1 <= commandLine.getOptionCount(\"--bool\"));\n+        assertEquals(0, commandLine.getOptionCount(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for int getOptionCount(Option)\n+     */\n+    public final void testGetOptionCountOption() {\n+        // one option, one switch\n+        assertTrue(1 <= commandLine.getOptionCount(present));\n+        assertTrue(1 <= commandLine.getOptionCount(bool));\n+        assertEquals(0, commandLine.getOptionCount(missing));\n+    }\n+\n+    public final void testGetOptions() {\n+        //TODO Implement getOptions().\n+    }\n+\n+    public final void testGetOptionTriggers() {\n+        //TODO Implement getOptionTriggers().\n+    }\n+\n+    // OLD TESTS FOLLOW\n     public final void testProperties() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         assertTrue(writeable.getProperties().isEmpty());\n \n     public final void testOptions() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         final Option start = CommandTest.buildStartCommand();\n \n     public final void testValues() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         final Option start = CommandTest.buildStartCommand();\n \n         try {\n             writeable.getValue(start);\n             fail(\"Cannot get single value if multiple are present\");\n-        }\n-        catch (IllegalStateException ise) {\n-            assertEquals(\"More than one value was supplied\", ise.getMessage());\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         ise.getMessage());\n         }\n \n         try {\n             writeable.getValue(\"start\");\n             fail(\"Cannot get single value if multiple are present\");\n-        }\n-        catch (IllegalStateException ise) {\n-            assertEquals(\"More than one value was supplied\", ise.getMessage());\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         ise.getMessage());\n         }\n \n         writeable.getValues(start).add(\"file3\");\n     public final void testSwitches() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         final Option start = CommandTest.buildStartCommand();\n \n         assertNull(writeable.getSwitch(\"go\"));\n \n         writeable.addSwitch(start, true);\n+\n         try {\n             writeable.addSwitch(start, false);\n             fail(\"Switch cannot be changed\");\n-        }\n-        catch (IllegalStateException ise) {\n-            assertEquals(\"Switch already set\", ise.getMessage());\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.SWITCH_ALREADY_SET),\n+                         ise.getMessage());\n         }\n     }\n \n     public final void testSwitches_True() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         final Option start = CommandTest.buildStartCommand();\n \n     public final void testSwitches_False() {\n         final Option option = new PropertyOption();\n         final List args = CLITestCase.list();\n-        final WriteableCommandLine writeable =\n-            OptionTestCase.commandLine(option, args);\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n \n         final Option start = CommandTest.buildStartCommand();\n \n         assertSame(Boolean.FALSE, writeable.getSwitch(start));\n     }\n \n-//    public final void testLooksLikeOption() {\n-//        final Option option = new PropertyOption();\n-//        final List args = OptionTestCase.list();\n-//        final WriteableCommandLine commandLine =\n-//            OptionTestCase.commandLine(option, args);\n-//\n-//        assertTrue(commandLine.looksLikeOption(\"-D\"));\n-//        assertFalse(commandLine.looksLikeOption(\"--help\"));\n-//        assertFalse(commandLine.looksLikeOption(\"+display\"));\n-//        assertFalse(commandLine.looksLikeOption(\"myprefix\"));\n-//        assertFalse(commandLine.looksLikeOption(\"myprefix2\"));\n-//        assertFalse(commandLine.looksLikeOption(\"myprefference\"));\n-//        assertFalse(commandLine.looksLikeOption(\"/SCANDISK\"));\n-//        assertFalse(commandLine.looksLikeOption(\"update\"));\n-//    }\n-\n-    public final void testGetOptions_Order() throws OptionException {\n+    //    public final void testLooksLikeOption() {\n+    //        final Option option = new PropertyOption();\n+    //        final List args = OptionTestCase.list();\n+    //        final WriteableCommandLine commandLine =\n+    //            OptionTestCase.commandLine(option, args);\n+    //\n+    //        assertTrue(commandLine.looksLikeOption(\"-D\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"--help\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"+display\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefix\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefix2\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefference\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"/SCANDISK\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"update\"));\n+    //    }\n+    public final void testGetOptions_Order()\n+        throws OptionException {\n         final Option help = DefaultOptionTest.buildHelpOption();\n         final Option login = CommandTest.buildLoginCommand();\n         final Option targets = ArgumentTest.buildTargetsArgument();\n \n         final Group group =\n-            new GroupBuilder()\n-                .withOption(help)\n-                .withOption(login)\n-                .withOption(targets)\n-                .create();\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets).create();\n \n         final Parser parser = new Parser();\n         parser.setGroup(group);\n+\n         final CommandLine cl =\n-            parser.parse(\n-                new String[] {\n-                    \"login\",\n-                    \"rob\",\n-                    \"--help\",\n-                    \"target1\",\n-                    \"target2\" });\n+            parser.parse(new String[] { \"login\", \"rob\", \"--help\", \"target1\", \"target2\" });\n \n         final Iterator i = cl.getOptions().iterator();\n \n         assertFalse(i.hasNext());\n     }\n \n-    public final void testGetOptionCount() throws OptionException {\n+    public final void testGetOptionCount()\n+        throws OptionException {\n         final Option help = DefaultOptionTest.buildHelpOption();\n         final Option login = CommandTest.buildLoginCommand();\n         final Option targets = ArgumentTest.buildTargetsArgument();\n         final Option display = SwitchTest.buildDisplaySwitch();\n \n         final Group group =\n-            new GroupBuilder()\n-                .withOption(help)\n-                .withOption(login)\n-                .withOption(targets)\n-                .withOption(display)\n-                .create();\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets)\n+                              .withOption(display).create();\n \n         final Parser parser = new Parser();\n         parser.setGroup(group);\n+\n         final CommandLine cl =\n-            parser.parse(\n-                new String[] {\n-                    \"--help\",\n-                    \"login\",\n-                    \"rob\",\n-                    \"+display\",\n-                    \"--help\",\n-                    \"--help\",\n-                    \"target1\",\n-                    \"target2\" });\n+            parser.parse(new String[] {\n+                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",\n+                             \"target2\"\n+                         });\n \n         assertEquals(1, cl.getOptionCount(login));\n         assertEquals(3, cl.getOptionCount(help));\n         assertEquals(1, cl.getOptionCount(display));\n     }\n \n-    public final void testGetOptionCount_Strings() throws OptionException {\n+    public final void testGetOptionCount_Strings()\n+        throws OptionException {\n         final Option help = DefaultOptionTest.buildHelpOption();\n         final Option login = CommandTest.buildLoginCommand();\n         final Option targets = ArgumentTest.buildTargetsArgument();\n         final Option display = SwitchTest.buildDisplaySwitch();\n \n         final Group group =\n-            new GroupBuilder()\n-                .withOption(help)\n-                .withOption(login)\n-                .withOption(targets)\n-                .withOption(display)\n-                .create();\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets)\n+                              .withOption(display).create();\n \n         final Parser parser = new Parser();\n         parser.setGroup(group);\n+\n         final CommandLine cl =\n-            parser.parse(\n-                new String[] {\n-                    \"--help\",\n-                    \"login\",\n-                    \"rob\",\n-                    \"+display\",\n-                    \"--help\",\n-                    \"--help\",\n-                    \"target1\",\n-                    \"target2\" });\n+            parser.parse(new String[] {\n+                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",\n+                             \"target2\"\n+                         });\n \n         assertEquals(1, cl.getOptionCount(\"login\"));\n         assertEquals(3, cl.getOptionCount(\"-?\"));\n         assertEquals(1, cl.getOptionCount(\"+display\"));\n     }\n \n-    public final void testOptionAsArgument() throws OptionException {\n-    \tfinal Option p = new DefaultOptionBuilder().withShortName(\"p\").create();\n-    \tfinal Argument argument = new ArgumentBuilder().create();\n-    \tfinal Option withArgument = new DefaultOptionBuilder().withShortName(\"attr\").withArgument(argument).create();\n-\n-    \tfinal Group group =\n-            new GroupBuilder()\n-                .withOption(p)\n-                .withOption(withArgument)\n-                .create();\n+    public final void testOptionAsArgument()\n+        throws OptionException {\n+        final Option p = new DefaultOptionBuilder().withShortName(\"p\").create();\n+        final Argument argument = new ArgumentBuilder().create();\n+        final Option withArgument =\n+            new DefaultOptionBuilder().withShortName(\"attr\").withArgument(argument).create();\n+\n+        final Group group = new GroupBuilder().withOption(p).withOption(withArgument).create();\n \n         final Parser parser = new Parser();\n         parser.setGroup(group);\n-        final CommandLine cl =\n-            parser.parse(\n-                new String[] {\n-                    \"-p\",\n-                    \"-attr\",\n-                    \"p\" });\n+\n+        final CommandLine cl = parser.parse(new String[] { \"-p\", \"-attr\", \"p\" });\n \n         assertEquals(1, cl.getOptionCount(\"-p\"));\n         assertTrue(cl.hasOption(\"-p\"));\n--- a/src/test/org/apache/commons/cli2/builder/DefaultOptionBuilderTest.java\n+++ b/src/test/org/apache/commons/cli2/builder/DefaultOptionBuilderTest.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.Argument;\n import org.apache.commons.cli2.Group;\n import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n+public class DefaultOptionBuilderTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private DefaultOptionBuilder defaultOptionBuilder;\n \n-public class DefaultOptionBuilderTest extends TestCase {\n-\n-    private DefaultOptionBuilder defaultOptionBuilder;\n-    \n     /*\n      * @see TestCase#setUp()\n      */\n-    protected void setUp() throws Exception {\n+    protected void setUp()\n+        throws Exception {\n         this.defaultOptionBuilder = new DefaultOptionBuilder();\n     }\n \n      */\n     public void testNew_NullShortPrefix() {\n         try {\n-            new DefaultOptionBuilder(null, null,\n-                    false);\n+            new DefaultOptionBuilder(null, null, false);\n             fail(\"null short prefix is not permitted\");\n-        }\n-        catch(IllegalArgumentException e) {\n-            assertEquals(\"shortPrefix should be at least 1 character long\",e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),\n+                         e.getMessage());\n         }\n     }\n \n      */\n     public void testNew_EmptyShortPrefix() {\n         try {\n-            new DefaultOptionBuilder(\"\", null,\n-                    false);\n+            new DefaultOptionBuilder(\"\", null, false);\n             fail(\"empty short prefix is not permitted\");\n-        }\n-        catch(IllegalArgumentException e) {\n-            assertEquals(\"shortPrefix should be at least 1 character long\",e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),\n+                         e.getMessage());\n         }\n     }\n \n      */\n     public void testNew_NullLongPrefix() {\n         try {\n-            new DefaultOptionBuilder(\"-\", null,\n-                    false);\n+            new DefaultOptionBuilder(\"-\", null, false);\n             fail(\"null long prefix is not permitted\");\n-        }\n-        catch(IllegalArgumentException e) {\n-            assertEquals(\"longPrefix should be at least 1 character long\",e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),\n+                         e.getMessage());\n         }\n     }\n \n      */\n     public void testNew_EmptyLongPrefix() {\n         try {\n-            new DefaultOptionBuilder(\"-\", \"\",\n-                    false);\n+            new DefaultOptionBuilder(\"-\", \"\", false);\n             fail(\"empty long prefix is not permitted\");\n-        }\n-        catch(IllegalArgumentException e) {\n-            assertEquals(\"longPrefix should be at least 1 character long\",e.getMessage());\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),\n+                         e.getMessage());\n         }\n     }\n \n         try {\n             this.defaultOptionBuilder.create();\n             fail(\"options must have a name\");\n-        }\n-        catch (IllegalStateException e) {\n-            assertEquals(\"Options must have at least one name\",e.getMessage());\n-        }\n-        \n-        {\n-            this.defaultOptionBuilder.withShortName(\"j\");\n-            this.defaultOptionBuilder.create();\n-        }\n-        \n-        {\n-            this.defaultOptionBuilder.withLongName(\"jkeyes\");\n-            this.defaultOptionBuilder.create();\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_NO_NAME), e.getMessage());\n         }\n \n+        this.defaultOptionBuilder.withShortName(\"j\");\n+        this.defaultOptionBuilder.create();\n+        this.defaultOptionBuilder.withLongName(\"jkeyes\");\n+        this.defaultOptionBuilder.create();\n+\n         {\n-            DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"--\",\n-                    true);\n+            DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"--\", true);\n             builder.withShortName(\"mx\");\n         }\n     }\n             this.defaultOptionBuilder.withShortName(\"a\");\n             this.defaultOptionBuilder.withLongName(\"apples\");\n         }\n-\n         // withShortName && this.preferred != null\n         {\n             this.defaultOptionBuilder.withLongName(\"apples\");\n             this.defaultOptionBuilder.withShortName(\"a\");\n         }\n-\n         // withShortName && this.preferred != null\n         {\n             this.defaultOptionBuilder.withLongName(\"apples\");\n             this.defaultOptionBuilder.withShortName(\"a\");\n         }\n-\n     }\n \n     public void testWithDescription() {\n         String description = \"desc\";\n         this.defaultOptionBuilder.withShortName(\"a\");\n         this.defaultOptionBuilder.withDescription(description);\n+\n         DefaultOption opt = this.defaultOptionBuilder.create();\n-        assertEquals(\"wrong description found\", description, \n-                opt.getDescription());\n+        assertEquals(\"wrong description found\", description, opt.getDescription());\n     }\n \n     public void testWithRequired() {\n             boolean required = false;\n             this.defaultOptionBuilder.withShortName(\"a\");\n             this.defaultOptionBuilder.withRequired(required);\n+\n             DefaultOption opt = this.defaultOptionBuilder.create();\n-            assertEquals(\"wrong required found\", required, \n-                    opt.isRequired());\n+            assertEquals(\"wrong required found\", required, opt.isRequired());\n         }\n \n         {\n             boolean required = true;\n             this.defaultOptionBuilder.withShortName(\"a\");\n             this.defaultOptionBuilder.withRequired(required);\n+\n             DefaultOption opt = this.defaultOptionBuilder.create();\n-            assertEquals(\"wrong required found\", required, \n-                    opt.isRequired());\n+            assertEquals(\"wrong required found\", required, opt.isRequired());\n         }\n-}\n+    }\n \n     public void testWithChildren() {\n         GroupBuilder gbuilder = new GroupBuilder();\n-        \n+\n         this.defaultOptionBuilder.withShortName(\"a\");\n         this.defaultOptionBuilder.withRequired(true);\n+\n         DefaultOption opt = this.defaultOptionBuilder.create();\n \n-        Group group = \n-            gbuilder.withName(\"withchildren\")\n-                .withOption(opt)\n-                .create();\n+        Group group = gbuilder.withName(\"withchildren\").withOption(opt).create();\n+\n         {\n             this.defaultOptionBuilder.withShortName(\"b\");\n             this.defaultOptionBuilder.withChildren(group);\n+\n             DefaultOption option = this.defaultOptionBuilder.create();\n             assertEquals(\"wrong children found\", group, option.getChildren());\n         }\n     public void testWithArgument() {\n         ArgumentBuilder abuilder = new ArgumentBuilder();\n         abuilder.withName(\"myarg\");\n+\n         Argument arg = abuilder.create();\n-        \n+\n         this.defaultOptionBuilder.withShortName(\"a\");\n         this.defaultOptionBuilder.withRequired(true);\n         this.defaultOptionBuilder.withArgument(arg);\n+\n         DefaultOption opt = this.defaultOptionBuilder.create();\n \n         assertEquals(\"wrong argument found\", arg, opt.getArgument());\n     public void testWithId() {\n         this.defaultOptionBuilder.withShortName(\"a\");\n         this.defaultOptionBuilder.withId(0);\n+\n         DefaultOption opt = this.defaultOptionBuilder.create();\n \n         assertEquals(\"wrong id found\", 0, opt.getId());\n     }\n-\n }\n--- a/src/test/org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * To change the template for this generated type comment go to\n  * Window - Preferences - Java - Code Generation - Code and Comments\n  */\n-public class DefaultingCommandLineTest extends CommandLineTestCase {\n-\t\n-\tprivate CommandLine first;\n-\tprivate CommandLine second;\n-\t\n-\tprivate Option inFirst = new DefaultOptionBuilder().withLongName(\"infirst\").create(); \n-\tprivate Option inBoth = new DefaultOptionBuilder().withLongName(\"inboth\").create(); \n-\tprivate Option inSecond = new DefaultOptionBuilder().withLongName(\"insecond\").create(); \n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n-\t */\n-\tprotected final CommandLine createCommandLine() {\n-\t\tfinal WriteableCommandLine writeable = new WriteableCommandLineImpl(root,new ArrayList());\n-\t\twriteable.addOption(present);\n-\t\twriteable.addProperty(\"present\",\"present property\");\n-\t\twriteable.addSwitch(bool,true);\n-\t\twriteable.addValue(present,\"present value\");\n-\t\twriteable.addOption(multiple);\n-\t\twriteable.addValue(multiple,\"value 1\");\n-\t\twriteable.addValue(multiple,\"value 2\");\n-\t\twriteable.addValue(multiple,\"value 3\");\n-\t\t\n-\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n-\t\tdefaults.appendCommandLine(writeable);\n-\t\treturn defaults;\n-\t}\n-\t\n-\tpublic void setUp() throws Exception{\n-\t\tsuper.setUp();\n-\t\t\n-\t\tWriteableCommandLine writeable;\n-\t\t\n-\t\twriteable = new WriteableCommandLineImpl(root,new ArrayList());\n-\t\twriteable.addOption(inFirst);\n-\t\twriteable.addOption(inBoth);\n-\t\twriteable.addProperty(\"infirst\",\"infirst first value\");\n-\t\twriteable.addProperty(\"inboth\",\"inboth first value\");\n-\t\twriteable.addSwitch(inFirst,true);\n-\t\twriteable.addSwitch(inBoth,true);\n-\t\twriteable.addValue(inFirst,\"infirst first value 1\");\n-\t\twriteable.addValue(inFirst,\"infirst first value 2\");\n-\t\twriteable.addValue(inBoth,\"inboth first value 1\");\n-\t\twriteable.addValue(inBoth,\"inboth first value 2\");\n-\t\tfirst = writeable;\n-\t\t\n-\t\twriteable = new WriteableCommandLineImpl(root,new ArrayList());\n-\t\twriteable.addOption(inSecond);\n-\t\twriteable.addOption(inBoth);\n-\t\twriteable.addProperty(\"insecond\",\"insecond second value\");\n-\t\twriteable.addProperty(\"inboth\",\"inboth second value\");\n-\t\twriteable.addSwitch(inSecond,true);\n-\t\twriteable.addSwitch(inBoth,true);\n-\t\twriteable.addValue(inSecond,\"insecond second value 1\");\n-\t\twriteable.addValue(inSecond,\"insecond second value 2\");\n-\t\twriteable.addValue(inBoth,\"inboth second value 1\");\n-\t\twriteable.addValue(inBoth,\"inboth second value 2\");\n-\t\tsecond = writeable;\n-\t}\n-\t\n-\tpublic final void testAppendCommandLine() {\n-\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n-\t\tIterator i;\n-\t\t\n-\t\ti = defaults.commandLines();\n-\t\tassertFalse(i.hasNext());\n-\t\t\n-\t\tdefaults.appendCommandLine(first);\n-\t\ti = defaults.commandLines();\n-\t\tassertSame(first,i.next());\n-\t\tassertFalse(i.hasNext());\n-\t\t\n-\t\tdefaults.appendCommandLine(second);\n-\t\ti = defaults.commandLines();\n-\t\tassertSame(first,i.next());\n-\t\tassertSame(second,i.next());\n-\t\tassertFalse(i.hasNext());\n-\t}\n-\t\n-\tpublic final void testInsertCommandLine() {\n-\t\tfinal DefaultingCommandLine defaults = new DefaultingCommandLine();\n-\t\tIterator i;\n-\t\t\n-\t\ti = defaults.commandLines();\n-\t\tassertFalse(i.hasNext());\n-\t\t\n-\t\tdefaults.insertCommandLine(0,first);\n-\t\ti = defaults.commandLines();\n-\t\tassertSame(first,i.next());\n-\t\tassertFalse(i.hasNext());\n-\t\t\n-\t\tdefaults.insertCommandLine(0,second);\n-\t\ti = defaults.commandLines();\n-\t\tassertSame(second,i.next());\n-\t\tassertSame(first,i.next());\n-\t\tassertFalse(i.hasNext());\n-\t}\n+public class DefaultingCommandLineTest\n+    extends CommandLineTestCase {\n+    private CommandLine first;\n+    private CommandLine second;\n+    private Option inFirst = new DefaultOptionBuilder().withLongName(\"infirst\").create();\n+    private Option inBoth = new DefaultOptionBuilder().withLongName(\"inboth\").create();\n+    private Option inSecond = new DefaultOptionBuilder().withLongName(\"insecond\").create();\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+     */\n+    protected final CommandLine createCommandLine() {\n+        final WriteableCommandLine writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(present);\n+        writeable.addProperty(\"present\", \"present property\");\n+        writeable.addSwitch(bool, true);\n+        writeable.addValue(present, \"present value\");\n+        writeable.addOption(multiple);\n+        writeable.addValue(multiple, \"value 1\");\n+        writeable.addValue(multiple, \"value 2\");\n+        writeable.addValue(multiple, \"value 3\");\n+\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        defaults.appendCommandLine(writeable);\n+\n+        return defaults;\n+    }\n+\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+\n+        WriteableCommandLine writeable;\n+\n+        writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(inFirst);\n+        writeable.addOption(inBoth);\n+        writeable.addProperty(\"infirst\", \"infirst first value\");\n+        writeable.addProperty(\"inboth\", \"inboth first value\");\n+        writeable.addSwitch(inFirst, true);\n+        writeable.addSwitch(inBoth, true);\n+        writeable.addValue(inFirst, \"infirst first value 1\");\n+        writeable.addValue(inFirst, \"infirst first value 2\");\n+        writeable.addValue(inBoth, \"inboth first value 1\");\n+        writeable.addValue(inBoth, \"inboth first value 2\");\n+        first = writeable;\n+\n+        writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(inSecond);\n+        writeable.addOption(inBoth);\n+        writeable.addProperty(\"insecond\", \"insecond second value\");\n+        writeable.addProperty(\"inboth\", \"inboth second value\");\n+        writeable.addSwitch(inSecond, true);\n+        writeable.addSwitch(inBoth, true);\n+        writeable.addValue(inSecond, \"insecond second value 1\");\n+        writeable.addValue(inSecond, \"insecond second value 2\");\n+        writeable.addValue(inBoth, \"inboth second value 1\");\n+        writeable.addValue(inBoth, \"inboth second value 2\");\n+        second = writeable;\n+    }\n+\n+    public final void testAppendCommandLine() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        Iterator i;\n+\n+        i = defaults.commandLines();\n+        assertFalse(i.hasNext());\n+\n+        defaults.appendCommandLine(first);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+\n+        defaults.appendCommandLine(second);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertSame(second, i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public final void testInsertCommandLine() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        Iterator i;\n+\n+        i = defaults.commandLines();\n+        assertFalse(i.hasNext());\n+\n+        defaults.insertCommandLine(0, first);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+\n+        defaults.insertCommandLine(0, second);\n+        i = defaults.commandLines();\n+        assertSame(second, i.next());\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+    }\n }\n--- a/src/test/org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n \n /**\n  * @author Rob Oxspring\n- *\n- * To change the template for this generated type comment go to\n- * Window - Preferences - Java - Code Generation - Code and Comments\n  */\n public class PreferencesCommandLineTest extends CommandLineTestCase {\n \t\n--- a/src/test/org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java\n-/**\n+/*\n  * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n \n /**\n  * @author Rob Oxspring\n- *\n- * To change the template for this generated type comment go to\n- * Window - Preferences - Java - Code Generation - Code and Comments\n  */\n-public class PropertiesCommandLineTest extends CommandLineTestCase {\n-\t\n-\tprivate Properties props = null;\n-\t\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n-\t */\n-\tprotected CommandLine createCommandLine() {\n-\t\tprops = new Properties();\n-\t\tprops.setProperty(\"--present\",\"present value\");\n-\t\tprops.setProperty(\"--alsopresent\",\"\");\n-\t\tprops.setProperty(\"--multiple\",\"value 1|value 2|value 3\");\n-\t\tprops.setProperty(\"--bool\",\"true\");\n-\t\t\n-\t\tprops.setProperty(\"present\",\"present property\");\n-\t\treturn new PropertiesCommandLine(root,props,'|');\n-\t}\n-\t\n-\tpublic void testToMakeEclipseSpotTheTestCase(){\n-\t\t// nothing to test\n-\t}\n+public class PropertiesCommandLineTest\n+    extends CommandLineTestCase {\n+    private Properties props = null;\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+     */\n+    protected CommandLine createCommandLine() {\n+        props = new Properties();\n+        props.setProperty(\"--present\", \"present value\");\n+        props.setProperty(\"--alsopresent\", \"\");\n+        props.setProperty(\"--multiple\", \"value 1|value 2|value 3\");\n+        props.setProperty(\"--bool\", \"true\");\n+\n+        props.setProperty(\"present\", \"present property\");\n+\n+        return new PropertiesCommandLine(root, props, '|');\n+    }\n+\n+    public void testToMakeEclipseSpotTheTestCase() {\n+        // nothing to test\n+    }\n }\n--- a/src/test/org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n import org.apache.commons.cli2.WriteableCommandLine;\n import org.apache.commons.cli2.WriteableCommandLineTestCase;\n \n-public class WriteableCommandLineImplTest extends WriteableCommandLineTestCase {\n+public class WriteableCommandLineImplTest\n+    extends WriteableCommandLineTestCase {\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.WriteableCommandLineTest#createWriteableCommandLine()\n+     */\n+    protected WriteableCommandLine createWriteableCommandLine() {\n+        return new WriteableCommandLineImpl(root, new ArrayList());\n+    }\n \n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.cli2.WriteableCommandLineTest#createWriteableCommandLine()\n-\t */\n-\tprotected WriteableCommandLine createWriteableCommandLine() {\n-\t\treturn new WriteableCommandLineImpl(root,new ArrayList());\n-\t}\n-\t\n-\tpublic void testToMakeEclipseSpotTheTestCase(){\n-\t\t// nothing to test\n-\t}\n+    public void testToMakeEclipseSpotTheTestCase() {\n+        // nothing to test\n+    }\n }\n--- a/src/test/org/apache/commons/cli2/option/ArgumentTest.java\n+++ b/src/test/org/apache/commons/cli2/option/ArgumentTest.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  */\n public class ArgumentTest extends ArgumentTestCase {\n \n-    private ResourceHelper resources = ResourceHelper.getResourceHelper(ArgumentTest.class);\n+    private ResourceHelper resources = ResourceHelper.getResourceHelper();\n     \n     public static Argument buildUsernameArgument() {\n         return new ArgumentImpl(\n                         0);\n             } catch (IllegalArgumentException e) {\n                 assertEquals(\n-                        resources.getMessage(\"cli.error.minimum.exceeds.maximum\"),\n+                        resources.getMessage(\"Argument.minimum.exceeds.maximum\"),\n                         e.getMessage());\n             }\n         }\n             }\n             catch(IllegalArgumentException exp) {\n                 assertEquals(\n-                        resources.getMessage(\"cli.error.too.few.defaults\"),\n+                        resources.getMessage(\"Argument.too.few.defaults\"),\n                         exp.getMessage());\n             }\n         }\n             }\n             catch(IllegalArgumentException exp) {\n                 assertEquals(\n-                    resources.getMessage(\"cli.error.too.many.defaults\"),\n+                    resources.getMessage(\"Argument.too.many.defaults\"),\n                     exp.getMessage());\n             }\n         }\n--- a/src/test/org/apache/commons/cli2/util/HelpFormatterTest.java\n+++ b/src/test/org/apache/commons/cli2/util/HelpFormatterTest.java\n-/**\n+/*\n  * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n import java.io.PrintWriter;\n import java.io.StringReader;\n import java.io.StringWriter;\n+\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashSet;\n import org.apache.commons.cli2.builder.GroupBuilder;\n import org.apache.commons.cli2.option.ArgumentTest;\n import org.apache.commons.cli2.option.DefaultOptionTest;\n-\n-public class HelpFormatterTest extends TestCase {\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class HelpFormatterTest\n+    extends TestCase {\n+    private ResourceHelper resources = ResourceHelper.getResourceHelper();\n     private HelpFormatter helpFormatter;\n     private Option verbose;\n     private Group options;\n \n     public void setUp() {\n         helpFormatter = new HelpFormatter(\"|*\", \"*-*\", \"*|\", 80);\n-        helpFormatter.setDivider(\n-            \"+------------------------------------------------------------------------------+\");\n+        helpFormatter.setDivider(\"+------------------------------------------------------------------------------+\");\n         helpFormatter.setHeader(\"Jakarta Commons CLI\");\n         helpFormatter.setFooter(\"Copyright 2003\\nApache Software Foundation\");\n         helpFormatter.setShellCommand(\"ant\");\n \n         verbose =\n-            new DefaultOptionBuilder()\n-                .withLongName(\"verbose\")\n-                .withDescription(\"print the version information and exit\")\n-                .create();\n-\n-        options = new GroupBuilder()\n-            .withName(\"options\")\n-            .withOption(DefaultOptionTest.buildHelpOption())\n-            .withOption(ArgumentTest.buildTargetsArgument())\n-            .withOption(\n-                new DefaultOptionBuilder()\n-                    .withLongName(\"diagnostics\")\n-                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n-                    .create())\n-            .withOption(\n-                new DefaultOptionBuilder()\n-                    .withLongName(\"projecthelp\")\n-                    .withDescription(\"print project help information\")\n-                    .create())\n-            .withOption(verbose)\n-            .create();        \n-        \n+            new DefaultOptionBuilder().withLongName(\"verbose\")\n+                                      .withDescription(\"print the version information and exit\")\n+                                      .create();\n+\n+        options =\n+            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())\n+                              .withOption(ArgumentTest.buildTargetsArgument())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")\n+                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                                                                    .create())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")\n+                                                                    .withDescription(\"print project help information\")\n+                                                                    .create()).withOption(verbose)\n+                              .create();\n+\n         helpFormatter.setGroup(options);\n     }\n \n-    public void testPrint() throws IOException {\n+    public void testPrint()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         final PrintWriter pw = new PrintWriter(writer);\n         helpFormatter.setPrintWriter(pw);\n         assertEquals(\"incorrect print writer\", pw, helpFormatter.getPrintWriter());\n \n         // test divider\n-        assertEquals(\"incorrect divider\", \n-                \"+------------------------------------------------------------------------------+\",\n-                helpFormatter.getDivider());\n+        assertEquals(\"incorrect divider\",\n+                     \"+------------------------------------------------------------------------------+\",\n+                     helpFormatter.getDivider());\n \n         // test header\n         assertEquals(\"incorrect header\", \"Jakarta Commons CLI\", helpFormatter.getHeader());\n \n         // test footer\n         assertEquals(\"incorrect footer\", \"Copyright 2003\\nApache Software Foundation\",\n-                helpFormatter.getFooter());\n+                     helpFormatter.getFooter());\n \n         // test gutters\n         assertEquals(\"incorrect left gutter\", \"|*\", helpFormatter.getGutterLeft());\n         assertEquals(\"incorrect right gutter\", \"*|\", helpFormatter.getGutterRight());\n         assertEquals(\"incorrect center gutter\", \"*-*\", helpFormatter.getGutterCenter());\n \n-\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Jakarta Commons CLI                                                         *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Usage:                                                                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*...]]                                                                       *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*options              *-*                                                    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*                     *-*or report problems.                                 *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --projecthelp      *-*print project help information                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --verbose          *-*print the version information and exit              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  target [target ...]*-*The targets ant should build                        *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Copyright 2003                                                              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Apache Software Foundation                                                  *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testComparator() throws IOException {\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Jakarta Commons CLI                                                         *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testComparator()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         final PrintWriter pw = new PrintWriter(writer);\n         helpFormatter.setPrintWriter(pw);\n+\n         final Comparator comparator = new OptionComparator();\n         helpFormatter.setComparator(comparator);\n         helpFormatter.print();\n \n         // test comparator\n         assertEquals(\"invalid comparator\", comparator, helpFormatter.getComparator());\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Jakarta Commons CLI                                                         *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Usage:                                                                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*ant [--verbose --projecthelp --help --diagnostics] [<target1> [<target2>    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*...]]                                                                       *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*options              *-*                                                    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --verbose          *-*print the version information and exit              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --projecthelp      *-*print project help information                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*                     *-*or report problems.                                 *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  target [target ...]*-*The targets ant should build                        *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Copyright 2003                                                              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Apache Software Foundation                                                  *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintHelp() throws IOException {\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Jakarta Commons CLI                                                         *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--verbose --projecthelp --help --diagnostics] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printHelp();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*options              *-*                                                    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*                     *-*or report problems.                                 *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --projecthelp      *-*print project help information                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  --verbose          *-*print the version information and exit              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*  target [target ...]*-*The targets ant should build                        *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintHelp_WithException() throws IOException {\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp_WithException()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.setException(new OptionException(verbose));\n         helpFormatter.printHelp();\n+\n         //System.out.println(writer);\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*--verbose*-*print the version information and exit                          *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintHelp_TooNarrow() throws IOException {\n-        final StringWriter writer = new StringWriter();\n-        helpFormatter = new HelpFormatter(\"<\",\"=\",\">\",4);\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*--verbose*-*print the version information and exit                          *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp_TooNarrow()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter = new HelpFormatter(\"<\", \"=\", \">\", 4);\n         helpFormatter.setGroup(options);\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printHelp();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"<options              = >\",\n-            reader.readLine());\n-        assertEquals(\n-            \"<  --help (-?,-h)     =D>\",\n-            reader.readLine());\n-        assertEquals(\n-            \"<                     =i>\",\n-            reader.readLine());\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"<options              = >\", reader.readLine());\n+        assertEquals(\"<  --help (-?,-h)     =D>\", reader.readLine());\n+        assertEquals(\"<                     =i>\", reader.readLine());\n+\n         // lots more lines unchecked\n     }\n \n-    public void testPrintException() throws IOException {\n-        final StringWriter writer = new StringWriter();\n-        helpFormatter.setPrintWriter(new PrintWriter(writer));\n-        helpFormatter.setException(new OptionException(verbose, \"cli.error.missing.option\"));\n+    public void testPrintException()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.setException(new OptionException(verbose, ResourceConstants.MISSING_OPTION));\n         helpFormatter.printException();\n+\n         //System.out.println(writer);\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Missing option --verbose                                                    *|\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintUsage() throws IOException {\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Missing option --verbose                                                    *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintUsage()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printUsage();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Usage:                                                                      *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*...]]                                                                       *|\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintHeader() throws IOException {\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHeader()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printHeader();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Jakarta Commons CLI                                                         *|\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintFooter() throws IOException {\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Jakarta Commons CLI                                                         *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintFooter()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printFooter();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"|*Copyright 2003                                                              *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"|*Apache Software Foundation                                                  *|\",\n-            reader.readLine());\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n-        assertNull(reader.readLine());\n-    }\n-\n-    public void testPrintDivider() throws IOException {\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintDivider()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.printDivider();\n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"+------------------------------------------------------------------------------+\",\n-            reader.readLine());\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n         assertNull(reader.readLine());\n     }\n \n     public void testWrap() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"Apache Software Foundation\", 30).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 30).iterator();\n         assertEquals(\"Apache Software Foundation\", i.next());\n         assertFalse(i.hasNext());\n     }\n \n     public void testWrap_WrapNeeded() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"Apache Software Foundation\", 20).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 20).iterator();\n         assertEquals(\"Apache Software\", i.next());\n         assertEquals(\"Foundation\", i.next());\n         assertFalse(i.hasNext());\n     }\n \n     public void testWrap_BeforeSpace() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"Apache Software Foundation\", 16).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 16).iterator();\n         assertEquals(\"Apache Software\", i.next());\n         assertEquals(\"Foundation\", i.next());\n         assertFalse(i.hasNext());\n     }\n \n     public void testWrap_AfterSpace() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"Apache Software Foundation\", 17).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 17).iterator();\n         assertEquals(\"Apache Software\", i.next());\n         assertEquals(\"Foundation\", i.next());\n         assertFalse(i.hasNext());\n     }\n \n     public void testWrap_InWord() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"Apache Software Foundation\", 8).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 8).iterator();\n         assertEquals(\"Apache\", i.next());\n         assertEquals(\"Software\", i.next());\n         assertEquals(\"Foundati\", i.next());\n     }\n \n     public void testWrap_NewLine() {\n-        final Iterator i =\n-            HelpFormatter.wrap(\"\\nApache Software Foundation\\n\", 30).iterator();\n+        final Iterator i = HelpFormatter.wrap(\"\\nApache Software Foundation\\n\", 30).iterator();\n         assertEquals(\"\", i.next());\n         assertEquals(\"Apache Software Foundation\", i.next());\n         assertEquals(\"\", i.next());\n     }\n \n     public void testWrap_NewLine2() {\n-        List wrapped = HelpFormatter.wrap(\"A really quite long general description of the option with specific alternatives documented:\\n\"+\n-                    \"  Indented special case\\n\"+\n-                    \"  Alternative scenario\", 30);\n-        \n-        final Iterator i =\n-            wrapped.iterator();\n-        \n+        List wrapped =\n+            HelpFormatter.wrap(\"A really quite long general description of the option with specific alternatives documented:\\n\" +\n+                               \"  Indented special case\\n\" + \"  Alternative scenario\", 30);\n+\n+        final Iterator i = wrapped.iterator();\n+\n         assertEquals(\"A really quite long general\", i.next());\n         assertEquals(\"description of the option\", i.next());\n         assertEquals(\"with specific alternatives\", i.next());\n         assertEquals(\"  Alternative scenario\", i.next());\n         assertFalse(i.hasNext());\n     }\n-    \n+\n     public void testWrap_Below1Length() {\n-        try{\n-            HelpFormatter.wrap(\"Apache Software Foundation\",-1);\n+        try {\n+            HelpFormatter.wrap(\"Apache Software Foundation\", -1);\n             fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,\n+                                              new Object[] { new Integer(-1) }), e.getMessage());\n         }\n-        catch(IllegalArgumentException e) {\n-            assertEquals(\"width must be positive\",e.getMessage());\n-        }\n-    }\n-\n-    public void testPad() throws IOException {\n+    }\n+\n+    public void testPad()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         HelpFormatter.pad(\"hello\", 10, writer);\n         assertEquals(\"hello     \", writer.toString());\n     }\n \n-    public void testPad_Null() throws IOException {\n+    public void testPad_Null()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         HelpFormatter.pad(null, 10, writer);\n         assertEquals(\"          \", writer.toString());\n     }\n \n-    public void testPad_TooLong() throws IOException {\n+    public void testPad_TooLong()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         HelpFormatter.pad(\"hello world\", 10, writer);\n         assertEquals(\"hello world\", writer.toString());\n     }\n-    \n-    public void testPad_TooShort() throws IOException {\n+\n+    public void testPad_TooShort()\n+        throws IOException {\n         final StringWriter writer = new StringWriter();\n         HelpFormatter.pad(\"hello world\", -5, writer);\n         assertEquals(\"hello world\", writer.toString());\n     }\n-    \n-    public void testGutters() throws IOException {\n+\n+    public void testGutters()\n+        throws IOException {\n         helpFormatter = new HelpFormatter(null, null, null, 80);\n         helpFormatter.setShellCommand(\"ant\");\n+\n         final Set lusage = new HashSet();\n         lusage.add(DisplaySetting.DISPLAY_ALIASES);\n         lusage.add(DisplaySetting.DISPLAY_GROUP_NAME);\n         helpFormatter.setLineUsageSettings(lusage);\n-        \n+\n         // test line usage\n         assertEquals(\"incorrect line usage\", lusage, helpFormatter.getLineUsageSettings());\n \n         dsettings.add(DisplaySetting.DISPLAY_GROUP_NAME);\n         dsettings.add(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n         dsettings.add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n-        \n+\n         helpFormatter.setDisplaySettings(dsettings);\n \n         verbose =\n-            new DefaultOptionBuilder()\n-                .withLongName(\"verbose\")\n-                .withDescription(\"print the version information and exit\")\n-                .create();\n-\n-        options = new GroupBuilder()\n-            .withName(\"options\")\n-            .withOption(DefaultOptionTest.buildHelpOption())\n-            .withOption(ArgumentTest.buildTargetsArgument())\n-            .withOption(\n-                new DefaultOptionBuilder()\n-                    .withLongName(\"diagnostics\")\n-                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n-                    .create())\n-            .withOption(\n-                new DefaultOptionBuilder()\n-                    .withLongName(\"projecthelp\")\n-                    .withDescription(\"print project help information\")\n-                    .create())\n-            .withOption(verbose)\n-            .create();        \n-        \n+            new DefaultOptionBuilder().withLongName(\"verbose\")\n+                                      .withDescription(\"print the version information and exit\")\n+                                      .create();\n+\n+        options =\n+            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())\n+                              .withOption(ArgumentTest.buildTargetsArgument())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")\n+                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                                                                    .create())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")\n+                                                                    .withDescription(\"print project help information\")\n+                                                                    .create()).withOption(verbose)\n+                              .create();\n+\n         helpFormatter.setGroup(options);\n \n         // test default gutters\n-        assertEquals(\"incorrect left gutter\", HelpFormatter.DEFAULT_GUTTER_LEFT, helpFormatter.getGutterLeft());\n-        assertEquals(\"incorrect right gutter\", HelpFormatter.DEFAULT_GUTTER_RIGHT, helpFormatter.getGutterRight());\n-        assertEquals(\"incorrect center gutter\", HelpFormatter.DEFAULT_GUTTER_CENTER, helpFormatter.getGutterCenter());\n-    \n+        assertEquals(\"incorrect left gutter\", HelpFormatter.DEFAULT_GUTTER_LEFT,\n+                     helpFormatter.getGutterLeft());\n+        assertEquals(\"incorrect right gutter\", HelpFormatter.DEFAULT_GUTTER_RIGHT,\n+                     helpFormatter.getGutterRight());\n+        assertEquals(\"incorrect center gutter\", HelpFormatter.DEFAULT_GUTTER_CENTER,\n+                     helpFormatter.getGutterCenter());\n+\n         final StringWriter writer = new StringWriter();\n         helpFormatter.setPrintWriter(new PrintWriter(writer));\n         helpFormatter.print();\n \n-        final BufferedReader reader =\n-            new BufferedReader(new StringReader(writer.toString()));\n-        assertEquals(\n-            \"Usage:                                                                          \",\n-            reader.readLine());\n-        assertEquals(\n-            \"ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2> ...]]  \",\n-            reader.readLine());\n-        assertEquals(\n-            \"options                                                                         \",\n-            reader.readLine());\n-        assertEquals(\n-            \"  --help (-?,-h)         Displays the help                                      \",\n-            reader.readLine());\n-        assertEquals(\n-            \"  --diagnostics          print information that might be helpful to diagnose or \",\n-            reader.readLine());\n-        assertEquals(\n-            \"                         report problems.                                       \",\n-            reader.readLine());\n-        assertEquals(\n-            \"  --projecthelp          print project help information                         \",\n-            reader.readLine());\n-        assertEquals(\n-            \"  --verbose              print the version information and exit                 \",\n-            reader.readLine());\n-        assertEquals(\n-            \"  target [target ...]    The targets ant should build                           \",\n-            reader.readLine());\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"Usage:                                                                          \",\n+                     reader.readLine());\n+        assertEquals(\"ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2> ...]]  \",\n+                     reader.readLine());\n+        assertEquals(\"options                                                                         \",\n+                     reader.readLine());\n+        assertEquals(\"  --help (-?,-h)         Displays the help                                      \",\n+                     reader.readLine());\n+        assertEquals(\"  --diagnostics          print information that might be helpful to diagnose or \",\n+                     reader.readLine());\n+        assertEquals(\"                         report problems.                                       \",\n+                     reader.readLine());\n+        assertEquals(\"  --projecthelp          print project help information                         \",\n+                     reader.readLine());\n+        assertEquals(\"  --verbose              print the version information and exit                 \",\n+                     reader.readLine());\n+        assertEquals(\"  target [target ...]    The targets ant should build                           \",\n+                     reader.readLine());\n         assertNull(reader.readLine());\n     }\n }\n \n \n class OptionComparator implements Comparator {\n-\n-    public int compare(Object o1, Object o2) {\n+    public int compare(Object o1,\n+                       Object o2) {\n         Option opt1 = (Option) o1;\n         Option opt2 = (Option) o2;\n+\n         return -opt1.getPreferredName().compareTo(opt2.getPreferredName());\n     }\n }\n--- a/src/test/org/apache/commons/cli2/validation/ClassValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/ClassValidatorTest.java\n-/**\n- * Copyright 2003-2004 The Apache Software Foundation\n+/*\n+ * Copyright 2003-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n public class ClassValidatorTest extends TestCase {\n \n     private final static ResourceHelper resources =\n-        ResourceHelper.getResourceHelper(ClassValidatorTest.class);\n+        ResourceHelper.getResourceHelper();\n \n     private ClassValidator validator;\n \n         } catch (InvalidArgumentException ive) {\n             assertEquals(\n                 resources.getMessage(\n-                    \"ClassValidator.error.bad.classname\",\n+                    \"ClassValidator.bad.classname\",\n                     className),\n                 ive.getMessage());\n         }\n         } catch (InvalidArgumentException ive) {\n             assertEquals(\n                 resources.getMessage(\n-                    \"ClassValidator.error.bad.classname\",\n+                    \"ClassValidator.bad.classname\",\n                     className),\n                 ive.getMessage());\n         }\n         } catch (InvalidArgumentException ive) {\n             assertEquals(\n                 resources.getMessage(\n-                    \"ClassValidator.error.bad.classname\",\n+                    \"ClassValidator.bad.classname\",\n                     className),\n                 ive.getMessage());\n         }\n         } catch (InvalidArgumentException ive) {\n             assertEquals(\n                 resources.getMessage(\n-                    \"ClassValidator.error.bad.classname\",\n+                    \"ClassValidator.bad.classname\",\n                     className),\n                 ive.getMessage());\n         }\n         } catch (InvalidArgumentException ive) {\n             assertEquals(\n                 resources.getMessage(\n-                    \"ClassValidator.error.class.notfound\",\n+                    \"ClassValidator.class.notfound\",\n                     className),\n                 ive.getMessage());\n         }\n         catch (final InvalidArgumentException ive) {\n             assertEquals(\n                     resources.getMessage(\n-                            \"ClassValidator.error.class.create\",\n+                            \"ClassValidator.class.create\",\n                             className),\n                             ive.getMessage());\n         }\n         catch (final InvalidArgumentException ive) {\n             assertEquals(\n                     resources.getMessage(\n-                            \"ClassValidator.error.class.access\",\n+                            \"ClassValidator.class.access\",\n                             className,\n                             \"Class org.apache.commons.cli2.validation.ClassValidator \" +\n                             \"can not access a member of class \" +\n--- a/src/test/org/apache/commons/cli2/validation/DateValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/DateValidatorTest.java\n \n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n+\n import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n /**\n  * JUnit test case for DateValidator.\n  *\n  * @author Rob Oxspring\n  * @author John Keyes\n  */\n-public class DateValidatorTest extends TestCase {\n+public class DateValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n     public static final DateFormat D_M_YY = new SimpleDateFormat(\"d/M/yy\");\n-    public static final DateFormat YYYY_MM_YY =\n-        new SimpleDateFormat(\"yyyy-MM-dd\");\n+    public static final DateFormat YYYY_MM_YY = new SimpleDateFormat(\"yyyy-MM-dd\");\n     private List formats = Arrays.asList(new Object[] { D_M_YY, YYYY_MM_YY });\n \n-    public void testSingleFormatValidate() throws InvalidArgumentException {\n+    public void testSingleFormatValidate()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"23/12/03\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = new DateValidator(D_M_YY);\n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date)i.next()));\n-        assertFalse(i.hasNext());\n-    }\n-\n-    public void testDefaultDateFormatValidate() throws InvalidArgumentException {\n+        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultDateFormatValidate()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"23-Dec-2003\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = DateValidator.getDateInstance();\n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date)i.next()));\n-        assertFalse(i.hasNext());\n-    }\n-\n-    public void testDefaultTimeFormatValidate() throws InvalidArgumentException {\n+        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultTimeFormatValidate()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"18:00:00\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = DateValidator.getTimeInstance();\n         assertFalse(i.hasNext());\n     }\n \n-    public void testDefaultDateTimeFormatValidate() throws InvalidArgumentException {\n+    public void testDefaultDateTimeFormatValidate()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"23-Jan-2003 18:00:00\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = DateValidator.getDateTimeInstance();\n         assertFalse(i.hasNext());\n     }\n \n-    public void testDefaultValidator() throws InvalidArgumentException {\n+    public void testDefaultValidator()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"23/01/03 18:00\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = new DateValidator();\n         assertFalse(i.hasNext());\n     }\n \n-    public void testValidate() throws InvalidArgumentException {\n+    public void testValidate()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = new DateValidator(formats);\n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date)i.next()));\n-        assertEquals(\"2002-10-12\", YYYY_MM_YY.format((Date)i.next()));\n-        assertFalse(i.hasNext());\n-    }\n-\n-    public void testMinimumBounds() throws InvalidArgumentException {\n+        assertEquals(\"2003-12-23\", YYYY_MM_YY.format((Date) i.next()));\n+        assertEquals(\"2002-10-12\", YYYY_MM_YY.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testMinimumBounds()\n+        throws InvalidArgumentException {\n         final DateValidator validator = new DateValidator(formats);\n         final Calendar cal = Calendar.getInstance();\n \n             final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n             final List list = Arrays.asList(array);\n             cal.set(2002, 1, 12);\n+\n             final Date min = cal.getTime();\n             validator.setMinimum(min);\n             assertTrue(\"maximum bound is set\", validator.getMaximum() == null);\n             final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n             final List list = Arrays.asList(array);\n             cal.set(2003, 1, 12);\n+\n             final Date min = cal.getTime();\n             validator.setMinimum(min);\n \n             try {\n                 validator.validate(list);\n                 fail(\"minimum out of bounds exception not caught\");\n+            } catch (final InvalidArgumentException exp) {\n+                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                                                  new Object[] { \"2002-10-12\" }), exp.getMessage());\n             }\n-            catch (final InvalidArgumentException exp) {\n-                assertEquals(\"Out of range: 2002-10-12\", exp.getMessage());\n-            }\n-        }\n-    }\n-\n-    public void testFormats() throws InvalidArgumentException {\n+        }\n+    }\n+\n+    public void testFormats()\n+        throws InvalidArgumentException {\n         final DateValidator validator = new DateValidator(formats);\n-        assertEquals(\"date format is incorrect\", \n-                     ((SimpleDateFormat)formats.get(0)).toPattern(), \n-                     ((SimpleDateFormat)validator.getFormats()[0]).toPattern());\n-        assertEquals(\"date format is incorrect\", \n-                     ((SimpleDateFormat)formats.get(1)).toPattern(), \n-                     ((SimpleDateFormat)validator.getFormats()[1]).toPattern());\n-    }\n-\n-    public void testMaximumBounds() throws InvalidArgumentException {\n+        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(0)).toPattern(),\n+                     ((SimpleDateFormat) validator.getFormats()[0]).toPattern());\n+        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(1)).toPattern(),\n+                     ((SimpleDateFormat) validator.getFormats()[1]).toPattern());\n+    }\n+\n+    public void testMaximumBounds()\n+        throws InvalidArgumentException {\n         final DateValidator validator = new DateValidator(formats);\n         final Calendar cal = Calendar.getInstance();\n \n             final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n             final List list = Arrays.asList(array);\n             cal.set(2004, 1, 12);\n+\n             final Date max = cal.getTime();\n             validator.setMaximum(max);\n             assertTrue(\"minimum bound is set\", validator.getMinimum() == null);\n             final Object[] array = new Object[] { \"23/12/03\", \"2004-10-12\" };\n             final List list = Arrays.asList(array);\n             cal.set(2004, 1, 12);\n+\n             final Date max = cal.getTime();\n             validator.setMaximum(max);\n \n             try {\n                 validator.validate(list);\n                 fail(\"maximum out of bounds exception not caught\");\n-            }\n-            catch (final InvalidArgumentException exp) {\n-                assertEquals(\"Out of range: 2004-10-12\", exp.getMessage());\n+            } catch (final InvalidArgumentException exp) {\n+                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                        new Object[] { \"2004-10-12\" }), exp.getMessage());\n             }\n         }\n     }\n     public static Test suite() {\n         Test result = new TestSuite(DateValidatorTest.class); // default behavior\n         result = new TimeZoneTestSuite(\"EST\", result); // ensure it runs in EST timezone\n+\n         return result;\n     }\n }\n--- a/src/test/org/apache/commons/cli2/validation/EnumValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/EnumValidatorTest.java\n-/**\n- * Copyright 2004 The Apache Software Foundation\n+/*\n+ * Copyright 2004-2005 The Apache Software Foundation\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n \n import junit.framework.TestCase;\n \n-public class EnumValidatorTest extends TestCase {\n-    private final Set enumSet = new TreeSet(\n-            Arrays.asList(\n-                    new Object[]{\"red\", \"green\", \"blue\"}));\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n-    public void testValidate() throws InvalidArgumentException {\n-        final Object[] array = new Object[] { \"red\", \"green\"};\n+public class EnumValidatorTest\n+    extends TestCase {\n+    private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private final Set enumSet = new TreeSet(Arrays.asList(new Object[] { \"red\", \"green\", \"blue\" }));\n+\n+    public void testValidate()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"red\", \"green\" };\n+\n         {\n-            final List list = Arrays.asList(array);        \n+            final List list = Arrays.asList(array);\n             final EnumValidator validator = new EnumValidator(enumSet);\n             assertEquals(\"valid values are incorrect\", enumSet, validator.getValidValues());\n             validator.validate(list);\n     }\n \n     public void testNonMember() {\n-        final Object[] array = new Object[] { \"red\", \"pink\"};\n+        final Object[] array = new Object[] { \"red\", \"pink\" };\n         final List list = Arrays.asList(array);\n-        final Validator validator = new EnumValidator(enumSet);\n+        final EnumValidator validator = new EnumValidator(enumSet);\n \n-        try{\n+        try {\n             validator.validate(list);\n             fail(\"InvalidArgumentException\");\n-        }\n-        catch(InvalidArgumentException e){\n-            assertEquals(\"'pink' is not allowed.  Permitted values are:['blue', 'green', 'red']\",e.getMessage());\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,\n+                                              new Object[] { \"pink\", validator.getValuesAsString() }),\n+                         e.getMessage());\n         }\n     }\n }\n--- a/src/test/org/apache/commons/cli2/validation/NumberValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/NumberValidatorTest.java\n package org.apache.commons.cli2.validation;\n \n import java.text.NumberFormat;\n+\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n \n import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n \n /**\n  * JUnit test case for NumberValidator.\n  * @author Rob Oxspring\n  * @author John Keyes\n  */\n-public class NumberValidatorTest extends TestCase {\n-    \n-    public void testValidate_Number() throws InvalidArgumentException {\n+public class NumberValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    public void testValidate_Number()\n+        throws InvalidArgumentException {\n         final NumberFormat format = NumberFormat.getNumberInstance();\n-        \n-        final Object[] array = \n-            new Object[] { \n-            format.format(1d), \n-            format.format(1.07d), \n-            format.format(-.45d)};\n+\n+        final Object[] array =\n+            new Object[] { format.format(1d), format.format(1.07d), format.format(-.45d) };\n \n         {\n             final List list = Arrays.asList(array);\n             validator.validate(list);\n \n             final Iterator i = list.iterator();\n-            assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n-            assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n-            assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n+            assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+            assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+            assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n             assertFalse(i.hasNext());\n         }\n     }\n \n-    public void testValidate_Currency() throws InvalidArgumentException {\n+    public void testValidate_Currency()\n+        throws InvalidArgumentException {\n         NumberFormat format = NumberFormat.getCurrencyInstance();\n         final Object[] array =\n-            new Object[] {\n-                format.format(1d),\n-                format.format(1.07),\n-                format.format(-0.45)};\n+            new Object[] { format.format(1d), format.format(1.07), format.format(-0.45) };\n         final List list = Arrays.asList(array);\n-        \n+\n         final NumberValidator validator = NumberValidator.getCurrencyInstance();\n         assertEquals(\"incorrect currency format\", format, validator.getFormat());\n \n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n         assertFalse(i.hasNext());\n     }\n \n-    public void testValidate_Percent() throws InvalidArgumentException {\n+    public void testValidate_Percent()\n+        throws InvalidArgumentException {\n         final NumberFormat format = NumberFormat.getPercentInstance();\n-        \n-        final Object[] array \n-            = new Object[] { \n-                format.format(.01), \n-                format.format(1.07),\n-                format.format(-.45),\n-                format.format(0.001) };\n+\n+        final Object[] array =\n+            new Object[] {\n+                             format.format(.01), format.format(1.07), format.format(-.45),\n+                             format.format(0.001)\n+            };\n         final List list = Arrays.asList(array);\n         final Validator validator = NumberValidator.getPercentInstance();\n \n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(0.01d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(1.07d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(-.45d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(0.00001d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(0.01d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(0.00001d, ((Number) i.next()).doubleValue(), 0.0001);\n         assertFalse(i.hasNext());\n     }\n \n-    public void testValidate_Integer() throws InvalidArgumentException {\n+    public void testValidate_Integer()\n+        throws InvalidArgumentException {\n         final Object[] array = new Object[] { \"1\", \"107\", \"-45\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = NumberValidator.getIntegerInstance();\n         validator.validate(list);\n \n         final Iterator i = list.iterator();\n-        assertEquals(1d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(107d, ((Number)i.next()).doubleValue(), 0.0001);\n-        assertEquals(-45d, ((Number)i.next()).doubleValue(), 0.0001);\n+        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(107d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-45d, ((Number) i.next()).doubleValue(), 0.0001);\n         assertFalse(i.hasNext());\n     }\n \n     public void testValidate_ExcessChars() {\n-        final Object[] array = new Object[] { \"10DowningStreet\"};\n+        final Object[] array = new Object[] { \"10DowningStreet\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = NumberValidator.getIntegerInstance();\n \n-        try{\n+        try {\n             validator.validate(list);\n             fail(\"InvalidArgumentException\");\n-        }\n-        catch(InvalidArgumentException e){\n-            assertEquals(\"10DowningStreet\",e.getMessage());\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"10DowningStreet\", e.getMessage());\n         }\n     }\n \n         try {\n             validator.validate(list);\n             fail(\"107 too big\");\n-        }\n-        catch (InvalidArgumentException ive) {\n-            assertEquals(\"Out of range: 107\", ive.getMessage());\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                              \"107\"), ive.getMessage());\n         }\n     }\n \n         try {\n             validator.validate(list);\n             fail(\"1 too small\");\n-        }\n-        catch (InvalidArgumentException ive) {\n-            assertEquals(\"Out of range: 1\", ive.getMessage());\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                              \"1\"), ive.getMessage());\n         }\n     }\n }\n--- a/src/test/org/apache/commons/cli2/validation/UrlValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/UrlValidatorTest.java\n \n import java.net.MalformedURLException;\n import java.net.URL;\n+\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n \n import junit.framework.TestCase;\n \n-public class UrlValidatorTest extends TestCase {\n-    \n-    public void testValidate() throws InvalidArgumentException, MalformedURLException {\n-        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\"};\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class UrlValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    public void testValidate()\n+        throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = new UrlValidator();\n \n         assertFalse(i.hasNext());\n     }\n \n-    public void testMalformedURL() throws InvalidArgumentException, MalformedURLException {\n-        final Object[] array = new Object[] { \"www.apache.org\"};\n+    public void testMalformedURL()\n+        throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"www.apache.org\" };\n         final List list = Arrays.asList(array);\n         final Validator validator = new UrlValidator();\n \n         try {\n             validator.validate(list);\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,\n+                                              new Object[] { \"www.apache.org\" }), e.getMessage());\n         }\n-        catch(InvalidArgumentException e){\n-            assertEquals(\"Cannot understand url: www.apache.org\",e.getMessage());\n-        }\n-        \n     }\n \n     public void testBadProtocol() {\n         {\n-            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\"};\n+            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n             final List list = Arrays.asList(array);\n             final UrlValidator validator = new UrlValidator();\n             validator.setProtocol(\"http\");\n-    \n+\n             assertEquals(\"incorrect protocol\", \"http\", validator.getProtocol());\n-            try{\n+\n+            try {\n                 validator.validate(list);\n                 fail(\"Expected InvalidArgumentException\");\n-            }\n-            catch(InvalidArgumentException e){\n-                assertEquals(\"file:///etc\",e.getMessage());\n+            } catch (InvalidArgumentException e) {\n+                assertEquals(\"file:///etc\", e.getMessage());\n             }\n         }\n+\n         {\n-            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\"};\n+            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n             final List list = Arrays.asList(array);\n             final UrlValidator validator = new UrlValidator(\"http\");\n-    \n-            try{\n+\n+            try {\n                 validator.validate(list);\n                 fail(\"Expected InvalidArgumentException\");\n-            }\n-            catch(InvalidArgumentException e){\n-                assertEquals(\"file:///etc\",e.getMessage());\n+            } catch (InvalidArgumentException e) {\n+                assertEquals(\"file:///etc\", e.getMessage());\n             }\n         }\n     }", "timestamp": 1126578724, "metainfo": ""}