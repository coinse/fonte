{"sha": "aa812e42a784bb551e3cda70078c2c1ed6147b20", "log": "Merge branch 'master' of https://github.com/mingfai/jsoup into mingfai-master", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n         Map<Character, String> map = escapeMode.getMap();\n \n-        for (int pos = 0; pos < string.length(); pos++) {\n-            Character c = string.charAt(pos);\n-            if (map.containsKey(c))\n-                accum.append('&').append(map.get(c)).append(';');\n-            else if (encoder.canEncode(c))\n-                accum.append(c.charValue());\n+        //@see \"http://stackoverflow.com/questions/1527856/how-can-i-iterate-through-the-unicode-codepoints-of-a-java-string\"\n+        final int length = string.length();\n+        for (int offset = 0; offset < length; ) {\n+            final int codePoint = string.codePointAt(offset);\n+            char[] chars = Character.toChars(codePoint);\n+\n+            if (chars.length==1 && map.containsKey(chars[0]))\n+                accum.append('&').append(map.get(chars[0])).append(';');\n+            else if (encoder.canEncode(new String(chars)))\n+                accum.append(new String(chars));\n             else\n-                accum.append(\"&#\").append((int) c).append(';');\n+                accum.append(\"&#\").append(codePoint).append(';');\n+\n+            offset += Character.charCount(codePoint);\n         }\n \n         return accum.toString();\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         selfClosingFlagAcknowledged = true;\n     }\n \n-    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return replacementChar;\n+                return new char[]{replacementChar};\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n-                return (char) charval;\n+                return Character.toChars(charval);\n             }\n         } else { // named\n             // get as many letters as possible, and look for matching entities.\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return Entities.getCharacterByName(nameRef);\n+            return new char[]{Entities.getCharacterByName(nameRef)};\n         }\n     }\n \n             builder.append(reader.consumeTo('&'));\n             if (reader.matches('&')) {\n                 reader.consume();\n-                Character c = consumeCharacterReference(null, inAttribute);\n-                if (c == null)\n+                char[] c = consumeCharacterReference(null, inAttribute);\n+                if (c == null || c.length==0)\n                     builder.append('&');\n                 else\n                     builder.append(c);\n         }\n         return builder.toString();\n     }\n-}\n+}\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n     CharacterReferenceInData {\n         // from & in data\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n+            char[] c = t.consumeCharacterReference(null, false);\n+            if (c == null||c.length==0)\n                 t.emit('&');\n             else\n-                t.emit(c);\n+                t.emit(new String(c));\n             t.transition(Data);\n         }\n     },\n     },\n     CharacterReferenceInRcdata {\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n+            char[] c = t.consumeCharacterReference(null, false);\n+            if (c == null||c.length==0)\n                 t.emit('&');\n             else\n-                t.emit(c);\n+                t.emit(new String(c));\n             t.transition(Rcdata);\n         }\n     },\n                 case eof: // should emit pending tag?\n                     t.eofError(this);\n                     t.transition(Data);\n-                // no default, as covered with above consumeToAny\n+                    // no default, as covered with above consumeToAny\n             }\n         }\n     },\n                 anythingElse(t, r);\n             }\n         }\n-        \n+\n         private void anythingElse(Tokeniser t, CharacterReader r) {\n             t.emit(\"</\" + t.dataBuffer.toString());\n             t.transition(ScriptDataEscaped);\n                 case '<':\n                     t.error(this);\n                     t.tagPending.appendAttributeName(c);\n-                // no default, as covered in consumeToAny\n+                    // no default, as covered in consumeToAny\n             }\n         }\n     },\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\"', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\\'', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('>', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n-}\n+}\n--- a/src/test/java/org/jsoup/nodes/AttributeTest.java\n+++ b/src/test/java/org/jsoup/nodes/AttributeTest.java\n package org.jsoup.nodes;\n \n-import static org.junit.Assert.*;\n+import org.junit.Test;\n \n-import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n \n public class AttributeTest {\n     @Test public void html() {\n         assertEquals(\"key=\\\"value &amp;\\\"\", attr.html());\n         assertEquals(attr.html(), attr.toString());\n     }\n+\n+    @Test public void testWithSupplementaryCharacterInAttributeKeyAndValue() {\n+        String s = new String(Character.toChars(135361));\n+        Attribute attr = new Attribute(s, \"A\" + s + \"B\");\n+        assertEquals(s + \"=\\\"A\" + s + \"B\\\"\", attr.html());\n+        assertEquals(attr.html(), attr.toString());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n         assertEquals(\"Hello &amp;&lt;&gt; &#197; &#229; &#960; &#26032; there &#190; &#169;\", escapedAsciiXhtml);\n         assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; \u03c0 \u65b0 there &frac34; &copy;\", escapedUtf);\n         // odd that it's defined as aring in base but angst in full\n+    }\n+\n+    @Test public void escapeSupplementaryCharacter(){\n+        String text = new String(Character.toChars(135361));\n+        String escapedAscii = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.base);\n+        assertEquals(\"&#135361;\", escapedAscii);\n+        String escapedUtf = Entities.escape(text, Charset.forName(\"UTF-8\").newEncoder(), Entities.EscapeMode.base);\n+        assertEquals(text, escapedUtf);\n     }\n \n     @Test public void unescape() {\n--- a/src/test/java/org/jsoup/nodes/TextNodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/TextNodeTest.java\n \n         assertEquals(\"Hello <b>there</b>\", TextUtil.stripNewlines(div.html())); // not great that we get \\n<b>there there... must correct\n     }\n+\n+    @Test public void testWithSupplementaryCharacter(){\n+        Document doc = Jsoup.parse(new String(Character.toChars(135361)));\n+        TextNode t = doc.body().textNodes().get(0);\n+        assertEquals(new String(Character.toChars(135361)), t.outerHtml().trim());\n+    }\n }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.junit.Test;\n+\n import static org.junit.Assert.*;\n \n /**\n- Tests that the selector selects correctly.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * Tests that the selector selects correctly.\n+ *\n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ */\n public class SelectorTest {\n     @Test public void testByTag() {\n         Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\").select(\"div\");\n         assertEquals(\"li\", containers.get(1).tagName());\n         assertEquals(\"123\", containers.get(1).text());\n     }\n+\n+    @Test public void selectSupplementaryCharacter() {\n+        String s = new String(Character.toChars(135361));\n+        Document doc = Jsoup.parse(\"<div k\" + s + \"='\" + s + \"'>^\" + s +\"$/div>\");\n+        assertEquals(\"div\", doc.select(\"div[k\" + s + \"]\").first().tagName());\n+        assertEquals(\"div\", doc.select(\"div:containsOwn(\" + s + \")\").first().tagName());\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n         private Charset charset = Charset.forName(\"UTF-8\");\n         private CharsetEncoder charsetEncoder = charset.newEncoder();\n         private boolean prettyPrint = true;\n+        private boolean outline = false;\n         private int indentAmount = 1;\n \n         public OutputSettings() {}\n          */\n         public OutputSettings prettyPrint(boolean pretty) {\n             prettyPrint = pretty;\n+            return this;\n+        }\n+        \n+        /**\n+         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n+         * all tags as block.\n+         * @return if outline mode is enabled.\n+         */\n+        public boolean outline() {\n+            return outline;\n+        }\n+        \n+        /**\n+         * Enable or disable HTML outline mode.\n+         * @param outlineMode new outline setting\n+         * @return this, for chaining\n+         */\n+        public OutputSettings outline(boolean outlineMode) {\n+            outline = outlineMode;\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n+        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n             indent(accum, depth, out);\n         accum\n                 .append(\"<\")\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n-            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n+            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n+                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n+            )))\n                 indent(accum, depth, out);\n             accum.append(\"</\").append(tagName()).append(\">\");\n         }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             html = normaliseWhitespace(html);\n         }\n \n-        if (out.prettyPrint() && siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank())\n+        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n             indent(accum, depth, out);\n         accum.append(html);\n     }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n     Element insert(Token.StartTag startTag) {\n         // handle empty unknown tags\n-        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n-        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n+        if (startTag.isSelfClosing()) {\n             Element el = insertEmpty(startTag);\n-            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            stack.add(el);\n+            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n         Element el = new Element(tag, baseUri, startTag.attributes);\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n-            tokeniser.acknowledgeSelfClosingFlag();\n-            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+            if (tag.isKnownTag()) {\n+                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n+            } else {\n+                // unknown tag, remember this is self closing for output\n                 tag.setSelfClosing();\n+                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n+            }\n         }\n         return el;\n     }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     }\n \n     /**\n+     * Parse a fragment of XML into a list of nodes.\n+     *\n+     * @param fragmentXml the fragment of XML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @return list of nodes parsed from the input XML.\n+     */\n+    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n+        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+    }\n+\n+    /**\n      * Parse a fragment of HTML into the {@code body} of a Document.\n      *\n      * @param bodyHtml fragment of HTML\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n             \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n-            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n             \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n     };\n     private static final String[] inlineTags = {\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n-            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n+            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n+            \"ins\", \"del\", \"s\"\n     };\n     private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.nodes.*;\n \n import java.util.Iterator;\n+import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n             }\n         }\n     }\n+\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n+        initialiseParse(inputFragment, baseUri, errors);\n+        runParser();\n+        return doc.childNodes();\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n         assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>Hello <span>jsoup <span>users</span></span></p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n     }\n+    \n+    @Test public void testFormatOutline() {\n+        Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n+        doc.outputSettings().outline(true);\n+        assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>\\n    Hello \\n    <span>\\n     jsoup \\n     <span>users</span>\\n    </span>\\n   </p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n+    }\n \n     @Test public void testSetIndent() {\n         Document doc = Jsoup.parse(\"<div><p>Hello\\nthere</p></div>\");\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n     }\n \n     @Test public void handlesKnownEmptyBlocks() {\n-        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.\n-        String h = \"<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two\";\n-        Document doc = Jsoup.parse(h);\n-        Element div1 = doc.getElementById(\"1\");\n-        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...\n-        assertTrue(doc.select(\"hr\").first().children().isEmpty());\n-        assertTrue(doc.select(\"hr\").last().children().isEmpty());\n-        assertTrue(doc.select(\"img\").first().children().isEmpty());\n-        assertTrue(doc.select(\"img\").last().children().isEmpty());\n+        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n+        String h = \"<div id='1' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<div id=\\\"1\\\"></div><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void handlesSolidusAtAttributeEnd() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URISyntaxException;\n+import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotSame;\n         assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n         assertEquals(\"#comment\", doc.childNode(2).nodeName());\n     }\n+\n+    @Test public void xmlFragment() {\n+        String xml = \"<one src='/foo/' />Two<three><four /></three>\";\n+        List<Node> nodes = Parser.parseXmlFragment(xml, \"http://example.com/\");\n+        assertEquals(3, nodes.size());\n+\n+        assertEquals(\"http://example.com/foo/\", nodes.get(0).absUrl(\"src\"));\n+        assertEquals(\"one\", nodes.get(0).nodeName());\n+        assertEquals(\"Two\", ((TextNode)nodes.get(1)).text());\n+    }\n }", "timestamp": 1359258089, "metainfo": ""}