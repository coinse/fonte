{"sha": "bbca7db20b9a45fb3d8efb29447349ed8593649c", "log": "Integrated new single-pass selector evaluators, contributed by knz (Anton Kazennikov).", "commit": "\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n      * @param sep string to place between strings\n      * @return joined string\n      */\n-    public static String join(Collection<String> strings, String sep) {\n+    public static String join(Collection strings, String sep) {\n         return join(strings.iterator(), sep);\n     }\n \n      * @param sep string to place between strings\n      * @return joined string\n      */\n-    public static String join(Iterator<String> strings, String sep) {\n+    public static String join(Iterator strings, String sep) {\n         if (!strings.hasNext())\n             return \"\";\n \n-        String start = strings.next();\n+        String start = strings.next().toString();\n         if (!strings.hasNext()) // only one, avoid builder\n             return start;\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Collector;\n import org.jsoup.select.Elements;\n+import org.jsoup.select.Evaluator;\n import org.jsoup.select.Selector;\n \n import java.util.*;\n     }\n \n     /**\n-     * Tests if this element has a class.\n+     * Tests if this element has a class. Case insensitive.\n      * @param className name of class to check for\n      * @return true if it does, false if not\n      */\n     public boolean hasClass(String className) {\n-        return classNames().contains(className);\n+        Set<String> classNames = classNames();\n+        for (String name : classNames) {\n+            if (className.equalsIgnoreCase(name))\n+                return true;\n+        }\n+        return false;\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n      * @return true if the next characters match.\n      */\n     public boolean matches(String seq) {\n-        /*int count = seq.length();\n-        if (count > remainingLength())\n-            return false;\n-\n-        while (--count >= 0) {\n-            if (Character.toLowerCase(seq.charAt(count)) != Character.toLowerCase(queue.charAt(pos+count)))\n-                return false;\n-        }\n-        return true;*/\n-    \t\n-    \treturn queue.regionMatches(true, pos, seq, 0, seq.length());\n+        return queue.regionMatches(true, pos, seq, 0, seq.length());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n         \n         for (Protocol protocol : protocols) {\n             String prot = protocol.toString() + \":\";\n-            if (value.toString().toLowerCase().startsWith(prot)) {\n+            if (value.toLowerCase().startsWith(prot)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/org/jsoup/select/Collector.java\n+++ b/src/main/java/org/jsoup/select/Collector.java\n package org.jsoup.select;\n \n import org.jsoup.nodes.Element;\n-import org.jsoup.nodes.Evaluator;\n import org.jsoup.nodes.Node;\n \n /**\n      */\n     public static Elements collect (Evaluator eval, Element root) {\n         Elements elements = new Elements();\n-        new NodeTraversor(new Accumulator(elements, eval)).traverse(root);\n+        new NodeTraversor(new Accumulator(root, elements, eval)).traverse(root);\n         return elements;\n     }\n \n     private static class Accumulator implements NodeVisitor {\n+        private final Element root;\n         private final Elements elements;\n         private final Evaluator eval;\n \n-        Accumulator(Elements elements, Evaluator eval) {\n+        Accumulator(Element root, Elements elements, Evaluator eval) {\n+            this.root = root;\n             this.elements = elements;\n             this.eval = eval;\n         }\n         public void head(Node node, int depth) {\n             if (node instanceof Element) {\n                 Element el = (Element) node;\n-                if (eval.matches(el, el))\n+                if (eval.matches(root, el))\n                     elements.add(el);\n             }\n         }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n+package org.jsoup.select;\n+\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Element;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\n+/**\n+ * Evaluates that an element matches the selector.\n+ */\n+public abstract class Evaluator {\n+    protected Evaluator() {\n+    }\n+\n+    /**\n+     * Test if the element meets the evaluator's requirements.\n+     *\n+     * @param root    Root of the matching subtree\n+     * @param element tested element\n+     */\n+    public abstract boolean matches(Element root, Element element);\n+\n+    /**\n+     * Evaluator for tag name\n+     */\n+    public static final class Tag extends Evaluator {\n+        private String tagName;\n+\n+        public Tag(String tagName) {\n+            this.tagName = tagName;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.tagName().equals(tagName));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s\", tagName);\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for element id\n+     */\n+    public static final class Id extends Evaluator {\n+        private String id;\n+\n+        public Id(String id) {\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (id.equals(element.id()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"#%s\", id);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for element class\n+     */\n+    public static final class Class extends Evaluator {\n+        private String className;\n+\n+        public Class(String className) {\n+            this.className = className;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.hasClass(className));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\".%s\", className);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attibute name matching\n+     */\n+    public static final class Attribute extends Evaluator {\n+        private String key;\n+\n+        public Attribute(String key) {\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s]\", key);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name prefix matching\n+     */\n+    public static final class AttributeStarting extends Evaluator {\n+        private String keyPrefix;\n+\n+        public AttributeStarting(String keyPrefix) {\n+            this.keyPrefix = keyPrefix;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n+            for (org.jsoup.nodes.Attribute attribute : values) {\n+                if (attribute.getKey().startsWith(keyPrefix))\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[^%s]\", keyPrefix);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name/value matching\n+     */\n+    public static final class AttributeWithValue extends AttributeKeyPair {\n+        public AttributeWithValue(String key, String value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s=%s]\", key, value);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name != value matching\n+     */\n+    public static final class AttributeWithValueNot extends AttributeKeyPair {\n+        public AttributeWithValueNot(String key, String value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return !value.equalsIgnoreCase(element.attr(key));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s!=%s]\", key, value);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name/value matching (value prefix)\n+     */\n+    public static final class AttributeWithValueStarting extends AttributeKeyPair {\n+        public AttributeWithValueStarting(String key, String value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key) && element.attr(key).toLowerCase().startsWith(value); // value is lower case already\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s^=%s]\", key, value);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name/value matching (value ending)\n+     */\n+    public static final class AttributeWithValueEnding extends AttributeKeyPair {\n+        public AttributeWithValueEnding(String key, String value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key) && element.attr(key).toLowerCase().endsWith(value); // value is lower case\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s$=%s]\", key, value);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name/value matching (value containing)\n+     */\n+    public static final class AttributeWithValueContaining extends AttributeKeyPair {\n+        public AttributeWithValueContaining(String key, String value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key) && element.attr(key).toLowerCase().contains(value); // value is lower case\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s*=%s]\", key, value);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for attribute name/value matching (value regex matching)\n+     */\n+    public static final class AttributeWithValueMatching extends Evaluator {\n+        String key;\n+        Pattern pattern;\n+\n+        public AttributeWithValueMatching(String key, Pattern pattern) {\n+            this.key = key.trim().toLowerCase();\n+            this.pattern = pattern;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s~=%s]\", key, pattern.toString());\n+        }\n+\n+    }\n+\n+    /**\n+     * Abstract evaluator for attribute name/value matching\n+     */\n+    public abstract static class AttributeKeyPair extends Evaluator {\n+        String key;\n+        String value;\n+\n+        public AttributeKeyPair(String key, String value) {\n+            Validate.notEmpty(key);\n+            Validate.notEmpty(value);\n+\n+            this.key = key.trim().toLowerCase();\n+            this.value = value.trim().toLowerCase();\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for any / all element matching\n+     */\n+    public static final class AllElements extends Evaluator {\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"*\";\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching by sibling index number (e < idx)\n+     */\n+    public static final class IndexLessThan extends IndexEvaluator {\n+        public IndexLessThan(int index) {\n+            super(index);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.elementSiblingIndex() < index;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":lt(%d)\", index);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for matching by sibling index number (e > idx)\n+     */\n+    public static final class IndexGreaterThan extends IndexEvaluator {\n+        public IndexGreaterThan(int index) {\n+            super(index);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.elementSiblingIndex() > index;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":gt(%d)\", index);\n+        }\n+\n+    }\n+\n+    /**\n+     * Evaluator for matching by sibling index number (e = idx)\n+     */\n+    public static final class IndexEquals extends IndexEvaluator {\n+        public IndexEquals(int index) {\n+            super(index);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return element.elementSiblingIndex() == index;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":eq(%d)\", index);\n+        }\n+\n+    }\n+\n+    /**\n+     * Abstract evaluator for sibling index matching\n+     *\n+     * @author ant\n+     */\n+    public abstract static class IndexEvaluator extends Evaluator {\n+        int index;\n+\n+        public IndexEvaluator(int index) {\n+            this.index = index;\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching Element (and its descendents) text\n+     */\n+    public static final class ContainsText extends Evaluator {\n+        private String searchText;\n+\n+        public ContainsText(String searchText) {\n+            this.searchText = searchText.toLowerCase();\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.text().toLowerCase().contains(searchText));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":contains(%s\", searchText);\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching Element's own text\n+     */\n+    public static final class ContainsOwnText extends Evaluator {\n+        private String searchText;\n+\n+        public ContainsOwnText(String searchText) {\n+            this.searchText = searchText.toLowerCase();\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.ownText().toLowerCase().contains(searchText));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":containsOwn(%s\", searchText);\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching Element (and its descendents) text with regex\n+     */\n+    public static final class Matches extends Evaluator {\n+        private Pattern pattern;\n+\n+        public Matches(Pattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            Matcher m = pattern.matcher(element.text());\n+            return m.find();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":matches(%s\", pattern);\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching Element's own text with regex\n+     */\n+    public static final class MatchesOwn extends Evaluator {\n+        private Pattern pattern;\n+\n+        public MatchesOwn(Pattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            Matcher m = pattern.matcher(element.ownText());\n+            return m.find();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":matchesOwn(%s\", pattern);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n+package org.jsoup.select;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.parser.TokenQueue;\n+import org.jsoup.select.selectors.*;\n+\n+/**\n+ * Parses a CSS selector into an Evaluator tree.\n+ */\n+class QueryParser {\n+    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n+\n+    private TokenQueue tq;\n+    private String query;\n+    private List<Evaluator> evals = new ArrayList<Evaluator>();\n+\n+    /**\n+     * Create a new QueryParser.\n+     * @param query CSS query\n+     */\n+    private QueryParser(String query) {\n+        this.query = query;\n+        this.tq = new TokenQueue(query);\n+    }\n+\n+    /**\n+     * Parse a CSS query into an Evaluator.\n+     * @param query CSS query\n+     * @return Evaluator\n+     */\n+    public static Evaluator parse(String query) {\n+        QueryParser p = new QueryParser(query);\n+        return p.parse();\n+    }\n+\n+    /**\n+     * Parse the query\n+     * @return Evaluator\n+     */\n+    Evaluator parse() {\n+        tq.consumeWhitespace();\n+\n+        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n+            evals.add(new RootSelector());\n+            combinator(tq.consume());\n+        } else {\n+            findElements();\n+        }\n+\n+        while (!tq.isEmpty()) {\n+            // hierarchy and extras\n+            boolean seenWhite = tq.consumeWhitespace();\n+\n+            if (tq.matchChomp(\",\")) { // group or\n+                OrSelector or = new OrSelector(evals);\n+                evals.clear();\n+                evals.add(or);\n+                while (!tq.isEmpty()) {\n+                    String subQuery = tq.chompTo(\",\");\n+                    or.add(parse(subQuery));\n+                }\n+            } else if (tq.matchesAny(combinators)) {\n+                combinator(tq.consume());\n+            } else if (seenWhite) {\n+                combinator(' ');\n+            } else { // E.class, E#id, E[attr] etc. AND\n+                findElements(); // take next el, #. etc off queue\n+            }\n+        }\n+\n+        if (evals.size() == 1)\n+            return evals.get(0);\n+\n+        return new AndSelector(evals);\n+    }\n+\n+    private void combinator(char combinator) {\n+        tq.consumeWhitespace();\n+        String subQuery = consumeSubQuery(); // support multi > childs\n+        Evaluator e;\n+\n+        if (evals.size() == 1)\n+            e = evals.get(0);\n+        else\n+            e = new AndSelector(evals);\n+        evals.clear();\n+        Evaluator f = parse(subQuery);\n+\n+        if (combinator == '>')\n+            evals.add(BasicSelector.and(f, new ImmediateParentSelector(e)));\n+        else if (combinator == ' ')\n+            evals.add(BasicSelector.and(f, new ParentSelector(e)));\n+        else if (combinator == '+')\n+            evals.add(BasicSelector.and(f, new ImmediatePreviousSiblingSelector(e)));\n+        else if (combinator == '~')\n+            evals.add(BasicSelector.and(f, new PreviousSiblingSelector(e)));\n+        else\n+            throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n+    }\n+\n+    private String consumeSubQuery() {\n+        StringBuilder sq = new StringBuilder();\n+        while (!tq.isEmpty()) {\n+            if (tq.matches(\"(\"))\n+                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n+            else if (tq.matches(\"[\"))\n+                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n+            else if (tq.matchesAny(combinators))\n+                break;\n+            else\n+                sq.append(tq.consume());\n+        }\n+        return sq.toString();\n+    }\n+\n+    private void findElements() {\n+        if (tq.matchChomp(\"#\"))\n+            byId();\n+        else if (tq.matchChomp(\".\"))\n+            byClass();\n+        else if (tq.matchesWord())\n+            byTag();\n+        else if (tq.matches(\"[\"))\n+            byAttribute();\n+        else if (tq.matchChomp(\"*\"))\n+            allElements();\n+        else if (tq.matchChomp(\":lt(\"))\n+            indexLessThan();\n+        else if (tq.matchChomp(\":gt(\"))\n+            indexGreaterThan();\n+        else if (tq.matchChomp(\":eq(\"))\n+            indexEquals();\n+        else if (tq.matches(\":has(\"))\n+            has();\n+        else if (tq.matches(\":contains(\"))\n+            contains(false);\n+        else if (tq.matches(\":containsOwn(\"))\n+            contains(true);\n+        else if (tq.matches(\":matches(\"))\n+            matches(false);\n+        else if (tq.matches(\":matchesOwn(\"))\n+            matches(true);\n+        else if (tq.matches(\":not(\"))\n+            not();\n+        else // unhandled\n+            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n+\n+    }\n+\n+    private void byId() {\n+        String id = tq.consumeCssIdentifier();\n+        Validate.notEmpty(id);\n+        evals.add(new Evaluator.Id(id));\n+    }\n+\n+    private void byClass() {\n+        String className = tq.consumeCssIdentifier();\n+        Validate.notEmpty(className);\n+        evals.add(new Evaluator.Class(className.trim().toLowerCase()));\n+    }\n+\n+    private void byTag() {\n+        String tagName = tq.consumeElementSelector();\n+        Validate.notEmpty(tagName);\n+\n+        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n+        if (tagName.contains(\"|\"))\n+            tagName = tagName.replace(\"|\", \":\");\n+\n+        evals.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n+    }\n+\n+    private void byAttribute() {\n+        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n+        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n+        Validate.notEmpty(key);\n+        cq.consumeWhitespace();\n+\n+        if (cq.isEmpty()) {\n+            if (key.startsWith(\"^\"))\n+                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n+            else\n+                evals.add(new Evaluator.Attribute(key));\n+        } else {\n+            if (cq.matchChomp(\"=\"))\n+                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n+\n+            else if (cq.matchChomp(\"!=\"))\n+                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n+\n+            else if (cq.matchChomp(\"^=\"))\n+                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n+\n+            else if (cq.matchChomp(\"$=\"))\n+                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n+\n+            else if (cq.matchChomp(\"*=\"))\n+                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n+\n+            else if (cq.matchChomp(\"~=\"))\n+                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n+            else\n+                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n+        }\n+    }\n+\n+    private void allElements() {\n+        evals.add(new Evaluator.AllElements());\n+    }\n+\n+    // pseudo selectors :lt, :gt, :eq\n+    private void indexLessThan() {\n+        evals.add(new Evaluator.IndexLessThan(consumeIndex()));\n+    }\n+\n+    private void indexGreaterThan() {\n+        evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));\n+    }\n+\n+    private void indexEquals() {\n+        evals.add(new Evaluator.IndexEquals(consumeIndex()));\n+    }\n+\n+    private int consumeIndex() {\n+        String indexS = tq.chompTo(\")\").trim();\n+        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n+        return Integer.parseInt(indexS);\n+    }\n+\n+    // pseudo selector :has(el)\n+    private void has() {\n+        tq.consume(\":has\");\n+        String subQuery = tq.chompBalanced('(', ')');\n+        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n+        evals.add(new HasSelector(parse(subQuery)));\n+    }\n+\n+    // pseudo selector :contains(text), containsOwn(text)\n+    private void contains(boolean own) {\n+        tq.consume(own ? \":containsOwn\" : \":contains\");\n+        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n+        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n+        if (own)\n+            evals.add(new Evaluator.ContainsOwnText(searchText));\n+        else\n+            evals.add(new Evaluator.ContainsText(searchText));\n+    }\n+\n+    // :matches(regex), matchesOwn(regex)\n+    private void matches(boolean own) {\n+        tq.consume(own ? \":matchesOwn\" : \":matches\");\n+        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n+        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n+\n+        if (own)\n+            evals.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n+        else\n+            evals.add(new Evaluator.Matches(Pattern.compile(regex)));\n+    }\n+\n+    // :not(selector)\n+    private void not() {\n+        tq.consume(\":not\");\n+        String subQuery = tq.chompBalanced('(', ')');\n+        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n+\n+        evals.add(new NotSelector(parse(subQuery)));\n+    }\n+}\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n package org.jsoup.select;\n \n-\n-import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Element;\n-import org.jsoup.parser.TokenQueue;\n \n import java.util.Collection;\n import java.util.LinkedHashSet;\n \n /**\n- CSS-like element selector, that finds elements matching a query.\n-\n- <h2>Selector syntax</h2>\n- A selector is a chain of simple selectors, seperated by combinators. Selectors are case insensitive (including against\n- elements, attributes, and attribute values).\n- <p/>\n- The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n- is equivalent).\n-\n- <table>\n-  <tr><th>Pattern</th><th>Matches</th><th>Example</th></tr>\n-  <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n-  <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n-  <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n-  <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n-  <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n-  <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n-  <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n-  <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n-  <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n-  <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n-  <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n-  <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n-  <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n-  <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n-  <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n-  <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n-  <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n-  <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n-  <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n-  <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n-  <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n-  <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n-  <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n-  <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n-  <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class</td></tr>\n-  <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n-  <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n-  <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n-  <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n-  <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n-  </table>\n-\n- @see Element#select(String)\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * CSS-like element selector, that finds elements matching a query.\n+ * <p/>\n+ * <h2>Selector syntax</h2>\n+ * A selector is a chain of simple selectors, seperated by combinators. Selectors are case insensitive (including against\n+ * elements, attributes, and attribute values).\n+ * <p/>\n+ * The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n+ * is equivalent).\n+ * <p/>\n+ * <table>\n+ * <tr><th>Pattern</th><th>Matches</th><th>Example</th></tr>\n+ * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n+ * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n+ * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n+ * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n+ * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n+ * <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n+ * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n+ * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n+ * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n+ * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n+ * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n+ * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n+ * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n+ * <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n+ * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n+ * <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n+ * <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n+ * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n+ * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n+ * <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n+ * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n+ * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n+ * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n+ * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class</td></tr>\n+ * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n+ * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n+ * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n+ * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n+ * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n+ * </table>\n+ *\n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ * @see Element#select(String)\n+ */\n public class Selector {\n-    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n+    private final Evaluator evaluator;\n     private final Element root;\n-    private final LinkedHashSet<Element> elements; // LHS for unique and ordered elements\n-    private final String query;\n-    private final TokenQueue tq;\n \n     private Selector(String query, Element root) {\n         Validate.notNull(query);\n         Validate.notEmpty(query);\n         Validate.notNull(root);\n \n-        this.elements = new LinkedHashSet<Element>();\n-        this.query = query;\n+        this.evaluator = QueryParser.parse(query);\n         this.root = root;\n-        this.tq = new TokenQueue(query);\n     }\n \n     /**\n-     Find elements matching selector.\n-     @param query CSS selector\n-     @param root root element to descend into\n-     @return matching elements, empty if not\n+     * Find elements matching selector.\n+     *\n+     * @param query CSS selector\n+     * @param root  root element to descend into\n+     * @return matching elements, empty if not\n      */\n     public static Elements select(String query, Element root) {\n         return new Selector(query, root).select();\n     }\n \n     /**\n-     Find elements matching selector.\n-     @param query CSS selector\n-     @param roots root elements to descend into\n-     @return matching elements, empty if not\n+     * Find elements matching selector.\n+     *\n+     * @param query CSS selector\n+     * @param roots root elements to descend into\n+     * @return matching elements, empty if not\n      */\n     public static Elements select(String query, Iterable<Element> roots) {\n         Validate.notEmpty(query);\n     }\n \n     private Elements select() {\n-        tq.consumeWhitespace();\n-        \n-        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n-            elements.add(root);\n-            combinator(tq.consume());\n-        } else if (tq.matches(\":has(\")) {\n-            elements.addAll(root.getAllElements());\n-        } else {\n-            addElements(findElements()); // chomp first element matcher off queue \n-        }            \n-               \n-        while (!tq.isEmpty()) {\n-            // hierarchy and extras\n-            boolean seenWhite = tq.consumeWhitespace();\n-            \n-            if (tq.matchChomp(\",\")) { // group or\n-                while (!tq.isEmpty()) {\n-                    String subQuery = tq.chompTo(\",\");\n-                    elements.addAll(select(subQuery, root));\n-                }\n-            } else if (tq.matchesAny(combinators)) {\n-                combinator(tq.consume());\n-            } else if (seenWhite) {\n-                combinator(' ');\n-            } else { // E.class, E#id, E[attr] etc. AND\n-                Elements candidates = findElements(); // take next el, #. etc off queue\n-                intersectElements(filterForSelf(elements, candidates));\n-            }\n-        }\n-        return new Elements(elements);\n-    }\n-    \n-    private void combinator(char combinator) {\n-        tq.consumeWhitespace();\n-        String subQuery = consumeSubQuery(); // support multi > childs\n-        \n-        Elements output;\n-        if (combinator == '>')\n-            output = filterForChildren(elements, select(subQuery, elements));\n-        else if (combinator == ' ')\n-            output = filterForDescendants(elements, select(subQuery, elements));\n-        else if (combinator == '+')\n-            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n-        else if (combinator == '~')\n-            output = filterForGeneralSiblings(elements, select(subQuery, root));\n-        else\n-            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n-        \n-        elements.clear(); elements.addAll(output);\n-    }\n-\n-    private String consumeSubQuery() {\n-        StringBuilder sq = new StringBuilder();\n-        while (!tq.isEmpty()) {\n-            if (tq.matches(\"(\"))\n-                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n-            else if (tq.matches(\"[\"))\n-                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n-            else if (tq.matchesAny(combinators))\n-                break;\n-            else\n-                sq.append(tq.consume());\n-        }\n-        return sq.toString();\n-    }\n-    \n-    private Elements findElements() {\n-        if (tq.matchChomp(\"#\")) {\n-            return byId();\n-        } else if (tq.matchChomp(\".\")) {\n-            return byClass();\n-        } else if (tq.matchesWord()) {\n-            return byTag();\n-        } else if (tq.matches(\"[\")) {\n-            return byAttribute();\n-        } else if (tq.matchChomp(\"*\")) {\n-            return allElements();\n-        } else if (tq.matchChomp(\":lt(\")) {\n-            return indexLessThan();\n-        } else if (tq.matchChomp(\":gt(\")) {\n-            return indexGreaterThan();\n-        } else if (tq.matchChomp(\":eq(\")) {\n-            return indexEquals();\n-        } else if (tq.matches(\":has(\")) {\n-            return has();\n-        } else if (tq.matches(\":contains(\")) {\n-            return contains(false);\n-        } else if (tq.matches(\":containsOwn(\")) {\n-            return contains(true);\n-        } else if (tq.matches(\":matches(\")) {\n-            return matches(false);\n-        } else if (tq.matches(\":matchesOwn(\")) {\n-            return matches(true);\n-        } else if (tq.matches(\":not(\")) {\n-            return not();\n-        } else { // unhandled\n-            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n-        }\n-    }\n-    \n-    private void addElements(Collection<Element> add) {\n-        elements.addAll(add);\n-    }\n-    \n-    private void intersectElements(Collection<Element> intersect) {\n-        elements.retainAll(intersect);\n-    }\n-\n-    private Elements byId() {\n-        String id = tq.consumeCssIdentifier();\n-        Validate.notEmpty(id);\n-\n-        Element found = root.getElementById(id);\n-        Elements byId = new Elements();\n-        if(found != null)\n-            byId.add(found);\n-        return byId;\n-    }\n-\n-    private Elements byClass() {\n-        String className = tq.consumeCssIdentifier();\n-        Validate.notEmpty(className);\n-\n-        return root.getElementsByClass(className);\n-    }\n-\n-    private Elements byTag() {\n-        String tagName = tq.consumeElementSelector();\n-        Validate.notEmpty(tagName);\n-        \n-        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n-        if (tagName.contains(\"|\"))\n-            tagName = tagName.replace(\"|\", \":\");\n-        return root.getElementsByTag(tagName);\n-    }\n-\n-    private Elements byAttribute() {\n-        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n-        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n-        Validate.notEmpty(key);\n-        cq.consumeWhitespace();\n-\n-        if (cq.isEmpty()) {\n-            return key.startsWith(\"^\") ? root.getElementsByAttributeStarting(key.substring(1)) : root.getElementsByAttribute(key);\n-        } else {\n-            if (cq.matchChomp(\"=\"))\n-                return root.getElementsByAttributeValue(key, cq.remainder());\n-\n-            else if (cq.matchChomp(\"!=\"))\n-                return root.getElementsByAttributeValueNot(key, cq.remainder());\n-\n-            else if (cq.matchChomp(\"^=\"))\n-                return root.getElementsByAttributeValueStarting(key, cq.remainder());\n-\n-            else if (cq.matchChomp(\"$=\"))\n-                return root.getElementsByAttributeValueEnding(key, cq.remainder());\n-\n-            else if (cq.matchChomp(\"*=\"))\n-                return root.getElementsByAttributeValueContaining(key, cq.remainder());\n-            \n-            else if (cq.matchChomp(\"~=\"))\n-                return root.getElementsByAttributeValueMatching(key, cq.remainder());\n-            \n-            else\n-                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n-        }\n-    }\n-\n-    private Elements allElements() {\n-        return root.getAllElements();\n-    }\n-    \n-    // pseudo selectors :lt, :gt, :eq\n-    private Elements indexLessThan() {\n-        return root.getElementsByIndexLessThan(consumeIndex());\n-    }\n-    \n-    private Elements indexGreaterThan() {\n-        return root.getElementsByIndexGreaterThan(consumeIndex());\n-    }\n-    \n-    private Elements indexEquals() {\n-        return root.getElementsByIndexEquals(consumeIndex());\n-    }\n-\n-    private int consumeIndex() {\n-        String indexS = tq.chompTo(\")\").trim();\n-        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n-        return Integer.parseInt(indexS);\n-    }\n-\n-    // pseudo selector :has(el)\n-    private Elements has() {\n-        tq.consume(\":has\");\n-        String subQuery = tq.chompBalanced('(',')');\n-        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n-\n-        return filterForParentsOfDescendants(elements, select(subQuery, elements));\n-    }\n-    \n-    // pseudo selector :contains(text), containsOwn(text)\n-    private Elements contains(boolean own) {\n-        tq.consume(own ? \":containsOwn\" : \":contains\");\n-        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n-        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n-        \n-        return own ? root.getElementsContainingOwnText(searchText) : root.getElementsContainingText(searchText);\n-    }\n-    \n-    // :matches(regex), matchesOwn(regex)\n-    private Elements matches(boolean own) {\n-        tq.consume(own? \":matchesOwn\" : \":matches\");\n-        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n-        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n-        \n-        return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);\n-    }\n-\n-    // :not(selector)\n-    private Elements not() {\n-        tq.consume(\":not\");\n-        String subQuery = tq.chompBalanced('(', ')');\n-        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n-\n-        return filterOut(root.getAllElements(), select(subQuery, root));\n-    }\n-\n-    // direct child descendants\n-    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n-        Elements children = new Elements();\n-        CHILD: for (Element c : candidates) {\n-            for (Element p : parents) {\n-                if (c.parent() != null && c.parent().equals(p)) {\n-                    children.add(c);\n-                    continue CHILD;\n-                }\n-            }\n-        }\n-        return children;\n-    }\n-    \n-    // children or lower descendants. input candidates stemmed from found elements, so are either a descendant \n-    // or the original element; so check that parent is not child\n-    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n-        Elements children = new Elements();\n-        CHILD: for (Element c : candidates) {\n-            for (Element p : parents) {\n-                if (c.equals(p)) {\n-                    continue CHILD;\n-                }\n-            }\n-            children.add(c);\n-        }\n-        return children;\n-    }\n-\n-    // implements :has(el). Finds elements that contain the matched elements\n-    private static Elements filterForParentsOfDescendants(Collection<Element> parents, Collection<Element> children) {\n-        Elements filteredParents = new Elements();\n-        for (Element p : parents) {\n-            for (Element c : children) {\n-                if (c.parents().contains(p)) {\n-                    filteredParents.add(p);\n-                }\n-            }\n-        }\n-        return filteredParents;\n-    }\n-    \n-    // adjacent siblings\n-    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n-        Elements siblings = new Elements();\n-        SIBLING: for (Element c: candidates) {\n-            for (Element e: elements) {\n-                if (!e.parent().equals(c.parent()))\n-                    continue;\n-                Element previousSib = c.previousElementSibling();\n-                if (previousSib != null && previousSib.equals(e)) {\n-                    siblings.add(c);\n-                    continue SIBLING;\n-                }\n-            }\n-        }\n-        return siblings;\n-    }\n-    \n-    // preceeding siblings\n-    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n-        Elements output = new Elements();\n-        SIBLING: for (Element c: candidates) {\n-            for (Element e: elements) {\n-                if (!e.parent().equals(c.parent()))\n-                    continue;\n-                int ePos = e.elementSiblingIndex();\n-                int cPos = c.elementSiblingIndex();\n-                if (cPos > ePos) {\n-                    output.add(c);\n-                    continue SIBLING;\n-                }\n-            }\n-        }\n-        return output;\n-    }\n-    \n-    // union of both sets, for e.class type selectors\n-    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n-        Elements children = new Elements();\n-        CHILD: for (Element c : candidates) {\n-            for (Element p : parents) {\n-                if (c.equals(p)) {\n-                    children.add(c);\n-                    continue CHILD;\n-                }\n-            }   \n-        }\n-        return children;\n+        return Collector.collect(evaluator, root);\n     }\n \n     // exclude set. package open so that Elements can implement .not() selector.\n     static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n         Elements output = new Elements();\n-        for (Element el: elements) {\n+        for (Element el : elements) {\n             boolean found = false;\n-            for (Element out: outs) {\n+            for (Element out : outs) {\n                 if (el.equals(out)) {\n                     found = true;\n                     break;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/AndSelector.java\n+package org.jsoup.select.selectors;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.sun.xml.internal.ws.util.StringUtils;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Sequencing 'and' evaluator.\n+ * Matches only if all underlying evaluators have matched\n+ */\n+public class AndSelector extends Evaluator {\n+\tprivate List<Evaluator> selectors;\n+\n+\tprivate AndSelector() {\n+\t\tsuper();\n+\t\tthis.selectors = new ArrayList<Evaluator>();\n+\t}\n+\t\n+\tpublic AndSelector(Evaluator... evals) {\n+\t\tthis();\n+\t\tthis.selectors.addAll(Arrays.asList(evals));\n+\t}\n+\n+\tpublic AndSelector(Collection<Evaluator> selectors) {\n+\t\tthis();\n+\t\tthis.selectors.addAll(selectors);\n+\t}\n+\t\n+\tpublic void add(Evaluator e) {\n+\t\tselectors.add(e);\n+\t}\n+\t\n+\tpublic void addAll(Collection<Evaluator> e) {\n+\t\tselectors.addAll(e);\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(Element root, Element node) {\n+\t\tfor(Evaluator s : selectors) {\n+\t\t\tif(!s.matches(root, node))\n+\t\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn StringUtil.join(selectors, \" \");\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/BasicSelector.java\n+package org.jsoup.select.selectors;\n+\n+import java.util.Arrays;\n+\n+import org.jsoup.select.Evaluator;\n+\n+public class BasicSelector {\n+\t\n+\tpublic static OrSelector or(Evaluator... sels) {\n+\t\treturn new OrSelector(Arrays.asList(sels));\n+\t}\n+\t\n+\tpublic static AndSelector and(Evaluator... sels) {\n+\t\treturn new AndSelector(Arrays.asList(sels));\n+\t}\n+\t\n+\tpublic static NotSelector not(Evaluator sel) {\n+\t\treturn new NotSelector(sel);\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/HasSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Evaluator for :has() construction\n+ * Matches if element's descendants matches underlying evaluator\n+ */\n+public class HasSelector extends Evaluator {\n+    private Evaluator sel;\n+\n+    public HasSelector(Evaluator sel) {\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element element) {\n+        for (Element e : element.getAllElements()) {\n+            if (e != element && sel.matches(root, e))\n+                return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\":has(%s)\", sel);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/ImmediateParentSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching Element's immediate parent.\n+ * For evaluating 'E > F' construction\n+ */\n+public class ImmediateParentSelector extends Evaluator {\n+    private Evaluator sel;\n+\n+    public ImmediateParentSelector(Evaluator sel) {\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element element) {\n+        if (root == element)\n+            return false;\n+\n+        Element parent = element.parent();\n+        return parent != null && sel.matches(root, parent);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/ImmediatePreviousSiblingSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching Element's immediate previous sibling.\n+ * For evaluating 'E + F' construction\n+ */\n+public class ImmediatePreviousSiblingSelector extends Evaluator {\n+    private Evaluator sel;\n+\n+    public ImmediatePreviousSiblingSelector(Evaluator sel) {\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element element) {\n+        if (root == element)\n+            return false;\n+\n+        Element prev = element.previousElementSibling();\n+        return prev != null && sel.matches(root, prev);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\":prev%s\", sel);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/NotSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Logical 'not' evaluator. Matches only if underlying evaluator didn't match.\n+ */\n+public class NotSelector extends Evaluator {\n+    private Evaluator sel;\n+\n+    public NotSelector(Evaluator sel) {\n+        super();\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element node) {\n+        return !sel.matches(root, node);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\":not%s\", sel);\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/OrSelector.java\n+package org.jsoup.select.selectors;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Sequencing 'or' evaluator.\n+ * Matches only if any underlying evaluators have matched\n+ */\n+public class OrSelector extends Evaluator {\n+\tprivate List<Evaluator> selectors;\n+\n+\tpublic OrSelector(Collection<Evaluator> selectors) {\n+\t\tsuper();\n+\t\tthis.selectors = new ArrayList<Evaluator>();\n+\t\tthis.selectors.addAll(selectors);\n+\t}\n+\t\n+\tpublic void add(Evaluator e) {\n+\t\tselectors.add(e);\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(Element root, Element node) {\n+\t\tfor(Evaluator s : selectors) {\n+\t\t\tif(s.matches(root, node))\n+\t\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\":or%s\", selectors);\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/ParentSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching any of Element's parents.\n+ * For evaluating 'E F' construction\n+ *\n+ * @author ant\n+ */\n+public class ParentSelector extends Evaluator {\n+    private Evaluator sel;\n+\n+    public ParentSelector(Evaluator sel) {\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element element) {\n+        if (root == element)\n+            return false;\n+\n+        Element parent = element.parent();\n+        while (parent != root) {\n+            if (sel.matches(root, parent))\n+                return true;\n+            parent = parent.parent();\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\":parent%s\", sel);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/PreviousSiblingSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Tree-based evaluator for matching Element's parent.\n+ * For evaluating 'E ~ F' construction\n+ */\n+public class PreviousSiblingSelector extends Evaluator {\n+    Evaluator sel;\n+\n+    public PreviousSiblingSelector(Evaluator sel) {\n+        this.sel = sel;\n+    }\n+\n+    @Override\n+    public boolean matches(Element root, Element element) {\n+        if (root == element)\n+            return false;\n+\n+        Element prev = element.previousElementSibling();\n+\n+        while (prev != null) {\n+            if (sel.matches(root, prev))\n+                return true;\n+\n+            prev = prev.previousElementSibling();\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\":prev*%s\", sel);\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/selectors/RootSelector.java\n+package org.jsoup.select.selectors;\n+\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.Evaluator;\n+\n+/**\n+ * Root matcher matches only on root node\n+ * @author ant\n+ *\n+ */\n+public class RootSelector extends Evaluator {\n+\n+\t@Override\n+\tpublic boolean matches(Element root, Element element) {\n+\t\treturn root == element;\n+\t}\n+\n+}\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n \n     @Test public void testById() {\n         Elements els = Jsoup.parse(\"<div><p id=foo>Hello</p><p id=foo>Foo two!</p></div>\").select(\"#foo\");\n-        assertEquals(1, els.size());\n+        assertEquals(2, els.size());\n         assertEquals(\"Hello\", els.get(0).text());\n+        assertEquals(\"Foo two!\", els.get(1).text());\n \n         Elements none = Jsoup.parse(\"<div id=1></div>\").select(\"#foo\");\n         assertEquals(0, none.size());\n         Elements none = Jsoup.parse(\"<div class='one'></div>\").select(\".foo\");\n         assertEquals(0, none.size());\n \n-        Elements els2 = Jsoup.parse(\"<div class='one-two'></div>\").select(\".one-two\");\n+        Elements els2 = Jsoup.parse(\"<div class='One-Two'></div>\").select(\".one-two\");\n         assertEquals(1, els2.size());\n     }\n \n         Elements els = doc.select(\"p,div,[title]\");\n \n         assertEquals(5, els.size());\n-        assertEquals(\"p\", els.get(0).tagName());\n+        assertEquals(\"div\", els.get(0).tagName());\n+        assertEquals(\"foo\", els.get(0).attr(\"title\"));\n         assertEquals(\"div\", els.get(1).tagName());\n-        assertEquals(\"foo\", els.get(1).attr(\"title\"));\n+        assertEquals(\"bar\", els.get(1).attr(\"title\"));\n         assertEquals(\"div\", els.get(2).tagName());\n-        assertEquals(\"bar\", els.get(2).attr(\"title\"));\n-        assertEquals(\"div\", els.get(3).tagName());\n-        assertTrue(els.get(3).attr(\"title\").length() == 0); // missing attributes come back as empty string\n-        assertFalse(els.get(3).hasAttr(\"title\"));\n+        assertTrue(els.get(2).attr(\"title\").length() == 0); // missing attributes come back as empty string\n+        assertFalse(els.get(2).hasAttr(\"title\"));\n+        assertEquals(\"p\", els.get(3).tagName());\n         assertEquals(\"span\", els.get(4).tagName());\n     }\n ", "timestamp": 1309605126, "metainfo": ""}