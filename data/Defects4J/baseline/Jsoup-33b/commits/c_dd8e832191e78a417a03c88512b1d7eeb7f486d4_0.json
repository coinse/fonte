{"sha": "dd8e832191e78a417a03c88512b1d7eeb7f486d4", "log": "Merge commit 'db2d5aa85352fe63531540ef396b944e2fe58e2c'  Added selector javadoc", "commit": "\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n package org.jsoup.select;\n \n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.DocumentType;\n import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.XmlDeclaration;\n \n import java.util.List;\n import java.util.regex.Matcher;\n         }\n \n     }\n+    \n+    /**\n+     * Evaluator for matching the last sibling (css :last-child)\n+     */\n+    public static final class IsLastChild extends Evaluator {\n+\t\t@Override\n+\t\tpublic boolean matches(Element root, Element element) {\n+\t\t\tfinal Element p = element.parent();\n+\t\t\treturn p != null && !(p instanceof Document) && element.elementSiblingIndex() == p.children().size()-1;\n+\t\t}\n+    \t\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \":last-child\";\n+\t\t}\n+    }\n+    \n+    public static final class IsFirstOfType extends IsNthOfType {\n+\t\tpublic IsFirstOfType() {\n+\t\t\tsuper(0,1);\n+\t\t}\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \":first-of-type\";\n+\t\t}\n+    }\n+    \n+    public static final class IsLastOfType extends IsNthLastOfType {\n+\t\tpublic IsLastOfType() {\n+\t\t\tsuper(0,1);\n+\t\t}\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \":last-of-type\";\n+\t\t}\n+    }\n+\n+    \n+    public static abstract class CssNthEvaluator extends Evaluator {\n+    \tprotected final int a, b;\n+    \t\n+    \tpublic CssNthEvaluator(int a, int b) {\n+    \t\tthis.a = a;\n+    \t\tthis.b = b;\n+    \t}\n+    \tpublic CssNthEvaluator(int b) {\n+    \t\tthis(0,b);\n+    \t}\n+    \t\n+    \t@Override\n+    \tpublic boolean matches(Element root, Element element) {\n+    \t\tfinal Element p = element.parent();\n+    \t\tif (p == null || (p instanceof Document)) return false;\n+    \t\t\n+    \t\tfinal int pos = calculatePosition(root, element);\n+    \t\tif (a == 0) return pos == b;\n+    \t\t\n+    \t\treturn (pos-b)*a >= 0 && (pos-b)%a==0;\n+    \t}\n+    \t\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tif (a == 0)\n+\t\t\t\treturn String.format(\":%s(%d)\",getPseudoClass(), b);\n+\t\t\tif (b == 0)\n+\t\t\t\treturn String.format(\":%s(%dn)\",getPseudoClass(), a);\n+\t\t\treturn String.format(\":%s(%dn%+d)\", getPseudoClass(),a, b);\n+\t\t}\n+    \t\n+\t\tprotected abstract String getPseudoClass();\n+\t\tprotected abstract int calculatePosition(Element root, Element element);\n+    }\n+    \n+    \n+    /**\n+     * css-compatible Evaluator for :eq (css :nth-child)\n+     * \n+     * @see IndexEquals\n+     */\n+    public static final class IsNthChild extends CssNthEvaluator {\n+\n+    \tpublic IsNthChild(int a, int b) {\n+    \t\tsuper(a,b);\n+\t\t}\n+\n+\t\tprotected int calculatePosition(Element root, Element element) {\n+\t\t\treturn element.elementSiblingIndex()+1;\n+\t\t}\n+\n+\t\t\n+\t\tprotected String getPseudoClass() {\n+\t\t\treturn \"nth-child\";\n+\t\t}\n+    }\n+    \n+    /**\n+     * css pseudo class :nth-last-child)\n+     * \n+     * @see IndexEquals\n+     */\n+    public static final class IsNthLastChild extends CssNthEvaluator {\n+    \tpublic IsNthLastChild(int a, int b) {\n+    \t\tsuper(a,b);\n+    \t}\n+\n+        @Override\n+        protected int calculatePosition(Element root, Element element) {\n+        \treturn element.parent().children().size() - element.elementSiblingIndex();\n+        }\n+        \n+\t\t@Override\n+\t\tprotected String getPseudoClass() {\n+\t\t\treturn \"nth-last-child\";\n+\t\t}\n+    }\n+    \n+    /**\n+     * css pseudo class nth-of-type\n+     * \n+     */\n+    public static class IsNthOfType extends CssNthEvaluator {\n+    \tpublic IsNthOfType(int a, int b) {\n+    \t\tsuper(a,b);\n+    \t}\n+\n+\t\tprotected int calculatePosition(Element root, Element element) {\n+\t\t\tint pos = 0;\n+        \tElements family = element.parent().children();\n+        \tfor (int i = 0; i < family.size(); i++) {\n+        \t\tif (family.get(i).tag() == element.tag()) pos++;\n+        \t\tif (family.get(i) == element) break;\n+        \t}\n+\t\t\treturn pos;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected String getPseudoClass() {\n+\t\t\treturn \"nth-of-type\";\n+\t\t}\n+    }\n+    \n+    public static class IsNthLastOfType extends CssNthEvaluator {\n+\n+\t\tpublic IsNthLastOfType(int a, int b) {\n+\t\t\tsuper(a, b);\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tprotected int calculatePosition(Element root, Element element) {\n+\t\t\tint pos = 0;\n+        \tElements family = element.parent().children();\n+        \tfor (int i = element.elementSiblingIndex(); i < family.size(); i++) {\n+        \t\tif (family.get(i).tag() == element.tag()) pos++;\n+        \t}\n+\t\t\treturn pos;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected String getPseudoClass() {\n+\t\t\treturn \"nth-last-of-type\";\n+\t\t}\n+    }\n+\n+    /**\n+     * Evaluator for matching the first sibling (css :first-child)\n+     */\n+    public static final class IsFirstChild extends Evaluator {\n+    \t@Override\n+    \tpublic boolean matches(Element root, Element element) {\n+    \t\tfinal Element p = element.parent();\n+    \t\treturn p != null && !(p instanceof Document) && element.elementSiblingIndex() == 0;\n+    \t}\n+    \t\n+    \t@Override\n+    \tpublic String toString() {\n+    \t\treturn \":first-child\";\n+    \t}\n+    }\n+    \n+    /**\n+     * css3 pseudo-class :root\n+     * @see <a href=\"http://www.w3.org/TR/selectors/#root-pseudo\">:root selector</a>\n+     *\n+     */\n+    public static final class IsRoot extends Evaluator {\n+    \t@Override\n+    \tpublic boolean matches(Element root, Element element) {\n+    \t\tfinal Element r = root instanceof Document?root.child(0):root;\n+    \t\treturn element == r;\n+    \t}\n+    \t@Override\n+    \tpublic String toString() {\n+    \t\treturn \":root\";\n+    \t}\n+    }\n+\n+    public static final class IsOnlyChild extends Evaluator {\n+\t\t@Override\n+\t\tpublic boolean matches(Element root, Element element) {\n+\t\t\tfinal Element p = element.parent();\n+\t\t\treturn p!=null && !(p instanceof Document) && element.siblingElements().size() == 0;\n+\t\t}\n+    \t@Override\n+    \tpublic String toString() {\n+    \t\treturn \":only-child\";\n+    \t}\n+    }\n+\n+    public static final class IsOnlyOfType extends Evaluator {\n+\t\t@Override\n+\t\tpublic boolean matches(Element root, Element element) {\n+\t\t\tfinal Element p = element.parent();\n+\t\t\tif (p==null || p instanceof Document) return false;\n+\t\t\t\n+\t\t\tint pos = 0;\n+        \tElements family = p.children();\n+        \tfor (int i = 0; i < family.size(); i++) {\n+        \t\tif (family.get(i).tag().equals(element.tag())) pos++;\n+        \t}\n+        \treturn pos == 1;\n+\t\t}\n+    \t@Override\n+    \tpublic String toString() {\n+    \t\treturn \":only-of-type\";\n+    \t}\n+    }\n+\n+    public static final class IsEmpty extends Evaluator {\n+\t\t@Override\n+\t\tpublic boolean matches(Element root, Element element) {\n+        \tList<Node> family = element.childNodes();\n+        \tfor (int i = 0; i < family.size(); i++) {\n+        \t\tNode n = family.get(i);\n+        \t\tif (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType)) return false; \n+        \t}\n+        \treturn true;\n+\t\t}\n+    \t@Override\n+    \tpublic String toString() {\n+    \t\treturn \":empty\";\n+    \t}\n+    }\n \n     /**\n      * Abstract evaluator for sibling index matching\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.jsoup.helper.StringUtil;\n             matches(true);\n         else if (tq.matches(\":not(\"))\n             not();\n-        else // unhandled\n+\t\telse if (tq.matchChomp(\":nth-child(\"))\n+        \tcssNthChild(false, false);\n+        else if (tq.matchChomp(\":nth-last-child(\"))\n+        \tcssNthChild(true, false);\n+        else if (tq.matchChomp(\":nth-of-type(\"))\n+        \tcssNthChild(false, true);\n+        else if (tq.matchChomp(\":nth-last-of-type(\"))\n+        \tcssNthChild(true, true);\n+        else if (tq.matchChomp(\":first-child\"))\n+        \tevals.add(new Evaluator.IsFirstChild());\n+        else if (tq.matchChomp(\":last-child\"))\n+        \tevals.add(new Evaluator.IsLastChild());\n+        else if (tq.matchChomp(\":first-of-type\"))\n+        \tevals.add(new Evaluator.IsFirstOfType());\n+        else if (tq.matchChomp(\":last-of-type\"))\n+        \tevals.add(new Evaluator.IsLastOfType());\n+        else if (tq.matchChomp(\":only-child\"))\n+        \tevals.add(new Evaluator.IsOnlyChild());\n+        else if (tq.matchChomp(\":only-of-type\"))\n+        \tevals.add(new Evaluator.IsOnlyOfType());\n+        else if (tq.matchChomp(\":empty\"))\n+        \tevals.add(new Evaluator.IsEmpty());\n+        else if (tq.matchChomp(\":root\"))\n+        \tevals.add(new Evaluator.IsRoot());\n+\t\telse // unhandled\n             throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n \n     }\n     private void indexEquals() {\n         evals.add(new Evaluator.IndexEquals(consumeIndex()));\n     }\n+    \n+    //pseudo selectors :first-child, :last-child, :nth-child, ...\n+    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n+\n+\tprivate void cssNthChild(boolean backwards, boolean ofType) {\n+\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n+\t\tMatcher mAB = NTH_AB.matcher(argS);\n+\t\tMatcher mB = NTH_B.matcher(argS);\n+\t\tfinal int a, b;\n+\t\tif (\"odd\".equals(argS)) {\n+\t\t\ta = 2;\n+\t\t\tb = 1;\n+\t\t} else if (\"even\".equals(argS)) {\n+\t\t\ta = 2;\n+\t\t\tb = 0;\n+\t\t} else if (mAB.matches()) {\n+\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n+\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n+\t\t} else if (mB.matches()) {\n+\t\t\ta = 0;\n+\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n+\t\t} else {\n+\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n+\t\t}\n+\t\tif (ofType)\n+\t\t\tif (backwards)\n+\t\t\t\tevals.add(new Evaluator.IsNthLastOfType(a, b));\n+\t\t\telse\n+\t\t\t\tevals.add(new Evaluator.IsNthOfType(a, b));\n+\t\telse {\n+\t\t\tif (backwards)\n+\t\t\t\tevals.add(new Evaluator.IsNthLastChild(a, b));\n+\t\t\telse\n+\t\t\t\tevals.add(new Evaluator.IsNthChild(a, b));\n+\t\t}\n+\t}\n \n     private int consumeIndex() {\n         String indexS = tq.chompTo(\")\").trim();\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n+ * <tr><td colspan=\"3\"><h3>Structural pseudo selectors</h3></td></tr>\n+ * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>\n+ * <tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>\n+ * In addition to this, <code>:nth-child()</code> can take <code>odd</code> and <code>even</code> as arguments instead. <code>odd</code> has the same signification as <code>2n+1</code>, and <code>even</code> has the same signification as <code>2n</code>.</td><td><code>tr:nth-child(2n+1)</code> finds every odd row of a table. <code>:nth-child(10n-1)</code> the 9th, 19th, 29th, etc, element. <code>li:nth-child(5)</code> the 5h li</td></tr>\n+ * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n+ * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n+ * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n+ * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div > p:first-child</code></td></tr>\n+ * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol > li:last-child</code></td></tr>\n+ * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n+ * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr > td:last-of-type</code></td></tr>\n+ * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>\n+ * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n+ * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>\n  * </table>\n  *\n  * @author Jonathan Hedley, jonathan@hedley.net\n--- /dev/null\n+++ b/src/test/java/org/jsoup/select/CssTest.java\n+package org.jsoup.select;\n+\n+import static org.junit.Assert.*;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.parser.Tag;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class CssTest {\n+\n+\tprivate Document html = null;\n+\tprivate static String htmlString;\n+\t\n+\t@BeforeClass\n+\tpublic static void initClass() {\n+\t\tStringBuilder sb = new StringBuilder(\"<html><head></head><body>\");\n+\t\t\n+\t\tsb.append(\"<div id='pseudo'>\");\n+\t\tfor (int i = 1; i <= 10; i++) {\n+\t\t\tsb.append(String.format(\"<p>%d</p>\",i));\n+\t\t}\n+\t\tsb.append(\"</div>\");\n+\n+\t\tsb.append(\"<div id='type'>\");\n+\t\tfor (int i = 1; i <= 10; i++) {\n+\t\t\tsb.append(String.format(\"<p>%d</p>\",i));\n+\t\t\tsb.append(String.format(\"<span>%d</span>\",i));\n+\t\t\tsb.append(String.format(\"<em>%d</em>\",i));\n+\t\t}\n+\t\tsb.append(\"</div>\");\n+\n+\t\tsb.append(\"<span id='onlySpan'><br /></span>\");\n+\t\tsb.append(\"<p class='empty'><!-- Comment only is still empty! --></p>\");\n+\t\t\n+\t\tsb.append(\"<div id='only'>\");\n+\t\tsb.append(\"Some text before the <em>only</em> child in this div\");\n+\t\tsb.append(\"</div>\");\n+\t\t\n+\t\tsb.append(\"</body></html>\");\n+\t\thtmlString = sb.toString();\n+\t}\n+\n+\t@Before\n+\tpublic void init() {\n+\t\thtml  = Jsoup.parse(htmlString);\n+\t}\n+\t\n+\t@Test\n+\tpublic void firstChild() {\n+\t\tcheck(html.select(\"#pseudo :first-child\"), \"1\");\n+\t\tcheck(html.select(\"html:first-child\"));\n+\t}\n+\n+\t@Test\n+\tpublic void lastChild() {\n+\t\tcheck(html.select(\"#pseudo :last-child\"), \"10\");\n+\t\tcheck(html.select(\"html:last-child\"));\n+\t}\n+\t\n+\t@Test\n+\tpublic void nthChild_simple() {\n+\t\tfor(int i = 1; i <=10; i++) {\n+\t\t\tcheck(html.select(String.format(\"#pseudo :nth-child(%d)\", i)), String.valueOf(i));\n+\t\t}\n+\t}\n+\n+\n+\t@Test\n+\tpublic void nthLastChild_simple() {\n+\t\tfor(int i = 1; i <=10; i++) {\n+\t\t\tcheck(html.select(String.format(\"#pseudo :nth-last-child(%d)\", i)), String.valueOf(11-i));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void nthOfType_simple() {\n+\t\tfor(int i = 1; i <=10; i++) {\n+\t\t\tcheck(html.select(String.format(\"#type p:nth-of-type(%d)\", i)), String.valueOf(i));\n+\t\t}\n+\t}\n+\t\n+\t@Test\n+\tpublic void nthLastOfType_simple() {\n+\t\tfor(int i = 1; i <=10; i++) {\n+\t\t\tcheck(html.select(String.format(\"#type :nth-last-of-type(%d)\", i)), String.valueOf(11-i),String.valueOf(11-i),String.valueOf(11-i));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void nthChild_advanced() {\n+\t\tcheck(html.select(\"#pseudo :nth-child(-5)\"));\n+\t\tcheck(html.select(\"#pseudo :nth-child(odd)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(2n-1)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(2n+1)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(2n+3)\"), \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(even)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(2n)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(3n-1)\"), \"2\", \"5\", \"8\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(-2n+5)\"), \"1\", \"3\", \"5\");\n+\t\tcheck(html.select(\"#pseudo :nth-child(+5)\"), \"5\");\n+\t}\n+\n+\t@Test\n+\tpublic void nthOfType_advanced() {\n+\t\tcheck(html.select(\"#type :nth-of-type(-5)\"));\n+\t\tcheck(html.select(\"#type p:nth-of-type(odd)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type em:nth-of-type(2n-1)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type p:nth-of-type(2n+1)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type span:nth-of-type(2n+3)\"), \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type p:nth-of-type(even)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type p:nth-of-type(2n)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type p:nth-of-type(3n-1)\"), \"2\", \"5\", \"8\");\n+\t\tcheck(html.select(\"#type p:nth-of-type(-2n+5)\"), \"1\", \"3\", \"5\");\n+\t\tcheck(html.select(\"#type :nth-of-type(+5)\"), \"5\", \"5\", \"5\");\n+\t}\n+\n+\t\n+\t@Test\n+\tpublic void nthLastChild_advanced() {\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(-5)\"));\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(odd)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(2n-1)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(2n+1)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(2n+3)\"), \"2\", \"4\", \"6\", \"8\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(even)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(2n)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(3n-1)\"), \"3\", \"6\", \"9\");\n+\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(-2n+5)\"), \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#pseudo :nth-last-child(+5)\"), \"6\");\n+\t}\n+\n+\t@Test\n+\tpublic void nthLastOfType_advanced() {\n+\t\tcheck(html.select(\"#type :nth-last-of-type(-5)\"));\n+\t\tcheck(html.select(\"#type p:nth-last-of-type(odd)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type em:nth-last-of-type(2n-1)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type p:nth-last-of-type(2n+1)\"), \"2\", \"4\", \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type span:nth-last-of-type(2n+3)\"), \"2\", \"4\", \"6\", \"8\");\n+\t\tcheck(html.select(\"#type p:nth-last-of-type(even)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type p:nth-last-of-type(2n)\"), \"1\", \"3\", \"5\", \"7\", \"9\");\n+\t\tcheck(html.select(\"#type p:nth-last-of-type(3n-1)\"), \"3\", \"6\", \"9\");\n+\n+\t\tcheck(html.select(\"#type span:nth-last-of-type(-2n+5)\"), \"6\", \"8\", \"10\");\n+\t\tcheck(html.select(\"#type :nth-last-of-type(+5)\"), \"6\", \"6\", \"6\");\n+\t}\n+\t\n+\t@Test\n+\tpublic void firstOfType() {\n+\t\tcheck(html.select(\"div:not(#only) :first-of-type\"), \"1\", \"1\", \"1\", \"1\");\n+\t}\n+\n+\t@Test\n+\tpublic void lastOfType() {\n+\t\tcheck(html.select(\"div:not(#only) :last-of-type\"), \"10\", \"10\", \"10\", \"10\");\n+\t}\n+\n+\t@Test\n+\tpublic void empty() {\n+\t\tfinal Elements sel = html.select(\":empty\");\n+\t\tassertEquals(3, sel.size());\n+\t\tassertEquals(\"head\", sel.get(0).tagName());\n+\t\tassertEquals(\"br\", sel.get(1).tagName());\n+\t\tassertEquals(\"p\", sel.get(2).tagName());\n+\t}\n+\t\n+\t@Test\n+\tpublic void onlyChild() {\n+\t\tfinal Elements sel = html.select(\"span :only-child\");\n+\t\tassertEquals(1, sel.size());\n+\t\tassertEquals(\"br\", sel.get(0).tagName());\n+\t\t\n+\t\tcheck(html.select(\"#only :only-child\"), \"only\");\n+\t}\n+\t\n+\t@Test\n+\tpublic void onlyOfType() {\n+\t\tfinal Elements sel = html.select(\":only-of-type\");\n+\t\tassertEquals(6, sel.size());\n+\t\tassertEquals(\"head\", sel.get(0).tagName());\n+\t\tassertEquals(\"body\", sel.get(1).tagName());\n+\t\tassertEquals(\"span\", sel.get(2).tagName());\n+\t\tassertEquals(\"br\", sel.get(3).tagName());\n+\t\tassertEquals(\"p\", sel.get(4).tagName());\n+\t\tassertTrue(sel.get(4).hasClass(\"empty\"));\n+\t\tassertEquals(\"em\", sel.get(5).tagName());\n+\t}\n+\t\n+\tprotected void check(Elements result, String...expectedContent ) {\n+\t\tassertEquals(\"Number of elements\", expectedContent.length, result.size());\n+\t\tfor (int i = 0; i < expectedContent.length; i++) {\n+\t\t\tassertNotNull(result.get(i));\n+\t\t\tassertEquals(\"Expected element\",expectedContent[i], result.get(i).ownText());\n+\t\t}\n+\t}\n+\n+\t\n+\t@Test\n+\tpublic void root() {\n+\t\tElements sel = html.select(\":root\");\n+\t\tassertEquals(1, sel.size());\n+\t\tassertNotNull(sel.get(0));\n+\t\tassertEquals(Tag.valueOf(\"html\"), sel.get(0).tag());\n+\n+\t\tElements sel2 = html.select(\"body\").select(\":root\");\n+\t\tassertEquals(1, sel2.size());\n+\t\tassertNotNull(sel2.get(0));\n+\t\tassertEquals(Tag.valueOf(\"body\"), sel2.get(0).tag());\n+\t}\n+\n+}\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n  * or by methods in the Connection.Request object directly. All request configuration must be made before the request\n  * is executed.\n- * <p>\n- * The Connection interface is <b>currently in beta</b> and subject to change. Comments, suggestions, and bug reports are welcome.\n  */\n public interface Connection {\n \n      * @return this Connection, for chaining\n      */\n     public Connection timeout(int millis);\n+\n+    /**\n+     * Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\n+     * and the input truncated. The default maximum is 1MB. A max size of zero is treated as an infinite amount (bounded\n+     * only by your patience and the memory available on your machine).\n+     * @param bytes number of bytes to read from the input before truncating\n+     * @return this Connection, for chaining\n+     */\n+    public Connection maxBodySize(int bytes);\n \n     /**\n      * Set the request referrer (aka \"referer\") header.\n     /**\n      * Execute the request as a GET, and parse the result.\n      * @return parsed Document\n+     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n+     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n+     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n+     * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n     public Document get() throws IOException;\n     /**\n      * Execute the request as a POST, and parse the result.\n      * @return parsed Document\n+     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n+     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n+     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n+     * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n     public Document post() throws IOException;\n     /**\n      * Execute the request.\n      * @return a response object\n+     * @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n+     * @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n+     * @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n+     * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n     public Response execute() throws IOException;\n         public Request timeout(int millis);\n \n         /**\n+         * Get the maximum body size, in milliseconds.\n+         * @return the maximum body size, in milliseconds.\n+         */\n+        public int maxBodySize();\n+\n+        /**\n+         * Update the maximum body size, in milliseconds.\n+         * @param bytes maximum body size, in milliseconds.\n+         * @return this Request, for chaining\n+         */\n+        public Request maxBodySize(int bytes);\n+\n+        /**\n          * Get the current followRedirects configuration.\n          * @return true if followRedirects is enabled.\n          */\n--- /dev/null\n+++ b/src/main/java/org/jsoup/HttpStatusException.java\n+package org.jsoup;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Signals that a HTTP request resulted in a not OK HTTP response.\n+ */\n+public class HttpStatusException extends IOException {\n+    private int statusCode;\n+    private String url;\n+\n+    public HttpStatusException(String message, int statusCode, String url) {\n+        super(message);\n+        this.statusCode = statusCode;\n+        this.url = url;\n+    }\n+\n+    public int getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return super.toString() + \". Status=\" + statusCode + \", URL=\" + url;\n+    }\n+}\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n      * Use examples:\n      * <ul>\n      *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n-     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();\n+     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();</code></li>\n      * </ul>\n      * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n      * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n      @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n      @return The parsed HTML.\n \n-     @throws IOException If the final server response != 200 OK (redirects are followed), or if there's an error reading\n-     the response stream.\n+     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n+     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n+     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n+     @throws java.net.SocketTimeoutException if the connection times out\n+     @throws IOException if a connection or read error occurs\n \n      @see #connect(String)\n      */\n--- /dev/null\n+++ b/src/main/java/org/jsoup/UnsupportedMimeTypeException.java\n+package org.jsoup;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Signals that a HTTP response returned a mime type that is not supported.\n+ */\n+public class UnsupportedMimeTypeException extends IOException {\n+    private String mimeType;\n+    private String url;\n+\n+    public UnsupportedMimeTypeException(String message, String mimeType, String url) {\n+        super(message);\n+        this.mimeType = mimeType;\n+        this.url = url;\n+    }\n+\n+    public String getMimeType() {\n+        return mimeType;\n+    }\n+\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return super.toString() + \". Mimetype=\" + mimeType + \", URL=\"+url;\n+    }\n+}\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n             // into head mode\n-            if (docData.charAt(0) == 65279)\n+            if (docData.length() > 0 && docData.charAt(0) == 65279)\n                 docData = docData.substring(1);\n \n             doc = parser.parseInput(docData, baseUri);\n         return doc;\n     }\n \n-    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n+    /**\n+     * Read the input stream into a byte buffer.\n+     * @param inStream the input stream to read from\n+     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n+     * @return the filled byte buffer\n+     * @throws IOException if an exception occurs whilst reading from the input stream.\n+     */\n+    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n+        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n+        final boolean capped = maxSize > 0;\n         byte[] buffer = new byte[bufferSize];\n         ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n         int read;\n-        while(true) {\n-            read  = inStream.read(buffer);\n+        int remaining = maxSize;\n+\n+        while (true) {\n+            read = inStream.read(buffer);\n             if (read == -1) break;\n+            if (capped) {\n+                if (read > remaining) {\n+                    outStream.write(buffer, 0, remaining);\n+                    break;\n+                }\n+                remaining -= read;\n+            }\n             outStream.write(buffer, 0, read);\n         }\n         ByteBuffer byteData = ByteBuffer.wrap(outStream.toByteArray());\n         return byteData;\n     }\n \n+    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n+        return readToByteBuffer(inStream, 0);\n+    }\n+\n     /**\n-     * Parse out a charset from a content type header.\n+     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n+     * will kick in.)\n      * @param contentType e.g. \"text/html; charset=EUC-JP\"\n      * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n      */\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n-            return m.group(1).trim().toUpperCase(Locale.ENGLISH);\n+            String charset = m.group(1).trim();\n+            if (Charset.isSupported(charset)) return charset;\n+            charset = charset.toUpperCase(Locale.ENGLISH);\n+            if (Charset.isSupported(charset)) return charset;\n         }\n         return null;\n     }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n package org.jsoup.helper;\n \n import org.jsoup.Connection;\n+import org.jsoup.HttpStatusException;\n+import org.jsoup.UnsupportedMimeTypeException;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n     public Connection timeout(int millis) {\n         req.timeout(millis);\n+        return this;\n+    }\n+\n+    public Connection maxBodySize(int bytes) {\n+        req.maxBodySize(bytes);\n         return this;\n     }\n \n \n     public static class Request extends Base<Connection.Request> implements Connection.Request {\n         private int timeoutMilliseconds;\n+        private int maxBodySizeBytes;\n         private boolean followRedirects;\n         private Collection<Connection.KeyVal> data;\n         private boolean ignoreHttpErrors = false;\n \n       \tprivate Request() {\n             timeoutMilliseconds = 3000;\n+            maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n             data = new ArrayList<Connection.KeyVal>();\n             method = Connection.Method.GET;\n         public Request timeout(int millis) {\n             Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n             timeoutMilliseconds = millis;\n+            return this;\n+        }\n+\n+        public int maxBodySize() {\n+            return maxBodySizeBytes;\n+        }\n+\n+        public Connection.Request maxBodySize(int bytes) {\n+            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n+            maxBodySizeBytes = bytes;\n             return this;\n         }\n \n         static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n             Validate.notNull(req, \"Request must not be null\");\n             String protocol = req.url().getProtocol();\n-            Validate\n-                .isTrue(protocol.equals(\"http\") || protocol.equals(\"https\"), \"Only http & https protocols supported\");\n+            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n+                throw new MalformedURLException(\"Only http & https protocols supported\");\n \n             // set up the request for execution\n             if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                 serialiseRequestUrl(req); // appends query string\n             HttpURLConnection conn = createConnection(req);\n-            conn.connect();\n-            if (req.method() == Connection.Method.POST)\n-                writePost(req.data(), conn.getOutputStream());          \n-\n-            int status = conn.getResponseCode();\n-            boolean needsRedirect = false;\n-            if (status != HttpURLConnection.HTTP_OK) {\n-                if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n-                    needsRedirect = true;\n-                else if (!req.ignoreHttpErrors())\n-                    throw new IOException(status + \" error loading URL \" + req.url().toString());\n-            }\n-            Response res = new Response(previousResponse);\n-            res.setupFromConnection(conn, previousResponse);\n-            if (needsRedirect && req.followRedirects()) {\n-                req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n-                req.data().clear();\n-                req.url(new URL(req.url(), res.header(\"Location\")));\n-                for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n-                    req.cookie(cookie.getKey(), cookie.getValue());\n+            Response res;\n+            try {\n+                conn.connect();\n+                if (req.method() == Connection.Method.POST)\n+                    writePost(req.data(), conn.getOutputStream());\n+\n+                int status = conn.getResponseCode();\n+                boolean needsRedirect = false;\n+                if (status != HttpURLConnection.HTTP_OK) {\n+                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER)\n+                        needsRedirect = true;\n+                    else if (!req.ignoreHttpErrors())\n+                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n                 }\n-                return execute(req, res);\n-            }\n-            res.req = req;\n-\n-            // check that we can handle the returned content type; if not, abort before fetching it\n-            String contentType = res.contentType();\n-            if (!req.ignoreContentType() && (contentType == null || !(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n-                throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml\",\n-                    contentType, req.url().toString()));\n-\n-            InputStream bodyStream = null;\n-            InputStream dataStream = null;\n-            try {\n-                dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-            \tbodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n-                        new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                        new BufferedInputStream(dataStream);\n-                \n-                res.byteData = DataUtil.readToByteBuffer(bodyStream);\n-                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n+                res = new Response(previousResponse);\n+                res.setupFromConnection(conn, previousResponse);\n+                if (needsRedirect && req.followRedirects()) {\n+                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n+                    req.data().clear();\n+                    req.url(new URL(req.url(), res.header(\"Location\")));\n+                    for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n+                        req.cookie(cookie.getKey(), cookie.getValue());\n+                    }\n+                    return execute(req, res);\n+                }\n+                res.req = req;\n+\n+                // check that we can handle the returned content type; if not, abort before fetching it\n+                String contentType = res.contentType();\n+                if (contentType != null && !req.ignoreContentType() && (!(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n+                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n+                            contentType, req.url().toString());\n+\n+                InputStream bodyStream = null;\n+                InputStream dataStream = null;\n+                try {\n+                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n+                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n+                            new BufferedInputStream(dataStream);\n+\n+                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n+                } finally {\n+                    if (bodyStream != null) bodyStream.close();\n+                    if (dataStream != null) dataStream.close();\n+                }\n             } finally {\n-                if (bodyStream != null) bodyStream.close();\n-                if (dataStream != null) dataStream.close();\n+                // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n+                // connection errors will not be released quickly enough and can cause a too many open files error.\n+                conn.disconnect();\n             }\n \n             res.executed = true;\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n         boolean modified = false;\n \n         int l = string.length();\n-        for (int i = 0; i < l; i++) {\n-            int c = string.codePointAt(i);\n+        int c;\n+        for (int i = 0; i < l; i+= Character.charCount(c)) {\n+            c = string.codePointAt(i);\n             if (isWhitespace(c)) {\n                 if (lastWasWhite) {\n                     modified = true;\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n package org.jsoup.nodes;\n \n+import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n      @return Trimmed title, or empty string if none set.\n      */\n     public String title() {\n+        // title is a preserve whitespace tag (for document output), but normalised here\n         Element titleEl = getElementsByTag(\"title\").first();\n-        return titleEl != null ? titleEl.text().trim() : \"\";\n+        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : \"\";\n     }\n \n     /**\n         private Charset charset = Charset.forName(\"UTF-8\");\n         private CharsetEncoder charsetEncoder = charset.newEncoder();\n         private boolean prettyPrint = true;\n+        private boolean outline = false;\n         private int indentAmount = 1;\n \n         public OutputSettings() {}\n          */\n         public OutputSettings prettyPrint(boolean pretty) {\n             prettyPrint = pretty;\n+            return this;\n+        }\n+        \n+        /**\n+         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n+         * all tags as block.\n+         * @return if outline mode is enabled.\n+         */\n+        public boolean outline() {\n+            return outline;\n+        }\n+        \n+        /**\n+         * Enable or disable HTML outline mode.\n+         * @param outlineMode new outline setting\n+         * @return this, for chaining\n+         */\n+        public OutputSettings outline(boolean outlineMode) {\n+            outline = outlineMode;\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n import org.jsoup.helper.Validate;\n \n /**\n- * A {@code <!DOCTPYE>} node.\n+ * A {@code <!DOCTYPE>} node.\n  */\n public class DocumentType extends Node {\n     // todo: quirk mode from publicId and systemId\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Collector;\n-import org.jsoup.select.Elements;\n-import org.jsoup.select.Evaluator;\n-import org.jsoup.select.Selector;\n+import org.jsoup.select.*;\n \n import java.util.*;\n import java.util.regex.Pattern;\n      * a filtered list of children that are elements, and the index is based on that filtered list.\n      * \n      * @param index the index number of the element to retrieve\n-     * @return the child element, if it exists, or {@code null} if absent.\n+     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n      * @see #childNode(int)\n      */\n     public Element child(int index) {\n     /**\n      * Add a node child node to this element.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element appendChild(Node child) {\n         addChildren(child);\n         return this;\n     }\n-    \n+\n     /**\n      * Add a node to the start of this element's children.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element prependChild(Node child) {\n         Validate.notNull(child);\n         \n         addChildren(0, child);\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n+     *\n+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n+     * end\n+     * @param children child nodes to insert\n+     * @return this element, for chaining.\n+     */\n+    public Element insertChildren(int index, Collection<? extends Node> children) {\n+        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n+        int currentSize = childNodeSize();\n+        if (index < 0) index += currentSize +1; // roll around\n+        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n+\n+        ArrayList<Node> nodes = new ArrayList<Node>(children);\n+        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n+        addChildren(index, nodeArray);\n         return this;\n     }\n     \n     }\n \n     /**\n-     * Insert the specified HTML into the DOM before this element (i.e. as a preceding sibling).\n+     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n      *\n      * @param html HTML to add before this element\n      * @return this element, for chaining\n     }\n \n     /**\n-     * Insert the specified node into the DOM before this node (i.e. as a preceding sibling).\n+     * Insert the specified node into the DOM before this node (as a preceding sibling).\n      * @param node to add before this element\n      * @return this Element, for chaining\n      * @see #after(Node)\n     }\n \n     /**\n-     * Insert the specified HTML into the DOM after this element (i.e. as a following sibling).\n+     * Insert the specified HTML into the DOM after this element (as a following sibling).\n      *\n      * @param html HTML to add after this element\n      * @return this element, for chaining\n     }\n \n     /**\n-     * Insert the specified node into the DOM after this node (i.e. as a following sibling).\n+     * Insert the specified node into the DOM after this node (as a following sibling).\n      * @param node to add after this element\n      * @return this element, for chaining\n      * @see #before(Node)\n      * @see #textNodes()\n      */\n     public String text() {\n-        StringBuilder sb = new StringBuilder();\n-        text(sb);\n-        return sb.toString().trim();\n-    }\n-\n-    private void text(StringBuilder accum) {\n-        appendWhitespaceIfBr(this, accum);\n-        \n-        for (Node child : childNodes) {\n-            if (child instanceof TextNode) {\n-                TextNode textNode = (TextNode) child;\n-                appendNormalisedText(accum, textNode);\n-            } else if (child instanceof Element) {\n-                Element element = (Element) child;\n-                if (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\n-                    accum.append(\" \");\n-                element.text(accum);\n+        final StringBuilder accum = new StringBuilder();\n+        new NodeTraversor(new NodeVisitor() {\n+            public void head(Node node, int depth) {\n+                if (node instanceof TextNode) {\n+                    TextNode textNode = (TextNode) node;\n+                    appendNormalisedText(accum, textNode);\n+                } else if (node instanceof Element) {\n+                    Element element = (Element) node;\n+                    if (accum.length() > 0 &&\n+                        (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n+                        !TextNode.lastCharIsWhitespace(accum))\n+                        accum.append(\" \");\n+                }\n             }\n-        }\n+\n+            public void tail(Node node, int depth) {\n+            }\n+        }).traverse(this);\n+        return accum.toString().trim();\n     }\n \n     /**\n         }\n     }\n \n-    private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n+    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n         String text = textNode.getWholeText();\n \n-        if (!preserveWhitespace()) {\n+        if (!preserveWhitespace(textNode.parent())) {\n             text = TextNode.normaliseWhitespace(text);\n             if (TextNode.lastCharIsWhitespace(accum))\n                 text = TextNode.stripLeadingWhitespace(text);\n             accum.append(\" \");\n     }\n \n-    boolean preserveWhitespace() {\n-        return tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n+    static boolean preserveWhitespace(Node node) {\n+        // looks only at this element and one level up, to prevent recursion & needless stack searches\n+        if (node != null && node instanceof Element) {\n+            Element element = (Element) node;\n+            return element.tag.preserveWhitespace() ||\n+                element.parent() != null && element.parent().tag.preserveWhitespace();\n+        }\n+        return false;\n     }\n \n     /**\n     }\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n+        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n             indent(accum, depth, out);\n         accum\n                 .append(\"<\")\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n-            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n+            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n+                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n+            )))\n                 indent(accum, depth, out);\n             accum.append(\"</\").append(tagName()).append(\">\");\n         }\n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames(); // creates linked set of class names from class attribute\n+        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n         return clone;\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n+\n+import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n import java.io.InputStream;\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n+    private static final Map<String, Character> base;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n     private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\n \n     /**\n      * Check if the input is a known named entity\n-     * @param name the possible entity name (e.g. \"lt\" or \"amp\"\n+     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity\n      */\n     public static boolean isNamedEntity(String name) {\n         return full.containsKey(name);\n+    }\n+\n+    /**\n+     * Check if the input is a known named entity in the base entity set.\n+     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n+     * @return true if a known named entity in the base set\n+     * @see #isNamedEntity(String)\n+     */\n+    public static boolean isBaseNamedEntity(String name) {\n+        return base.containsKey(name);\n     }\n \n     /**\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n         Map<Character, String> map = escapeMode.getMap();\n \n-        for (int pos = 0; pos < string.length(); pos++) {\n-            Character c = string.charAt(pos);\n-            if (map.containsKey(c))\n-                accum.append('&').append(map.get(c)).append(';');\n-            else if (encoder.canEncode(c))\n-                accum.append(c.charValue());\n-            else\n-                accum.append(\"&#\").append((int) c).append(';');\n+        final int length = string.length();\n+        for (int offset = 0; offset < length; ) {\n+            final int codePoint = string.codePointAt(offset);\n+\n+            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n+            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+                final char c = (char) codePoint;\n+                if (map.containsKey(c))\n+                    accum.append('&').append(map.get(c)).append(';');\n+                else if (encoder.canEncode(c))\n+                    accum.append(c);\n+                else\n+                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+            } else {\n+                final String c = new String(Character.toChars(codePoint));\n+                if (encoder.canEncode(c))\n+                    accum.append(c);\n+                else\n+                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+            }\n+\n+            offset += Character.charCount(codePoint);\n         }\n \n         return accum.toString();\n      * @return\n      */\n     static String unescape(String string, boolean strict) {\n-        // todo: change this method to use Tokeniser.consumeCharacterReference\n-        if (!string.contains(\"&\"))\n-            return string;\n-\n-        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\\\d*);?\n-        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n-        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n-\n-        while (m.find()) {\n-            int charval = -1;\n-            String num = m.group(3);\n-            if (num != null) {\n-                try {\n-                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n-                    charval = Integer.valueOf(num, base);\n-                } catch (NumberFormatException e) {\n-                } // skip\n-            } else {\n-                String name = m.group(1);\n-                if (full.containsKey(name))\n-                    charval = full.get(name);\n-            }\n-\n-            if (charval != -1 || charval > 0xFFFF) { // out of range\n-                String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n-            } else {\n-                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string\n-            }\n-        }\n-        m.appendTail(accum);\n-        return accum.toString();\n+        return Parser.unescapeEntities(string, strict);\n     }\n \n     // xhtml has restricted entities\n \n     static {\n         xhtmlByVal = new HashMap<Character, String>();\n-        baseByVal = toCharacterKey(loadEntities(\"entities-base.properties\")); // most common / default\n+        base = loadEntities(\"entities-base.properties\");  // most common / default\n+        baseByVal = toCharacterKey(base);\n         full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n         fullByVal = toCharacterKey(full);\n \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     }\n \n     /**\n-     Get a child node by index\n+     Get a child node by its 0-based index.\n      @param index index of child node\n-     @return the child node at this index.\n+     @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n      */\n     public Node childNode(int index) {\n         return childNodes.get(index);\n      @return list of children. If no children, returns an empty list.\n      */\n     public List<Node> childNodes() {\n-        // actually returns the real list, as this method is hit many times during selection, and so is a GC time-sink\n-        // leaving the documentation as is (warning of unmodifiability) to discourage out-of-API modifications\n-        return childNodes;\n+        return Collections.unmodifiableList(childNodes);\n+    }\n+\n+    /**\n+     * Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original\n+     * nodes\n+     * @return a deep copy of this node's children\n+     */\n+    public List<Node> childNodesCopy() {\n+        List<Node> children = new ArrayList<Node>(childNodes.size());\n+        for (Node node : childNodes) {\n+            children.add(node.clone());\n+        }\n+        return children;\n+    }\n+\n+    /**\n+     * Get the number of child nodes that this node holds.\n+     * @return the number of child nodes that this node holds.\n+     */\n+    public final int childNodeSize() {\n+        return childNodes.size();\n     }\n     \n     protected Node[] childNodesAsArray() {\n-        return childNodes.toArray(new Node[childNodes().size()]);\n+        return childNodes.toArray(new Node[childNodeSize()]);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n         String html = Entities.escape(getWholeText(), out);\n-        if (out.prettyPrint() && parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {\n+        if (out.prettyPrint() && parent() instanceof Element && !Element.preserveWhitespace((Element) parent())) {\n             html = normaliseWhitespace(html);\n         }\n \n-        if (out.prettyPrint() && siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank())\n+        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n             indent(accum, depth, out);\n         accum.append(html);\n     }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n     Element insert(Token.StartTag startTag) {\n         // handle empty unknown tags\n-        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n-        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n+        if (startTag.isSelfClosing()) {\n             Element el = insertEmpty(startTag);\n-            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            stack.add(el);\n+            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n         Element el = new Element(tag, baseUri, startTag.attributes);\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n-            tokeniser.acknowledgeSelfClosingFlag();\n-            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+            if (tag.isKnownTag()) {\n+                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n+            } else {\n+                // unknown tag, remember this is self closing for output\n                 tag.setSelfClosing();\n+                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n+            }\n         }\n         return el;\n     }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n                             LinkedList<Element> stack = tb.getStack();\n-                            for (int si = 0; si < stack.size(); si++) {\n+                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n+                            // run-aways\n+                            for (int si = 0; si < stack.size() && si < 64; si++) {\n                                 Element el = stack.get(si);\n                                 if (el == formatEl) {\n                                     commonAncestor = stack.get(si - 1);\n                             }\n \n                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                             for (Node childNode : childNodes) {\n                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                             }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     }\n \n     /**\n+     * Parse a fragment of XML into a list of nodes.\n+     *\n+     * @param fragmentXml the fragment of XML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @return list of nodes parsed from the input XML.\n+     */\n+    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n+        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+    }\n+\n+    /**\n      * Parse a fragment of HTML into the {@code body} of a Document.\n      *\n      * @param bodyHtml fragment of HTML\n             body.appendChild(node);\n         }\n         return doc;\n+    }\n+\n+    /**\n+     * Utility method to unescape HTML entities from a string\n+     * @param string HTML escaped string\n+     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n+     * @return an unescaped string\n+     */\n+    public static String unescapeEntities(String string, boolean inAttribute) {\n+        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());\n+        return tokeniser.unescapeEntities(inAttribute);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n      */\n     public static Tag valueOf(String tagName) {\n         Validate.notNull(tagName);\n-        tagName = tagName.trim().toLowerCase();\n-        Validate.notEmpty(tagName);\n-\n-        synchronized (tags) {\n-            Tag tag = tags.get(tagName);\n+        Tag tag = tags.get(tagName);\n+\n+        if (tag == null) {\n+            tagName = tagName.trim().toLowerCase();\n+            Validate.notEmpty(tagName);\n+            tag = tags.get(tagName);\n+\n             if (tag == null) {\n                 // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n                 tag = new Tag(tagName);\n                 tag.isBlock = false;\n                 tag.canContainBlock = true;\n             }\n-            return tag;\n-        }\n+        }\n+        return tag;\n     }\n \n     /**\n             \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n-            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n             \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n     };\n     private static final String[] inlineTags = {\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n-            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n+            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n+            \"ins\", \"del\", \"s\"\n     };\n     private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n         }\n     }\n \n-    private static Tag register(Tag tag) {\n-        synchronized (tags) {\n-            tags.put(tag.tagName, tag);\n-        }\n-        return tag;\n+    private static void register(Tag tag) {\n+        tags.put(tag.tagName, tag);\n     }\n }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         }\n \n         void appendAttributeValue(String append) {\n-            pendingAttributeValue = pendingAttributeValue == null ? new StringBuilder(append) : pendingAttributeValue.append(append);\n+            ensureAttributeValue();\n+            pendingAttributeValue.append(append);\n         }\n \n         void appendAttributeValue(char append) {\n-            appendAttributeValue(String.valueOf(append));\n+            ensureAttributeValue();\n+            pendingAttributeValue.append(append);\n+        }\n+\n+        void appendAttributeValue(char[] append) {\n+            ensureAttributeValue();\n+            pendingAttributeValue.append(append);\n+        }\n+\n+        private final void ensureAttributeValue() {\n+            if (pendingAttributeValue == null)\n+                pendingAttributeValue = new StringBuilder();\n         }\n     }\n \n \n     static class Comment extends Token {\n         final StringBuilder data = new StringBuilder();\n+        boolean bogus = false;\n \n         Comment() {\n             type = TokenType.Comment;\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         charBuffer.append(str);\n     }\n \n+    void emit(char[] chars) {\n+        charBuffer.append(chars);\n+    }\n+\n     void emit(char c) {\n         charBuffer.append(c);\n     }\n         selfClosingFlagAcknowledged = true;\n     }\n \n-    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return replacementChar;\n+                return new char[]{replacementChar};\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n-                return (char) charval;\n+                return Character.toChars(charval);\n             }\n         } else { // named\n-            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n+            // get as many letters as possible, and look for matching entities.\n             String nameRef = reader.consumeLetterThenDigitSequence();\n-            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n             boolean looksLegit = reader.matches(';');\n-            boolean found = false;\n-            while (nameRef.length() > 0 && !found) {\n-                if (Entities.isNamedEntity(nameRef))\n-                    found = true;\n-                else {\n-                    nameRef = nameRef.substring(0, nameRef.length()-1);\n-                    reader.unconsume();\n-                }\n-            }\n+            // found if a base named entity without a ;, or an extended entity with the ;.\n+            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n+\n             if (!found) {\n+                reader.rewindToMark();\n                 if (looksLegit) // named with semicolon\n-                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n-                reader.rewindToMark();\n+                    characterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\n                 return null;\n             }\n             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return Entities.getCharacterByName(nameRef);\n+            return new char[]{Entities.getCharacterByName(nameRef)};\n         }\n     }\n \n         // Element currentNode = currentNode();\n         // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n     }\n-}\n+\n+    /**\n+     * Utility method to consume reader and unescape entities found within.\n+     * @param inAttribute\n+     * @return unescaped string from reader\n+     */\n+    String unescapeEntities(boolean inAttribute) {\n+        StringBuilder builder = new StringBuilder();\n+        while (!reader.isEmpty()) {\n+            builder.append(reader.consumeTo('&'));\n+            if (reader.matches('&')) {\n+                reader.consume();\n+                char[] c = consumeCharacterReference(null, inAttribute);\n+                if (c == null || c.length==0)\n+                    builder.append('&');\n+                else\n+                    builder.append(c);\n+            }\n+        }\n+        return builder.toString();\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n     CharacterReferenceInData {\n         // from & in data\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n+            char[] c = t.consumeCharacterReference(null, false);\n             if (c == null)\n                 t.emit('&');\n             else\n     },\n     CharacterReferenceInRcdata {\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n+            char[] c = t.consumeCharacterReference(null, false);\n             if (c == null)\n                 t.emit('&');\n             else\n \n         private void anythingElse(Tokeniser t, CharacterReader r) {\n             t.emit(\"</\" + t.dataBuffer.toString());\n+            r.unconsume();\n             t.transition(Rcdata);\n         }\n     },\n                 anythingElse(t, r);\n             }\n         }\n-        \n+\n         private void anythingElse(Tokeniser t, CharacterReader r) {\n             t.emit(\"</\" + t.dataBuffer.toString());\n             t.transition(ScriptDataEscaped);\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\"', true);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\\'', true);\n+                    char[] ref = t.consumeCharacterReference('\\'', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('>', true);\n+                    char[] ref = t.consumeCharacterReference('>', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n             // rewind to capture character that lead us here\n             r.unconsume();\n             Token.Comment comment = new Token.Comment();\n+            comment.bogus = true;\n             comment.data.append(r.consumeTo('>'));\n             // todo: replace nullChar with replaceChar\n             t.emit(comment);\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n-}\n+}\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.nodes.*;\n \n import java.util.Iterator;\n+import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n \n     void insert(Token.Comment commentToken) {\n         Comment comment = new Comment(commentToken.getData(), baseUri);\n-        insertNode(comment);\n+        Node insert = comment;\n+        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n+            String data = comment.getData();\n+            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n+                String declaration = data.substring(1);\n+                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n+            }\n+        }\n+        insertNode(insert);\n     }\n \n     void insert(Token.Character characterToken) {\n             }\n         }\n     }\n+\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n+        initialiseParse(inputFragment, baseUri, errors);\n+        runParser();\n+        return doc.childNodes();\n+    }\n }\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.parser.Tag;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n \n import java.util.List;\n \n \n     /**\n      Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n-     @param source source of HTML\n-     @param dest destination element to copy into\n-     @return number of discarded elements (that were considered unsafe)\n      */\n-    private int copySafeNodes(Element source, Element dest) {\n-        List<Node> sourceChildren = source.childNodes();\n-        int numDiscarded = 0;\n+    private final class CleaningVisitor implements NodeVisitor {\n+        private int numDiscarded = 0;\n+        private final Element root;\n+        private Element destination; // current element to append nodes to\n \n-        for (Node sourceChild : sourceChildren) {\n-            if (sourceChild instanceof Element) {\n-                Element sourceEl = (Element) sourceChild;\n+        private CleaningVisitor(Element root, Element destination) {\n+            this.root = root;\n+            this.destination = destination;\n+        }\n+\n+        public void head(Node source, int depth) {\n+            if (source instanceof Element) {\n+                Element sourceEl = (Element) source;\n \n                 if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs\n                     ElementMeta meta = createSafeElement(sourceEl);\n                     Element destChild = meta.el;\n-                    dest.appendChild(destChild);\n+                    destination.appendChild(destChild);\n \n                     numDiscarded += meta.numAttribsDiscarded;\n-                    numDiscarded += copySafeNodes(sourceEl, destChild); // recurs\n-                } else { // not a safe tag, but it may have children (els or text) that are, so recurse\n+                    destination = destChild;\n+                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                     numDiscarded++;\n-                    numDiscarded += copySafeNodes(sourceEl, dest);\n                 }\n-            } else if (sourceChild instanceof TextNode) {\n-                TextNode sourceText = (TextNode) sourceChild;\n-                TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri());\n-                dest.appendChild(destText);\n-            } // else, we don't care about comments, xml proc instructions, etc\n+            } else if (source instanceof TextNode) {\n+                TextNode sourceText = (TextNode) source;\n+                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n+                destination.appendChild(destText);\n+            } else { // else, we don't care about comments, xml proc instructions, etc\n+                numDiscarded++;\n+            }\n         }\n-        return numDiscarded;\n+\n+        public void tail(Node source, int depth) {\n+            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {\n+                destination = destination.parent(); // would have descended, so pop destination stack\n+            }\n+        }\n+    }\n+\n+    private int copySafeNodes(Element source, Element dest) {\n+        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n+        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);\n+        traversor.traverse(source);\n+        return cleaningVisitor.numDiscarded;\n     }\n \n     private ElementMeta createSafeElement(Element sourceEl) {\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n         return this;\n     }\n \n-    boolean isSafeTag(String tag) {\n+    /**\n+     * Test if the supplied tag is allowed by this whitelist\n+     * @param tag test tag\n+     * @return true if allowed\n+     */\n+    protected boolean isSafeTag(String tag) {\n         return tagNames.contains(TagName.valueOf(tag));\n     }\n \n+    /**\n+     * Test if the supplied attribute is allowed by this whitelist for this tag\n+     * @param tagName tag to consider allowing the attribute in\n+     * @param el element under test, to confirm protocol\n+     * @param attr attribute under test\n+     * @return true if allowed\n+     */\n     boolean isSafeAttribute(String tagName, Element el, Attribute attr) {\n         TagName tag = TagName.valueOf(tagName);\n         AttributeKey key = AttributeKey.valueOf(attr.getKey());\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n     public Elements(Element... elements) {\n         this(Arrays.asList(elements));\n     }\n-    \n+\n+    /**\n+     * Creates a deep copy of these elements.\n+     * @return a deep copy\n+     */\n     @Override\n \tpublic Elements clone() {\n     \tList<Element> elements = new ArrayList<Element>();\n     // list-like methods\n     /**\n      Get the first matched element.\n-     @return The first matched element, or <code>null</code> if contents is empty;\n+     @return The first matched element, or <code>null</code> if contents is empty.\n      */\n     public Element first() {\n         return contents.isEmpty() ? null : contents.get(0);\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n     \n     /**\n      * css3 pseudo-class :root\n-     * @see http://www.w3.org/TR/selectors/#root-pseudo\n+     * @see <a href=\"http://www.w3.org/TR/selectors/#root-pseudo\">:root selector</a>\n      *\n      */\n     public static final class IsRoot extends Evaluator {\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n         \n         while (node != null) {\n             visitor.head(node, depth);\n-            if (node.childNodes().size() > 0) {\n+            if (node.childNodeSize() > 0) {\n                 node = node.childNode(0);\n                 depth++;\n             } else {\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n \t\t\ta = 2;\n \t\t\tb = 0;\n \t\t} else if (mAB.matches()) {\n-\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1)\n-\t\t\t\t\t.replaceFirst(\"^\\\\+\", \"\")) : 1;\n-\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4)\n-\t\t\t\t\t.replaceFirst(\"^\\\\+\", \"\")) : 0;\n+\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n+\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n \t\t} else if (mB.matches()) {\n \t\t\ta = 0;\n \t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n \t\t} else {\n-\t\t\tthrow new Selector.SelectorParseException(\n-\t\t\t\t\t\"Could not parse nth-index '%s': unexpected format\", argS);\n+\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", argS);\n \t\t}\n \t\tif (ofType)\n \t\t\tif (backwards)\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n- * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n+ * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n+ * <tr><td colspan=\"3\"><h3>Structural pseudo selectors</h3></td></tr>\n+ * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>\n+ * <tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>\n+ * In addition to this, <code>:nth-child()</code> can take <code>odd</code> and <code>even</code> as arguments instead. <code>odd</code> has the same signification as <code>2n+1</code>, and <code>even</code> has the same signification as <code>2n</code>.</td><td><code>tr:nth-child(2n+1)</code> finds every odd row of a table. <code>:nth-child(10n-1)</code> the 9th, 19th, 29th, etc, element. <code>li:nth-child(5)</code> the 5h li</td></tr>\n+ * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n+ * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n+ * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n+ * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div > p:first-child</code></td></tr>\n+ * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol > li:last-child</code></td></tr>\n+ * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n+ * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr > td:last-of-type</code></td></tr>\n+ * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>\n+ * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n+ * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>\n  * </table>\n  *\n  * @author Jonathan Hedley, jonathan@hedley.net\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n public class DataUtilTest {\n     @Test\n     public void testCharset() {\n-        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=utf-8 \"));\n+        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=utf-8 \"));\n         assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=UTF-8\"));\n         assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=ISO-8859-1\"));\n         assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html\"));\n         assertEquals(null, DataUtil.getCharsetFromContentType(null));\n+        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html;charset=Unknown\"));\n     }\n \n     @Test public void testQuotedCharset() {\n-        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"utf-8\\\"\"));\n-        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=\\\"utf-8\\\"\"));\n+        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"utf-8\\\"\"));\n+        assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=\\\"UTF-8\\\"\"));\n         assertEquals(\"ISO-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"ISO-8859-1\\\"\"));\n+        assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=\\\"Unsupported\\\"\"));\n     }\n     \n     @Test public void discardsSpuriousByteOrderMark() {\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n package org.jsoup.helper;\n \n+import org.jsoup.Jsoup;\n import org.junit.Test;\n \n import java.util.Arrays;\n         assertTrue(check2 != StringUtil.normaliseWhitespace(check2));\n         assertTrue(check3 != StringUtil.normaliseWhitespace(check3));\n     }\n+\n+    @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {\n+        String test71540chars = \"\\ud869\\udeb2\\u304b\\u309a  1\";\n+        String test71540charsExpectedSingleWhitespace = \"\\ud869\\udeb2\\u304b\\u309a 1\";\n+\n+        assertEquals(test71540charsExpectedSingleWhitespace, StringUtil.normaliseWhitespace(test71540chars));\n+        String extractedText = Jsoup.parse(test71540chars).text();\n+        assertEquals(test71540charsExpectedSingleWhitespace, extractedText);\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/ParseTest.java\n+++ b/src/test/java/org/jsoup/integration/ParseTest.java\n         assertEquals(\"<title>\u767e\u5ea6\u4e00\u4e0b\uff0c\u4f60\u5c31\u77e5\u9053      </title>\", doc.select(\"title\").outerHtml());\n \n         doc.outputSettings().charset(\"ascii\");\n-        assertEquals(\"<title>&#30334;&#24230;&#19968;&#19979;&#65292;&#20320;&#23601;&#30693;&#36947;      </title>\",\n+        assertEquals(\"<title>&#x767e;&#x5ea6;&#x4e00;&#x4e0b;&#xff0c;&#x4f60;&#x5c31;&#x77e5;&#x9053;      </title>\",\n             doc.select(\"title\").outerHtml());\n     }\n \n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n package org.jsoup.integration;\n \n+import org.jsoup.HttpStatusException;\n+import org.jsoup.UnsupportedMimeTypeException;\n import org.junit.Test;\n import org.junit.Ignore;\n import static org.junit.Assert.*;\n import org.jsoup.Jsoup;\n import org.jsoup.Connection;\n \n+import java.net.MalformedURLException;\n import java.net.URL;\n import java.io.IOException;\n import java.util.Map;\n         Connection.Response res = Jsoup.connect(\"http://www.baidu.com/\").timeout(10*1000).execute();\n         Document doc = res.parse();\n \n-        assertEquals(\"GB2312\", doc.outputSettings().charset().displayName());\n-        assertEquals(\"GB2312\", res.charset());\n+        assertEquals(\"GBK\", doc.outputSettings().charset().displayName());\n+        assertEquals(\"GBK\", res.charset());\n         assert(res.hasCookie(\"BAIDUID\"));\n-        assertEquals(\"text/html;charset=gb2312\", res.contentType());\n+        assertEquals(\"text/html;charset=gbk\", res.contentType());\n     }\n     \n     @Test\n         boolean threw = false;\n         try {\n             Document doc = Jsoup.parse(new URL(url), 3000);\n-        } catch (IOException e) {\n-            threw = true;\n+        } catch (UnsupportedMimeTypeException e) {\n+            threw = true;\n+            assertEquals(\"org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://jsoup.org/rez/osi_logo.png\", e.toString());\n+            assertEquals(url, e.getUrl());\n+            assertEquals(\"image/png\", e.getMimeType());\n+        } catch (IOException e) {\n+        }\n+        assertTrue(threw);\n+    }\n+\n+    @Test\n+    public void exceptOnUnsupportedProtocol(){\n+        String url = \"file://etc/passwd\";\n+        boolean threw = false;\n+        try {\n+            Document doc = Jsoup.connect(url).get();\n+        } catch (MalformedURLException e) {\n+            threw = true;\n+            assertEquals(\"java.net.MalformedURLException: Only http & https protocols supported\", e.toString());\n+        } catch (IOException e) {\n         }\n         assertTrue(threw);\n     }\n \n     @Test\n     public void throwsExceptionOnError() {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/404\");\n+        String url = \"http://direct.infohound.net/tools/404\";\n+        Connection con = Jsoup.connect(url);\n         boolean threw = false;\n         try {\n             Document doc = con.get();\n-        } catch (IOException e) {\n-            threw = true;\n+        } catch (HttpStatusException e) {\n+            threw = true;\n+            assertEquals(\"org.jsoup.HttpStatusException: HTTP error fetching URL. Status=404, URL=http://direct.infohound.net/tools/404\", e.toString());\n+            assertEquals(url, e.getUrl());\n+            assertEquals(404, e.getStatusCode());\n+        } catch (IOException e) {\n         }\n         assertTrue(threw);\n     }\n         Connection.Response res = con.execute();\n         Document doc = res.parse();\n         assertEquals(404, res.statusCode());\n-        assertEquals(\"Not Found\", doc.select(\"h1\").first().text());\n+        assertEquals(\"404 Not Found\", doc.select(\"h1\").first().text());\n     }\n \n     @Test\n         Document doc = Jsoup.connect(echoURL).cookies(cookies).get();\n         assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc));\n     }\n+\n+    @Test\n+    public void handlesDodgyCharset() throws IOException {\n+        // tests that when we get back \"UFT8\", that it is recognised as unsupported, and falls back to default instead\n+        String url = \"http://direct.infohound.net/tools/bad-charset.pl\";\n+        Connection.Response res = Jsoup.connect(url).execute();\n+        assertEquals(\"text/html; charset=UFT8\", res.header(\"Content-Type\")); // from the header\n+        assertEquals(null, res.charset()); // tried to get from header, not supported, so returns null\n+        Document doc = res.parse(); // would throw an error if charset unsupported\n+        assertTrue(doc.text().contains(\"Hello!\"));\n+        assertEquals(\"UTF-8\", res.charset()); // set from default on parse\n+    }\n+\n+    @Test\n+    public void maxBodySize() throws IOException {\n+        String url = \"http://direct.infohound.net/tools/large.html\"; // 280 K\n+\n+        Connection.Response defaultRes = Jsoup.connect(url).execute();\n+        Connection.Response smallRes = Jsoup.connect(url).maxBodySize(50 * 1024).execute(); // crops\n+        Connection.Response mediumRes = Jsoup.connect(url).maxBodySize(200 * 1024).execute(); // crops\n+        Connection.Response largeRes = Jsoup.connect(url).maxBodySize(300 * 1024).execute(); // does not crop\n+        Connection.Response unlimitedRes = Jsoup.connect(url).maxBodySize(0).execute();\n+\n+        int actualString = 280735;\n+        assertEquals(actualString, defaultRes.body().length());\n+        assertEquals(50 * 1024, smallRes.body().length());\n+        assertEquals(200 * 1024, mediumRes.body().length());\n+        assertEquals(actualString, largeRes.body().length());\n+        assertEquals(actualString, unlimitedRes.body().length());\n+\n+        int actualDocText = 269541;\n+        assertEquals(actualDocText, defaultRes.parse().text().length());\n+        assertEquals(49165, smallRes.parse().text().length());\n+        assertEquals(196577, mediumRes.parse().text().length());\n+        assertEquals(actualDocText, largeRes.parse().text().length());\n+        assertEquals(actualDocText, unlimitedRes.parse().text().length());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/AttributeTest.java\n+++ b/src/test/java/org/jsoup/nodes/AttributeTest.java\n package org.jsoup.nodes;\n \n-import static org.junit.Assert.*;\n+import org.junit.Test;\n \n-import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n \n public class AttributeTest {\n     @Test public void html() {\n         assertEquals(\"key=\\\"value &amp;\\\"\", attr.html());\n         assertEquals(attr.html(), attr.toString());\n     }\n+\n+    @Test public void testWithSupplementaryCharacterInAttributeKeyAndValue() {\n+        String s = new String(Character.toChars(135361));\n+        Attribute attr = new Attribute(s, \"A\" + s + \"B\");\n+        assertEquals(s + \"=\\\"A\" + s + \"B\\\"\", attr.html());\n+        assertEquals(attr.html(), attr.toString());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n         withTitle.title(\"Hello\");\n         assertEquals(\"Hello\", withTitle.title());\n         assertEquals(\"Hello\", withTitle.select(\"title\").first().text());\n+\n+        Document normaliseTitle = Jsoup.parse(\"<title>   Hello\\nthere   \\n   now   \\n\");\n+        assertEquals(\"Hello there now\", normaliseTitle.title());\n     }\n \n     @Test public void testOutputEncoding() {\n \n         doc.outputSettings().charset(\"ascii\");\n         assertEquals(Entities.EscapeMode.base, doc.outputSettings().escapeMode());\n-        assertEquals(\"<p title=\\\"&#960;\\\">&#960; &amp; &lt; &gt; </p>\", doc.body().html());\n+        assertEquals(\"<p title=\\\"&#x3c0;\\\">&#x3c0; &amp; &lt; &gt; </p>\", doc.body().html());\n \n         doc.outputSettings().escapeMode(Entities.EscapeMode.extended);\n         assertEquals(\"<p title=\\\"&pi;\\\">&pi; &amp; &lt; &gt; </p>\", doc.body().html());\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n import java.util.Map;\n         Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n         assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>Hello <span>jsoup <span>users</span></span></p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n     }\n+    \n+    @Test public void testFormatOutline() {\n+        Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n+        doc.outputSettings().outline(true);\n+        assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>\\n    Hello \\n    <span>\\n     jsoup \\n     <span>users</span>\\n    </span>\\n   </p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n+    }\n \n     @Test public void testSetIndent() {\n         Document doc = Jsoup.parse(\"<div><p>Hello\\nthere</p></div>\");\n         assertEquals(\"<div><p>One</p><p><span>Two</span></p></div><p><span>Two</span><span>Three</span></p>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n+    @Test public void testClonesClassnames() {\n+        Document doc = Jsoup.parse(\"<div class='one two'></div>\");\n+        Element div = doc.select(\"div\").first();\n+        Set<String> classes = div.classNames();\n+        assertEquals(2, classes.size());\n+        assertTrue(classes.contains(\"one\"));\n+        assertTrue(classes.contains(\"two\"));\n+\n+        Element copy = div.clone();\n+        Set<String> copyClasses = copy.classNames();\n+        assertEquals(2, copyClasses.size());\n+        assertTrue(copyClasses.contains(\"one\"));\n+        assertTrue(copyClasses.contains(\"two\"));\n+        copyClasses.add(\"three\");\n+        copyClasses.remove(\"one\");\n+\n+        assertTrue(classes.contains(\"one\"));\n+        assertFalse(classes.contains(\"three\"));\n+        assertFalse(copyClasses.contains(\"one\"));\n+        assertTrue(copyClasses.contains(\"three\"));\n+\n+        assertEquals(\"\", div.html());\n+        assertEquals(\"\", copy.html());\n+    }\n+\n     @Test public void testTagNameSet() {\n         Document doc = Jsoup.parse(\"<div><i>Hello</i>\");\n         doc.select(\"i\").first().tagName(\"em\");\n         assertEquals(\"<p>One</p>\", els.get(0).outerHtml());\n         assertEquals(\"<p>Three</p>\", els.get(1).outerHtml());\n     }\n+\n+    @Test public void testChildThrowsIndexOutOfBoundsOnMissing() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p></div>\");\n+        Element div = doc.select(\"div\").first();\n+\n+        assertEquals(2, div.children().size());\n+        assertEquals(\"One\", div.child(0).text());\n+\n+        try {\n+            div.child(3);\n+            fail(\"Should throw index out of bounds\");\n+        } catch (IndexOutOfBoundsException e) {}\n+    }\n+\n+    @Test\n+    public void moveByAppend() {\n+        // test for https://github.com/jhy/jsoup/issues/239\n+        // can empty an element and append its children to another element\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(4, div1.childNodeSize());\n+        List<Node> children = div1.childNodes();\n+        assertEquals(4, children.size());\n+\n+        div2.insertChildren(0, children);\n+\n+        assertEquals(0, children.size()); // children is backed by div1.childNodes, moved, so should be 0 now\n+        assertEquals(0, div1.childNodeSize());\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\"></div>\\n<div id=\\\"2\\\">\\n Text \\n <p>One</p> Text \\n <p>Two</p>\\n</div>\",\n+            doc.body().html());\n+    }\n+\n+    @Test\n+    public void insertChildrenArgumentValidation() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        List<Node> children = div1.childNodes();\n+\n+        try {\n+            div2.insertChildren(6, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n+\n+        try {\n+            div2.insertChildren(-5, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        try {\n+            div2.insertChildren(0, null);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void insertChildrenAtPosition() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text1 <p>One</p> Text2 <p>Two</p></div><div id=2>Text3 <p>Three</p></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Elements p1s = div1.select(\"p\");\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(2, div2.childNodeSize());\n+        div2.insertChildren(-1, p1s);\n+        assertEquals(2, div1.childNodeSize()); // moved two out\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(3, p1s.get(1).siblingIndex()); // should be last\n+\n+        List<Node> els = new ArrayList<Node>();\n+        Element el1 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span1\");\n+        Element el2 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span2\");\n+        TextNode tn1 = new TextNode(\"Text4\", \"\");\n+        els.add(el1);\n+        els.add(el2);\n+        els.add(tn1);\n+\n+        assertNull(el1.parent());\n+        div2.insertChildren(-2, els);\n+        assertEquals(div2, el1.parent());\n+        assertEquals(7, div2.childNodeSize());\n+        assertEquals(3, el1.siblingIndex());\n+        assertEquals(4, el2.siblingIndex());\n+        assertEquals(5, tn1.siblingIndex());\n+    }\n+\n+    @Test\n+    public void insertChildrenAsCopy() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        Elements ps = doc.select(\"p\").clone();\n+        ps.first().text(\"One cloned\");\n+        div2.insertChildren(-1, ps);\n+\n+        assertEquals(4, div1.childNodeSize()); // not moved -- cloned\n+        assertEquals(2, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\">Text <p>One</p> Text <p>Two</p></div><div id=\\\"2\\\"><p>One cloned</p><p>Two</p></div>\",\n+            TextUtil.stripNewlines(doc.body().html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n-import org.jsoup.nodes.Entities;\n \n import java.nio.charset.Charset;\n \n         String escapedAscii = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.base);\n         String escapedAsciiFull = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.extended);\n         String escapedAsciiXhtml = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.xhtml);\n+        String escapedUtfFull = Entities.escape(text, Charset.forName(\"UTF-8\").newEncoder(), Entities.EscapeMode.base);\n+        String escapedUtfMin = Entities.escape(text, Charset.forName(\"UTF-8\").newEncoder(), Entities.EscapeMode.xhtml);\n+\n+        assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; &#x3c0; &#x65b0; there &frac34; &copy;\", escapedAscii);\n+        assertEquals(\"Hello &amp;&lt;&gt; &angst; &aring; &pi; &#x65b0; there &frac34; &copy;\", escapedAsciiFull);\n+        assertEquals(\"Hello &amp;&lt;&gt; &#xc5; &#xe5; &#x3c0; &#x65b0; there &#xbe; &#xa9;\", escapedAsciiXhtml);\n+        assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; \u03c0 \u65b0 there &frac34; &copy;\", escapedUtfFull);\n+        assertEquals(\"Hello &amp;&lt;&gt; \u00c5 \u00e5 \u03c0 \u65b0 there \u00be \u00a9\", escapedUtfMin);\n+        // odd that it's defined as aring in base but angst in full\n+\n+        // round trip\n+        assertEquals(text, Entities.unescape(escapedAscii));\n+        assertEquals(text, Entities.unescape(escapedAsciiFull));\n+        assertEquals(text, Entities.unescape(escapedAsciiXhtml));\n+        assertEquals(text, Entities.unescape(escapedUtfFull));\n+        assertEquals(text, Entities.unescape(escapedUtfMin));\n+    }\n+\n+    @Test public void escapeSupplementaryCharacter(){\n+        String text = new String(Character.toChars(135361));\n+        String escapedAscii = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.base);\n+        assertEquals(\"&#x210c1;\", escapedAscii);\n         String escapedUtf = Entities.escape(text, Charset.forName(\"UTF-8\").newEncoder(), Entities.EscapeMode.base);\n-\n-        assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; &#960; &#26032; there &frac34; &copy;\", escapedAscii);\n-        assertEquals(\"Hello &amp;&lt;&gt; &angst; &aring; &pi; &#26032; there &frac34; &copy;\", escapedAsciiFull);\n-        assertEquals(\"Hello &amp;&lt;&gt; &#197; &#229; &#960; &#26032; there &#190; &#169;\", escapedAsciiXhtml);\n-        assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; \u03c0 \u65b0 there &frac34; &copy;\", escapedUtf);\n-        // odd that it's defined as aring in base but angst in full\n+        assertEquals(text, escapedUtf);\n     }\n \n     @Test public void unescape() {\n-        String text = \"Hello &amp;&LT&gt; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n-        assertEquals(\"Hello &<> \u00c5 \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n+        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n+        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n \n         assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));\n     }\n \n-    @Test public void strictUnescape() { // for attributes, enforce strict unescaping (must look like &xxx; , not just &xxx)\n-        String text = \"Hello &mid &amp;\";\n-        assertEquals(\"Hello &mid &\", Entities.unescape(text, true));\n-        assertEquals(\"Hello \u2223 &\", Entities.unescape(text));\n-        assertEquals(\"Hello \u2223 &\", Entities.unescape(text, false));\n+    @Test public void strictUnescape() { // for attributes, enforce strict unescaping (must look like &#xxx; , not just &#xxx)\n+        String text = \"Hello &amp= &amp;\";\n+        assertEquals(\"Hello &amp= &\", Entities.unescape(text, true));\n+        assertEquals(\"Hello &= &\", Entities.unescape(text));\n+        assertEquals(\"Hello &= &\", Entities.unescape(text, false));\n     }\n \n     \n         assertEquals(\"&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;\", p.html());\n         assertEquals(\"\u00b9\u00b2\u00b3\u00bc\u00bd\u00be\", p.text());\n     }\n+\n+    @Test public void noSpuriousDecodes() {\n+        String string = \"http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\";\n+        assertEquals(string, Entities.unescape(string));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n         assertEquals(\"odd\", el.attr(\"abs:href\"));\n     }\n \n+    @Test public void handleAbsOnFileUris() {\n+        Document doc = Jsoup.parse(\"<a href='password'>One/a><a href='/var/log/messages'>Two</a>\", \"file:/etc/\");\n+        Element one = doc.select(\"a\").first();\n+        assertEquals(\"file:/etc/password\", one.absUrl(\"href\"));\n+        Element two = doc.select(\"a\").get(1);\n+        assertEquals(\"file:/var/log/messages\", two.absUrl(\"href\"));\n+    }\n+\n+    @Test\n+    public void handleAbsOnLocalhostFileUris() {\n+        Document doc = Jsoup.parse(\"<a href='password'>One/a><a href='/var/log/messages'>Two</a>\", \"file://localhost/etc/\");\n+        Element one = doc.select(\"a\").first();\n+        assertEquals(\"file://localhost/etc/password\", one.absUrl(\"href\"));\n+    }\n+\n     /*\n     Test for an issue with Java's abs URL handler.\n      */\n         assertEquals(\"<p>One</p>\", nodes.get(0).outerHtml());\n         assertEquals(\"<p>Three</p>\", nodes.get(1).outerHtml());\n     }\n+\n+    @Test public void childNodesCopy() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text 1 <p>One</p> Text 2 <p>Two<p>Three</div><div id=2>\");\n+        Element div1 = doc.select(\"#1\").first();\n+        Element div2 = doc.select(\"#2\").first();\n+        List<Node> divChildren = div1.childNodesCopy();\n+        assertEquals(5, divChildren.size());\n+        TextNode tn1 = (TextNode) div1.childNode(0);\n+        TextNode tn2 = (TextNode) divChildren.get(0);\n+        tn2.text(\"Text 1 updated\");\n+        assertEquals(\"Text 1 \", tn1.text());\n+        div2.insertChildren(-1, divChildren);\n+        assertEquals(\"<div id=\\\"1\\\">Text 1 <p>One</p> Text 2 <p>Two</p><p>Three</p></div><div id=\\\"2\\\">Text 1 updated\"\n+            +\"<p>One</p> Text 2 <p>Two</p><p>Three</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/TextNodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/TextNodeTest.java\n \n         assertEquals(\"Hello <b>there</b>\", TextUtil.stripNewlines(div.html())); // not great that we get \\n<b>there there... must correct\n     }\n+\n+    @Test public void testWithSupplementaryCharacter(){\n+        Document doc = Jsoup.parse(new String(Character.toChars(135361)));\n+        TextNode t = doc.body().textNodes().get(0);\n+        assertEquals(new String(Character.toChars(135361)), t.outerHtml().trim());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n     @Test public void strictAttributeUnescapes() {\n         String html = \"<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>\";\n         Elements els = Jsoup.parse(html).select(\"a\");\n-        assertEquals(\"?foo=bar\u2223&lt=true\", els.first().attr(\"href\")); // &mid gets to \u2223 because not tailed by =; lt is so not unescaped\n+        assertEquals(\"?foo=bar&mid&lt=true\", els.first().attr(\"href\"));\n         assertEquals(\"?foo=bar<qux&lg=1\", els.last().attr(\"href\"));\n     }\n \n     @Test public void moreAttributeUnescapes() {\n         String html = \"<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>\";\n         Elements els = Jsoup.parse(html).select(\"a\");\n-        assertEquals(\"&wr_id=123&mid-size=true&ok=\u2240\", els.first().attr(\"href\"));\n+        assertEquals(\"&wr_id=123&mid-size=true&ok=&wr\", els.first().attr(\"href\"));\n     }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         Element div = doc.getElementById(\"1\");\n         assertEquals(\"<html> <foo><&amp;\", div.text());\n         assertEquals(0, div.children().size());\n-        assertEquals(1, div.childNodes().size()); // no elements, one text node\n+        assertEquals(1, div.childNodeSize()); // no elements, one text node\n     }\n \n     @Test public void handlesInvalidStartTags() {\n     }\n \n     @Test public void handlesKnownEmptyBlocks() {\n-        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.\n-        String h = \"<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two\";\n-        Document doc = Jsoup.parse(h);\n-        Element div1 = doc.getElementById(\"1\");\n-        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...\n-        assertTrue(doc.select(\"hr\").first().children().isEmpty());\n-        assertTrue(doc.select(\"hr\").last().children().isEmpty());\n-        assertTrue(doc.select(\"img\").first().children().isEmpty());\n-        assertTrue(doc.select(\"img\").last().children().isEmpty());\n+        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n+        String h = \"<div id='1' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<div id=\\\"1\\\"></div><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void handlesSolidusAtAttributeEnd() {\n         assertEquals(\"html\", nodes.get(0).nodeName());\n         assertEquals(\"<html> <head></head> <body> <ol> <li>One</li> </ol> <p>Two</p> </body> </html>\", StringUtil.normaliseWhitespace(nodes.get(0).outerHtml()));\n     }\n+\n+    @Test public void doesNotFindShortestMatchingEntity() {\n+        // previous behaviour was to identify a possible entity, then chomp down the string until a match was found.\n+        // (as defined in html5.) However in practise that lead to spurious matches against the author's intent.\n+        String html = \"One &clubsuite; &clubsuit;\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(StringUtil.normaliseWhitespace(\"One &amp;clubsuite; \u2663\"), doc.body().html());\n+    }\n+\n+    @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch() {\n+        // extended entities need a ; at the end to match, base does not\n+        String html = \"&amp &quot &reg &icy &hopf &icy; &hopf;\";\n+        Document doc = Jsoup.parse(html);\n+        doc.outputSettings().escapeMode(Entities.EscapeMode.extended); // modifies output only to clarify test\n+        assertEquals(StringUtil.normaliseWhitespace(\"&amp; &quot; &reg; &amp;icy &amp;hopf &icy; &hopf;\"), doc.body().html());\n+    }\n+\n+    @Test public void handlesXmlDeclarationAsBogusComment() {\n+        String html = \"<?xml encoding='UTF-8' ?><body>One</body>\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<!--?xml encoding='UTF-8' ?--> <html> <head></head> <body> One </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void handlesTagsInTextarea() {\n+        String html = \"<textarea><p>Jsoup</p></textarea>\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<textarea>&lt;p&gt;Jsoup&lt;/p&gt;</textarea>\", doc.body().html());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n+import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URISyntaxException;\n+import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotSame;\n         Document xmlDoc = Jsoup.parse(\"<br>one</br>\", \"\", Parser.xmlParser());\n         assertEquals(\"<br>one</br>\", xmlDoc.html());\n     }\n+\n+    @Test public void handlesXmlDeclarationAsDeclaration() {\n+        String html = \"<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->\";\n+        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n+        assertEquals(\"<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->\",\n+                StringUtil.normaliseWhitespace(doc.outerHtml()));\n+        assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n+        assertEquals(\"#comment\", doc.childNode(2).nodeName());\n+    }\n+\n+    @Test public void xmlFragment() {\n+        String xml = \"<one src='/foo/' />Two<three><four /></three>\";\n+        List<Node> nodes = Parser.parseXmlFragment(xml, \"http://example.com/\");\n+        assertEquals(3, nodes.size());\n+\n+        assertEquals(\"http://example.com/foo/\", nodes.get(0).absUrl(\"src\"));\n+        assertEquals(\"one\", nodes.get(0).nodeName());\n+        assertEquals(\"Two\", ((TextNode)nodes.get(1)).text());\n+    }\n }\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Entities;\n-import org.jsoup.safety.Whitelist;\n import org.junit.Test;\n import static org.junit.Assert.*;\n \n         String ok = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\";\n         String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n         String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n+        String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n         assertTrue(Jsoup.isValid(ok, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));\n     }\n     \n     @Test public void resolvesRelativeLinks() {\n         assertEquals(\"<a href=\\\"http://example.com/foo\\\" rel=\\\"nofollow\\\">Link</a>\\n<img src=\\\"http://example.com/bar\\\" />\", clean);\n     }\n \n-    @Test public void preservesRelatedLinksIfConfigured() {\n+    @Test public void preservesRelativeLinksIfConfigured() {\n         String html = \"<a href='/foo'>Link</a><img src='/bar'> <img src='javascript:alert()'>\";\n         String clean = Jsoup.clean(html, \"http://example.com/\", Whitelist.basicWithImages().preserveRelativeLinks(true));\n         assertEquals(\"<a href=\\\"/foo\\\" rel=\\\"nofollow\\\">Link</a>\\n<img src=\\\"/bar\\\" /> \\n<img />\", clean);\n         os.charset(\"ASCII\");\n         os.escapeMode(Entities.EscapeMode.base);\n         String customOut2 = Jsoup.clean(html, \"http://foo.com/\", Whitelist.relaxed(), os);\n-        assertEquals(\"<div><p>&#8492;</p></div>\", customOut2);\n+        assertEquals(\"<div><p>&#x212c;</p></div>\", customOut2);\n     }\n \n     @Test public void handlesFramesets() {\n         Document dirtyDoc = Jsoup.parse(dirty);\n         Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n         assertFalse(cleanDoc == null);\n-        assertEquals(0, cleanDoc.body().childNodes().size());\n+        assertEquals(0, cleanDoc.body().childNodeSize());\n+    }\n+\n+    @Test public void cleansInternationalText() {\n+        assertEquals(\"\u043f\u0440\u0438\u0432\u0435\u0442\", Jsoup.clean(\"\u043f\u0440\u0438\u0432\u0435\u0442\", Whitelist.none()));\n     }\n }\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n         assertEquals(\"<p><i><b>This</b></i> is <i><b>jsoup</b></i></p>\", doc.body().html());\n     }\n \n+    @Test public void wrapDiv() {\n+        String h = \"<p><b>This</b> is <b>jsoup</b>.</p> <p>How do you like it?</p>\";\n+        Document doc = Jsoup.parse(h);\n+        doc.select(\"p\").wrap(\"<div></div>\");\n+        assertEquals(\"<div><p><b>This</b> is <b>jsoup</b>.</p></div> <div><p>How do you like it?</p></div>\",\n+                TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n     @Test public void unwrap() {\n         String h = \"<div><font>One</font> <font><a href=\\\"/\\\">Two</a></font></div\";\n         Document doc = Jsoup.parse(h);\n         doc.select(\"font\").unwrap();\n         assertEquals(\"<div>One <a href=\\\"/\\\">Two</a></div>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void unwrapP() {\n+        String h = \"<p><a>One</a> Two</p> Three <i>Four</i> <p>Fix <i>Six</i></p>\";\n+        Document doc = Jsoup.parse(h);\n+        doc.select(\"p\").unwrap();\n+        assertEquals(\"<a>One</a> Two Three <i>Four</i> Fix <i>Six</i>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void empty() {\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.junit.Test;\n+\n import static org.junit.Assert.*;\n \n /**\n- Tests that the selector selects correctly.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * Tests that the selector selects correctly.\n+ *\n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ */\n public class SelectorTest {\n     @Test public void testByTag() {\n         Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\").select(\"div\");\n         assertEquals(\"li\", containers.get(1).tagName());\n         assertEquals(\"123\", containers.get(1).text());\n     }\n+\n+    @Test public void selectSupplementaryCharacter() {\n+        String s = new String(Character.toChars(135361));\n+        Document doc = Jsoup.parse(\"<div k\" + s + \"='\" + s + \"'>^\" + s +\"$/div>\");\n+        assertEquals(\"div\", doc.select(\"div[k\" + s + \"]\").first().tagName());\n+        assertEquals(\"div\", doc.select(\"div:containsOwn(\" + s + \")\").first().tagName());\n+    }\n }", "timestamp": 1359331278, "metainfo": ""}