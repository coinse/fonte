{"sha": "db11c04d29dd50f4405c51043b40f0d47d15925d", "log": "[CSV-68] Use the Builder pattern for CSVFormat.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n import java.io.Reader;\n import java.io.Serializable;\n import java.io.StringWriter;\n+import java.util.Arrays;\n \n /**\n  * The format specification of a CSV file.\n  *\n  * This class is immutable.\n- * \n+ *\n  * @version $Id$\n  */\n public class CSVFormat implements Serializable {\n \n     /**\n      * Creates a new CSV format builds.\n-     * \n-     * @param delimiter \n+     *\n+     * @param delimiter\n      *            the char used for value separation, must not be a line break character\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n     public static CSVFormatBuilder newBuilder(final CSVFormat format) {\n         return new CSVFormatBuilder(format);\n     }\n-    \n+\n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n      * <ul>\n      *            the char used for value separation, must not be a line break character\n      * @param quoteChar\n      *            the char used as value encapsulation marker\n-     * @param quotePolicy \n+     * @param quotePolicy\n      *            the quote policy\n      * @param commentStart\n      *            the char used for comment identification\n      *            the header\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final \n-                    boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator, \n-            final String[] header) {\n-        if (isLineBreak(delimiter)) {\n+    private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final\n+                    boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator,\n+ final String[] header)\n+    {\n+        if (isLineBreak(delimiter))\n+        {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.delimiter = delimiter;\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         this.recordSeparator = lineSeparator;\n-        this.header = header;\n+        this.header = header == null ? null : header.clone();\n     }\n \n     /**\n     public Quote getQuotePolicy() {\n         return quotePolicy;\n     }\n-    \n+\n+    @Override\n+    public int hashCode()\n+    {\n+        final int prime = 31;\n+        int result = 1;\n+\n+        result = prime * result + delimiter;\n+        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n+        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n+        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n+        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n+        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n+        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n+        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n+        result = prime * result + Arrays.hashCode(header);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj)\n+    {\n+        if (this == obj)\n+        {\n+            return true;\n+        }\n+        if (obj == null)\n+        {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass())\n+        {\n+            return false;\n+        }\n+\n+        CSVFormat other = (CSVFormat) obj;\n+        if (delimiter != other.delimiter)\n+        {\n+            return false;\n+        }\n+        if (quotePolicy != other.quotePolicy)\n+        {\n+            return false;\n+        }\n+        if (quoteChar == null)\n+        {\n+            if (other.quoteChar != null)\n+            {\n+                return false;\n+            }\n+        }\n+        else if (!quoteChar.equals(other.quoteChar))\n+        {\n+            return false;\n+        }\n+        if (commentStart == null)\n+        {\n+            if (other.commentStart != null)\n+            {\n+                return false;\n+            }\n+        }\n+        else if (!commentStart.equals(other.commentStart))\n+        {\n+            return false;\n+        }\n+        if (escape == null)\n+        {\n+            if (other.escape != null)\n+            {\n+                return false;\n+            }\n+        }\n+        else if (!escape.equals(other.escape))\n+        {\n+            return false;\n+        }\n+        if (!Arrays.equals(header, other.header))\n+        {\n+            return false;\n+        }\n+        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces)\n+        {\n+            return false;\n+        }\n+        if (ignoreEmptyLines != other.ignoreEmptyLines)\n+        {\n+            return false;\n+        }\n+        if (recordSeparator == null)\n+        {\n+            if (other.recordSeparator != null)\n+            {\n+                return false;\n+            }\n+        }\n+        else if (!recordSeparator.equals(other.recordSeparator))\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     public static class CSVFormatBuilder {\n \n         private char delimiter;\n          *            the char used for value separation, must not be a line break character\n          * @param quoteChar\n          *            the char used as value encapsulation marker\n-         * @param quotePolicy \n+         * @param quotePolicy\n          *            the quote policy\n          * @param commentStart\n          *            the char used for comment identification\n          * @throws IllegalArgumentException if the delimiter is a line break character\n          */\n         // package protected for use by test code\n-        CSVFormatBuilder(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final \n-                        boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator, \n+        CSVFormatBuilder(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final\n+                        boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator,\n                 final String[] header) {\n             if (isLineBreak(delimiter)) {\n                 throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n             this.recordSeparator = lineSeparator;\n             this.header = header;\n         }\n-        \n-        /**\n-         * \n+\n+        /**\n+         *\n          * Creates a CSVFormatBuilder, using the values of the given CSVFormat.\n-         * \n+         *\n          * @param format\n          *            The format to use values from\n          */\n \n         /**\n          * Creates a basic CSVFormatBuilder.\n-         * \n-         * @param delimiter \n+         *\n+         * @param delimiter\n          *            the char used for value separation, must not be a line break character\n          * @throws IllegalArgumentException if the delimiter is a line break character\n          */\n             return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                                  ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n         }\n-        \n+\n         /**\n          * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n-         * \n+         *\n          * @throws IllegalStateException\n          */\n         private void validate() throws IllegalStateException {\n             if (quoteChar != null && delimiter == quoteChar.charValue()) {\n                 throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n             }\n-        \n+\n             if (escape != null && delimiter == escape.charValue()) {\n                 throw new IllegalStateException(\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n             }\n-        \n+\n             if (commentStart != null && delimiter == commentStart.charValue()) {\n-                throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \n+                throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart +\n                         \"')\");\n             }\n-        \n+\n             if (quoteChar != null && quoteChar.equals(commentStart)) {\n-                throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \n+                throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart +\n                         \"')\");\n             }\n-        \n+\n             if (escape != null && escape.equals(commentStart)) {\n                 throw new IllegalStateException(\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n             }\n-        \n+\n             if (escape == null && quotePolicy == Quote.NONE) {\n                 throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n             }\n             if (isLineBreak(delimiter)) {\n                 throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n             }\n-            this.delimiter = delimiter; \n+            this.delimiter = delimiter;\n             return this;\n         }\n \n             this.header = header;\n             return this;\n         }\n-        \n+\n         /**\n          * Sets the trimming behavior of the format.\n          *\n--- a/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.LF;\n-import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n     @Test\n     public void testCopiedFormatIsEqualToOriginal() {\n         CSVFormat copyOfRCF4180 = CSVFormat.newBuilder(RFC4180).build();\n-        assertEqualFormats(RFC4180, copyOfRCF4180);\n+        assertEquals(RFC4180, copyOfRCF4180);\n     }\n \n     @Test\n         assertTrue(newFormat.getDelimiter() != RFC4180.getDelimiter());\n     }\n     \n-    // FIXME implement equals on CSVFormat to allow use of Assert.assertEquals()\n-    private static void assertEqualFormats(CSVFormat expected, CSVFormat acutal) {\n-        assertEquals(expected.getCommentStart(), acutal.getCommentStart());\n-        assertEquals(expected.getDelimiter(), acutal.getDelimiter());\n-        assertEquals(expected.getEscape(), acutal.getEscape());\n-        assertArrayEquals(expected.getHeader(), acutal.getHeader());\n-        assertEquals(expected.getIgnoreEmptyLines(), acutal.getIgnoreEmptyLines());\n-        assertEquals(expected.getIgnoreSurroundingSpaces(), acutal.getIgnoreSurroundingSpaces());\n-        assertEquals(expected.getQuoteChar(), acutal.getQuoteChar());\n-        assertEquals(expected.getQuotePolicy(), acutal.getQuotePolicy());\n-        assertEquals(expected.getRecordSeparator(), acutal.getRecordSeparator());\n+    @Test\n+    public void testHeaderReferenceCannotEscape() {\n+        String[] header = new String[]{\"one\", \"tow\", \"three\"};\n+        builder.withHeader(header);\n+        \n+        CSVFormat firstFormat = builder.build();\n+        CSVFormat secondFormat = builder.build();\n+        assertNotSame(header, firstFormat.getHeader());\n+        assertNotSame(firstFormat, secondFormat.getHeader());\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n package org.apache.commons.csv;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n \n import java.io.ByteArrayInputStream;\n         assertEquals(\"trim\", CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines());\n     }\n+    \n+    @Test\n+    public void testEquals() {\n+        CSVFormat right = CSVFormat.DEFAULT;\n+        CSVFormat left = CSVFormat.newBuilder().build();\n+\n+        assertFalse(right.equals(null));\n+        assertFalse(right.equals(\"A String Instance\"));\n+\n+        assertEquals(right, right);\n+        assertEquals(right, left);\n+        assertEquals(left, right);\n+        \n+        assertEquals(right.hashCode(), right.hashCode());\n+        assertEquals(right.hashCode(), left.hashCode());\n+    }\n+\n+    @Test\n+    public void testEqualsDelimiter() {\n+        CSVFormat right = CSVFormat.newBuilder('!').build();\n+        CSVFormat left = CSVFormat.newBuilder('?').build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsQuoteChar() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'').withQuoteChar('\"').build();\n+        CSVFormat left = CSVFormat.newBuilder(right).withQuoteChar('!').build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsQuotePolicy() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withQuotePolicy(Quote.MINIMAL)\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsCommentStart() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withCommentStart('!')\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsEscape() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withEscape('!')\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreSurroundingSpaces() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withIgnoreSurroundingSpaces(true)\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withIgnoreSurroundingSpaces(false)\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsIgnoreEmptyLines() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines(true)\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withIgnoreEmptyLines(false)\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsRecordSeparator() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines(true)\n+                .withRecordSeparator('*')\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withRecordSeparator('!')\n+                .build();\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsHeader() {\n+        CSVFormat right = CSVFormat.newBuilder('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL)\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines(true)\n+                .withRecordSeparator('*')\n+                .withHeader(\"One\", \"Two\", \"Three\")\n+                .build();\n+        CSVFormat left = CSVFormat.newBuilder(right)\n+                .withHeader(\"Three\", \"Two\", \"One\")\n+                .build();\n+        \n+        assertNotEquals(right, left);\n+    }\n+\n+    private static void assertNotEquals(Object right, Object left) {\n+        assertFalse(right.equals(left));\n+        assertFalse(left.equals(right));\n+    }\n }", "timestamp": 1353175238, "metainfo": ""}