{"sha": "7e63096d47883aa55b436f01649459c639ceca3c", "log": "Javadoc.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n /**\n  * Specifies the format of a CSV file and parses input.\n- * <p>\n- * This class is immutable.\n+ * <h4>Using predefined formats</h4>\n+ * <p>\n+ * You can use one of the predefined formats:\n  * </p>\n- * You can extend a format through a builder. For example, to extend the Excel format with columns header, you write:\n+ * <ul>\n+ * <li>{@link #DEFAULT}</li>\n+ * <li>{@link #EXCEL}</li>\n+ * <li>{@link #MYSQL}</li>\n+ * <li>{@link #RFC4180}</li>\n+ * </ul>\n+ * <p>For example:</p>\n+ * <pre>CSVParser parser = CSVFormat.EXCEL.parse(reader);</pre>\n+ * <p>The {@link CSVRecord} provides static methods to parse other input types, for example:</p>\n+ * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n+ * <h4>Defining formats</h4>\n+ * <p>\n+ * You can extend a format by calling the {@code with} methods. For example:\n+ * </p>\n+ * <pre>CSVFormat.EXCEL\n+ *   .withNullString(&quot;N/A&quot;)\n+ *   .withIgnoreSurroundingSpaces(true);</pre>\n+ * <h4>Defining column names</h4>\n+ * <p>\n+ * To define the column names you want to use to access records, write:\n  * </p>\n  * <pre>CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);</pre>\n  * <p>\n- * You can parse through a format. For example, to parse an Excel file with columns header, you write:\n+ * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and \n+ * assumes that your CSV source does not contain a first record that also defines column names. If it does, then\n+ * you are overriding this metadata with your names and you should skip the first record by calling \n+ * {@link #withSkipHeaderRecord(boolean)} with {@code true}. \n+ * </p>\n+ * <h4>Parsing</h4>\n+ * <p>\n+ * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n  * </p>\n  * <pre>Reader in = ...;\n  *CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);</pre>\n  * <p>\n- *\n+ * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n+ * </p>\n+ * <h4>Referencing columns safely</h4>\n+ * <p>\n+ * If your source contains a header record, you can simplify your code and safely reference columns, \n+ * by using {@link #withHeader(String...)} with no arguments:\n+ * </p>\n+ * <pre>CSVFormat.EXCEL.withHeader();</pre>\n+ * <p>\n+ * This causes the parser to read the first record and use its values as column names.\n+ * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n+ * </p> \n+ * <pre>String value = record.get(&quot;Col1&quot;);</pre>\n+ * <p>\n+ * This makes your code impervious to changes in column order in the CSV file.\n+ * </p>\n+ * <h4>Notes</h4> \n+ * <p>\n+ * This class is immutable.\n+ * </p>\n  * @version $Id$\n  */\n public class CSVFormat implements Serializable {", "timestamp": 1375381477, "metainfo": ""}