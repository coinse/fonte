{"sha": "38741a48c692ae2fc13cd2445e77ace6ecea1156", "log": "CSV-54 Confusing semantic of the ignore leading/trailing spaces parameters  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final char encapsulator;\n     private final char commentStart;\n     private final char escape;\n-    private final boolean leadingSpacesIgnored;\n-    private final boolean trailingSpacesIgnored;\n+    private final boolean surroundingSpacesIgnored; // Should leading/trailing spaces be ignored around values?\n     private final boolean emptyLinesIgnored;\n     private final String lineSeparator; // for outputs\n     private final String[] header;\n      * Starting format with no settings defined; used for creating other formats from scratch.\n      */\n     private static CSVFormat PRISTINE = \n-            new CSVFormat(DISABLED, DISABLED, DISABLED, DISABLED, false, false, false, null, null);\n+            new CSVFormat(DISABLED, DISABLED, DISABLED, DISABLED, false, false, null, null);\n \n     /** \n      * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines. \n             PRISTINE\n             .withDelimiter('\\t')\n             .withEncapsulator('\"')\n-            .withLeadingSpacesIgnored(true)\n-            .withTrailingSpacesIgnored(true)\n+            .withSurroundingSpacesIgnored(true)\n             .withEmptyLinesIgnored(true)\n             .withLineSeparator(CRLF)\n             ;\n      * @param encapsulator              the char used as value encapsulation marker\n      * @param commentStart              the char used for comment identification\n      * @param escape                    the char used to escape special characters in values\n-     * @param leadingSpacesIgnored      <tt>true</tt> when leading whitespaces should be ignored\n-     * @param trailingSpacesIgnored     <tt>true</tt> when trailing whitespaces should be ignored\n+     * @param surroundingSpacesIgnored  <tt>true</tt> when whitespaces enclosing values should be ignored\n      * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines\n      * @param lineSeparator             the line separator to use for output\n      * @param header                    the header\n             char encapsulator,\n             char commentStart,\n             char escape,\n-            boolean leadingSpacesIgnored,\n-            boolean trailingSpacesIgnored,\n+            boolean surroundingSpacesIgnored,\n             boolean emptyLinesIgnored,\n             String lineSeparator,\n             String[] header) {\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n         this.escape = escape;\n-        this.leadingSpacesIgnored = leadingSpacesIgnored;\n-        this.trailingSpacesIgnored = trailingSpacesIgnored;\n+        this.surroundingSpacesIgnored = surroundingSpacesIgnored;\n         this.emptyLinesIgnored = emptyLinesIgnored;\n         this.lineSeparator = lineSeparator;\n         this.header = header;\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEncapsulating() {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEscaping() {\n     }\n \n     /**\n-     * Tells if the spaces characters at the beginning of the values are ignored when parsing a file.\n-     * \n-     * @return <tt>true</tt> if leading spaces are removed, <tt>false</tt> if they are preserved.\n-     */\n-    public boolean isLeadingSpacesIgnored() {\n-        return leadingSpacesIgnored;\n-    }\n-\n-    /**\n-     * Returns a copy of this format with the specified left trimming behavior.\n-     *\n-     * @param leadingSpacesIgnored the left trimming behavior, <tt>true</tt> to remove the leading spaces,\n-     *                             <tt>false</tt> to leave the spaces as is.\n-     * @return A copy of this format with the specified left trimming behavior.\n-     */\n-    public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n-    }\n-\n-    /**\n-     * Tells if the spaces characters at the end of the values are ignored when parsing a file.\n-     * \n-     * @return <tt>true</tt> if trailing spaces are removed, <tt>false</tt> if they are preserved.\n-     */\n-    public boolean isTrailingSpacesIgnored() {\n-        return trailingSpacesIgnored;\n-    }\n-\n-    /**\n-     * Returns a copy of this format with the specified right trimming behavior.\n-     *\n-     * @param trailingSpacesIgnored the right trimming behavior, <tt>true</tt> to remove the trailing spaces,\n-     *                              <tt>false</tt> to leave the spaces as is.\n-     * @return A copy of this format with the specified right trimming behavior.\n-     */\n-    public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+     * Specifies whether spaces around values are ignored when parsing input.\n+     * \n+     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the value.\n+     */\n+    public boolean isSurroundingSpacesIgnored() {\n+        return surroundingSpacesIgnored;\n     }\n \n     /**\n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format  with the specified empty line skipping behavior.\n      */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     String[] getHeader() {\n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(String... header) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n         //  important: make sure a new char gets consumed in each iteration\n         while (tkn.type == INVALID) {\n             // ignore whitespaces at beginning of a token\n-            if (leadingSpacesIgnored) {\n+            if (surroundingSpacesIgnored) {\n                 while (isWhitespace(c) && !eol) {\n                     c = in.read();\n                     eol = isEndOfLine(c);\n             c = in.read();\n         }\n \n-        if (trailingSpacesIgnored) {\n+        if (surroundingSpacesIgnored) {\n             trimTrailingSpaces(tkn.content);\n         }\n \n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     private final char encapsulator;\n     private final char commmentStart;\n     \n-    final boolean leadingSpacesIgnored;\n-    final boolean trailingSpacesIgnored;\n+    final boolean surroundingSpacesIgnored;\n     final boolean emptyLinesIgnored;\n     \n     final CSVFormat format;\n         this.escape = format.getEscape();\n         this.encapsulator = format.getEncapsulator();\n         this.commmentStart = format.getCommentStart();\n-        this.leadingSpacesIgnored = format.isLeadingSpacesIgnored();\n-        this.trailingSpacesIgnored = format.isTrailingSpacesIgnored();\n+        this.surroundingSpacesIgnored = format.isSurroundingSpacesIgnored();\n         this.emptyLinesIgnored = format.isEmptyLinesIgnored();\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testImmutalibity() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, \"\\r\\n\", null);\n         \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n         format.withCommentStart('?');\n         format.withLineSeparator(\"?\");\n         format.withEscape('?');\n-        format.withLeadingSpacesIgnored(false);\n-        format.withTrailingSpacesIgnored(false);\n+        format.withSurroundingSpacesIgnored(false);\n         format.withEmptyLinesIgnored(false);\n         \n         assertEquals('!', format.getDelimiter());\n         assertEquals('!', format.getEscape());\n         assertEquals(\"\\r\\n\", format.getLineSeparator());\n         \n-        assertTrue(format.isLeadingSpacesIgnored());\n-        assertTrue(format.isTrailingSpacesIgnored());\n+        assertTrue(format.isSurroundingSpacesIgnored());\n         assertTrue(format.isEmptyLinesIgnored());\n     }\n \n     @Test\n     public void testMutators() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, \"\\r\\n\", null);\n         \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n         assertEquals('?', format.withEscape('?').getEscape());\n         \n-        assertFalse(format.withLeadingSpacesIgnored(false).isLeadingSpacesIgnored());\n-        assertFalse(format.withTrailingSpacesIgnored(false).isTrailingSpacesIgnored());\n-        assertFalse(format.withSurroundingSpacesIgnored(false).isLeadingSpacesIgnored());\n-        assertFalse(format.withSurroundingSpacesIgnored(false).isTrailingSpacesIgnored());\n+        assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored());\n         assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());\n     }\n \n         assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());\n         assertEquals(\"line separator\", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());\n         assertEquals(\"escape\", CSVFormat.DEFAULT.getEscape(), format.getEscape());\n-        assertEquals(\"trim left\", CSVFormat.DEFAULT.isLeadingSpacesIgnored(), format.isLeadingSpacesIgnored());\n-        assertEquals(\"trim right\", CSVFormat.DEFAULT.isTrailingSpacesIgnored(), format.isTrailingSpacesIgnored());\n+        assertEquals(\"trim\", CSVFormat.DEFAULT.isSurroundingSpacesIgnored(), format.isSurroundingSpacesIgnored());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());\n     }\n } \n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n         //  important: make sure a new char gets consumed in each iteration\n         while (!tkn.isReady && tkn.type != EOF) {\n             // ignore whitespaces at beginning of a token\n-            if (format.isLeadingSpacesIgnored()) {\n+            if (format.isSurroundingSpacesIgnored()) {\n                 while (isWhitespace(c) && !eol) {\n                     wsBuf.append((char) c);\n                     c = in.read();\n             } else {\n                 // next token must be a simple token\n                 // add removed blanks when not ignoring whitespace chars...\n-                if (!format.isLeadingSpacesIgnored()) {\n+                if (!format.isSurroundingSpacesIgnored()) {\n                     tkn.content.append(wsBuf);\n                 }\n                 simpleTokenLexer(tkn, c);\n             c = in.read();\n         }\n \n-        if (format.isTrailingSpacesIgnored()) {\n+        if (format.isSurroundingSpacesIgnored()) {\n             trimTrailingSpaces(tkn.content);\n         }\n \n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n     @Test\n     public void testNextToken1() throws IOException {\n         String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n         *        a,  \" foo \" ,b\n         */\n         String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(code));\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         for (String[] re : res) {\n-            assertTrue(Arrays.equals(re, parser.getRecord().values()));\n+            assertTrue(\"Failed to match: \"+Arrays.toString(re), Arrays.equals(re, parser.getRecord().values()));\n         }\n         \n         assertNull(parser.getRecord());\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(code));\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n \n-        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();\n         };\n \n \n-        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();", "timestamp": 1332788550, "metainfo": ""}