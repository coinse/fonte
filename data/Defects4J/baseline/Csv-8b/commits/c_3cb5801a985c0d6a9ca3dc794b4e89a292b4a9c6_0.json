{"sha": "3cb5801a985c0d6a9ca3dc794b4e89a292b4a9c6", "log": "Replaced CharBuffer with StringBuilder (CSV-59)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     /** length of the initial token (content-)buffer */\n     private static final int INITIAL_TOKEN_LENGTH = 50;\n     \n-    private final CharBuffer wsBuf = new CharBuffer();\n+    private final StringBuilder wsBuf = new StringBuilder();\n     \n     private final CSVFormat format;\n     \n         Type type = INVALID;\n         \n         /** The content buffer. */\n-        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n+        StringBuilder content = new StringBuilder(INITIAL_TOKEN_LENGTH);\n         \n         /** Token ready flag: indicates a valid token with content (ready for the parser). */\n         boolean isReady;\n \n         Token reset() {\n-            content.clear();\n+            content.setLength(0);\n             type = INVALID;\n             isReady = false;\n             return this;\n      * @throws IOException on stream access error\n      */\n     Token nextToken(Token tkn) throws IOException {\n-        wsBuf.clear(); // reuse\n+        wsBuf.setLength(0); // reuse\n \n         // get the last read char (required for empty line detection)\n         int lastChar = in.readAgain();\n         /* note: unfortunately isEndOfLine may consumes a character silently.\n         *       this has no effect outside of the method. so a simple workaround\n         *       is to call 'readAgain' on the stream...\n-        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)\n         */\n         int c = in.read();\n         boolean eol = isEndOfLine(c);\n         }\n \n         if (format.isTrailingSpacesIgnored()) {\n-            tkn.content.trimTrailingWhitespace();\n+            trimTrailingSpaces(tkn.content);\n         }\n \n         return tkn;\n     }\n \n+    private void trimTrailingSpaces(StringBuilder buffer) {\n+        while (buffer.length() > 0 && Character.isWhitespace(buffer.charAt(buffer.length() - 1))) {\n+            buffer.setLength(buffer.length() - 1);\n+        }\n+    }\n \n     /**\n      * An encapsulated token lexer", "timestamp": 1331746948, "metainfo": ""}