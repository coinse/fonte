{"sha": "93a07b9b8f9e4fa82e6f306d57d71d5268d7dacf", "log": "Better param name.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n                 // reached end of file without any content (empty line at the end)\n                 if (isEndOfFile(c)) {\n                     token.type = EOF;\n-                    // don't set tkn.isReady here because no content\n+                    // don't set token.isReady here because no content\n                     return token;\n                 }\n             }\n         // did we reach eof during the last iteration already ? EOF\n         if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {\n             token.type = EOF;\n-            // don't set tkn.isReady here because no content\n+            // don't set token.isReady here because no content\n             return token;\n         }\n \n                 token.type = TOKEN;\n             } else if (eol) {\n                 // empty token return EORECORD(\"\")\n-                // noop: tkn.content.append(\"\");\n+                // noop: token.content.append(\"\");\n                 token.type = EORECORD;\n             } else if (isQuoteChar(c)) {\n                 // consume encapsulated token\n                 parseEncapsulatedToken(token);\n             } else if (isEndOfFile(c)) {\n                 // end of file return EOF()\n-                // noop: tkn.content.append(\"\");\n+                // noop: token.content.append(\"\");\n                 token.type = EOF;\n                 token.isReady = true; // there is data at EOF\n             } else {\n      * <li>an unescaped delimiter has been reached (TOKEN)</li>\n      * </ul>\n      *\n-     * @param tkn\n+     * @param token\n      *            the current token\n      * @param c\n      *            the current character\n      * @throws IOException\n      *             on stream access error\n      */\n-    private Token parseSimpleToken(final Token tkn, int c) throws IOException {\n-        // Faster to use while(true)+break than while(tkn.type == INVALID)\n+    private Token parseSimpleToken(final Token token, int c) throws IOException {\n+        // Faster to use while(true)+break than while(token.type == INVALID)\n         while (true) {\n             if (readEndOfLine(c)) {\n-                tkn.type = EORECORD;\n+                token.type = EORECORD;\n                 break;\n             } else if (isEndOfFile(c)) {\n-                tkn.type = EOF;\n-                tkn.isReady = true; // There is data at EOF\n+                token.type = EOF;\n+                token.isReady = true; // There is data at EOF\n                 break;\n             } else if (isDelimiter(c)) {\n-                tkn.type = TOKEN;\n+                token.type = TOKEN;\n                 break;\n             } else if (isEscape(c)) {\n                 final int unescaped = readEscape();\n                 if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n-                    tkn.content.append((char) c).append((char) in.getLastChar());\n+                    token.content.append((char) c).append((char) in.getLastChar());\n                 } else {\n-                    tkn.content.append((char) unescaped);\n+                    token.content.append((char) unescaped);\n                 }\n                 c = in.read(); // continue\n             } else {\n-                tkn.content.append((char) c);\n+                token.content.append((char) c);\n                 c = in.read(); // continue\n             }\n         }\n \n         if (ignoreSurroundingSpaces) {\n-            trimTrailingSpaces(tkn.content);\n-        }\n-\n-        return tkn;\n+            trimTrailingSpaces(token.content);\n+        }\n+\n+        return token;\n     }\n \n     /**\n      * </ul>\n      * <li>end of stream has been reached (EOF)</li> </ul>\n      *\n-     * @param tkn\n+     * @param token\n      *            the current token\n      * @return a valid token object\n      * @throws IOException\n      *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n      */\n-    private Token parseEncapsulatedToken(final Token tkn) throws IOException {\n+    private Token parseEncapsulatedToken(final Token token) throws IOException {\n         // save current line number in case needed for IOE\n         final long startLineNumber = getCurrentLineNumber();\n         int c;\n             if (isEscape(c)) {\n                 final int unescaped = readEscape();\n                 if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n-                    tkn.content.append((char) c).append((char) in.getLastChar());\n+                    token.content.append((char) c).append((char) in.getLastChar());\n                 } else {\n-                    tkn.content.append((char) unescaped);\n+                    token.content.append((char) unescaped);\n                 }\n             } else if (isQuoteChar(c)) {\n                 if (isQuoteChar(in.lookAhead())) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n                     c = in.read();\n-                    tkn.content.append((char) c);\n+                    token.content.append((char) c);\n                 } else {\n                     // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                     while (true) {\n                         c = in.read();\n                         if (isDelimiter(c)) {\n-                            tkn.type = TOKEN;\n-                            return tkn;\n+                            token.type = TOKEN;\n+                            return token;\n                         } else if (isEndOfFile(c)) {\n-                            tkn.type = EOF;\n-                            tkn.isReady = true; // There is data at EOF\n-                            return tkn;\n+                            token.type = EOF;\n+                            token.isReady = true; // There is data at EOF\n+                            return token;\n                         } else if (readEndOfLine(c)) {\n-                            tkn.type = EORECORD;\n-                            return tkn;\n+                            token.type = EORECORD;\n+                            return token;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n                             throw new IOException(\"(line \" + getCurrentLineNumber() +\n                         \") EOF reached before encapsulated token finished\");\n             } else {\n                 // consume character\n-                tkn.content.append((char) c);\n+                token.content.append((char) c);\n             }\n         }\n     }", "timestamp": 1371779186, "metainfo": ""}