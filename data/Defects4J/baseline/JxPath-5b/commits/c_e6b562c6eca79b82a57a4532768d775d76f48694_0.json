{"sha": "e6b562c6eca79b82a57a4532768d775d76f48694", "log": "A complete re-write to address multiple additional use cases   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.*;\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n- * An simple XPath evaluation mechanism, which works only for some xpaths\n- * but is much faster than the usual process. It is only used for\n+ * An evaluation mechanism for simple XPaths, which\n+ * is much faster than the usual process. It is only used for\n  * xpaths which have no context-dependent parts, consist entirely of\n- * child:: steps with predicates that either integer or have the form\n- * <code>[@name = ...]</code>.\n+ * <code>child::name</code> and <code>self::node()</code> steps with\n+ * predicates that either integer or have the form <code>[@name = ...]</code>.\n  *\n  * @author Dmitri Plotnikov\n  * @version $Revision: 1.10 $ $Date: 2002/04/24 04:05:40 $\n  */\n public class SimplePathInterpreter {\n \n-    /**\n-     * Walks a location path in a highly simplified fashion: from pointer to\n-     * pointer, no contexts.  This is only possible if the path consists of\n-     * simple steps like \"/foo[3]\" and is context-independent.\n-     */\n-    public static NodePointer interpretPath(EvalContext context, NodePointer parentPointer, Step steps[]){\n-        if (parentPointer == null){\n+    // Because of the complexity caused by the variety of situations\n+    // that need to be addressed by this class, we attempt to break up\n+    // the class into individual methods addressing those situations\n+    // individually.  The names of the methods are supposed to\n+    // give brief descriptions of those situations.\n+\n+    private static final QName QNAME_NAME = new QName(null, \"name\");\n+    private static final int PERFECT_MATCH = 1000;\n+\n+    // Uncomment this variable and the PATH = ... lines in\n+    // the two following methods in order to be able to print the\n+    // currently evaluated path for debugging of this class\n+//    private static String PATH;       // Debugging\n+\n+    /**\n+     * Interpret a simple path that starts with the given root and\n+     * follows the given steps. All steps must have the axis \"child::\"\n+     * and a name test.  They can also optionally have predicates\n+     * of type [@name=expression] or simply [expression] interpreted\n+     * as an index.\n+     */\n+    public static NodePointer interpretSimpleLocationPath(\n+            EvalContext context, NodePointer root, Step steps[])\n+    {\n+//        PATH = createNullPointer(context, root, steps, 0).toString();  // Dbg\n+        NodePointer pointer = doStep(context, root, steps, 0);\n+        return valuePointer(pointer);\n+    }\n+\n+    /**\n+     * Interpret the steps of a simple expression path that\n+     * starts with the given root, which is the result of evaluation\n+     * of the root expression of the expression path, applies the\n+     * given predicates to it and then follows the given steps.\n+     * All steps must have the axis \"child::\"\n+     * and a name test.  They can also optionally have predicates\n+     * of type [@name=...] or simply [...] interpreted as an index.\n+     */\n+    public static NodePointer interpretSimpleExpressionPath(\n+                EvalContext context, NodePointer root,\n+                Expression predicates[], Step[] steps)\n+    {\n+//        PATH = createNullPointerForPredicates(context, root,\n+//                    steps, -1, predicates, 0).toString();  // Debugging\n+        return doPredicate(context, root, steps, -1, predicates, 0);\n+    }\n+\n+    /**\n+     * Recursive evaluation of a path. The general plan is:\n+     * Look at the current step,\n+     * find nodes that match it,\n+     * iterate over those nodes and\n+     * for each of them call doStep again for subsequent steps.\n+     */\n+    private static NodePointer doStep(\n+            EvalContext context, NodePointer parent,\n+            Step steps[], int current_step)\n+    {\n+        parent = valuePointer(parent);\n+\n+        if (parent == null){\n             return null;\n         }\n \n-        NodePointer pointer = (NodePointer)parentPointer;\n-        while (pointer != null && !pointer.isNode()){\n-            pointer = pointer.getValuePointer();\n-        }\n-\n-        for (int i = 0; i < steps.length; i++){\n-            Step step = steps[i];\n-            int defaultIndex = (i == steps.length - 1 ? -1 : 0);\n+        if (current_step == steps.length){\n+            // We have reached the end of the list of steps\n+            return parent;\n+        }\n+\n+        Step step = steps[current_step];\n+        Expression predicates[] = step.getPredicates();\n+\n+        // Divide and conquer: the process is broken out into\n+        // four major use cases.\n+        // 1. Current step has no predicates and\n+        //    the root is a property owner (e.g. bean or map)\n+        // 2. Current step has predicates and\n+        //    the root is a property owner (e.g. bean or map)\n+        // 3. Current step has no predicates and\n+        //    the root is an InfoSet standard node (e.g. DOM Node)\n+        // 4. Current step has predicates and\n+        //    the root is an InfoSet standard node (e.g. DOM Node)\n+\n+        if (parent instanceof PropertyOwnerPointer){\n+            if (predicates == null || predicates.length == 0){\n+                return doStep_noPredicates_propertyOwner(\n+                    context, (PropertyOwnerPointer)parent, steps, current_step);\n+            }\n+            else {\n+                return doStep_predicates_propertyOwner(\n+                    context, (PropertyOwnerPointer)parent, steps, current_step);\n+            }\n+        }\n+        else {\n+            if (predicates == null || predicates.length == 0){\n+                 return doStep_noPredicates_standard(\n+                    context, parent, steps, current_step);\n+            }\n+            else {\n+                return doStep_predicates_standard(\n+                    context, parent, steps, current_step);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * We have a step that starts with a property owner (bean, map, etc) and has\n+     * no predicates.  The name test of the step may map to a scalar property\n+     * or to a collection.  If it is a collection, we should apply the tail of\n+     * the path to each element until we find a match. If we don't find\n+     * a perfect match, we should return the \"best quality\" pointer, which\n+     * has the longest chain of steps mapping to existing nodes and the shortes\n+     * tail of Null* pointers.\n+     */\n+    private static NodePointer doStep_noPredicates_propertyOwner(\n+                EvalContext context, PropertyOwnerPointer parentPointer,\n+                Step[] steps, int current_step)\n+    {\n+        Step step = steps[current_step];\n+        NodePointer childPointer;\n+        if (step.getAxis() == Compiler.AXIS_CHILD){\n+            // Treat the name test as a property name\n             QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n-            Expression predicates[] = step.getPredicates();\n-\n-            // The following complicated logic is designed to translate\n-            // an xpath like \"foo[@name='x'][@name='y'][3]/bar/baz[4]\" into\n-            // a sequence of \"single steps\", each of which takes a node pointer,\n-            // a name and an optional index and gets you another node pointer.\n-\n-            // Note: if the last step is not indexed, the default index used\n-            // for that very last step is \"-1\", that is \"do not index at all\",\n-            // not \"0\" as in all preceeding steps.\n-\n-            int count = (predicates == null ? 0 : predicates.length);\n-            if (count == 0){\n-                pointer = singleStep(context, pointer, name, defaultIndex, false);\n-            }\n-            else {\n-                Expression lastIndexPredicate = null;\n-                if (!(predicates[count - 1] instanceof NameAttributeTest)){\n-                    lastIndexPredicate = predicates[count - 1];\n-                }\n-\n-                if (lastIndexPredicate != null){\n-                    int index = indexFromPredicate(context, lastIndexPredicate);\n-                    if (count == 1){\n-                        pointer = singleStep(context, pointer, name, index, false);\n-                    }\n-                    else {\n-                        pointer = singleStep(context, pointer, name, -1, false);\n-                        for (int j = 0; j < count - 1; j++){\n-                            String key = keyFromPredicate(context, predicates[j]);\n-                            if (j < count - 2){\n-                                pointer = singleStep(context, pointer, key, -1, true);\n-                            }\n-                            else {\n-                                pointer = singleStep(context, pointer, key, index, true);\n-                            }\n+\n+            childPointer = parentPointer.getPropertyPointer();\n+            ((PropertyPointer)childPointer).setPropertyName(name.toString());\n+        }\n+        else {\n+            childPointer = parentPointer;\n+        }\n+\n+        if (!childPointer.isActual()){\n+            // The property does not exist - create a null pointer.\n+            return createNullPointer(\n+                            context, parentPointer, steps, current_step);\n+        }\n+        else if (current_step == steps.length - 1){\n+            // If this is the last step - we are done, we found it\n+            return childPointer;\n+        }\n+        else if (childPointer.isCollection()){\n+            // Iterate over all values and\n+            // execute remaining steps for each node,\n+            // looking for the best quality match\n+            int bestQuality = 0;\n+            NodePointer bestMatch = null;\n+            int count = childPointer.getLength();\n+            for (int i = 0; i < count; i++){\n+                childPointer.setIndex(i);\n+                NodePointer pointer = doStep(\n+                        context, childPointer, steps, current_step + 1);\n+                int quality = computeQuality(pointer);\n+                if (quality == PERFECT_MATCH){\n+                    return pointer;\n+                }\n+                else if (quality > bestQuality){\n+                    bestQuality = quality;\n+                    bestMatch = (NodePointer)pointer.clone();\n+                }\n+            }\n+            if (bestMatch != null){\n+                return bestMatch;\n+            }\n+            // This step did not find anything - return a null pointer\n+            return createNullPointer(\n+                        context, childPointer, steps, current_step);\n+        }\n+        else {\n+            // Evaluate subsequent steps\n+            return doStep(\n+                       context, childPointer, steps, current_step + 1);\n+        }\n+    }\n+\n+    /**\n+     * A path that starts with a standard InfoSet node (e.g. DOM Node) and\n+     * has no predicates.  Get a child iterator and apply the tail of\n+     * the path to each element until we find a match. If we don't find\n+     * a perfect match, we should return the \"best quality\" pointer, which\n+     * has the longest chain of steps mapping to existing nodes and the shortes\n+     * tail of Null* pointers.\n+     */\n+    private static NodePointer doStep_noPredicates_standard(\n+                EvalContext context, NodePointer parentPointer,\n+                Step[] steps, int current_step)\n+    {\n+        Step step = steps[current_step];\n+        int bestQuality = 0;\n+        NodePointer bestMatch = null;\n+        NodeIterator it =\n+                parentPointer.childIterator(step.getNodeTest(), false, null);\n+        if (it != null){\n+            for (int i = 1; it.setPosition(i); i++){\n+                NodePointer childPointer = it.getNodePointer();\n+                if (steps.length == current_step + 1){\n+                    // If this is the last step - we are done, we found it\n+                    return childPointer;\n+                }\n+                NodePointer pointer = doStep(\n+                        context, childPointer, steps, current_step + 1);\n+                int quality = computeQuality(pointer);\n+                if (quality == PERFECT_MATCH){\n+                    return pointer;\n+                }\n+                else if (quality > bestQuality){\n+                    bestQuality = quality;\n+                    bestMatch = (NodePointer)pointer.clone();\n+                }\n+            }\n+        }\n+\n+        if (bestMatch != null){\n+            return bestMatch;\n+        }\n+\n+        return createNullPointer(\n+                context, parentPointer, steps, current_step);\n+    }\n+\n+    /**\n+     * A path that starts with a property owner. The method evaluates\n+     * the first predicate in a special way and then forwards to\n+     * a general predicate processing method.\n+     */\n+    private static NodePointer doStep_predicates_propertyOwner(\n+            EvalContext context, PropertyOwnerPointer parentPointer,\n+            Step[] steps, int current_step)\n+    {\n+        Step step = steps[current_step];\n+        Expression predicates[] = step.getPredicates();\n+\n+        NodePointer childPointer;\n+        if (step.getAxis() == Compiler.AXIS_CHILD){\n+            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            childPointer = parentPointer.getPropertyPointer();\n+            ((PropertyPointer)childPointer).setPropertyName(name.toString());\n+        }\n+        else {\n+            childPointer = parentPointer;\n+        }\n+        if (!childPointer.isActual()){\n+            // Property does not exist - return a null pointer\n+            return createNullPointer(\n+                        context, parentPointer, steps, current_step);\n+        }\n+\n+        // Evaluate predicates\n+        return doPredicate(\n+            context, childPointer, steps, current_step, predicates, 0);\n+    }\n+\n+    /**\n+     * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n+     * The method evaluates the first predicate in a special way and\n+     * then forwards to a general predicate processing method.\n+     */\n+    private static NodePointer doStep_predicates_standard(\n+            EvalContext context, NodePointer parent,\n+            Step[] steps, int current_step)\n+    {\n+        Step step = steps[current_step];\n+        Expression predicates[] = step.getPredicates();\n+\n+        if (step.getAxis() == Compiler.AXIS_SELF){\n+            return doPredicate(context, parent,\n+                steps, current_step, predicates, 0);\n+        }\n+\n+        Expression predicate = predicates[0];\n+\n+        // Optimize for a single predicate to avoid building a list\n+        // and to allow the direct access to the index'th element\n+        // in the case of a simple subscript predecate\n+        // It is a very common use case, so it deserves individual\n+        // attention\n+        if (predicates.length == 1){\n+            NodeIterator it = parent.childIterator(\n+                    step.getNodeTest(), false, null);\n+            NodePointer pointer = null;\n+            if (it != null){\n+                if (predicate instanceof NameAttributeTest){ // [@name = key]\n+                    String key = keyFromPredicate(context, predicate);\n+                    for (int i = 1; it.setPosition(i); i++){\n+                        NodePointer ptr = it.getNodePointer();\n+                        if (isNameAttributeEqual(ptr, key)){\n+                            pointer = ptr;\n+                            break;\n                         }\n                     }\n                 }\n                 else {\n-                    pointer = singleStep(context, pointer, name, -1, false);\n-                    for (int j = 0; j < count; j++){\n-                        String key = keyFromPredicate(context, predicates[j]);\n-                        if (j < count - 1){\n-                            pointer = singleStep(context, pointer, key, -1, true);\n-                        }\n-                        else {\n-                            pointer = singleStep(context, pointer, key, defaultIndex, true);\n-                        }\n+                    int index = indexFromPredicate(context, predicate);\n+                    if (it.setPosition(index + 1)){\n+                        pointer = it.getNodePointer();\n                     }\n                 }\n             }\n-        }\n-        return pointer;\n-    }\n-\n-    /**\n-     * Interprets predicates for the root expression of an Expression Path without creating\n-     * any intermediate contexts.  This is an option used for optimization when the path\n-     * has a simple structure and predicates are context-independent.\n-     */\n-    public static NodePointer interpretPredicates(EvalContext context, NodePointer pointer, Expression predicates[]){\n-        if (predicates == null || predicates.length == 0 || pointer == null){\n-            return pointer;\n-        }\n-\n-        // The following complicated logic is designed to translate\n-        // an xpath like \"$foo[@name='x'][@name='y'][3]\" into\n-        // a sequence of \"single steps\", each of which takes a node pointer,\n-        // a name and an optional index and gets you another node pointer.\n-\n-        int count = predicates.length;\n-        Expression lastIndexPredicate = null;\n-        if (!(predicates[count - 1] instanceof NameAttributeTest)){\n-            lastIndexPredicate = predicates[count - 1];\n-        }\n-\n-        if (lastIndexPredicate != null){\n-            int index = indexFromPredicate(context, lastIndexPredicate);\n-            if (count == 1){\n-                if (index >= 0 && index < pointer.getLength()){\n-                    pointer.setIndex(index);\n+            if (pointer != null){\n+                return doStep(context, pointer, steps, current_step + 1);\n+            }\n+        }\n+        else {\n+            NodeIterator it = parent.childIterator(\n+                    step.getNodeTest(), false, null);\n+            if (it != null){\n+                List list = new ArrayList();\n+                for (int i = 1; it.setPosition(i); i++){\n+                    list.add(it.getNodePointer());\n+                }\n+                NodePointer pointer = doPredicates_standard(context, list,\n+                    steps, current_step, predicates, 0);\n+                if (pointer != null){\n+                    return pointer;\n+                }\n+            }\n+        }\n+        return createNullPointer(\n+                    context, parent, steps, current_step);\n+    }\n+\n+    /**\n+     * Evaluates predicates and proceeds with the subsequent steps\n+     * of the path.\n+     */\n+    private static NodePointer doPredicate(\n+                EvalContext context, NodePointer parent,\n+                Step[] steps, int current_step,\n+                Expression predicates[], int current_predicate)\n+    {\n+        if (current_predicate == predicates.length){\n+            return doStep(context, parent, steps, current_step + 1);\n+        }\n+\n+        Expression predicate = predicates[current_predicate];\n+        if (predicate instanceof NameAttributeTest){ // [@name = key1]\n+            return doPredicate_name(context, parent,\n+                    steps, current_step, predicates, current_predicate);\n+        }\n+        else {      // [index]\n+            return doPredicate_index(context, parent,\n+                    steps, current_step, predicates, current_predicate);\n+        }\n+    }\n+\n+    private static NodePointer doPredicate_name(\n+            EvalContext context, NodePointer parent,\n+            Step[] steps, int current_step,\n+            Expression[] predicates, int current_predicate)\n+    {\n+        Expression predicate = predicates[current_predicate];\n+        String key = keyFromPredicate(context, predicate);\n+        NodePointer child = valuePointer(parent);\n+        if (child instanceof PropertyOwnerPointer){\n+            PropertyPointer pointer =\n+               ((PropertyOwnerPointer)child).getPropertyPointer();\n+            pointer.setPropertyName(key);\n+            if (pointer.isActual()){\n+                return doPredicate(\n+                        context, pointer, steps, current_step,\n+                        predicates, current_predicate + 1);\n+            }\n+        }\n+        else if (child.isCollection()){\n+            // For each node in the collection, perform the following:\n+            // if the node is a property owner, apply this predicate to it;\n+            // if the node is a collection, apply this predicate to each elem.;\n+            // if the node is not a prop owner or a collection,\n+            //  see if it has the attribute \"name\" with the right value,\n+            //  if so - proceed to the next predicate\n+            NodePointer bestMatch = null;\n+            int bestQuality = 0;\n+            int count = child.getLength();\n+            for (int i = 0; i < count; i++){\n+                child.setIndex(i);\n+                NodePointer valuePointer = valuePointer(child);\n+                if (valuePointer == child){\n+                    valuePointer = (NodePointer)child.clone();\n+                }\n+                NodePointer pointer;\n+                if ((valuePointer instanceof PropertyOwnerPointer) ||\n+                        valuePointer.isCollection()){\n+                    pointer = doPredicate_name(\n+                            context, valuePointer, steps, current_step,\n+                            predicates, current_predicate);\n+                }\n+                else if (isNameAttributeEqual(valuePointer, key)){\n+                    pointer = doPredicate(\n+                            context, valuePointer, steps, current_step,\n+                            predicates, current_predicate + 1);\n                 }\n                 else {\n-                    pointer = new NullElementPointer(pointer, index);\n-                }\n-            }\n-            else {\n-                for (int j = 0; j < count - 1; j++){\n-                    String key = keyFromPredicate(context, predicates[j]);\n-                    if (j < count - 2){\n-                        pointer = singleStep(context, pointer, key, -1, true);\n+                    pointer = null;\n+                }\n+                if (pointer != null){\n+                    int quality = computeQuality(pointer);\n+                    if (quality == PERFECT_MATCH){\n+                        return pointer;\n                     }\n-                    else {\n-                        pointer = singleStep(context, pointer, key, index, true);\n+                    if (quality > bestQuality){\n+                        bestMatch = (NodePointer)pointer.clone();\n+                        bestQuality = quality;\n                     }\n                 }\n             }\n+            if (bestMatch != null){\n+                return bestMatch;\n+            }\n         }\n         else {\n-            for (int j = 0; j < count; j++){\n-                String key = keyFromPredicate(context, predicates[j]);\n-                if (j < count - 1){\n-                    pointer = singleStep(context, pointer, key, -1, true);\n-                }\n-                else {\n-                    pointer = singleStep(context, pointer, key, -1, true);\n-                }\n-            }\n-        }\n-        return pointer;\n-    }\n-\n-    /**\n-     * @param property can be either a name or a QName\n-     */\n-    private static NodePointer singleStep(EvalContext context, NodePointer parent, Object property, int index, boolean dynamic){\n-        if (parent instanceof PropertyOwnerPointer){\n-            PropertyPointer pointer = ((PropertyOwnerPointer)parent).getPropertyPointer();\n-            String name;\n-            if (property instanceof QName){\n-                name = ((QName)property).getName();\n-            }\n-            else {\n-                name = (String)property;\n-            }\n-            pointer.setPropertyName(name);\n-            if (pointer instanceof NullPropertyPointer && dynamic){\n-                ((NullPropertyPointer)pointer).setDynamic(true);\n-            }\n-            if (index != -1){\n-                if (index >= 0 && index < pointer.getLength()){\n-                    pointer.setIndex(index);\n-                    return pointer.getValuePointer();\n-                }\n-                else {\n-                    return new NullElementPointer(pointer, index).getValuePointer();\n-                }\n-            }\n-            else {\n-                return pointer.getValuePointer();\n-            }\n+            // If the node is a standard InfoSet node (e.g. DOM Node),\n+            // employ doPredicates_standard, which will iterate through\n+            // the node's children and apply all predicates\n+            NodePointer found = doPredicates_standard(context,\n+                    Collections.singletonList(child), steps,\n+                    current_step, predicates, current_predicate);\n+            if (found != null){\n+                return found;\n+            }\n+        }\n+        // If nothing worked - return a null pointer\n+        return createNullPointerForPredicates(\n+                context, child, steps, current_step,\n+                predicates, current_predicate);\n+    }\n+\n+    /**\n+     * Called exclusively for standard InfoSet nodes, e.g. DOM nodes\n+     * to evaluate predicate sequences like [@name=...][@name=...][index].\n+     */\n+    private static NodePointer doPredicates_standard(\n+                EvalContext context, List parents,\n+                Step[] steps, int current_step,\n+                Expression predicates[], int current_predicate)\n+    {\n+        if (parents.size() == 0){\n+            return null;\n+        }\n+\n+        // If all predicates have been processed, take the first\n+        // element from the list of results and proceed to the\n+        // remaining steps with that element.\n+        if (current_predicate == predicates.length){\n+            NodePointer pointer = (NodePointer)parents.get(0);\n+            return doStep(context, pointer, steps, current_step + 1);\n+        }\n+\n+        Expression predicate = predicates[current_predicate];\n+        if (predicate instanceof NameAttributeTest){\n+            String key = keyFromPredicate(context, predicate);\n+            List newList = new ArrayList();\n+            for (int i = 0; i < parents.size(); i++){\n+                NodePointer pointer = (NodePointer)parents.get(i);\n+                if (isNameAttributeEqual(pointer, key)){\n+                    newList.add(pointer);\n+                }\n+            }\n+            if (newList.size() == 0){\n+                return null;\n+            }\n+            return doPredicates_standard(context, newList,\n+                    steps, current_step,\n+                    predicates, current_predicate + 1);\n         }\n         else {\n-            QName name;\n-            if (property instanceof QName){\n-                name = (QName)property;\n-            }\n-            else {\n-                name = new QName(null, (String)property);\n-            }\n-            NodeIterator it = parent.childIterator(new NodeNameTest(name), false, null);\n-            if (it != null && it.setPosition(index == -1 ? 1 : index + 1)){\n-                return it.getNodePointer();\n-            }\n-            else {\n-                PropertyPointer pointer = new NullPropertyPointer(parent);\n-                pointer.setPropertyName(name.toString());\n-                pointer.setIndex(index);\n-                return pointer.getValuePointer();\n-            }\n-        }\n-    }\n-\n-    private static int indexFromPredicate(EvalContext context, Expression predicate){\n+            // For a subscript, simply take the corresponding\n+            // element from the list of results and\n+            // proceed to the remaining predicates with that element\n+            int index = indexFromPredicate(context, predicate);\n+            if (index < 0 || index >= parents.size()){\n+                return null;\n+            }\n+            NodePointer ptr = (NodePointer)parents.get(index);\n+            return doPredicate(context, ptr, steps, current_step,\n+                predicates, current_predicate + 1);\n+        }\n+    }\n+\n+    /**\n+     * Evaluate a subscript predicate: see if the node is a collection and\n+     * if the index is inside the collection\n+     */\n+    private static NodePointer doPredicate_index(\n+            EvalContext context, NodePointer parent,\n+            Step[] steps, int current_step,\n+            Expression[] predicates, int current_predicate)\n+    {\n+        Expression predicate = predicates[current_predicate];\n+        int index = indexFromPredicate(context, predicate);\n+        NodePointer pointer = parent;\n+        if (isCollectionElement(pointer, index)){\n+            pointer.setIndex(index);\n+            return doPredicate(context, valuePointer(pointer),\n+                    steps, current_step, predicates, current_predicate + 1);\n+        }\n+        return createNullPointerForPredicates(context, parent,\n+                steps, current_step, predicates, current_predicate);\n+    }\n+\n+    /**\n+     * Extract an integer from a subscript predicate. The returned index\n+     * starts with 0, even though the subscript starts with 1.\n+     */\n+    private static int indexFromPredicate(\n+            EvalContext context, Expression predicate)\n+    {\n         Object value = predicate.computeValue(context);\n         if (value instanceof EvalContext){\n             value = ((EvalContext)value).getSingleNodePointer();\n             value = ((NodePointer)value).getValue();\n         }\n         if (value == null){\n-            throw new JXPathException(\"Predicate is null: \" + value);\n+            throw new JXPathException(\"Predicate value is null\");\n         }\n \n         if (value instanceof Number){\n         return -1;\n     }\n \n+    /**\n+     * Extracts the string value of the expression from a predicate like\n+     * [@name=expression].\n+     */\n     private static String keyFromPredicate(EvalContext context,\n                 Expression predicate){\n         Expression expr = ((NameAttributeTest)predicate).\n                                     getNameTestExpression();\n         return InfoSetUtil.stringValue(expr.computeValue(context));\n     }\n+\n+    /**\n+     * For a pointer that matches an actual node, returns 0.\n+     * For a pointer that does not match an actual node, but whose\n+     * parent pointer does returns -1, etc.\n+     */\n+    private static int computeQuality(NodePointer pointer){\n+        int quality = PERFECT_MATCH;\n+        while (pointer != null && !pointer.isActual()){\n+            quality--;\n+            pointer = pointer.getParent();\n+        }\n+        return quality;\n+    }\n+\n+    /**\n+     * Returns true if the pointer has an attribute called \"name\" and\n+     * its value is equal to the supplied string.\n+     */\n+    private static boolean isNameAttributeEqual(\n+            NodePointer pointer, String name)\n+    {\n+        NodeIterator it = pointer.attributeIterator(QNAME_NAME);\n+        return it != null && it.setPosition(1) &&\n+                name.equals(it.getNodePointer().getValue());\n+    }\n+\n+    /**\n+     * Returns true if the pointer is a collection and the index is\n+     * withing the bounds of the collection.\n+     */\n+    private static boolean isCollectionElement(NodePointer pointer, int index){\n+        return pointer.isActual() && (index == 0 ||\n+            (pointer.isCollection() &&\n+                    index >= 0 && index < pointer.getLength()));\n+    }\n+\n+    /**\n+     * For an intermediate pointer (e.g. PropertyPointer, ContainerPointer)\n+     * returns a pointer for the contained value.\n+     */\n+    private static NodePointer valuePointer(NodePointer pointer){\n+        while (pointer != null && !pointer.isNode()){\n+            pointer = pointer.getValuePointer();\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * Creates a \"null pointer\" that\n+     * a) represents the requested path and\n+     * b) can be used for creation of missing nodes in the path.\n+     */\n+    private static NodePointer createNullPointer(\n+            EvalContext context, NodePointer parent, Step[] steps,\n+            int current_step)\n+    {\n+        parent = valuePointer(parent);\n+\n+        if (current_step == steps.length){\n+            return parent;\n+        }\n+\n+        Step step = steps[current_step];\n+\n+        if (step.getAxis() == Compiler.AXIS_CHILD){\n+            NullPropertyPointer pointer = new NullPropertyPointer(parent);\n+            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            pointer.setPropertyName(name.toString());\n+            parent = pointer;\n+        }\n+        // else { it is self::node() }\n+\n+        Expression predicates[] = step.getPredicates();\n+        return createNullPointerForPredicates(context, parent,\n+                steps, current_step, predicates, 0);\n+    }\n+\n+    /**\n+     * Creates a \"null pointer\" that starts with predicates.\n+     */\n+    private static NodePointer createNullPointerForPredicates(\n+            EvalContext context, NodePointer parent,\n+            Step[] steps, int current_step,\n+            Expression predicates[], int current_predicate)\n+    {\n+        for (int i = current_predicate; i < predicates.length; i++){\n+            Expression predicate = predicates[i];\n+            if (predicate instanceof NameAttributeTest){\n+                String key = keyFromPredicate(context, predicate);\n+                parent = valuePointer(parent);\n+                NullPropertyPointer pointer = new NullPropertyPointer(parent);\n+                pointer.setNameAttributeValue(key);\n+                parent = pointer;\n+            }\n+            else {\n+                int index = indexFromPredicate(context, predicate);\n+                if (parent instanceof NullPropertyPointer){\n+                    parent.setIndex(index);\n+                }\n+                else {\n+                    parent = new NullElementPointer(parent, index);\n+                }\n+            }\n+        }\n+        // Proceed with the remaining steps\n+        return createNullPointer(\n+                    context, parent, steps, current_step + 1);\n+    }\n }", "timestamp": 1028943347, "metainfo": ""}