{"sha": "430fdd01e75a5e681274aa65adeb2d9826ee45a8", "log": "Organized imports, formatted code Fixed problems with getValue() and getNode()   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.6 2002/08/10 01:28:49 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/08/10 01:28:49 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n import java.net.URL;\n \n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Source;\n import javax.xml.transform.Transformer;\n-import javax.xml.transform.TransformerConfigurationException;\n-import javax.xml.transform.TransformerException;\n import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.TransformerFactoryConfigurationError;\n import javax.xml.transform.dom.DOMResult;\n-import javax.xml.transform.stream.StreamSource;\n \n import org.apache.commons.jxpath.xml.DocumentContainer;\n import org.w3c.dom.Document;\n-import org.xml.sax.SAXException;\n-\n-import org.apache.commons.jxpath.xml.DocumentContainer;\n \n /**\n  * An XML document container reads and parses XML only when it is\n  * @deprecated 1.1 Please use org.apache.commons.jxpath.xml.DocumentContainer\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/08/10 01:28:49 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class XMLDocumentContainer implements Container {\n \n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.18 2002/10/20 03:43:39 dmitri Exp $\n- * $Revision: 1.18 $\n- * $Date: 2002/10/20 03:43:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.19 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.19 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.*;\n \n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ExpressionContext;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.ri.axes.RootContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * An XPath evaluation context.\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.18 $ $Date: 2002/10/20 03:43:39 $\n+ * @version $Revision: 1.19 $ $Date: 2002/11/26 01:20:06 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java,v 1.2 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri;\n \n+import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathContextFactory;\n import org.apache.commons.jxpath.JXPathContextFactoryConfigurationError;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.Variables;\n \n /**\n  * Default implementation of JXPathContextFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class JXPathContextFactoryReferenceImpl extends JXPathContextFactory {\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.9 2002/10/20 03:43:39 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:43:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n-import java.util.HashSet;\n-\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:43:39 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class AncestorContext extends EvalContext {\n     private NodeTest nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.8 2002/10/20 03:43:38 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/10/20 03:43:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.9 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n-import java.util.HashSet;\n-\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.NodeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n  * EvalContext that walks the \"parent::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/10/20 03:43:38 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class ParentContext extends EvalContext {\n     private NodeTest nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.8 2002/05/29 00:41:32 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/05/29 00:41:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.9 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/05/29 00:41:32 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n     private Stack nameStack;\n     private NodePointer currentNodePointer;\n     private NodePointer currentRootLocation;\n-    private boolean includeSelf;\n     private boolean reverse;\n \n     public PrecedingOrFollowingContext(EvalContext parentContext, NodeTest nodeTest, boolean reverse){\n         super(parentContext);\n-        this.includeSelf = includeSelf;\n         this.nodeTest = nodeTest;\n         this.reverse = reverse;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.14 2002/10/12 21:02:24 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/10/12 21:02:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.15 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.axes;\n \n import java.util.Iterator;\n+\n import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.compiler.CoreOperation;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import org.apache.commons.jxpath.ri.compiler.NameAttributeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n \n /**\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2002/10/12 21:02:24 $\n+ * @version $Revision: 1.15 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n     }\n \n     public boolean nextNode(){\n-        if (done){\n-            return false;\n-        }\n-        while (parentContext.nextNode()){\n-            if (setupDynamicPropertyPointer()){\n-                Object pred = nameTestExpression.computeValue(parentContext);\n-                if (pred instanceof NodePointer){\n-                    pred = ((NodePointer)pred).getValue();\n-                }\n-                dynamicPropertyPointer.setPropertyName(InfoSetUtil.stringValue(pred));\n-                position = 1;\n-                done = true;\n-                return true;\n-            }\n-            else {\n-                Object pred = expression.computeValue(parentContext);\n-                if (pred instanceof Iterator){\n-                    if (!((Iterator)pred).hasNext()){\n-                        return false;\n-                    }\n-                    pred = ((Iterator)pred).next();\n-                }\n-\n-                if (pred instanceof NodePointer){\n-                    pred = ((NodePointer)pred).getNode();\n-                }\n-\n-                if (pred instanceof Number){\n-                    int pos = (int)InfoSetUtil.doubleValue(pred);\n-                    position++;\n-                    done = true;\n-                    return parentContext.setPosition(pos);\n-                }\n-                else if (InfoSetUtil.booleanValue(pred)){\n-                    position++;\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n+\t\tif (done) {\n+\t\t\treturn false;\n+\t\t}\n+\t\twhile (parentContext.nextNode()) {\n+\t\t\tif (setupDynamicPropertyPointer()) {\n+\t\t\t\tObject pred = nameTestExpression.computeValue(parentContext);\n+\t\t\t\tif (pred instanceof NodePointer) {\n+\t\t\t\t\tpred = ((NodePointer) pred).getValue();\n+\t\t\t\t}\n+\t\t\t\tdynamicPropertyPointer.setPropertyName(\n+\t\t\t\t\tInfoSetUtil.stringValue(pred));\n+\t\t\t\tposition = 1;\n+\t\t\t\tdone = true;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tObject pred = expression.computeValue(parentContext);\n+\t\t\t\tif (pred instanceof Iterator) {\n+\t\t\t\t\tif (!((Iterator) pred).hasNext()) {\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\tpred = ((Iterator) pred).next();\n+\t\t\t\t}\n+\n+\t\t\t\tif (pred instanceof NodePointer) {\n+\t\t\t\t\tpred = ((NodePointer) pred).getNode();\n+\t\t\t\t}\n+\n+\t\t\t\tif (pred instanceof Number) {\n+\t\t\t\t\tint pos = (int) InfoSetUtil.doubleValue(pred);\n+\t\t\t\t\tposition++;\n+\t\t\t\t\tdone = true;\n+\t\t\t\t\treturn parentContext.setPosition(pos);\n+\t\t\t\t}\n+\t\t\t\telse if (InfoSetUtil.booleanValue(pred)) {\n+\t\t\t\t\tposition++;\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n     }\n \n     /**\n     }\n \n     public boolean setPosition(int position){\n-        if (nameTestExpression == null){\n-            return setPositionStandard(position);\n-        }\n-        else {\n-            if (dynamicPropertyPointer == null){\n-                if (!setupDynamicPropertyPointer()){\n-                    return setPositionStandard(position);\n-                }\n-            }\n-            if (position < 1 || position > dynamicPropertyPointer.getLength()){\n-                return false;\n-            }\n-            dynamicPropertyPointer.setIndex(position - 1);\n-            return true;\n-        }\n+\t\tif (nameTestExpression == null) {\n+\t\t\treturn setPositionStandard(position);\n+\t\t}\n+\t\telse {\n+\t\t\tif (dynamicPropertyPointer == null) {\n+\t\t\t\tif (!setupDynamicPropertyPointer()) {\n+\t\t\t\t\treturn setPositionStandard(position);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (position < 1\n+\t\t\t\t|| position > dynamicPropertyPointer.getLength()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tdynamicPropertyPointer.setIndex(position - 1);\n+\t\t\treturn true;\n+\t\t}\n     }\n \n     public NodePointer getCurrentNodePointer(){\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n     {\n //        PATH = createNullPointer(context, root, steps, 0).toString();  // Dbg\n         NodePointer pointer = doStep(context, root, steps, 0);\n-        return valuePointer(pointer);\n+//        return valuePointer(pointer);\n+        return pointer;\n     }\n \n     /**\n     {\n //        PATH = createNullPointerForPredicates(context, root,\n //                    steps, -1, predicates, 0).toString();  // Debugging\n-        return doPredicate(context, root, steps, -1, predicates, 0);\n+        NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0);\n+//        return valuePointer(pointer);\n+        return pointer;\n     }\n \n     /**\n             EvalContext context, NodePointer parent,\n             Step steps[], int current_step)\n     {\n-        parent = valuePointer(parent);\n-\n         if (parent == null){\n             return null;\n         }\n             return parent;\n         }\n \n+        // Open all containers\n+        parent = valuePointer(parent);\n+        \n         Step step = steps[current_step];\n         Expression predicates[] = step.getPredicates();\n \n         NodePointer pointer = parent;\n         if (isCollectionElement(pointer, index)){\n             pointer.setIndex(index);\n-            return doPredicate(context, valuePointer(pointer),\n+            return doPredicate(context, pointer,\n                     steps, current_step, predicates, current_predicate + 1);\n         }\n         return createNullPointerForPredicates(context, parent,\n      * returns a pointer for the contained value.\n      */\n     private static NodePointer valuePointer(NodePointer pointer){\n-        while (pointer != null && !pointer.isNode()){\n-            pointer = pointer.getValuePointer();\n-        }\n-        return pointer;\n+        return pointer == null ? null : pointer.getValuePointer();\n     }\n \n     /**\n             EvalContext context, NodePointer parent, Step[] steps,\n             int current_step)\n     {\n-        parent = valuePointer(parent);\n-\n         if (current_step == steps.length){\n             return parent;\n         }\n+\n+        parent = valuePointer(parent);\n \n         Step step = steps[current_step];\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.7 2002/10/12 20:56:03 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/12 20:56:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import java.util.Collection;\n+\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n-import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n-\n-import java.util.Collection;\n \n /**\n  * An element of the compile tree representing one of built-in functions\n  * like \"position()\" or \"number()\".\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/12 20:56:03 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class CoreFunction extends Operation {\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.6 2002/08/26 22:19:51 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/08/26 22:19:51 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n+import java.util.*;\n+\n import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.InfoSetUtil;\n-import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.axes.InitialContext;\n import org.apache.commons.jxpath.ri.axes.SelfContext;\n import org.apache.commons.jxpath.ri.axes.UnionContext;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Set;\n-import java.util.HashSet;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n  * A compile tree element representing one of the core operations like \"+\",\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/08/26 22:19:51 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class CoreOperation extends Operation {\n     public CoreOperation(int code, Expression args[]){\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n package org.apache.commons.jxpath.ri.compiler;\n \n-import org.apache.commons.jxpath.ri.EvalContext;\n \n /**\n- *\n+ * Captures the <code>foo[@name=<i>expr</i>]</code> expression. These\n+ * expressions are handled in a special way when applied to beans\n+ * or maps.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class NameAttributeTest extends CoreOperation {\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.12 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.13 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n  * context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.13 $ $Date: 2002/11/26 01:20:06 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n \n     public abstract int getLength();\n \n     /**\n-     * By default, returns <code>getNodeValue()</code>, can be overridden to\n+     * By default, returns <code>getNode()</code>, can be overridden to\n      * return a \"canonical\" value, like for instance a DOM element should\n      * return its string value.\n      */\n     public Object getValue() {\n+        NodePointer valuePointer = getValuePointer();\n+        if (valuePointer != this){\n+            return valuePointer.getValue();\n+        }\n+        // Default behavior is to return the same as getNode() \n         return getNode();\n     }\n \n      * this method returns the pointer to the contents.\n      * Only an auxiliary (non-node) pointer can (and should) return a\n      * value pointer other than itself.\n+     * Note that you probably don't want to override <code>getValuePointer()</code>\n+     * directly.  Override the <code>getImmediateValuePointer()</code> \n+     * method instead.  The <code>getValuePointer()</code> method is\n+     * calls <code>getImmediateValuePointer()</code> and, if the result is not\n+     * <code>this</code>, invokes <code>getValuePointer()</code> recursively.\n+     * The idea here is to open all nested containers. Let's say we have a \n+     * container within a container within a container.\n+     * The <code>getValuePointer()</code> method should then open all \n+     * those containers and return the pointer to the ultimate contents.\n+     * It does so with the above recursion.\n      */\n     public NodePointer getValuePointer() {\n+        NodePointer ivp = getImmediateValuePointer();\n+        if (ivp != this){\n+            return ivp.getValuePointer();\n+        }\n         return this;\n     }\n \n+    /**\n+     * @see #getValuePointer()\n+     * \n+     * @return NodePointer is either <code>this</code> or a pointer\n+     *   for the immediately contained value.\n+     */\n+    public NodePointer getImmediateValuePointer() {\n+        return this;\n+    }\n+    \n     /**\n      * An actual pointer points to an existing part of an object graph, even\n      * if it is null. A non-actual pointer represents a part that does not exist\n \n     /**\n      * Returns the object the pointer points to; does not convert it\n+     * to a \"canonical\" type. Opens containers, properties etc and returns\n+     * the ultimate contents.\n+     */\n+    public Object getNode(){\n+        return getValuePointer().getImmediateNode();\n+    }\n+    \n+    /**\n+     * Returns the object the pointer points to; does not convert it\n      * to a \"canonical\" type.\n      */\n-    public abstract Object getNode();\n+    public abstract Object getImmediateNode();\n \n     /**\n      * Converts the value to the required type and changes the corresponding\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.7 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION){\n             return ValueUtils.getValue(value, index);\n         return actual;\n     }\n \n-    public NodePointer getValuePointer(){\n+    public NodePointer getImmediateValuePointer(){\n         if (valuePointer == null){\n             Object value = null;\n             if (actual){\n-                value = getNode();\n+                value = getImmediateNode();\n             }\n             valuePointer = NodePointer.newChildNodePointer(this, null, value);\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.3 2002/10/13 02:59:01 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/13 02:59:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.4 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model.beans;\n \n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n  * well as the \"xml:lang\" attribute.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/10/13 02:59:01 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class BeanAttributeIterator extends PropertyIterator {\n     private NodePointer parent;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.7 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.beans;\n \n-import java.beans.PropertyDescriptor;\n import java.util.Locale;\n \n import org.apache.commons.jxpath.JXPathBeanInfo;\n import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.util.ValueUtils;\n \n /**\n  * A Pointer that points to a JavaBean or a collection. It is either\n  * in the chain.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     private Object bean;\n     private JXPathBeanInfo beanInfo;\n \n-    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo, Locale locale){\n-        super(null, locale);\n-        this.name = name;\n-        this.bean = bean;\n-        this.beanInfo = beanInfo;\n-    }\n+\tpublic BeanPointer(\n+    \t\tQName name,\n+    \t\tObject bean,\n+    \t\tJXPathBeanInfo beanInfo,\n+    \t\tLocale locale) \n+    {\n+\t\tsuper(null, locale);\n+\t\tthis.name = name;\n+\t\tthis.bean = bean;\n+\t\tthis.beanInfo = beanInfo;\n+\t}\n \n     /**\n      * @param name is the name given to the first node\n      */\n-    public BeanPointer(NodePointer parent, QName name, Object bean, JXPathBeanInfo beanInfo){\n-        super(parent);\n-        this.name = name;\n-        this.bean = bean;\n-        this.beanInfo = beanInfo;\n-    }\n+\tpublic BeanPointer(\n+    \t\tNodePointer parent,\n+    \t\tQName name,\n+    \t\tObject bean,\n+    \t\tJXPathBeanInfo beanInfo) \n+    {\n+\t\tsuper(parent);\n+\t\tthis.name = name;\n+\t\tthis.bean = bean;\n+\t\tthis.beanInfo = beanInfo;\n+\t}\n \n     public PropertyPointer getPropertyPointer(){\n         return new BeanPropertyPointer(this, beanInfo);\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n-            return true;\n-        }\n-\n-        if (!(object instanceof BeanPointer)){\n-            return false;\n-        }\n-\n-        BeanPointer other = (BeanPointer)object;\n-        if (parent != other.parent){\n-            if (parent == null || !parent.equals(other.parent)){\n-                return false;\n-            }\n-        }\n-\n-        if ((name == null && other.name != null) ||\n-                (name != null && !name.equals(other.name))){\n-            return false;\n-        }\n-\n-        int i_this = (index == WHOLE_COLLECTION ? 0 : index);\n-        int i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-        if (i_this != i_other){\n-            return false;\n-        }\n-\n-        if (bean instanceof Number || bean instanceof String || bean instanceof Boolean){\n-            return bean.equals(other.bean);\n-        }\n-        return bean == other.bean;\n-    }\n+\tpublic boolean equals(Object object) {\n+\t\tif (object == this) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (!(object instanceof BeanPointer)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tBeanPointer other = (BeanPointer) object;\n+\t\tif (parent != other.parent) {\n+\t\t\tif (parent == null || !parent.equals(other.parent)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ((name == null && other.name != null)\n+\t\t\t|| (name != null && !name.equals(other.name))) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tint i_this = (index == WHOLE_COLLECTION ? 0 : index);\n+\t\tint i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n+\t\tif (i_this != i_other) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (bean instanceof Number\n+\t\t\t|| bean instanceof String\n+\t\t\t|| bean instanceof Boolean) {\n+\t\t\treturn bean.equals(other.bean);\n+\t\t}\n+\t\treturn bean == other.bean;\n+\t}\n \n     /**\n      * If the pointer has a parent, then parent's path.\n      * If the bean is a primitive value, the value itself.\n      * Otherwise - an empty string.\n      */\n-    public String asPath(){\n-        if (parent != null){\n-            return super.asPath();\n-        }\n-        else if (bean == null){\n-            return \"null()\";\n-        }\n-        else if (bean instanceof Number){\n-            String string = bean.toString();\n-            if (string.endsWith(\".0\")){\n-                string = string.substring(0, string.length() - 2);\n-            }\n-            return string;\n-        }\n-        else if (bean instanceof Boolean){\n-            return ((Boolean)bean).booleanValue() ? \"true()\" : \"false()\";\n-        }\n-        else if (bean instanceof String){\n-            return \"'\" + bean + \"'\";\n-        }\n-        return \"/\";\n-    }\n+\tpublic String asPath() {\n+\t\tif (parent != null) {\n+\t\t\treturn super.asPath();\n+\t\t}\n+\t\telse if (bean == null) {\n+\t\t\treturn \"null()\";\n+\t\t}\n+\t\telse if (bean instanceof Number) {\n+\t\t\tString string = bean.toString();\n+\t\t\tif (string.endsWith(\".0\")) {\n+\t\t\t\tstring = string.substring(0, string.length() - 2);\n+\t\t\t}\n+\t\t\treturn string;\n+\t\t}\n+\t\telse if (bean instanceof Boolean) {\n+\t\t\treturn ((Boolean) bean).booleanValue() ? \"true()\" : \"false()\";\n+\t\t}\n+\t\telse if (bean instanceof String) {\n+\t\t\treturn \"'\" + bean + \"'\";\n+\t\t}\n+\t\treturn \"/\";\n+\t}\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.9 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model.beans;\n \n import java.beans.PropertyDescriptor;\n-import java.util.Arrays;\n \n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.JXPathBeanInfo;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private String propertyName;\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         if (value == UNINITIALIZED){\n             Object baseValue = getBaseValue();\n             if (index == WHOLE_COLLECTION){\n         return getPropertyDescriptor() != null;\n     }\n \n+    public boolean isCollection(){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            return false;\n+        }\n+        \n+        int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n+        if (hint == -1){\n+            return false;\n+        }\n+        if (hint == 1){\n+            return true;\n+        }\n+        \n+        Object value = getBaseValue();\n+        return value != null && ValueUtils.isCollection(value);\n+    }\n+    \n+    /**\n+     * If the property contains a collection, then the length of that\n+     * collection, otherwise - 1.\n+     */\n+    public int getLength(){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            return 1;\n+        }\n+        \n+        int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n+        if (hint == -1){\n+            return 1;\n+        }\n+        return ValueUtils.getLength(getBaseValue());\n+    }\n+    \n     /**\n      * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n      * change the value of the index'th element of the collection\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.7 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n         return index == WHOLE_COLLECTION;\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         if (index != WHOLE_COLLECTION){\n             return ValueUtils.getValue(collection, index);\n         }\n                 valuePointer = this;\n             }\n             else {\n-                Object value = getNode();\n-                valuePointer = NodePointer.\n-                \t\t\tnewChildNodePointer(this, getName(), value);\n+                Object value = getImmediateNode();\n+                valuePointer =\n+                    NodePointer.newChildNodePointer(this, getName(), value);\n             }\n         }\n         return valuePointer;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.9 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.Arrays;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.DynamicPropertyHandler;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.JXPathIntrospector;\n+import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n     private String[] names;\n     private String requiredPropertyName;\n \n-    public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler){\n-        super(parent);\n-        this.handler = handler;\n-    }\n-\n+\tpublic DynamicPropertyPointer(\n+    \t\tNodePointer parent,\n+    \t\tDynamicPropertyHandler handler) \n+    {\n+\t\tsuper(parent);\n+\t\tthis.handler = handler;\n+\t}\n     /**\n      * This type of node is auxiliary.\n      */\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getNode(){\n-        Object value;\n-        if (index == WHOLE_COLLECTION){\n-            value = handler.getProperty(getBean(), getPropertyName());\n-        }\n-        else {\n-            value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index);\n-        }\n-        return value;\n+    public Object getImmediateNode(){\n+\t\tObject value;\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\tvalue = handler.getProperty(getBean(), getPropertyName());\n+\t\t}\n+\t\telse {\n+\t\t\tvalue =\n+\t\t\t\tValueUtils.getValue(\n+\t\t\t\t\thandler.getProperty(getBean(), getPropertyName()),\n+\t\t\t\t\tindex);\n+\t\t}\n+\t\treturn value;\n     }\n \n     /**\n      * represented by the property.\n      */\n     public void setValue(Object value){\n-        if (index == WHOLE_COLLECTION){\n-            handler.setProperty(getBean(), getPropertyName(), value);\n-        }\n-        else {\n-            ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value);\n-        }\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), value);\n+\t\t}\n+\t\telse {\n+\t\t\tValueUtils.setValue(\n+\t\t\t\thandler.getProperty(getBean(), getPropertyName()),\n+\t\t\t\tindex,\n+\t\t\t\tvalue);\n+\t\t}\n     }\n \n     public NodePointer createPath(JXPathContext context, Object value){\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n-        // Ignore the name passed to us, use our own data\n-        if (index == WHOLE_COLLECTION){\n-            handler.setProperty(getBean(), getPropertyName(), value);\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (collection == null){\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory.createObject(context, this, getBean(), getPropertyName(), 0)){\n-                    throw new JXPathException(\"Factory could not create an object for path: \" + asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0){\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()){\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                handler.setProperty(getBean(), getPropertyName(), collection);\n-            }\n-\n-            ValueUtils.setValue(collection, index, value);\n-        }\n-        NodePointer ptr = (NodePointer)clone();\n-        ptr.setIndex(index);\n-        return ptr;\n+\t\t// Ignore the name passed to us, use our own data\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), value);\n+\t\t}\n+\t\telse {\n+\t\t\tObject collection = getBaseValue();\n+\t\t\tif (collection == null) {\n+\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\t\tif (!factory\n+\t\t\t\t\t.createObject(\n+\t\t\t\t\t\tcontext,\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tgetBean(),\n+\t\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\t\t0)) {\n+\t\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\t\"Factory could not create an object for path: \"\n+\t\t\t\t\t\t\t+ asPath());\n+\t\t\t\t}\n+\t\t\t\tcollection = getBaseValue();\n+\t\t\t}\n+\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n+\t\t\t}\n+\n+\t\t\tif (index >= getLength()) {\n+\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n+\t\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n+\t\t\t}\n+\n+\t\t\tValueUtils.setValue(collection, index, value);\n+\t\t}\n+\t\tNodePointer ptr = (NodePointer) clone();\n+\t\tptr.setIndex(index);\n+\t\treturn ptr;\n     }\n \n     public NodePointer createChild(JXPathContext context, QName name, int index){\n-        // Ignore the name passed to us, use our own data\n-        Object collection = getBaseValue();\n-        if (collection == null){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory.createObject(context, this, getBean(), getPropertyName(), 0)){\n-                throw new JXPathException(\"Factory could not create an object for path: \" + asPath());\n-            }\n-            collection = getBaseValue();\n-        }\n-\n-        if (index < 0){\n-            throw new JXPathException(\"Index is less than 1: \" + asPath());\n-        }\n-\n-        if (index >= getLength()){\n-            collection = ValueUtils.expandCollection(collection, index + 1);\n-            handler.setProperty(getBean(), getPropertyName(), collection);\n-        }\n-\n-        DynamicPropertyPointer pointer = (DynamicPropertyPointer)this.clone();\n-        pointer.setIndex(index);\n-        return pointer;\n+\t\t// Ignore the name passed to us, use our own data\n+\t\tObject collection = getBaseValue();\n+\t\tif (collection == null) {\n+\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\tif (!factory\n+\t\t\t\t.createObject(context, this, getBean(), getPropertyName(), 0)) {\n+\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n+\t\t\t}\n+\t\t\tcollection = getBaseValue();\n+\t\t}\n+\n+\t\tif (index < 0) {\n+\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n+\t\t}\n+\n+\t\tif (index >= getLength()) {\n+\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n+\t\t}\n+\n+\t\tDynamicPropertyPointer pointer = (DynamicPropertyPointer) this.clone();\n+\t\tpointer.setIndex(index);\n+\t\treturn pointer;\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-        if (getNode() == null){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n-                throw new JXPathException(\"Factory could not create an object for path: \" + asPath());\n-            }\n-        }\n-        return this;\n+\t\tif (getNode() == null) {\n+\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\tint inx = (index == WHOLE_COLLECTION ? 0 : index);\n+\t\t\tif (!factory\n+\t\t\t\t.createObject(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tthis,\n+\t\t\t\t\tgetBean(),\n+\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\tinx)) {\n+\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n+\t\t\t}\n+\t\t}\n+\t\treturn this;\n     }\n \n     public void remove(){\n-        if (index == WHOLE_COLLECTION){\n-            handler.setProperty(getBean(), getPropertyName(), null);\n-        }\n-        else if (isCollection()){\n-            Object collection = ValueUtils.remove(getBaseValue(), index);\n-            handler.setProperty(getBean(), getPropertyName(), collection);\n-        }\n-        else if (index == 0){\n-            handler.setProperty(getBean(), getPropertyName(), null);\n-        }\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), null);\n+\t\t}\n+\t\telse if (isCollection()) {\n+\t\t\tObject collection = ValueUtils.remove(getBaseValue(), index);\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), collection);\n+\t\t}\n+\t\telse if (index == 0) {\n+\t\t\thandler.setProperty(getBean(), getPropertyName(), null);\n+\t\t}\n     }\n \n     public String asPath(){\n-        StringBuffer buffer = new StringBuffer();\n-        buffer.append(getParent().asPath());\n-        if (buffer.length() == 0){\n-            buffer.append(\"/.\");\n-        }\n-        else if (buffer.charAt(buffer.length() - 1) == '/'){\n-            buffer.append('.');\n-        }\n-        buffer.append(\"[@name='\");\n-        buffer.append(escape(getPropertyName()));\n-        buffer.append(\"']\");\n-        if (index != WHOLE_COLLECTION && isCollection()){\n-            buffer.append('[').append(index + 1).append(']');\n-        }\n-        return buffer.toString();\n+\t\tStringBuffer buffer = new StringBuffer();\n+\t\tbuffer.append(getParent().asPath());\n+\t\tif (buffer.length() == 0) {\n+\t\t\tbuffer.append(\"/.\");\n+\t\t}\n+\t\telse if (buffer.charAt(buffer.length() - 1) == '/') {\n+\t\t\tbuffer.append('.');\n+\t\t}\n+\t\tbuffer.append(\"[@name='\");\n+\t\tbuffer.append(escape(getPropertyName()));\n+\t\tbuffer.append(\"']\");\n+\t\tif (index != WHOLE_COLLECTION && isCollection()) {\n+\t\t\tbuffer.append('[').append(index + 1).append(']');\n+\t\t}\n+\t\treturn buffer.toString();\n     }\n \n     private String escape(String string){\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.5 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.6 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of the attribute is based on the locale supplied to it in the constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.6 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class LangAttributePointer extends NodePointer {\n     public LangAttributePointer(NodePointer parent){\n         return parent.getLocale().toString().replace('_', '-');\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return getBaseValue();\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.9 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * as the parent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class NullElementPointer extends PropertyOwnerPointer {\n \n         return null;\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return null;\n     }\n     \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.9 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n         return null;\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return null;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.9 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         if (value == UNINITIALIZED){\n             if (index == WHOLE_COLLECTION){\n                 value = getBaseValue();\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.6 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:20:06 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a property of the parent object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n  */\n public abstract class PropertyPointer extends NodePointer {\n     public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         if (value == UNINITIALIZED){\n             if (index == WHOLE_COLLECTION){\n                 value = getBaseValue();\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n      */\n-    public NodePointer getValuePointer(){\n-        return NodePointer.newChildNodePointer(this, getName(), getNode());\n+    public NodePointer getImmediateValuePointer(){\n+        return NodePointer.newChildNodePointer(\n+            this,\n+            getName(),\n+            getImmediateNode());\n     }\n \n     public int hashCode(){\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.5 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.6 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.6 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n         return getValuePointer().isLeaf();\n     }    \n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         Object value = getBaseValue();\n         if (index != WHOLE_COLLECTION){\n             if (index >= 0 && index < getLength()){\n         container.setValue(value);\n     }\n \n-    public NodePointer getValuePointer(){\n-        if (valuePointer == null){\n-            Object value = getNode();\n-            valuePointer = NodePointer.newChildNodePointer(this, getName(), value).getValuePointer();\n+    public NodePointer getImmediateValuePointer(){\n+        if (valuePointer == null) {\n+            Object value = getImmediateNode();\n+            valuePointer =\n+                NodePointer.newChildNodePointer(this, getName(), value);\n         }\n         return valuePointer;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.7 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.8 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n         return 1;\n     }    \n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         String value = attr.getValue();\n         if (value == null){\n             return null;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.11 2002/10/20 03:44:52 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/10/20 03:44:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.12 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/10/20 03:44:52 $\n+ * @version $Revision: 1.12 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n         return node;\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return node;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.6 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.7 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class NamespacePointer extends NodePointer {\n     private String prefix;\n         return 1;\n     }    \n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return getNamespaceURI();\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java,v 1.1 2002/10/20 03:44:18 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:44:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.dynabeans;\n \n-import java.beans.PropertyDescriptor;\n import java.util.Locale;\n \n import org.apache.commons.beanutils.DynaBean;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n-import org.apache.commons.jxpath.JXPathIntrospector;\n-import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.util.ValueUtils;\n \n \n /**\n  * A Pointer that points to a DynaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:44:18 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class DynaBeanPointer extends PropertyOwnerPointer {\n     private QName name;\n         return dynaBean;\n     }\n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return dynaBean;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java,v 1.1 2002/10/20 03:44:18 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:44:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.Locale;\n \n import org.apache.commons.beanutils.DynaBean;\n-import org.apache.commons.beanutils.DynaClass;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n  * </a>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:44:18 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class DynaBeanPointerFactory implements NodePointerFactory {\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.2 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.beanutils.DynaClass;\n import org.apache.commons.beanutils.DynaProperty;\n import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n-import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.util.TypeConverter;\n import org.apache.commons.jxpath.util.TypeUtils;\n import org.apache.commons.jxpath.util.ValueUtils;\n \n  * Pointer pointing to a property of a DynaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class DynaBeanPropertyPointer extends PropertyPointer {\n     private DynaBean dynaBean;\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         String name = getPropertyName();\n         if (name.equals(\"*\")){\n             return null;\n     public NodePointer createChild(JXPathContext context,\n             QName name, int index, Object value)\n     {\n-        // Ignore the name passed to us, use our own data\n-        if (index == WHOLE_COLLECTION){\n-            setValue(index, value);\n-        }\n-        else if (isIndexedProperty()){\n-            dynaBean.set(getPropertyName(), index, convert(value, true));\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (collection == null){\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory.createObject(\n-                        context, this, getBean(), getPropertyName(), 0)){\n-                    throw new JXPathException(\n-                        \"Factory could not create an object for path: \" +\n-                        asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0){\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()){\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                dynaBean.set(getPropertyName(), collection);\n-            }\n-\n-            ValueUtils.setValue(collection, index, value);\n-        }\n-        NodePointer ptr = (NodePointer)clone();\n-        ptr.setIndex(index);\n-        return ptr;\n+\t\t// Ignore the name passed to us, use our own data\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\tsetValue(index, value);\n+\t\t}\n+\t\telse if (isIndexedProperty()) {\n+\t\t\tdynaBean.set(getPropertyName(), index, convert(value, true));\n+\t\t}\n+\t\telse {\n+\t\t\tObject collection = getBaseValue();\n+\t\t\tif (collection == null) {\n+\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\t\tif (!factory\n+\t\t\t\t\t.createObject(\n+\t\t\t\t\t\tcontext,\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tgetBean(),\n+\t\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\t\t0)) {\n+\t\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\t\"Factory could not create an object for path: \"\n+\t\t\t\t\t\t\t+ asPath());\n+\t\t\t\t}\n+\t\t\t\tcollection = getBaseValue();\n+\t\t\t}\n+\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n+\t\t\t}\n+\n+\t\t\tif (index >= getLength()) {\n+\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n+\t\t\t\tdynaBean.set(getPropertyName(), collection);\n+\t\t\t}\n+\n+\t\t\tValueUtils.setValue(collection, index, value);\n+\t\t}\n+\t\tNodePointer ptr = (NodePointer) clone();\n+\t\tptr.setIndex(index);\n+\t\treturn ptr;\n     }\n \n     public NodePointer createChild(JXPathContext context,\n             QName name, int index)\n     {\n-        if (isIndexedProperty()){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory.createObject(\n-                        context, this, dynaBean, getPropertyName(), index)){\n-                throw new JXPathException(\n-                    \"Factory could not create an object for path: \" + asPath());\n-            }\n-        }\n-        else {\n-            // Ignore the name passed to us, use our own data\n-            Object collection = getBaseValue();\n-            if (collection == null){\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory.createObject(\n-                            context, this, dynaBean, getPropertyName(), index)){\n-                    throw new JXPathException(\n-                        \"Factory could not create an object for path: \" +\n-                        asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0){\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()){\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                dynaBean.set(getPropertyName(), collection);\n-            }\n-        }\n-\n-        DynaBeanPropertyPointer pointer = (DynaBeanPropertyPointer)this.clone();\n-        pointer.setIndex(index);\n-        return pointer;\n+\t\tif (isIndexedProperty()) {\n+\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\tif (!factory\n+\t\t\t\t.createObject(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tthis,\n+\t\t\t\t\tdynaBean,\n+\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\tindex)) {\n+\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\t// Ignore the name passed to us, use our own data\n+\t\t\tObject collection = getBaseValue();\n+\t\t\tif (collection == null) {\n+\t\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\t\tif (!factory\n+\t\t\t\t\t.createObject(\n+\t\t\t\t\t\tcontext,\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tdynaBean,\n+\t\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\t\tindex)) {\n+\t\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\t\"Factory could not create an object for path: \"\n+\t\t\t\t\t\t\t+ asPath());\n+\t\t\t\t}\n+\t\t\t\tcollection = getBaseValue();\n+\t\t\t}\n+\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new JXPathException(\"Index is less than 1: \" + asPath());\n+\t\t\t}\n+\n+\t\t\tif (index >= getLength()) {\n+\t\t\t\tcollection = ValueUtils.expandCollection(collection, index + 1);\n+\t\t\t\tdynaBean.set(getPropertyName(), collection);\n+\t\t\t}\n+\t\t}\n+\n+\t\tDynaBeanPropertyPointer pointer =\n+\t\t\t(DynaBeanPropertyPointer) this.clone();\n+\t\tpointer.setIndex(index);\n+\t\treturn pointer;\n     }\n \n     public NodePointer createPath(JXPathContext context){\n-        if (getNode() == null){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory.createObject(\n-                    context, this, dynaBean, getPropertyName(), inx)){\n-                throw new JXPathException(\n-                        \"Factory could not create an object for path: \" +\n-                        asPath());\n-            }\n-        }\n+\t\tif (getNode() == null) {\n+\t\t\tAbstractFactory factory = getAbstractFactory(context);\n+\t\t\tint inx = (index == WHOLE_COLLECTION ? 0 : index);\n+\t\t\tif (!factory\n+\t\t\t\t.createObject(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tthis,\n+\t\t\t\t\tdynaBean,\n+\t\t\t\t\tgetPropertyName(),\n+\t\t\t\t\tinx)) {\n+\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\"Factory could not create an object for path: \" + asPath());\n+\t\t\t}\n+\t\t}\n         return this;\n     }\n \n     public void remove(){\n-        if (index == WHOLE_COLLECTION){\n-            dynaBean.set(getPropertyName(), null);\n-        }\n-        else if (isIndexedProperty()){\n-            dynaBean.set(getPropertyName(), index, null);\n-        }\n-        else if (isCollection()){\n-            Object collection = ValueUtils.remove(getBaseValue(), index);\n-            dynaBean.set(getPropertyName(), collection);\n-        }\n-        else if (index == 0){\n-            dynaBean.set(getPropertyName(), null);\n-        }\n+\t\tif (index == WHOLE_COLLECTION) {\n+\t\t\tdynaBean.set(getPropertyName(), null);\n+\t\t}\n+\t\telse if (isIndexedProperty()) {\n+\t\t\tdynaBean.set(getPropertyName(), index, null);\n+\t\t}\n+\t\telse if (isCollection()) {\n+\t\t\tObject collection = ValueUtils.remove(getBaseValue(), index);\n+\t\t\tdynaBean.set(getPropertyName(), collection);\n+\t\t}\n+\t\telse if (index == 0) {\n+\t\t\tdynaBean.set(getPropertyName(), null);\n+\t\t}\n     }\n \n     private AbstractFactory getAbstractFactory(JXPathContext context){\n-        AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n-            throw new JXPathException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n-        }\n-        return factory;\n+\t\tAbstractFactory factory = context.getFactory();\n+\t\tif (factory == null) {\n+\t\t\tthrow new JXPathException(\n+\t\t\t\t\"Factory is not set on the JXPathContext - cannot create path: \"\n+\t\t\t\t\t+ asPath());\n+\t\t}\n+\t\treturn factory;\n     }\n \n     private void setValue(int index, Object value){\n \n \n     private Object convert(Object value, boolean element){\n-        DynaClass dynaClass = (DynaClass)dynaBean.getDynaClass();\n-        DynaProperty property =\n-                dynaClass.getDynaProperty(getPropertyName());\n-        Class type = property.getType();\n-        if (element){\n-            if (type.isArray()){\n-                type = type.getComponentType();\n-            }\n-            else {\n-                return value;       // No need to convert\n-            }\n-        }\n-\n-        try {\n-            return TypeUtils.convert(value, type);\n-        }\n-        catch (Exception ex){\n-            ex.printStackTrace();\n-            throw new JXPathException(\"Cannot convert value of class \" +\n-                    (value == null ? \"null\" : value.getClass().getName()) +\n-                    \" to type \" + type, ex);\n-        }\n+\t\tDynaClass dynaClass = (DynaClass) dynaBean.getDynaClass();\n+\t\tDynaProperty property = dynaClass.getDynaProperty(getPropertyName());\n+\t\tClass type = property.getType();\n+\t\tif (element) {\n+\t\t\tif (type.isArray()) {\n+\t\t\t\ttype = type.getComponentType();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn value; // No need to convert\n+\t\t\t}\n+\t\t}\n+\n+\t\ttry {\n+\t\t\treturn TypeUtils.convert(value, type);\n+\t\t}\n+\t\tcatch (Exception ex) {\n+\t\t\tex.printStackTrace();\n+\t\t\tthrow new JXPathException(\n+\t\t\t\t\"Cannot convert value of class \"\n+\t\t\t\t\t+ (value == null ? \"null\" : value.getClass().getName())\n+\t\t\t\t\t+ \" to type \"\n+\t\t\t\t\t+ type,\n+\t\t\t\tex);\n+\t\t}\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.2 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.compiler.NodeTest;\n-import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.TypeUtils;\n import org.jdom.Attribute;\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class JDOMAttributePointer extends NodePointer {\n     private Attribute attr;\n         this.attr = attr;\n     }\n \n-    public QName getName(){\n-        return new QName(JDOMNodePointer.getPrefix(attr), JDOMNodePointer.getLocalName(attr));\n-    }\n+\tpublic QName getName() {\n+\t\treturn new QName(\n+\t\t\tJDOMNodePointer.getPrefix(attr),\n+\t\t\tJDOMNodePointer.getLocalName(attr));\n+\t}\n \n     public QName getExpandedName(){\n         return new QName(getNamespaceURI(),  attr.getName());\n         return 1;\n     }    \n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         String value = attr.getValue();\n         if (value == null){\n             return null;\n     public boolean isLeaf(){\n         return true;\n     }\n-\n-//    public boolean testNode(NodeTest nodeTest){\n-//        return nodeTest == null ||\n-//                ((nodeTest instanceof NodeTypeTest) &&\n-//                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n-//    }\n \n     /**\n      * Sets the value of this attribute.\n         return attr == other.attr;\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n-        // Won't happen - attributes don't have children\n-        return 0;\n-    }\n+\tpublic int compareChildNodePointers(\n+    \t\tNodePointer pointer1,\n+    \t\tNodePointer pointer2) \n+    {\n+\t\t// Won't happen - attributes don't have children\n+\t\treturn 0;\n+\t}\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:29:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.*;\n \n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.jdom.*;\n+import org.jdom.Element;\n+import org.jdom.Namespace;\n \n /**\n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class JDOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n             namespaces = new ArrayList();\n             prefixes = new HashSet();\n             collectNamespaces((Element)parent.getNode());\n-//            System.err.println(\"NAMESPACES: \" + namespaces);\n         }\n     }\n \n     private void collectNamespaces(Element element){\n-//            NamedNodeMap map = node.getAttributes();\n-//            int count = map.getLength();\n-//            for (int i = 0; i < count; i++){\n-//                Attr attr = (Attr)map.item(i);\n-//                String prefix = DOMNodePointer.getPrefix(attr);\n-//                String name = DOMNodePointer.getLocalName(attr);\n-//                if ((prefix != null && prefix.equals(\"xmlns\")) ||\n-//                        (prefix == null && name.equals(\"xmlns\"))){\n-//                    attributes.add(attr);\n-//                }\n-//            }\n         Namespace ns = element.getNamespace();\n         if (ns != null && !prefixes.contains(ns.getPrefix())){\n             namespaces.add(ns);\n         if (index < 0){\n             index = 0;\n         }\n-        String prefix = \"\";\n         Namespace ns = (Namespace)namespaces.get(index);\n-//        String name = attr.getPrefix();\n-//        if (name != null && name.equals(\"xmlns\")){\n-//            prefix = JDOMNodePointer.getLocalName(attr);\n-//        }\n         return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.2 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.3 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.compiler.NodeTest;\n-import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class JDOMNamespacePointer extends NodePointer {\n     private String prefix;\n         this.prefix = prefix;\n     }\n \n-    public JDOMNamespacePointer(NodePointer parent, String prefix, String namespaceURI){\n-        super(parent);\n-        this.prefix = prefix;\n-        this.namespaceURI = namespaceURI;\n-    }\n+\tpublic JDOMNamespacePointer(\n+    \t\tNodePointer parent,\n+    \t\tString prefix,\n+    \t\tString namespaceURI) \n+    {\n+\t\tsuper(parent);\n+\t\tthis.prefix = prefix;\n+\t\tthis.namespaceURI = namespaceURI;\n+\t}\n \n     public QName getName(){\n         return new QName(getNamespaceURI(), prefix);\n         return 1;\n     }    \n \n-    public Object getNode(){\n+    public Object getImmediateNode(){\n         return getNamespaceURI();\n     }\n \n         throw new UnsupportedOperationException(\"Cannot modify a namespace\");\n     }\n \n-    /*\n-    public boolean testNode(NodeTest nodeTest){\n-        return nodeTest == null ||\n-                ((nodeTest instanceof NodeTypeTest) &&\n-                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n-    }\n-*/\n     public String asPath(){\n         StringBuffer buffer = new StringBuffer();\n         if (parent != null){\n         return prefix.equals(other.prefix);\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n-        // Won't happen - namespaces don't have children\n-        return 0;\n-    }\n+\tpublic int compareChildNodePointers(\n+\t\tNodePointer pointer1,\n+\t\tNodePointer pointer2) \n+    {\n+\t\t// Won't happen - namespaces don't have children\n+\t\treturn 0;\n+\t}\n  }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.3 2002/10/20 03:44:51 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/20 03:44:51 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.4 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import java.util.ArrayList;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n-import org.apache.commons.jxpath.ri.compiler.NodeTest;\n-import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n-import org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\n+import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.TypeUtils;\n-import org.jdom.Attribute;\n-import org.jdom.CDATA;\n-import org.jdom.Comment;\n-import org.jdom.Document;\n-import org.jdom.Element;\n-import org.jdom.Namespace;\n-import org.jdom.ProcessingInstruction;\n-import org.jdom.Text;\n+import org.jdom.*;\n \n /**\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/10/20 03:44:51 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class JDOMNodePointer extends NodePointer {\n     private Object node;\n     /**\n      * @see org.apache.commons.jxpath.ri.model.NodePointer#getNode()\n      */\n-    public Object getNode() {\n+    public Object getImmediateNode() {\n         return node;\n     }\n \n     }\n \n     public NodePointer createAttribute(JXPathContext context, QName name){\n-        if (!(node instanceof Element)){\n-            return super.createAttribute(context, name);\n-        }\n-\n-        Element element = (Element)node;\n-        String prefix = name.getPrefix();\n-        if (prefix != null){\n-            Namespace ns = element.getNamespace(prefix);\n-            if (ns == null){\n-                throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\n-            }\n-            Attribute attr = element.getAttribute(name.getName(), ns);\n-            if (attr == null){\n-                element.setAttribute(name.getName(), \"\", ns);\n-            }\n-        }\n-        else {\n-            Attribute attr = element.getAttribute(name.getName());\n-            if (attr == null){\n-                element.setAttribute(name.getName(), \"\");\n-            }\n-        }\n-        NodeIterator it = attributeIterator(name);\n-        it.setPosition(1);\n-        return it.getNodePointer();\n+\t\tif (!(node instanceof Element)) {\n+\t\t\treturn super.createAttribute(context, name);\n+\t\t}\n+\n+\t\tElement element = (Element) node;\n+\t\tString prefix = name.getPrefix();\n+\t\tif (prefix != null) {\n+\t\t\tNamespace ns = element.getNamespace(prefix);\n+\t\t\tif (ns == null) {\n+\t\t\t\tthrow new JXPathException(\n+\t\t\t\t\t\"Unknown namespace prefix: \" + prefix);\n+\t\t\t}\n+\t\t\tAttribute attr = element.getAttribute(name.getName(), ns);\n+\t\t\tif (attr == null) {\n+\t\t\t\telement.setAttribute(name.getName(), \"\", ns);\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tAttribute attr = element.getAttribute(name.getName());\n+\t\t\tif (attr == null) {\n+\t\t\t\telement.setAttribute(name.getName(), \"\");\n+\t\t\t}\n+\t\t}\n+\t\tNodeIterator it = attributeIterator(name);\n+\t\tit.setPosition(1);\n+\t\treturn it.getNodePointer();\n     }\n \n     public void remove(){\n     }\n \n     private int getRelativePositionOfPI(String target){\n-        Element parent = ((ProcessingInstruction)node).getParent();\n-        if (parent == null){\n-            return 1;\n-        }\n-        List children = parent.getContent();\n-        int count = 0;\n-        for (int i = 0; i < children.size(); i++){\n-            Object child = children.get(i);\n-            if (child instanceof ProcessingInstruction &&\n-                  (target == null ||\n-                   target.equals(((ProcessingInstruction)child).getTarget()))){\n-                count++;\n-            }\n-            if (child == node){\n-                break;\n-            }\n-        }\n-        return count;\n+\t\tElement parent = ((ProcessingInstruction) node).getParent();\n+\t\tif (parent == null) {\n+\t\t\treturn 1;\n+\t\t}\n+\t\tList children = parent.getContent();\n+\t\tint count = 0;\n+\t\tfor (int i = 0; i < children.size(); i++) {\n+\t\t\tObject child = children.get(i);\n+\t\t\tif (child instanceof ProcessingInstruction\n+\t\t\t\t&& (target == null\n+\t\t\t\t\t|| target.equals(\n+\t\t\t\t\t\t((ProcessingInstruction) child).getTarget()))) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t\tif (child == node) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn count;\n     }\n \n     public int hashCode(){\n         return node == other.node;\n     }\n \n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n-        AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n-            throw new JXPathException(\n-                    \"Factory is not set on the JXPathContext - \" +\n-                    \"cannot create path: \" + asPath());\n-        }\n-        return factory;\n-    }\n+\tprivate AbstractFactory getAbstractFactory(JXPathContext context) {\n+\t\tAbstractFactory factory = context.getFactory();\n+\t\tif (factory == null) {\n+\t\t\tthrow new JXPathException(\n+\t\t\t\t\"Factory is not set on the JXPathContext - cannot create path: \"\n+\t\t\t\t\t+ asPath());\n+\t\t}\n+\t\treturn factory;\n+\t}\n }\n--- a/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java,v 1.1 2002/06/12 21:02:05 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/06/12 21:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.util;\n \n-import java.lang.reflect.*;\n-import java.util.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.Pointer;\n \n /**\n  * Method lookup utilities, which find static and non-static methods as well\n  * as constructors based on a name and list of parameters.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/06/12 21:02:05 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class MethodLookupUtils {\n \n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.8 2002/06/16 03:22:21 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/06/16 03:22:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.9 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.util;\n \n-import java.lang.reflect.*;\n-import java.util.*;\n-\n-import org.apache.commons.jxpath.ExpressionContext;\n-import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.Pointer;\n-\n /**\n  * Global type conversion utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/06/16 03:22:21 $\n+ * @version $Revision: 1.9 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class TypeUtils {\n     private static TypeConverter typeConverter = new BasicTypeConverter();\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.9 2002/10/20 03:43:55 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/10/20 03:43:55 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.10 2002/11/26 01:20:07 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/11/26 01:20:07 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.beans.IndexedPropertyDescriptor;\n import java.beans.PropertyDescriptor;\n-import java.lang.reflect.*;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.*;\n \n+import org.apache.commons.jxpath.DynamicPropertyHandler;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.DynamicPropertyHandler;\n \n /**\n  * Collection and property access utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/10/20 03:43:55 $\n+ * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:07 $\n  */\n public class ValueUtils {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n             return true;\n         }\n         return false;\n+    }\n+    \n+    /**\n+     * Returns 1 if the type is a collection, \n+     * -1 if it is definitely not\n+     * and 0 if it may be a collection in some cases.\n+     */\n+    public static int getCollectionHint(Class clazz){\n+        if (clazz.isArray()){\n+            return 1;\n+        }\n+        \n+        if (Collection.class.isAssignableFrom(clazz)){\n+            return 1;\n+        }\n+        \n+        if (clazz.isPrimitive()){\n+            return -1;\n+        }\n+        \n+        if (clazz.isInterface()){\n+            return 0;\n+        }\n+        \n+        if (Modifier.isFinal(clazz.getModifiers())){\n+            return -1;\n+        }\n+                \n+        return 0;\n     }\n \n     /**\n     public static Object getValue(Object bean,\n             PropertyDescriptor propertyDescriptor, int index){\n         if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n-            Object value;\n             try {\n                 IndexedPropertyDescriptor ipd =\n                     (IndexedPropertyDescriptor)propertyDescriptor;\n         }\n \n         // Check the implemented interfaces and subinterfaces\n-        String methodName = method.getName();\n-        Class[] parameterTypes = method.getParameterTypes();\n-        method =\n-            getAccessibleMethodFromInterfaceNest(clazz,\n-                                                 method.getName(),\n-                                                 method.getParameterTypes());\n+\t\tmethod =\n+\t\t\tgetAccessibleMethodFromInterfaceNest(\n+\t\t\t\tclazz,\n+\t\t\t\tmethod.getName(),\n+\t\t\t\tmethod.getParameterTypes());\n         return (method);\n     }\n \n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.29 2002/10/20 03:48:21 dmitri Exp $\n- * $Revision: 1.29 $\n- * $Date: 2002/10/20 03:48:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.30 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.30 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n-import junit.framework.Test;\n+import java.util.*;\n+\n import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-import org.w3c.dom.*;\n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n-import java.beans.*;\n+\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n  * Abstract superclass for various JXPath tests.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.29 $ $Date: 2002/10/20 03:48:21 $\n+ * @version $Revision: 1.30 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public abstract class JXPathTestCase extends TestCase\n     {\n         super(name);\n     }\n-/*\n-    protected void testXPaths(JXPathContext ctx, XPathTest xpath_tests[])\n-            throws Exception\n-    {\n-        Exception exception = null;\n-        for  (int i=0; i < xpath_tests.length; i++) {\n-            try {\n-                Object actual;\n-                // System.err.println(\"XPATH: \" + xpath_tests[i].xpath);\n-                if (xpath_tests[i].path){\n-                    if (xpath_tests[i].eval){\n-                        Iterator it = ctx.iteratePointers(xpath_tests[i].xpath);\n-                        List paths = new ArrayList();\n-                        while (it.hasNext()){\n-                            paths.add(((Pointer)it.next()).asPath());\n-                        }\n-                        actual = paths;\n-                    }\n-                    else {\n-                        ctx.setLenient(xpath_tests[i].lenient);\n-                        actual = ctx.getPointer(xpath_tests[i].xpath).asPath();\n-                    }\n-                }\n-                else {\n-                    if (xpath_tests[i].eval){\n-                        ArrayList list = new ArrayList();\n-                        Iterator it = ctx.iterate(xpath_tests[i].xpath);\n-                        while (it.hasNext()){\n-                            list.add(it.next());\n-                        }\n-                        actual = list;\n-                    }\n-                    else {\n-                        ctx.setLenient(xpath_tests[i].lenient);\n-                        actual = ctx.getValue(xpath_tests[i].xpath);\n-                        ctx.setLenient(false);\n-                    }\n-                }\n-                assertEquals(\"Evaluating <\" + xpath_tests[i].xpath + \">\",\n-                        xpath_tests[i].expected, actual);\n-            }\n-            catch (Exception ex){\n-                System.err.println(\"Exception during <\" +\n-                    xpath_tests[i].xpath + \">\");\n-                ex.printStackTrace();\n-                exception = ex;\n-            }\n-            if (exception != null){\n-                throw exception;\n-            }\n-        }\n-\n-        // Make sure that location paths are properly constructed\n-        for (int i=0; i < xpath_tests.length; i++) {\n-            try {\n-                if (!xpath_tests[i].path && !xpath_tests[i].eval){\n-                    Pointer ptr = ctx.getPointer(xpath_tests[i].xpath);\n-                    Pointer test = ctx.getPointer(ptr.asPath());\n-                    assertEquals(\n-                        \"Testing pointer for <\" + xpath_tests[i].xpath + \">\",\n-                        ptr.asPath(), test.asPath());\n-                }\n-            }\n-            catch (Exception ex){\n-                System.err.println(\"Exception during pointer test <\" +\n-                        xpath_tests[i].xpath + \">\");\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-*/\n+    \n     protected void assertXPathValue(JXPathContext ctx,\n                 String xpath, Object expected)\n     {\n--- a/src/test/org/apache/commons/jxpath/TestNull.java\n+++ b/src/test/org/apache/commons/jxpath/TestNull.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestNull.java,v 1.1 2001/08/23 00:47:02 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:47:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestNull.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.util.*;\n \n /**\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:47:02 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestNull {\n \n--- a/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n \n     public void test_doStep_noPredicates_propertyOwner(){\n         // Existing scalar property\n-        testValueAndPointer(\"/int\",\n+        assertValueAndPointer(\"/int\",\n                 new Integer(1),\n                 \"/int\",\n+                \"Bb\",\n                 \"BbB\");\n \n         // self::\n-        testValueAndPointer(\"/./int\",\n+        assertValueAndPointer(\"/./int\",\n                 new Integer(1),\n                 \"/int\",\n+                \"Bb\",\n                 \"BbB\");\n \n         // Missing property\n-        testNullPointer(\"/foo\",\n+        assertNullPointer(\"/foo\",\n                 \"/foo\",\n-                \"BnN\");\n+                \"Bn\");\n \n         // existingProperty/existingScalarProperty\n-        testValueAndPointer(\"/nestedBean/int\",\n+        assertValueAndPointer(\"/nestedBean/int\",\n                 new Integer(1),\n                 \"/nestedBean/int\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // existingProperty/collectionProperty\n-        testValueAndPointer(\"/nestedBean/strings\",\n+        assertValueAndPointer(\"/nestedBean/strings\",\n                 bean.getNestedBean().getStrings(),\n                 \"/nestedBean/strings\",\n+                \"BbBb\",\n                 \"BbBbC\");\n \n         // existingProperty/missingProperty\n-        testNullPointer(\"/nestedBean/foo\",\n+        assertNullPointer(\"/nestedBean/foo\",\n                 \"/nestedBean/foo\",\n-                \"BbBnN\");\n+                \"BbBn\");\n \n         // map/missingProperty\n-        testNullPointer(\"/map/foo\",\n+        assertNullPointer(\"/map/foo\",\n                 \"/map[@name='foo']\",\n-                \"BbDdN\");\n+                \"BbDd\");\n \n         // Existing property by search in collection\n-        testValueAndPointer(\"/list/int\",\n+        assertValueAndPointer(\"/list/int\",\n                 new Integer(1),\n                 \"/list[3]/int\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // Missing property by search in collection\n-        testNullPointer(\"/list/foo\",\n+        assertNullPointer(\"/list/foo\",\n                 \"/list[1]/foo\",\n-                \"BbBnN\");\n+                \"BbBn\");\n \n         // existingProperty/missingProperty/missingProperty\n-        testNullPointer(\"/nestedBean/foo/bar\",\n+        assertNullPointer(\"/nestedBean/foo/bar\",\n                 \"/nestedBean/foo/bar\",\n-                \"BbBnNnN\");\n+                \"BbBnNn\");\n \n         // collection/existingProperty/missingProperty\n-        testNullPointer(\"/list/int/bar\",\n+        assertNullPointer(\"/list/int/bar\",\n                 \"/list[3]/int/bar\",\n-                \"BbBbBnN\");\n+                \"BbBbBn\");\n \n         // collectionProperty/missingProperty/missingProperty\n-        testNullPointer(\"/list/foo/bar\",\n+        assertNullPointer(\"/list/foo/bar\",\n                 \"/list[1]/foo/bar\",\n-                \"BbBnNnN\");\n+                \"BbBnNn\");\n \n         // map/missingProperty/anotherStep\n-        testNullPointer(\"/map/foo/bar\",\n+        assertNullPointer(\"/map/foo/bar\",\n                 \"/map[@name='foo']/bar\",\n-                \"BbDdNnN\");\n+                \"BbDdNn\");\n \n         // Existing dynamic property\n-        testValueAndPointer(\"/map/Key1\",\n+        assertValueAndPointer(\"/map/Key1\",\n                 \"Value 1\",\n                 \"/map[@name='Key1']\",\n+                \"BbDd\",\n                 \"BbDdB\");\n \n         // collectionProperty\n-        testValueAndPointer(\"/integers\",\n+        assertValueAndPointer(\"/integers\",\n                 bean.getIntegers(),\n                 \"/integers\",\n+                \"Bb\",\n                 \"BbC\");\n     }\n \n     public void test_doStep_noPredicates_standard(){\n         // Existing DOM node\n-        testValueAndPointer(\"/vendor/location/address/city\",\n+        assertValueAndPointer(\"/vendor/location/address/city\",\n                 \"Fruit Market\",\n                 \"/vendor/location[2]/address[1]/city[1]\",\n                 \"BbMMMM\");\n \n         // Missing DOM node\n-        testNullPointer(\"/vendor/location/address/pity\",\n+        assertNullPointer(\"/vendor/location/address/pity\",\n                 \"/vendor/location[1]/address[1]/pity\",\n-                \"BbMMMnN\");\n+                \"BbMMMn\");\n \n         // Missing DOM node inside a missing element\n-        testNullPointer(\"/vendor/location/address/itty/bitty\",\n+        assertNullPointer(\"/vendor/location/address/itty/bitty\",\n                 \"/vendor/location[1]/address[1]/itty/bitty\",\n-                \"BbMMMnNnN\");\n+                \"BbMMMnNn\");\n \n         // Missing DOM node by search for the best match\n-        testNullPointer(\"/vendor/location/address/city/pretty\",\n+        assertNullPointer(\"/vendor/location/address/city/pretty\",\n                 \"/vendor/location[2]/address[1]/city[1]/pretty\",\n-                \"BbMMMMnN\");\n+                \"BbMMMMn\");\n     }\n \n     public void test_doStep_predicates_propertyOwner(){\n         // missingProperty[@name=foo]\n-        testNullPointer(\"/foo[@name='foo']\",\n+        assertNullPointer(\"/foo[@name='foo']\",\n                 \"/foo[@name='foo']\",\n-                \"BnNnN\");\n+                \"BnNn\");\n \n         // missingProperty[index]\n-        testNullPointer(\"/foo[3]\",\n+        assertNullPointer(\"/foo[3]\",\n                 \"/foo[3]\",\n-                \"BnN\");\n+                \"Bn\");\n     }\n \n     public void test_doStep_predicates_standard(){\n         // Looking for an actual XML attribute called \"name\"\n         // nodeProperty/name[@name=value]\n-        testValueAndPointer(\"/vendor/contact[@name='jack']\",\n+        assertValueAndPointer(\"/vendor/contact[@name='jack']\",\n                 \"Jack\",\n                 \"/vendor/contact[2]\",\n                 \"BbMM\");\n \n         // Indexing in XML\n-        testValueAndPointer(\"/vendor/contact[2]\",\n+        assertValueAndPointer(\"/vendor/contact[2]\",\n                 \"Jack\",\n                 \"/vendor/contact[2]\",\n                 \"BbMM\");\n \n         // Indexing in XML, no result\n-        testNullPointer(\"/vendor/contact[5]\",\n+        assertNullPointer(\"/vendor/contact[5]\",\n                 \"/vendor/contact[5]\",\n-                \"BbMnN\");\n+                \"BbMn\");\n \n         // Combination of search by name and indexing in XML\n-        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+        assertValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n                 \"Jack Black\",\n                 \"/vendor/contact[4]\",\n                 \"BbMM\");\n \n         // Combination of search by name and indexing in XML\n-        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+        assertValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n                 \"Jack Black\",\n                 \"/vendor/contact[4]\",\n                 \"BbMM\");\n \n     public void test_doPredicate_name(){\n         // existingProperty[@name=existingProperty]\n-        testValueAndPointer(\"/nestedBean[@name='int']\",\n+        assertValueAndPointer(\"/nestedBean[@name='int']\",\n                 new Integer(1),\n                 \"/nestedBean/int\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // /self::node()[@name=existingProperty]\n-        testValueAndPointer(\"/.[@name='int']\",\n+        assertValueAndPointer(\"/.[@name='int']\",\n                 new Integer(1),\n                 \"/int\",\n+                \"Bb\",\n                 \"BbB\");\n \n         // dynamicProperty[@name=existingProperty]\n-        testValueAndPointer(\"/map[@name='Key1']\",\n+        assertValueAndPointer(\"/map[@name='Key1']\",\n                 \"Value 1\",\n                 \"/map[@name='Key1']\",\n+                \"BbDd\",\n                 \"BbDdB\");\n \n         // existingProperty[@name=collectionProperty]\n-        testValueAndPointer(\"/nestedBean[@name='strings']\",\n+        assertValueAndPointer(\"/nestedBean[@name='strings']\",\n                 bean.getNestedBean().getStrings(),\n                 \"/nestedBean/strings\",\n+                \"BbBb\",\n                 \"BbBbC\");\n \n         // existingProperty[@name=missingProperty]\n-        testNullPointer(\"/nestedBean[@name='foo']\",\n+        assertNullPointer(\"/nestedBean[@name='foo']\",\n                 \"/nestedBean[@name='foo']\",\n-                \"BbBnN\");\n+                \"BbBn\");\n \n         // map[@name=collectionProperty]\n-        testValueAndPointer(\"/map[@name='Key3']\",\n+        assertValueAndPointer(\"/map[@name='Key3']\",\n                 bean.getMap().get(\"Key3\"),\n                 \"/map[@name='Key3']\",\n+                \"BbDd\",\n                 \"BbDdC\");\n-\n+                \n         // map[@name=missingProperty]\n-        testNullPointer(\"/map[@name='foo']\",\n+        assertNullPointer(\"/map[@name='foo']\",\n                 \"/map[@name='foo']\",\n-                \"BbDdN\");\n+                \"BbDd\");\n \n         // collectionProperty[@name=...] (find node)\n-        testValueAndPointer(\"/list[@name='fruitco']\",\n+        assertValueAndPointer(\"/list[@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/list[5]\",\n                 \"BbCM\");\n \n         // collectionProperty[@name=...] (find map entry)\n-        testValueAndPointer(\"/map/Key3[@name='key']/name\",\n+        assertValueAndPointer(\"/map/Key3[@name='key']/name\",\n                 \"Name 9\",\n                 \"/map[@name='Key3'][4][@name='key']/name\",\n+                \"BbDdCDdBb\",\n                 \"BbDdCDdBbB\");\n \n         // map/collectionProperty[@name...]\n-        testValueAndPointer(\"map/Key3[@name='fruitco']\",\n+        assertValueAndPointer(\"map/Key3[@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/map[@name='Key3'][3]\",\n                 \"BbDdCM\");\n \n         // Bean property -> DOM Node, name match\n-        testValueAndPointer(\"/vendor[@name='fruitco']\",\n+        assertValueAndPointer(\"/vendor[@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/vendor\",\n                 \"BbM\");\n \n         // Bean property -> DOM Node, name mismatch\n-        testNullPointer(\"/vendor[@name='foo']\",\n+        assertNullPointer(\"/vendor[@name='foo']\",\n                 \"/vendor[@name='foo']\",\n-                \"BbMnN\");\n-\n-        testNullPointer(\"/vendor[@name='foo'][3]\",\n+                \"BbMn\");\n+\n+        assertNullPointer(\"/vendor[@name='foo'][3]\",\n                 \"/vendor[@name='foo'][3]\",\n-                \"BbMnN\");\n+                \"BbMn\");\n \n         // existingProperty(bean)[@name=missingProperty]/anotherStep\n-        testNullPointer(\"/nestedBean[@name='foo']/bar\",\n+        assertNullPointer(\"/nestedBean[@name='foo']/bar\",\n                 \"/nestedBean[@name='foo']/bar\",\n-                \"BbBnNnN\");\n+                \"BbBnNn\");\n \n         // map[@name=missingProperty]/anotherStep\n-        testNullPointer(\"/map[@name='foo']/bar\",\n+        assertNullPointer(\"/map[@name='foo']/bar\",\n                 \"/map[@name='foo']/bar\",\n-                \"BbDdNnN\");\n+                \"BbDdNn\");\n \n         // existingProperty(node)[@name=missingProperty]/anotherStep\n-        testNullPointer(\"/vendor[@name='foo']/bar\",\n+        assertNullPointer(\"/vendor[@name='foo']/bar\",\n                 \"/vendor[@name='foo']/bar\",\n-                \"BbMnNnN\");\n+                \"BbMnNn\");\n \n         // existingProperty(node)[@name=missingProperty][index]/anotherStep\n-        testNullPointer(\"/vendor[@name='foo'][3]/bar\",\n+        assertNullPointer(\"/vendor[@name='foo'][3]/bar\",\n                 \"/vendor[@name='foo'][3]/bar\",\n-                \"BbMnNnN\");\n+                \"BbMnNn\");\n \n         // Existing dynamic property + existing property\n-        testValueAndPointer(\"/map[@name='Key2'][@name='name']\",\n+        assertValueAndPointer(\"/map[@name='Key2'][@name='name']\",\n                 \"Name 6\",\n                 \"/map[@name='Key2']/name\",\n+                \"BbDdBb\",\n                 \"BbDdBbB\");\n \n         // Existing dynamic property + existing property + index\n-        testValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n+        assertValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n                 \"String 2\",\n                 \"/map[@name='Key2']/strings[2]\",\n+                \"BbDdBb\",\n                 \"BbDdBbB\");\n \n         // bean/map/map/property\n-        testValueAndPointer(\"map[@name='Key5'][@name='key']/name\",\n+        assertValueAndPointer(\"map[@name='Key5'][@name='key']/name\",\n                 \"Name 9\",\n                 \"/map[@name='Key5'][@name='key']/name\",\n+                \"BbDdDdBb\",\n                 \"BbDdDdBbB\");\n \n-        testNullPointer(\"map[@name='Key2'][@name='foo']\",\n+        assertNullPointer(\"map[@name='Key2'][@name='foo']\",\n                 \"/map[@name='Key2'][@name='foo']\",\n-                \"BbDdBnN\");\n-\n-        testNullPointer(\"map[@name='Key2'][@name='foo'][@name='bar']\",\n+                \"BbDdBn\");\n+\n+        assertNullPointer(\"map[@name='Key2'][@name='foo'][@name='bar']\",\n                 \"/map[@name='Key2'][@name='foo'][@name='bar']\",\n-                \"BbDdBnNnN\");\n+                \"BbDdBnNn\");\n \n         // bean/map/node\n-        testValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n+        assertValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/map[@name='Key4']\",\n                 \"BbDdM\");\n \n     public void test_doPredicates_standard(){\n         // bean/map/collection/node\n-        testValueAndPointer(\"map[@name='Key3'][@name='fruitco']\",\n+        assertValueAndPointer(\"map[@name='Key3'][@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/map[@name='Key3'][3]\",\n                 \"BbDdCM\");\n \n         // bean/map/collection/missingNode\n-        testNullPointer(\"map[@name='Key3'][@name='foo']\",\n+        assertNullPointer(\"map[@name='Key3'][@name='foo']\",\n                 \"/map[@name='Key3'][4][@name='foo']\",\n-                \"BbDdCDdN\");\n+                \"BbDdCDd\");\n \n         // bean/map/node\n-        testValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n+        assertValueAndPointer(\"map[@name='Key4'][@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"/map[@name='Key4']\",\n                 \"BbDdM\");\n \n         // bean/map/emptyCollection[@name=foo]\n-        testNullPointer(\"map[@name='Key6'][@name='fruitco']\",\n+        assertNullPointer(\"map[@name='Key6'][@name='fruitco']\",\n                 \"/map[@name='Key6'][@name='fruitco']\",\n-                \"BbDdCnN\");\n+                \"BbDdCn\");\n \n         // bean/node[@name=foo][index]\n-        testValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n+        assertValueAndPointer(\"/vendor/contact[@name='jack'][2]\",\n                 \"Jack Black\",\n                 \"/vendor/contact[4]\",\n                 \"BbMM\");\n \n         // bean/node[@name=foo][missingIndex]\n-        testNullPointer(\"/vendor/contact[@name='jack'][5]\",\n+        assertNullPointer(\"/vendor/contact[@name='jack'][5]\",\n                 \"/vendor/contact[@name='jack'][5]\",\n-                \"BbMnNnN\");\n+                \"BbMnNn\");\n \n         // bean/node/.[@name=foo][index]\n-        testValueAndPointer(\"/vendor/contact/.[@name='jack']\",\n+        assertValueAndPointer(\"/vendor/contact/.[@name='jack']\",\n                 \"Jack\",\n                 \"/vendor/contact[2]\",\n                 \"BbMM\");\n \n     public void test_doPredicate_index(){\n         // Existing dynamic property + existing property + index\n-        testValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n+        assertValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n                 \"String 2\",\n                 \"/map[@name='Key2']/strings[2]\",\n+                \"BbDdBb\",\n                 \"BbDdBbB\");\n \n         // existingProperty[@name=collectionProperty][index]\n-        testValueAndPointer(\"/nestedBean[@name='strings'][2]\",\n+        assertValueAndPointer(\"/nestedBean[@name='strings'][2]\",\n                 bean.getNestedBean().getStrings()[1],\n                 \"/nestedBean/strings[2]\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // existingProperty[@name=missingProperty][index]\n-        testNullPointer(\"/nestedBean[@name='foo'][3]\",\n+        assertNullPointer(\"/nestedBean[@name='foo'][3]\",\n                 \"/nestedBean[@name='foo'][3]\",\n-                \"BbBnN\");\n+                \"BbBn\");\n \n         // existingProperty[@name=collectionProperty][missingIndex]\n-        testNullPointer(\"/nestedBean[@name='strings'][5]\",\n+        assertNullPointer(\"/nestedBean[@name='strings'][5]\",\n                 \"/nestedBean/strings[5]\",\n-                \"BbBbEN\");\n+                \"BbBbE\");\n \n         // map[@name=collectionProperty][index]\n-        testValueAndPointer(\"/map[@name='Key3'][2]\",\n+        assertValueAndPointer(\"/map[@name='Key3'][2]\",\n                 new Integer(2),\n                 \"/map[@name='Key3'][2]\",\n+                \"BbDd\",\n                 \"BbDdB\");\n \n         // map[@name=collectionProperty][missingIndex]\n-        testNullPointer(\"/map[@name='Key3'][5]\",\n+        assertNullPointer(\"/map[@name='Key3'][5]\",\n                 \"/map[@name='Key3'][5]\",\n-                \"BbDdEN\");\n+                \"BbDdE\");\n \n         // map[@name=collectionProperty][missingIndex]/property\n-        testNullPointer(\"/map[@name='Key3'][5]/foo\",\n+        assertNullPointer(\"/map[@name='Key3'][5]/foo\",\n                 \"/map[@name='Key3'][5]/foo\",\n-                \"BbDdENnN\");\n+                \"BbDdENn\");\n \n         // map[@name=map][@name=collection][index]\n-        testValueAndPointer(\"/map[@name='Key5'][@name='strings'][2]\",\n+        assertValueAndPointer(\"/map[@name='Key5'][@name='strings'][2]\",\n                 \"String 2\",\n                 \"/map[@name='Key5'][@name='strings'][2]\",\n+                \"BbDdDd\",\n                 \"BbDdDdB\");\n \n         // map[@name=map][@name=collection][missingIndex]\n-        testNullPointer(\"/map[@name='Key5'][@name='strings'][5]\",\n+        assertNullPointer(\"/map[@name='Key5'][@name='strings'][5]\",\n                 \"/map[@name='Key5'][@name='strings'][5]\",\n-                \"BbDdDdEN\");\n+                \"BbDdDdE\");\n \n         // Existing dynamic property + indexing\n-        testValueAndPointer(\"/map[@name='Key3'][2]\",\n+        assertValueAndPointer(\"/map[@name='Key3'][2]\",\n                 new Integer(2),\n                 \"/map[@name='Key3'][2]\",\n+                \"BbDd\",\n                 \"BbDdB\");\n \n         // Existing dynamic property + indexing\n-        testValueAndPointer(\"/map[@name='Key3'][1]/name\",\n+        assertValueAndPointer(\"/map[@name='Key3'][1]/name\",\n                 \"some\",\n                 \"/map[@name='Key3'][1]/name\",\n+                \"BbDdBb\",\n                 \"BbDdBbB\");\n \n         // map[@name=missingProperty][index]\n-        testNullPointer(\"/map[@name='foo'][3]\",\n+        assertNullPointer(\"/map[@name='foo'][3]\",\n                 \"/map[@name='foo'][3]\",\n-                \"BbDdEN\");\n+                \"BbDdE\");\n \n         // collectionProperty[index]\n-        testValueAndPointer(\"/integers[2]\",\n+        assertValueAndPointer(\"/integers[2]\",\n                 new Integer(2),\n                 \"/integers[2]\",\n+                \"Bb\",\n                 \"BbB\");\n \n         // existingProperty/collectionProperty[index]\n-        testValueAndPointer(\"/nestedBean/strings[2]\",\n+        assertValueAndPointer(\"/nestedBean/strings[2]\",\n                 bean.getNestedBean().getStrings()[1],\n                 \"/nestedBean/strings[2]\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // existingProperty[index]/existingProperty\n-        testValueAndPointer(\"/list[3]/int\",\n+        assertValueAndPointer(\"/list[3]/int\",\n                 new Integer(1),\n                 \"/list[3]/int\",\n+                \"BbBb\",\n                 \"BbBbB\");\n \n         // existingProperty[missingIndex]\n-        testNullPointer(\"/list[6]\",\n+        assertNullPointer(\"/list[6]\",\n                 \"/list[6]\",\n-                \"BbEN\");\n+                \"BbE\");\n \n         // existingProperty/missingProperty[index]\n-        testNullPointer(\"/nestedBean/foo[3]\",\n+        assertNullPointer(\"/nestedBean/foo[3]\",\n                 \"/nestedBean/foo[3]\",\n-                \"BbBnN\");\n+                \"BbBn\");\n \n         // map[@name=missingProperty][index]\n-        testNullPointer(\"/map/foo[3]\",\n+        assertNullPointer(\"/map/foo[3]\",\n                 \"/map[@name='foo'][3]\",\n-                \"BbDdEN\");\n+                \"BbDdE\");\n \n         // existingProperty/collectionProperty[missingIndex]\n-        testNullPointer(\"/nestedBean/strings[5]\",\n+        assertNullPointer(\"/nestedBean/strings[5]\",\n                 \"/nestedBean/strings[5]\",\n-                \"BbBbEN\");\n+                \"BbBbE\");\n \n         // map/collectionProperty[missingIndex]/property\n-        testNullPointer(\"/map/Key3[5]/foo\",\n+        assertNullPointer(\"/map/Key3[5]/foo\",\n                 \"/map[@name='Key3'][5]/foo\",\n-                \"BbDdENnN\");\n+                \"BbDdENn\");\n \n         // map[@name=map]/collection[index]\n-        testValueAndPointer(\"/map[@name='Key5']/strings[2]\",\n+        assertValueAndPointer(\"/map[@name='Key5']/strings[2]\",\n                 \"String 2\",\n                 \"/map[@name='Key5'][@name='strings'][2]\",\n+                \"BbDdDd\",\n                 \"BbDdDdB\");\n \n         // map[@name=map]/collection[missingIndex]\n-        testNullPointer(\"/map[@name='Key5']/strings[5]\",\n+        assertNullPointer(\"/map[@name='Key5']/strings[5]\",\n                 \"/map[@name='Key5'][@name='strings'][5]\",\n-                \"BbDdDdEN\");\n+                \"BbDdDdE\");\n \n         // scalarPropertyAsCollection[index]\n-        testValueAndPointer(\"/int[1]\",\n+        assertValueAndPointer(\"/int[1]\",\n                 new Integer(1),\n                 \"/int\",\n+                \"Bb\",\n                 \"BbB\");\n \n         // scalarPropertyAsCollection[index]\n-        testValueAndPointer(\".[1]/int\",\n+        assertValueAndPointer(\".[1]/int\",\n                 new Integer(1),\n                 \"/int\",\n+                \"Bb\",\n                 \"BbB\");\n     }\n \n         context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n         context.getVariables().declareVariable(\"testnull\", new TestNull());\n \n-        testNullPointer(\"$testnull/nothing[2]\",\n+        assertNullPointer(\"$testnull/nothing[2]\",\n                 \"$testnull/nothing[2]\",\n-                \"VBbEN\");\n-    }\n-\n-    private void testValueAndPointer(\n+                \"VBbE\");\n+    }\n+\n+    private void assertValueAndPointer(\n             String path, Object expectedValue, String expectedPath,\n             String expectedSignature)\n     {\n+        assertValueAndPointer(\n+            path,\n+            expectedValue,\n+            expectedPath,\n+            expectedSignature,\n+            expectedSignature);\n+    }\n+    \n+    private void assertValueAndPointer(\n+            String path, Object expectedValue, String expectedPath,\n+            String expectedSignature, String expectedValueSignature)\n+    {\n         Object value = context.getValue(path);\n         assertEquals(\"Checking value: \" + path, expectedValue, value);\n \n \n         assertEquals(\"Checking signature: \" + path,\n                 expectedSignature, pointerSignature(pointer));\n-    }\n-\n-\n-    private void testNullPointer(String path, String expectedPath,\n+        \n+        Pointer vPointer = ((NodePointer)pointer).getValuePointer();\n+        assertEquals(\"Checking value pointer signature: \" + path,\n+                expectedValueSignature, pointerSignature(vPointer));\n+    }\n+\n+    private void assertNullPointer(String path, String expectedPath,\n             String expectedSignature)\n     {\n         Pointer pointer = context.getPointer(path);\n         assertNotNull(\"Null path exists: \" + path,\n                     pointer);\n-        assertTrue(\"Null path is null: \" + path,\n-                    !((NodePointer)pointer).isActual());\n         assertEquals(\"Null path as path: \" + path,\n                     expectedPath, pointer.asPath());\n         assertEquals(\"Checking Signature: \" + path,\n-                expectedSignature, pointerSignature(pointer));\n+                    expectedSignature, pointerSignature(pointer));\n+                \n+        Pointer vPointer = ((NodePointer)pointer).getValuePointer();\n+        assertTrue(\"Null path is null: \" + path,\n+                    !((NodePointer)vPointer).isActual());\n+        assertEquals(\"Checking value pointer signature: \" + path,\n+                    expectedSignature + \"N\", pointerSignature(vPointer));\n     }\n \n     /**\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test basic functionality of JXPath - core functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public class CoreFunctionTest extends JXPathTestCase\n     public void testIDFunction(){\n         context.setIdentityManager(new IdentityManager(){\n             public Pointer getPointerByID(JXPathContext context, String id){\n-                NodePointer ptr = (NodePointer)context.getPointer(\"/document\");\n+                NodePointer ptr = (NodePointer)context.\n+                        getPointer(\"/document\");\n+                ptr = ptr.getValuePointer();\n                 return ptr.getPointerByID(context, id);\n             }\n         });\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import java.util.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestFunctions2 {\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-\n-import junit.framework.TestSuite;\n-\n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathTestCase;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.Pointer;\n+import java.util.*;\n+\n+import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public abstract class BeanModelTestCase extends JXPathTestCase\n {\n-    private static boolean enabled = true;\n     private JXPathContext context;\n \n     /**\n      * Test property iterators, the core of the graph traversal engine\n      */\n     public void testIndividualIterators(){\n-        if (!enabled){\n-            return;\n-        }\n-//        testIndividual(0, 0, true, false, 3);\n         testIndividual(+1, 0, true, false, 0);\n         testIndividual(-1, 0, true, false, 4);\n \n     private void testIndividual(int relativePropertyIndex, int offset,\n                 boolean useStartLocation, boolean reverse, int expected)\n     {\n-        PropertyOwnerPointer root =\n-            (PropertyOwnerPointer)NodePointer.newNodePointer(\n-                    new QName(null, \"root\"), createContextBean(),\n-                    Locale.getDefault());\n-\n-        NodeIterator it;\n-\n-        PropertyPointer start = null;\n-\n-        if (useStartLocation){\n-            start = root.getPropertyPointer();\n-            start.setPropertyIndex(relativeProperty(start, relativePropertyIndex));\n-            start.setIndex(offset);\n-        }\n-        it = root.childIterator(\n-                new NodeNameTest(new QName(null, \"integers\")),\n-                reverse, start);\n-\n-        int size = 0;\n-        while(it.setPosition(it.getPosition() + 1)){\n-            size++;\n-        }\n-        assertEquals(\"ITERATIONS: Individual, relativePropertyIndex=\" +\n-            relativePropertyIndex +\n-            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n-            \", reverse=\" + reverse, expected, size);\n+\t\tPropertyOwnerPointer root =\n+\t\t\t(PropertyOwnerPointer) NodePointer.newNodePointer(\n+\t\t\t\tnew QName(null, \"root\"),\n+\t\t\t\tcreateContextBean(),\n+\t\t\t\tLocale.getDefault());\n+\n+\t\tNodeIterator it;\n+\n+\t\tPropertyPointer start = null;\n+\n+\t\tif (useStartLocation) {\n+\t\t\tstart = root.getPropertyPointer();\n+\t\t\tstart.setPropertyIndex(\n+\t\t\t\trelativeProperty(start, relativePropertyIndex));\n+\t\t\tstart.setIndex(offset);\n+\t\t}\n+\t\tit =\n+\t\t\troot.childIterator(\n+\t\t\t\tnew NodeNameTest(new QName(null, \"integers\")),\n+\t\t\t\treverse,\n+\t\t\t\tstart);\n+\n+\t\tint size = 0;\n+\t\twhile (it.setPosition(it.getPosition() + 1)) {\n+\t\t\tsize++;\n+\t\t}\n+\t\tassertEquals(\n+\t\t\t\"ITERATIONS: Individual, relativePropertyIndex=\"\n+\t\t\t\t+ relativePropertyIndex\n+\t\t\t\t+ \", offset=\"\n+\t\t\t\t+ offset\n+\t\t\t\t+ \", useStartLocation=\"\n+\t\t\t\t+ useStartLocation\n+\t\t\t\t+ \", reverse=\"\n+\t\t\t\t+ reverse,\n+\t\t\texpected,\n+\t\t\tsize);\n     }\n \n     /**\n      * Test property iterators with multiple properties returned\n      */\n     public void testMultipleIterators(){\n-        if (!enabled){\n-            return;\n-        }\n         testMultiple(0, 0, true, false, 20);\n \n         testMultiple(3, 0, true, false, 16);\n     }\n \n     public void testIteratePropertyArrayWithHasNext(){\n-        if (!enabled){\n-            return;\n-        }\n-        JXPathContext context = JXPathContext.newContext(createContextBean());\n-        Iterator it = context.iteratePointers(\"/integers\");\n-        List actual = new ArrayList();\n-        while(it.hasNext()){\n-            actual.add(((Pointer)it.next()).asPath());\n-        }\n-        assertEquals(\"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n-            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n-            actual);\n-    }\n-\n-    public void testIteratePropertyArrayWithoutHasNext(){\n-        if (!enabled){\n-            return;\n-        }\n-        JXPathContext context = JXPathContext.newContext(createContextBean());\n-        Iterator it = context.iteratePointers(\"/integers\");\n-        List actual = new ArrayList();\n-        for (int i = 0; i < 4; i++){\n-            actual.add(it.next().toString());\n-        }\n-        assertEquals(\"Iterating 'next'<\" + \"/integers\" + \">\",\n-            list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\"),\n-            actual);\n-    }\n+\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n+\t\tIterator it = context.iteratePointers(\"/integers\");\n+\t\tList actual = new ArrayList();\n+\t\twhile (it.hasNext()) {\n+\t\t\tactual.add(((Pointer) it.next()).asPath());\n+\t\t}\n+\t\tassertEquals(\n+\t\t\t\"Iterating 'hasNext'/'next'<\" + \"/integers\" + \">\",\n+\t\t\tlist(\n+\t\t\t\t\"/integers[1]\",\n+\t\t\t\t\"/integers[2]\",\n+\t\t\t\t\"/integers[3]\",\n+\t\t\t\t\"/integers[4]\"),\n+\t\t\tactual);\n+    }\n+\n+\tpublic void testIteratePropertyArrayWithoutHasNext() {\n+\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n+\t\tIterator it = context.iteratePointers(\"/integers\");\n+\t\tList actual = new ArrayList();\n+\t\tfor (int i = 0; i < 4; i++) {\n+\t\t\tactual.add(it.next().toString());\n+\t\t}\n+\t\tassertEquals(\n+\t\t\t\"Iterating 'next'<\" + \"/integers\" + \">\",\n+\t\t\tlist(\n+\t\t\t\t\"/integers[1]\",\n+\t\t\t\t\"/integers[2]\",\n+\t\t\t\t\"/integers[3]\",\n+\t\t\t\t\"/integers[4]\"),\n+\t\t\tactual);\n+\t}\n \n     public void testIterateAndSet(){\n-        if (!enabled){\n-            return;\n-        }\n-\n         JXPathContext context = JXPathContext.newContext(createContextBean());\n \n         Iterator it = context.iteratePointers(\"beans/int\");\n     /**\n      * Test contributed by Kate Dvortsova\n      */\n-    public void testIteratePointerSetValue() {\n-        JXPathContext context = JXPathContext.newContext(createContextBean());\n-\n-        assertXPathValue(context, \"/beans[1]/name\", \"Name 1\");\n-        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n-\n-        // Test setting via context\n-        context.setValue(\"/beans[2]/name\", \"Name 2 set\");\n-        assertXPathValue(context, \"/beans[2]/name\", \"Name 2 set\");\n-\n-        // Restore original value\n-        context.setValue(\"/beans[2]/name\", \"Name 2\");\n-        assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n-\n-        int iter_count = 0;\n-        Iterator iter = context.iteratePointers(\"/beans/name\");\n-        while (iter.hasNext()) {\n-            iter_count++;\n-            Pointer pointer = (Pointer) iter.next();\n-            String s = (String) pointer.getValue();\n-            s = s + \"suffix\";\n-            pointer.setValue(s);\n-            assertEquals(\"pointer.getValue\", s, pointer.getValue());\n-            // fails right here, the value isn't getting set in the bean.\n-            assertEquals(\"context.getValue\", s, context.getValue(pointer.asPath()));\n-        }\n-        assertEquals(\"Iteration count\", 2, iter_count);\n-\n-        assertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n-        assertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n-    }\n+\tpublic void testIteratePointerSetValue() {\n+\t\tJXPathContext context = JXPathContext.newContext(createContextBean());\n+\n+\t\tassertXPathValue(context, \"/beans[1]/name\", \"Name 1\");\n+\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+\t\t// Test setting via context\n+\t\tcontext.setValue(\"/beans[2]/name\", \"Name 2 set\");\n+\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2 set\");\n+\n+\t\t// Restore original value\n+\t\tcontext.setValue(\"/beans[2]/name\", \"Name 2\");\n+\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n+\n+\t\tint iter_count = 0;\n+\t\tIterator iter = context.iteratePointers(\"/beans/name\");\n+\t\twhile (iter.hasNext()) {\n+\t\t\titer_count++;\n+\t\t\tPointer pointer = (Pointer) iter.next();\n+\t\t\tString s = (String) pointer.getValue();\n+\t\t\ts = s + \"suffix\";\n+\t\t\tpointer.setValue(s);\n+\t\t\tassertEquals(\"pointer.getValue\", s, pointer.getValue());\n+\t\t\t// fails right here, the value isn't getting set in the bean.\n+\t\t\tassertEquals(\n+\t\t\t\t\"context.getValue\",\n+\t\t\t\ts,\n+\t\t\t\tcontext.getValue(pointer.asPath()));\n+\t\t}\n+\t\tassertEquals(\"Iteration count\", 2, iter_count);\n+\n+\t\tassertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n+\t\tassertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n+\t}\n \n     public void testRoot(){\n         assertXPathValueAndPointer(context,\n                 \"/nestedBean/int\");\n     }\n \n-    public void testAttributeLang(){\n-\n-        assertXPathValue(context,\n-                \"@xml:lang\",\n-                \"en-US\");\n-\n-        assertXPathValue(context,\n-                \"count(@xml:*)\",\n-                new Double(1));\n-\n-        assertXPathValue(context,\"lang('en')\", Boolean.TRUE);\n-        assertXPathValue(context,\"lang('fr')\", Boolean.FALSE);\n-        assertXPathValueIterator(context, \"beans[1]/strings[string-length() = 8]\", list(\"String 1\", \"String 2\", \"String 3\"));\n-        assertXPathValue(context,\"boolean(boolean)\", Boolean.FALSE);\n-        assertXPathValue(context,\"boolean(integers[position() < 3])\", Boolean.TRUE);\n-        assertXPathValue(context,\"boolean(integers[position() > 4])\", Boolean.FALSE);\n-        assertXPathValue(context,\"sum(integers)\", new Double(10));\n-    }\n+\tpublic void testAttributeLang() {\n+\n+\t\tassertXPathValue(context, \n+            \"@xml:lang\", \n+            \"en-US\");\n+\n+\t\tassertXPathValue(context, \n+            \"count(@xml:*)\", \n+            new Double(1));\n+\n+\t\tassertXPathValue(context, \n+            \"lang('en')\", \n+            Boolean.TRUE);\n+            \n+\t\tassertXPathValue(context, \n+            \"lang('fr')\", \n+            Boolean.FALSE);\n+            \n+\t\tassertXPathValueIterator(\n+\t\t\tcontext,\n+\t\t\t\"beans[1]/strings[string-length() = 8]\",\n+\t\t\tlist(\"String 1\", \"String 2\", \"String 3\"));\n+            \n+\t\tassertXPathValue(context, \n+            \"boolean(boolean)\", \n+            Boolean.FALSE);\n+            \n+\t\tassertXPathValue(\n+\t\t\tcontext,\n+\t\t\t\"boolean(integers[position() < 3])\",\n+\t\t\tBoolean.TRUE);\n+            \n+\t\tassertXPathValue(\n+\t\t\tcontext,\n+\t\t\t\"boolean(integers[position() > 4])\",\n+\t\t\tBoolean.FALSE);\n+            \n+\t\tassertXPathValue(context, \n+            \"sum(integers)\", \n+            new Double(10));\n+\t}\n \n     public void testBooleanPredicate(){\n         // use child axis\n--- a/src/test/org/apache/commons/jxpath/ri/model/TestDynamicPropertyFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestDynamicPropertyFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/Attic/TestDynamicPropertyFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/Attic/TestDynamicPropertyFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model;\n \n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n import java.util.Vector;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.TestBean;\n-import org.jdom.Element;\n-import org.w3c.dom.Node;\n+import org.apache.commons.jxpath.*;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestDynamicPropertyFactory extends AbstractFactory {\n \n      * Create a new instance and put it in the collection on the parent object.\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n-        if (name.equals(\"map\")){\n-            ((TestBean)parent).setMap(new HashMap());\n-            return true;\n-        }\n-        else if (name.equals(\"TestKey1\")){\n-            ((Map)parent).put(name, \"\");\n-            return true;\n-        }\n-        else if (name.equals(\"TestKey2\")){\n-            ((Map)parent).put(name, new NestedTestBean(\"newName\"));\n-            return true;\n-        }\n-        else if (name.equals(\"TestKey3\")){\n-            Vector v = new Vector();\n-            for (int i = 0; i <= index; i++){\n-                v.add(null);\n-            }\n-            ((Map)parent).put(name, v);\n-            return true;\n-        }\n-        else if (name.equals(\"TestKey4\")){\n-            ((Map)parent).put(name, new Object[]{new TestBean()});\n-            return true;\n-        }\n-        return false;\n-    }\n+\tpublic boolean createObject(\n+    \t\tJXPathContext context,\n+    \t\tPointer pointer,\n+    \t\tObject parent,\n+    \t\tString name,\n+    \t\tint index) \n+    {\n+\t\tif (name.equals(\"map\")) {\n+\t\t\t((TestBean) parent).setMap(new HashMap());\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"TestKey1\")) {\n+\t\t\t((Map) parent).put(name, \"\");\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"TestKey2\")) {\n+\t\t\t((Map) parent).put(name, new NestedTestBean(\"newName\"));\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"TestKey3\")) {\n+\t\t\tVector v = new Vector();\n+\t\t\tfor (int i = 0; i <= index; i++) {\n+\t\t\t\tv.add(null);\n+\t\t\t}\n+\t\t\t((Map) parent).put(name, v);\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"TestKey4\")) {\n+\t\t\t((Map) parent).put(name, new Object[] { new TestBean()});\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n     public boolean declareVariable(JXPathContext context, String name){\n         return false;\n--- a/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model;\n \n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Vector;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.TestBean;\n-import org.jdom.Element;\n-import org.w3c.dom.Node;\n+import org.apache.commons.jxpath.*;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestMixedModelFactory extends AbstractFactory {\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.2 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.3 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.3 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public abstract class XMLModelTestCase extends JXPathTestCase\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"document\", docCtr.getValue());\n             vars.declareVariable(\"container\", docCtr);\n+            vars.declareVariable(\"element\", \n+            context.getPointer(\"vendor/location/address/street\").getNode());\n         }\n     }\n \n         assertXPathValue(context,\n                 \"$document/vendor//street\",\n                 \"Orchard Road\");\n-\n     }\n \n     public void testContainer() {\n                 \"number(vendor/location/employeeCount)\",\n                 new Double(10));\n     }\n+    \n+    public void testElementInVariable() {\n+        assertXPathValue(context,\n+                \"$element\",\n+                \"Orchard Road\");                \n+    }\n \n     public void testTypeConversions() {\n         // Implicit conversion to number\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.beans;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.w3c.dom.*;\n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n-import java.beans.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.ri.model.BeanModelTestCase;\n \n /**\n  * Tests JXPath with JavaBeans\n *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public class BeanModelTest extends BeanModelTestCase\n {\n-    private static final boolean enabled = true;\n-\n     /**\n      * Construct a new instance of this test case.\n      *\n      * Return the tests included in this test suite.\n      */\n     public static TestSuite suite(){\n-//        return (new TestSuite(BeanModelTest.class));\n-        TestSuite s = new TestSuite();\n-        s.addTest(new BeanModelTest(\"testAxisParent\"));\n-        return s;\n+        return (new TestSuite(BeanModelTest.class));\n     }\n \n     protected Object createContextBean(){\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/DynamicPropertiesModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/DynamicPropertiesModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertiesModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertiesModelTest.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.beans;\n \n-import java.lang.reflect.InvocationTargetException;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-import org.w3c.dom.*;\n-import java.util.*;\n-import java.lang.reflect.*;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n-import java.beans.*;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.ri.model.TestDynamicPropertyFactory;\n \n /**\n  * @todo more iterator testing with maps\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public class DynamicPropertiesModelTest extends JXPathTestCase\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.beans;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Vector;\n-\n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.TestBean;\n-import org.jdom.Element;\n-import org.w3c.dom.Node;\n+import org.apache.commons.jxpath.*;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestBeanFactory extends AbstractFactory {\n \n     public boolean createObject(JXPathContext context, \n                 Pointer pointer, Object parent, String name, int index)\n     {\n-        if (name.equals(\"nestedBean\")){\n-            ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n-            return true;\n-        }\n-        else if (name.equals(\"beans\")){\n-            TestBean bean = (TestBean)parent;\n-            if (bean.getBeans() == null || index >= bean.getBeans().length){\n-                bean.setBeans(new NestedTestBean[index + 1]);\n-            }\n-            ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n-            return true;\n-        }\n-        return false;\n-    }\n+\t\tif (name.equals(\"nestedBean\")) {\n+\t\t\t((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"beans\")) {\n+\t\t\tTestBean bean = (TestBean) parent;\n+\t\t\tif (bean.getBeans() == null || index >= bean.getBeans().length) {\n+\t\t\t\tbean.setBeans(new NestedTestBean[index + 1]);\n+\t\t\t}\n+\t\t\t((TestBean) parent).getBeans()[index] =\n+\t\t\t\tnew NestedTestBean(\"newName\");\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;   }\n \n     /**\n      * Create a new object and set it on the specified variable\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.3 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.4 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.xml.DocumentContainer;\n-\n-import org.w3c.dom.*;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n \n /**\n  * Tests JXPath with DOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public class DOMModelTest extends XMLModelTestCase\n     public DOMModelTest(String name){\n         super(name);\n     }\n-\n+    \n     /**\n      * Return the tests included in this test suite.\n      */\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.dynabeans;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Vector;\n-\n import org.apache.commons.beanutils.DynaBean;\n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.*;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n  */\n public class TestDynaBeanFactory extends AbstractFactory {\n \n     /**\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n-        if (name.equals(\"nestedBean\")){\n-            ((DynaBean)parent).set(\"nestedBean\", new NestedTestBean(\"newName\"));\n-            return true;\n-        }\n-        else if (name.equals(\"beans\")){\n-            DynaBean bean = (DynaBean)parent;\n-            Object beans[] = (Object[])bean.get(\"beans\");\n-            if (beans == null || index >= beans.length){\n-                beans = new NestedTestBean[index + 1];\n-                bean.set(\"beans\", beans);\n-            }\n-            beans[index] = new NestedTestBean(\"newName\");\n-            return true;\n-        }\n-        return false;\n-    }\n+\tpublic boolean createObject(\n+    \t\tJXPathContext context,\n+    \t\tPointer pointer,\n+    \t\tObject parent,\n+    \t\tString name,\n+    \t\tint index) \n+    {\n+\t\tif (name.equals(\"nestedBean\")) {\n+\t\t\t((DynaBean) parent).set(\n+\t\t\t\t\"nestedBean\",\n+\t\t\t\tnew NestedTestBean(\"newName\"));\n+\t\t\treturn true;\n+\t\t} else if (name.equals(\"beans\")) {\n+\t\t\tDynaBean bean = (DynaBean) parent;\n+\t\t\tObject beans[] = (Object[]) bean.get(\"beans\");\n+\t\t\tif (beans == null || index >= beans.length) {\n+\t\t\t\tbeans = new NestedTestBean[index + 1];\n+\t\t\t\tbean.set(\"beans\", beans);\n+\t\t\t}\n+\t\t\tbeans[index] = new NestedTestBean(\"newName\");\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n \n \n     /**\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.3 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.4 2002/11/26 01:20:08 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/11/26 01:20:08 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n \n import junit.framework.Test;\n-import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import java.util.*;\n-import java.lang.reflect.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.util.*;\n-import org.apache.commons.jxpath.ri.*;\n-import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.compiler.Expression;\n-import org.apache.commons.jxpath.xml.*;\n+import org.apache.commons.jxpath.xml.DocumentContainer;\n import org.jdom.*;\n-\n-import java.beans.*;\n \n /**\n  * Tests JXPath with JDOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:08 $\n  */\n \n public class JDOMModelTest extends XMLModelTestCase", "timestamp": 1038273608, "metainfo": ""}