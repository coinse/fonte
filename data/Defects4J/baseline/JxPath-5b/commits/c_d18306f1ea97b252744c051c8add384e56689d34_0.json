{"sha": "d18306f1ea97b252744c051c8add384e56689d34", "log": "Bug fix: /person[address/state = 'NY'] is supposed to return persons that have at least one address with at least one state = 'NY'. The \"equal()\" operation was supposed to search for a match, while it was merely comparing the first node to the supplied value.   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.6 2002/08/26 22:19:51 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/08/26 22:19:51 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n+import org.apache.commons.jxpath.ri.axes.SelfContext;\n import org.apache.commons.jxpath.ri.axes.UnionContext;\n \n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Set;\n import java.util.HashSet;\n \n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.6 $ $Date: 2002/08/26 22:19:51 $\n  */\n public class CoreOperation extends Operation {\n     public CoreOperation(int code, Expression args[]){\n      * Compares two values\n      */\n     protected boolean equal(EvalContext context, Expression left, Expression right){\n-        Object l = left.computeValue(context);\n-        Object r = right.computeValue(context);\n-        boolean result;\n-        if (l == r){\n-            return true;\n-        }\n-\n-        if (l instanceof EvalContext && r instanceof EvalContext){\n-            Set lset = new HashSet(valueSet(((EvalContext)l)));\n-            Set rset = new HashSet(valueSet(((EvalContext)r)));\n-            return lset.equals(rset);\n-        }\n-\n-        if (l instanceof EvalContext){\n+        Object l = left.compute(context);\n+        Object r = right.compute(context);\n+\n+//        System.err.println(\"COMPARING: \" +\n+//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n+//            (r == null ? \"null\" : r.getClass().getName()));\n+\n+        if (l instanceof InitialContext || l instanceof SelfContext){\n             l = ((EvalContext)l).getSingleNodePointer();\n         }\n-        if (r instanceof EvalContext){\n+\n+        if (r instanceof InitialContext || r instanceof SelfContext){\n             r = ((EvalContext)r).getSingleNodePointer();\n         }\n \n+        if (l instanceof Collection){\n+            l = ((Collection)l).iterator();\n+        }\n+\n+        if (r instanceof Collection){\n+            r = ((Collection)r).iterator();\n+        }\n+\n+        if ((l instanceof Iterator) && !(r instanceof Iterator)){\n+            return contains((Iterator)l, r);\n+        }\n+        else if (!(l instanceof Iterator) && (r instanceof Iterator)){\n+            return contains((Iterator)r, l);\n+        }\n+        else if (l instanceof Iterator && r instanceof Iterator){\n+            return findMatch((Iterator)l, (Iterator)r);\n+        }\n+\n+        return equal(l, r);\n+    }\n+\n+    protected boolean contains(Iterator it, Object value){\n+        while (it.hasNext()){\n+            Object element = it.next();\n+            if (equal(element, value)){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean findMatch(Iterator lit, Iterator rit){\n+        HashSet left = new HashSet();\n+        while (lit.hasNext()){\n+            left.add(lit.next());\n+        }\n+        while (rit.hasNext()){\n+            if (contains(left.iterator(), rit.next())){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean equal(Object l, Object r){\n         if (l instanceof Pointer && r instanceof Pointer){\n             if (l.equals(r)){\n                 return true;\n             }\n         }\n \n-        if (l instanceof NodePointer){\n-            l = ((NodePointer)l).getValue();\n-        }\n-        if (r instanceof NodePointer){\n-            r = ((NodePointer)r).getValue();\n-        }\n-\n+        if (l instanceof Pointer){\n+            l = ((Pointer)l).getValue();\n+        }\n+\n+        if (r instanceof Pointer){\n+            r = ((Pointer)r).getValue();\n+        }\n+\n+        if (l == r){\n+            return true;\n+        }\n+\n+//        System.err.println(\"COMPARING VALUES: \" + l + \" \" + r);\n         if (l instanceof Boolean || r instanceof Boolean){\n-            result = (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n+            return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n         }\n         else if (l instanceof Number || r instanceof Number){\n-            result = (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n+            return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n         }\n         else if (l instanceof String || r instanceof String){\n-            result = (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n+            return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n         }\n         else if (l == null){\n             return r == null;\n         }\n-        else {\n-            result = l.equals(r);\n-        }\n-        return result;\n+        return l.equals(r);\n     }\n \n     /**", "timestamp": 1030400391, "metainfo": ""}