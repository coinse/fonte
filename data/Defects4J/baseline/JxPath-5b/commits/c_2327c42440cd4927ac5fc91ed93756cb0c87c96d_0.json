{"sha": "2327c42440cd4927ac5fc91ed93756cb0c87c96d", "log": "Checkstyle, be happy!   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.4 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.5 2003/01/11 05:41:21 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath;\n \n /**\n- * The {@link JXPathContext#createPath JXPathContext.createPath()} method of JXPathContext can \n- * create missing objects as it traverses an XPath; it utilizes an AbstractFactory for that purpose.\n- * Install a factory on JXPathContext by calling {@link JXPathContext#setFactory\n- * JXPathContext.setFactory()}.\n+ * The  {@link JXPathContext#createPath JXPathContext.createPath()} method of\n+ * JXPathContext can create missing objects as it traverses an XPath; it\n+ * utilizes an AbstractFactory for that purpose. Install a factory on\n+ * JXPathContext by calling {@link JXPathContext#setFactory JXPathContext.\n+ * setFactory()}.\n  * <p>\n- * All methods of this class return false.  Override any of them to\n- * return true to indicate that the factory has successfully created the described object.\n+ * All  methods of this class return false.  Override any of them to return true\n+ * to indicate that the factory has successfully created the described object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:21 $\n  */\n public abstract class AbstractFactory {\n \n     /**\n-     * The parameters may describe a collection element or an individual object. It is up\n-     * to the factory to infer which one it is. If it is a collection, the\n-     * factory should check if the collection exists.  If not, it should create\n-     * the collection. Then it should create the index'th element of the collection\n-     * and return true.\n+     * The  parameters may describe a collection element or an individual\n+     * object. It is up to the factory to infer which one it is. If it is a\n+     * collection, the factory should check if the collection exists.  If not,\n+     * it should create the collection. Then it should create the index'th\n+     * element of the collection and return true.\n      * <p>\n      * \n-     * @param context can be used to evaluate other XPaths, get to variables etc.\n+     * @param context can be used to evaluate other XPaths, get to variables\n+     * etc.\n      * @param pointer describes the location of the node to be created\n-     * @param parent is the object that will server as a parent of the new object\n-     * @param name is the name of the child of the parent that needs to be created. \n-     *        In the case of DOM may be qualified.\n-     * @param index is used if the pointer represents a collection element. You may\n-     *        need to expand or even create the collection to accomodate the new element.\n+     * @param parent is the object that will server as a parent of the new\n+     * object\n+     * @param name is the name of the child of the parent that needs to be\n+     * created. In the case of DOM may be qualified.\n+     * @param index is used if the pointer represents a collection element. You\n+     * may need to expand or even create the collection to accomodate the new\n+     * element.\n      * \n      * @return true if the object was successfully created\n      */\n     public boolean createObject(JXPathContext context, Pointer pointer, \n-                                Object parent, String name, int index){\n+                                Object parent, String name, int index) \n+    {\n         return false;\n     }\n \n     /**\n      * Declare the specified variable\n      * \n-     * @param context hosts variable pools. See {@link JXPathContext#getVariables() \n-     *        JXPathContext.getVariables()}\n+     * @param context hosts variable pools. See \n+     * {@link JXPathContext#getVariables() JXPathContext.getVariables()}\n      * @param name is the name of the variable without the \"$\" sign\n      * \n      * @return true if the variable was successfully defined\n      */\n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/BasicVariables.java\n+++ b/src/java/org/apache/commons/jxpath/BasicVariables.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/BasicVariables.java,v 1.3 2002/05/08 23:02:42 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/05/08 23:02:42 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/BasicVariables.java,v 1.4 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A basic implementation of the Variables interface that uses a HashMap.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 23:02:42 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class BasicVariables implements Variables {\n \n      *\n      * @return true if the variable is declared\n      */\n-    public boolean isDeclaredVariable(String varName){\n+    public boolean isDeclaredVariable(String varName) {\n         return vars.containsKey(varName);\n     }\n \n      *\n      * @return the value of the variable\n      */\n-    public Object getVariable(String varName){\n+    public Object getVariable(String varName) {\n         // Note that a variable may be defined with a null value\n \n-        if (vars.containsKey(varName)){\n+        if (vars.containsKey(varName)) {\n             return vars.get(varName);\n         }\n \n-        throw new IllegalArgumentException(\"No such variable: '\" + varName + \"'\");\n+        throw new IllegalArgumentException(\n+            \"No such variable: '\" + varName + \"'\");\n     }\n \n     /**\n      * @param varName is a variable name without the \"$\" sign\n      * @param value is the new value for the variable, which can be null\n      */\n-    public void declareVariable(String varName, Object value){\n+    public void declareVariable(String varName, Object value) {\n         vars.put(varName, value);\n     }\n \n      *\n      * @param varName is a variable name without the \"$\" sign\n      */\n-    public void undeclareVariable(String varName){\n+    public void undeclareVariable(String varName) {\n         vars.remove(varName);\n     }\n-    public String toString(){\n+    \n+    public String toString() {\n         return vars.toString();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.5 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.6 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * the method.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class ClassFunctions implements Functions {\n     private Class functionClass;\n     private String namespace;\n     private static final Object[] EMPTY_ARRAY = new Object[0];\n \n-    public ClassFunctions(Class functionClass, String namespace){\n+    public ClassFunctions(Class functionClass, String namespace) {\n         this.functionClass = functionClass;\n         this.namespace = namespace;\n     }\n      *\n      * @returns a singleton\n      */\n-    public Set getUsedNamespaces(){\n+    public Set getUsedNamespaces() {\n         return Collections.singleton(namespace);\n     }\n \n      * @return a MethodFunction, a ConstructorFunction or null if there is no\n      *      such function.\n      */\n-    public Function getFunction(String namespace, String name, Object[] parameters) {\n+    public Function getFunction(\n+        String namespace,\n+        String name,\n+        Object[] parameters) \n+    {\n         if (!namespace.equals(this.namespace)) {\n             return null;\n         }\n--- a/src/java/org/apache/commons/jxpath/ExpressionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ExpressionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ExpressionContext.java,v 1.4 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ExpressionContext.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </pre></blockquote>\n  * This expression will find all nodes of the graph that are dates.\n  */\n-public interface ExpressionContext\n-{\n+public interface ExpressionContext {\n+    \n     /**\n      * Get the JXPathContext in which this function is being evaluated.\n      *\n      * @return A list representing the current context nodes.\n      */\n-    public JXPathContext getJXPathContext();\n+    JXPathContext getJXPathContext();\n \n     /**\n      * Get the current context node.\n      *\n      * @return The current context node pointer.\n      */\n-    public Pointer getContextNodePointer();\n+    Pointer getContextNodePointer();\n \n     /**\n      * Get the current context node list.  Each element of the list is\n      *\n      * @return A list representing the current context nodes.\n      */\n-    public List getContextNodeList();\n+    List getContextNodeList();\n \n     /**\n      * Returns the current context position.\n      */\n-    public int getPosition();\n+    int getPosition();\n }\n--- a/src/java/org/apache/commons/jxpath/Function.java\n+++ b/src/java/org/apache/commons/jxpath/Function.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Function.java,v 1.3 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Function.java,v 1.4 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n /**\n  * Extension function interface. Extension functions are grouped into\n  * {@link Functions Functions} objects, which are installed on\n- * JXPathContexts using the {@link JXPathContext#setFunctions JXPathContext.setFunctions()}\n+ * JXPathContexts using the \n+ * {@link JXPathContext#setFunctions JXPathContext.setFunctions()}\n  * call.\n  * <p>\n  * The Function interface can be implemented directly. However,\n  * most of the time JXPath's built-in implementations should suffice.\n- * See {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}.\n+ * See {@link ClassFunctions ClassFunctions} and \n+ * {@link PackageFunctions PackageFunctions}.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:41 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface Function {\n \n--- a/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n+++ b/src/java/org/apache/commons/jxpath/FunctionLibrary.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/FunctionLibrary.java,v 1.1 2001/08/23 00:46:58 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/FunctionLibrary.java,v 1.2 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n \n /**\n  * An object that aggregates Functions objects into a group Functions object.\n  * that need to be registered.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:58 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class FunctionLibrary implements Functions {\n     private List allFunctions = new ArrayList();\n     /**\n      * Add functions to the library\n      */\n-    public void addFunctions(Functions functions){\n+    public void addFunctions(Functions functions) {\n         allFunctions.add(functions);\n         byNamespace = null;\n     }\n     /**\n      * Remove functions from the library.\n      */\n-    public void removeFunctions(Functions functions){\n+    public void removeFunctions(Functions functions) {\n         allFunctions.remove(functions);\n         byNamespace = null;\n     }\n      * Returns a set containing all namespaces used by the aggregated\n      * Functions.\n      */\n-    public Set getUsedNamespaces(){\n-        if (byNamespace == null){\n+    public Set getUsedNamespaces() {\n+        if (byNamespace == null) {\n             prepareCache();\n         }\n         return byNamespace.keySet();\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n      */\n-    public Function getFunction(String namespace, String name, Object[] parameters){\n-        if (byNamespace == null){\n+    public Function getFunction(\n+        String namespace,\n+        String name,\n+        Object[] parameters) \n+    {\n+        if (byNamespace == null) {\n             prepareCache();\n         }\n         Object candidates = byNamespace.get(namespace);\n-        if (candidates instanceof Functions){\n-            return ((Functions)candidates).getFunction(namespace, name, parameters);\n+        if (candidates instanceof Functions) {\n+            return ((Functions) candidates).getFunction(\n+                namespace,\n+                name,\n+                parameters);\n         }\n-        else if (candidates instanceof List){\n-            List list = (List)candidates;\n+        else if (candidates instanceof List) {\n+            List list = (List) candidates;\n             int count = list.size();\n-            for (int i = 0; i < count; i++){\n-                Function function = ((Functions)list.get(i)).getFunction(namespace, name, parameters);\n-                if (function != null){\n+            for (int i = 0; i < count; i++) {\n+                Function function =\n+                    ((Functions) list.get(i)).getFunction(\n+                        namespace,\n+                        name,\n+                        parameters);\n+                if (function != null) {\n                     return function;\n                 }\n             }\n         return null;\n     }\n \n-    private void prepareCache(){\n+    private void prepareCache() {\n         byNamespace = new HashMap();\n         int count = allFunctions.size();\n-        for (int i = 0; i < count; i++){\n-            Functions funcs = (Functions)allFunctions.get(i);\n+        for (int i = 0; i < count; i++) {\n+            Functions funcs = (Functions) allFunctions.get(i);\n             Set namespaces = funcs.getUsedNamespaces();\n-            for (Iterator it = namespaces.iterator(); it.hasNext();){\n-                String ns = (String)it.next();\n+            for (Iterator it = namespaces.iterator(); it.hasNext();) {\n+                String ns = (String) it.next();\n                 Object candidates = byNamespace.get(ns);\n-                if (candidates == null){\n+                if (candidates == null) {\n                     byNamespace.put(ns, funcs);\n                 }\n-                else if (candidates instanceof Functions){\n+                else if (candidates instanceof Functions) {\n                     List lst = new ArrayList();\n                     lst.add(candidates);\n                     lst.add(funcs);\n                     byNamespace.put(ns, lst);\n                 }\n                 else {\n-                    ((List)candidates).add(funcs);\n+                    ((List) candidates).add(funcs);\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/Functions.java\n+++ b/src/java/org/apache/commons/jxpath/Functions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Functions.java,v 1.3 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Functions.java,v 1.4 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n /**\n  * A group of Function objects sharing a common namespace or a set of\n  * common namespaces. Use the classes\n- * {@link ClassFunctions ClassFunctions} and {@link PackageFunctions PackageFunctions}\n+ * {@link ClassFunctions ClassFunctions} and \n+ * {@link PackageFunctions PackageFunctions}\n  * to register extension functions implemented as Java methods.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface Functions {\n \n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.4 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.beans.*;\n-import java.util.*;\n+import java.beans.BeanInfo;\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+import java.util.Arrays;\n+import java.util.Comparator;\n \n /**\n  * An implementation of JXPathBeanInfo based on JavaBeans' BeanInfo. Properties\n  * See java.beans.BeanInfo, java.beans.Introspector\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n     private boolean atomic = false;\n     private String[] propertyNames;\n     private Class dynamicPropertyHandlerClass;\n \n-    public JXPathBasicBeanInfo(Class clazz){\n+    public JXPathBasicBeanInfo(Class clazz) {\n         this.clazz = clazz;\n     }\n \n-    public JXPathBasicBeanInfo(Class clazz, boolean atomic){\n+    public JXPathBasicBeanInfo(Class clazz, boolean atomic) {\n         this.clazz = clazz;\n         this.atomic = atomic;\n     }\n \n-    public JXPathBasicBeanInfo(Class clazz, Class dynamicPropertyHandlerClass){\n+    public JXPathBasicBeanInfo(Class clazz, Class dynamicPropertyHandlerClass) {\n         this.clazz = clazz;\n         this.atomic = false;\n         this.dynamicPropertyHandlerClass = dynamicPropertyHandlerClass;\n      * Returns true if objects of this class are treated as atomic\n      * objects which have no properties of their own.\n      */\n-    public boolean isAtomic(){\n+    public boolean isAtomic() {\n         return atomic;\n     }\n \n     }\n \n     public PropertyDescriptor[] getPropertyDescriptors() {\n-        if (propertyDescriptors == null){\n+        if (propertyDescriptors == null) {\n             try {\n                 BeanInfo bi = null;\n-                if (clazz.isInterface()){\n+                if (clazz.isInterface()) {\n                     bi = Introspector.getBeanInfo(clazz);\n                 }\n                 else {\n                 PropertyDescriptor[] pds = bi.getPropertyDescriptors();\n                 propertyDescriptors = new PropertyDescriptor[pds.length];\n                 System.arraycopy(pds, 0, propertyDescriptors, 0, pds.length);\n-                Arrays.sort(propertyDescriptors, new Comparator(){\n-                    public int compare(Object left, Object right){\n-                        return ((PropertyDescriptor)left).getName().\n-                            compareTo(((PropertyDescriptor)right).getName());\n+                Arrays.sort(propertyDescriptors, new Comparator() {\n+                    public int compare(Object left, Object right) {\n+                        return ((PropertyDescriptor) left).getName().compareTo(\n+                            ((PropertyDescriptor) right).getName());\n                     }\n                 });\n             }\n-            catch (IntrospectionException ex){\n+            catch (IntrospectionException ex) {\n                 ex.printStackTrace();\n             }\n         }\n         return propertyDescriptors;\n     }\n \n-    public PropertyDescriptor getPropertyDescriptor(String propertyName){\n-        if (propertyNames == null){\n+    public PropertyDescriptor getPropertyDescriptor(String propertyName) {\n+        if (propertyNames == null) {\n             PropertyDescriptor[] pds = getPropertyDescriptors();\n             propertyNames = new String[pds.length];\n-            for (int i = 0; i < pds.length; i++){\n+            for (int i = 0; i < pds.length; i++) {\n                 propertyNames[i] = pds[i].getName();\n             }\n         }\n \n-        for (int i = 0; i < propertyNames.length; i++){\n-            if (propertyNames[i] == propertyName){\n+        for (int i = 0; i < propertyNames.length; i++) {\n+            if (propertyNames[i] == propertyName) {\n                 return propertyDescriptors[i];\n             }\n         }\n \n-        for (int i = 0; i < propertyNames.length; i++){\n-            if (propertyNames[i].equals(propertyName)){\n+        for (int i = 0; i < propertyNames.length; i++) {\n+            if (propertyNames[i].equals(propertyName)) {\n                 return propertyDescriptors[i];\n             }\n         }\n     }\n \n     /**\n-     * For a dynamic class, returns the corresponding DynamicPropertyHandler class.\n+     * For  a dynamic class, returns the corresponding DynamicPropertyHandler\n+     * class.\n      */\n     public Class getDynamicPropertyHandlerClass() {\n         return dynamicPropertyHandlerClass;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"BeanInfo [class = \");\n         buffer.append(clazz.getName());\n         buffer.append(\", properties = \");\n         PropertyDescriptor[] jpds = getPropertyDescriptors();\n-        for (int i = 0; i < jpds.length; i++){\n+        for (int i = 0; i < jpds.length; i++) {\n             buffer.append(\"\\n    \");\n             buffer.append(jpds[i].getPropertyType());\n             buffer.append(\": \");\n--- a/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/21 21:52:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java,v 1.4 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.beans.PropertyDescriptor;\n \n /**\n- * JXPathBeanInfo is similar to java.beans.BeanInfo in that it describes properties\n- * of a JavaBean class.  By default, JXPathBeanInfo classes are automatically\n- * generated by {@link JXPathIntrospector JXPathIntrospector} based on the java.beans.BeanInfo.\n- * As with JavaBeans, the user can supply an alternative\n- * implementation of JXPathBeanInfo for a custom class.  The alternative implementation\n- * is located by class name, which is the same as the name of the class it represents\n- * with the suffix \"XBeanInfo\".  So, for example, if you need to provide an\n- * alternative JXPathBeanInfo class for class \"com.foo.Bar\", write a class\n- * \"com.foo.BarXBeanInfo\" and make it implement the JXPathBeanInfo interface.\n+ * JXPathBeanInfo  is similar to java.beans.BeanInfo in that it describes\n+ * properties of a JavaBean class.  By default, JXPathBeanInfo classes are\n+ * automatically generated by {@link JXPathIntrospector JXPathIntrospector}\n+ * based on the java.beans.BeanInfo. As with JavaBeans, the user can supply an\n+ * alternative implementation of JXPathBeanInfo for a custom class.  The\n+ * alternative implementation is located by class name, which is the same as the\n+ * name of the class it represents with the suffix \"XBeanInfo\".  So, for\n+ * example, if you need to provide an alternative JXPathBeanInfo class for class\n+ * \"com.foo.Bar\", write a class \"com.foo.BarXBeanInfo\" and make it implement the\n+ * JXPathBeanInfo interface.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface JXPathBeanInfo  {\n \n--- a/src/java/org/apache/commons/jxpath/JXPathContext.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.11 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContext.java,v 1.12 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.Iterator;\n+import java.util.Locale;\n \n /**\n- * JXPathContext provides APIs for the traversal of graphs of JavaBeans using\n- * the XPath syntax.\n- * Using JXPathContext, you can read and write properties of JavaBeans, arrays, collections\n- * and maps. JXPathContext uses JavaBeans introspection to enumerate and access JavaBeans\n- * properties.\n+ * JXPathContext  provides APIs for the traversal of graphs of JavaBeans using\n+ * the XPath syntax. Using JXPathContext, you can read and write properties of\n+ * JavaBeans, arrays, collections and maps. JXPathContext uses JavaBeans\n+ * introspection to enumerate and access JavaBeans properties.\n  * <p>\n- * JXPathContext allows alternative implementations. This is why instead of\n- * allocating JXPathContext directly, you should call a static <code>newContext</code>\n- * method.  This method will utilize the JXPathContextFactory API to locate\n- * a suitable implementation of JXPath.\n- * Bundled with JXPath comes a default implementation called\n- * Reference Implementation.\n+ * JXPathContext  allows alternative implementations. This is why instead of\n+ * allocating JXPathContext directly, you should call a static\n+ * <code>newContext</code> method.  This method will utilize the\n+ * JXPathContextFactory API to locate a suitable implementation of JXPath.\n+ * Bundled with JXPath comes a default implementation called Reference\n+ * Implementation.\n  * </p>\n  *\n  * <h2>JXPath Interprets XPath Syntax on Java Object Graphs</h2>\n  * String fName = (String)context.getValue(\"firstName\");\n  * </blockquote></pre>\n  *\n- * In this example, we are using JXPath to access a property of the <code>emp</code> bean.\n- * In this simple case the invocation of JXPath is equivalent to invocation of getFirstName()\n- * on the bean.\n+ * In  this example, we are using JXPath to access a property of the\n+ * <code>emp</code> bean. In this simple case the invocation of JXPath is\n+ * equivalent to invocation of getFirstName() on the bean.\n  *\n  * <h3>Example 2: Nested Bean Property Access</h3>\n  * JXPath can traverse object graphs:\n  * JXPathContext context = JXPathContext.newContext(ints);\n  * Integer thirdInt = (Integer)context.getValue(\"numbers[3]\");\n  * </blockquote></pre>\n- * A collection can be an arbitrary array or an instance of java.util.Collection.\n+ * A  collection can be an arbitrary array or an instance of java.util.\n+ * Collection.\n  * <p>\n  * Note: in XPath the first element of a collection has index 1, not 0.<br>\n  *\n  * elements:\n  *\n  * <pre><blockquote>\n- * String homeZipCode = (String)context.getValue(\"addresses[@name='home']/zipCode\");\n+ * String homeZipCode = \n+ *     (String) context.getValue(\"addresses[@name='home']/zipCode\");\n  * </blockquote></pre>\n  *\n  * In this case, the key can be an expression, e.g. a variable.<br>\n  * </blockquote></pre>\n  *\n  * <h3>Example 7: Creating objects</h3>\n- * JXPath can be used to create new objects. First, create a subclass of\n- * {@link AbstractFactory AbstractFactory} and install it on the JXPathContext.\n- * Then call {@link JXPathContext#createPath createPathAndSetValue()} instead of \"setValue\".\n- * JXPathContext will invoke your AbstractFactory when it discovers that an\n- * intermediate node of the path is <b>null</b>.  It will not override existing\n- * nodes.\n+ * JXPath  can be used to create new objects. First, create a subclass of {@link\n+ * AbstractFactory AbstractFactory} and install it on the JXPathContext. Then\n+ * call {@link JXPathContext#createPath createPathAndSetValue()} instead of\n+ * \"setValue\". JXPathContext will invoke your AbstractFactory when it discovers\n+ * that an intermediate node of the path is <b>null</b>.  It will not override\n+ * existing nodes.\n  *\n  * <pre><blockquote>\n  * public class AddressFactory extends AbstractFactory {\n- *    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n+ *    public boolean createObject(JXPathContext context, \n+ *               Pointer pointer, Object parent, String name, int index){\n  *     if ((parent instanceof Employee) &amp;&amp; name.equals(\"address\"){\n  *       ((Employee)parent).setAddress(new Address());\n  *       return true;\n  * </blockquote></pre>\n  *\n  * <h3>Example 9: Using Nested Contexts</h3>\n- * If you need to use the same set of variable while interpreting\n- * XPaths with different beans, it makes sense to put the variables in a separate\n- * context and specify that context as a parent context every time you\n- * allocate a new JXPathContext for a JavaBean.\n+ * If  you need to use the same set of variable while interpreting XPaths with\n+ * different beans, it makes sense to put the variables in a separate context\n+ * and specify that context as a parent context every time you allocate a new\n+ * JXPathContext for a JavaBean.\n  *\n  * <pre><blockquote>\n  * JXPathContext varContext = JXPathContext.newContext(null);\n  * <p>\n  * Here's how you can create new objects:\n  * <pre><blockquote>\n- * Book book = (Book)context.getValue(\"org.apache.commons.jxpath.example.Book.new('John Updike')\");\n+ * Book book = \n+ *    (Book) context.getValue(\n+ *         \"org.apache.commons.jxpath.example.Book.new ('John Updike')\");\n  * </blockquote></pre>\n  *\n  * Here's how you can call static methods:\n  * <pre><blockquote>\n- * Book book = (Book)context.getValue(\"org.apache.commons.jxpath.example.Book.getBestBook('John Updike')\");\n+ *   Book book = \n+ *    (Book) context.getValue( \n+ *       \"org. apache.commons.jxpath.example.Book.getBestBook('John Updike')\");\n  * </blockquote></pre>\n  *\n  * Here's how you can call regular methods:\n  *\n  * <h2>Notes</h2>\n  * <ul>\n- * <li>JXPath does not support DOM attributes for non-DOM objects. Even though XPaths\n- *     like \"para[@type='warning']\" are legitimate, they will always produce empty results.\n- *     The only attribute supported for JavaBeans is \"name\".  The XPath \"foo/bar\" is\n- *     equivalent to \"foo[@name='bar']\".\n+ * <li> JXPath does not support DOM attributes for non-DOM objects. Even though\n+ * XPaths like \"para[@type='warning']\" are legitimate, they will always produce\n+ * empty results. The only attribute supported for JavaBeans is \"name\".  The\n+ * XPath \"foo/bar\" is equivalent to \"foo[@name='bar']\".\n  * </ul>\n  *\n- * See <a href=\"http://www.w3schools.com/xpath\">XPath Tutorial by W3Schools</a><br>\n- * Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path Language (XPath)\n- *    Version 1.0 </a><br><br>\n+ * See  <a href=\"http://www.w3schools.com/xpath\">XPath Tutorial by\n+ * W3Schools</a><br>. Also see <a href=\"http://www.w3.org/TR/xpath\">XML Path\n+ * Language (XPath) Version 1.0</a><br><br> \n+ * \n  * You will also find more information and examples in\n  * <a href=\"http://jakarta.apache.org/commons/jxpath/users-guide.html\">\n  * JXPath User's Guide</a>\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:22 $\n  */\n public abstract class JXPathContext {\n     protected JXPathContext parentContext;\n     /**\n      * Creates a new JXPathContext with the specified object as the root node.\n      */\n-    public static JXPathContext newContext(Object contextBean){\n+    public static JXPathContext newContext(Object contextBean) {\n         return JXPathContextFactory.newInstance().newContext(null, contextBean);\n     }\n \n     /**\n-     * Creates a new JXPathContext with the specified bean as the root node and the\n-     * specified parent context. Variables defined in a parent context can be\n-     * referenced in XPaths passed to the child context.\n-     */\n-    public static JXPathContext newContext(JXPathContext parentContext, Object contextBean){\n-        return JXPathContextFactory.newInstance().newContext(parentContext, contextBean);\n-    }\n-\n-    /**\n-     * This constructor should remain protected - it is to be overridden by subclasses,\n-     * but never explicitly invoked by clients.\n-     */\n-    protected JXPathContext(JXPathContext parentContext, Object contextBean){\n+     * Creates  a new JXPathContext with the specified bean as the root node and\n+     * the specified parent context. Variables defined in a parent context can\n+     * be referenced in XPaths passed to the child context.\n+     */\n+    public static JXPathContext newContext(\n+        JXPathContext parentContext,\n+        Object contextBean) \n+    {\n+        return JXPathContextFactory.newInstance().newContext(\n+            parentContext,\n+            contextBean);\n+    }\n+\n+    /**\n+     * This  constructor should remain protected - it is to be overridden by\n+     * subclasses, but never explicitly invoked by clients.\n+     */\n+    protected JXPathContext(JXPathContext parentContext, Object contextBean) {\n         this.parentContext = parentContext;\n         this.contextBean = contextBean;\n     }\n     /**\n      * Returns the parent context of this context or null.\n      */\n-    public JXPathContext getParentContext(){\n+    public JXPathContext getParentContext() {\n         return parentContext;\n     }\n \n     /**\n      * Returns the JavaBean associated with this context.\n      */\n-    public Object getContextBean(){\n+    public Object getContextBean() {\n         return contextBean;\n     }\n \n     /**\n      * Installs a custom implementation of the Variables interface.\n      */\n-    public void setVariables(Variables vars){\n+    public void setVariables(Variables vars) {\n         this.vars = vars;\n     }\n \n      * returns the default implementation of Variables,\n      * {@link BasicVariables BasicVariables}.\n      */\n-    public Variables getVariables(){\n-        if (vars == null){\n+    public Variables getVariables() {\n+        if (vars == null) {\n             vars = new BasicVariables();\n         }\n         return vars;\n      *\n      * @see FunctionLibrary\n      */\n-    public void setFunctions(Functions functions){\n+    public void setFunctions(Functions functions) {\n         this.functions = functions;\n     }\n \n     /**\n      * Returns the set of functions installed on the context.\n      */\n-    public Functions getFunctions(){\n+    public Functions getFunctions() {\n         return functions;\n     }\n \n      * <code>createPath()</code> and <code>createPathAndSetValue()</code>\n      * methods.\n      */\n-    public void setFactory(AbstractFactory factory){\n+    public void setFactory(AbstractFactory factory) {\n         this.factory = factory;\n     }\n \n      * If none has been installed and this context has a parent context,\n      * returns the parent's factory.  Otherwise returns null.\n      */\n-    public AbstractFactory getFactory(){\n-        if (factory == null && parentContext != null){\n+    public AbstractFactory getFactory() {\n+        if (factory == null && parentContext != null) {\n             return parentContext.getFactory();\n         }\n         return factory;\n      * affected by the locale.  By default, JXPath uses\n      * <code>Locale.getDefault()</code>\n      */\n-    public void setLocale(Locale locale){\n+    public void setLocale(Locale locale) {\n         this.locale = locale;\n     }\n \n      * the context has a parent, returns the parent's locale.\n      * Otherwise, returns Locale.getDefault().\n      */\n-    protected Locale getLocale(){\n-        if (locale == null){\n-            if (parentContext != null){\n+    protected Locale getLocale() {\n+        if (locale == null) {\n+            if (parentContext != null) {\n                 return parentContext.getLocale();\n             }\n             else {\n      * <p>\n      * By default, lenient = false\n      */\n-    public void setLenient(boolean lenient){\n+    public void setLenient(boolean lenient) {\n         this.lenient = lenient;\n     }\n \n     /**\n      * @see #setLenient(boolean)\n      */\n-    public boolean isLenient(){\n+    public boolean isLenient() {\n         return lenient;\n     }\n \n      * and there is a convenient place to cache CompiledExpression\n      * between invocations.\n      */\n-    public static CompiledExpression compile(String xpath){\n-        if (compilationContext == null){\n+    public static CompiledExpression compile(String xpath) {\n+        if (compilationContext == null) {\n             compilationContext = JXPathContext.newContext(null);\n         }\n         return compilationContext.compilePath(xpath);\n      * Install an identity manager that will be used by the context\n      * to look up a node by its ID.\n      */\n-    public void setIdentityManager(IdentityManager idManager){\n+    public void setIdentityManager(IdentityManager idManager) {\n         this.idManager = idManager;\n     }\n \n      * Returns this context's identity manager. If none has been installed,\n      * returns the identity manager of the parent context.\n      */\n-    public IdentityManager getIdentityManager(){\n-        if (idManager == null && parentContext != null){\n+    public IdentityManager getIdentityManager() {\n+        if (idManager == null && parentContext != null) {\n             return parentContext.getIdentityManager();\n         }\n         return idManager;\n      *\n      * @param id is the ID of the sought node.\n      */\n-    public Pointer getPointerByID(String id){\n+    public Pointer getPointerByID(String id) {\n         IdentityManager manager = getIdentityManager();\n-        if (manager != null){\n+        if (manager != null) {\n             return manager.getPointerByID(this, id);\n         }\n         else {\n-            throw new JXPathException(\"Cannot find an element by ID - \" +\n-                \"no IdentityManager has been specified\");\n+            throw new JXPathException(\n+                \"Cannot find an element by ID - \"\n+                    + \"no IdentityManager has been specified\");\n         }\n     }\n \n      * Install a key manager that will be used by the context\n      * to look up a node by a key value.\n      */\n-    public void setKeyManager(KeyManager keyManager){\n+    public void setKeyManager(KeyManager keyManager) {\n         this.keyManager = keyManager;\n     }\n \n      * Returns this context's key manager. If none has been installed,\n      * returns the key manager of the parent context.\n      */\n-    public KeyManager getKeyManager(){\n-        if (keyManager == null && parentContext != null){\n+    public KeyManager getKeyManager() {\n+        if (keyManager == null && parentContext != null) {\n             return parentContext.getKeyManager();\n         }\n         return keyManager;\n     /**\n      * Locates a Node by a key value.\n      */\n-    public Pointer getPointerByKey(String key, String value){\n+    public Pointer getPointerByKey(String key, String value) {\n         KeyManager manager = getKeyManager();\n-        if (manager != null){\n+        if (manager != null) {\n             return manager.getPointerByKey(this, key, value);\n         }\n         else {\n-            throw new JXPathException(\"Cannot find an element by key - \" +\n-                \"no KeyManager has been specified\");\n+            throw new JXPathException(\n+                \"Cannot find an element by key - \"\n+                    + \"no KeyManager has been specified\");\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathContextFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactory.java,v 1.3 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathContextFactory.java,v 1.4 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.util.*;\n-import java.io.*;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.Properties;\n \n /**\n  * Defines a factory API that enables applications to obtain a\n  * @see JXPathContext#newContext(JXPathContext,Object)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:41 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:22 $\n  */\n public abstract class JXPathContextFactory {\n \n         \"org.apache.commons.jxpath.JXPathContextFactory\";\n \n     /** The default factory class */\n-    private static final String defaultClassName =\n+    private static final String DEFAULT_FACTORY_CLASS =\n         \"org.apache.commons.jxpath.ri.JXPathContextFactoryReferenceImpl\";\n \n     protected JXPathContextFactory () {\n      * the <code>JXPathContextFactory</code> implementation class to load:\n      * <ul>\n      * <li>\n-     * Use the <code>org.apache.commons.jxpath.JXPathContextFactory</code> system\n-     * property.\n+     * Use  the <code>org.apache.commons.jxpath.JXPathContextFactory</code>\n+     * system property.\n      * </li>\n      * <li>\n      * Alternatively, use the JAVA_HOME (the parent directory where jdk is\n      * Use the Services API (as detailed in the JAR specification), if\n      * available, to determine the classname. The Services API will look\n      * for a classname in the file\n-     * <code>META-INF/services/<i>org.apache.commons.jxpath.JXPathContextFactory</i></code>\n-     * in jars available to the runtime.\n+     * <code>META- INF/services/<i>org.apache.commons.jxpath.\n+     * JXPathContextFactory</i></code> in jars available to the runtime.\n      * </li>\n      * <li>\n      * Platform default <code>JXPathContextFactory</code> instance.\n      * @exception JXPathFactoryConfigurationError if the implementation is not\n      * available or cannot be instantiated.\n      */\n-\n     public static JXPathContextFactory newInstance() {\n-        String factoryImplName = findFactory(FACTORY_NAME_PROPERTY, defaultClassName);\n+        String factoryImplName =\n+            findFactory(FACTORY_NAME_PROPERTY, DEFAULT_FACTORY_CLASS);\n \n         if (factoryImplName == null) {\n             throw new JXPathContextFactoryConfigurationError(\n-                \"No default implementation found\");\n+                    \"No default implementation found\");\n         }\n \n         JXPathContextFactory factoryImpl;\n         try {\n             Class clazz = Class.forName(factoryImplName);\n-            factoryImpl = (JXPathContextFactory)clazz.newInstance();\n-        } catch  (ClassNotFoundException cnfe) {\n+            factoryImpl = (JXPathContextFactory) clazz.newInstance();\n+        }\n+        catch (ClassNotFoundException cnfe) {\n             throw new JXPathContextFactoryConfigurationError(cnfe);\n-        } catch (IllegalAccessException iae) {\n+        }\n+        catch (IllegalAccessException iae) {\n             throw new JXPathContextFactoryConfigurationError(iae);\n-        } catch (InstantiationException ie) {\n+        }\n+        catch (InstantiationException ie) {\n             throw new JXPathContextFactoryConfigurationError(ie);\n         }\n         return factoryImpl;\n      * cannot be created which satisfies the configuration requested\n      */\n \n-    public abstract JXPathContext newContext(JXPathContext parentContext, Object contextBean)\n+    public abstract JXPathContext newContext(\n+        JXPathContext parentContext,\n+        Object contextBean)\n         throws JXPathContextFactoryConfigurationError;\n \n     // -------------------- private methods --------------------\n             debug = System.getProperty(\"jxpath.debug\") != null;\n         }\n         catch (SecurityException se) {\n+            // This is ok\n         }\n     }\n \n         try {\n             String systemProp = System.getProperty(property);\n             if (systemProp != null) {\n-                if (debug){\n-                    System.err.println(\"JXPath: found system property\" + systemProp);\n+                if (debug) {\n+                    System.err.println(\n+                        \"JXPath: found system property\" + systemProp);\n                 }\n                 return systemProp;\n             }\n \n         }\n         catch (SecurityException se) {\n-        }\n-\n-        if (foundFactory != null){\n+            // Ignore\n+        }\n+\n+        if (foundFactory != null) {\n             return foundFactory;\n         }\n \n         try {\n             String systemProp = System.getProperty(property);\n             if (systemProp != null) {\n-                if (debug){\n-                    System.err.println(\"JXPath: found system property\" + systemProp);\n+                if (debug) {\n+                    System.err.println(\n+                        \"JXPath: found system property\" + systemProp);\n                 }\n                 return systemProp;\n             }\n \n         }\n         catch (SecurityException se) {\n-        }\n+            // Ignore\n+       }\n \n         // try to read from $java.home/lib/xml.properties\n         try {\n             String javah = System.getProperty(\"java.home\");\n             String configFile =\n-                javah + File.separator + \"lib\" + File.separator + \"jxpath.properties\";\n+                javah\n+                    + File.separator\n+                    + \"lib\"\n+                    + File.separator\n+                    + \"jxpath.properties\";\n             File f = new File(configFile);\n             if (f.exists()) {\n                 Properties props = new Properties();\n                 props.load(new FileInputStream(f));\n                 foundFactory = props.getProperty(property);\n-                if (debug){\n-                    System.err.println(\"JXPath: found java.home property \" + foundFactory);\n-                }\n-                if (foundFactory != null){\n+                if (debug) {\n+                    System.err.println(\n+                        \"JXPath: found java.home property \" + foundFactory);\n+                }\n+                if (foundFactory != null) {\n                     return foundFactory;\n                 }\n             }\n         }\n         catch (Exception ex) {\n-            if (debug){\n+            if (debug) {\n                 ex.printStackTrace();\n             }\n         }\n             }\n \n             if (is != null) {\n-                if (debug){\n+                if (debug) {\n                     System.err.println(\"JXPath: found  \" + serviceId);\n                 }\n-                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n+                BufferedReader rd =\n+                    new BufferedReader(new InputStreamReader(is));\n \n                 foundFactory = rd.readLine();\n                 rd.close();\n \n-                if (debug){\n-                    System.err.println(\"JXPath: loaded from services: \" + foundFactory);\n+                if (debug) {\n+                    System.err.println(\n+                        \"JXPath: loaded from services: \" + foundFactory);\n                 }\n                 if (foundFactory != null && !\"\".equals(foundFactory)) {\n                     return foundFactory;\n             }\n         }\n         catch (Exception ex) {\n-            if (debug){\n+            if (debug) {\n                 ex.printStackTrace();\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/JXPathException.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathException.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathException.java,v 1.1 2002/04/26 03:28:36 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/26 03:28:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathException.java,v 1.2 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Thrown in various situations by JXPath; may contain a nested exception.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/26 03:28:36 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:22 $\n  */\n \n public class JXPathException extends RuntimeException {\n      *\n      * @return The error message.\n      */\n-    public String getMessage () {\n-        String message = super.getMessage ();\n+    public String getMessage() {\n+        String message = super.getMessage();\n \n         if (exception != null) {\n-            if (message == null){\n-                if (exception.getMessage() != null){\n+            if (message == null) {\n+                if (exception.getMessage() != null) {\n                     return exception.getMessage();\n                 }\n                 else {\n                 }\n             }\n             else {\n-                if (exception.getMessage() != null){\n+                if (exception.getMessage() != null) {\n                     return message + \"; \" + exception.getMessage();\n                 }\n                 else {\n      *\n      * @return The encapsulated exception, or null if there is none.\n      */\n-    public Throwable getException () {\n+    public Throwable getException() {\n         return exception;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathIntrospector.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathIntrospector.java,v 1.4 2002/08/10 01:27:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/10 01:27:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathIntrospector.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.HashMap;\n \n /**\n- * JXPathIntrospector maintains a registry of {@link JXPathBeanInfo JXPathBeanInfo} objects\n- * for Java classes.\n+ * JXPathIntrospector  maintains a registry of {@link JXPathBeanInfo\n+ * JXPathBeanInfo} objects for Java classes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/08/10 01:27:38 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class JXPathIntrospector {\n \n      * for the specified class. That object returns true to isDynamic().\n      */\n     public static void registerDynamicClass(\n-            Class beanClass, Class dynamicPropertyHandlerClass) {\n+        Class beanClass,\n+        Class dynamicPropertyHandlerClass) \n+    {\n         JXPathBasicBeanInfo bi =\n             new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass);\n-        if (beanClass.isInterface()){\n+        if (beanClass.isInterface()) {\n             byInterface.put(beanClass, bi);\n         }\n         else {\n     }\n \n     /**\n-     * Creates and registers a JXPathBeanInfo object for the supplied class.\n-     * If the class has already been registered, returns the registered JXPathBeanInfo\n-     * object.\n+     * Creates  and registers a JXPathBeanInfo object for the supplied class. If\n+     * the class has already been registered, returns the registered\n+     * JXPathBeanInfo object.\n      * <p>\n      * The process of creation of JXPathBeanInfo is as follows:\n      * <ul>\n      * <li>If class named <code>&lt;beanClass&gt;XBeanInfo</code> exists,\n      *     an instance of that class is allocated.\n-     * <li>Otherwise, an instance of {@link JXPathBasicBeanInfo JXPathBasicBeanInfo} is\n-     *     allocated.\n+     * <li>Otherwise, an instance of {@link JXPathBasicBeanInfo\n+     *     JXPathBasicBeanInfo}  is allocated.\n      * </ul>\n      */\n     public static JXPathBeanInfo getBeanInfo(Class beanClass) {\n         JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass);\n         if (beanInfo == null) {\n             beanInfo = findDynamicBeanInfo(beanClass);\n-            if (beanInfo == null){\n+            if (beanInfo == null) {\n                 beanInfo = findInformant(beanClass);\n                 if (beanInfo == null) {\n                     beanInfo = new JXPathBasicBeanInfo(beanClass);\n      * Find a dynamic bean info if available for any superclasses or\n      * interfaces.\n      */\n-    private static JXPathBeanInfo findDynamicBeanInfo(Class beanClass){\n+    private static JXPathBeanInfo findDynamicBeanInfo(Class beanClass) {\n         JXPathBeanInfo beanInfo;\n-        if (beanClass.isInterface()){\n+        if (beanClass.isInterface()) {\n             beanInfo = (JXPathBeanInfo) byInterface.get(beanClass);\n-            if (beanInfo != null){\n+            if (beanInfo != null) {\n                 return beanInfo;\n             }\n         }\n \n         Class interfaces[] = beanClass.getInterfaces();\n-        if (interfaces != null){\n-            for (int i = 0; i < interfaces.length; i++){\n+        if (interfaces != null) {\n+            for (int i = 0; i < interfaces.length; i++) {\n                 beanInfo = findDynamicBeanInfo(interfaces[i]);\n-                if (beanInfo != null){\n+                if (beanInfo != null) {\n                     return beanInfo;\n                 }\n             }\n         }\n \n         Class sup = beanClass.getSuperclass();\n-        if (sup != null){\n+        if (sup != null) {\n             return findDynamicBeanInfo(sup);\n         }\n         return null;\n      * classloader.\n      */\n     private static Object instantiate(Class sibling, String className)\n-        throws Exception {\n+        throws Exception \n+    {\n \n         // First check with sibling's classloader (if any).\n         ClassLoader cl = sibling.getClassLoader();\n--- a/src/java/org/apache/commons/jxpath/KeyManager.java\n+++ b/src/java/org/apache/commons/jxpath/KeyManager.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/KeyManager.java,v 1.1 2002/06/08 22:47:24 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/06/08 22:47:24 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/KeyManager.java,v 1.2 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * function.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/06/08 22:47:24 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface KeyManager {\n \n     /**\n      * Finds a node by a key value.\n      */\n-    Pointer getPointerByKey(JXPathContext context, String keyName, String keyValue);\n+    Pointer getPointerByKey(\n+        JXPathContext context,\n+        String keyName,\n+        String keyValue);\n }\n--- a/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n+++ b/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java,v 1.2 2002/04/24 03:29:33 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 03:29:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/MapDynamicPropertyHandler.java,v 1.3 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements the DynamicPropertyHandler interface for java.util.Map.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 03:29:33 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class MapDynamicPropertyHandler implements DynamicPropertyHandler {\n \n     /**\n      * Returns string representations of all keys in the map.\n      */\n-    public String[] getPropertyNames(Object object){\n+    public String[] getPropertyNames(Object object) {\n         Map map = (Map) object;\n         String names[] = new String[map.size()];\n         Iterator it = map.keySet().iterator();\n-        for (int i = 0; i < names.length; i++){\n+        for (int i = 0; i < names.length; i++) {\n             names[i] = String.valueOf(it.next());\n         }\n         return names;\n     /**\n      * Sets the specified key value.\n      */\n-    public void setProperty(Object object, String propertyName, Object value){\n-        ((Map)object).put(propertyName, value);\n+    public void setProperty(Object object, String propertyName, Object value) {\n+        ((Map) object).put(propertyName, value);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.6 2002/06/16 03:22:22 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/06/16 03:22:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/06/16 03:22:22 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n      * Returns a Function, if any, for the specified namespace,\n      * name and parameter types.\n      * <p>\n-     * @param namespace - if it is not the same as specified in the construction,\n-     *      this method returns null\n+     * @param  namespace - if it is not the same as specified in the\n+     * construction, this method returns null\n      * @param name - name of the method, which can one these forms:\n      * <ul>\n-     * <li><b>methodname</b>, if invoking a method on an object passed as the first parameter</li>\n+     * <li><b>methodname</b>, if invoking a method on an object passed as the\n+     * first parameter</li>\n      * <li><b>Classname.new</b>, if looking for a constructor</li>\n-     * <li><b>subpackage.subpackage.Classname.new</b>, if looking for a constructor in\n-     *      a subpackage</li>\n+     * <li><b>subpackage.subpackage.Classname.new</b>, if looking for a\n+     * constructor in a subpackage</li>\n      * <li><b>Classname.methodname</b>, if looking for a static method</li>\n      * <li><b>subpackage.subpackage.Classname.methodname</b>, if looking for a\n-     *      static method of a class in a subpackage</li>\n+     * static method of a class in a subpackage</li>\n      * </ul>\n      *\n-     * @return a MethodFunction, a ConstructorFunction or null if no function is found\n+     * @return  a MethodFunction, a ConstructorFunction or null if no function\n+     * is found\n      */\n-    public Function getFunction(String namespace, String name, Object[] parameters) {\n+    public Function getFunction(\n+        String namespace,\n+        String name,\n+        Object[] parameters) \n+    {\n         if ((namespace == null && this.namespace != null)\n             || (namespace != null && !namespace.equals(this.namespace))) {\n             return null;\n             Object target = parameters[0];\n             if (target != null) {\n                 if (target instanceof ExpressionContext) {\n-                    Pointer pointer = ((ExpressionContext) target).getContextNodePointer();\n+                    Pointer pointer =\n+                        ((ExpressionContext) target).getContextNodePointer();\n                     if (pointer != null) {\n                         target = pointer.getValue();\n                     }\n                 }\n             }\n             if (target != null) {\n-                Method method = MethodLookupUtils.\n-                    lookupMethod(target.getClass(), name, parameters);\n+                Method method =\n+                    MethodLookupUtils.lookupMethod(\n+                        target.getClass(),\n+                        name,\n+                        parameters);\n                 if (method != null) {\n                     return new MethodFunction(method);\n                 }\n             functionClass = Class.forName(className);\n         }\n         catch (ClassNotFoundException ex) {\n-            throw new JXPathException(\"Cannot invoke extension function \"\n-                + (namespace != null ? namespace + \":\" + name : name),\n+            throw new JXPathException(\n+                \"Cannot invoke extension function \"\n+                    + (namespace != null ? namespace + \":\" + name : name),\n                 ex);\n         }\n \n         }\n         else {\n             Method method =\n-                MethodLookupUtils.\n-                    lookupStaticMethod(functionClass, methodName, parameters);\n+                MethodLookupUtils.lookupStaticMethod(\n+                    functionClass,\n+                    methodName,\n+                    parameters);\n             if (method != null) {\n                 return new MethodFunction(method);\n             }\n--- a/src/java/org/apache/commons/jxpath/Pointer.java\n+++ b/src/java/org/apache/commons/jxpath/Pointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.4 2002/08/10 16:13:03 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/10 16:13:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/Pointer.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointers represent locations of objects and their properties\n  * in Java object graphs. JXPathContext has methods\n  * ({@link JXPathContext#getPointer(java.lang.String) getPointer()}\n- * and ({@link JXPathContext#iteratePointers(java.lang.String) iteratePointers()},\n- * which, given an XPath, produce Pointers for the objects or properties\n- * described the the path. For example, <code>ctx.getPointer(\"foo/bar\")</code>\n- * will produce a Pointer that can get and set the property \"bar\" of\n- * the object which is the value of the property \"foo\" of the root object.\n- * The value of <code>ctx.getPointer(\"aMap/aKey[3]\")</code> will be a pointer\n- * to the 3'rd element of the array, which is the value for the key \"aKey\" of\n- * the map, which is the value of the property \"aMap\" of the root object.\n+ * and  ({@link JXPathContext#iteratePointers(java.lang.String)\n+ * iteratePointers()}, which, given an XPath, produce Pointers for the objects\n+ * or properties described the the path. For example, <code>ctx.getPointer\n+ * (\"foo/bar\")</code> will produce a Pointer that can get and set the property\n+ * \"bar\" of the object which is the value of the property \"foo\" of the root\n+ * object. The value of <code>ctx.getPointer(\"aMap/aKey[3]\")</code> will be a\n+ * pointer to the 3'rd element of the array, which is the value for the key\n+ * \"aKey\" of the map, which is the value of the property \"aMap\" of the root\n+ * object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/08/10 16:13:03 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface Pointer {\n \n     /**\n      * Returns a string that is a proper \"canonical\" XPath that corresponds to\n      * this pointer.  Consider this example:\n-     * <p><code>Pointer ptr = ctx.getPointer(\"//employees[firstName = 'John']\")</code>\n-     * <p>The value of <code>ptr.asPath()</code> will look something like\n-     * <code>\"/departments[2]/employees[3]\"</code>, so, basically, it represents the\n-     * concrete location(s) of the result of a search performed by JXPath.\n-     * If an object in the pointer's path is a Dynamic Property object (like a Map),\n-     * the asPath method generates an XPath that looks like this:\n-     * <code>\"/departments[@name = 'HR']/employees[3]\"</code>.\n+     * <p><code>Pointer  ptr = ctx.getPointer(\"//employees[firstName = 'John']\")\n+     * </code>\n+     * <p>The  value of <code>ptr.asPath()</code> will look something like\n+     * <code>\"/departments[2]/employees[3]\"</code>, so, basically, it represents\n+     * the concrete location(s) of the result of a search performed by JXPath.\n+     * If an object in the pointer's path is a Dynamic Property object (like a\n+     * Map), the asPath method generates an XPath that looks like this: <code>\"\n+     * /departments[@name = 'HR']/employees[3]\"</code>.\n      */\n     String asPath();\n }\n--- a/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/XMLDocumentContainer.java,v 1.8 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * @deprecated 1.1 Please use org.apache.commons.jxpath.xml.DocumentContainer\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class XMLDocumentContainer implements Container {\n \n     private String parser;\n \n     /**\n-     * @param URL is a URL for an XML file. Use getClass().getResource(resourceName)\n-     * to load XML from a resource file.\n+     * @param  URL is a URL for an XML file. Use getClass().getResource\n+     * (resourceName) to load XML from a resource file.\n      */\n-    public XMLDocumentContainer(URL xmlURL){\n+    public XMLDocumentContainer(URL xmlURL) {\n         delegate = new DocumentContainer(xmlURL);\n     }\n \n-    public XMLDocumentContainer(Source source){\n+    public XMLDocumentContainer(Source source) {\n         this.source = source;\n-        if (source == null){\n+        if (source == null) {\n             throw new RuntimeException(\"Source is null\");\n         }\n     }\n     /**\n      * Reads XML, caches it internally and returns the Document.\n      */\n-    public Object getValue(){\n-        if (document == null){\n+    public Object getValue() {\n+        if (document == null) {\n             try {\n-                if (source != null){\n+                if (source != null) {\n                     DOMResult result = new DOMResult();\n-                    Transformer trans = TransformerFactory.newInstance().newTransformer();\n+                    Transformer trans =\n+                        TransformerFactory.newInstance().newTransformer();\n                     trans.transform(source, result);\n                     document = (Document) result.getNode();\n                 }\n                     document = delegate.getValue();\n                 }\n             }\n-            catch (Exception ex){\n+            catch (Exception ex) {\n                 throw new JXPathException(\n-                    \"Cannot read XML from: \" +\n-                        (xmlURL != null ? xmlURL.toString() :\n-                            (source != null ?\n-                                source.getSystemId() : \"<<undefined source>>\")),\n+                    \"Cannot read XML from: \"\n+                        + (xmlURL != null\n+                            ? xmlURL.toString()\n+                            : (source != null\n+                                ? source.getSystemId()\n+                                : \"<<undefined source>>\")),\n                     ex);\n             }\n         }\n     /**\n      * Throws an UnsupportedOperationException\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         throw new UnsupportedOperationException();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.6 2002/05/08 00:40:00 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/05/08 00:40:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An extension function that creates an instance using a constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/05/08 00:40:00 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class ConstructorFunction implements Function {\n \n     private Constructor constructor;\n     private static final Object EMPTY_ARRAY[] = new Object[0];\n \n-    public ConstructorFunction(Constructor constructor){\n+    public ConstructorFunction(Constructor constructor) {\n         this.constructor = constructor;\n     }\n \n     /**\n      * Converts parameters to suitable types and invokes the constructor.\n      */\n-    public Object invoke(ExpressionContext context, Object[] parameters){\n+    public Object invoke(ExpressionContext context, Object[] parameters) {\n         try {\n             Object[] args;\n-            if (parameters == null){\n+            if (parameters == null) {\n                 parameters = EMPTY_ARRAY;\n             }\n             int pi = 0;\n             Class types[] = constructor.getParameterTypes();\n-            if (types.length > 0 && ExpressionContext.class.isAssignableFrom(types[0])){\n+            if (types.length > 0\n+                && ExpressionContext.class.isAssignableFrom(types[0])) {\n                 pi = 1;\n             }\n             args = new Object[parameters.length + pi];\n-            if (pi == 1){\n+            if (pi == 1) {\n                 args[0] = context;\n             }\n-            for (int i = 0; i < parameters.length; i++){\n+            for (int i = 0; i < parameters.length; i++) {\n                 args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);\n             }\n             return constructor.newInstance(args);\n         }\n-        catch (Exception exception){\n-            throw new JXPathException(\"Cannot invoke constructor \" + constructor, exception);\n+        catch (Exception exception) {\n+            throw new JXPathException(\n+                \"Cannot invoke constructor \" + constructor,\n+                exception);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.6 2002/05/08 00:40:00 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/05/08 00:40:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.7 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n+ * An XPath extension function implemented as an individual Java method.\n+ * \n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/05/08 00:40:00 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class MethodFunction implements Function {\n \n     private Method method;\n     private static final Object EMPTY_ARRAY[] = new Object[0];\n \n-    public MethodFunction(Method method){\n+    public MethodFunction(Method method) {\n         this.method = method;\n     }\n \n-    public Object invoke(ExpressionContext context, Object[] parameters){\n+    public Object invoke(ExpressionContext context, Object[] parameters) {\n         try {\n             Object target;\n             Object[] args;\n-            if (Modifier.isStatic(method.getModifiers())){\n+            if (Modifier.isStatic(method.getModifiers())) {\n                 target = null;\n-                if (parameters == null){\n+                if (parameters == null) {\n                     parameters = EMPTY_ARRAY;\n                 }\n                 int pi = 0;\n                 Class types[] = method.getParameterTypes();\n-                if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+                if (types.length >= 1\n+                    && ExpressionContext.class.isAssignableFrom(types[0])) {\n                     pi = 1;\n                 }\n                 args = new Object[parameters.length + pi];\n-                if (pi == 1){\n+                if (pi == 1) {\n                     args[0] = context;\n                 }\n-                for (int i = 0; i < parameters.length; i++){\n-                    args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);\n+                for (int i = 0; i < parameters.length; i++) {\n+                    args[i + pi] =\n+                        TypeUtils.convert(parameters[i], types[i + pi]);\n                 }\n             }\n             else {\n                 int pi = 0;\n                 Class types[] = method.getParameterTypes();\n-                if (types.length >= 1 &&\n-                        ExpressionContext.class.isAssignableFrom(types[0])){\n+                if (types.length >= 1\n+                    && ExpressionContext.class.isAssignableFrom(types[0])) {\n                     pi = 1;\n                 }\n-                target = TypeUtils.\n-                        convert(parameters[0], method.getDeclaringClass());\n+                target =\n+                    TypeUtils.convert(\n+                        parameters[0],\n+                        method.getDeclaringClass());\n                 args = new Object[parameters.length - 1 + pi];\n-                if (pi == 1){\n+                if (pi == 1) {\n                     args[0] = context;\n                 }\n-                for (int i = 1; i < parameters.length; i++){\n+                for (int i = 1; i < parameters.length; i++) {\n                     args[pi + i - 1] =\n-                            TypeUtils.convert(parameters[i], types[i + pi - 1]);\n+                        TypeUtils.convert(parameters[i], types[i + pi - 1]);\n                 }\n             }\n \n             return method.invoke(target, args);\n         }\n-        catch (Exception exception){\n+        catch (Exception exception) {\n             throw new JXPathException(\"Cannot invoke \" + method, exception);\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/Compiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Compiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Compiler.java,v 1.4 2002/06/08 22:47:25 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/08 22:47:25 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Compiler.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * produced and consumed by the APIs.  Arguments and return values are\n  * declared as java.lang.Object.\n  * <p>\n- * Since objects returned by Compiler methods are passed as arguments to\n- * other Compiler methods, the descriptions of these methods use virtual\n- * types.  There are four virtual object types: EXPRESSION, QNAME, STEP and NODE_TEST.\n+ * Since  objects returned by Compiler methods are passed as arguments to other\n+ * Compiler methods, the descriptions of these methods use virtual types.  There\n+ * are four virtual object types: EXPRESSION, QNAME, STEP and NODE_TEST.\n  * <p>\n  * The following example illustrates this notion.  This sequence compiles\n  * the xpath \"foo[round(1 div 2)]/text()\":\n  *      Object expr1 = compiler.number(\"1\");\n  *      Object expr2 = compiler.number(\"2\");\n  *      Object expr3 = compiler.div(expr1, expr2);\n- *      Object expr4 = compiler.coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});\n+ *      Object expr4 = compiler.\n+ *              coreFunction(Compiler.FUNCTION_ROUND, new Object[]{expr3});\n  *      Object test1 = compiler.nodeNameTest(qname1);\n- *      Object step1 = compiler.step(Compiler.AXIS_CHILD, test1, new Object[]{expr4});\n+ *      Object step1 = compiler.\n+ *              step(Compiler.AXIS_CHILD, test1, new Object[]{expr4});\n  *      Object test2 = compiler.nodeTypeTest(Compiler.NODE_TYPE_TEXT);\n  *      Object step2 = compiler.nodeTypeTest(Compiler.AXIS_CHILD, test2, null);\n  *      Object expr5 = compiler.locationPath(false, new Object[]{step1, step2});\n  * </pre></blockquote>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/06/08 22:47:25 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public interface Compiler {\n \n     Object minus(Object left, Object right);\n \n     /**\n-     * Produces an EXPRESSION object representing <i>left</i> multiplied by <i>right</i>\n+     * Produces  an EXPRESSION object representing <i>left</i> multiplied by\n+     * <i>right</i>\n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n     Object multiply(Object left, Object right);\n \n     /**\n-     * Produces an EXPRESSION object representing <i>left</i> divided by <i>right</i>\n+     * Produces  an EXPRESSION object representing <i>left</i> divided by\n+     * <i>right</i>\n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n     Object divide(Object left, Object right);\n \n     /**\n-     * Produces an EXPRESSION object representing <i>left</i> modulo <i>right</i>\n+     * Produces  an EXPRESSION object representing <i>left</i> modulo\n+     * <i>right</i>\n      *\n      * @param left is an EXPRESSION object\n      * @param right is an EXPRESSION object\n     Object nodeTypeTest(int nodeType);\n \n     /**\n-     * Produces a NODE_TEST object that represents a processing instruction test.\n+     * Produces  a NODE_TEST object that represents a processing instruction\n+     * test.\n      *\n      * @param qname is a QNAME object\n      */\n      * @param predicates are EXPRESSION objects\n      * @param steps are STEP objects\n      */\n-    Object expressionPath(Object expression, Object[] predicates, Object[] steps);\n+    Object expressionPath(\n+        Object expression,\n+        Object[] predicates,\n+        Object[] steps);\n }\n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.19 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.19 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.20 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.20 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n \n import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.JXPathContext;\n /**\n  * An XPath evaluation context.\n  *\n- * When evaluating a path, a chain of EvalContexts is created, each\n- * context in the chain representing a step of the path. Subclasses of EvalContext\n+ * When  evaluating a path, a chain of EvalContexts is created, each context in\n+ * the chain representing a step of the path. Subclasses of EvalContext\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.19 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.20 $ $Date: 2003/01/11 05:41:22 $\n  */\n public abstract class EvalContext implements ExpressionContext, Iterator {\n     protected EvalContext parentContext;\n \n     // Sorts in the reverse order to the one defined by the Comparable\n     // interface.\n-    private static final Comparator REVERSE_COMPARATOR = new Comparator(){\n-        public int compare(Object o1, Object o2){\n-            return ((Comparable)o2).compareTo(o1);\n+    private static final Comparator REVERSE_COMPARATOR = new Comparator() {\n+        public int compare(Object o1, Object o2) {\n+            return ((Comparable) o2).compareTo(o1);\n         }\n     };\n \n-    public EvalContext(EvalContext parentContext){\n+    public EvalContext(EvalContext parentContext) {\n         this.parentContext = parentContext;\n     }\n \n-    public Pointer getContextNodePointer(){\n+    public Pointer getContextNodePointer() {\n         return getCurrentNodePointer();\n     }\n \n-    public JXPathContext getJXPathContext(){\n+    public JXPathContext getJXPathContext() {\n         return getRootContext().getJXPathContext();\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n      * @return 1 ascending order, -1 descending order,\n      *  0 - does not require ordering\n      */\n-    public int getDocumentOrder(){\n+    public int getDocumentOrder() {\n         // Default behavior: if the parent needs to be ordered,\n         // this one needs to be ordered too\n-        if (parentContext != null && parentContext.getDocumentOrder() != 0){\n+        if (parentContext != null && parentContext.getDocumentOrder() != 0) {\n             return 1;\n         }\n         return 0;\n     /**\n      * Returns true if there are mode nodes matching the context's constraints.\n      */\n-    public boolean hasNext(){\n-        if (pointerIterator != null){\n+    public boolean hasNext() {\n+        if (pointerIterator != null) {\n             return pointerIterator.hasNext();\n         }\n \n-        if (getDocumentOrder() != 0){\n+        if (getDocumentOrder() != 0) {\n             return constructIterator();\n         }\n         else {\n-            if (!done && !hasPerformedIteratorStep){\n+            if (!done && !hasPerformedIteratorStep) {\n                 performIteratorStep();\n             }\n             return !done;\n     /**\n      * Returns the next node pointer in the context\n      */\n-    public Object next(){\n-        if (pointerIterator != null){\n+    public Object next() {\n+        if (pointerIterator != null) {\n             return pointerIterator.next();\n         }\n \n-        if (getDocumentOrder() != 0){\n-            if (!constructIterator()){\n+        if (getDocumentOrder() != 0) {\n+            if (!constructIterator()) {\n                 throw new NoSuchElementException();\n             }\n             return pointerIterator.next();\n         }\n         else {\n-            if (!done && !hasPerformedIteratorStep){\n+            if (!done && !hasPerformedIteratorStep) {\n                 performIteratorStep();\n             }\n-            if (done){\n+            if (done) {\n                 throw new NoSuchElementException();\n             }\n             hasPerformedIteratorStep = false;\n-            return (NodePointer)getCurrentNodePointer().clone();\n+            return (NodePointer) getCurrentNodePointer().clone();\n         }\n     }\n \n     /**\n      * Moves the iterator forward by one position\n      */\n-    private void performIteratorStep(){\n+    private void performIteratorStep() {\n         done = true;\n-        if (position != 0 && nextNode()){\n+        if (position != 0 && nextNode()) {\n             done = false;\n         }\n         else {\n-            while (nextSet()){\n-                if (nextNode()){\n+            while (nextSet()) {\n+                if (nextNode()) {\n                     done = false;\n                     break;\n                 }\n     /**\n      * Operation is not supported\n      */\n-    public void remove(){\n+    public void remove() {\n         throw new UnsupportedOperationException(\n             \"JXPath iterators cannot remove nodes\");\n     }\n \n-    private boolean constructIterator(){\n+    private boolean constructIterator() {\n         HashSet set = new HashSet();\n         ArrayList list = new ArrayList();\n-        while (nextSet()){\n-            while (nextNode()){\n+        while (nextSet()) {\n+            while (nextNode()) {\n                 NodePointer pointer = getCurrentNodePointer();\n-                if (!set.contains(pointer)){\n-                    Pointer cln = (Pointer)pointer.clone();\n+                if (!set.contains(pointer)) {\n+                    Pointer cln = (Pointer) pointer.clone();\n                     set.add(cln);\n                     list.add(cln);\n                 }\n             }\n         }\n-        if (list.isEmpty()){\n+        if (list.isEmpty()) {\n             return false;\n         }\n \n-        if (getDocumentOrder() == 1){\n+        if (getDocumentOrder() == 1) {\n             Collections.sort(list);\n         }\n         else {\n             reset();\n         }\n         List list = new ArrayList();\n-        while (nextSet()){\n+        while (nextSet()) {\n             while (nextNode()) {\n                 list.add(getCurrentNodePointer());\n             }\n      * Returns the root context of the path, which provides easy\n      * access to variables and functions.\n      */\n-    public RootContext getRootContext(){\n-        if (rootContext == null){\n+    public RootContext getRootContext() {\n+        if (rootContext == null) {\n             rootContext = parentContext.getRootContext();\n         }\n         return rootContext;\n     /**\n      * Sets current position = 0, which is the pre-iteration state.\n      */\n-    public void reset(){\n+    public void reset() {\n         position = 0;\n     }\n \n-    public int getCurrentPosition(){\n+    public int getCurrentPosition() {\n         return position;\n     }\n \n      * Returns the first encountered Pointer that matches the current\n      * context's criteria.\n      */\n-    public Pointer getSingleNodePointer(){\n+    public Pointer getSingleNodePointer() {\n         reset();\n-        while(nextSet()){\n-            if (nextNode()){\n+        while (nextSet()) {\n+            if (nextNode()) {\n                 return getCurrentNodePointer();\n             }\n         }\n      * Returns false if the position is out of the node set range.\n      * You can call it with 0 as the position argument to restart the iteration.\n      */\n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n         return true;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n+++ b/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java,v 1.5 2002/11/29 07:22:02 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/11/29 07:22:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/InfoSetUtil.java,v 1.6 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Type conversions, XPath style.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/11/29 07:22:02 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class InfoSetUtil {\n \n     private static final Double ZERO = new Double(0);\n     private static final Double ONE = new Double(1);\n-    private static final Double NaN = new Double(Double.NaN);\n+    private static final Double NOT_A_NUMBER = new Double(Double.NaN);\n \n \n     /**\n      * Converts the supplied object to String\n      */\n-    public static String stringValue(Object object){\n-        if (object instanceof String){\n-            return (String)object;\n-        }\n-        else if (object instanceof Number){\n-            double d = ((Number)object).doubleValue();\n-            long l = ((Number)object).longValue();\n-            if (d == l){\n+    public static String stringValue(Object object) {\n+        if (object instanceof String) {\n+            return (String) object;\n+        }\n+        else if (object instanceof Number) {\n+            double d = ((Number) object).doubleValue();\n+            long l = ((Number) object).longValue();\n+            if (d == l) {\n                 return String.valueOf(l);\n             }\n             return String.valueOf(d);\n         }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? \"true\" : \"false\";\n-        }\n-        else if (object == null){\n+        else if (object instanceof Boolean) {\n+            return ((Boolean) object).booleanValue() ? \"true\" : \"false\";\n+        }\n+        else if (object == null) {\n             return \"\";\n         }\n-        else if (object instanceof NodePointer){\n-            return stringValue(((NodePointer)object).getValue());\n-        }\n-        else if (object instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)object;\n+        else if (object instanceof NodePointer) {\n+            return stringValue(((NodePointer) object).getValue());\n+        }\n+        else if (object instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) object;\n             Pointer ptr = ctx.getSingleNodePointer();\n-            if (ptr != null){\n+            if (ptr != null) {\n                 return stringValue(ptr);\n             }\n             return \"\";\n     /**\n      * Converts the supplied object to Number\n      */\n-    public static Number number(Object object){\n-        if (object instanceof Number){\n-            return (Number)object;\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? ONE : ZERO;\n-        }\n-        else if (object instanceof String){\n+    public static Number number(Object object) {\n+        if (object instanceof Number) {\n+            return (Number) object;\n+        }\n+        else if (object instanceof Boolean) {\n+            return ((Boolean) object).booleanValue() ? ONE : ZERO;\n+        }\n+        else if (object instanceof String) {\n             Double value;\n             try {\n-                value = new Double((String)object);\n-            }\n-            catch (NumberFormatException ex){\n-                value = NaN;\n+                value = new Double((String) object);\n+            }\n+            catch (NumberFormatException ex) {\n+                value = NOT_A_NUMBER;\n             }\n             return value;\n         }\n-        else if (object instanceof EvalContext){\n+        else if (object instanceof EvalContext) {\n             return number(stringValue(object));\n         }\n-        else if (object instanceof NodePointer){\n-            return number(((NodePointer)object).getValue());\n+        else if (object instanceof NodePointer) {\n+            return number(((NodePointer) object).getValue());\n         }\n         return number(stringValue(object));\n     }\n     /**\n      * Converts the supplied object to double\n      */\n-    public static double doubleValue(Object object){\n-        if (object instanceof Number){\n-            return ((Number)object).doubleValue();\n-        }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue() ? 0.0 : 1.0;\n-        }\n-        else if (object instanceof String){\n-            if (object.equals(\"\")){\n+    public static double doubleValue(Object object) {\n+        if (object instanceof Number) {\n+            return ((Number) object).doubleValue();\n+        }\n+        else if (object instanceof Boolean) {\n+            return ((Boolean) object).booleanValue() ? 0.0 : 1.0;\n+        }\n+        else if (object instanceof String) {\n+            if (object.equals(\"\")) {\n                 return 0.0;\n             }\n \n             double value;\n             try {\n-                value = Double.parseDouble((String)object);\n-            }\n-            catch (NumberFormatException ex){\n+                value = Double.parseDouble((String) object);\n+            }\n+            catch (NumberFormatException ex) {\n                 value = Double.NaN;\n             }\n             return value;\n         }\n-        else if (object instanceof NodePointer){\n-            return doubleValue(((NodePointer)object).getValue());\n-        }\n-        else if (object instanceof EvalContext){\n+        else if (object instanceof NodePointer) {\n+            return doubleValue(((NodePointer) object).getValue());\n+        }\n+        else if (object instanceof EvalContext) {\n             return doubleValue(stringValue(object));\n         }\n         return doubleValue(stringValue(object));\n     /**\n      * Converts the supplied object to boolean\n      */\n-    public static boolean booleanValue(Object object){\n-        if (object instanceof Number){\n-            double value = ((Number)object).doubleValue();\n+    public static boolean booleanValue(Object object) {\n+        if (object instanceof Number) {\n+            double value = ((Number) object).doubleValue();\n             return value != 0 && value != -0 && !Double.isNaN(value);\n         }\n-        else if (object instanceof Boolean){\n-            return ((Boolean)object).booleanValue();\n-        }\n-        else if (object instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)object;\n+        else if (object instanceof Boolean) {\n+            return ((Boolean) object).booleanValue();\n+        }\n+        else if (object instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) object;\n             return ctx.nextSet() && ctx.nextNode();\n         }\n-        else if (object instanceof String){\n-            return ((String)object).length() != 0;\n-        }\n-        else if (object instanceof NodePointer){\n-            return ((NodePointer)object).isActual();\n-        }\n-        else if (object == null){\n+        else if (object instanceof String) {\n+            return ((String) object).length() != 0;\n+        }\n+        else if (object instanceof NodePointer) {\n+            return ((NodePointer) object).isActual();\n+        }\n+        else if (object == null) {\n             return false;\n         }\n         return true;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.4 2002/06/16 03:22:21 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/16 03:22:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/06/16 03:22:21 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class JXPathCompiledExpression implements CompiledExpression {\n \n     private String xpath;\n     private Expression expression;\n \n-    public JXPathCompiledExpression(String xpath, Expression expression){\n+    public JXPathCompiledExpression(String xpath, Expression expression) {\n         this.xpath = xpath;\n         this.expression = expression;\n     }\n      * @see CompiledExpression#getValue(JXPathContext)\n      */\n     public Object getValue(JXPathContext context) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     getValue(xpath, expression);\n     }\n \n      * @see CompiledExpression#getValue(JXPathContext, Class)\n      */\n     public Object getValue(JXPathContext context, Class requiredType) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     getValue(xpath, expression, requiredType);\n     }\n \n      * @see CompiledExpression#setValue(JXPathContext, Object)\n      */\n     public void setValue(JXPathContext context, Object value) {\n-        ((JXPathContextReferenceImpl)context).\n+        ((JXPathContextReferenceImpl) context).\n                     setValue(xpath, expression, value);\n     }\n \n      * @see CompiledExpression#createPath(JXPathContext)\n      */\n     public Pointer createPath(JXPathContext context) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     createPath(xpath, expression);\n     }\n \n      * @see CompiledExpression#createPathAndSetValue(JXPathContext, Object)\n      */\n     public Pointer createPathAndSetValue(JXPathContext context, Object value) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     createPathAndSetValue(xpath, expression, value);\n     }\n \n      * @see CompiledExpression#iterate(JXPathContext)\n      */\n     public Iterator iterate(JXPathContext context) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     iterate(xpath, expression);\n     }\n \n      * @see CompiledExpression#getPointer(JXPathContext, String)\n      */\n     public Pointer getPointer(JXPathContext context, String xpath) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     getPointer(xpath, expression);\n     }\n \n      * @see CompiledExpression#iteratePointers(JXPathContext)\n      */\n     public Iterator iteratePointers(JXPathContext context) {\n-        return ((JXPathContextReferenceImpl)context).\n+        return ((JXPathContextReferenceImpl) context).\n                     iteratePointers(xpath, expression);\n     }\n \n     /**\n      * @see CompiledExpression#removePath(JXPathContext)\n      */\n-    public void removePath(JXPathContext context){\n-        ((JXPathContextReferenceImpl)context).removePath(xpath, expression);\n+    public void removePath(JXPathContext context) {\n+        ((JXPathContextReferenceImpl) context).removePath(xpath, expression);\n     }\n \n     /**\n      * @see CompiledExpression#removeAll(JXPathContext)\n      */\n-    public void removeAll(JXPathContext context){\n-        ((JXPathContextReferenceImpl)context).removeAll(xpath, expression);\n+    public void removeAll(JXPathContext context) {\n+        ((JXPathContextReferenceImpl) context).removeAll(xpath, expression);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java,v 1.2 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextFactoryReferenceImpl.java,v 1.3 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Default implementation of JXPathContextFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class JXPathContextFactoryReferenceImpl extends JXPathContextFactory {\n \n-    public JXPathContextFactoryReferenceImpl(){\n+    public JXPathContextFactoryReferenceImpl() {\n     }\n \n-    public JXPathContext newContext(JXPathContext parentContext, Object contextBean) throws JXPathContextFactoryConfigurationError {\n+    public JXPathContext newContext(\n+        JXPathContext parentContext,\n+        Object contextBean)\n+        throws JXPathContextFactoryConfigurationError \n+    {\n         return new JXPathContextReferenceImpl(parentContext, contextBean);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.24 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.24 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.25 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.25 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n \n import java.lang.ref.SoftReference;\n-import java.util.*;\n-\n-import org.apache.commons.jxpath.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+import org.apache.commons.jxpath.CompiledExpression;\n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.Functions;\n+import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.PackageFunctions;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.Variables;\n import org.apache.commons.jxpath.ri.axes.RootContext;\n import org.apache.commons.jxpath.ri.compiler.Expression;\n import org.apache.commons.jxpath.ri.compiler.TreeCompiler;\n  * The reference implementation of JXPathContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.24 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.25 $ $Date: 2003/01/11 05:41:22 $\n  */\n-public class JXPathContextReferenceImpl extends JXPathContext\n-{\n-    private static final Compiler compiler = new TreeCompiler();\n-    private static final Map compiled = new HashMap();\n-    private static final PackageFunctions genericFunctions =\n+public class JXPathContextReferenceImpl extends JXPathContext {\n+    \n+    private static final Compiler COMPILER = new TreeCompiler();\n+    private static Map compiled = new HashMap();\n+    private static final PackageFunctions GENERIC_FUNCTIONS =\n         new PackageFunctions(\"\", null);\n-    private static boolean useSoftCache = true;\n+    private static final boolean USE_SOFT_CACHE = true;\n     private static int cleanupCount = 0;\n     private static Vector nodeFactories = new Vector();\n     private static NodePointerFactory nodeFactoryArray[] = null;\n         Object domFactory = allocateConditionally(\n                 \"org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory\",\n                 \"org.w3c.dom.Node\");\n-        if (domFactory != null){\n+        if (domFactory != null) {\n             nodeFactories.add(domFactory);\n         }\n \n         Object jdomFactory = allocateConditionally(\n                 \"org.apache.commons.jxpath.ri.model.jdom.JDOMPointerFactory\",\n                 \"org.jdom.Document\");\n-        if (jdomFactory != null){\n+        if (jdomFactory != null) {\n             nodeFactories.add(jdomFactory);\n         }\n \n         // DynaBean factory is only registered if BeanUtils are on the classpath\n-        Object dynaBeanFactory = allocateConditionally(\n-                \"org.apache.commons.jxpath.ri.model.dynabeans.DynaBeanPointerFactory\",\n+        Object dynaBeanFactory =\n+            allocateConditionally(\n+                \"org.apache.commons.jxpath.ri.model.dynabeans.\"\n+                    + \"DynaBeanPointerFactory\",\n                 \"org.apache.commons.beanutils.DynaBean\");\n-        if (dynaBeanFactory != null){\n+        if (dynaBeanFactory != null) {\n             nodeFactories.add(dynaBeanFactory);\n         }\n \n     private static final int CLEANUP_THRESHOLD = 500;\n \n     protected JXPathContextReferenceImpl(JXPathContext parentContext,\n-                                         Object contextBean){\n+                                         Object contextBean) \n+    {\n         super(parentContext, contextBean);\n-        synchronized (nodeFactories){\n+        synchronized (nodeFactories) {\n             createNodeFactoryArray();\n         }\n     }\n      * additional types of objects.  Make sure the factory returns\n      * a name that puts it in the right position on the list of factories.\n      */\n-    public static void addNodePointerFactory(NodePointerFactory factory){\n-        synchronized (nodeFactories){\n+    public static void addNodePointerFactory(NodePointerFactory factory) {\n+        synchronized (nodeFactories) {\n             nodeFactories.add(factory);\n             nodeFactoryArray = null;\n         }\n     }\n \n-    public static NodePointerFactory[] getNodePointerFactories(){\n+    public static NodePointerFactory[] getNodePointerFactories() {\n         return nodeFactoryArray;\n     }\n \n-    protected CompiledExpression compilePath(String xpath){\n+    protected CompiledExpression compilePath(String xpath) {\n         return new JXPathCompiledExpression(xpath, compileExpression(xpath));\n     }\n \n-    private static Expression compileExpression(String xpath){\n+    private static Expression compileExpression(String xpath) {\n         Expression expr;\n-        if (useSoftCache){\n+        if (USE_SOFT_CACHE) {\n             expr = null;\n-            SoftReference ref = (SoftReference)compiled.get(xpath);\n-            if (ref != null){\n-                expr = (Expression)ref.get();\n-            }\n-            if (expr == null){\n-                expr = (Expression)Parser.parseExpression(xpath, compiler);\n+            SoftReference ref = (SoftReference) compiled.get(xpath);\n+            if (ref != null) {\n+                expr = (Expression) ref.get();\n+            }\n+            if (expr == null) {\n+                expr = (Expression) Parser.parseExpression(xpath, COMPILER);\n                 compiled.put(xpath, new SoftReference(expr));\n-                if (cleanupCount++ >= CLEANUP_THRESHOLD){\n+                if (cleanupCount++ >= CLEANUP_THRESHOLD) {\n                     cleanupCache();\n                 }\n             }\n         }\n         else {\n-            expr = (Expression)compiled.get(xpath);\n-            if (expr == null){\n-                expr = (Expression)Parser.parseExpression(xpath, compiler);\n+            expr = (Expression) compiled.get(xpath);\n+            if (expr == null) {\n+                expr = (Expression) Parser.parseExpression(xpath, COMPILER);\n                 compiled.put(xpath, expr);\n             }\n         }\n         return expr;\n     }\n \n-    private static void cleanupCache(){\n+    private static void cleanupCache() {\n         Iterator it = compiled.entrySet().iterator();\n-        while (it.hasNext()){\n-            Map.Entry me = (Map.Entry)it.next();\n-            if (((SoftReference)me.getValue()).get() == null){\n+        while (it.hasNext()) {\n+            Map.Entry me = (Map.Entry) it.next();\n+            if (((SoftReference) me.getValue()).get() == null) {\n                 it.remove();\n             }\n         }\n      * Traverses the xpath and returns the resulting object. Primitive\n      * types are wrapped into objects.\n      */\n-    public Object getValue(String xpath){\n+    public Object getValue(String xpath) {\n         return getValue(xpath, compileExpression(xpath));\n     }\n \n-    public Object getValue(String xpath, Expression expr){\n+    public Object getValue(String xpath, Expression expr) {\n         Object result = expr.computeValue(getRootContext());\n         if (result instanceof EvalContext) {\n             EvalContext ctx = (EvalContext) result;\n      * Calls getValue(xpath), converts the result to the required type\n      * and returns the result of the conversion.\n      */\n-    public Object getValue(String xpath, Class requiredType){\n+    public Object getValue(String xpath, Class requiredType) {\n         Expression expr = compileExpression(xpath);\n         return getValue(xpath, expr, requiredType);\n     }\n \n-    public Object getValue(String xpath, Expression expr, Class requiredType){\n+    public Object getValue(String xpath, Expression expr, Class requiredType) {\n         Object value = getValue(xpath, expr);\n-        if (value != null && requiredType != null){\n-            if (!TypeUtils.canConvert(value, requiredType)){\n-                throw new JXPathException(\"Invalid expression type. '\" + xpath +\n-                    \"' returns \" + value.getClass().getName() +\n-                    \". It cannot be converted to \" + requiredType.getName());\n+        if (value != null && requiredType != null) {\n+            if (!TypeUtils.canConvert(value, requiredType)) {\n+                throw new JXPathException(\n+                    \"Invalid expression type. '\"\n+                        + xpath\n+                        + \"' returns \"\n+                        + value.getClass().getName()\n+                        + \". It cannot be converted to \"\n+                        + requiredType.getName());\n             }\n             value = TypeUtils.convert(value, requiredType);\n         }\n      * for the path. If the xpath matches no properties\n      * in the graph, the Iterator will not be null.\n      */\n-    public Iterator iterate(String xpath){\n+    public Iterator iterate(String xpath) {\n         return iterate(xpath, compileExpression(xpath));\n     }\n \n-    public Iterator iterate(String xpath, Expression expr){\n+    public Iterator iterate(String xpath, Expression expr) {\n         return expr.iterate(getRootContext());\n     }\n \n-    public Pointer getPointer(String xpath){\n+    public Pointer getPointer(String xpath) {\n         return getPointer(xpath, compileExpression(xpath));\n     }\n \n-    public Pointer getPointer(String xpath, Expression expr){\n+    public Pointer getPointer(String xpath, Expression expr) {\n         Object result = expr.computeValue(getRootContext());\n-        if (result instanceof EvalContext){\n-            result = ((EvalContext)result).getSingleNodePointer();\n-        }\n-        if (result instanceof Pointer){\n-            if (!lenient && !((NodePointer)result).isActual()){\n+        if (result instanceof EvalContext) {\n+            result = ((EvalContext) result).getSingleNodePointer();\n+        }\n+        if (result instanceof Pointer) {\n+            if (!lenient && !((NodePointer) result).isActual()) {\n                 throw new JXPathException(\"No pointer for xpath: \" + xpath);\n             }\n-            return (Pointer)result;\n+            return (Pointer) result;\n         }\n         else {\n             return NodePointer.newNodePointer(null, result, getLocale());\n         }\n     }\n \n-    public void setValue(String xpath, Object value){\n+    public void setValue(String xpath, Object value) {\n         setValue(xpath, compileExpression(xpath), value);\n     }\n \n \n-    public void setValue(String xpath, Expression expr, Object value){\n+    public void setValue(String xpath, Expression expr, Object value) {\n         try {\n             setValue(xpath, expr, value, false);\n         }\n-        catch (Throwable ex){\n+        catch (Throwable ex) {\n             throw new JXPathException(\n                 \"Exception trying to set value with xpath \" + xpath, ex);\n         }\n     }\n \n-    public Pointer createPath(String xpath){\n+    public Pointer createPath(String xpath) {\n         return createPath(xpath, compileExpression(xpath));\n     }\n \n-    public Pointer createPath(String xpath, Expression expr){\n+    public Pointer createPath(String xpath, Expression expr) {\n         try {\n             Object result = expr.computeValue(getRootContext());\n             Pointer pointer = null;\n \n-            if (result instanceof Pointer){\n-                pointer = (Pointer)result;\n-            }\n-            else if (result instanceof EvalContext){\n-                EvalContext ctx = (EvalContext)result;\n+            if (result instanceof Pointer) {\n+                pointer = (Pointer) result;\n+            }\n+            else if (result instanceof EvalContext) {\n+                EvalContext ctx = (EvalContext) result;\n                 pointer = ctx.getSingleNodePointer();\n             }\n             else {\n                 // This should never happen\n                 throw new JXPathException(\"Expression is not a path:\" + xpath);\n             }\n-            return ((NodePointer)pointer).createPath(this);\n-        }\n-        catch (Throwable ex){\n+            return ((NodePointer) pointer).createPath(this);\n+        }\n+        catch (Throwable ex) {\n+            ex.printStackTrace();\n             throw new JXPathException(\n-                \"Exception trying to create xpath \" + xpath, ex);\n-        }\n-    }\n-\n-    public Pointer createPathAndSetValue(String xpath, Object value){\n+                \"Exception trying to create xpath \" + xpath,\n+                ex);\n+        }\n+    }\n+\n+    public Pointer createPathAndSetValue(String xpath, Object value) {\n         return createPathAndSetValue(xpath, compileExpression(xpath), value);\n     }\n \n-    public Pointer createPathAndSetValue(String xpath, Expression expr, Object value){\n+    public Pointer createPathAndSetValue(\n+        String xpath,\n+        Expression expr,\n+        Object value) \n+    {\n         try {\n             return setValue(xpath, expr, value, true);\n         }\n-        catch (Throwable ex){\n+        catch (Throwable ex) {\n+            ex.printStackTrace();\n             throw new JXPathException(\n-                \"Exception trying to create xpath \" + xpath, ex);\n-        }\n-    }\n-\n-    private Pointer setValue(String xpath, Expression expr, Object value, boolean create){\n+                \"Exception trying to create xpath \" + xpath,\n+                ex);\n+        }\n+    }\n+\n+    private Pointer setValue(\n+        String xpath,\n+        Expression expr,\n+        Object value,\n+        boolean create) \n+    {\n         Object result = expr.computeValue(getRootContext());\n-//        System.err.println(\"RESULT: \" + result);\n+        //        System.err.println(\"RESULT: \" + result);\n         Pointer pointer = null;\n \n-        if (result instanceof Pointer){\n-            pointer = (Pointer)result;\n-        }\n-        else if (result instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)result;\n+        if (result instanceof Pointer) {\n+            pointer = (Pointer) result;\n+        }\n+        else if (result instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) result;\n             pointer = ctx.getSingleNodePointer();\n         }\n         else {\n             // This should never happen\n             throw new JXPathException(\"Cannot set value for xpath: \" + xpath);\n         }\n-        if (create){\n-            pointer = ((NodePointer)pointer).createPath(this, value);\n+        if (create) {\n+            pointer = ((NodePointer) pointer).createPath(this, value);\n         }\n         else {\n             pointer.setValue(value);\n      * If the xpath matches no properties\n      * in the graph, the Iterator be empty, but not null.\n      */\n-    public Iterator iteratePointers(String xpath){\n+    public Iterator iteratePointers(String xpath) {\n         return iteratePointers(xpath, compileExpression(xpath));\n     }\n \n-    public Iterator iteratePointers(String xpath, Expression expr){\n+    public Iterator iteratePointers(String xpath, Expression expr) {\n         return expr.iteratePointers(getRootContext());\n     }\n \n-    public void removePath(String xpath){\n+    public void removePath(String xpath) {\n         removePath(xpath, compileExpression(xpath));\n     }\n \n-    public void removePath(String xpath, Expression expr){\n+    public void removePath(String xpath, Expression expr) {\n         try {\n-            NodePointer pointer = (NodePointer)getPointer(xpath, expr);\n-            if (pointer != null){\n-                ((NodePointer)pointer).remove();\n-            }\n-        }\n-        catch (Throwable ex){\n+            NodePointer pointer = (NodePointer) getPointer(xpath, expr);\n+            if (pointer != null) {\n+                ((NodePointer) pointer).remove();\n+            }\n+        }\n+        catch (Throwable ex) {\n             throw new JXPathException(\n-                \"Exception trying to remove xpath \" + xpath, ex);\n-        }\n-    }\n-\n-    public void removeAll(String xpath){\n+                \"Exception trying to remove xpath \" + xpath,\n+                ex);\n+        }\n+    }\n+\n+    public void removeAll(String xpath) {\n         removeAll(xpath, compileExpression(xpath));\n     }\n \n-    public void removeAll(String xpath, Expression expr){\n+    public void removeAll(String xpath, Expression expr) {\n         try {\n             ArrayList list = new ArrayList();\n             Iterator it = expr.iterate(getRootContext());\n-            while (it.hasNext()){\n+            while (it.hasNext()) {\n                 list.add(it.next());\n             }\n             Collections.sort(list);\n-            for (int i = list.size() - 1; i >= 0; i--){\n-                NodePointer pointer = (NodePointer)list.get(i);\n+            for (int i = list.size() - 1; i >= 0; i--) {\n+                NodePointer pointer = (NodePointer) list.get(i);\n                 pointer.remove();\n             }\n         }\n-        catch (Throwable ex){\n+        catch (Throwable ex) {\n             throw new JXPathException(\n-                \"Exception trying to remove all for xpath \" + xpath, ex);\n-        }\n-    }\n-\n-    public synchronized Pointer getContextPointer(){\n-        if (rootPointer == null){\n+                \"Exception trying to remove all for xpath \" + xpath,\n+                ex);\n+        }\n+    }\n+\n+    public synchronized Pointer getContextPointer() {\n+        if (rootPointer == null) {\n             rootPointer = NodePointer.newNodePointer(new QName(null, \"root\"),\n                 getContextBean(), getLocale());\n         }\n         return rootPointer;\n     }\n \n-    private EvalContext getRootContext(){\n-        return new RootContext(this, (NodePointer)getContextPointer());\n-    }\n-\n-    public NodePointer getVariablePointer(QName name){\n+    private EvalContext getRootContext() {\n+        return new RootContext(this, (NodePointer) getContextPointer());\n+    }\n+\n+    public NodePointer getVariablePointer(QName name) {\n         String varName = name.toString();\n         JXPathContext varCtx = this;\n         Variables vars = null;\n-        while (varCtx != null){\n+        while (varCtx != null) {\n             vars = varCtx.getVariables();\n-            if (vars.isDeclaredVariable(varName)){\n+            if (vars.isDeclaredVariable(varName)) {\n                 break;\n             }\n             varCtx = varCtx.getParentContext();\n             vars = null;\n         }\n-        if (vars != null){\n+        if (vars != null) {\n             return new VariablePointer(vars, name);\n         }\n         else {\n         }\n     }\n \n-    public Function getFunction(QName functionName, Object[] parameters){\n+    public Function getFunction(QName functionName, Object[] parameters) {\n         String namespace = functionName.getPrefix();\n         String name = functionName.getName();\n         JXPathContext funcCtx = this;\n         Function func = null;\n         Functions funcs;\n-        while (funcCtx != null){\n+        while (funcCtx != null) {\n             funcs = funcCtx.getFunctions();\n-            if (funcs != null){\n+            if (funcs != null) {\n                 func = funcs.getFunction(namespace, name, parameters);\n-                if (func != null){\n+                if (func != null) {\n                     return func;\n                 }\n \n                 break;\n             }\n         }\n-        func = genericFunctions.getFunction(namespace, name, parameters);\n-        if (func != null){\n+        func = GENERIC_FUNCTIONS.getFunction(namespace, name, parameters);\n+        if (func != null) {\n             return func;\n         }\n         throw new JXPathException(\n      */\n     public static Object allocateConditionally(\n             String className,\n-            String existenceCheckClassName){\n+            String existenceCheckClassName) \n+    {\n         try {\n             try {\n                 Class.forName(existenceCheckClassName);\n             }\n-            catch (ClassNotFoundException ex){\n+            catch (ClassNotFoundException ex) {\n                 return null;\n             }\n \n             Class cls = Class.forName(className);\n             return cls.newInstance();\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             throw new JXPathException(\"Cannot allocate \" + className, ex);\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/Parser.java\n+++ b/src/java/org/apache/commons/jxpath/ri/Parser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Parser.java,v 1.4 2002/04/26 03:28:37 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/26 03:28:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/Parser.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * XPath parser\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/26 03:28:37 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class Parser {\n \n      * Parses the XPath expression. Throws a JXPathException in case\n      * of a syntax error.\n      */\n-    public static Object parseExpression(String expression, Compiler compiler){\n-        synchronized (parser){\n+    public static Object parseExpression(\n+        String expression,\n+        Compiler compiler) \n+    {\n+        synchronized (parser) {\n             parser.setCompiler(compiler);\n             Object expr = null;\n             try {\n                 expr = parser.parseExpression();\n             }\n             catch (TokenMgrError e) {\n-                throw new JXPathException(\"Invalid XPath: '\"\n-                    + addEscapes(expression)\n-                    + \"'. Invalid symbol '\"\n-                    + addEscapes(String.valueOf(e.getCharacter()))\n-                    + \"' \"\n-                    + describePosition(expression, e.getPosition()));\n+                throw new JXPathException(\n+                    \"Invalid XPath: '\"\n+                        + addEscapes(expression)\n+                        + \"'. Invalid symbol '\"\n+                        + addEscapes(String.valueOf(e.getCharacter()))\n+                        + \"' \"\n+                        + describePosition(expression, e.getPosition()));\n             }\n             catch (ParseException e) {\n-                throw new JXPathException(\"Invalid XPath: '\"\n-                    + addEscapes(expression)\n-                    + \"'. Syntax error \"\n-                    + describePosition(expression, e.currentToken.beginColumn));\n+                throw new JXPathException(\n+                    \"Invalid XPath: '\"\n+                        + addEscapes(expression)\n+                        + \"'. Syntax error \"\n+                        + describePosition(\n+                            expression,\n+                            e.currentToken.beginColumn));\n             }\n             return expr;\n         }\n     }\n \n-    private static String describePosition(String expression, int position){\n-        if (position <= 0){\n+    private static String describePosition(String expression, int position) {\n+        if (position <= 0) {\n             return \"at the beginning of the expression\";\n         }\n-        else if (position >= expression.length()){\n+        else if (position >= expression.length()) {\n             return \"- expression incomplete\";\n         }\n         else {\n         }\n     }\n \n-    private static String addEscapes(String string){\n+    private static String addEscapes(String string) {\n         // Piggy-back on the code generated by JavaCC\n         return TokenMgrError.addEscapes(string);\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/QName.java\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/QName.java,v 1.4 2002/10/13 02:25:36 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/10/13 02:25:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/QName.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:22 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * and an local name.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/10/13 02:25:36 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n  */\n public class QName {\n     private String prefix;\n     private String name;\n \n-    public QName(String qualifiedName){\n+    public QName(String qualifiedName) {\n         int index = qualifiedName.indexOf(':');\n-        if (index == -1){\n+        if (index == -1) {\n             prefix = null;\n             name = qualifiedName;\n         }\n         }\n     }\n \n-    public QName(String prefix, String localName){\n-        if (localName.indexOf(':') != -1){\n-            throw new JXPathException(\"The 'localName' part of a QName cannot contain colons\");\n+    public QName(String prefix, String localName) {\n+        if (localName.indexOf(':') != -1) {\n+            throw new JXPathException(\n+                \"The 'localName' part of a QName cannot contain colons\");\n         }\n         this.prefix = prefix;\n         this.name = localName;\n     }\n \n-    public String getPrefix(){\n+    public String getPrefix() {\n         return prefix;\n     }\n \n-    public String getName(){\n+    public String getName() {\n         return name;\n     }\n \n-    public String toString(){\n-        if (prefix != null){\n+    public String toString() {\n+        if (prefix != null) {\n             return prefix + ':' + name;\n         }\n         return name;\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return name.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (!(object instanceof QName)){\n+    public boolean equals(Object object) {\n+        if (!(object instanceof QName)) {\n             return false;\n         }\n-        if (this == object){\n+        if (this == object) {\n             return true;\n         }\n-        QName that = (QName)object;\n-        if (!this.name.equals(that.name)){\n+        QName that = (QName) object;\n+        if (!this.name.equals(that.name)) {\n             return false;\n         }\n \n-        if ((this.prefix == null && that.prefix != null) ||\n-            (this.prefix != null && !this.prefix.equals(that.prefix))){\n+        if ((this.prefix == null && that.prefix != null)\n+            || (this.prefix != null && !this.prefix.equals(that.prefix))) {\n             return false;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.10 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.11 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.11 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class AncestorContext extends EvalContext {\n     private NodeTest nodeTest;\n \n     /**\n      * @param parentContext represents the previous step on the path\n-     * @param includeSelf differentiates between \"ancestor::\" and \"ancestor-or-self::\" axes\n+     * @param  includeSelf differentiates between \"ancestor::\" and \"ancestor-\n+     * or-self::\" axes\n      * @param nameTest is the name of the element(s) we are looking for\n      */\n-    public AncestorContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest){\n+    public AncestorContext(\n+        EvalContext parentContext,\n+        boolean includeSelf,\n+        NodeTest nodeTest) \n+    {\n         super(parentContext);\n         this.includeSelf = includeSelf;\n         this.nodeTest = nodeTest;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    public int getDocumentOrder(){\n+    public int getDocumentOrder() {\n         return -1;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    public boolean setPosition(int position){\n-        if (position < getCurrentPosition()){\n+    public boolean setPosition(int position) {\n+        if (position < getCurrentPosition()) {\n             reset();\n         }\n \n-        while (getCurrentPosition() < position){\n-            if (!nextNode()){\n+        while (getCurrentPosition() < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean nextNode(){\n-        if (!setStarted){\n+    public boolean nextNode() {\n+        if (!setStarted) {\n             setStarted = true;\n             currentNodePointer = parentContext.getCurrentNodePointer();\n-            if (includeSelf){\n-                if (currentNodePointer.testNode(nodeTest)){\n+            if (includeSelf) {\n+                if (currentNodePointer.testNode(nodeTest)) {\n                     position++;\n                     return true;\n                 }\n             }\n         }\n \n-        while(true){\n+        while (true) {\n             currentNodePointer = currentNodePointer.getParent();\n \n-            if (currentNodePointer == null){\n+            if (currentNodePointer == null) {\n                 return false;\n             }\n \n-            if (currentNodePointer.testNode(nodeTest)){\n+            if (currentNodePointer.testNode(nodeTest)) {\n                 position++;\n                 return true;\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.6 2002/04/28 04:35:48 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/04/28 04:35:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.7 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"attribute::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/04/28 04:35:48 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class AttributeContext extends EvalContext {\n     private NodeTest nodeTest;\n      * @param parentContext represents the previous step on the path\n      * @param nameTest is the name of the attribute we are looking for\n      */\n-    public AttributeContext(EvalContext parentContext, NodeTest nodeTest){\n+    public AttributeContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n-    public boolean setPosition(int position){\n-        if (position < getCurrentPosition()){\n+    public boolean setPosition(int position) {\n+        if (position < getCurrentPosition()) {\n             reset();\n         }\n \n-        while (getCurrentPosition() < position){\n-            if (!nextNode()){\n+        while (getCurrentPosition() < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n-        if (!setStarted){\n+        if (!setStarted) {\n             setStarted = true;\n-            if (!(nodeTest instanceof NodeNameTest)){\n+            if (!(nodeTest instanceof NodeNameTest)) {\n                 return false;\n             }\n-            QName name = ((NodeNameTest)nodeTest).getNodeName();\n-            iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\n+            QName name = ((NodeNameTest) nodeTest).getNodeName();\n+            iterator =\n+                parentContext.getCurrentNodePointer().attributeIterator(name);\n         }\n \n-        if (iterator == null){\n+        if (iterator == null) {\n             return false;\n         }\n-        if (!iterator.setPosition(iterator.getPosition() + 1)){\n+        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n             return false;\n         }\n         currentNodePointer = iterator.getNodePointer();\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.11 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.12 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class ChildContext extends EvalContext {\n     private NodeTest nodeTest;\n     private boolean reverse;\n     private NodeIterator iterator;\n \n-    public ChildContext(EvalContext parentContext, NodeTest nodeTest, boolean startFromParentLocation, boolean reverse){\n+    public ChildContext(\n+        EvalContext parentContext,\n+        NodeTest nodeTest,\n+        boolean startFromParentLocation,\n+        boolean reverse) \n+    {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n         this.startFromParentLocation = startFromParentLocation;\n         this.reverse = reverse;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getCurrentNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n         }\n-        if (iterator != null){\n+        if (iterator != null) {\n             return iterator.getNodePointer();\n         }\n         else {\n      * of the collection.  For example, \"books\" will return the collection\n      * of books rather than the first book from that collection.\n      */\n-    public Pointer getSingleNodePointer(){\n-        if (position == 0){\n-            while(nextSet()){\n+    public Pointer getSingleNodePointer() {\n+        if (position == 0) {\n+            while (nextSet()) {\n                 prepare();\n-                if (iterator == null){\n+                if (iterator == null) {\n                     return null;\n                 }\n                 // See if there is a property there, singular or collection\n                 NodePointer pointer = iterator.getNodePointer();\n-                if (pointer != null){\n+                if (pointer != null) {\n                     return pointer;\n                 }\n             }\n         return getCurrentNodePointer();\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         iterator = null;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         int oldPosition = getCurrentPosition();\n         super.setPosition(position);\n-        if (oldPosition == 0){\n+        if (oldPosition == 0) {\n             prepare();\n         }\n-        if (iterator == null){\n+        if (iterator == null) {\n             return false;\n         }\n         return iterator.setPosition(position);\n     /**\n      * Allocates a PropertyIterator.\n      */\n-    private void prepare(){\n+    private void prepare() {\n         NodePointer parent = parentContext.getCurrentNodePointer();\n-        if (parent == null){\n+        if (parent == null) {\n             return;\n         }\n-        if (startFromParentLocation){\n+        if (startFromParentLocation) {\n             NodePointer pointer = parent.getParent();\n-            while (pointer != null && pointer.isContainer()){\n+            while (pointer != null && pointer.isContainer()) {\n                 pointer = pointer.getParent();\n             }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.10 2002/11/29 06:44:16 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/29 06:44:16 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.11 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/29 06:44:16 $\n+ * @version $Revision: 1.11 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class DescendantContext extends EvalContext {\n     private NodeTest nodeTest;\n     private Stack stack;\n     private NodePointer currentNodePointer;\n     private boolean includeSelf;\n-    private final static NodeTest elementNodeTest =\n+    private static final NodeTest ELEMENT_NODE_TEST =\n             new NodeTypeTest(Compiler.NODE_TYPE_NODE);\n \n     public DescendantContext(\n         this.nodeTest = nodeTest;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getCurrentNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n         }\n         return currentNodePointer;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    public boolean setPosition(int position){\n-        if (position < this.position){\n+    public boolean setPosition(int position) {\n+        if (position < this.position) {\n             reset();\n         }\n \n-        while (this.position < position){\n-            if (!nextNode()){\n+        while (this.position < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         if (!setStarted) {\n             setStarted = true;\n             stack = new Stack();\n                 if (!currentNodePointer.isLeaf()) {\n                     stack.push(\n                         currentNodePointer.childIterator(\n-                            elementNodeTest,\n+                            ELEMENT_NODE_TEST,\n                             false,\n                             null));\n                 }\n                 if (!currentNodePointer.isLeaf()) {\n                     stack.push(\n                         currentNodePointer.childIterator(\n-                            elementNodeTest,\n+                            ELEMENT_NODE_TEST,\n                             false,\n                             null));\n                 }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.8 2002/07/03 21:12:36 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/07/03 21:12:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.9 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * on to the parent context.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/07/03 21:12:36 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class InitialContext extends EvalContext {\n     private boolean startedSet = false;\n     private boolean collection;\n     private NodePointer nodePointer;\n \n-    public InitialContext(EvalContext parentContext){\n+    public InitialContext(EvalContext parentContext) {\n         super(parentContext);\n         nodePointer = parentContext.getCurrentNodePointer();\n-        if (nodePointer != null){\n-            collection = (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n+        if (nodePointer != null) {\n+            collection =\n+                (nodePointer.getIndex() == NodePointer.WHOLE_COLLECTION);\n         }\n     }\n \n-    public Pointer getSingleNodePointer(){\n+    public Pointer getSingleNodePointer() {\n         return nodePointer;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return nodePointer;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n-        if (collection){\n-            if (position >= 1 && position <= nodePointer.getLength()){\n+        if (collection) {\n+            if (position >= 1 && position <= nodePointer.getLength()) {\n                 nodePointer.setIndex(position - 1);\n                 return true;\n             }\n         }\n     }\n \n-    public boolean nextSet(){\n-        if (started){\n+    public boolean nextSet() {\n+        if (started) {\n             return false;\n         }\n         started = true;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.5 2002/04/28 04:35:48 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/04/28 04:35:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.6 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"namespace::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/04/28 04:35:48 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class NamespaceContext extends EvalContext {\n     private NodeTest nodeTest;\n      * @param parentContext represents the previous step on the path\n      * @param nodeTest is the name of the namespace we are looking for\n      */\n-    public NamespaceContext(EvalContext parentContext, NodeTest nodeTest){\n+    public NamespaceContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         setStarted = false;\n         iterator = null;\n         super.reset();\n     }\n \n-    public boolean setPosition(int position){\n-        if (position < getCurrentPosition()){\n+    public boolean setPosition(int position) {\n+        if (position < getCurrentPosition()) {\n             reset();\n         }\n \n-        while (getCurrentPosition() < position){\n-            if (!nextNode()){\n+        while (getCurrentPosition() < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         super.setPosition(getCurrentPosition() + 1);\n-        if (!setStarted){\n+        if (!setStarted) {\n             setStarted = true;\n-            if (!(nodeTest instanceof NodeNameTest)){\n+            if (!(nodeTest instanceof NodeNameTest)) {\n                 return false;\n             }\n \n-            QName testName = ((NodeNameTest)nodeTest).getNodeName();\n-            if (testName.getPrefix() != null){\n+            QName testName = ((NodeNameTest) nodeTest).getNodeName();\n+            if (testName.getPrefix() != null) {\n                 return false;\n             }\n             String testLocalName = testName.getName();\n-            if (testLocalName.equals(\"*\")){\n-                iterator = parentContext.getCurrentNodePointer().namespaceIterator();\n+            if (testLocalName.equals(\"*\")) {\n+                iterator =\n+                    parentContext.getCurrentNodePointer().namespaceIterator();\n             }\n             else {\n-                currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testLocalName);\n+                currentNodePointer =\n+                    parentContext.getCurrentNodePointer().namespacePointer(\n+                        testLocalName);\n                 return currentNodePointer != null;\n             }\n         }\n \n-        if (iterator == null){\n+        if (iterator == null) {\n             return false;\n         }\n-        if (!iterator.setPosition(iterator.getPosition() + 1)){\n+        if (!iterator.setPosition(iterator.getPosition() + 1)) {\n             return false;\n         }\n         currentNodePointer = iterator.getNodePointer();\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.10 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.11 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"parent::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.11 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class ParentContext extends EvalContext {\n     private NodeTest nodeTest;\n     private boolean setStarted = false;\n     private NodePointer currentNodePointer;\n \n-    public ParentContext(EvalContext parentContext, NodeTest nodeTest){\n+    public ParentContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    public int getCurrentPosition(){\n+    public int getCurrentPosition() {\n         return 1;\n     }\n \n-    public int getDocumentOrder(){\n+    public int getDocumentOrder() {\n         return -1;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         setStarted = false;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         super.setPosition(position);\n         return position == 1;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         // Each set contains exactly one node: the parent\n-        if (setStarted){\n+        if (setStarted) {\n             return false;\n         }\n         setStarted = true;\n         NodePointer thisLocation = parentContext.getCurrentNodePointer();\n         currentNodePointer = thisLocation.getParent();\n-        while (currentNodePointer != null && currentNodePointer.isContainer()){\n+        while (currentNodePointer != null\n+            && currentNodePointer.isContainer()) {\n             currentNodePointer = currentNodePointer.getParent();\n         }\n-        if (currentNodePointer != null &&\n-                currentNodePointer.testNode(nodeTest)){\n+        if (currentNodePointer != null\n+            && currentNodePointer.testNode(nodeTest)) {\n             position++;\n             return true;\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.10 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.11 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.11 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n     private NodePointer currentRootLocation;\n     private boolean reverse;\n \n-    public PrecedingOrFollowingContext(EvalContext parentContext, NodeTest nodeTest, boolean reverse){\n+    public PrecedingOrFollowingContext(\n+        EvalContext parentContext,\n+        NodeTest nodeTest,\n+        boolean reverse) \n+    {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n         this.reverse = reverse;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return currentNodePointer;\n     }\n \n-    public int getDocumentOrder(){\n+    public int getDocumentOrder() {\n         return reverse ? -1 : 1;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         stack = new Stack();\n         setStarted = false;\n     }\n \n-    public boolean setPosition(int position){\n-        if (position < this.position){\n+    public boolean setPosition(int position) {\n+        if (position < this.position) {\n             reset();\n         }\n \n-        while (this.position < position){\n-            if (!nextNode()){\n+        while (this.position < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    public boolean nextNode(){\n-        if (!setStarted){\n+    public boolean nextNode() {\n+        if (!setStarted) {\n             setStarted = true;\n             currentRootLocation = parentContext.getCurrentNodePointer();\n-            NodePointer parent = getMaterialPointer(currentRootLocation.getParent());\n-            if (parent != null){\n+            NodePointer parent =\n+                getMaterialPointer(currentRootLocation.getParent());\n+            if (parent != null) {\n                 // TBD: check type\n-                stack.push(parent.childIterator(null, reverse, currentRootLocation));\n-            }\n-        }\n-\n-        while (true){\n-            if (stack.isEmpty()){\n-                currentRootLocation = getMaterialPointer(currentRootLocation.getParent());\n-\n-                if (currentRootLocation == null || currentRootLocation.isRoot()){\n+                stack.push(\n+                    parent.childIterator(null, reverse, currentRootLocation));\n+            }\n+        }\n+\n+        while (true) {\n+            if (stack.isEmpty()) {\n+                currentRootLocation =\n+                    getMaterialPointer(currentRootLocation.getParent());\n+\n+                if (currentRootLocation == null\n+                    || currentRootLocation.isRoot()) {\n                     break;\n                 }\n \n-                NodePointer parent = getMaterialPointer(currentRootLocation.getParent());\n-                if (parent != null){\n-                    stack.push(parent.childIterator(null, reverse, currentRootLocation));\n-                }\n-            }\n-\n-            while (!stack.isEmpty()){\n-                if (!reverse){\n-                    NodeIterator it = (NodeIterator)stack.peek();\n-                    if (it.setPosition(it.getPosition() + 1)){\n+                NodePointer parent =\n+                    getMaterialPointer(currentRootLocation.getParent());\n+                if (parent != null) {\n+                    stack.push(\n+                        parent.childIterator(\n+                            null,\n+                            reverse,\n+                            currentRootLocation));\n+                }\n+            }\n+\n+            while (!stack.isEmpty()) {\n+                if (!reverse) {\n+                    NodeIterator it = (NodeIterator) stack.peek();\n+                    if (it.setPosition(it.getPosition() + 1)) {\n                         currentNodePointer = it.getNodePointer();\n-                        if (!currentNodePointer.isLeaf()){\n-                            stack.push(currentNodePointer.childIterator(null, reverse, null));\n-                        }\n-                        if (currentNodePointer.testNode(nodeTest)){\n+                        if (!currentNodePointer.isLeaf()) {\n+                            stack.push(\n+                                currentNodePointer.childIterator(\n+                                    null,\n+                                    reverse,\n+                                    null));\n+                        }\n+                        if (currentNodePointer.testNode(nodeTest)) {\n                             super.setPosition(getCurrentPosition() + 1);\n                             return true;\n                         }\n                     }\n                     else {\n-                        // We get here only if the name test failed and the iterator ended\n+                        // We get here only if the name test failed \n+                        // and the iterator ended\n                         stack.pop();\n                     }\n                 }\n                 else {\n-                    NodeIterator it = (NodeIterator)stack.peek();\n-                    if (it.setPosition(it.getPosition() + 1)){\n+                    NodeIterator it = (NodeIterator) stack.peek();\n+                    if (it.setPosition(it.getPosition() + 1)) {\n                         currentNodePointer = it.getNodePointer();\n-                        if (!currentNodePointer.isLeaf()){\n-                            stack.push(currentNodePointer.childIterator(null, reverse, null));\n-                        }\n-                        else if (currentNodePointer.testNode(nodeTest)){\n+                        if (!currentNodePointer.isLeaf()) {\n+                            stack.push(\n+                                currentNodePointer.childIterator(\n+                                    null,\n+                                    reverse,\n+                                    null));\n+                        }\n+                        else if (currentNodePointer.testNode(nodeTest)) {\n                             super.setPosition(getCurrentPosition() + 1);\n                             return true;\n                         }\n                     }\n                     else {\n                         stack.pop();\n-                        if (!stack.isEmpty()){\n-                            it = (PropertyIterator)stack.peek();\n+                        if (!stack.isEmpty()) {\n+                            it = (PropertyIterator) stack.peek();\n                             currentNodePointer = it.getNodePointer();\n-                            if (currentNodePointer.testNode(nodeTest)){\n+                            if (currentNodePointer.testNode(nodeTest)) {\n                                 super.setPosition(getCurrentPosition() + 1);\n                                 return true;\n                             }\n     }\n \n     /**\n-     * If the pointer is auxiliary, return the parent; otherwise - the pointer itself\n+     * If  the pointer is auxiliary, return the parent; otherwise - the pointer\n+     * itself\n      */\n-    private NodePointer getMaterialPointer(NodePointer pointer){\n-        while (pointer != null && pointer.isContainer()){\n+    private NodePointer getMaterialPointer(NodePointer pointer) {\n+        while (pointer != null && pointer.isContainer()) {\n             pointer = pointer.getParent();\n         }\n         return pointer;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.16 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.16 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.17 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.17 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.16 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.17 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n     private Expression nameTestExpression;\n     private PropertyPointer dynamicPropertyPointer;\n \n-    public PredicateContext(EvalContext parentContext, Expression expression){\n+    public PredicateContext(EvalContext parentContext, Expression expression) {\n         super(parentContext);\n         this.expression = expression;\n-        if (expression instanceof NameAttributeTest){\n+        if (expression instanceof NameAttributeTest) {\n             nameTestExpression =\n-                ((NameAttributeTest)expression).getNameTestExpression();\n-        }\n-    }\n-\n-    public boolean nextNode(){\n+                ((NameAttributeTest) expression).getNameTestExpression();\n+        }\n+    }\n+\n+    public boolean nextNode() {\n         if (done) {\n             return false;\n         }\n      * Used for an optimized access to dynamic properties using the\n      * \"map[@name = 'name']\" syntax\n      */\n-    private boolean setupDynamicPropertyPointer(){\n-        if (nameTestExpression == null){\n+    private boolean setupDynamicPropertyPointer() {\n+        if (nameTestExpression == null) {\n             return false;\n         }\n \n         NodePointer parent = parentContext.getCurrentNodePointer();\n-        if (parent == null){\n+        if (parent == null) {\n             return false;\n         }\n         parent = parent.getValuePointer();\n-        if (!(parent instanceof PropertyOwnerPointer)){\n+        if (!(parent instanceof PropertyOwnerPointer)) {\n             return false;\n         }\n         dynamicPropertyPointer =\n-            ((PropertyOwnerPointer)parent).getPropertyPointer();\n+            ((PropertyOwnerPointer) parent).getPropertyPointer();\n         return true;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         if (nameTestExpression == null) {\n             return setPositionStandard(position);\n         }\n         }\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getCurrentNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n         }\n-        if (dynamicPropertyPointer != null){\n+        if (dynamicPropertyPointer != null) {\n             return dynamicPropertyPointer.getValuePointer();\n         }\n         else {\n         }\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         done = false;\n     }\n \n-    public boolean nextSet(){\n+    public boolean nextSet() {\n         reset();\n         return parentContext.nextSet();\n     }\n \n-    private boolean setPositionStandard(int position){\n-        if (this.position > position){\n+    private boolean setPositionStandard(int position) {\n+        if (this.position > position) {\n             reset();\n         }\n \n-        while (this.position < position){\n-            if (!nextNode()){\n+        while (this.position < position) {\n+            if (!nextNode()) {\n                 return false;\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.8 2002/06/08 22:45:25 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/06/08 22:45:25 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.9 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * EvalContext that is used to hold the root node for the path traversal.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/06/08 22:45:25 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class RootContext extends EvalContext {\n     private boolean startedSet = false;\n     public static final Object UNKNOWN_VALUE = new Object();\n     private static final int MAX_REGISTER = 4;\n \n-    public RootContext(JXPathContextReferenceImpl parent, NodePointer pointer){\n+    public RootContext(JXPathContextReferenceImpl parent, NodePointer pointer) {\n         super(null);\n         this.parent = parent;\n         this.pointer = pointer;\n     }\n \n-    public JXPathContext getJXPathContext(){\n+    public JXPathContext getJXPathContext() {\n         return parent;\n     }\n \n-    public RootContext getRootContext(){\n+    public RootContext getRootContext() {\n         return this;\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n+    public NodePointer getCurrentNodePointer() {\n         return pointer;\n     }\n \n-    public int getCurrentPosition(){\n+    public int getCurrentPosition() {\n         return 1;\n     }\n \n-    public boolean nextNode(){\n-        if (started){\n+    public boolean nextNode() {\n+        if (started) {\n             return false;\n         }\n         started = true;\n         return true;\n     }\n \n-    public boolean nextSet(){\n-        if (startedSet){\n+    public boolean nextSet() {\n+        if (startedSet) {\n             return false;\n         }\n         startedSet = true;\n         return true;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         return position == 1;\n     }\n \n-    public EvalContext getConstantContext(Object constant){\n+    public EvalContext getConstantContext(Object constant) {\n         NodePointer pointer;\n-        if (constant instanceof NodePointer){\n-            pointer = (NodePointer)constant;\n+        if (constant instanceof NodePointer) {\n+            pointer = (NodePointer) constant;\n         }\n         else {\n-            pointer = NodePointer.newNodePointer(new QName(null, \"\"), constant, null);\n+            pointer =\n+                NodePointer.newNodePointer(new QName(null, \"\"), constant, null);\n         }\n         return new InitialContext(new RootContext(parent, pointer));\n     }\n \n-    public EvalContext getVariableContext(QName variableName){\n-        return new InitialContext(new RootContext(parent, parent.getVariablePointer(variableName)));\n+    public EvalContext getVariableContext(QName variableName) {\n+        return new InitialContext(\n+            new RootContext(parent, parent.getVariablePointer(variableName)));\n     }\n \n-    public Function getFunction(QName functionName, Object[] parameters){\n+    public Function getFunction(QName functionName, Object[] parameters) {\n         return parent.getFunction(functionName, parameters);\n     }\n \n-    public Object getRegisteredValue(int id){\n-        if (registers == null || id >= MAX_REGISTER || id == -1){\n+    public Object getRegisteredValue(int id) {\n+        if (registers == null || id >= MAX_REGISTER || id == -1) {\n             return UNKNOWN_VALUE;\n         }\n         return registers[id];\n     }\n \n-    public int setRegisteredValue(Object value){\n-        if (registers == null){\n+    public int setRegisteredValue(Object value) {\n+        if (registers == null) {\n             registers = new Object[MAX_REGISTER];\n-            for (int i = 0; i < MAX_REGISTER; i++){\n+            for (int i = 0; i < MAX_REGISTER; i++) {\n                 registers[i] = UNKNOWN_VALUE;\n             }\n         }\n-        if (availableRegister >= MAX_REGISTER){\n+        if (availableRegister >= MAX_REGISTER) {\n             return -1;\n         }\n         registers[availableRegister] = value;\n         availableRegister++;\n-        return availableRegister-1;\n+        return availableRegister - 1;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return super.toString() + \":\" + pointer.asPath();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.8 2002/07/03 21:12:36 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/07/03 21:12:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.9 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * EvalContext that returns the current node from the parent context if the test succeeds.\n+ * EvalContext  that returns the current node from the parent context if the\n+ * test succeeds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/07/03 21:12:36 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class SelfContext extends EvalContext {\n     private NodeTest nodeTest;\n     private boolean startedSet = false;\n     private NodePointer nodePointer;\n \n-    public SelfContext(EvalContext parentContext, NodeTest nodeTest){\n+    public SelfContext(EvalContext parentContext, NodeTest nodeTest) {\n         super(parentContext);\n         this.nodeTest = nodeTest;\n     }\n \n-    public Pointer getSingleNodePointer(){\n+    public Pointer getSingleNodePointer() {\n         return parentContext.getSingleNodePointer();\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getCurrentNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n         }\n         return nodePointer;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         return setPosition(getCurrentPosition() + 1);\n     }\n \n-    public void reset(){\n+    public void reset() {\n         super.reset();\n         startedSet = false;\n     }\n \n-    public boolean setPosition(int position){\n-        if (position != 1){\n+    public boolean setPosition(int position) {\n+        if (position != 1) {\n             return false;\n         }\n         super.setPosition(position);\n-        if (!startedSet){\n+        if (!startedSet) {\n             startedSet = true;\n-            nodePointer = (NodePointer)parentContext.getCurrentNodePointer();\n+            nodePointer = (NodePointer) parentContext.getCurrentNodePointer();\n         }\n \n-        if (nodePointer == null){\n+        if (nodePointer == null) {\n             return false;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n-import java.util.*;\n-\n-import org.apache.commons.jxpath.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.jxpath.JXPathException;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.InfoSetUtil;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.ri.compiler.NameAttributeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.compiler.Step;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.InfoSetUtil;\n+import org.apache.commons.jxpath.ri.model.beans.LangAttributePointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullElementPointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n \n /**\n  * An evaluation mechanism for simple XPaths, which\n     {\n //        PATH = createNullPointerForPredicates(context, root,\n //                    steps, -1, predicates, 0).toString();  // Debugging\n-        NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0);\n+        NodePointer pointer =\n+            doPredicate(context, root, steps, -1, predicates, 0);\n //        return valuePointer(pointer);\n         return pointer;\n     }\n      */\n     private static NodePointer doStep(\n             EvalContext context, NodePointer parent,\n-            Step steps[], int current_step)\n-    {\n-        if (parent == null){\n+            Step steps[], int currentStep)\n+    {\n+        if (parent == null) {\n             return null;\n         }\n \n-        if (current_step == steps.length){\n+        if (currentStep == steps.length) {\n             // We have reached the end of the list of steps\n             return parent;\n         }\n         // Open all containers\n         parent = valuePointer(parent);\n         \n-        Step step = steps[current_step];\n+        Step step = steps[currentStep];\n         Expression predicates[] = step.getPredicates();\n \n         // Divide and conquer: the process is broken out into\n         // 4. Current step has predicates and\n         //    the root is an InfoSet standard node (e.g. DOM Node)\n \n-        if (parent instanceof PropertyOwnerPointer){\n-            if (predicates == null || predicates.length == 0){\n-                return doStep_noPredicates_propertyOwner(\n-                    context, (PropertyOwnerPointer)parent, steps, current_step);\n+        if (parent instanceof PropertyOwnerPointer) {\n+            if (predicates == null || predicates.length == 0) {\n+                return doStepNoPredicatesPropertyOwner(\n+                    context,\n+                    (PropertyOwnerPointer) parent,\n+                    steps,\n+                    currentStep);\n             }\n             else {\n-                return doStep_predicates_propertyOwner(\n-                    context, (PropertyOwnerPointer)parent, steps, current_step);\n+                return doStepPredicatesPropertyOwner(\n+                    context,\n+                    (PropertyOwnerPointer) parent,\n+                    steps,\n+                    currentStep);\n             }\n         }\n         else {\n-            if (predicates == null || predicates.length == 0){\n-                 return doStep_noPredicates_standard(\n-                    context, parent, steps, current_step);\n+            if (predicates == null || predicates.length == 0) {\n+                return doStepNoPredicatesStandard(\n+                    context,\n+                    parent,\n+                    steps,\n+                    currentStep);\n             }\n             else {\n-                return doStep_predicates_standard(\n-                    context, parent, steps, current_step);\n+                return doStepPredicatesStandard(\n+                    context,\n+                    parent,\n+                    steps,\n+                    currentStep);\n             }\n         }\n     }\n      * has the longest chain of steps mapping to existing nodes and the shortes\n      * tail of Null* pointers.\n      */\n-    private static NodePointer doStep_noPredicates_propertyOwner(\n+    private static NodePointer doStepNoPredicatesPropertyOwner(\n                 EvalContext context, PropertyOwnerPointer parentPointer,\n-                Step[] steps, int current_step)\n-    {\n-        Step step = steps[current_step];\n-        NodePointer childPointer = createChildPointerForStep(parentPointer, step);\n-\n-        if (!childPointer.isActual()){\n+                Step[] steps, int currentStep)\n+    {\n+        Step step = steps[currentStep];\n+        NodePointer childPointer =\n+            createChildPointerForStep(parentPointer, step);\n+\n+        if (!childPointer.isActual()) {\n             // The property does not exist - create a null pointer.\n             return createNullPointer(\n-                            context, parentPointer, steps, current_step);\n-        }\n-        else if (current_step == steps.length - 1){\n+                context,\n+                parentPointer,\n+                steps,\n+                currentStep);\n+        }\n+        else if (currentStep == steps.length - 1) {\n             // If this is the last step - we are done, we found it\n             return childPointer;\n         }\n-        else if (childPointer.isCollection()){\n+        else if (childPointer.isCollection()) {\n             // Iterate over all values and\n             // execute remaining steps for each node,\n             // looking for the best quality match\n             int bestQuality = 0;\n             NodePointer bestMatch = null;\n             int count = childPointer.getLength();\n-            for (int i = 0; i < count; i++){\n+            for (int i = 0; i < count; i++) {\n                 childPointer.setIndex(i);\n-                NodePointer pointer = doStep(\n-                        context, childPointer, steps, current_step + 1);\n+                NodePointer pointer =\n+                    doStep(context, childPointer, steps, currentStep + 1);\n                 int quality = computeQuality(pointer);\n-                if (quality == PERFECT_MATCH){\n+                if (quality == PERFECT_MATCH) {\n                     return pointer;\n                 }\n-                else if (quality > bestQuality){\n+                else if (quality > bestQuality) {\n                     bestQuality = quality;\n-                    bestMatch = (NodePointer)pointer.clone();\n-                }\n-            }\n-            if (bestMatch != null){\n+                    bestMatch = (NodePointer) pointer.clone();\n+                }\n+            }\n+            if (bestMatch != null) {\n                 return bestMatch;\n             }\n             // This step did not find anything - return a null pointer\n-            return createNullPointer(\n-                        context, childPointer, steps, current_step);\n+            return createNullPointer(context, childPointer, steps, currentStep);\n         }\n         else {\n             // Evaluate subsequent steps\n-            return doStep(\n-                       context, childPointer, steps, current_step + 1);\n+            return doStep(context, childPointer, steps, currentStep + 1);\n         }\n     }\n \n      * has the longest chain of steps mapping to existing nodes and the shortes\n      * tail of Null* pointers.\n      */\n-    private static NodePointer doStep_noPredicates_standard(\n+    private static NodePointer doStepNoPredicatesStandard(\n                 EvalContext context, NodePointer parentPointer,\n-                Step[] steps, int current_step)\n-    {\n-        Step step = steps[current_step];\n-\n-        if (step.getAxis() == Compiler.AXIS_SELF){\n-            return doStep(context, parentPointer, steps, current_step + 1);\n+                Step[] steps, int currentStep)\n+    {\n+        Step step = steps[currentStep];\n+\n+        if (step.getAxis() == Compiler.AXIS_SELF) {\n+            return doStep(context, parentPointer, steps, currentStep + 1);\n         }\n \n         int bestQuality = 0;\n         NodePointer bestMatch = null;\n         NodeIterator it = getNodeIterator(parentPointer, step);\n-        if (it != null){\n-            for (int i = 1; it.setPosition(i); i++){\n+        if (it != null) {\n+            for (int i = 1; it.setPosition(i); i++) {\n                 NodePointer childPointer = it.getNodePointer();\n-                if (steps.length == current_step + 1){\n+                if (steps.length == currentStep + 1) {\n                     // If this is the last step - we are done, we found it\n                     return childPointer;\n                 }\n                 NodePointer pointer = doStep(\n-                        context, childPointer, steps, current_step + 1);\n+                        context, childPointer, steps, currentStep + 1);\n                 int quality = computeQuality(pointer);\n-                if (quality == PERFECT_MATCH){\n+                if (quality == PERFECT_MATCH) {\n                     return pointer;\n                 }\n-                else if (quality > bestQuality){\n+                else if (quality > bestQuality) {\n                     bestQuality = quality;\n-                    bestMatch = (NodePointer)pointer.clone();\n-                }\n-            }\n-        }\n-\n-        if (bestMatch != null){\n+                    bestMatch = (NodePointer) pointer.clone();\n+                }\n+            }\n+        }\n+\n+        if (bestMatch != null) {\n             return bestMatch;\n         }\n \n         return createNullPointer(\n-                context, parentPointer, steps, current_step);\n+                context, parentPointer, steps, currentStep);\n     }\n \n     /**\n      * the first predicate in a special way and then forwards to\n      * a general predicate processing method.\n      */\n-    private static NodePointer doStep_predicates_propertyOwner(\n+    private static NodePointer doStepPredicatesPropertyOwner(\n             EvalContext context, PropertyOwnerPointer parentPointer,\n-            Step[] steps, int current_step)\n-    {\n-        Step step = steps[current_step];\n+            Step[] steps, int currentStep)\n+    {\n+        Step step = steps[currentStep];\n         Expression predicates[] = step.getPredicates();\n \n         NodePointer childPointer =\n-                createChildPointerForStep(parentPointer, step);\n-        if (!childPointer.isActual()){\n+            createChildPointerForStep(parentPointer, step);\n+        if (!childPointer.isActual()) {\n             // Property does not exist - return a null pointer\n             return createNullPointer(\n-                        context, parentPointer, steps, current_step);\n+                context,\n+                parentPointer,\n+                steps,\n+                currentStep);\n         }\n \n         // Evaluate predicates\n         return doPredicate(\n-            context, childPointer, steps, current_step, predicates, 0);\n+            context,\n+            childPointer,\n+            steps,\n+            currentStep,\n+            predicates,\n+            0);\n     }\n \n     private static NodePointer createChildPointerForStep(\n                 PropertyOwnerPointer parentPointer, Step step)\n     {\n         int axis = step.getAxis();\n-        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE){\n+        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n             NodePointer childPointer;\n-            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n-            if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)){\n+            QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n+            if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) {\n                 childPointer = new LangAttributePointer(parentPointer);\n             }\n             else {\n                 childPointer = parentPointer.getPropertyPointer();\n-                ((PropertyPointer)childPointer).setPropertyName(name.toString());\n+                ((PropertyPointer) childPointer).setPropertyName(\n+                    name.toString());\n                 childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n             }\n             return childPointer;\n      * The method evaluates the first predicate in a special way and\n      * then forwards to a general predicate processing method.\n      */\n-    private static NodePointer doStep_predicates_standard(\n+    private static NodePointer doStepPredicatesStandard(\n             EvalContext context, NodePointer parent,\n-            Step[] steps, int current_step)\n-    {\n-        Step step = steps[current_step];\n+            Step[] steps, int currentStep)\n+    {\n+        Step step = steps[currentStep];\n         Expression predicates[] = step.getPredicates();\n \n         int axis = step.getAxis();\n-        if (axis == Compiler.AXIS_SELF){\n-            return doPredicate(context, parent,\n-                steps, current_step, predicates, 0);\n+        if (axis == Compiler.AXIS_SELF) {\n+            return doPredicate(\n+                context,\n+                parent,\n+                steps,\n+                currentStep,\n+                predicates,\n+                0);\n         }\n \n         Expression predicate = predicates[0];\n         // in the case of a simple subscript predecate\n         // It is a very common use case, so it deserves individual\n         // attention\n-        if (predicates.length == 1){\n+        if (predicates.length == 1) {\n             NodeIterator it = getNodeIterator(parent, step);\n             NodePointer pointer = null;\n-            if (it != null){\n-                if (predicate instanceof NameAttributeTest){ // [@name = key]\n+            if (it != null) {\n+                if (predicate instanceof NameAttributeTest) { // [@name = key]\n                     String key = keyFromPredicate(context, predicate);\n-                    for (int i = 1; it.setPosition(i); i++){\n+                    for (int i = 1; it.setPosition(i); i++) {\n                         NodePointer ptr = it.getNodePointer();\n-                        if (isNameAttributeEqual(ptr, key)){\n+                        if (isNameAttributeEqual(ptr, key)) {\n                             pointer = ptr;\n                             break;\n                         }\n                 }\n                 else {\n                     int index = indexFromPredicate(context, predicate);\n-                    if (it.setPosition(index + 1)){\n+                    if (it.setPosition(index + 1)) {\n                         pointer = it.getNodePointer();\n                     }\n                 }\n             }\n-            if (pointer != null){\n-                return doStep(context, pointer, steps, current_step + 1);\n+            if (pointer != null) {\n+                return doStep(context, pointer, steps, currentStep + 1);\n             }\n         }\n         else {\n             NodeIterator it = getNodeIterator(parent, step);\n-            if (it != null){\n+            if (it != null) {\n                 List list = new ArrayList();\n-                for (int i = 1; it.setPosition(i); i++){\n+                for (int i = 1; it.setPosition(i); i++) {\n                     list.add(it.getNodePointer());\n                 }\n-                NodePointer pointer = doPredicates_standard(context, list,\n-                    steps, current_step, predicates, 0);\n-                if (pointer != null){\n+                NodePointer pointer =\n+                    doPredicatesStandard(\n+                        context,\n+                        list,\n+                        steps,\n+                        currentStep,\n+                        predicates,\n+                        0);\n+                if (pointer != null) {\n                     return pointer;\n                 }\n             }\n         }\n-        return createNullPointer(\n-                    context, parent, steps, current_step);\n+        return createNullPointer(context, parent, steps, currentStep);\n     }\n \n     /**\n      */\n     private static NodePointer doPredicate(\n                 EvalContext context, NodePointer parent,\n-                Step[] steps, int current_step,\n-                Expression predicates[], int current_predicate)\n-    {\n-        if (current_predicate == predicates.length){\n-            return doStep(context, parent, steps, current_step + 1);\n-        }\n-\n-        Expression predicate = predicates[current_predicate];\n-        if (predicate instanceof NameAttributeTest){ // [@name = key1]\n-            return doPredicate_name(context, parent,\n-                    steps, current_step, predicates, current_predicate);\n-        }\n-        else {      // [index]\n-            return doPredicate_index(context, parent,\n-                    steps, current_step, predicates, current_predicate);\n-        }\n-    }\n-\n-    private static NodePointer doPredicate_name(\n+                Step[] steps, int currentStep,\n+                Expression predicates[], int currentPredicate)\n+    {\n+        if (currentPredicate == predicates.length) {\n+            return doStep(context, parent, steps, currentStep + 1);\n+        }\n+\n+        Expression predicate = predicates[currentPredicate];\n+        if (predicate instanceof NameAttributeTest) { // [@name = key1]\n+            return doPredicateName(\n+                context,\n+                parent,\n+                steps,\n+                currentStep,\n+                predicates,\n+                currentPredicate);\n+        }\n+        else { // [index]\n+            return doPredicateIndex(\n+                context,\n+                parent,\n+                steps,\n+                currentStep,\n+                predicates,\n+                currentPredicate);\n+        }\n+    }\n+\n+    private static NodePointer doPredicateName(\n             EvalContext context, NodePointer parent,\n-            Step[] steps, int current_step,\n-            Expression[] predicates, int current_predicate)\n-    {\n-        Expression predicate = predicates[current_predicate];\n+            Step[] steps, int currentStep,\n+            Expression[] predicates, int currentPredicate)\n+    {\n+        Expression predicate = predicates[currentPredicate];\n         String key = keyFromPredicate(context, predicate);\n         NodePointer child = valuePointer(parent);\n-        if (child instanceof PropertyOwnerPointer){\n+        if (child instanceof PropertyOwnerPointer) {\n             PropertyPointer pointer =\n-               ((PropertyOwnerPointer)child).getPropertyPointer();\n+                ((PropertyOwnerPointer) child).getPropertyPointer();\n             pointer.setPropertyName(key);\n-            if (pointer.isActual()){\n+            if (pointer.isActual()) {\n                 return doPredicate(\n-                        context, pointer, steps, current_step,\n-                        predicates, current_predicate + 1);\n-            }\n-        }\n-        else if (child.isCollection()){\n+                    context,\n+                    pointer,\n+                    steps,\n+                    currentStep,\n+                    predicates,\n+                    currentPredicate + 1);\n+            }\n+        }\n+        else if (child.isCollection()) {\n             // For each node in the collection, perform the following:\n             // if the node is a property owner, apply this predicate to it;\n             // if the node is a collection, apply this predicate to each elem.;\n             NodePointer bestMatch = null;\n             int bestQuality = 0;\n             int count = child.getLength();\n-            for (int i = 0; i < count; i++){\n+            for (int i = 0; i < count; i++) {\n                 child.setIndex(i);\n                 NodePointer valuePointer = valuePointer(child);\n-                if (valuePointer == child){\n-                    valuePointer = (NodePointer)child.clone();\n+                if (valuePointer == child) {\n+                    valuePointer = (NodePointer) child.clone();\n                 }\n                 NodePointer pointer;\n-                if ((valuePointer instanceof PropertyOwnerPointer) ||\n-                        valuePointer.isCollection()){\n-                    pointer = doPredicate_name(\n-                            context, valuePointer, steps, current_step,\n-                            predicates, current_predicate);\n-                }\n-                else if (isNameAttributeEqual(valuePointer, key)){\n-                    pointer = doPredicate(\n-                            context, valuePointer, steps, current_step,\n-                            predicates, current_predicate + 1);\n+                if ((valuePointer instanceof PropertyOwnerPointer)\n+                    || valuePointer.isCollection()) {\n+                    pointer =\n+                        doPredicateName(\n+                            context,\n+                            valuePointer,\n+                            steps,\n+                            currentStep,\n+                            predicates,\n+                            currentPredicate);\n+                }\n+                else if (isNameAttributeEqual(valuePointer, key)) {\n+                    pointer =\n+                        doPredicate(\n+                            context,\n+                            valuePointer,\n+                            steps,\n+                            currentStep,\n+                            predicates,\n+                            currentPredicate + 1);\n                 }\n                 else {\n                     pointer = null;\n                 }\n-                if (pointer != null){\n+                if (pointer != null) {\n                     int quality = computeQuality(pointer);\n-                    if (quality == PERFECT_MATCH){\n+                    if (quality == PERFECT_MATCH) {\n                         return pointer;\n                     }\n-                    if (quality > bestQuality){\n-                        bestMatch = (NodePointer)pointer.clone();\n+                    if (quality > bestQuality) {\n+                        bestMatch = (NodePointer) pointer.clone();\n                         bestQuality = quality;\n                     }\n                 }\n             }\n-            if (bestMatch != null){\n+            if (bestMatch != null) {\n                 return bestMatch;\n             }\n         }\n             // If the node is a standard InfoSet node (e.g. DOM Node),\n             // employ doPredicates_standard, which will iterate through\n             // the node's children and apply all predicates\n-            NodePointer found = doPredicates_standard(context,\n-                    Collections.singletonList(child), steps,\n-                    current_step, predicates, current_predicate);\n-            if (found != null){\n+            NodePointer found =\n+                doPredicatesStandard(\n+                    context,\n+                    Collections.singletonList(child),\n+                    steps,\n+                    currentStep,\n+                    predicates,\n+                    currentPredicate);\n+            if (found != null) {\n                 return found;\n             }\n         }\n         // If nothing worked - return a null pointer\n         return createNullPointerForPredicates(\n-                context, child, steps, current_step,\n-                predicates, current_predicate);\n+            context,\n+            child,\n+            steps,\n+            currentStep,\n+            predicates,\n+            currentPredicate);\n     }\n \n     /**\n      * Called exclusively for standard InfoSet nodes, e.g. DOM nodes\n      * to evaluate predicate sequences like [@name=...][@name=...][index].\n      */\n-    private static NodePointer doPredicates_standard(\n+    private static NodePointer doPredicatesStandard(\n                 EvalContext context, List parents,\n-                Step[] steps, int current_step,\n-                Expression predicates[], int current_predicate)\n-    {\n-        if (parents.size() == 0){\n+                Step[] steps, int currentStep,\n+                Expression predicates[], int currentPredicate)\n+    {\n+        if (parents.size() == 0) {\n             return null;\n         }\n \n         // If all predicates have been processed, take the first\n         // element from the list of results and proceed to the\n         // remaining steps with that element.\n-        if (current_predicate == predicates.length){\n-            NodePointer pointer = (NodePointer)parents.get(0);\n-            return doStep(context, pointer, steps, current_step + 1);\n-        }\n-\n-        Expression predicate = predicates[current_predicate];\n-        if (predicate instanceof NameAttributeTest){\n+        if (currentPredicate == predicates.length) {\n+            NodePointer pointer = (NodePointer) parents.get(0);\n+            return doStep(context, pointer, steps, currentStep + 1);\n+        }\n+\n+        Expression predicate = predicates[currentPredicate];\n+        if (predicate instanceof NameAttributeTest) {\n             String key = keyFromPredicate(context, predicate);\n             List newList = new ArrayList();\n-            for (int i = 0; i < parents.size(); i++){\n-                NodePointer pointer = (NodePointer)parents.get(i);\n-                if (isNameAttributeEqual(pointer, key)){\n+            for (int i = 0; i < parents.size(); i++) {\n+                NodePointer pointer = (NodePointer) parents.get(i);\n+                if (isNameAttributeEqual(pointer, key)) {\n                     newList.add(pointer);\n                 }\n             }\n-            if (newList.size() == 0){\n+            if (newList.size() == 0) {\n                 return null;\n             }\n-            return doPredicates_standard(context, newList,\n-                    steps, current_step,\n-                    predicates, current_predicate + 1);\n+            return doPredicatesStandard(\n+                context,\n+                newList,\n+                steps,\n+                currentStep,\n+                predicates,\n+                currentPredicate + 1);\n         }\n         else {\n             // For a subscript, simply take the corresponding\n             // element from the list of results and\n             // proceed to the remaining predicates with that element\n             int index = indexFromPredicate(context, predicate);\n-            if (index < 0 || index >= parents.size()){\n+            if (index < 0 || index >= parents.size()) {\n                 return null;\n             }\n-            NodePointer ptr = (NodePointer)parents.get(index);\n-            return doPredicate(context, ptr, steps, current_step,\n-                predicates, current_predicate + 1);\n+            NodePointer ptr = (NodePointer) parents.get(index);\n+            return doPredicate(\n+                context,\n+                ptr,\n+                steps,\n+                currentStep,\n+                predicates,\n+                currentPredicate + 1);\n         }\n     }\n \n      * Evaluate a subscript predicate: see if the node is a collection and\n      * if the index is inside the collection\n      */\n-    private static NodePointer doPredicate_index(\n+    private static NodePointer doPredicateIndex(\n             EvalContext context, NodePointer parent,\n-            Step[] steps, int current_step,\n-            Expression[] predicates, int current_predicate)\n-    {\n-        Expression predicate = predicates[current_predicate];\n+            Step[] steps, int currentStep,\n+            Expression[] predicates, int currentPredicate)\n+    {\n+        Expression predicate = predicates[currentPredicate];\n         int index = indexFromPredicate(context, predicate);\n         NodePointer pointer = parent;\n-        if (isCollectionElement(pointer, index)){\n+        if (isCollectionElement(pointer, index)) {\n             pointer.setIndex(index);\n-            return doPredicate(context, pointer,\n-                    steps, current_step, predicates, current_predicate + 1);\n-        }\n-        return createNullPointerForPredicates(context, parent,\n-                steps, current_step, predicates, current_predicate);\n+            return doPredicate(\n+                context,\n+                pointer,\n+                steps,\n+                currentStep,\n+                predicates,\n+                currentPredicate + 1);\n+        }\n+        return createNullPointerForPredicates(\n+            context,\n+            parent,\n+            steps,\n+            currentStep,\n+            predicates,\n+            currentPredicate);\n     }\n \n     /**\n      * starts with 0, even though the subscript starts with 1.\n      */\n     private static int indexFromPredicate(\n-            EvalContext context, Expression predicate)\n+        EvalContext context,\n+        Expression predicate) \n     {\n         Object value = predicate.computeValue(context);\n-        if (value instanceof EvalContext){\n-            value = ((EvalContext)value).getSingleNodePointer();\n-        }\n-        if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getValue();\n-        }\n-        if (value == null){\n+        if (value instanceof EvalContext) {\n+            value = ((EvalContext) value).getSingleNodePointer();\n+        }\n+        if (value instanceof NodePointer) {\n+            value = ((NodePointer) value).getValue();\n+        }\n+        if (value == null) {\n             throw new JXPathException(\"Predicate value is null\");\n         }\n \n-        if (value instanceof Number){\n-            return (int)(InfoSetUtil.doubleValue(value) + 0.5) - 1;\n-        }\n-        else if (InfoSetUtil.booleanValue(value)){\n+        if (value instanceof Number) {\n+            return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1;\n+        }\n+        else if (InfoSetUtil.booleanValue(value)) {\n             return 0;\n         }\n \n      * [@name=expression].\n      */\n     private static String keyFromPredicate(EvalContext context,\n-                Expression predicate){\n-        Expression expr = ((NameAttributeTest)predicate).\n-                                    getNameTestExpression();\n+                Expression predicate) \n+    {\n+        Expression expr =\n+            ((NameAttributeTest) predicate).getNameTestExpression();\n         return InfoSetUtil.stringValue(expr.computeValue(context));\n     }\n \n      * For a pointer that does not match an actual node, but whose\n      * parent pointer does returns -1, etc.\n      */\n-    private static int computeQuality(NodePointer pointer){\n+    private static int computeQuality(NodePointer pointer) {\n         int quality = PERFECT_MATCH;\n-        while (pointer != null && !pointer.isActual()){\n+        while (pointer != null && !pointer.isActual()) {\n             quality--;\n             pointer = pointer.getParent();\n         }\n      * its value is equal to the supplied string.\n      */\n     private static boolean isNameAttributeEqual(\n-            NodePointer pointer, String name)\n+        NodePointer pointer,\n+        String name) \n     {\n         NodeIterator it = pointer.attributeIterator(QNAME_NAME);\n-        return it != null && it.setPosition(1) &&\n-                name.equals(it.getNodePointer().getValue());\n+        return it != null\n+            && it.setPosition(1)\n+            && name.equals(it.getNodePointer().getValue());\n     }\n \n     /**\n      * Returns true if the pointer is a collection and the index is\n      * withing the bounds of the collection.\n      */\n-    private static boolean isCollectionElement(NodePointer pointer, int index){\n-        return pointer.isActual() && (index == 0 ||\n-            (pointer.isCollection() &&\n-                    index >= 0 && index < pointer.getLength()));\n+    private static boolean isCollectionElement(\n+        NodePointer pointer,\n+        int index) \n+    {\n+        return pointer.isActual()\n+            && (index == 0\n+                || (pointer.isCollection()\n+                    && index >= 0\n+                    && index < pointer.getLength()));\n     }\n \n     /**\n      * For an intermediate pointer (e.g. PropertyPointer, ContainerPointer)\n      * returns a pointer for the contained value.\n      */\n-    private static NodePointer valuePointer(NodePointer pointer){\n+    private static NodePointer valuePointer(NodePointer pointer) {\n         return pointer == null ? null : pointer.getValuePointer();\n     }\n \n      */\n     private static NodePointer createNullPointer(\n             EvalContext context, NodePointer parent, Step[] steps,\n-            int current_step)\n-    {\n-        if (current_step == steps.length){\n+            int currentStep)\n+    {\n+        if (currentStep == steps.length) {\n             return parent;\n         }\n \n         parent = valuePointer(parent);\n \n-        Step step = steps[current_step];\n+        Step step = steps[currentStep];\n \n         int axis = step.getAxis();\n-        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE){\n+        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n             NullPropertyPointer pointer = new NullPropertyPointer(parent);\n-            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n             pointer.setPropertyName(name.toString());\n             pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n             parent = pointer;\n         // else { it is self::node() }\n \n         Expression predicates[] = step.getPredicates();\n-        return createNullPointerForPredicates(context, parent,\n-                steps, current_step, predicates, 0);\n+        return createNullPointerForPredicates(\n+            context,\n+            parent,\n+            steps,\n+            currentStep,\n+            predicates,\n+            0);\n     }\n \n     /**\n      */\n     private static NodePointer createNullPointerForPredicates(\n             EvalContext context, NodePointer parent,\n-            Step[] steps, int current_step,\n-            Expression predicates[], int current_predicate)\n-    {\n-        for (int i = current_predicate; i < predicates.length; i++){\n+            Step[] steps, int currentStep,\n+            Expression predicates[], int currentPredicate)\n+    {\n+        for (int i = currentPredicate; i < predicates.length; i++) {\n             Expression predicate = predicates[i];\n-            if (predicate instanceof NameAttributeTest){\n+            if (predicate instanceof NameAttributeTest) {\n                 String key = keyFromPredicate(context, predicate);\n                 parent = valuePointer(parent);\n                 NullPropertyPointer pointer = new NullPropertyPointer(parent);\n             }\n             else {\n                 int index = indexFromPredicate(context, predicate);\n-                if (parent instanceof NullPropertyPointer){\n+                if (parent instanceof NullPropertyPointer) {\n                     parent.setIndex(index);\n                 }\n                 else {\n         }\n         // Proceed with the remaining steps\n         return createNullPointer(\n-                    context, parent, steps, current_step + 1);\n-    }\n-\n-    private static NodeIterator getNodeIterator(NodePointer pointer, Step step){\n-        if (step.getAxis() == Compiler.AXIS_CHILD){\n+                    context, parent, steps, currentStep + 1);\n+    }\n+\n+    private static NodeIterator getNodeIterator(\n+        NodePointer pointer,\n+        Step step) \n+    {\n+        if (step.getAxis() == Compiler.AXIS_CHILD) {\n             return pointer.childIterator(step.getNodeTest(), false, null);\n         }\n-        else {      // Compiler.AXIS_ATTRIBUTE\n-            if (!(step.getNodeTest() instanceof NodeNameTest)){\n+        else { // Compiler.AXIS_ATTRIBUTE\n+            if (!(step.getNodeTest() instanceof NodeNameTest)) {\n                 throw new UnsupportedOperationException(\n-                    \"Not supported node test for attributes: \" +\n-                        step.getNodeTest());\n+                    \"Not supported node test for attributes: \"\n+                        + step.getNodeTest());\n             }\n             return pointer.attributeIterator(\n-                ((NodeNameTest)step.getNodeTest()).getNodeName());\n-        }\n-    }\n-\n-    private static boolean isLangAttribute(QName name){\n-        return name.getPrefix() != null &&\n-                name.getPrefix().equals(\"xml\") &&\n-                name.getName().equals(\"lang\");\n+                ((NodeNameTest) step.getNodeTest()).getNodeName());\n+        }\n+    }\n+\n+    private static boolean isLangAttribute(QName name) {\n+        return name.getPrefix() != null\n+            && name.getPrefix().equals(\"xml\")\n+            && name.getName().equals(\"lang\");\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.7 2002/05/29 00:41:32 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/05/29 00:41:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.8 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of a union operation like (a | b)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/05/29 00:41:32 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class UnionContext extends EvalContext {\n     private boolean startedSet = false;\n     private EvalContext contexts[];\n     private List list;\n \n-    public UnionContext(EvalContext parentContext, EvalContext contexts[]){\n+    public UnionContext(EvalContext parentContext, EvalContext contexts[]) {\n         super(parentContext);\n         this.contexts = contexts;\n     }\n \n-    public int getDocumentOrder(){\n-        if (contexts.length > 1){\n+    public int getDocumentOrder() {\n+        if (contexts.length > 1) {\n             return 1;\n         }\n         return super.getDocumentOrder();\n     }\n \n-    public NodePointer getCurrentNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getCurrentNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n         }\n-        return (NodePointer)list.get(position - 1);\n+        return (NodePointer) list.get(position - 1);\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         super.setPosition(position);\n-        if (list == null){\n+        if (list == null) {\n             prepareList();\n         }\n         return position >= 1 && position <= list.size();\n     }\n \n-    public boolean nextSet(){\n-        if (startedSet){\n+    public boolean nextSet() {\n+        if (startedSet) {\n             return false;\n         }\n         startedSet = true;\n         return true;\n     }\n \n-    public boolean nextNode(){\n+    public boolean nextNode() {\n         return setPosition(position + 1);\n     }\n \n-    private void prepareList(){\n+    private void prepareList() {\n         list = new ArrayList();\n         HashSet set = new HashSet();\n-        for (int i = 0; i < contexts.length; i++){\n-            EvalContext ctx = (EvalContext)contexts[i];\n-            while (ctx.nextSet()){\n-                while (ctx.nextNode()){\n+        for (int i = 0; i < contexts.length; i++) {\n+            EvalContext ctx = (EvalContext) contexts[i];\n+            while (ctx.nextSet()) {\n+                while (ctx.nextNode()) {\n                     NodePointer ptr = ctx.getCurrentNodePointer();\n-                    if (!set.contains(ptr)){\n-                        ptr = (NodePointer)ptr.clone();\n+                    if (!set.contains(ptr)) {\n+                        ptr = (NodePointer) ptr.clone();\n                         list.add(ptr);\n                         set.add(ptr);\n                     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Constant.java,v 1.4 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A compile tree element containing a constant number or string.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class Constant extends Expression {\n \n     private Object value;\n \n-    public Constant(Number number){\n+    public Constant(Number number) {\n         super(Expression.OP_CONSTANT);\n         this.value = number;\n     }\n \n-    public Constant(String string){\n+    public Constant(String string) {\n         super(Expression.OP_CONSTANT);\n         this.value = string;\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return value;\n     }\n \n     /**\n      * Returns the value of the constant.\n      */\n-    public Object computeValue(EvalContext context){\n+    public Object computeValue(EvalContext context) {\n         return value;\n     }\n \n     /**\n      * Returns false\n      */\n-    public boolean isContextDependent(){\n+    public boolean isContextDependent() {\n         return false;\n     }\n \n     /**\n      * Returns false\n      */\n-    public boolean computeContextDependent(){\n+    public boolean computeContextDependent() {\n         return false;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"(CONST \" + value + \")\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.8 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.9 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * like \"position()\" or \"number()\".\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class CoreFunction extends Operation {\n \n     private static final Double ZERO = new Double(0);\n     private int functionCode;\n \n-    public CoreFunction(int functionCode, Expression args[]){\n+    public CoreFunction(int functionCode, Expression args[]) {\n         super(Expression.OP_CORE_FUNCTION, args);\n         this.functionCode = functionCode;\n     }\n \n-    public int getFunctionCode(){\n+    public int getFunctionCode() {\n         return functionCode;\n     }\n \n-    public Expression getArg1(){\n+    public Expression getArg1() {\n         return args[0];\n     }\n \n-    public Expression getArg2(){\n+    public Expression getArg2() {\n         return args[1];\n     }\n \n-    public Expression getArg3(){\n+    public Expression getArg3() {\n         return args[2];\n     }\n \n-    public int getArgumentCount(){\n-        if (args == null){\n+    public int getArgumentCount() {\n+        if (args == null) {\n             return 0;\n         }\n         return args.length;\n      * the function is last(), position(), boolean(), local-name(),\n      * name(), string(), lang(), number().\n      */\n-    public boolean computeContextDependent(){\n-        if (super.computeContextDependent()){\n+    public boolean computeContextDependent() {\n+        if (super.computeContextDependent()) {\n             return true;\n         }\n \n-        switch(functionCode){\n+        switch(functionCode) {\n             case Compiler.FUNCTION_LAST:\n             case Compiler.FUNCTION_POSITION:\n                 return true;\n         return false;\n     }\n \n-    protected String opCodeToString(){\n+    protected String opCodeToString() {\n         String function = null;\n-        switch(functionCode){\n-            case Compiler.FUNCTION_LAST:             function = \"last\"; break;\n-            case Compiler.FUNCTION_POSITION:         function = \"position\"; break;\n-            case Compiler.FUNCTION_COUNT:            function = \"count\"; break;\n-            case Compiler.FUNCTION_ID:               function = \"id\"; break;\n-            case Compiler.FUNCTION_LOCAL_NAME:       function = \"local-name\"; break;\n-            case Compiler.FUNCTION_NAMESPACE_URI:    function = \"namespace-uri\"; break;\n-            case Compiler.FUNCTION_NAME:             function = \"name\"; break;\n-            case Compiler.FUNCTION_STRING:           function = \"string\"; break;\n-            case Compiler.FUNCTION_CONCAT:           function = \"concat\"; break;\n-            case Compiler.FUNCTION_STARTS_WITH:      function = \"starts-with\"; break;\n-            case Compiler.FUNCTION_CONTAINS:         function = \"contains\"; break;\n-            case Compiler.FUNCTION_SUBSTRING_BEFORE: function = \"substring-before\"; break;\n-            case Compiler.FUNCTION_SUBSTRING_AFTER:  function = \"substring-after\"; break;\n-            case Compiler.FUNCTION_SUBSTRING:        function = \"substring\"; break;\n-            case Compiler.FUNCTION_STRING_LENGTH:    function = \"string-length\"; break;\n-            case Compiler.FUNCTION_NORMALIZE_SPACE:  function = \"normalize-space\"; break;\n-            case Compiler.FUNCTION_TRANSLATE:        function = \"translate\"; break;\n-            case Compiler.FUNCTION_BOOLEAN:          function = \"boolean\"; break;\n-            case Compiler.FUNCTION_NOT:              function = \"not\"; break;\n-            case Compiler.FUNCTION_TRUE:             function = \"true\"; break;\n-            case Compiler.FUNCTION_FALSE:            function = \"false\"; break;\n-            case Compiler.FUNCTION_LANG:             function = \"lang\"; break;\n-            case Compiler.FUNCTION_NUMBER:           function = \"number\"; break;\n-            case Compiler.FUNCTION_SUM:              function = \"sum\"; break;\n-            case Compiler.FUNCTION_FLOOR:            function = \"floor\"; break;\n-            case Compiler.FUNCTION_CEILING:          function = \"ceiling\"; break;\n-            case Compiler.FUNCTION_ROUND:            function = \"round\"; break;\n-            case Compiler.FUNCTION_KEY:              function = \"key\"; break;\n+        switch (functionCode) {\n+            case Compiler.FUNCTION_LAST :\n+                function = \"last\";\n+                break;\n+            case Compiler.FUNCTION_POSITION :\n+                function = \"position\";\n+                break;\n+            case Compiler.FUNCTION_COUNT :\n+                function = \"count\";\n+                break;\n+            case Compiler.FUNCTION_ID :\n+                function = \"id\";\n+                break;\n+            case Compiler.FUNCTION_LOCAL_NAME :\n+                function = \"local-name\";\n+                break;\n+            case Compiler.FUNCTION_NAMESPACE_URI :\n+                function = \"namespace-uri\";\n+                break;\n+            case Compiler.FUNCTION_NAME :\n+                function = \"name\";\n+                break;\n+            case Compiler.FUNCTION_STRING :\n+                function = \"string\";\n+                break;\n+            case Compiler.FUNCTION_CONCAT :\n+                function = \"concat\";\n+                break;\n+            case Compiler.FUNCTION_STARTS_WITH :\n+                function = \"starts-with\";\n+                break;\n+            case Compiler.FUNCTION_CONTAINS :\n+                function = \"contains\";\n+                break;\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n+                function = \"substring-before\";\n+                break;\n+            case Compiler.FUNCTION_SUBSTRING_AFTER :\n+                function = \"substring-after\";\n+                break;\n+            case Compiler.FUNCTION_SUBSTRING :\n+                function = \"substring\";\n+                break;\n+            case Compiler.FUNCTION_STRING_LENGTH :\n+                function = \"string-length\";\n+                break;\n+            case Compiler.FUNCTION_NORMALIZE_SPACE :\n+                function = \"normalize-space\";\n+                break;\n+            case Compiler.FUNCTION_TRANSLATE :\n+                function = \"translate\";\n+                break;\n+            case Compiler.FUNCTION_BOOLEAN :\n+                function = \"boolean\";\n+                break;\n+            case Compiler.FUNCTION_NOT :\n+                function = \"not\";\n+                break;\n+            case Compiler.FUNCTION_TRUE :\n+                function = \"true\";\n+                break;\n+            case Compiler.FUNCTION_FALSE :\n+                function = \"false\";\n+                break;\n+            case Compiler.FUNCTION_LANG :\n+                function = \"lang\";\n+                break;\n+            case Compiler.FUNCTION_NUMBER :\n+                function = \"number\";\n+                break;\n+            case Compiler.FUNCTION_SUM :\n+                function = \"sum\";\n+                break;\n+            case Compiler.FUNCTION_FLOOR :\n+                function = \"floor\";\n+                break;\n+            case Compiler.FUNCTION_CEILING :\n+                function = \"ceiling\";\n+                break;\n+            case Compiler.FUNCTION_ROUND :\n+                function = \"round\";\n+                break;\n+            case Compiler.FUNCTION_KEY :\n+                function = \"key\";\n+                break;\n         }\n         return super.opCodeToString() + ':' + function;\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n     /**\n      * Computes a built-in function\n      */\n-    public Object computeValue(EvalContext context){\n-        switch(functionCode){\n-            case Compiler.FUNCTION_LAST:                return functionLast(context);\n-            case Compiler.FUNCTION_POSITION:            return functionPosition(context);\n-            case Compiler.FUNCTION_COUNT:               return functionCount(context);\n-            case Compiler.FUNCTION_LANG:                return functionLang(context);\n-            case Compiler.FUNCTION_ID:                  return functionID(context);\n-            case Compiler.FUNCTION_LOCAL_NAME:          return functionLocalName(context);\n-            case Compiler.FUNCTION_NAMESPACE_URI:       return functionNamespaceURI(context);\n-            case Compiler.FUNCTION_NAME:                return functionName(context);\n-            case Compiler.FUNCTION_STRING:              return functionString(context);\n-            case Compiler.FUNCTION_CONCAT:              return functionConcat(context);\n-            case Compiler.FUNCTION_STARTS_WITH:         return functionStartsWith(context);\n-            case Compiler.FUNCTION_CONTAINS:            return functionContains(context);\n-            case Compiler.FUNCTION_SUBSTRING_BEFORE:    return functionSubstringBefore(context);\n-            case Compiler.FUNCTION_SUBSTRING_AFTER:     return functionSubstringAfter(context);\n-            case Compiler.FUNCTION_SUBSTRING:           return functionSubstring(context);\n-            case Compiler.FUNCTION_STRING_LENGTH:       return functionStringLength(context);\n-            case Compiler.FUNCTION_NORMALIZE_SPACE:     return functionNormalizeSpace(context);\n-            case Compiler.FUNCTION_TRANSLATE:           return functionTranslate(context);\n-            case Compiler.FUNCTION_BOOLEAN:             return functionBoolean(context);\n-            case Compiler.FUNCTION_NOT:                 return functionNot(context);\n-            case Compiler.FUNCTION_TRUE:                return functionTrue(context);\n-            case Compiler.FUNCTION_FALSE:               return functionFalse(context);\n-            case Compiler.FUNCTION_NULL:                return functionNull(context);\n-            case Compiler.FUNCTION_NUMBER:              return functionNumber(context);\n-            case Compiler.FUNCTION_SUM:                 return functionSum(context);\n-            case Compiler.FUNCTION_FLOOR:               return functionFloor(context);\n-            case Compiler.FUNCTION_CEILING:             return functionCeiling(context);\n-            case Compiler.FUNCTION_ROUND:               return functionRound(context);\n-            case Compiler.FUNCTION_KEY:                 return functionKey(context);\n+    public Object computeValue(EvalContext context) {\n+        switch (functionCode) {\n+            case Compiler.FUNCTION_LAST :\n+                return functionLast(context);\n+            case Compiler.FUNCTION_POSITION :\n+                return functionPosition(context);\n+            case Compiler.FUNCTION_COUNT :\n+                return functionCount(context);\n+            case Compiler.FUNCTION_LANG :\n+                return functionLang(context);\n+            case Compiler.FUNCTION_ID :\n+                return functionID(context);\n+            case Compiler.FUNCTION_LOCAL_NAME :\n+                return functionLocalName(context);\n+            case Compiler.FUNCTION_NAMESPACE_URI :\n+                return functionNamespaceURI(context);\n+            case Compiler.FUNCTION_NAME :\n+                return functionName(context);\n+            case Compiler.FUNCTION_STRING :\n+                return functionString(context);\n+            case Compiler.FUNCTION_CONCAT :\n+                return functionConcat(context);\n+            case Compiler.FUNCTION_STARTS_WITH :\n+                return functionStartsWith(context);\n+            case Compiler.FUNCTION_CONTAINS :\n+                return functionContains(context);\n+            case Compiler.FUNCTION_SUBSTRING_BEFORE :\n+                return functionSubstringBefore(context);\n+            case Compiler.FUNCTION_SUBSTRING_AFTER :\n+                return functionSubstringAfter(context);\n+            case Compiler.FUNCTION_SUBSTRING :\n+                return functionSubstring(context);\n+            case Compiler.FUNCTION_STRING_LENGTH :\n+                return functionStringLength(context);\n+            case Compiler.FUNCTION_NORMALIZE_SPACE :\n+                return functionNormalizeSpace(context);\n+            case Compiler.FUNCTION_TRANSLATE :\n+                return functionTranslate(context);\n+            case Compiler.FUNCTION_BOOLEAN :\n+                return functionBoolean(context);\n+            case Compiler.FUNCTION_NOT :\n+                return functionNot(context);\n+            case Compiler.FUNCTION_TRUE :\n+                return functionTrue(context);\n+            case Compiler.FUNCTION_FALSE :\n+                return functionFalse(context);\n+            case Compiler.FUNCTION_NULL :\n+                return functionNull(context);\n+            case Compiler.FUNCTION_NUMBER :\n+                return functionNumber(context);\n+            case Compiler.FUNCTION_SUM :\n+                return functionSum(context);\n+            case Compiler.FUNCTION_FLOOR :\n+                return functionFloor(context);\n+            case Compiler.FUNCTION_CEILING :\n+                return functionCeiling(context);\n+            case Compiler.FUNCTION_ROUND :\n+                return functionRound(context);\n+            case Compiler.FUNCTION_KEY :\n+                return functionKey(context);\n         }\n         return null;\n     }\n \n-    protected Object functionLast(EvalContext context){\n+    protected Object functionLast(EvalContext context) {\n         assertArgCount(0);\n         // Move the position to the beginning and iterate through\n         // the context to count nodes.\n         int old = context.getCurrentPosition();\n         context.reset();\n         int count = 0;\n-        while(context.nextNode()){\n+        while (context.nextNode()) {\n             count++;\n         }\n \n         // Restore the current position.\n-        if (old != 0){\n+        if (old != 0) {\n             context.setPosition(old);\n         }\n         return new Double(count);\n     }\n \n-    protected Object functionPosition(EvalContext context){\n+    protected Object functionPosition(EvalContext context) {\n         assertArgCount(0);\n         return new Integer(context.getCurrentPosition());\n     }\n \n-    protected Object functionCount(EvalContext context){\n+    protected Object functionCount(EvalContext context) {\n         assertArgCount(1);\n         Expression arg1 = getArg1();\n         int count = 0;\n         Object value = arg1.compute(context);\n-        if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getValue();\n-        }\n-        if (value instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)value;\n-            while(ctx.hasNext()){\n+        if (value instanceof NodePointer) {\n+            value = ((NodePointer) value).getValue();\n+        }\n+        if (value instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) value;\n+            while (ctx.hasNext()) {\n                 ctx.next();\n                 count++;\n             }\n         }\n-        else if (value instanceof Collection){\n-            count = ((Collection)value).size();\n-        }\n-        else if (value == null){\n+        else if (value instanceof Collection) {\n+            count = ((Collection) value).size();\n+        }\n+        else if (value == null) {\n             count = 0;\n         }\n         else {\n         return new Double(count);\n     }\n \n-    protected Object functionLang(EvalContext context){\n+    protected Object functionLang(EvalContext context) {\n         assertArgCount(1);\n         String lang = InfoSetUtil.stringValue(getArg1().computeValue(context));\n-        NodePointer pointer = (NodePointer)context.getSingleNodePointer();\n-        if (pointer == null){\n+        NodePointer pointer = (NodePointer) context.getSingleNodePointer();\n+        if (pointer == null) {\n             return Boolean.FALSE;\n         }\n-        return pointer.isLanguage(lang) ? Boolean.TRUE: Boolean.FALSE;\n-    }\n-\n-    protected Object functionID(EvalContext context){\n+        return pointer.isLanguage(lang) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    protected Object functionID(EvalContext context) {\n         assertArgCount(1);\n         String id = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         JXPathContext jxpathContext = context.getJXPathContext();\n-        NodePointer pointer = (NodePointer)jxpathContext.getContextPointer();\n+        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n         return pointer.getPointerByID(jxpathContext, id);\n     }\n \n-    protected Object functionKey(EvalContext context){\n+    protected Object functionKey(EvalContext context) {\n         assertArgCount(2);\n         String key = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String value = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         JXPathContext jxpathContext = context.getJXPathContext();\n-        NodePointer pointer = (NodePointer)jxpathContext.getContextPointer();\n+        NodePointer pointer = (NodePointer) jxpathContext.getContextPointer();\n         return pointer.getPointerByKey(jxpathContext, key, value);\n     }\n \n-    protected Object functionNamespaceURI(EvalContext context){\n-        if (getArgumentCount() == 0){\n+    protected Object functionNamespaceURI(EvalContext context) {\n+        if (getArgumentCount() == 0) {\n             return context.getCurrentNodePointer();\n         }\n         assertArgCount(1);\n         Object set = getArg1().compute(context);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.hasNext()){\n-                NodePointer ptr = (NodePointer)ctx.next();\n+        if (set instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) set;\n+            if (ctx.hasNext()) {\n+                NodePointer ptr = (NodePointer) ctx.next();\n                 String str = ptr.getNamespaceURI();\n                 return str == null ? \"\" : str;\n             }\n         return \"\";\n     }\n \n-    protected Object functionLocalName(EvalContext context){\n-        if (getArgumentCount() == 0){\n+    protected Object functionLocalName(EvalContext context) {\n+        if (getArgumentCount() == 0) {\n             return context.getCurrentNodePointer();\n         }\n         assertArgCount(1);\n         Object set = getArg1().compute(context);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.hasNext()){\n-                NodePointer ptr = (NodePointer)ctx.next();\n+        if (set instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) set;\n+            if (ctx.hasNext()) {\n+                NodePointer ptr = (NodePointer) ctx.next();\n                 return ptr.getName().getName();\n             }\n         }\n         return \"\";\n     }\n \n-    protected Object functionName(EvalContext context){\n-        if (getArgumentCount() == 0){\n+    protected Object functionName(EvalContext context) {\n+        if (getArgumentCount() == 0) {\n             return context.getCurrentNodePointer();\n         }\n         assertArgCount(1);\n         Object set = getArg1().compute(context);\n-        if (set instanceof EvalContext){\n-            EvalContext ctx = (EvalContext)set;\n-            if (ctx.hasNext()){\n-                NodePointer ptr = (NodePointer)ctx.next();\n+        if (set instanceof EvalContext) {\n+            EvalContext ctx = (EvalContext) set;\n+            if (ctx.hasNext()) {\n+                NodePointer ptr = (NodePointer) ctx.next();\n                 return ptr.getExpandedName().toString();\n             }\n         }\n         return \"\";\n     }\n \n-    protected Object functionString(EvalContext context){\n-        if (getArgumentCount() == 0){\n+    protected Object functionString(EvalContext context) {\n+        if (getArgumentCount() == 0) {\n             return InfoSetUtil.stringValue(context.getCurrentNodePointer());\n         }\n         assertArgCount(1);\n         return InfoSetUtil.stringValue(getArg1().computeValue(context));\n     }\n \n-    protected Object functionConcat(EvalContext context){\n-        if (getArgumentCount() < 2){\n+    protected Object functionConcat(EvalContext context) {\n+        if (getArgumentCount() < 2) {\n             assertArgCount(2);\n         }\n         StringBuffer buffer = new StringBuffer();\n         Expression args[] = getArguments();\n-        for (int i = 0; i < args.length; i++){\n+        for (int i = 0; i < args.length; i++) {\n             buffer.append(InfoSetUtil.stringValue(args[i].compute(context)));\n         }\n         return buffer.toString();\n     }\n \n-    protected Object functionStartsWith(EvalContext context){\n+    protected Object functionStartsWith(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n-    protected Object functionContains(EvalContext context){\n+    protected Object functionContains(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n-    protected Object functionSubstringBefore(EvalContext context){\n+    protected Object functionSubstringBefore(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         int index = s1.indexOf(s2);\n-        if (index == -1){\n+        if (index == -1) {\n             return \"\";\n         }\n         return s1.substring(0, index);\n     }\n \n-    protected Object functionSubstringAfter(EvalContext context){\n+    protected Object functionSubstringAfter(EvalContext context) {\n         assertArgCount(2);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         int index = s1.indexOf(s2);\n-        if (index == -1){\n+        if (index == -1) {\n             return \"\";\n         }\n         return s1.substring(index + s2.length());\n     }\n \n-    protected Object functionSubstring(EvalContext context){\n+    protected Object functionSubstring(EvalContext context) {\n         int ac = getArgumentCount();\n-        if (ac != 2 && ac != 3){\n+        if (ac != 2 && ac != 3) {\n             assertArgCount(2);\n         }\n \n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         double from = InfoSetUtil.doubleValue(getArg2().computeValue(context));\n-        if (Double.isNaN(from)){\n+        if (Double.isNaN(from)) {\n             return \"\";\n         }\n \n         from = Math.round(from);\n-        if (ac == 2){\n-            if (from < 1){\n+        if (ac == 2) {\n+            if (from < 1) {\n                 from = 1;\n             }\n-            return s1.substring((int)from - 1);\n+            return s1.substring((int) from - 1);\n         }\n         else {\n-            double length = InfoSetUtil.doubleValue(getArg3().computeValue(context));\n+            double length =\n+                InfoSetUtil.doubleValue(getArg3().computeValue(context));\n             length = Math.round(length);\n-            if (length < 0){\n+            if (length < 0) {\n                 return \"\";\n             }\n \n             double to = from + length;\n-            if (to < 1){\n+            if (to < 1) {\n                 return \"\";\n             }\n \n-            if (to > s1.length() + 1){\n-                if (from < 1){\n+            if (to > s1.length() + 1) {\n+                if (from < 1) {\n                     from = 1;\n                 }\n-                return s1.substring((int)from - 1);\n-            }\n-\n-            if (from < 1){\n+                return s1.substring((int) from - 1);\n+            }\n+\n+            if (from < 1) {\n                 from = 1;\n             }\n-            return s1.substring((int)from - 1, (int)(to - 1));\n-        }\n-    }\n-\n-    protected Object functionStringLength(EvalContext context){\n+            return s1.substring((int) from - 1, (int) (to - 1));\n+        }\n+    }\n+\n+    protected Object functionStringLength(EvalContext context) {\n         String s;\n-        if (getArgumentCount() == 0){\n+        if (getArgumentCount() == 0) {\n             s = InfoSetUtil.stringValue(context.getCurrentNodePointer());\n         }\n         else {\n         return new Double(s.length());\n     }\n \n-    protected Object functionNormalizeSpace(EvalContext context){\n+    protected Object functionNormalizeSpace(EvalContext context) {\n         assertArgCount(1);\n         String s = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         char chars[] = s.toCharArray();\n         int out = 0;\n         int phase = 0;\n-        for (int in = 0; in < chars.length; in++){\n-            switch(chars[in]){\n+        for (int in = 0; in < chars.length; in++) {\n+            switch(chars[in]) {\n                 case 0x20:\n                 case 0x9:\n                 case 0xD:\n                 case 0xA:\n-                    if (phase == 0){      // beginning\n+                    if (phase == 0) {      // beginning\n                         ;\n                     }\n-                    else if (phase == 1){ // non-space\n+                    else if (phase == 1) { // non-space\n                         phase = 2;\n                         chars[out++] = ' ';\n                     }\n                     phase = 1;\n             }\n         }\n-        if (phase == 2){ // trailing-space\n+        if (phase == 2) { // trailing-space\n             out--;\n         }\n         return new String(chars, 0, out);\n     }\n \n-    protected Object functionTranslate(EvalContext context){\n+    protected Object functionTranslate(EvalContext context) {\n         assertArgCount(3);\n         String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context));\n         String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context));\n         String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context));\n         char chars[] = s1.toCharArray();\n         int out = 0;\n-        for (int in = 0; in < chars.length; in++){\n+        for (int in = 0; in < chars.length; in++) {\n             char c = chars[in];\n             int inx = s2.indexOf(c);\n-            if (inx != -1){\n-                if (inx < s3.length()){\n+            if (inx != -1) {\n+                if (inx < s3.length()) {\n                     chars[out++] = s3.charAt(inx);\n                 }\n             }\n         return new String(chars, 0, out);\n     }\n \n-    protected Object functionBoolean(EvalContext context){\n-        assertArgCount(1);\n-        return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n-    }\n-\n-    protected Object functionNot(EvalContext context){\n-        assertArgCount(1);\n-        return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.FALSE : Boolean.TRUE;\n-    }\n-\n-    protected Object functionTrue(EvalContext context){\n+    protected Object functionBoolean(EvalContext context) {\n+        assertArgCount(1);\n+        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n+            ? Boolean.TRUE\n+            : Boolean.FALSE;\n+    }\n+\n+    protected Object functionNot(EvalContext context) {\n+        assertArgCount(1);\n+        return InfoSetUtil.booleanValue(getArg1().computeValue(context))\n+            ? Boolean.FALSE\n+            : Boolean.TRUE;\n+    }\n+\n+    protected Object functionTrue(EvalContext context) {\n         assertArgCount(0);\n         return Boolean.TRUE;\n     }\n \n-    protected Object functionFalse(EvalContext context){\n+    protected Object functionFalse(EvalContext context) {\n         assertArgCount(0);\n         return Boolean.FALSE;\n     }\n \n-    protected Object functionNull(EvalContext context){\n+    protected Object functionNull(EvalContext context) {\n         assertArgCount(0);\n         return null;\n     }\n \n-    protected Object functionNumber(EvalContext context){\n-        if (getArgumentCount() == 0){\n+    protected Object functionNumber(EvalContext context) {\n+        if (getArgumentCount() == 0) {\n             return InfoSetUtil.number(context.getCurrentNodePointer());\n         }\n         assertArgCount(1);\n         return InfoSetUtil.number(getArg1().computeValue(context));\n     }\n \n-    protected Object functionSum(EvalContext context){\n+    protected Object functionSum(EvalContext context) {\n         assertArgCount(1);\n         Object v = getArg1().compute(context);\n-        if (v == null){\n+        if (v == null) {\n             return ZERO;\n         }\n-        else if (v instanceof EvalContext){\n+        else if (v instanceof EvalContext) {\n             double sum = 0.0;\n-            EvalContext ctx = (EvalContext)v;\n-            while (ctx.hasNext()){\n-                NodePointer ptr = (NodePointer)ctx.next();\n+            EvalContext ctx = (EvalContext) v;\n+            while (ctx.hasNext()) {\n+                NodePointer ptr = (NodePointer) ctx.next();\n                 sum += InfoSetUtil.doubleValue(ptr);\n             }\n             return new Double(sum);\n         }\n-        throw new JXPathException(\"Invalid argument type for 'sum': \"\n-            + v.getClass().getName());\n-    }\n-\n-    protected Object functionFloor(EvalContext context){\n+        throw new JXPathException(\n+            \"Invalid argument type for 'sum': \" + v.getClass().getName());\n+    }\n+\n+    protected Object functionFloor(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.floor(v));\n     }\n \n-    protected Object functionCeiling(EvalContext context){\n+    protected Object functionCeiling(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.ceil(v));\n     }\n \n-    protected Object functionRound(EvalContext context){\n+    protected Object functionRound(EvalContext context) {\n         assertArgCount(1);\n         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n         return new Double(Math.round(v));\n     }\n \n-    private void assertArgCount(int count){\n-        if (getArgumentCount() != count){\n+    private void assertArgCount(int count) {\n+        if (getArgumentCount() != count) {\n             throw new JXPathException(\"Incorrect number of argument: \" + this);\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.8 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.compiler;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n \n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.EvalContext;\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class CoreOperation extends Operation {\n-    public CoreOperation(int code, Expression args[]){\n+    public CoreOperation(int code, Expression args[]) {\n         super(code, args);\n     }\n \n-    public CoreOperation(int code, Expression arg){\n+    public CoreOperation(int code, Expression arg) {\n         super(code, new Expression[]{arg});\n     }\n \n-    public CoreOperation(int code, Expression arg1, Expression arg2){\n+    public CoreOperation(int code, Expression arg1, Expression arg2) {\n         super(code, new Expression[]{arg1, arg2});\n     }\n \n-    public Expression getArg1(){\n+    public Expression getArg1() {\n         return args[0];\n     }\n \n-    public Expression getArg2(){\n+    public Expression getArg2() {\n         return args[1];\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n-    public Object computeValue(EvalContext context){\n-        switch (getExpressionTypeCode()){\n+    public Object computeValue(EvalContext context) {\n+        switch (getExpressionTypeCode()) {\n             case Expression.OP_UNION:\n                 return union(context, args[0], args[1]);\n \n     /**\n      * Computes <code>\"left | right\"<code>\n      */\n-    protected Object union(EvalContext context, Expression left, Expression right){\n+    protected Object union(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         Object l = left.compute(context);\n         Object r = right.compute(context);\n         EvalContext lctx;\n-        if (l instanceof EvalContext){\n-            lctx = (EvalContext)l;\n+        if (l instanceof EvalContext) {\n+            lctx = (EvalContext) l;\n         }\n         else {\n             lctx = context.getRootContext().getConstantContext(l);\n         }\n         EvalContext rctx;\n-        if (r instanceof EvalContext){\n-            rctx = (EvalContext)r;\n+        if (r instanceof EvalContext) {\n+            rctx = (EvalContext) r;\n         }\n         else {\n             rctx = context.getRootContext().getConstantContext(r);\n         }\n-        return new UnionContext(context.getRootContext(), new EvalContext[]{lctx, rctx});\n+        return new UnionContext(\n+            context.getRootContext(),\n+            new EvalContext[] { lctx, rctx });\n     }\n \n     /**\n      * Computes <code>\"-arg\"<code>\n      */\n-    protected Object minus(EvalContext context, Expression arg){\n+    protected Object minus(EvalContext context, Expression arg) {\n         double a = InfoSetUtil.doubleValue(arg.computeValue(context));\n         return new Double(-a);\n     }\n     /**\n      * Computes <code>\"a + b + c + d\"<code>\n      */\n-    protected Object sum(EvalContext context, Expression[] arguments){\n+    protected Object sum(EvalContext context, Expression[] arguments) {\n         double s = 0.0;\n-        for (int i = 0; i < arguments.length; i++){\n+        for (int i = 0; i < arguments.length; i++) {\n             s += InfoSetUtil.doubleValue(arguments[i].computeValue(context));\n         }\n         return new Double(s);\n     /**\n      * Computes <code>\"left - right\"<code>\n      */\n-    protected Object minus(EvalContext context, Expression left, Expression right){\n+    protected Object minus(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         double l = InfoSetUtil.doubleValue(left.computeValue(context));\n         double r = InfoSetUtil.doubleValue(right.computeValue(context));\n         return new Double(l - r);\n     /**\n      * Computes <code>\"left div right\"<code>\n      */\n-    protected Object div(EvalContext context, Expression left, Expression right){\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return new Double(l/r);\n+    protected Object div(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l / r);\n     }\n \n     /**\n      * Computes <code>\"left * right\"<code>\n      */\n-    protected Object mult(EvalContext context, Expression left, Expression right){\n-        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n-        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n-        return new Double(l*r);\n+    protected Object mult(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n+        double l = InfoSetUtil.doubleValue(left.computeValue(context));\n+        double r = InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l * r);\n     }\n \n     /**\n      * Computes <code>\"left mod right\"<code>\n      */\n-    protected Object mod(EvalContext context, Expression left, Expression right){\n-        long l = (long)InfoSetUtil.doubleValue(left.computeValue(context));\n-        long r = (long)InfoSetUtil.doubleValue(right.computeValue(context));\n-        return new Double(l%r);\n+    protected Object mod(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n+        long l = (long) InfoSetUtil.doubleValue(left.computeValue(context));\n+        long r = (long) InfoSetUtil.doubleValue(right.computeValue(context));\n+        return new Double(l % r);\n     }\n \n     /**\n      * Computes <code>\"left &lt; right\"<code>\n      */\n-    protected Object lt(EvalContext context, Expression left, Expression right){\n+    protected Object lt(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         double l = InfoSetUtil.doubleValue(left.computeValue(context));\n         double r = InfoSetUtil.doubleValue(right.computeValue(context));\n         return l < r ? Boolean.TRUE : Boolean.FALSE;\n     /**\n      * Computes <code>\"left &gt; right\"<code>\n      */\n-    protected Object gt(EvalContext context, Expression left, Expression right){\n+    protected Object gt(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         double l = InfoSetUtil.doubleValue(left.computeValue(context));\n         double r = InfoSetUtil.doubleValue(right.computeValue(context));\n         return l > r ? Boolean.TRUE : Boolean.FALSE;\n     /**\n      * Computes <code>\"left &lt;= right\"<code>\n      */\n-    protected Object lte(EvalContext context, Expression left, Expression right){\n+    protected Object lte(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         double l = InfoSetUtil.doubleValue(left.computeValue(context));\n         double r = InfoSetUtil.doubleValue(right.computeValue(context));\n         return l <= r ? Boolean.TRUE : Boolean.FALSE;\n     /**\n      * Computes <code>\"left &gt;= right\"<code>\n      */\n-    protected Object gte(EvalContext context, Expression left, Expression right){\n+    protected Object gte(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         double l = InfoSetUtil.doubleValue(left.computeValue(context));\n         double r = InfoSetUtil.doubleValue(right.computeValue(context));\n         return l >= r ? Boolean.TRUE : Boolean.FALSE;\n     /**\n      * Computes <code>\"left = right\"<code>\n      */\n-    protected Object eq(EvalContext context, Expression left, Expression right){\n+    protected Object eq(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         return equal(context, left, right) ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     /**\n      * Computes <code>\"left != right\"<code>\n      */\n-    protected Object ne(EvalContext context, Expression left, Expression right){\n+    protected Object ne(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         return equal(context, left, right) ? Boolean.FALSE : Boolean.TRUE;\n     }\n \n     /**\n      * Compares two values\n      */\n-    protected boolean equal(EvalContext context, Expression left, Expression right){\n+    protected boolean equal(\n+        EvalContext context,\n+        Expression left,\n+        Expression right) \n+    {\n         Object l = left.compute(context);\n         Object r = right.compute(context);\n \n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext){\n-            l = ((EvalContext)l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext){\n-            r = ((EvalContext)r).getSingleNodePointer();\n-        }\n-\n-        if (l instanceof Collection){\n-            l = ((Collection)l).iterator();\n-        }\n-\n-        if (r instanceof Collection){\n-            r = ((Collection)r).iterator();\n-        }\n-\n-        if ((l instanceof Iterator) && !(r instanceof Iterator)){\n-            return contains((Iterator)l, r);\n-        }\n-        else if (!(l instanceof Iterator) && (r instanceof Iterator)){\n-            return contains((Iterator)r, l);\n-        }\n-        else if (l instanceof Iterator && r instanceof Iterator){\n-            return findMatch((Iterator)l, (Iterator)r);\n+        if (l instanceof InitialContext || l instanceof SelfContext) {\n+            l = ((EvalContext) l).getSingleNodePointer();\n+        }\n+\n+        if (r instanceof InitialContext || r instanceof SelfContext) {\n+            r = ((EvalContext) r).getSingleNodePointer();\n+        }\n+\n+        if (l instanceof Collection) {\n+            l = ((Collection) l).iterator();\n+        }\n+\n+        if (r instanceof Collection) {\n+            r = ((Collection) r).iterator();\n+        }\n+\n+        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n+            return contains((Iterator) l, r);\n+        }\n+        else if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n+            return contains((Iterator) r, l);\n+        }\n+        else if (l instanceof Iterator && r instanceof Iterator) {\n+            return findMatch((Iterator) l, (Iterator) r);\n         }\n \n         return equal(l, r);\n     }\n \n-    protected boolean contains(Iterator it, Object value){\n-        while (it.hasNext()){\n+    protected boolean contains(Iterator it, Object value) {\n+        while (it.hasNext()) {\n             Object element = it.next();\n-            if (equal(element, value)){\n+            if (equal(element, value)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    protected boolean findMatch(Iterator lit, Iterator rit){\n+    protected boolean findMatch(Iterator lit, Iterator rit) {\n         HashSet left = new HashSet();\n-        while (lit.hasNext()){\n+        while (lit.hasNext()) {\n             left.add(lit.next());\n         }\n-        while (rit.hasNext()){\n-            if (contains(left.iterator(), rit.next())){\n+        while (rit.hasNext()) {\n+            if (contains(left.iterator(), rit.next())) {\n                 return true;\n             }\n         }\n         return false;\n     }\n \n-    protected boolean equal(Object l, Object r){\n-        if (l instanceof Pointer && r instanceof Pointer){\n-            if (l.equals(r)){\n+    protected boolean equal(Object l, Object r) {\n+        if (l instanceof Pointer && r instanceof Pointer) {\n+            if (l.equals(r)) {\n                 return true;\n             }\n         }\n \n-        if (l instanceof Pointer){\n-            l = ((Pointer)l).getValue();\n-        }\n-\n-        if (r instanceof Pointer){\n-            r = ((Pointer)r).getValue();\n-        }\n-\n-        if (l == r){\n+        if (l instanceof Pointer) {\n+            l = ((Pointer) l).getValue();\n+        }\n+\n+        if (r instanceof Pointer) {\n+            r = ((Pointer) r).getValue();\n+        }\n+\n+        if (l == r) {\n             return true;\n         }\n \n //        System.err.println(\"COMPARING VALUES: \" + l + \" \" + r);\n-        if (l instanceof Boolean || r instanceof Boolean){\n+        if (l instanceof Boolean || r instanceof Boolean) {\n             return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n         }\n-        else if (l instanceof Number || r instanceof Number){\n+        else if (l instanceof Number || r instanceof Number) {\n             return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n         }\n-        else if (l instanceof String || r instanceof String){\n-            return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n-        }\n-        else if (l == null){\n+        else if (l instanceof String || r instanceof String) {\n+            return (\n+                InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n+        }\n+        else if (l == null) {\n             return r == null;\n         }\n         return l.equals(r);\n     /**\n      * Extracts all values from a context\n      */\n-    private Set valueSet(EvalContext context){\n+    private Set valueSet(EvalContext context) {\n         HashSet set = new HashSet();\n-        while(context.hasNext()){\n+        while (context.hasNext()) {\n             context.next();\n             NodePointer pointer = context.getCurrentNodePointer();\n             set.add(pointer.getValue());\n     /**\n      * Computes <code>\"left and right\"<code>\n      */\n-    protected Object and(EvalContext context, Expression[] arguments){\n-        for (int i = 0; i < arguments.length; i++){\n-            if (!InfoSetUtil.booleanValue(arguments[i].computeValue(context))){\n+    protected Object and(EvalContext context, Expression[] arguments) {\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!InfoSetUtil.booleanValue(arguments[i].computeValue(context))) {\n                 return Boolean.FALSE;\n             }\n         }\n     /**\n      * Computes <code>\"left or right\"<code>\n      */\n-    protected Object or(EvalContext context, Expression[] arguments){\n-        for (int i = 0; i < arguments.length; i++){\n-            if (InfoSetUtil.booleanValue(arguments[i].computeValue(context))){\n+    protected Object or(EvalContext context, Expression[] arguments) {\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (InfoSetUtil.booleanValue(arguments[i].computeValue(context))) {\n                 return Boolean.TRUE;\n             }\n         }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,v 1.4 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * provides that hint.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:23 $\n  */\n public abstract class Expression {\n \n \n     public static final int OP_KEY_LOOKUP = 23;\n \n-    protected static Double ZERO = new Double(0);\n-    protected static Double ONE = new Double(1);\n-    protected static Double NaN = new Double(Double.NaN);\n+    protected static final Double ZERO = new Double(0);\n+    protected static final Double ONE = new Double(1);\n+    protected static final Double NOT_A_NUMBER = new Double(Double.NaN);\n \n     private int typeCode;\n \n     private boolean contextDependencyKnown = false;\n     private boolean contextDependent;\n \n-    protected Expression(int typeCode){\n+    protected Expression(int typeCode) {\n         this.typeCode = typeCode;\n     }\n \n-    public int getExpressionTypeCode(){\n+    public int getExpressionTypeCode() {\n         return typeCode;\n     }\n \n-    protected Expression[] getArguments(){\n+    protected Expression[] getArguments() {\n         return null;\n     }\n \n      * Returns true if this expression should be re-evaluated\n      * each time the current position in the context changes.\n      */\n-    public boolean isContextDependent(){\n-        if (!contextDependencyKnown){\n+    public boolean isContextDependent() {\n+        if (!contextDependencyKnown) {\n             contextDependent = computeContextDependent();\n             contextDependencyKnown = true;\n         }\n      */\n     public abstract boolean computeContextDependent();\n \n-    public String toString(){\n+    public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('(');\n         buffer.append(opCodeToString());\n         Expression args[] = getArguments();\n-        if (args != null){\n+        if (args != null) {\n             buffer.append(' ');\n-            for (int i = 0; i < args.length; i++){\n-                if (i > 0){\n+            for (int i = 0; i < args.length; i++) {\n+                if (i > 0) {\n                     buffer.append(\", \");\n                 }\n                 buffer.append(args[i]);\n         return buffer.toString();\n     }\n \n-    protected String opCodeToString(){\n-        switch(typeCode){\n+    protected String opCodeToString() {\n+        switch(typeCode) {\n             case OP_CONSTANT: return \"CONST\";\n             case OP_STEP: return \"STEP\";\n             case OP_SUM: return \"SUM\";\n     public abstract Object computeValue(EvalContext context);\n     public abstract Object compute(EvalContext context);\n \n-    public Iterator iterate(EvalContext context){\n+    public Iterator iterate(EvalContext context) {\n         Object result = compute(context);\n-        if (result instanceof EvalContext){\n-            return new ValueIterator((EvalContext)result);\n+        if (result instanceof EvalContext) {\n+            return new ValueIterator((EvalContext) result);\n         }\n         return ValueUtils.iterate(result);\n     }\n \n-    public Iterator iteratePointers(EvalContext context){\n+    public Iterator iteratePointers(EvalContext context) {\n         Object result = compute(context);\n-        if (result == null){\n+        if (result == null) {\n             return Collections.EMPTY_LIST.iterator();\n         }\n-        if (result instanceof EvalContext){\n-            return (EvalContext)result;\n+        if (result instanceof EvalContext) {\n+            return (EvalContext) result;\n         }\n         return new PointerIterator(ValueUtils.iterate(result),\n                 new QName(null, \"value\"),\n         private QName qname;\n         private Locale locale;\n \n-        public PointerIterator(Iterator it, QName qname, Locale locale){\n+        public PointerIterator(Iterator it, QName qname, Locale locale) {\n             this.iterator = it;\n             this.qname = qname;\n             this.locale = locale;\n         }\n \n-        public boolean hasNext(){\n+        public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n-        public Object next(){\n+        public Object next() {\n             Object o = iterator.next();\n             return NodePointer.newNodePointer(qname, o, locale);\n         }\n \n-        public void remove(){\n+        public void remove() {\n             throw new UnsupportedOperationException();\n         }\n     }\n     public static class ValueIterator implements Iterator {\n         private Iterator iterator;\n \n-        public ValueIterator(Iterator it){\n+        public ValueIterator(Iterator it) {\n             this.iterator = it;\n         }\n \n-        public boolean hasNext(){\n+        public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n-        public Object next(){\n+        public Object next() {\n             Object o = iterator.next();\n-            if (o instanceof Pointer){\n-                return ((Pointer)o).getValue();\n+            if (o instanceof Pointer) {\n+                return ((Pointer) o).getValue();\n             }\n             return o;\n         }\n \n-        public void remove(){\n+        public void remove() {\n             throw new UnsupportedOperationException();\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.5 2002/08/10 01:39:29 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/08/10 01:39:29 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExpressionPath.java,v 1.6 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.axes.*;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n+import org.apache.commons.jxpath.ri.axes.PredicateContext;\n+import org.apache.commons.jxpath.ri.axes.SimplePathInterpreter;\n+import org.apache.commons.jxpath.ri.axes.UnionContext;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * An element of the parse tree that represents an expression path, which is\n- * a path that starts with an expression like a function call: <code>getFoo(.)/bar</code>.\n+ * An  element of the parse tree that represents an expression path, which is a\n+ * path that starts with an expression like a function call: <code>getFoo(.)\n+ * /bar</code>.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/08/10 01:39:29 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class ExpressionPath extends Path {\n \n     private boolean basicKnown = false;\n     private boolean basic;\n \n-    public ExpressionPath(Expression expression, Expression[] predicates, Step[] steps){\n+    public ExpressionPath(\n+        Expression expression,\n+        Expression[] predicates,\n+        Step[] steps) \n+    {\n         super(Expression.OP_EXPRESSION_PATH, steps);\n         this.expression = expression;\n         this.predicates = predicates;\n     }\n \n-    public Expression getExpression(){\n+    public Expression getExpression() {\n         return expression;\n     }\n \n      * Predicates are the expressions in brackets that may follow\n      * the root expression of the path.\n      */\n-    public Expression[] getPredicates(){\n+    public Expression[] getPredicates() {\n         return predicates;\n     }\n \n      * Returns true if the root expression or any of the\n      * predicates or the path steps are context dependent.\n      */\n-    public boolean computeContextDependent(){\n-        if (expression.isContextDependent()){\n+    public boolean computeContextDependent() {\n+        if (expression.isContextDependent()) {\n             return true;\n         }\n-        if (predicates != null){\n-            for (int i = 0; i < predicates.length; i++){\n-                if (predicates[i].isContextDependent()){\n+        if (predicates != null) {\n+            for (int i = 0; i < predicates.length; i++) {\n+                if (predicates[i].isContextDependent()) {\n                     return true;\n                 }\n             }\n      * Recognized paths formatted as <code>$x[3]/foo[2]</code>.  The\n      * evaluation of such \"simple\" paths is optimized and streamlined.\n      */\n-    public boolean isSimpleExpressionPath(){\n-        if (!basicKnown){\n+    public boolean isSimpleExpressionPath() {\n+        if (!basicKnown) {\n             basicKnown = true;\n             basic = isSimplePath() && areBasicPredicates(getPredicates());\n         }\n         return basic;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"(EXPRESSION-PATH \");\n         buffer.append(expression);\n \n-        if (predicates != null){\n+        if (predicates != null) {\n             buffer.append(' ');\n-            for (int i = 0; i < predicates.length; i++){\n+            for (int i = 0; i < predicates.length; i++) {\n                 buffer.append('[');\n                 buffer.append(predicates[i]);\n                 buffer.append(']');\n         }\n \n         Step steps[] = getSteps();\n-        if (steps != null){\n+        if (steps != null) {\n             buffer.append(' ');\n-            for (int i = 0; i < steps.length; i++){\n-                if (i > 0){\n+            for (int i = 0; i < steps.length; i++) {\n+                if (i > 0) {\n                     buffer.append(\", \");\n                 }\n                 buffer.append(steps[i]);\n         return buffer.toString();\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return expressionPath(context, false);\n     }\n \n-    public Object computeValue(EvalContext context){\n+    public Object computeValue(EvalContext context) {\n         return expressionPath(context, true);\n     }\n \n     /**\n      * Walks an expression path (a path that starts with an expression)\n      */\n-    protected Object expressionPath(EvalContext evalContext, boolean firstMatch){\n+    protected Object expressionPath(\n+        EvalContext evalContext,\n+        boolean firstMatch) \n+    {\n         Object value = expression.compute(evalContext);\n         EvalContext context;\n-        if (value instanceof InitialContext){\n-            // This is an optimization. We can avoid iterating through a collection\n-            // if the context bean is in fact one.\n-            context = (InitialContext)value;\n-        }\n-        else if (value instanceof EvalContext){\n+        if (value instanceof InitialContext) {\n+            // This is an optimization. We can avoid iterating through a \n+            // collection if the context bean is in fact one.\n+            context = (InitialContext) value;\n+        }\n+        else if (value instanceof EvalContext) {\n             // UnionContext will collect all values from the \"value\" context\n             // and treat the whole thing as a big collection.\n-            context = new UnionContext(evalContext, new EvalContext[]{(EvalContext)value});\n+            context =\n+                new UnionContext(\n+                    evalContext,\n+                    new EvalContext[] {(EvalContext) value });\n         }\n         else {\n             context = evalContext.getRootContext().getConstantContext(value);\n         }\n \n-\n-        if (firstMatch && isSimpleExpressionPath() &&\n-                !(context instanceof UnionContext)){\n+        if (firstMatch\n+            && isSimpleExpressionPath()\n+            && !(context instanceof UnionContext)) {\n             EvalContext ctx = context;\n-            NodePointer ptr = (NodePointer)ctx.getSingleNodePointer();\n-            if (ptr != null &&\n-                    (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n-                     predicates == null || predicates.length == 0)){\n-                return SimplePathInterpreter.\n-                    interpretSimpleExpressionPath(\n-                            evalContext, ptr, predicates, getSteps());\n-            }\n-        }\n-        if (predicates != null){\n-            for (int j = 0; j < predicates.length; j++){\n+            NodePointer ptr = (NodePointer) ctx.getSingleNodePointer();\n+            if (ptr != null\n+                && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION\n+                    || predicates == null\n+                    || predicates.length == 0)) {\n+                return SimplePathInterpreter.interpretSimpleExpressionPath(\n+                    evalContext,\n+                    ptr,\n+                    predicates,\n+                    getSteps());\n+            }\n+        }\n+        if (predicates != null) {\n+            for (int j = 0; j < predicates.length; j++) {\n                 context = new PredicateContext(context, predicates[j]);\n             }\n         }\n-        if (firstMatch){\n+        if (firstMatch) {\n             return getSingleNodePointerForSteps(context);\n         }\n         else {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.6 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.Arrays;\n \n /**\n- * Represents an element of the parse tree representing an extension function call.\n+ * Represents  an element of the parse tree representing an extension function\n+ * call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class ExtensionFunction extends Operation {\n \n     private QName functionName;\n \n-    public ExtensionFunction(QName functionName, Expression args[]){\n+    public ExtensionFunction(QName functionName, Expression args[]) {\n         super(Expression.OP_FUNCTION, args);\n         this.functionName = functionName;\n     }\n \n-    public QName getFunctionName(){\n+    public QName getFunctionName() {\n         return functionName;\n     }\n \n      * An extension function gets the current context, therefore it MAY be\n      * context dependent.\n      */\n-    public boolean computeContextDependent(){\n+    public boolean computeContextDependent() {\n         return true;\n     }\n \n-    public String opCodeToString(){\n+    public String opCodeToString() {\n         return super.opCodeToString() + ':' + functionName;\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n-    public Object computeValue(EvalContext context){\n+    public Object computeValue(EvalContext context) {\n         Object[] parameters = null;\n-        if (args != null){\n+        if (args != null) {\n             parameters = new Object[args.length];\n-            for (int i = 0; i < args.length; i++){\n+            for (int i = 0; i < args.length; i++) {\n                 Object param = args[i].compute(context);\n                 parameters[i] = param;\n             }\n         }\n-        Function function = context.getRootContext().getFunction(functionName, parameters);\n-        if (function == null){\n-            throw new JXPathException(\"No such function: \" + functionName +\n-                 Arrays.asList(parameters));\n+        Function function =\n+            context.getRootContext().getFunction(functionName, parameters);\n+        if (function == null) {\n+            throw new JXPathException(\n+                \"No such function: \"\n+                    + functionName\n+                    + Arrays.asList(parameters));\n         }\n \n         return function.invoke(context, parameters);\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/LocationPath.java,v 1.6 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class LocationPath extends Path {\n \n     private boolean absolute;\n \n-    public LocationPath(boolean absolute, Step[] steps){\n+    public LocationPath(boolean absolute, Step[] steps) {\n         super(Expression.OP_LOCATION_PATH, steps);\n         this.absolute = absolute;\n     }\n \n-    public boolean isAbsolute(){\n+    public boolean isAbsolute() {\n         return absolute;\n     }\n \n-    public boolean computeContextDependent(){\n-        if (!absolute){\n+    public boolean computeContextDependent() {\n+        if (!absolute) {\n             return true;\n         }\n \n         return super.computeContextDependent();\n     }\n \n-    public String toString(){\n+    public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(\"(PATH\");\n-        if (absolute){\n+        if (absolute) {\n             buffer.append(\"[absolute] \");\n         }\n-        else{\n+        else {\n             buffer.append(\"[relative] \");\n         }\n         Step args[] = getSteps();\n-        if (args != null){\n+        if (args != null) {\n             buffer.append(' ');\n-            for (int i = 0; i < args.length; i++){\n-                if (i > 0){\n+            for (int i = 0; i < args.length; i++) {\n+                if (i > 0) {\n                     buffer.append(\", \");\n                 }\n                 buffer.append(args[i]);\n         return buffer.toString();\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n-        if (isAbsolute()){\n+        if (isAbsolute()) {\n             rootContext = context.getRootContext();\n         }\n         else {\n     }\n \n \n-    public Object computeValue(EvalContext context){\n+    public Object computeValue(EvalContext context) {\n         // Create a chain of contexts\n         EvalContext rootContext;\n         if (isAbsolute()) {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NameAttributeTest.java\n  * or maps.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class NameAttributeTest extends CoreOperation {\n \n-    public NameAttributeTest(Expression namePath, Expression nameValue){\n+    public NameAttributeTest(Expression namePath, Expression nameValue) {\n         super(OP_EQ, namePath, nameValue);\n     }\n \n-    public Expression getNameTestExpression(){\n+    public Expression getNameTestExpression() {\n         return getArg2();\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.4 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.5 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class NodeNameTest extends NodeTest {\n     private QName qname;\n \n-    public NodeNameTest(QName qname){\n+    public NodeNameTest(QName qname) {\n         this.qname = qname;\n     }\n \n-    public QName getNodeName(){\n+    public QName getNodeName() {\n         return qname;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return qname.toString();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeTypeTest.java,v 1.4 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class NodeTypeTest extends NodeTest {\n     private int nodeType;\n \n-    public NodeTypeTest(int nodeType){\n+    public NodeTypeTest(int nodeType) {\n         this.nodeType = nodeType;\n     }\n \n-    public int getNodeType(){\n+    public int getNodeType() {\n         return nodeType;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return nodeTypeToString(nodeType) + \"()\";\n     }\n \n-    public static String nodeTypeToString(int code){\n-        switch(code){\n-            case Compiler.NODE_TYPE_NODE: return \"node\";\n-            case Compiler.NODE_TYPE_TEXT: return \"text\";\n-            case Compiler.NODE_TYPE_COMMENT: return \"comment\";\n-            case Compiler.NODE_TYPE_PI: return \"processing-instruction\";\n+    public static String nodeTypeToString(int code) {\n+        switch (code) {\n+            case Compiler.NODE_TYPE_NODE :\n+                return \"node\";\n+            case Compiler.NODE_TYPE_TEXT :\n+                return \"text\";\n+            case Compiler.NODE_TYPE_COMMENT :\n+                return \"comment\";\n+            case Compiler.NODE_TYPE_PI :\n+                return \"processing-instruction\";\n         }\n         return \"UNKNOWN\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java,v 1.3 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Operation.java,v 1.4 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:23 $\n  */\n public abstract class Operation extends Expression {\n \n     protected Expression args[];\n \n-    public Operation(int code, Expression args[]){\n+    public Operation(int code, Expression args[]) {\n         super(code);\n         this.args = args;\n     }\n \n-    public Expression[] getArguments(){\n+    public Expression[] getArguments() {\n         return args;\n     }\n \n-    public boolean computeContextDependent(){\n-        if (args != null){\n-            for (int i = 0; i < args.length; i++){\n-                if (args[i].isContextDependent()){\n+    public boolean computeContextDependent() {\n+        if (args != null) {\n+            for (int i = 0; i < args.length; i++) {\n+                if (args[i].isContextDependent()) {\n                     return true;\n                 }\n             }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.6 2002/10/13 02:59:01 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/13 02:59:01 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.7 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.EvalContext;\n+import org.apache.commons.jxpath.ri.axes.AncestorContext;\n+import org.apache.commons.jxpath.ri.axes.AttributeContext;\n+import org.apache.commons.jxpath.ri.axes.ChildContext;\n+import org.apache.commons.jxpath.ri.axes.DescendantContext;\n+import org.apache.commons.jxpath.ri.axes.NamespaceContext;\n+import org.apache.commons.jxpath.ri.axes.ParentContext;\n+import org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext;\n+import org.apache.commons.jxpath.ri.axes.PredicateContext;\n+import org.apache.commons.jxpath.ri.axes.SelfContext;\n+import org.apache.commons.jxpath.ri.axes.SimplePathInterpreter;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.apache.commons.jxpath.ri.axes.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/10/13 02:59:01 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:23 $\n  */\n public abstract class Path extends Expression {\n \n     private boolean basicKnown = false;\n     private boolean basic;\n \n-    public Path(int typeCode, Step[] steps){\n+    public Path(int typeCode, Step[] steps) {\n         super(typeCode);\n         this.steps = steps;\n     }\n \n-    public Step[] getSteps(){\n+    public Step[] getSteps() {\n         return steps;\n     }\n \n-    public boolean computeContextDependent(){\n-        if (steps != null){\n-            for (int i = 0; i < steps.length; i++){\n-                if (steps[i].isContextDependent()){\n+    public boolean computeContextDependent() {\n+        if (steps != null) {\n+            for (int i = 0; i < steps.length; i++) {\n+                if (steps[i].isContextDependent()) {\n                     return true;\n                 }\n             }\n     }\n \n     /**\n-     * Recognized paths formatted as <code>foo/bar[3]/baz[@name = 'biz']</code>.  The\n-     * evaluation of such \"simple\" paths is optimized and streamlined.\n-     */\n-    public boolean isSimplePath(){\n-        if (!basicKnown){\n+     * Recognized  paths formatted as <code>foo/bar[3]/baz[@name = 'biz']\n+     * </code>.  The evaluation of such \"simple\" paths is optimized and\n+     * streamlined.\n+     */\n+    public boolean isSimplePath() {\n+        if (!basicKnown) {\n             basicKnown = true;\n             basic = true;\n             Step[] steps = getSteps();\n-            for (int i = 0; i < steps.length; i++){\n+            for (int i = 0; i < steps.length; i++) {\n                 boolean accepted = false;\n-                if (steps[i].getAxis() == Compiler.AXIS_SELF &&\n-                        (steps[i].getNodeTest() instanceof NodeTypeTest) &&\n-                        ((NodeTypeTest)steps[i].getNodeTest()).getNodeType() ==\n-                                Compiler.NODE_TYPE_NODE){\n+                if (steps[i].getAxis() == Compiler.AXIS_SELF\n+                    && (steps[i].getNodeTest() instanceof NodeTypeTest)\n+                    && ((NodeTypeTest) steps[i].getNodeTest()).getNodeType()\n+                        == Compiler.NODE_TYPE_NODE) {\n                     accepted = true;\n                 }\n-                else if ((steps[i].getAxis() == Compiler.AXIS_CHILD ||\n-                          steps[i].getAxis() == Compiler.AXIS_ATTRIBUTE)  &&\n-                        (steps[i].getNodeTest() instanceof NodeNameTest) &&\n-                        !((NodeNameTest)steps[i].getNodeTest()).\n-                                    getNodeName().getName().equals(\"*\")){\n+                else if (\n+                    (steps[i].getAxis() == Compiler.AXIS_CHILD\n+                        || steps[i].getAxis() == Compiler.AXIS_ATTRIBUTE)\n+                        && (steps[i].getNodeTest() instanceof NodeNameTest)\n+                        && !((NodeNameTest) steps[i].getNodeTest())\n+                            .getNodeName()\n+                            .getName()\n+                            .equals(\n+                            \"*\")) {\n                     accepted = true;\n                 }\n-                if (accepted){\n+                if (accepted) {\n                     accepted = areBasicPredicates(steps[i].getPredicates());\n                 }\n-                if (!accepted){\n+                if (!accepted) {\n                     basic = false;\n                     break;\n                 }\n         return basic;\n     }\n \n-    protected boolean areBasicPredicates(Expression predicates[]){\n-        if (predicates != null && predicates.length != 0){\n+    protected boolean areBasicPredicates(Expression predicates[]) {\n+        if (predicates != null && predicates.length != 0) {\n             boolean firstIndex = true;\n-            for (int i = 0; i < predicates.length; i++){\n-                if (predicates[i] instanceof NameAttributeTest){\n-                    if (((NameAttributeTest)predicates[i]).\n-                                getNameTestExpression().isContextDependent()){\n+            for (int i = 0; i < predicates.length; i++) {\n+                if (predicates[i] instanceof NameAttributeTest) {\n+                    if (((NameAttributeTest) predicates[i])\n+                        .getNameTestExpression()\n+                        .isContextDependent()) {\n                         return false;\n                     }\n                 }\n-                else if (predicates[i].isContextDependent()){\n+                else if (predicates[i].isContextDependent()) {\n                     return false;\n                 }\n                 else {\n-                    if (!firstIndex){\n+                    if (!firstIndex) {\n                         return false;\n                     }\n                     firstIndex = false;\n      * Given a root context, walks a path therefrom and finds the\n      * pointer to the first element matching the path.\n      */\n-    protected Pointer getSingleNodePointerForSteps(EvalContext context){\n-        if (steps.length == 0){\n+    protected Pointer getSingleNodePointerForSteps(EvalContext context) {\n+        if (steps.length == 0) {\n             return context.getSingleNodePointer();\n         }\n \n-        if (isSimplePath()){\n-            NodePointer ptr = (NodePointer)context.getSingleNodePointer();\n-            return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps);\n+        if (isSimplePath()) {\n+            NodePointer ptr = (NodePointer) context.getSingleNodePointer();\n+            return SimplePathInterpreter.interpretSimpleLocationPath(\n+                context,\n+                ptr,\n+                steps);\n         }\n         else {\n             return searchForPath(context);\n     }\n \n     private Pointer searchForPath(EvalContext context) {\n-        for (int i = 0; i < steps.length; i++){\n-            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+        for (int i = 0; i < steps.length; i++) {\n+            context =\n+                createContextForStep(\n+                    context,\n+                    steps[i].getAxis(),\n+                    steps[i].getNodeTest());\n             Expression predicates[] = steps[i].getPredicates();\n-            if (predicates != null){\n-                for (int j = 0; j < predicates.length; j++){\n+            if (predicates != null) {\n+                for (int j = 0; j < predicates.length; j++) {\n                     context = new PredicateContext(context, predicates[j]);\n                 }\n             }\n      * Given a root context, walks a path therefrom and builds a context\n      * that contains all nodes matching the path.\n      */\n-    protected EvalContext evalSteps(EvalContext context){\n-        if (steps.length == 0){\n+    protected EvalContext evalSteps(EvalContext context) {\n+        if (steps.length == 0) {\n             return context;\n         }\n \n-        for (int i = 0; i < steps.length; i++){\n-            context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest());\n+        for (int i = 0; i < steps.length; i++) {\n+            context =\n+                createContextForStep(\n+                    context,\n+                    steps[i].getAxis(),\n+                    steps[i].getNodeTest());\n             Expression predicates[] = steps[i].getPredicates();\n-            if (predicates != null){\n-                for (int j = 0; j < predicates.length; j++){\n+            if (predicates != null) {\n+                for (int j = 0; j < predicates.length; j++) {\n                     context = new PredicateContext(context, predicates[j]);\n                 }\n             }\n      * Different axes are serviced by different contexts. This method\n      * allocates the right context for the supplied step.\n      */\n-    protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest){\n-        switch(axis){\n-            case Compiler.AXIS_ANCESTOR:\n+    protected EvalContext createContextForStep(\n+        EvalContext context,\n+        int axis,\n+        NodeTest nodeTest) \n+    {\n+        switch (axis) {\n+            case Compiler.AXIS_ANCESTOR :\n                 return new AncestorContext(context, false, nodeTest);\n-            case Compiler.AXIS_ANCESTOR_OR_SELF:\n+            case Compiler.AXIS_ANCESTOR_OR_SELF :\n                 return new AncestorContext(context, true, nodeTest);\n-            case Compiler.AXIS_ATTRIBUTE:\n+            case Compiler.AXIS_ATTRIBUTE :\n                 return new AttributeContext(context, nodeTest);\n-            case Compiler.AXIS_CHILD:\n+            case Compiler.AXIS_CHILD :\n                 return new ChildContext(context, nodeTest, false, false);\n-            case Compiler.AXIS_DESCENDANT:\n+            case Compiler.AXIS_DESCENDANT :\n                 return new DescendantContext(context, false, nodeTest);\n-            case Compiler.AXIS_DESCENDANT_OR_SELF:\n+            case Compiler.AXIS_DESCENDANT_OR_SELF :\n                 return new DescendantContext(context, true, nodeTest);\n-            case Compiler.AXIS_FOLLOWING:\n-                return new PrecedingOrFollowingContext(context, nodeTest, false);\n-            case Compiler.AXIS_FOLLOWING_SIBLING:\n+            case Compiler.AXIS_FOLLOWING :\n+                return new PrecedingOrFollowingContext(\n+                    context,\n+                    nodeTest,\n+                    false);\n+            case Compiler.AXIS_FOLLOWING_SIBLING :\n                 return new ChildContext(context, nodeTest, true, false);\n-            case Compiler.AXIS_NAMESPACE:\n+            case Compiler.AXIS_NAMESPACE :\n                 return new NamespaceContext(context, nodeTest);\n-            case Compiler.AXIS_PARENT:\n+            case Compiler.AXIS_PARENT :\n                 return new ParentContext(context, nodeTest);\n-            case Compiler.AXIS_PRECEDING:\n+            case Compiler.AXIS_PRECEDING :\n                 return new PrecedingOrFollowingContext(context, nodeTest, true);\n-            case Compiler.AXIS_PRECEDING_SIBLING:\n+            case Compiler.AXIS_PRECEDING_SIBLING :\n                 return new ChildContext(context, nodeTest, true, true);\n-            case Compiler.AXIS_SELF:\n+            case Compiler.AXIS_SELF :\n                 return new SelfContext(context, nodeTest);\n         }\n-        return null;        // Never happens\n+        return null; // Never happens\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java,v 1.3 2002/04/24 04:05:38 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/24 04:05:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ProcessingInstructionTest.java,v 1.4 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/24 04:05:38 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class ProcessingInstructionTest extends NodeTest {\n     private String target;\n \n-    public ProcessingInstructionTest(String target){\n+    public ProcessingInstructionTest(String target) {\n         this.target = target;\n     }\n \n-    public String getTarget(){\n+    public String getTarget() {\n         return target;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"processing-instruction(\" + target + \")\";\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Step.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Step.java,v 1.5 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class Step {\n     private int axis;\n     private NodeTest nodeTest;\n     private Expression[] predicates;\n \n-    protected Step(int axis, NodeTest nodeTest, Expression[] predicates){\n+    protected Step(int axis, NodeTest nodeTest, Expression[] predicates) {\n         this.axis = axis;\n         this.nodeTest = nodeTest;\n         this.predicates = predicates;\n     }\n \n-    public int getAxis(){\n+    public int getAxis() {\n         return axis;\n     }\n \n-    public NodeTest getNodeTest(){\n+    public NodeTest getNodeTest() {\n         return nodeTest;\n     }\n \n-    public Expression[] getPredicates(){\n+    public Expression[] getPredicates() {\n         return predicates;\n     }\n \n-    public boolean isContextDependent(){\n-        if (predicates != null){\n-            for (int i = 0; i < predicates.length; i++){\n-                if (predicates[i].isContextDependent()){\n+    public boolean isContextDependent() {\n+        if (predicates != null) {\n+            for (int i = 0; i < predicates.length; i++) {\n+                if (predicates[i].isContextDependent()) {\n                     return true;\n                 }\n             }\n         return false;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(axisToString(getAxis()));\n         buffer.append(\"::\");\n         buffer.append(nodeTest);\n         Expression[] predicates = getPredicates();\n-        if (predicates != null){\n-            for (int i = 0; i < predicates.length; i++){\n+        if (predicates != null) {\n+            for (int i = 0; i < predicates.length; i++) {\n                 buffer.append('[');\n                 buffer.append(predicates[i]);\n                 buffer.append(']');\n         return buffer.toString();\n     }\n \n-    public static String axisToString(int axis){\n-        switch (axis){\n-            case Compiler.AXIS_SELF:                 return \"self\";\n-            case Compiler.AXIS_CHILD:                return \"child\";\n-            case Compiler.AXIS_PARENT:               return \"parent\";\n-            case Compiler.AXIS_ANCESTOR:             return \"ancestor\";\n-            case Compiler.AXIS_ATTRIBUTE:            return \"attribute\";\n-            case Compiler.AXIS_NAMESPACE:            return \"namespace\";\n-            case Compiler.AXIS_PRECEDING:            return \"preceding\";\n-            case Compiler.AXIS_FOLLOWING:            return \"following\";\n-            case Compiler.AXIS_DESCENDANT:           return \"descendant\";\n-            case Compiler.AXIS_ANCESTOR_OR_SELF:     return \"ancestor-or-self\";\n-            case Compiler.AXIS_FOLLOWING_SIBLING:    return \"following-sibling\";\n-            case Compiler.AXIS_PRECEDING_SIBLING:    return \"preceding-sibling\";\n-            case Compiler.AXIS_DESCENDANT_OR_SELF:   return \"descendant-or-self\";\n+    public static String axisToString(int axis) {\n+        switch (axis) {\n+            case Compiler.AXIS_SELF :\n+                return \"self\";\n+            case Compiler.AXIS_CHILD :\n+                return \"child\";\n+            case Compiler.AXIS_PARENT :\n+                return \"parent\";\n+            case Compiler.AXIS_ANCESTOR :\n+                return \"ancestor\";\n+            case Compiler.AXIS_ATTRIBUTE :\n+                return \"attribute\";\n+            case Compiler.AXIS_NAMESPACE :\n+                return \"namespace\";\n+            case Compiler.AXIS_PRECEDING :\n+                return \"preceding\";\n+            case Compiler.AXIS_FOLLOWING :\n+                return \"following\";\n+            case Compiler.AXIS_DESCENDANT :\n+                return \"descendant\";\n+            case Compiler.AXIS_ANCESTOR_OR_SELF :\n+                return \"ancestor-or-self\";\n+            case Compiler.AXIS_FOLLOWING_SIBLING :\n+                return \"following-sibling\";\n+            case Compiler.AXIS_PRECEDING_SIBLING :\n+                return \"preceding-sibling\";\n+            case Compiler.AXIS_DESCENDANT_OR_SELF :\n+                return \"descendant-or-self\";\n         }\n         return \"UNKNOWN\";\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.5 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.6 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class TreeCompiler implements Compiler {\n \n     private static final QName QNAME_NAME = new QName(null, \"name\");\n \n-    public Object number(String value){\n+    public Object number(String value) {\n         return new Constant(new Double(value));\n     }\n \n-    public Object literal(String value){\n+    public Object literal(String value) {\n         return new Constant(value);\n     }\n \n-    public Object qname(String prefix, String name){\n+    public Object qname(String prefix, String name) {\n         return new QName(prefix, name);\n     }\n \n-    public Object sum(Object[] arguments){\n-        return new CoreOperation(Expression.OP_SUM, toExpressionArray(arguments));\n-    }\n-\n-    public Object minus(Object left, Object right){\n-        return new CoreOperation(Expression.OP_MINUS, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object multiply(Object left, Object right){\n-        return new CoreOperation(Expression.OP_MULT, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object divide(Object left, Object right){\n-        return new CoreOperation(Expression.OP_DIV, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object mod(Object left, Object right){\n-        return new CoreOperation(Expression.OP_MOD, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object lessThan(Object left, Object right){\n-        return new CoreOperation(Expression.OP_LT, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object lessThanOrEqual(Object left, Object right){\n-        return new CoreOperation(Expression.OP_LTE, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object greaterThan(Object left, Object right){\n-        return new CoreOperation(Expression.OP_GT, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object greaterThanOrEqual(Object left, Object right){\n-        return new CoreOperation(Expression.OP_GTE, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object equal(Object left, Object right){\n-        if (isNameAttributeTest((Expression)left)){\n-            return new NameAttributeTest((Expression)left, (Expression)right);\n+    public Object sum(Object[] arguments) {\n+        return new CoreOperation(\n+            Expression.OP_SUM,\n+            toExpressionArray(arguments));\n+    }\n+\n+    public Object minus(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_MINUS,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object multiply(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_MULT,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object divide(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_DIV,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object mod(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_MOD,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object lessThan(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_LT,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object lessThanOrEqual(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_LTE,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object greaterThan(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_GT,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object greaterThanOrEqual(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_GTE,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object equal(Object left, Object right) {\n+        if (isNameAttributeTest((Expression) left)) {\n+            return new NameAttributeTest((Expression) left, (Expression) right);\n         }\n         else {\n-            return new CoreOperation(Expression.OP_EQ, (Expression)left, (Expression)right);\n-        }\n-    }\n-\n-    public Object notEqual(Object left, Object right){\n-        return new CoreOperation(Expression.OP_NE, (Expression)left, (Expression)right);\n-    }\n-\n-    public Object minus(Object argument){\n-        return new CoreOperation(Expression.OP_UNARY_MINUS, (Expression)argument);\n-    }\n-\n-    public Object variableReference(Object qName){\n-        return new VariableReference((QName)qName);\n-    }\n-\n-    public Object function(int code, Object[] args){\n+            return new CoreOperation(\n+                Expression.OP_EQ,\n+                (Expression) left,\n+                (Expression) right);\n+        }\n+    }\n+\n+    public Object notEqual(Object left, Object right) {\n+        return new CoreOperation(\n+            Expression.OP_NE,\n+            (Expression) left,\n+            (Expression) right);\n+    }\n+\n+    public Object minus(Object argument) {\n+        return new CoreOperation(\n+            Expression.OP_UNARY_MINUS,\n+            (Expression) argument);\n+    }\n+\n+    public Object variableReference(Object qName) {\n+        return new VariableReference((QName) qName);\n+    }\n+\n+    public Object function(int code, Object[] args) {\n         return new CoreFunction(code, toExpressionArray(args));\n     }\n \n-    public Object function(Object name, Object[] args){\n-        return new ExtensionFunction((QName)name, toExpressionArray(args));\n-    }\n-\n-    public Object and(Object arguments[]){\n-        return new CoreOperation(Expression.OP_AND, toExpressionArray(arguments));\n-    }\n-\n-    public Object or(Object arguments[]){\n-        return new CoreOperation(Expression.OP_OR, toExpressionArray(arguments));\n-    }\n-\n-    public Object union(Object[] arguments){\n-        return new CoreOperation(Expression.OP_UNION, toExpressionArray(arguments));\n-    }\n-\n-    public Object locationPath(boolean absolute, Object[] steps){\n+    public Object function(Object name, Object[] args) {\n+        return new ExtensionFunction((QName) name, toExpressionArray(args));\n+    }\n+\n+    public Object and(Object arguments[]) {\n+        return new CoreOperation(\n+            Expression.OP_AND,\n+            toExpressionArray(arguments));\n+    }\n+\n+    public Object or(Object arguments[]) {\n+        return new CoreOperation(\n+            Expression.OP_OR,\n+            toExpressionArray(arguments));\n+    }\n+\n+    public Object union(Object[] arguments) {\n+        return new CoreOperation(\n+            Expression.OP_UNION,\n+            toExpressionArray(arguments));\n+    }\n+\n+    public Object locationPath(boolean absolute, Object[] steps) {\n         return new LocationPath(absolute, toStepArray(steps));\n     }\n \n-    public Object expressionPath(Object expression, Object[] predicates, Object[] steps){\n-        return new ExpressionPath((Expression)expression, toExpressionArray(predicates), toStepArray(steps));\n-    }\n-\n-    public Object nodeNameTest(Object qname){\n-        return new NodeNameTest((QName)qname);\n-    }\n-\n-    public Object nodeTypeTest(int nodeType){\n+    public Object expressionPath(\n+        Object expression,\n+        Object[] predicates,\n+        Object[] steps) \n+    {\n+        return new ExpressionPath(\n+            (Expression) expression,\n+            toExpressionArray(predicates),\n+            toStepArray(steps));\n+    }\n+\n+    public Object nodeNameTest(Object qname) {\n+        return new NodeNameTest((QName) qname);\n+    }\n+\n+    public Object nodeTypeTest(int nodeType) {\n         return new NodeTypeTest(nodeType);\n     }\n \n-    public Object processingInstructionTest(String instruction){\n+    public Object processingInstructionTest(String instruction) {\n         return new ProcessingInstructionTest(instruction);\n     }\n \n-    public Object step(int axis, Object nodeTest, Object[] predicates){\n-        return new Step(axis, (NodeTest)nodeTest, toExpressionArray(predicates));\n-    }\n-\n-    private Expression[] toExpressionArray(Object[] array){\n+    public Object step(int axis, Object nodeTest, Object[] predicates) {\n+        return new Step(\n+            axis,\n+            (NodeTest) nodeTest,\n+            toExpressionArray(predicates));\n+    }\n+\n+    private Expression[] toExpressionArray(Object[] array) {\n         Expression expArray[] = null;\n-        if (array != null){\n+        if (array != null) {\n             expArray = new Expression[array.length];\n-            for (int i = 0; i < expArray.length; i++){\n-                expArray[i] = (Expression)array[i];\n+            for (int i = 0; i < expArray.length; i++) {\n+                expArray[i] = (Expression) array[i];\n             }\n         }\n         return expArray;\n     }\n \n-    private Step[] toStepArray(Object[] array){\n+    private Step[] toStepArray(Object[] array) {\n         Step stepArray[] = null;\n-        if (array != null){\n+        if (array != null) {\n             stepArray = new Step[array.length];\n-            for (int i = 0; i < stepArray.length; i++){\n-                stepArray[i] = (Step)array[i];\n+            for (int i = 0; i < stepArray.length; i++) {\n+                stepArray[i] = (Step) array[i];\n             }\n         }\n         return stepArray;\n     }\n-    \n-    private boolean isNameAttributeTest(Expression arg){\n-        if (arg.getExpressionTypeCode() != Expression.OP_LOCATION_PATH){\n-            return false;\n-        }\n-        \n-        Step[] steps = ((LocationPath)arg).getSteps();\n-        if (steps.length != 1){\n-            return false;\n-        }\n-        if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE){\n+\n+    private boolean isNameAttributeTest(Expression arg) {\n+        if (arg.getExpressionTypeCode() != Expression.OP_LOCATION_PATH) {\n+            return false;\n+        }\n+\n+        Step[] steps = ((LocationPath) arg).getSteps();\n+        if (steps.length != 1) {\n+            return false;\n+        }\n+        if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) {\n             return false;\n         }\n         NodeTest test = steps[0].getNodeTest();\n-        if (!(test instanceof NodeNameTest)){\n-            return false;\n-        }\n-        if (!((NodeNameTest)test).getNodeName().equals(QNAME_NAME)){\n+        if (!(test instanceof NodeNameTest)) {\n+            return false;\n+        }\n+        if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) {\n             return false;\n         }\n         return true;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.4 2002/05/08 00:39:59 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/08 00:39:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.5 2003/01/11 05:41:23 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:23 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An element of the compile tree holding a variable reference.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/05/08 00:39:59 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:23 $\n  */\n public class VariableReference extends Expression {\n \n     private QName varName;\n \n-    public VariableReference(QName varName){\n+    public VariableReference(QName varName) {\n         super(Expression.OP_VAR);\n         this.varName = varName;\n     }\n \n-    public QName getVariableName(){\n+    public QName getVariableName() {\n         return varName;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"(VAR \" + varName + \")\";\n     }\n \n-    public boolean isContextDependent(){\n+    public boolean isContextDependent() {\n         return false;\n     }\n \n-    public boolean computeContextDependent(){\n+    public boolean computeContextDependent() {\n         return false;\n     }\n \n-    public Object compute(EvalContext context){\n+    public Object compute(EvalContext context) {\n         return computeValue(context);\n     }\n \n     /**\n      * Returns the value of the variable.\n      */\n-    public Object computeValue(EvalContext context){\n+    public Object computeValue(EvalContext context) {\n         return context.getRootContext().getVariableContext(varName);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.14 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.15 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * attribute and only simple, context-independent predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.15 $ $Date: 2003/01/11 05:41:24 $\n  */\n public abstract class NodePointer implements Pointer, Cloneable, Comparable {\n \n-    public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n+    public static final int WHOLE_COLLECTION = Integer.MIN_VALUE;\n     protected int index = WHOLE_COLLECTION;\n-    public static String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n+    public static final String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n     private boolean attribute = false;\n \n     /**\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n     public static NodePointer newNodePointer(\n-            QName name, Object bean, Locale locale)\n+        QName name,\n+        Object bean,\n+        Locale locale) \n     {\n         if (bean == null) {\n             return new NullPointer(name, locale);\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n-            NodePointer pointer = factories[i].\n-                    createNodePointer(name, bean, locale);\n+            NodePointer pointer =\n+                factories[i].createNodePointer(name, bean, locale);\n             if (pointer != null) {\n                 return pointer;\n             }\n         }\n         throw new JXPathException(\n-            \"Could not allocate a NodePointer for object of \" +\n-            bean.getClass());\n+            \"Could not allocate a NodePointer for object of \"\n+                + bean.getClass());\n     }\n \n     /**\n      * NodePointerFactories until it finds one that can create a pointer.\n      */\n     public static NodePointer newChildNodePointer(\n-            NodePointer parent, QName name, Object bean)\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n     {\n         NodePointerFactory[] factories =\n             JXPathContextReferenceImpl.getNodePointerFactories();\n         for (int i = 0; i < factories.length; i++) {\n-            NodePointer pointer = factories[i].\n-                    createNodePointer(parent, name, bean);\n+            NodePointer pointer =\n+                factories[i].createNodePointer(parent, name, bean);\n             if (pointer != null) {\n                 return pointer;\n             }\n         }\n         throw new JXPathException(\n-            \"Could not allocate a NodePointer for object of \" +\n-            bean.getClass());\n+            \"Could not allocate a NodePointer for object of \"\n+                + bean.getClass());\n     }\n \n     protected NodePointer parent;\n     /**\n      * Set to true if the pointer represents the \"attribute::\" axis.\n      */\n-    public void setAttribute(boolean attribute){\n+    public void setAttribute(boolean attribute) {\n         this.attribute = attribute;\n     }\n \n     /**\n      * Returns true if the pointer represents the \"attribute::\" axis.\n      */\n-    public boolean isAttribute(){\n+    public boolean isAttribute() {\n         return attribute;\n     }\n \n     /**\n      * @deprecated Please use !isContainer()\n      */\n-    public boolean isNode(){\n+    public boolean isNode() {\n         return !isContainer();\n     }\n      \n      */\n     public Object getValue() {\n         NodePointer valuePointer = getValuePointer();\n-        if (valuePointer != this){\n+        if (valuePointer != this) {\n             return valuePointer.getValue();\n         }\n         // Default behavior is to return the same as getNode() \n      */\n     public NodePointer getValuePointer() {\n         NodePointer ivp = getImmediateValuePointer();\n-        if (ivp != this){\n+        if (ivp != this) {\n             return ivp.getValuePointer();\n         }\n         return this;\n      *\n      * @deprecated 1.1 Please use getNode()\n      */\n-    public Object getNodeValue(){\n+    public Object getNodeValue() {\n         return getNode();\n     }\n \n      * to a \"canonical\" type. Opens containers, properties etc and returns\n      * the ultimate contents.\n      */\n-    public Object getNode(){\n+    public Object getNode() {\n         return getValuePointer().getImmediateNode();\n     }\n     \n             return testLocalName.equals(nodeName.getName());\n         }\n         else if (test instanceof NodeTypeTest) {\n-            if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+            if (((NodeTypeTest) test).getNodeType()\n+                == Compiler.NODE_TYPE_NODE) {\n                 return isNode();\n             }\n         }\n     /**\n      * Remove the node of the object graph this pointer points to.\n      */\n-    public void remove(){\n+    public void remove() {\n         // It is a no-op\n \n //        System.err.println(\"REMOVING: \" + asPath() + \" \" + getClass());\n     /**\n      * Called by a child pointer if that child needs to assign the value\n      * supplied in the createPath(context, value) call to a non-existent\n-     * node. This method must may have to expand the collection in order to\n-     * assign the element.\n-     */\n-    public NodePointer createChild(JXPathContext context, QName name,\n-                            int index, Object value) {\n+     * node. This method may have to expand the collection in order to assign\n+     * the element.\n+     */\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index,\n+        Object value) \n+    {\n         throw new JXPathException(\n             \"Cannot create an object for path \"\n-                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n+                + asPath()\n+                + \"/\"\n+                + name\n+                + \"[\"\n+                + (index + 1)\n+                + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n \n      * describing the newly created element.\n      */\n     public NodePointer createChild(\n-            JXPathContext context, QName name, int index) {\n+        JXPathContext context,\n+        QName name,\n+        int index) \n+    {\n         throw new JXPathException(\n             \"Cannot create an object for path \"\n-                + asPath() + \"/\" + name + \"[\" + (index + 1) + \"]\"\n+                + asPath()\n+                + \"/\"\n+                + name\n+                + \"[\"\n+                + (index + 1)\n+                + \"]\"\n                 + \", operation is not allowed for this type of node\");\n     }\n-\n+    \n     /**\n      * Called to create a non-existing attribute\n      */\n-    public NodePointer createAttribute(JXPathContext context, QName name){\n+    public NodePointer createAttribute(JXPathContext context, QName name) {\n         throw new JXPathException(\n             \"Cannot create an attribute for path \"\n                 + asPath() + \"/@\" + name\n      * that match the given NodeTest, starting with the specified one.\n      */\n     public NodeIterator childIterator(\n-                    NodeTest test, boolean reverse, NodePointer startWith) {\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         NodePointer valuePointer = getValuePointer();\n-        if (valuePointer != null && valuePointer != this){\n+        if (valuePointer != null && valuePointer != this) {\n             return valuePointer.childIterator(test, reverse, startWith);\n         }\n         return null;\n      */\n     public NodeIterator attributeIterator(QName qname) {\n         NodePointer valuePointer = getValuePointer();\n-        if (valuePointer != null && valuePointer != this){\n+        if (valuePointer != null && valuePointer != this) {\n             return valuePointer.attributeIterator(qname);\n         }\n         return null;\n     /**\n      * Locates a node by ID.\n      */\n-    public Pointer getPointerByID(JXPathContext context, String id){\n+    public Pointer getPointerByID(JXPathContext context, String id) {\n         return context.getPointerByID(id);\n     }\n \n     /**\n      * Locates a node by key and value.\n      */\n-    public Pointer getPointerByKey(JXPathContext context,\n-                                      String key, String value){\n+    public Pointer getPointerByKey(\n+        JXPathContext context,\n+        String key,\n+        String value) \n+    {\n         return context.getPointerByKey(key, value);\n     }\n \n \n     public Object clone() {\n         try {\n-            NodePointer ptr = (NodePointer)super.clone();\n-            if (parent != null){\n-                ptr.parent = (NodePointer)parent.clone();\n+            NodePointer ptr = (NodePointer) super.clone();\n+            if (parent != null) {\n+                ptr.parent = (NodePointer) parent.clone();\n             }\n             return ptr;\n         }\n         return asPath();\n     }\n \n-    public int compareTo(Object object){\n+    public int compareTo(Object object) {\n         // Let it throw a ClassCastException\n         NodePointer pointer = (NodePointer) object;\n-        if (parent == pointer.parent){\n-            if (parent == null){\n+        if (parent == pointer.parent) {\n+            if (parent == null) {\n                 return 0;\n             }\n             return parent.compareChildNodePointers(this, pointer);\n         // Task 1: find the common parent\n         int depth1 = 0;\n         NodePointer p1 = this;\n-        while (p1 != null){\n-            depth1 ++;\n+        while (p1 != null) {\n+            depth1++;\n             p1 = p1.parent;\n         }\n         int depth2 = 0;\n         NodePointer p2 = pointer;\n-        while (p2 != null){\n-            depth2 ++;\n+        while (p2 != null) {\n+            depth2++;\n             p2 = p2.parent;\n         }\n         return compareNodePointers(this, depth1, pointer, depth2);\n     }\n \n     private int compareNodePointers(\n-            NodePointer p1, int depth1, NodePointer p2, int depth2)\n+        NodePointer p1,\n+        int depth1,\n+        NodePointer p2,\n+        int depth2) \n     {\n-        if (depth1 < depth2){\n-            int r = compareNodePointers(p1, depth1, p2.parent, depth2-1);\n-            if (r != 0){\n+        if (depth1 < depth2) {\n+            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n+            if (r != 0) {\n                 return r;\n             }\n             return -1;\n         }\n-        else if (depth1 > depth2){\n-            int r = compareNodePointers(p1.parent, depth1-1, p2, depth2);\n-            if (r != 0){\n+        else if (depth1 > depth2) {\n+            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n+            if (r != 0) {\n                 return r;\n             }\n             return 1;\n         }\n-        if (p1 == null && p2 == null){\n+        if (p1 == null && p2 == null) {\n             return 0;\n         }\n \n-        if (p1 != null && p1.equals(p2)){\n+        if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n-        if (depth1 == 1){\n+        if (depth1 == 1) {\n             throw new JXPathException(\n                 \"Cannot compare pointers that do not belong to the same tree: '\"\n-                + p1 + \"' and '\" + p2 + \"'\");\n-        }\n-        int r = compareNodePointers(\n-                p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n-        if (r != 0){\n+                    + p1\n+                    + \"' and '\"\n+                    + p2\n+                    + \"'\");\n+        }\n+        int r =\n+            compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n+        if (r != 0) {\n             return r;\n         }\n \n     /**\n      * Print internal structure of a pointer for debugging\n      */\n-    public void printPointerChain(){\n+    public void printPointerChain() {\n         printDeep(this, \"\");\n     }\n \n-    private static void printDeep(NodePointer pointer, String indent){\n-        if (indent.length() == 0){\n-            System.err.println(\"POINTER: \" + pointer + \"(\" +\n-                    pointer.getClass().getName() + \")\");\n+    private static void printDeep(NodePointer pointer, String indent) {\n+        if (indent.length() == 0) {\n+            System.err.println(\n+                \"POINTER: \"\n+                    + pointer\n+                    + \"(\"\n+                    + pointer.getClass().getName()\n+                    + \")\");\n         }\n         else {\n-            System.err.println(indent + \" of \" + pointer + \"(\" +\n-                    pointer.getClass().getName() + \")\");\n-        }\n-        if (pointer.getParent() != null){\n+            System.err.println(\n+                indent\n+                    + \" of \"\n+                    + pointer\n+                    + \"(\"\n+                    + pointer.getClass().getName()\n+                    + \")\");\n+        }\n+        if (pointer.getParent() != null) {\n             printDeep(pointer.getParent(), indent + \"  \");\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java,v 1.2 2002/04/24 04:05:39 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java,v 1.3 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * by the \"getOrder\" method and always queried in that order.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:24 $\n  */\n public interface NodePointerFactory {\n \n     /**\n      * The factory name determines its position between other factories.\n      */\n-    public int getOrder();\n+    int getOrder();\n \n     /**\n      * Create a NodePointer for the supplied object.  The node will represent\n      * the \"root\" object a path.\n      *\n-     * Return null if this factory does not recognize objects of the supplied type.\n+     * @return  null if this factory does not recognize objects of the supplied\n+     * type.\n      */\n-    public NodePointer createNodePointer(QName name, Object object, Locale locale);\n+    NodePointer createNodePointer(QName name, Object object, Locale locale);\n \n     /**\n      * Create a NodePointer for the supplied child object.\n      * <p>\n-     * Return null if this factory does not recognize objects of the supplied type.\n+     * @return null if this factory does not recognize objects of the supplied\n+     * type.\n      */\n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object object);\n+    NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object object);\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.9 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.10 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Pointer to a context variable.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.10 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class VariablePointer extends NodePointer {\n     private Variables variables;\n     private NodePointer valuePointer;\n     private boolean actual;\n \n-    public VariablePointer(Variables variables, QName name){\n+    public VariablePointer(Variables variables, QName name) {\n         super(null);\n         this.variables = variables;\n         this.name = name;\n         actual = true;\n     }\n \n-    public VariablePointer(QName name){\n+    public VariablePointer(QName name) {\n         super(null);\n         this.name = name;\n         actual = false;\n     }\n \n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return name;\n     }\n \n-    public Object getBaseValue(){\n-        if (!actual){\n+    public Object getBaseValue() {\n+        if (!actual) {\n             throw new JXPathException(\"Undefined variable: \" + name);\n         }\n         return variables.getVariable(name.getName());\n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         Object value = getBaseValue();\n-        if (index != WHOLE_COLLECTION){\n+        if (index != WHOLE_COLLECTION) {\n             return ValueUtils.getValue(value, index);\n         }\n         return value;\n     }\n \n-    public void setValue(Object value){\n-        if (!actual){\n+    public void setValue(Object value) {\n+        if (!actual) {\n             throw new JXPathException(\"Cannot set undefined variable: \" + name);\n         }\n         valuePointer = null;\n-        if (index != WHOLE_COLLECTION){\n+        if (index != WHOLE_COLLECTION) {\n             Object collection = getBaseValue();\n             ValueUtils.setValue(collection, index, value);\n         }\n         }\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return actual;\n     }\n \n-    public NodePointer getImmediateValuePointer(){\n-        if (valuePointer == null){\n+    public NodePointer getImmediateValuePointer() {\n+        if (valuePointer == null) {\n             Object value = null;\n-            if (actual){\n+            if (actual) {\n                 value = getImmediateNode();\n             }\n             valuePointer = NodePointer.newChildNodePointer(this, null, value);\n         return valuePointer;\n     }\n \n-    public int getLength(){\n-        if (actual){\n+    public int getLength() {\n+        if (actual) {\n             Object value = getBaseValue();\n             if (value == null) {\n                 return 1;\n         return 0;\n     }\n \n-    public NodePointer createPath(JXPathContext context, Object value){\n-        if (actual){\n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        if (actual) {\n             setValue(value);\n             return this;\n         }\n         return ptr;\n     }\n \n-    public NodePointer createPath(JXPathContext context){\n-        if (!actual){\n+    public NodePointer createPath(JXPathContext context) {\n+        if (!actual) {\n             AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory.declareVariable(context, name.toString())){\n-                throw new JXPathException(\"Factory cannot define variable '\" + name + \"' for path: \" + asPath());\n+            if (!factory.declareVariable(context, name.toString())) {\n+                throw new JXPathException(\n+                    \"Factory cannot define variable '\"\n+                        + name\n+                        + \"' for path: \"\n+                        + asPath());\n             }\n             findVariables(context);\n             // Assert: actual == true\n         return this;\n     }\n \n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index) \n+    {\n         Object collection = createCollection(context, index);\n-        if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)){\n+        if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)) {\n             AbstractFactory factory = getAbstractFactory(context);\n-            // Ignore the name passed as a parameter, pass the name of the variable instead\n-            if (!factory.createObject(context, this, collection, getName().toString(), index)){\n-                throw new JXPathException(\"Factory could not create object path: \" + asPath());\n+            boolean success =\n+                factory.createObject(\n+                    context,\n+                    this,\n+                    collection,\n+                    getName().toString(),\n+                    index);\n+            if (!success) {\n+                throw new JXPathException(\n+                    \"Factory could not create object path: \" + asPath());\n             }\n             setIndex(index);\n         }\n         return this;\n     }\n \n-    /**\n-     */\n-    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n+    public NodePointer createChild(\n+            JXPathContext context,\n+            QName name, \n+            int index,\n+            Object value) \n+    {\n         Object collection = createCollection(context, index);\n         ValueUtils.setValue(collection, index, value);\n-        NodePointer cl = (NodePointer)clone();\n+        NodePointer cl = (NodePointer) clone();\n         cl.setIndex(index);\n         return cl;\n     }\n \n-    private Object createCollection(JXPathContext context, int index){\n+    private Object createCollection(JXPathContext context, int index) {\n         createPath(context);\n \n         Object collection = getBaseValue();\n-        if (collection == null){\n-            throw new JXPathException(\"Factory did not assign a collection to variable '\" + name + \"' for path: \" + asPath());\n-        }\n-\n-        if (index == WHOLE_COLLECTION){\n+        if (collection == null) {\n+            throw new JXPathException(\n+                \"Factory did not assign a collection to variable '\"\n+                    + name\n+                    + \"' for path: \"\n+                    + asPath());\n+        }\n+\n+        if (index == WHOLE_COLLECTION) {\n             index = 0;\n         }\n-        else if (index < 0){\n+        else if (index < 0) {\n             throw new JXPathException(\"Index is less than 1: \" + asPath());\n         }\n \n-        if (index >= getLength()){\n+        if (index >= getLength()) {\n             collection = ValueUtils.expandCollection(collection, index + 1);\n             variables.declareVariable(name.toString(), collection);\n         }\n         return collection;\n     }\n \n-    public void remove(){\n-        if (actual){\n-            if (index == WHOLE_COLLECTION){\n+    public void remove() {\n+        if (actual) {\n+            if (index == WHOLE_COLLECTION) {\n                 variables.undeclareVariable(name.toString());\n             }\n             else {\n-                if (index < 0){\n-                    throw new JXPathException(\"Index is less than 1: \" + asPath());\n+                if (index < 0) {\n+                    throw new JXPathException(\n+                        \"Index is less than 1: \" + asPath());\n                 }\n \n                 Object collection = getBaseValue();\n-                if (collection != null && index < getLength()){\n+                if (collection != null && index < getLength()) {\n                     collection = ValueUtils.remove(collection, index);\n                     variables.declareVariable(name.toString(), collection);\n                 }\n         }\n     }\n \n-    protected void findVariables(JXPathContext context){\n+    protected void findVariables(JXPathContext context) {\n         valuePointer = null;\n         JXPathContext varCtx = context;\n-        while (varCtx != null){\n+        while (varCtx != null) {\n             variables = varCtx.getVariables();\n-            if (variables.isDeclaredVariable(name.toString())){\n+            if (variables.isDeclaredVariable(name.toString())) {\n                 actual = true;\n                 break;\n             }\n         }\n     }\n \n-    public int hashCode(){\n-        return (actual ? System.identityHashCode(variables): 0) + name.hashCode() + index;\n-    }\n-\n-    public boolean equals(Object object){\n-        if (object == this){\n+    public int hashCode() {\n+        return (actual ? System.identityHashCode(variables) : 0)\n+            + name.hashCode()\n+            + index;\n+    }\n+\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof VariablePointer)){\n+        if (!(object instanceof VariablePointer)) {\n             return false;\n         }\n \n-        VariablePointer other = (VariablePointer)object;\n-        return variables == other.variables &&\n-                name.equals(other.name) &&\n-                index == other.index;\n-    }\n-\n-    public String asPath(){\n+        VariablePointer other = (VariablePointer) object;\n+        return variables == other.variables\n+            && name.equals(other.name)\n+            && index == other.index;\n+    }\n+\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append('$');\n         buffer.append(name);\n-        if (!actual){\n-            if (index != WHOLE_COLLECTION){\n+        if (!actual) {\n+            if (index != WHOLE_COLLECTION) {\n                 buffer.append('[').append(index + 1).append(']');\n             }\n         }\n-        else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())){\n+        else if (\n+            index != WHOLE_COLLECTION\n+                && (getNode() == null || isCollection())) {\n             buffer.append('[').append(index + 1).append(']');\n         }\n         return buffer.toString();\n     }\n \n-    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n-    public NodeIterator namespaceIterator(){\n+    public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n-    public NodePointer namespacePointer(String name){\n+    public NodePointer namespacePointer(String name) {\n         return getValuePointer().namespacePointer(name);\n     }\n \n-    public boolean testNode(NodeTest nodeTest){\n+    public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n+    private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n+        if (factory == null) {\n             throw new JXPathException(\n               \"Factory is not set on the JXPathContext - cannot create path: \"\n               + asPath());\n         return factory;\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.4 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.5 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * well as the \"xml:lang\" attribute.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class BeanAttributeIterator extends PropertyIterator {\n     private NodePointer parent;\n     private int position = 0;\n     private boolean includeXmlLang;\n \n-    public BeanAttributeIterator(PropertyOwnerPointer parent, QName name){\n-        super(parent,\n-                (name.getPrefix() == null &&\n-                 (name.getName() == null || name.getName().equals(\"*\"))) ?\n-                        null : name.toString(), false, null);\n+    public BeanAttributeIterator(PropertyOwnerPointer parent, QName name) {\n+        super(\n+            parent,\n+            (name.getPrefix() == null\n+                && (name.getName() == null || name.getName().equals(\"*\")))\n+                ? null\n+                : name.toString(),\n+            false,\n+            null);\n         this.parent = parent;\n         includeXmlLang =\n-            (name.getPrefix() != null && name.getPrefix().equals(\"xml\")) &&\n-            (name.getName().equals(\"lang\") || name.getName().equals(\"*\"));\n+            (name.getPrefix() != null && name.getPrefix().equals(\"xml\"))\n+                && (name.getName().equals(\"lang\") \n+                || name.getName().equals(\"*\"));\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (includeXmlLang && position == 1){\n+    public NodePointer getNodePointer() {\n+        if (includeXmlLang && position == 1) {\n             return new LangAttributePointer(parent);\n         }\n         else {\n         }\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n-        if (includeXmlLang){\n-            if (position == 1){\n+        if (includeXmlLang) {\n+            if (position == 1) {\n                 return true;\n             }\n             else {\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.9 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.10 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * in the chain.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.10 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class BeanPointer extends PropertyOwnerPointer {\n     private QName name;\n         this.beanInfo = beanInfo;\n     }\n \n-    public PropertyPointer getPropertyPointer(){\n+    public PropertyPointer getPropertyPointer() {\n         return new BeanPropertyPointer(this, beanInfo);\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return name;\n     }\n \n     /**\n      * Returns the bean itself\n      */\n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return bean;\n     }\n \n     /**\n      * Returns false\n      */\n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n     /**\n      * Returns 1.\n      */\n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }\n \n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n             return false;\n         }\n \n-        int i_this = (index == WHOLE_COLLECTION ? 0 : index);\n-        int i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-        if (i_this != i_other) {\n+        int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n+        int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n+        if (iThis != iOther) {\n             return false;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java,v 1.3 2002/07/03 21:12:36 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/07/03 21:12:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java,v 1.4 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for JavaBeans.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/07/03 21:12:36 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class BeanPointerFactory implements NodePointerFactory {\n \n     public static final int BEAN_POINTER_FACTORY_ORDER = 900;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return BEAN_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+    public NodePointer createNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale)\n+    {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n         return new BeanPointer(name, bean, bi, locale);\n     }\n \n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n-        if (bean == null){\n+    public NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n+    {\n+        if (bean == null) {\n             return new NullPointer(parent, name);\n         }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.11 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.12 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.beans.PropertyDescriptor;\n \n-import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.JXPathBeanInfo;\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n \n  * Pointer pointing to a property of a JavaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class BeanPropertyPointer extends PropertyPointer {\n     private String propertyName;\n     private Object baseValue = UNINITIALIZED;\n     private Object value = UNINITIALIZED;\n \n-    public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo){\n+    public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo) {\n         super(parent);\n         this.beanInfo = beanInfo;\n     }\n     /**\n      * This type of node is auxiliary.\n      */\n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n     /**\n      * Number of the bean's properties.\n      */\n-    public int getPropertyCount(){\n+    public int getPropertyCount() {\n         return getPropertyDescriptors().length;\n     }\n \n     /**\n      * Names of all properties, sorted alphabetically\n      */\n-    public String[] getPropertyNames(){\n-        if (names == null){\n+    public String[] getPropertyNames() {\n+        if (names == null) {\n             PropertyDescriptor pds[] = getPropertyDescriptors();\n             names = new String[pds.length];\n-            for (int i = 0; i < names.length; i++){\n+            for (int i = 0; i < names.length; i++) {\n                 names[i] = pds[i].getName();\n             }\n         }\n     /**\n      * Select a property by name\n      */\n-    public void setPropertyName(String propertyName){\n+    public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n         this.propertyName = propertyName;\n     }\n     /**\n      * Selects a property by its offset in the alphabetically sorted list.\n      */\n-    public void setPropertyIndex(int index){\n-        if (propertyIndex != index){\n+    public void setPropertyIndex(int index) {\n+        if (propertyIndex != index) {\n             super.setPropertyIndex(index);\n             propertyName = null;\n             propertyDescriptor = null;\n     /**\n      * The value of the currently selected property.\n      */\n-    public Object getBaseValue(){\n-        if (baseValue == UNINITIALIZED){\n+    public Object getBaseValue() {\n+        if (baseValue == UNINITIALIZED) {\n             PropertyDescriptor pd = getPropertyDescriptor();\n-            if (pd == null){\n+            if (pd == null) {\n                 return null;\n             }\n             baseValue = ValueUtils.getValue(getBean(), pd);\n         return baseValue;\n     }\n \n-    public void setIndex(int index){\n-        if (this.index != index){\n+    public void setIndex(int index) {\n+        if (this.index != index) {\n             // When dealing with a scalar, index == 0 is equivalent to\n             // WHOLE_COLLECTION, so do not change it.\n-            if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()){\n+            if (this.index != WHOLE_COLLECTION\n+                || index != 0\n+                || isCollection()) {\n                 super.setIndex(index);\n                 value = UNINITIALIZED;\n             }\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getImmediateNode(){\n-        if (value == UNINITIALIZED){\n+    public Object getImmediateNode() {\n+        if (value == UNINITIALIZED) {\n             Object baseValue = getBaseValue();\n-            if (index == WHOLE_COLLECTION){\n+            if (index == WHOLE_COLLECTION) {\n                 value = baseValue;\n             }\n-            else if (value != null && index >= 0 && index < getLength()){\n+            else if (value != null && index >= 0 && index < getLength()) {\n                 value = ValueUtils.getValue(baseValue, index);\n             }\n             else {\n         return value;\n     }\n \n-    protected boolean isActualProperty(){\n+    protected boolean isActualProperty() {\n         return getPropertyDescriptor() != null;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         PropertyDescriptor pd = getPropertyDescriptor();\n-        if (pd == null){\n+        if (pd == null) {\n             return false;\n         }\n         \n         int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n-        if (hint == -1){\n+        if (hint == -1) {\n             return false;\n         }\n-        if (hint == 1){\n+        if (hint == 1) {\n             return true;\n         }\n         \n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      */\n-    public int getLength(){\n+    public int getLength() {\n         PropertyDescriptor pd = getPropertyDescriptor();\n-        if (pd == null){\n+        if (pd == null) {\n             return 1;\n         }\n         \n         int hint = ValueUtils.getCollectionHint(pd.getPropertyType());\n-        if (hint == -1){\n+        if (hint == -1) {\n             return 1;\n         }\n         return ValueUtils.getLength(getBaseValue());\n      * change the value of the index'th element of the collection\n      * represented by the property.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         PropertyDescriptor pd = getPropertyDescriptor();\n-        if (pd == null){\n-            throw new JXPathException(\"Cannot set property: \" + asPath() +\n-                    \" - no such property\");\n-        }\n-\n-        if (index == WHOLE_COLLECTION){\n+        if (pd == null) {\n+            throw new JXPathException(\n+                \"Cannot set property: \" + asPath() + \" - no such property\");\n+        }\n+\n+        if (index == WHOLE_COLLECTION) {\n             ValueUtils.setValue(getBean(), pd, value);\n         }\n         else {\n         this.value = value;\n     }\n \n-    public NodePointer createPath(JXPathContext context){\n-        if (getNode() == null){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory.createObject(context, this, getBean(),\n-                    getPropertyName(), inx)){\n-                throw new JXPathException(\n-                    \"Factory could not create an object for path: \" + asPath());\n-            }\n+    /**\n+     * @see PropertyPointer#createPath(JXPathContext)\n+     */\n+    public NodePointer createPath(JXPathContext context) {\n+        if (getImmediateNode() == null) {\n+            super.createPath(context);\n             baseValue = UNINITIALIZED;\n             value = UNINITIALIZED;\n         }\n         return this;\n     }\n \n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index){\n-        return createPath(context).getValuePointer().\n-                createChild(context, name, index);\n-    }\n-\n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index, Object value){\n-        return createPath(context).getValuePointer().\n-                createChild(context, name, index, value);\n-    }\n-\n-    private BeanPropertyPointer setIndexExpandingCollection(\n-            JXPathContext context, QName name, int index){\n-        // Ignore the name passed to us, use our own information\n-        PropertyDescriptor pd = getPropertyDescriptor();\n-        if (pd == null){\n-            throw new JXPathException(\"Cannot create path: \" + asPath() +\n-                    \" - property '\" + getPropertyName() + \"' does not exist\");\n-        }\n-\n-        if (index < 0){\n-            throw new JXPathException(\"Index is less than 1: \" + asPath());\n-        }\n-\n-        if (index >= getLength()){\n-            AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory.createObject(context, this, getBean(),\n-                    getPropertyName(), index)){\n-                throw new JXPathException(\"Factory could not create path \" +\n-                        asPath());\n-            }\n-        }\n-        BeanPropertyPointer clone = (BeanPropertyPointer)this.clone();\n-        clone.baseValue = UNINITIALIZED;\n-        clone.value = UNINITIALIZED;\n-        clone.setIndex(index);\n-        return clone;\n-    }\n-\n-    public void remove(){\n-        if (index == WHOLE_COLLECTION){\n+    public void remove() {\n+        if (index == WHOLE_COLLECTION) {\n             setValue(null);\n         }\n-        else if (isCollection()){\n+        else if (isCollection()) {\n             Object collection = ValueUtils.remove(getBaseValue(), index);\n             ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection);\n         }\n-        else if (index == 0){\n+        else if (index == 0) {\n             index = WHOLE_COLLECTION;\n             setValue(null);\n         }\n     /**\n      * Name of the currently selected property.\n      */\n-    public String getPropertyName(){\n-        if (propertyName == null){\n+    public String getPropertyName() {\n+        if (propertyName == null) {\n             PropertyDescriptor pd = getPropertyDescriptor();\n-            if (pd != null){\n+            if (pd != null) {\n                 propertyName = pd.getName();\n             }\n         }\n      * Finds the property descriptor corresponding to the current property\n      * index.\n      */\n-    private PropertyDescriptor getPropertyDescriptor(){\n-        if (propertyDescriptor == null){\n+    private PropertyDescriptor getPropertyDescriptor() {\n+        if (propertyDescriptor == null) {\n             int inx = getPropertyIndex();\n-            if (inx == UNSPECIFIED_PROPERTY){\n-                propertyDescriptor = beanInfo.\n-                        getPropertyDescriptor(propertyName);\n+            if (inx == UNSPECIFIED_PROPERTY) {\n+                propertyDescriptor =\n+                    beanInfo.getPropertyDescriptor(propertyName);\n             }\n             else {\n                 PropertyDescriptor propertyDescriptors[] =\n-                        getPropertyDescriptors();\n-                if (inx >=0 && inx < propertyDescriptors.length){\n+                    getPropertyDescriptors();\n+                if (inx >= 0 && inx < propertyDescriptors.length) {\n                     propertyDescriptor = propertyDescriptors[inx];\n                 }\n                 else {\n         return propertyDescriptor;\n     }\n \n-    protected PropertyDescriptor[] getPropertyDescriptors(){\n-        if (propertyDescriptors == null){\n+    protected PropertyDescriptor[] getPropertyDescriptors() {\n+        if (propertyDescriptors == null) {\n             propertyDescriptors = beanInfo.getPropertyDescriptors();\n         }\n         return propertyDescriptors;\n     }\n-\n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n-        AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n-            throw new JXPathException(\"Factory is not set on the \" +\n-                \"JXPathContext - cannot create path: \" + asPath());\n-        }\n-        return factory;\n-    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.11 2003/01/10 02:11:28 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2003/01/10 02:11:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.12 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Transparent pointer to a collection (array or Collection).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2003/01/10 02:11:28 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class CollectionPointer extends NodePointer {\n     private Object collection;\n     private NodePointer valuePointer;\n \n-    public CollectionPointer(Object collection, Locale locale){\n+    public CollectionPointer(Object collection, Locale locale) {\n         super(null, locale);\n         this.collection = collection;\n     }\n \n-    public CollectionPointer(NodePointer parent, Object collection){\n+    public CollectionPointer(NodePointer parent, Object collection) {\n         super(parent);\n         this.collection = collection;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return null;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return collection;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return true;\n     }\n \n-    public int getLength(){\n+    public int getLength() {\n         return ValueUtils.getLength(getBaseValue());\n     }\n \n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }\n \n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return index != WHOLE_COLLECTION;\n     }\n \n-    public Object getImmediateNode(){\n-        if (index != WHOLE_COLLECTION){\n+    public Object getImmediateNode() {\n+        if (index != WHOLE_COLLECTION) {\n             return ValueUtils.getValue(collection, index);\n         }\n         return collection;\n     }\n \n-    public void setValue(Object value){\n-        if (index == WHOLE_COLLECTION){\n+    public void setValue(Object value) {\n+        if (index == WHOLE_COLLECTION) {\n             parent.setValue(value);\n         }\n         else {\n         }\n     }\n \n-    public void setIndex(int index){\n+    public void setIndex(int index) {\n         super.setIndex(index);\n         valuePointer = null;\n     }\n \n-    public NodePointer getValuePointer(){\n-        if (valuePointer == null){\n-            if (index == WHOLE_COLLECTION){\n+    public NodePointer getValuePointer() {\n+        if (valuePointer == null) {\n+            if (index == WHOLE_COLLECTION) {\n                 valuePointer = this;\n             }\n             else {\n         return valuePointer;\n     }\n \n-    public NodePointer createChild(JXPathContext context, \n-                QName name, int index, Object value)\n-    {\n-        if (parent instanceof PropertyPointer){\n-            return parent.createChild(context, name, index, value);\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getNode(), index + 1);\n-            }\n-            ValueUtils.setValue(collection, index, value);\n-            NodePointer ptr = (NodePointer)clone();\n-            ptr.setIndex(index);\n-            return ptr;\n-        }\n-    }\n-\n-    public NodePointer createPath(JXPathContext context){\n-        if (parent instanceof PropertyPointer){\n-            return parent.createPath(context);\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getNode(), index + 1);\n-            }\n-            return this;\n-        }\n-    }\n-\n-    public NodePointer createChild(JXPathContext context, \n-                QName name, int index)\n-    {\n-        if (parent instanceof PropertyPointer){\n-            return parent.createChild(context, name, index);\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (ValueUtils.getLength(collection) <= index){\n-                ValueUtils.expandCollection(getNode(), index + 1);\n-            }\n-            return this;\n-        }\n-    }\n-\n-    public int hashCode(){\n+    public NodePointer createPath(JXPathContext context) {\n+        Object collection = getBaseValue();\n+        if (ValueUtils.getLength(collection) <= index) {\n+            collection = ValueUtils.expandCollection(getNode(), index + 1);\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        NodePointer ptr = createPath(context);\n+        ptr.setValue(value);\n+        return ptr;\n+    }\n+\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index,\n+        Object value) \n+    {\n+        NodePointer ptr = (NodePointer) clone();\n+        ptr.setIndex(index);\n+        return ptr.createPath(context, value);\n+    }\n+\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index) \n+    {\n+        NodePointer ptr = (NodePointer) clone();\n+        ptr.setIndex(index);\n+        return ptr.createPath(context);\n+    }\n+\n+    public int hashCode() {\n         return System.identityHashCode(collection) + index;\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof CollectionPointer)){\n+        if (!(object instanceof CollectionPointer)) {\n             return false;\n         }\n \n-        CollectionPointer other = (CollectionPointer)object;\n-        return collection == other.collection &&\n-                index == other.index;\n+        CollectionPointer other = (CollectionPointer) object;\n+        return collection == other.collection && index == other.index;\n     }\n \n     public NodeIterator childIterator(NodeTest test, \n                 boolean reverse, NodePointer startWith)\n     {\n-        if (index == WHOLE_COLLECTION){\n+        if (index == WHOLE_COLLECTION) {\n             return null;\n         }\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n-        if (index == WHOLE_COLLECTION){\n+    public NodeIterator attributeIterator(QName name) {\n+        if (index == WHOLE_COLLECTION) {\n             return null;\n         }\n         return getValuePointer().attributeIterator(name);\n     }\n \n-    public NodeIterator namespaceIterator(){\n-        if (index == WHOLE_COLLECTION){\n+    public NodeIterator namespaceIterator() {\n+        if (index == WHOLE_COLLECTION) {\n             return null;\n         }\n         return getValuePointer().namespaceIterator();\n     }\n \n-    public NodePointer namespacePointer(String namespace){\n-        if (index == WHOLE_COLLECTION){\n+    public NodePointer namespacePointer(String namespace) {\n+        if (index == WHOLE_COLLECTION) {\n             return null;\n         }\n         return getValuePointer().namespacePointer(namespace);\n     }\n \n-    public boolean testNode(NodeTest nodeTest){\n+    public boolean testNode(NodeTest nodeTest) {\n //        if (index\n         /** @todo: infinite loop here */\n         return getValuePointer().testNode(nodeTest);\n         }\n         if (index != WHOLE_COLLECTION) {\n             // Address the list[1][2] case\n-            if (parent != null && parent.getIndex() != WHOLE_COLLECTION){\n+            if (parent != null && parent.getIndex() != WHOLE_COLLECTION) {\n                 buffer.append(\"/.\");\n             }\n             buffer.append(\"[\").append(index + 1).append(']');\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java,v 1.3 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for stand-alone collections.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class CollectionPointerFactory implements NodePointerFactory {\n \n     public static final int COLLECTION_POINTER_FACTORY_ORDER = 10;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return COLLECTION_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n-        if (ValueUtils.isCollection(bean)){\n+    public NodePointer createNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale) \n+    {\n+        if (ValueUtils.isCollection(bean)) {\n             return new CollectionPointer(bean, locale);\n         }\n         return null;\n     }\n \n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n-        if (ValueUtils.isCollection(bean)){\n+    public NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n+    {\n+        if (ValueUtils.isCollection(bean)) {\n             return new CollectionPointer(parent, bean);\n         }\n         return null;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.7 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.8 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * of the attribute is based on the locale supplied to it in the constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class LangAttributePointer extends NodePointer {\n-    public LangAttributePointer(NodePointer parent){\n+    public LangAttributePointer(NodePointer parent) {\n         super(parent);\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return new QName(null, \"lang\");\n     }\n \n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return getName();\n     }\n \n-    public String getNamespaceURI(){\n+    public String getNamespaceURI() {\n         return null;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return parent.getLocale().toString().replace('_', '-');\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return getBaseValue();\n     }\n \n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n      */\n-    public void setValue(Object value){\n-        throw new UnsupportedOperationException(\"Cannot change locale using the 'lang' attribute\");\n+    public void setValue(Object value) {\n+        throw new UnsupportedOperationException(\n+                \"Cannot change locale using the 'lang' attribute\");\n     }\n \n     /**\n      */\n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n-            if (buffer.length() == 0 ||\n-                    buffer.charAt(buffer.length()-1) != '/'){\n+            if (buffer.length() == 0\n+                || buffer.charAt(buffer.length() - 1) != '/') {\n                 buffer.append('/');\n             }\n         }\n         return buffer.toString();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return 0;\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof LangAttributePointer)){\n+        if (!(object instanceof LangAttributePointer)) {\n             return false;\n         }\n \n         return true;\n     }\n \n-    public boolean testNode(NodeTest test){\n+    public boolean testNode(NodeTest test) {\n         return false;\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         // Won't happen - lang attributes don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.12 2003/01/10 02:11:28 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2003/01/10 02:11:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.13 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model.beans;\n \n import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n \n /**\n- * Used when there is a need to construct a Pointer for\n- * a collection element that does not exist.  For example,\n- * if the path is \"foo[3]\", but the collection \"foo\" only has\n- * one element or is empty or is null, the NullElementPointer\n- * can be used to capture this situatuin without putting\n- * a regular NodePointer into an invalid state.  Just create\n- * a NullElementPointer with index 2 (= 3 - 1) and a \"foo\" pointer\n- * as the parent.\n+ * Used when there is a need to construct a Pointer for a collection element\n+ * that does not exist.  For example, if the path is \"foo[3]\", but the\n+ * collection \"foo\" only has one element or is empty or is null, the\n+ * NullElementPointer can be used to capture this situation without putting a\n+ * regular NodePointer into an invalid state.  Just create a NullElementPointer\n+ * with index 2 (= 3 - 1) and a \"foo\" pointer as the parent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2003/01/10 02:11:28 $\n+ * @version $Revision: 1.13 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class NullElementPointer extends CollectionPointer {\n \n-    public NullElementPointer(NodePointer parent, int index){\n-        super(parent, (Object)null);\n+    public NullElementPointer(NodePointer parent, int index) {\n+        super(parent, (Object) null);\n         this.index = index;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return null;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return null;\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return null;\n     }\n     \n         return true;\n     }    \n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n-    public PropertyPointer getPropertyPointer(){\n+    public PropertyPointer getPropertyPointer() {\n         return new NullPropertyPointer(this);\n     }\n \n-    public NodePointer getValuePointer(){\n+    public NodePointer getValuePointer() {\n         return new NullPointer(this, getName());\n     }\n \n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         throw new UnsupportedOperationException(\n             \"Collection element does not exist: \" + this);\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return false;\n     }\n \n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n-    public NodePointer createPath(JXPathContext context, Object value){\n-        if (parent instanceof PropertyPointer) {\n-            return parent.getParent().createChild(\n-                context,\n-                parent.getName(),\n-                index,\n-                value);\n-        }\n-        else {\n-            return parent.createChild(context, null, index, value);\n-        }\n+    public NodePointer createPath(JXPathContext context) {\n+        return parent.createChild(context, null, index);\n+    }\n+    \n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        return parent.createChild(context, null, index, value);\n     }\n \n-    public NodePointer createPath(JXPathContext context){\n-        if (parent instanceof PropertyPointer) {\n-            return parent.getParent().createChild(\n-                context,\n-                parent.getName(),\n-                index);\n-        }\n-        else {\n-            return parent.createChild(context, null, index);\n-        }\n-    }\n-\n-    public NodePointer createChild(\n-        JXPathContext context,\n-        QName name,\n-        int index,\n-        Object value) \n-    {\n-        if (index != 0 && index != WHOLE_COLLECTION) {\n-            throw new JXPathException(\n-                \"Internal error. Indexed passed to \"\n-                    + \"NullElementPointer.createChild() is not 0: \"\n-                    + index);\n-        }\n-        if (parent instanceof PropertyPointer) {\n-            return parent.getParent().createChild(\n-                context,\n-                parent.getName(),\n-                getIndex(),\n-                value);\n-        }\n-        else {\n-            return parent.createChild(context, name, getIndex(), value);\n-        }\n-    }\n-\n-    public NodePointer createChild(\n-        JXPathContext context,\n-        QName name,\n-        int index) \n-    {\n-        if (index != 0 && index != WHOLE_COLLECTION) {\n-            throw new JXPathException(\n-                \"Internal error. Indexed passed to \"\n-                    + \"NullElementPointer.createChild() is not 0: \"\n-                    + index);\n-        }\n-        if (parent instanceof PropertyPointer) {\n-            return parent.getParent().createChild(\n-                context,\n-                parent.getName(),\n-                getIndex());\n-        }\n-        else {\n-            return parent.createChild(context, name, getIndex());\n-        }\n-    }\n-\n-    public int hashCode(){\n+    public int hashCode() {\n         return getParent().hashCode() + index;\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof NullElementPointer)){\n+        if (!(object instanceof NullElementPointer)) {\n             return false;\n         }\n \n-        NullElementPointer other = (NullElementPointer)object;\n-        return getParent() == other.getParent() &&\n-            index == other.index;\n+        NullElementPointer other = (NullElementPointer) object;\n+        return getParent() == other.getParent() && index == other.index;\n     }\n \n-    public int getLength(){\n+    public int getLength() {\n         return 0;\n     }\n     \n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java,v 1.7 2002/10/20 03:47:17 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/20 03:47:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java,v 1.8 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/10/20 03:47:17 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class NullPointer extends PropertyOwnerPointer {\n     private QName name;\n     private String id;\n \n-    public NullPointer(QName name, Locale locale){\n+    public NullPointer(QName name, Locale locale) {\n         super(null, locale);\n         this.name = name;\n     }\n     /**\n      * Used for the root node\n      */\n-    public NullPointer(NodePointer parent, QName name){\n+    public NullPointer(NodePointer parent, QName name) {\n         super(parent);\n         this.name = name;\n     }\n \n-    public NullPointer(Locale locale, String id){\n+    public NullPointer(Locale locale, String id) {\n         super(null, locale);\n         this.id = id;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return name;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return null;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n         return true;\n     }        \n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return false;\n     }\n \n-    public PropertyPointer getPropertyPointer(){\n+    public PropertyPointer getPropertyPointer() {\n         return new NullPropertyPointer(this);\n     }\n \n-    public NodePointer createPath(JXPathContext context, Object value){\n-        if (parent != null){\n-            if (parent instanceof PropertyPointer){\n-                return parent.createPath(context, value);\n-            }\n-            else {\n-                return parent.createChild(context, getName(), 0, value);\n-            }\n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        if (parent != null) {\n+            return parent.createPath(context, value).getValuePointer();\n         }\n         else {\n-            throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+            throw new UnsupportedOperationException(\n+                \"Cannot create the root object: \" + asPath());\n         }\n     }\n \n-    public NodePointer createPath(JXPathContext context){\n-        if (parent != null){\n-            if (parent instanceof PropertyPointer){\n-                return parent.createPath(context).getValuePointer();\n-            }\n-            else {\n-                return parent.createChild(context, getName(), 0).getValuePointer();\n-            }\n+    public NodePointer createPath(JXPathContext context) {\n+        if (parent != null) {\n+            return parent.createPath(context).getValuePointer();\n         }\n-        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+        else {\n+            throw new UnsupportedOperationException(\n+                \"Cannot create the root object: \" + asPath());\n+        }\n     }\n \n-    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n-        if (parent != null){\n-            NodePointer pointer = createPath(context);\n-            if (pointer != null){\n-                pointer = pointer.getValuePointer().createChild(context, name, index, value);\n-                return pointer;\n-            }\n-        }\n-        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index) \n+    {\n+        return createPath(context).createChild(context, name, index);\n     }\n \n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n-        if (parent != null){\n-            NodePointer pointer = createPath(context);\n-            if (pointer != null){\n-                return pointer.createChild(context, name, index);\n-            }\n-        }\n-        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name, \n+        int index,\n+        Object value) \n+    {\n+        return createPath(context).createChild(context, name, index, value);\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof NullPointer)){\n+        if (!(object instanceof NullPointer)) {\n             return false;\n         }\n \n-        NullPointer other = (NullPointer)object;\n-        return (name == null && other.name == null) ||\n-               (name != null && name.equals(other.name));\n+        NullPointer other = (NullPointer) object;\n+        return (name == null && other.name == null)\n+            || (name != null && name.equals(other.name));\n     }\n \n-    public String asPath(){\n-        if (id != null){\n+    public String asPath() {\n+        if (id != null) {\n             return \"id(\" + id + \")\";\n         }\n \n-        if (parent != null){\n+        if (parent != null) {\n             return super.asPath();\n         }\n         return \"null()\";\n     }\n \n-    public int getLength(){\n+    public int getLength() {\n         return 0;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.11 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.12 2003/01/11 05:41:24 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:24 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:24 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n \n     /**\n      */\n-    public NullPropertyPointer(NodePointer parent){\n+    public NullPropertyPointer(NodePointer parent) {\n         super(parent);\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return new QName(propertyName);\n     }\n \n-    public void setPropertyIndex(int index){\n-    }\n-\n-    public int getLength(){\n+    public void setPropertyIndex(int index) {\n+    }\n+\n+    public int getLength() {\n         return 0;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return null;\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return null;\n     }\n \n         return true;\n     }    \n \n-    public NodePointer getValuePointer(){\n+    public NodePointer getValuePointer() {\n         return new NullPointer(this,  new QName(getPropertyName()));\n     }\n \n-    protected boolean isActualProperty(){\n+    protected boolean isActualProperty() {\n         return false;\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return false;\n     }\n \n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n-    public void setValue(Object value){\n-        if (parent == null || parent.isContainer()){\n-            throw new JXPathException(\"Cannot set property \" + asPath() +\n-                \", the target object is null\");\n-        }\n-        else {\n-            throw new JXPathException(\"Cannot set property \" + asPath() +\n-                \", path does not match a changeable location\");\n-        }\n-    }\n-\n-    public NodePointer createPath(JXPathContext context){\n-        if (isAttribute()){\n+    public void setValue(Object value) {\n+        if (parent == null || parent.isContainer()) {\n+            throw new JXPathException(\n+                \"Cannot set property \"\n+                    + asPath()\n+                    + \", the target object is null\");\n+        }\n+        else {\n+            throw new JXPathException(\n+                \"Cannot set property \"\n+                    + asPath()\n+                    + \", path does not match a changeable location\");\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context) {\n+        if (isAttribute()) {\n             return parent.createAttribute(context, getName());\n         }\n         else {\n-            return parent.createChild(context, getName(), getIndex());\n-        }\n-    }\n-\n-    public NodePointer createPath(JXPathContext context, Object value){\n-        if (isAttribute()){\n+            // Consider these two use cases:\n+            // 1. The parent pointer of NullPropertyPointer is \n+            //    a PropertyOwnerPointer other than NullPointer. When we call \n+            //    createPath on it, it most likely returns itself. We then\n+            //    take a PropertyPointer from it and get the PropertyPointer\n+            //    to expand the collection for the corresponsing property.\n+            //\n+            // 2. The parent pointer of NullPropertyPointer is a NullPointer.\n+            //    When we call createPath, it may return a PropertyOwnerPointer\n+            //    or it may return anything else, like a DOMNodePointer.\n+            //    In the former case we need to exactly what we did in use \n+            //    case 1.  In the latter case, we simply request that the \n+            //    non-property pointer expand the collection by itself.\n+\n+            NodePointer newParent = parent.createPath(context);\n+            if (newParent instanceof PropertyOwnerPointer) {\n+                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n+                newParent = pop.getPropertyPointer();\n+            }\n+            return newParent.createChild(context, getName(), getIndex());\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        if (isAttribute()) {\n             NodePointer pointer = parent.createAttribute(context, getName());\n             pointer.setValue(value);\n             return pointer;\n         }\n         else {\n-            return parent.createChild(context, getName(), getIndex(), value);\n-        }\n-    }\n-\n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index, Object value){\n+            NodePointer newParent = parent.createPath(context);\n+            if (newParent instanceof PropertyOwnerPointer) {\n+                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n+                newParent = pop.getPropertyPointer();\n+            }\n+            return newParent.createChild(context, getName(), index, value);\n+        }\n+    }\n+    \n+    public NodePointer createChild(\n+            JXPathContext context,\n+            QName name, \n+            int index)\n+    {\n+        return createPath(context).createChild(context, name, index);\n+    }\n+        \n+    public NodePointer createChild(\n+            JXPathContext context,\n+            QName name, \n+            int index,\n+            Object value) \n+    {\n         return createPath(context).createChild(context, name, index, value);\n     }\n \n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index){\n-        return createPath(context).createChild(context, name, index);\n-    }\n-\n-    public String getPropertyName(){\n+    public String getPropertyName() {\n         return propertyName;\n     }\n \n-    public void setPropertyName(String propertyName){\n+    public void setPropertyName(String propertyName) {\n         this.propertyName = propertyName;\n     }\n \n-    public void setNameAttributeValue(String attributeValue){\n+    public void setNameAttributeValue(String attributeValue) {\n         this.propertyName = attributeValue;\n         byNameAttribute = true;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return getIndex() != WHOLE_COLLECTION;\n     }\n \n-    public int getPropertyCount(){\n+    public int getPropertyCount() {\n         return 0;\n     }\n \n-    public String[] getPropertyNames(){\n+    public String[] getPropertyNames() {\n         return new String[0];\n     }\n \n-    public String asPath(){\n-        if (!byNameAttribute){\n+    public String asPath() {\n+        if (!byNameAttribute) {\n             return super.asPath();\n         }\n         else {\n             buffer.append(\"[@name='\");\n             buffer.append(escape(getPropertyName()));\n             buffer.append(\"']\");\n-            if (index != WHOLE_COLLECTION){\n+            if (index != WHOLE_COLLECTION) {\n                 buffer.append('[').append(index + 1).append(']');\n             }\n             return buffer.toString();\n         }\n     }\n \n-    private String escape(String string){\n+    private String escape(String string) {\n         int index = string.indexOf('\\'');\n-        while (index != -1){\n-            string = string.substring(0, index) + \"&apos;\" +\n-                    string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&apos;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n-        while (index != -1){\n-            string = string.substring(0, index) + \"&quot;\" +\n-                    string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&quot;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n         return string;\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java,v 1.6 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java,v 1.7 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class PropertyIterator implements NodeIterator {\n     private boolean empty = false;\n     private boolean ready = false;\n     private boolean includeStart = false;\n \n-    public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith){\n+    public PropertyIterator(\n+        PropertyOwnerPointer pointer,\n+        String name,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         propertyNodePointer = pointer.getPropertyPointer();\n         this.name = name;\n         this.reverse = reverse;\n         }\n     }\n     \n-    protected NodePointer getPropertyPointer(){\n+    protected NodePointer getPropertyPointer() {\n         return propertyNodePointer;\n     }\n \n-    public void reset(){\n+    public void reset() {\n         position = 0;\n         targetReady = false;\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (position == 0){\n-            if (name != null){\n-                if (!targetReady){\n+    public NodePointer getNodePointer() {\n+        if (position == 0) {\n+            if (name != null) {\n+                if (!targetReady) {\n                     prepareForIndividualProperty(name);\n                 }\n                 // If there is no such property - return null\n-                if (empty){\n+                if (empty) {\n                     return null;\n                 }\n             }\n             else {\n-                if (!setPosition(1)){\n+                if (!setPosition(1)) {\n                     return null;\n                 }\n                 reset();\n         return getValuePointer();       \n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n-        if (name != null){\n+    public boolean setPosition(int position) {\n+        if (name != null) {\n             return setPositionIndividualProperty(position);\n         }\n         else {\n         }\n     }\n \n-    private boolean setPositionIndividualProperty(int position){\n+    private boolean setPositionIndividualProperty(int position) {\n         this.position = position;\n-        if (position < 1){\n+        if (position < 1) {\n             return false;\n         }\n \n-        if (!targetReady){\n+        if (!targetReady) {\n             prepareForIndividualProperty(name);\n         }\n \n-        if (empty){\n+        if (empty) {\n             return false;\n         }\n \n         int length = getLength();\n         int index;\n-        if (!reverse){\n+        if (!reverse) {\n             index = position + startIndex;\n-            if (!includeStart){\n+            if (!includeStart) {\n                 index++;\n             }\n-            if (index > length){\n+            if (index > length) {\n                 return false;\n             }\n         }\n         else {\n             int end = startIndex;\n-            if (end == -1){\n+            if (end == -1) {\n                 end = length - 1;\n             }\n             index = end - position + 2;\n-            if (!includeStart){\n+            if (!includeStart) {\n                 index--;\n             }\n-            if (index < 1){\n+            if (index < 1) {\n                 return false;\n             }\n         }\n         return true;\n     }\n \n-    private boolean setPositionAllProperties(int position){\n+    private boolean setPositionAllProperties(int position) {\n         this.position = position;\n-        if (position < 1){\n+        if (position < 1) {\n             return false;\n         }\n \n         int offset;\n         int count = propertyNodePointer.getPropertyCount();\n-        if (!reverse){\n+        if (!reverse) {\n             int index = 1;\n-            for (int i = startPropertyIndex; i < count; i++){\n+            for (int i = startPropertyIndex; i < count; i++) {\n                 propertyNodePointer.setPropertyIndex(i);\n                 int length = getLength();\n-                if (i == startPropertyIndex){\n+                if (i == startPropertyIndex) {\n                     length -= startIndex;\n-                    if (!includeStart){\n+                    if (!includeStart) {\n                         length--;\n                     }\n                     offset = startIndex + position - index;\n-                    if (!includeStart){\n+                    if (!includeStart) {\n                         offset++;\n                     }\n                 }\n                 else {\n                     offset = position - index;\n                 }\n-                if (index <= position && position < index + length){\n+                if (index <= position && position < index + length) {\n                     propertyNodePointer.setIndex(offset);\n                     return true;\n                 }\n         else {\n             int index = 1;\n             int start = startPropertyIndex;\n-            if (start == PropertyPointer.UNSPECIFIED_PROPERTY){\n+            if (start == PropertyPointer.UNSPECIFIED_PROPERTY) {\n                 start = count - 1;\n             }\n-            for (int i = start; i >= 0; i--){\n+            for (int i = start; i >= 0; i--) {\n                 propertyNodePointer.setPropertyIndex(i);\n                 int length = getLength();\n-                if (i == startPropertyIndex){\n+                if (i == startPropertyIndex) {\n                     int end = startIndex;\n-                    if (end == -1){\n+                    if (end == -1) {\n                         end = length - 1;\n                     }\n                     length = end + 1;\n                     offset = end - position + 1;\n-                    if (!includeStart){\n+                    if (!includeStart) {\n                         offset--;\n                         length--;\n                     }\n                     offset = length - (position - index) - 1;\n                 }\n \n-                if (index <= position && position < index + length){\n+                if (index <= position && position < index + length) {\n                     propertyNodePointer.setIndex(offset);\n                     return true;\n                 }\n         return false;\n     }\n \n-    protected void prepareForIndividualProperty(String name){\n+    protected void prepareForIndividualProperty(String name) {\n         targetReady = true;\n         empty = true;\n \n         String names[] = propertyNodePointer.getPropertyNames();\n-        if (!reverse){\n-            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n+        if (!reverse) {\n+            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) {\n                 startPropertyIndex = 0;\n             }\n-            if (startIndex == NodePointer.WHOLE_COLLECTION){\n+            if (startIndex == NodePointer.WHOLE_COLLECTION) {\n                 startIndex = 0;\n             }\n-            for (int i = startPropertyIndex; i < names.length; i++){\n-                if (names[i].equals(name)){\n+            for (int i = startPropertyIndex; i < names.length; i++) {\n+                if (names[i].equals(name)) {\n                     propertyNodePointer.setPropertyIndex(i);\n-                    if (i != startPropertyIndex){\n+                    if (i != startPropertyIndex) {\n                         startIndex = 0;\n                         includeStart = true;\n                     }\n             }\n         }\n         else {\n-            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n+            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) {\n                 startPropertyIndex = names.length - 1;\n             }\n-            if (startIndex == NodePointer.WHOLE_COLLECTION){\n+            if (startIndex == NodePointer.WHOLE_COLLECTION) {\n                 startIndex = -1;\n             }\n-            for (int i = startPropertyIndex; i >= 0; i--){\n-                if (names[i].equals(name)){\n+            for (int i = startPropertyIndex; i >= 0; i--) {\n+                if (names[i].equals(name)) {\n                     propertyNodePointer.setPropertyIndex(i);\n-                    if (i != startPropertyIndex){\n+                    if (i != startPropertyIndex) {\n                         startIndex = -1;\n                         includeStart = true;\n                     }\n         try {\n             length = propertyNodePointer.getLength();   // TBD: cache length\n         }\n-        catch (Throwable t){\n+        catch (Throwable t) {\n             // @todo: should this exception be reported in any way?\n             length = 0;\n         }\n         try {\n             return propertyNodePointer.getValuePointer();\n         }\n-        catch (Throwable ex){\n+        catch (Throwable ex) {\n             // @todo: should this exception be reported in any way?\n             NullPropertyPointer npp =\n                 new NullPropertyPointer(propertyNodePointer.getParent());\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.12 2003/01/10 02:11:28 dmitri Exp $\n- * $Revision: 1.12 $\n- * $Date: 2003/01/10 02:11:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.13 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.Locale;\n \n-import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.12 $ $Date: 2003/01/10 02:11:28 $\n+ * @version $Revision: 1.13 $ $Date: 2003/01/11 05:41:25 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n-    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n-        if (test == null){\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n+        if (test == null) {\n             return createNodeIterator(null, reverse, startWith);\n         }\n-        else if (test instanceof NodeNameTest){\n-            QName testName = ((NodeNameTest)test).getNodeName();\n+        else if (test instanceof NodeNameTest) {\n+            QName testName = ((NodeNameTest) test).getNodeName();\n             String property;\n-            if (!isDefaultNamespace(testName.getPrefix())){\n+            if (!isDefaultNamespace(testName.getPrefix())) {\n                 return null;\n             }\n-            else if (testName.getName().equals(\"*\")){\n+            else if (testName.getName().equals(\"*\")) {\n                 property = null;\n             }\n             else {\n             }\n             return createNodeIterator(property, reverse, startWith);\n         }\n-        else if (test instanceof NodeTypeTest){\n-            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+        else if (test instanceof NodeTypeTest) {\n+            if (((NodeTypeTest) test).getNodeType()\n+                == Compiler.NODE_TYPE_NODE) {\n                 return createNodeIterator(null, reverse, startWith);\n             }\n         }\n         return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return new BeanAttributeIterator(this, name);\n     }\n \n-    protected PropertyOwnerPointer(NodePointer parent, Locale locale){\n+    protected PropertyOwnerPointer(NodePointer parent, Locale locale) {\n         super(parent, locale);\n     }\n \n-    protected PropertyOwnerPointer(NodePointer parent){\n+    protected PropertyOwnerPointer(NodePointer parent) {\n         super(parent);\n     }\n \n-    public void setIndex(int index){\n-        if (this.index != index){\n+    public void setIndex(int index) {\n+        if (this.index != index) {\n             super.setIndex(index);\n             value = UNINITIALIZED;\n         }\n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getImmediateNode(){\n-        if (value == UNINITIALIZED){\n-            if (index == WHOLE_COLLECTION){\n+    public Object getImmediateNode() {\n+        if (value == UNINITIALIZED) {\n+            if (index == WHOLE_COLLECTION) {\n                 value = getBaseValue();\n             }\n             else {\n      * Throws an exception if you try to change the root element, otherwise\n      * forwards the call to the parent pointer.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         this.value = value;\n-        if (parent.isContainer()){\n+        if (parent.isContainer()) {\n             parent.setValue(value);\n         }\n-        else if (parent != null){\n-            if (index == WHOLE_COLLECTION){\n+        else if (parent != null) {\n+            if (index == WHOLE_COLLECTION) {\n                 throw new UnsupportedOperationException(\n-                    \"Cannot setValue of an object that is not \" +\n-                    \"some other object's property\");\n+                    \"Cannot setValue of an object that is not \"\n+                        + \"some other object's property\");\n             }\n             else {\n                 throw new JXPathException(\n      * If this is a root node pointer, throws an exception; otherwise\n      * forwards the call to the parent node.\n      */\n-    public void remove(){\n+    public void remove() {\n         this.value = null;\n-        if (parent != null){\n+        if (parent != null) {\n             parent.remove();\n         }\n         else {\n             throw new UnsupportedOperationException(\n-                \"Cannot remove an object that is not \" +\n-                \"some other object's property or a collection element\");\n+                \"Cannot remove an object that is not \"\n+                    + \"some other object's property or a collection element\");\n         }\n     }\n \n     public abstract PropertyPointer getPropertyPointer();\n \n-    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n-        PropertyPointer prop = getPropertyPointer();\n-        prop.setPropertyName(name.getName());\n-        prop.setIndex(index);\n-        return prop.createPath(context, value);\n-    }\n-\n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n-        PropertyPointer prop = getPropertyPointer();\n-        prop.setPropertyName(name.getName());\n-        prop.setIndex(index);\n-        return prop.createPath(context);\n-    }\n-\n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n-        int r = pointer1.getName().toString().compareTo(pointer2.getName().toString());\n-        if (r != 0){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n+        int r =\n+            pointer1.getName().toString().compareTo(\n+                pointer2.getName().toString());\n+        if (r != 0) {\n             return r;\n         }\n         return pointer1.getIndex() - pointer2.getIndex();\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.7 2002/11/26 01:20:06 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/26 01:20:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.8 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.beans;\n \n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.JXPathIntrospector;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n  * a property of the parent object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/26 01:20:06 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:25 $\n  */\n public abstract class PropertyPointer extends NodePointer {\n-    public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n+    public static final int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n \n     protected int propertyIndex = UNSPECIFIED_PROPERTY;\n     protected Object bean;\n      * Takes a javabean, a descriptor of a property of that object and\n      * an offset within that property (starting with 0).\n      */\n-    public PropertyPointer(NodePointer parent){\n+    public PropertyPointer(NodePointer parent) {\n         super(parent);\n     }\n \n-    public int getPropertyIndex(){\n+    public int getPropertyIndex() {\n         return propertyIndex;\n     }\n \n-    public void setPropertyIndex(int index){\n+    public void setPropertyIndex(int index) {\n         propertyIndex = index;\n         index = WHOLE_COLLECTION;\n     }\n \n-    public Object getBean(){\n-        if (bean == null){\n+    public Object getBean() {\n+        if (bean == null) {\n             bean = getParent().getNode();\n         }\n         return bean;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return new QName(null, getPropertyName());\n     }\n \n \n     protected abstract boolean isActualProperty();\n \n-    public boolean isActual(){\n-        if (!isActualProperty()){\n+    public boolean isActual() {\n+        if (!isActualProperty()) {\n             return false;\n         }\n \n     private static final Object UNINITIALIZED = new Object();\n \n     private Object value = UNINITIALIZED;\n-    public Object getImmediateNode(){\n-        if (value == UNINITIALIZED){\n-            if (index == WHOLE_COLLECTION){\n+    public Object getImmediateNode() {\n+        if (value == UNINITIALIZED) {\n+            if (index == WHOLE_COLLECTION) {\n                 value = getBaseValue();\n             }\n             else {\n         return value;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      */\n-    public int getLength(){\n+    public int getLength() {\n         return ValueUtils.getLength(getBaseValue());\n     }\n \n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n      */\n-    public NodePointer getImmediateValuePointer(){\n+    public NodePointer getImmediateValuePointer() {\n         return NodePointer.newChildNodePointer(\n             this,\n             getName(),\n             getImmediateNode());\n     }\n \n-    public int hashCode(){\n+    public NodePointer createPath(JXPathContext context) {\n+        if (getImmediateNode() == null) {\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            boolean success =\n+                factory.createObject(\n+                    context,\n+                    this,\n+                    getBean(),\n+                    getPropertyName(),\n+                    inx);\n+            if (!success) {\n+                throw new JXPathException(\n+                    \"Factory \"\n+                        + factory\n+                        + \" could not create an object for path: \"\n+                        + asPath());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        // If neccessary, expand collection\n+        if (index != WHOLE_COLLECTION && index >= getLength()) {\n+            createPath(context);\n+        }\n+        setValue(value);            \n+        return this;\n+    }\n+\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index,\n+        Object value) \n+    {\n+        PropertyPointer prop = (PropertyPointer) clone();\n+        if (name != null) {\n+            prop.setPropertyName(name.toString());\n+        }\n+        prop.setIndex(index);\n+        return prop.createPath(context, value);\n+    }\n+\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index) \n+    {\n+        PropertyPointer prop = (PropertyPointer) clone();\n+        if (name != null) {\n+            prop.setPropertyName(name.toString());\n+        }\n+        prop.setIndex(index);\n+        return prop.createPath(context);\n+    }\n+\n+    public int hashCode() {\n         return getParent().hashCode() + propertyIndex + index;\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof PropertyPointer)){\n+        if (!(object instanceof PropertyPointer)) {\n             return false;\n         }\n \n-        PropertyPointer other = (PropertyPointer)object;\n-        if (parent != other.parent){\n-            if (parent == null || !parent.equals(other.parent)){\n+        PropertyPointer other = (PropertyPointer) object;\n+        if (parent != other.parent) {\n+            if (parent == null || !parent.equals(other.parent)) {\n                 return false;\n             }\n         }\n \n-        if (getPropertyIndex() != other.getPropertyIndex() ||\n-               !getPropertyName().equals(other.getPropertyName())){\n+        if (getPropertyIndex() != other.getPropertyIndex()\n+            || !getPropertyName().equals(other.getPropertyName())) {\n             return false;\n         }\n \n-        int i_this = (index == WHOLE_COLLECTION ? 0 : index);\n-        int i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-        return i_this == i_other;\n-    }\n-\n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+        int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n+        int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n+        return iThis == iOther;\n+    }\n+\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         return getValuePointer().compareChildNodePointers(pointer1, pointer2);\n     }\n+    \n+    private AbstractFactory getAbstractFactory(JXPathContext context) {\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null) {\n+            throw new JXPathException(\n+                \"Factory is not set on the \"\n+                    + \"JXPathContext - cannot create path: \"\n+                    + asPath());\n+        }\n+        return factory;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.7 2002/11/28 01:02:04 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/28 01:02:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.8 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * itself.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/11/28 01:02:04 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class ContainerPointer extends NodePointer {\n     private Container container;\n     private NodePointer valuePointer;\n \n-    public ContainerPointer(Container container, Locale locale){\n+    public ContainerPointer(Container container, Locale locale) {\n         super(null, locale);\n         this.container = container;\n     }\n \n-    public ContainerPointer(NodePointer parent, Container container){\n+    public ContainerPointer(NodePointer parent, Container container) {\n         super(parent);\n         this.container = container;\n     }\n     /**\n      * This type of node is auxiliary.\n      */\n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return null;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return container.getValue();\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         Object value = getBaseValue();\n         return value != null && ValueUtils.isCollection(value);\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         Object value = getBaseValue();\n         if (value == null) {\n             return 1;\n         return getValuePointer().isLeaf();\n     }    \n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         Object value = getBaseValue();\n-        if (index != WHOLE_COLLECTION){\n-            if (index >= 0 && index < getLength()){\n+        if (index != WHOLE_COLLECTION) {\n+            if (index >= 0 && index < getLength()) {\n                 return ValueUtils.getValue(value, index);\n             }\n             else {\n         return value;\n     }\n \n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         container.setValue(value);\n     }\n \n-    public NodePointer getImmediateValuePointer(){\n+    public NodePointer getImmediateValuePointer() {\n         if (valuePointer == null) {\n             Object value = getImmediateNode();\n             valuePointer =\n         return valuePointer;\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(container) + index;\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof ContainerPointer)){\n+        if (!(object instanceof ContainerPointer)) {\n             return false;\n         }\n \n-        ContainerPointer other = (ContainerPointer)object;\n-        return container == other.container &&\n-                index == other.index;\n-    }\n-\n-    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        ContainerPointer other = (ContainerPointer) object;\n+        return container == other.container && index == other.index;\n+    }\n+\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         return getValuePointer().childIterator(test, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return getValuePointer().attributeIterator(name);\n     }\n \n-    public NodeIterator namespaceIterator(){\n+    public NodeIterator namespaceIterator() {\n         return getValuePointer().namespaceIterator();\n     }\n \n-    public NodePointer namespacePointer(String namespace){\n+    public NodePointer namespacePointer(String namespace) {\n         return getValuePointer().namespacePointer(namespace);\n     }\n \n-    public boolean testNode(NodeTest nodeTest){\n+    public boolean testNode(NodeTest nodeTest) {\n         return getValuePointer().testNode(nodeTest);\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         return pointer1.getIndex() - pointer2.getIndex();\n     }\n \n-    public String asPath(){\n-        if (parent != null){\n+    public String asPath() {\n+        if (parent != null) {\n             return parent.asPath();\n         }\n         return \"/\";\n--- a/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java,v 1.2 2002/04/24 04:05:41 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java,v 1.3 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for Container objects.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:41 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class ContainerPointerFactory implements NodePointerFactory {\n \n     public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return CONTAINER_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n-        if (bean instanceof Container){\n-            return new ContainerPointer((Container)bean, locale);\n+    public NodePointer createNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale) \n+    {\n+        if (bean instanceof Container) {\n+            return new ContainerPointer((Container) bean, locale);\n         }\n         return null;\n     }\n \n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n-        if (bean instanceof Container){\n-            return new ContainerPointer(parent, (Container)bean);\n+    public NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n+    {\n+        if (bean instanceof Container) {\n+            return new ContainerPointer(parent, (Container) bean);\n         }\n         return null;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,v 1.7 2002/12/02 01:12:20 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/12/02 01:12:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,v 1.8 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of attributes of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/12/02 01:12:20 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMAttributeIterator implements NodeIterator {\n     private NodePointer parent;\n     private List attributes;\n     private int position = 0;\n \n-    public DOMAttributeIterator(NodePointer parent, QName name){\n+    public DOMAttributeIterator(NodePointer parent, QName name) {\n         this.parent = parent;\n         this.name = name;\n         attributes = new ArrayList();\n-        Node node = (Node)parent.getNode();\n-        if (node.getNodeType() == Node.ELEMENT_NODE){\n+        Node node = (Node) parent.getNode();\n+        if (node.getNodeType() == Node.ELEMENT_NODE) {\n             String lname = name.getName();\n-            if (!lname.equals(\"*\")){\n-                Attr attr = getAttribute((Element)node, name);\n-                if (attr != null){\n+            if (!lname.equals(\"*\")) {\n+                Attr attr = getAttribute((Element) node, name);\n+                if (attr != null) {\n                     attributes.add(attr);\n                 }\n             }\n             else {\n                 NamedNodeMap map = node.getAttributes();\n                 int count = map.getLength();\n-                for (int i = 0; i < count; i++){\n-                    Attr attr = (Attr)map.item(i);\n-                    if (testAttr(attr, name)){\n+                for (int i = 0; i < count; i++) {\n+                    Attr attr = (Attr) map.item(i);\n+                    if (testAttr(attr, name)) {\n                         attributes.add(attr);\n                     }\n                 }\n         }\n     }\n \n-    private boolean testAttr(Attr attr, QName testName){\n+    private boolean testAttr(Attr attr, QName testName) {\n         String nodePrefix = DOMNodePointer.getPrefix(attr);\n         String nodeLocalName = DOMNodePointer.getLocalName(attr);\n \n-        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")){\n-            return false;\n-        }\n-\n-        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")){\n+        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n+            return false;\n+        }\n+\n+        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n             return false;\n         }\n \n         String testLocalName = name.getName();\n-        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)){\n+        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n             String testPrefix = testName.getPrefix();\n \n-            if (equalStrings(testPrefix, nodePrefix)){\n+            if (equalStrings(testPrefix, nodePrefix)) {\n                 return true;\n             }\n \n             String testNS = null;\n-            if (testPrefix != null){\n+            if (testPrefix != null) {\n                 testNS = parent.getNamespaceURI(testPrefix);\n             }\n \n             String nodeNS = null;\n-            if (nodePrefix != null){\n+            if (nodePrefix != null) {\n                 nodeNS = parent.getNamespaceURI(nodePrefix);\n             }\n             return equalStrings(testNS, nodeNS);\n         return false;\n     }\n \n-    private static boolean equalStrings(String s1, String s2){\n-        if (s1 == null && s2 != null){\n-            return false;\n-        }\n-        if (s1 != null && !s1.equals(s2)){\n+    private static boolean equalStrings(String s1, String s2) {\n+        if (s1 == null && s2 != null) {\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)) {\n             return false;\n         }\n         return true;\n     }\n \n-    private Attr getAttribute(Element element, QName name){\n+    private Attr getAttribute(Element element, QName name) {\n         String testPrefix = name.getPrefix();\n         String testNS = null;\n \n-        if (testPrefix != null){\n+        if (testPrefix != null) {\n             testNS = parent.getNamespaceURI(testPrefix);\n         }\n \n-        if (testNS != null){\n+        if (testNS != null) {\n             Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n-            if (attr != null){\n+            if (attr != null) {\n                 return attr;\n             }\n-            \n+\n             // This may mean that the parser does not support NS for\n             // attributes, example - the version of Crimson bundled\n             // with JDK 1.4.0\n             NamedNodeMap nnm = element.getAttributes();\n-            for (int i = 0; i < nnm.getLength(); i++){\n-                attr = (Attr)nnm.item(i);\n-                if (testAttr(attr, name)){\n+            for (int i = 0; i < nnm.getLength(); i++) {\n+                attr = (Attr) nnm.item(i);\n+                if (testAttr(attr, name)) {\n                     return attr;\n                 }\n             }\n         }\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         }\n         int index = position - 1;\n-        if (index < 0){\n+        if (index < 0) {\n             index = 0;\n         }\n-        return new DOMAttributePointer(parent, (Attr)attributes.get(index));\n-    }\n-\n-    public int getPosition(){\n+        return new DOMAttributePointer(parent, (Attr) attributes.get(index));\n+    }\n+\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.9 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.10 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.10 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMAttributePointer extends NodePointer {\n     private Attr attr;\n \n-    public DOMAttributePointer(NodePointer parent, Attr attr){\n+    public DOMAttributePointer(NodePointer parent, Attr attr) {\n         super(parent);\n         this.attr = attr;\n     }\n \n-    public QName getName(){\n-        return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr));\n+    public QName getName() {\n+        return new QName(\n+            DOMNodePointer.getPrefix(attr),\n+            DOMNodePointer.getLocalName(attr));\n     }\n \n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return new QName(getNamespaceURI(),  DOMNodePointer.getLocalName(attr));\n     }\n \n-    public String getNamespaceURI(){\n+    public String getNamespaceURI() {\n         String prefix = DOMNodePointer.getPrefix(attr);\n-        if (prefix == null){\n+        if (prefix == null) {\n             return null;\n         }\n         return parent.getNamespaceURI(prefix);\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return attr;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         String value = attr.getValue();\n-        if (value == null){\n+        if (value == null) {\n             return null;\n         }\n-        if (value.equals(\"\") && !attr.getSpecified()){\n+        if (value.equals(\"\") && !attr.getSpecified()) {\n             return null;\n         }\n         return value;\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return true;\n     }\n \n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         return true;\n     }\n \n-    public boolean testNode(NodeTest nodeTest){\n-        return nodeTest == null ||\n-                ((nodeTest instanceof NodeTypeTest) &&\n-                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    public boolean testNode(NodeTest nodeTest) {\n+        return nodeTest == null\n+            || ((nodeTest instanceof NodeTypeTest)\n+                && ((NodeTypeTest) nodeTest).getNodeType()\n+                    == Compiler.NODE_TYPE_NODE);\n     }\n \n     /**\n      * Sets the value of this attribute.\n      */\n-    public void setValue(Object value){\n-        attr.setValue((String)TypeUtils.convert(value, String.class));\n+    public void setValue(Object value) {\n+        attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n-    public void remove(){\n+    public void remove() {\n         attr.getOwnerElement().removeAttributeNode(attr);\n     }\n \n     /**\n      */\n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n-            if (buffer.length() == 0 ||\n-                    buffer.charAt(buffer.length()-1) != '/'){\n+            if (buffer.length() == 0\n+                || buffer.charAt(buffer.length() - 1) != '/') {\n                 buffer.append('/');\n             }\n         }\n         return buffer.toString();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof DOMAttributePointer)){\n+        if (!(object instanceof DOMAttributePointer)) {\n             return false;\n         }\n \n-        DOMAttributePointer other = (DOMAttributePointer)object;\n+        DOMAttributePointer other = (DOMAttributePointer) object;\n         return attr == other.attr;\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         // Won't happen - attributes don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java,v 1.4 2002/08/10 16:13:04 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/10 16:13:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java,v 1.5 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/08/10 16:13:04 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n     private List attributes;\n     private int position = 0;\n \n-    public DOMNamespaceIterator(NodePointer parent){\n+    public DOMNamespaceIterator(NodePointer parent) {\n         this.parent = parent;\n         attributes = new ArrayList();\n-        collectNamespaces(attributes, (Node)parent.getNode());\n+        collectNamespaces(attributes, (Node) parent.getNode());\n     }\n \n-    private void collectNamespaces(List attributes, Node node){\n+    private void collectNamespaces(List attributes, Node node) {\n         Node parent = node.getParentNode();\n-        if (parent != null){\n+        if (parent != null) {\n             collectNamespaces(attributes, parent);\n         }\n-        if (node.getNodeType() == Node.ELEMENT_NODE){\n+        if (node.getNodeType() == Node.ELEMENT_NODE) {\n             NamedNodeMap map = node.getAttributes();\n             int count = map.getLength();\n-            for (int i = 0; i < count; i++){\n-                Attr attr = (Attr)map.item(i);\n+            for (int i = 0; i < count; i++) {\n+                Attr attr = (Attr) map.item(i);\n                 String prefix = DOMNodePointer.getPrefix(attr);\n                 String name = DOMNodePointer.getLocalName(attr);\n-                if ((prefix != null && prefix.equals(\"xmlns\")) ||\n-                        (prefix == null && name.equals(\"xmlns\"))){\n+                if ((prefix != null && prefix.equals(\"xmlns\"))\n+                    || (prefix == null && name.equals(\"xmlns\"))) {\n                     attributes.add(attr);\n                 }\n             }\n         }\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         }\n         int index = position - 1;\n-        if (index < 0){\n+        if (index < 0) {\n             index = 0;\n         }\n         String prefix = \"\";\n-        Attr attr = (Attr)attributes.get(index);\n+        Attr attr = (Attr) attributes.get(index);\n         String name = attr.getPrefix();\n-        if (name != null && name.equals(\"xmlns\")){\n+        if (name != null && name.equals(\"xmlns\")) {\n             prefix = DOMNodePointer.getLocalName(attr);\n         }\n         return new NamespacePointer(parent, prefix, attr.getValue());\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= attributes.size();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java,v 1.5 2002/08/10 16:13:04 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/08/10 16:13:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java,v 1.6 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of children of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/08/10 16:13:04 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMNodeIterator implements NodeIterator {\n     private NodePointer parent;\n     private boolean reverse;\n     private int position = 0;\n \n-    public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith){\n+    public DOMNodeIterator(\n+        NodePointer parent,\n+        NodeTest nodeTest,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         this.parent = parent;\n-        this.node = (Node)parent.getNode();\n-        if (startWith != null){\n-            this.child = (Node)startWith.getNode();\n+        this.node = (Node) parent.getNode();\n+        if (startWith != null) {\n+            this.child = (Node) startWith.getNode();\n         }\n         this.nodeTest = nodeTest;\n         this.reverse = reverse;\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (child == null){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (child == null) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         return new DOMNodePointer(parent, child);\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n-        while (this.position < position){\n-            if (!next()){\n+    public boolean setPosition(int position) {\n+        while (this.position < position) {\n+            if (!next()) {\n                 return false;\n             }\n         }\n-        while (this.position > position){\n-            if (!previous()){\n+        while (this.position > position) {\n+            if (!previous()) {\n                 return false;\n             }\n         }\n-//        System.err.println(getNodePointer().asPath() + \" SET POSITION: \" + position);\n         return true;\n     }\n \n-    private boolean previous(){\n+    private boolean previous() {\n         position--;\n-        if (!reverse){\n+        if (!reverse) {\n             child = child.getPreviousSibling();\n-            while (child != null && !testChild()){\n+            while (child != null && !testChild()) {\n                 child = child.getPreviousSibling();\n             }\n         }\n         else {\n             child = child.getNextSibling();\n-            while (child != null && !testChild()){\n+            while (child != null && !testChild()) {\n                 child = child.getNextSibling();\n             }\n         }\n         return child != null;\n     }\n \n-    private boolean next(){\n+    private boolean next() {\n         position++;\n-        if (!reverse){\n-            if (position == 1){\n-                if (child == null){\n+        if (!reverse) {\n+            if (position == 1) {\n+                if (child == null) {\n                     child = node.getFirstChild();\n                 }\n                 else {\n             else {\n                 child = child.getNextSibling();\n             }\n-            while (child != null && !testChild()){\n+            while (child != null && !testChild()) {\n                 child = child.getNextSibling();\n             }\n         }\n         else {\n-            if (position == 1){\n-                if (child == null){\n+            if (position == 1) {\n+                if (child == null) {\n                     child = node.getLastChild();\n                 }\n                 else {\n             else {\n                 child = child.getPreviousSibling();\n             }\n-            while (child != null && !testChild()){\n+            while (child != null && !testChild()) {\n                 child = child.getPreviousSibling();\n             }\n         }\n         return child != null;\n     }\n \n-    private boolean testChild(){\n+    private boolean testChild() {\n         return DOMNodePointer.testNode(parent, child, nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.14 2002/11/29 06:44:16 dmitri Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/11/29 06:44:16 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.15 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2002/11/29 06:44:16 $\n+ * @version $Revision: 1.15 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMNodePointer extends NodePointer {\n     private Node node;\n     public static final String XMLNS_NAMESPACE_URI = \n             \"http://www.w3.org/2000/xmlns/\";\n \n-    public DOMNodePointer(Node node, Locale locale){\n+    public DOMNodePointer(Node node, Locale locale) {\n         super(null, locale);\n         this.node = node;\n     }\n \n-    public DOMNodePointer(Node node, Locale locale, String id){\n+    public DOMNodePointer(Node node, Locale locale, String id) {\n         super(null, locale);\n         this.node = node;\n         this.id = id;\n     }\n \n-    public DOMNodePointer(NodePointer parent, Node node){\n+    public DOMNodePointer(NodePointer parent, Node node) {\n         super(parent);\n         this.node = node;\n     }\n \n-    public boolean testNode(NodeTest test){\n+    public boolean testNode(NodeTest test) {\n         return testNode(this, node, test);\n     }\n \n     public static boolean testNode(\n             NodePointer pointer, Node node, NodeTest test)\n     {\n-        if (test == null){\n+        if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest){\n-            if (node.getNodeType() != Node.ELEMENT_NODE){\n+        else if (test instanceof NodeNameTest) {\n+            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                 return false;\n             }\n-//            System.err.println(\"Testing: \" + ((Element)node).getTagName());\n-\n-            QName testName = ((NodeNameTest)test).getNodeName();\n+\n+            QName testName = ((NodeNameTest) test).getNodeName();\n             String testLocalName = testName.getName();\n-            boolean wildcard = testLocalName.equals(\"*\"); \n+            boolean wildcard = testLocalName.equals(\"*\");\n             String testPrefix = testName.getPrefix();\n-            if (wildcard && testPrefix == null){\n+            if (wildcard && testPrefix == null) {\n                 return true;\n             }\n-            \n-            if (wildcard || \n-                    testLocalName.equals(DOMNodePointer.getLocalName(node))){\n+\n+            if (wildcard\n+                || testLocalName.equals(DOMNodePointer.getLocalName(node))) {\n                 String nodePrefix = DOMNodePointer.getPrefix(node);\n-                if (equalStrings(testPrefix, nodePrefix)){\n+                if (equalStrings(testPrefix, nodePrefix)) {\n                     return true;\n                 }\n \n                 return equalStrings(testNS, nodeNS);\n             }\n         }\n-        else if (test instanceof NodeTypeTest){\n+        else if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n-            switch (((NodeTypeTest)test).getNodeType()){\n-                case Compiler.NODE_TYPE_NODE:\n+            switch (((NodeTypeTest) test).getNodeType()) {\n+                case Compiler.NODE_TYPE_NODE :\n                     return nodeType == Node.ELEMENT_NODE;\n-                case Compiler.NODE_TYPE_TEXT:\n-                    return nodeType == Node.CDATA_SECTION_NODE ||\n-                            nodeType == Node.TEXT_NODE;\n-                case Compiler.NODE_TYPE_COMMENT:\n+                case Compiler.NODE_TYPE_TEXT :\n+                    return nodeType == Node.CDATA_SECTION_NODE\n+                        || nodeType == Node.TEXT_NODE;\n+                case Compiler.NODE_TYPE_COMMENT :\n                     return nodeType == Node.COMMENT_NODE;\n-                case Compiler.NODE_TYPE_PI:\n+                case Compiler.NODE_TYPE_PI :\n                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n             }\n             return false;\n         }\n-        else if (test instanceof ProcessingInstructionTest){\n-            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE){\n-                String testPI = ((ProcessingInstructionTest)test).getTarget();\n-                String nodePI = ((ProcessingInstruction)node).getTarget();\n+        else if (test instanceof ProcessingInstructionTest) {\n+            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n+                String testPI = ((ProcessingInstructionTest) test).getTarget();\n+                String nodePI = ((ProcessingInstruction) node).getTarget();\n                 return testPI.equals(nodePI);\n             }\n         }\n         return false;\n     }\n \n-    private static boolean equalStrings(String s1, String s2){\n-        if (s1 == null && s2 != null){\n+    private static boolean equalStrings(String s1, String s2) {\n+        if (s1 == null && s2 != null) {\n             return false;\n         }\n-        if (s1 != null && s2 == null){\n+        if (s1 != null && s2 == null) {\n             return false;\n         }\n \n-        if (s1 != null && !s1.trim().equals(s2.trim())){\n+        if (s1 != null && !s1.trim().equals(s2.trim())) {\n             return false;\n         }\n \n         return true;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         String ln = null;\n         String ns = null;\n         int type = node.getNodeType();\n-        if (type == Node.ELEMENT_NODE){\n+        if (type == Node.ELEMENT_NODE) {\n             ns = DOMNodePointer.getPrefix(node);\n             ln = DOMNodePointer.getLocalName(node);\n         }\n-        else if (type == Node.PROCESSING_INSTRUCTION_NODE){\n-            ln = ((ProcessingInstruction)node).getTarget();\n+        else if (type == Node.PROCESSING_INSTRUCTION_NODE) {\n+            ln = ((ProcessingInstruction) node).getTarget();\n         }\n         return new QName(ns, ln);\n     }\n \n-    public String getNamespaceURI(){\n-        if (node.getNodeType() == Node.ELEMENT_NODE){\n+    public String getNamespaceURI() {\n+        if (node.getNodeType() == Node.ELEMENT_NODE) {\n             return getNamespaceURI(getName().getPrefix());\n         }\n         return null;\n     }\n \n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return new QName(getNamespaceURI(), getName().getName());\n     }\n \n-    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         return new DOMNodeIterator(this, test, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return new DOMAttributeIterator(this, name);\n     }\n \n-    public NodePointer namespacePointer(String prefix){\n+    public NodePointer namespacePointer(String prefix) {\n         return new NamespacePointer(this, prefix);\n     }\n \n-    public NodeIterator namespaceIterator(){\n+    public NodeIterator namespaceIterator() {\n         return new DOMNamespaceIterator(this);\n     }\n \n-    public String getNamespaceURI(String prefix){\n-        if (prefix == null || prefix.equals(\"\")){\n+    public String getNamespaceURI(String prefix) {\n+        if (prefix == null || prefix.equals(\"\")) {\n             return getDefaultNamespaceURI();\n         }\n \n-        if (prefix.equals(\"xml\")){\n+        if (prefix.equals(\"xml\")) {\n             return XML_NAMESPACE_URI;\n         }\n \n-        if (prefix.equals(\"xmlns\")){\n+        if (prefix.equals(\"xmlns\")) {\n             return XMLNS_NAMESPACE_URI;\n         }\n \n         String namespace = null;\n-        if (namespaces == null){\n+        if (namespaces == null) {\n             namespaces = new HashMap();\n         }\n         else {\n-            namespace = (String)namespaces.get(prefix);\n-        }\n-\n-        if (namespace == null){\n+            namespace = (String) namespaces.get(prefix);\n+        }\n+\n+        if (namespace == null) {\n             String qname = \"xmlns:\" + prefix;\n             Node aNode = node;\n-            while (aNode != null){\n-                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n-                    Attr attr = ((Element)aNode).getAttributeNode(qname);\n-                    if (attr != null){\n+            while (aNode != null) {\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n+                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n+                    if (attr != null) {\n                         namespace = attr.getValue();\n                         break;\n                     }\n                 }\n                 aNode = aNode.getParentNode();\n             }\n-            if (namespace == null || namespace.equals(\"\")){\n+            if (namespace == null || namespace.equals(\"\")) {\n                 namespace = NodePointer.UNKNOWN_NAMESPACE;\n             }\n         }\n         return namespace;\n     }\n \n-    public String getDefaultNamespaceURI(){\n-        if (defaultNamespace == null){\n+    public String getDefaultNamespaceURI() {\n+        if (defaultNamespace == null) {\n             Node aNode = node;\n-            while (aNode != null){\n-                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n-                    Attr attr = ((Element)aNode).getAttributeNode(\"xmlns\");\n-                    if (attr != null){\n+            while (aNode != null) {\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n+                    Attr attr = ((Element) aNode).getAttributeNode(\"xmlns\");\n+                    if (attr != null) {\n                         defaultNamespace = attr.getValue();\n                         break;\n                     }\n                 aNode = aNode.getParentNode();\n             }\n         }\n-        if (defaultNamespace == null){\n+        if (defaultNamespace == null) {\n             defaultNamespace = \"\";\n         }\n         // TBD: We are supposed to resolve relative URIs to absolute ones.\n         return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return node;\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return node;\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return true;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }\n \n-    public boolean isLeaf(){\n-        if (node instanceof Element){\n-//            System.err.println(\"HAS CHILD NODES: \" + ((Element)node).getTagName() + \" \" + !node.hasChildNodes());\n+    public boolean isLeaf() {\n+        if (node instanceof Element) {\n+//            System.err.println(\"HAS CHILD NODES: \" + \n+//              ((Element)node).getTagName() + \" \" + !node.hasChildNodes());\n         }\n         return !node.hasChildNodes();\n     }\n      * or its parent has the specified prefix <i>lang</i>.\n      * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n      */\n-    public boolean isLanguage(String lang){\n+    public boolean isLanguage(String lang) {\n         String current = getLanguage();\n-        if (current == null){\n+        if (current == null) {\n             return super.isLanguage(lang);\n         }\n         return current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n-    protected String getLanguage(){\n+    protected String getLanguage() {\n         Node n = node;\n-        while (n != null){\n-            if (n.getNodeType() == Node.ELEMENT_NODE){\n-                Element e = (Element)n;\n+        while (n != null) {\n+            if (n.getNodeType() == Node.ELEMENT_NODE) {\n+                Element e = (Element) n;\n                 String attr = e.getAttribute(\"xml:lang\");\n-                if (attr != null && !attr.equals(\"\")){\n+                if (attr != null && !attr.equals(\"\")) {\n                     return attr;\n                 }\n             }\n      * If the value is an Element or Document, the children of the\n      * node are replaced with the children of the passed node.\n      */\n-    public void setValue(Object value){\n-        if (node.getNodeType() == Node.TEXT_NODE ||\n-                node.getNodeType() == Node.CDATA_SECTION_NODE){\n-            String string = (String)TypeUtils.convert(value, String.class);\n-            if (string != null && !string.equals(\"\")){\n+    public void setValue(Object value) {\n+        if (node.getNodeType() == Node.TEXT_NODE\n+            || node.getNodeType() == Node.CDATA_SECTION_NODE) {\n+            String string = (String) TypeUtils.convert(value, String.class);\n+            if (string != null && !string.equals(\"\")) {\n                 node.setNodeValue(string);\n             }\n             else {\n         else {\n             NodeList children = node.getChildNodes();\n             int count = children.getLength();\n-            for (int i = count; --i >= 0;){\n+            for (int i = count; --i >= 0;) {\n                 Node child = children.item(i);\n                 node.removeChild(child);\n             }\n-            \n-            if (value instanceof Node){\n-                Node valueNode = (Node)value;\n-                if (valueNode instanceof Element ||\n-                        valueNode instanceof Document){\n+\n+            if (value instanceof Node) {\n+                Node valueNode = (Node) value;\n+                if (valueNode instanceof Element\n+                    || valueNode instanceof Document) {\n                     children = valueNode.getChildNodes();\n-                    for (int i = 0; i < children.getLength(); i++){\n+                    for (int i = 0; i < children.getLength(); i++) {\n                         Node child = children.item(i);\n                         node.appendChild(child.cloneNode(true));\n                     }\n                 }\n                 else {\n                     node.appendChild(valueNode.cloneNode(true));\n-                }            \n+                }\n             }\n             else {\n-                String string = (String)TypeUtils.convert(value, String.class);\n-                if (string != null && !string.equals(\"\")){\n-                    Node textNode = \n-                            node.getOwnerDocument().createTextNode(string);\n+                String string = (String) TypeUtils.convert(value, String.class);\n+                if (string != null && !string.equals(\"\")) {\n+                    Node textNode =\n+                        node.getOwnerDocument().createTextNode(string);\n                     node.appendChild(textNode);\n                 }\n             }\n         }\n     }\n     \n-    public NodePointer createChild(JXPathContext context, \n-                QName name, int index)\n+    public NodePointer createChild(\n+        JXPathContext context,\n+        QName name,\n+        int index) \n     {\n-        if (index == WHOLE_COLLECTION){\n+        if (index == WHOLE_COLLECTION) {\n             index = 0;\n         }\n-        if (!getAbstractFactory(context).\n-                createObject(context, this, node, name.toString(), index)){\n-            throw new JXPathException(\n-                    \"Factory could not create a child node for path: \" +\n-                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n-        }\n-        NodeIterator it = childIterator(new NodeNameTest(name), false, null);\n-        if (it == null || !it.setPosition(index + 1)){\n-            throw new JXPathException(\n-                    \"Factory could not create a child node for path: \" +\n-                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n-        }\n-        return it.getNodePointer();\n+        boolean success =\n+            getAbstractFactory(context).createObject(\n+                context,\n+                this,\n+                node,\n+                name.toString(),\n+                index);\n+        if (success) {\n+            NodeIterator it =\n+                childIterator(new NodeNameTest(name), false, null);\n+            if (it != null && it.setPosition(index + 1)) {\n+                return it.getNodePointer();\n+            }\n+        }\n+        throw new JXPathException(\n+            \"Factory could not create a child node for path: \"\n+                + asPath()\n+                + \"/\"\n+                + name\n+                + \"[\"\n+                + (index + 1)\n+                + \"]\");\n     }\n \n     public NodePointer createChild(JXPathContext context, \n         return ptr;\n     }\n \n-    public NodePointer createAttribute(JXPathContext context, QName name){\n-        if (!(node instanceof Element)){\n+    public NodePointer createAttribute(JXPathContext context, QName name) {\n+        if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         }\n-        Element element = (Element)node;\n+        Element element = (Element) node;\n         String prefix = name.getPrefix();\n-        if (prefix != null){\n+        if (prefix != null) {\n             String ns = getNamespaceURI(prefix);\n-            if (ns == null){\n+            if (ns == null) {\n                 throw new JXPathException(\n                     \"Unknown namespace prefix: \" + prefix);\n             }\n             element.setAttributeNS(ns, name.toString(), \"\");\n         }\n         else {\n-            if (!element.hasAttribute(name.getName())){\n+            if (!element.hasAttribute(name.getName())) {\n                 element.setAttribute(name.getName(), \"\");\n             }\n         }\n         return it.getNodePointer();\n     }\n \n-    public void remove(){\n+    public void remove() {\n         Node parent = node.getParentNode();\n-        if (parent == null){\n+        if (parent == null) {\n             throw new JXPathException(\"Cannot remove root DOM node\");\n         }\n         parent.removeChild(node);\n     }\n \n-    public String asPath(){\n-        if (id != null){\n+    public String asPath() {\n+        if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n         }\n \n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n         }\n-        switch(node.getNodeType()){\n-            case Node.ELEMENT_NODE:\n+        switch (node.getNodeType()) {\n+            case Node.ELEMENT_NODE :\n                 // If the parent pointer is not a DOMNodePointer, it is\n                 // the parent's responsibility to produce the node test part\n                 // of the path\n-                if (parent instanceof DOMNodePointer){\n-                    if (buffer.length() == 0 ||\n-                            buffer.charAt(buffer.length()-1) != '/'){\n+                if (parent instanceof DOMNodePointer) {\n+                    if (buffer.length() == 0\n+                        || buffer.charAt(buffer.length() - 1) != '/') {\n                         buffer.append('/');\n                     }\n                     buffer.append(getName());\n                     buffer.append(getRelativePositionByName()).append(']');\n                 }\n                 break;\n-            case Node.TEXT_NODE:\n-            case Node.CDATA_SECTION_NODE:\n+            case Node.TEXT_NODE :\n+            case Node.CDATA_SECTION_NODE :\n                 buffer.append(\"/text()\");\n                 buffer.append('[');\n                 buffer.append(getRelativePositionOfTextNode()).append(']');\n                 break;\n-            case Node.PROCESSING_INSTRUCTION_NODE:\n-                String target = ((ProcessingInstruction)node).getTarget();\n+            case Node.PROCESSING_INSTRUCTION_NODE :\n+                String target = ((ProcessingInstruction) node).getTarget();\n                 buffer.append(\"/processing-instruction(\\'\");\n                 buffer.append(target).append(\"')\");\n                 buffer.append('[');\n                 buffer.append(getRelativePositionOfPI(target)).append(']');\n                 break;\n-            case Node.DOCUMENT_NODE:\n+            case Node.DOCUMENT_NODE :\n                 // That'll be empty\n         }\n         return buffer.toString();\n     }\n \n-    private String escape(String string){\n+    private String escape(String string) {\n         int index = string.indexOf('\\'');\n-        while (index != -1){\n-            string = string.substring(0, index) + \n-                \"&apos;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&apos;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n-        while (index != -1){\n-            string = string.substring(0, index) + \n-                \"&quot;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&quot;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n         return string;\n     }\n \n-    private int getRelativePositionByName(){\n+    private int getRelativePositionByName() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n-        while (n != null){\n-            if (n.getNodeType() == Node.ELEMENT_NODE){\n+        while (n != null) {\n+            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                 String nm = n.getNodeName();\n-                if (nm.equals(node.getNodeName())){\n-                    count ++;\n+                if (nm.equals(node.getNodeName())) {\n+                    count++;\n                 }\n             }\n             n = n.getPreviousSibling();\n         return count;\n     }\n \n-    private int getRelativePositionOfTextNode(){\n+    private int getRelativePositionOfTextNode() {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n-        while (n != null){\n-            if (n.getNodeType() == Node.TEXT_NODE || \n-                        n.getNodeType() == Node.CDATA_SECTION_NODE){\n-                count ++;\n+        while (n != null) {\n+            if (n.getNodeType() == Node.TEXT_NODE\n+                || n.getNodeType() == Node.CDATA_SECTION_NODE) {\n+                count++;\n             }\n             n = n.getPreviousSibling();\n         }\n         return count;\n     }\n \n-    private int getRelativePositionOfPI(String target){\n+    private int getRelativePositionOfPI(String target) {\n         int count = 1;\n         Node n = node.getPreviousSibling();\n-        while (n != null){\n-            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE &&\n-                    ((ProcessingInstruction)n).getTarget().equals(target)){\n-                count ++;\n+        while (n != null) {\n+            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE\n+                && ((ProcessingInstruction) n).getTarget().equals(target)) {\n+                count++;\n             }\n             n = n.getPreviousSibling();\n         }\n         return count;\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(node);\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof DOMNodePointer)){\n+        if (!(object instanceof DOMNodePointer)) {\n             return false;\n         }\n \n-        DOMNodePointer other = (DOMNodePointer)object;\n+        DOMNodePointer other = (DOMNodePointer) object;\n         return node == other.node;\n     }\n \n-    public static String getPrefix(Node node){\n+    public static String getPrefix(Node node) {\n         String prefix = node.getPrefix();\n-        if (prefix != null){\n+        if (prefix != null) {\n             return prefix;\n         }\n \n         String name = node.getNodeName();\n         int index = name.lastIndexOf(':');\n-        if (index == -1){\n+        if (index == -1) {\n             return null;\n         }\n \n         return name.substring(0, index);\n     }\n \n-    public static String getLocalName(Node node){\n+    public static String getLocalName(Node node) {\n         String localName = node.getLocalName();\n-        if (localName != null){\n+        if (localName != null) {\n             return localName;\n         }\n \n         String name = node.getNodeName();\n         int index = name.lastIndexOf(':');\n-        if (index == -1){\n+        if (index == -1) {\n             return name;\n         }\n \n         return name.substring(index + 1);\n     }\n \n-    public Object getValue(){\n+    public Object getValue() {\n         return stringValue(node);\n     }\n \n-    private String stringValue(Node node){\n+    private String stringValue(Node node) {\n         int nodeType = node.getNodeType();\n-        if (nodeType == Node.COMMENT_NODE){\n-            String text = ((Comment)node).getData();\n+        if (nodeType == Node.COMMENT_NODE) {\n+            String text = ((Comment) node).getData();\n             return text == null ? \"\" : text.trim();\n         }\n-        else if (nodeType == Node.TEXT_NODE ||\n-                nodeType == Node.CDATA_SECTION_NODE){\n+        else if (\n+            nodeType == Node.TEXT_NODE\n+                || nodeType == Node.CDATA_SECTION_NODE) {\n             String text = node.getNodeValue();\n             return text == null ? \"\" : text.trim();\n         }\n-        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE){\n-            String text = ((ProcessingInstruction)node).getData();\n+        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\n+            String text = ((ProcessingInstruction) node).getData();\n             return text == null ? \"\" : text.trim();\n         }\n         else {\n             NodeList list = node.getChildNodes();\n             StringBuffer buf = new StringBuffer(16);\n-            for(int i = 0; i < list.getLength();i++) {\n+            for (int i = 0; i < list.getLength(); i++) {\n                 Node child = list.item(i);\n-                if (child.getNodeType() == Node.TEXT_NODE){\n+                if (child.getNodeType() == Node.TEXT_NODE) {\n                     buf.append(child.getNodeValue());\n                 }\n                 else {\n     /**\n      * Locates a node by ID.\n      */\n-    public Pointer getPointerByID(JXPathContext context, String id){\n+    public Pointer getPointerByID(JXPathContext context, String id) {\n         Document document;\n-        if (node.getNodeType() == Node.DOCUMENT_NODE){\n-            document = (Document)node;\n+        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n+            document = (Document) node;\n         }\n         else {\n             document = node.getOwnerDocument();\n         }\n         Element element = document.getElementById(id);\n-        if (element != null){\n+        if (element != null) {\n             return new DOMNodePointer(element, getLocale(), id);\n         }\n         else {\n         }\n     }\n \n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n+    private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n+        if (factory == null) {\n             throw new JXPathException(\n-                \"Factory is not set on the JXPathContext - \" +\n-                \"cannot create path: \" + asPath());\n+                \"Factory is not set on the JXPathContext - \"\n+                    + \"cannot create path: \"\n+                    + asPath());\n         }\n         return factory;\n     }\n     public int compareChildNodePointers(\n             NodePointer pointer1, NodePointer pointer2)\n     {\n-        Node node1 = (Node)pointer1.getBaseValue();\n-        Node node2 = (Node)pointer2.getBaseValue();\n-        if (node1 == node2){\n+        Node node1 = (Node) pointer1.getBaseValue();\n+        Node node2 = (Node) pointer2.getBaseValue();\n+        if (node1 == node2) {\n             return 0;\n         }\n \n         int t1 = node1.getNodeType();\n         int t2 = node2.getNodeType();\n-        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE){\n+        if (t1 == Node.ATTRIBUTE_NODE && t2 != Node.ATTRIBUTE_NODE) {\n             return -1;\n         }\n-        else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE){\n+        else if (t1 != Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n             return 1;\n         }\n-        else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE){\n-            NamedNodeMap map = ((Node)getNode()).getAttributes();\n+        else if (t1 == Node.ATTRIBUTE_NODE && t2 == Node.ATTRIBUTE_NODE) {\n+            NamedNodeMap map = ((Node) getNode()).getAttributes();\n             int length = map.getLength();\n-            for (int i = 0; i < length; i++){\n+            for (int i = 0; i < length; i++) {\n                 Node n = map.item(i);\n-                if (n == node1){\n+                if (n == node1) {\n                     return -1;\n                 }\n-                else if (n == node2){\n+                else if (n == node2) {\n                     return 1;\n                 }\n             }\n-            return 0;       // Should not happen\n+            return 0; // Should not happen\n         }\n \n         Node current = node.getFirstChild();\n-        while (current != null){\n-            if (current == node1){\n+        while (current != null) {\n+            if (current == node1) {\n                 return -1;\n             }\n-            else if (current == node2){\n+            else if (current == node2) {\n                 return 1;\n             }\n             current = current.getNextSibling();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java,v 1.2 2002/04/24 04:05:40 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/24 04:05:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java,v 1.3 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for DOM elements.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:40 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DOMPointerFactory implements NodePointerFactory {\n \n     public static final int DOM_POINTER_FACTORY_ORDER = 100;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return DOM_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n-        if (bean instanceof Node){\n-            return new DOMNodePointer((Node)bean, locale);\n+    public NodePointer createNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale) \n+    {\n+        if (bean instanceof Node) {\n+            return new DOMNodePointer((Node) bean, locale);\n         }\n         return null;\n     }\n \n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n-        if (bean instanceof Node){\n-            return new DOMNodePointer(parent, (Node)bean);\n+    public NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n+    {\n+        if (bean instanceof Node) {\n+            return new DOMNodePointer(parent, (Node) bean);\n         }\n         return null;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.8 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.9 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class NamespacePointer extends NodePointer {\n     private String prefix;\n     private String namespaceURI;\n \n-    public NamespacePointer(NodePointer parent, String prefix){\n+    public NamespacePointer(NodePointer parent, String prefix) {\n         super(parent);\n         this.prefix = prefix;\n     }\n \n-    public NamespacePointer(NodePointer parent, String prefix, String namespaceURI){\n+    public NamespacePointer(\n+        NodePointer parent,\n+        String prefix,\n+        String namespaceURI) \n+    {\n         super(parent);\n         this.prefix = prefix;\n         this.namespaceURI = namespaceURI;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return new QName(getNamespaceURI(), prefix);\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return null;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n-    public String getNamespaceURI(){\n-        if (namespaceURI == null){\n+    public String getNamespaceURI() {\n+        if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         }\n         return namespaceURI;\n     }\n \n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n     }\n \n-    public boolean testNode(NodeTest nodeTest){\n-        return nodeTest == null ||\n-                ((nodeTest instanceof NodeTypeTest) &&\n-                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    public boolean testNode(NodeTest nodeTest) {\n+        return nodeTest == null\n+            || ((nodeTest instanceof NodeTypeTest)\n+                && ((NodeTypeTest) nodeTest).getNodeType()\n+                    == Compiler.NODE_TYPE_NODE);\n     }\n \n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n-            if (buffer.length() == 0 ||\n-                    buffer.charAt(buffer.length()-1) != '/'){\n+            if (buffer.length() == 0\n+                || buffer.charAt(buffer.length() - 1) != '/') {\n                 buffer.append('/');\n             }\n         }\n         return buffer.toString();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return prefix.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof NamespacePointer)){\n+        if (!(object instanceof NamespacePointer)) {\n             return false;\n         }\n \n-        NamespacePointer other = (NamespacePointer)object;\n+        NamespacePointer other = (NamespacePointer) object;\n         return prefix.equals(other.prefix);\n     }\n \n-    public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2){\n+    public int compareChildNodePointers(\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n+    {\n         // Won't happen - namespaces don't have children\n         return 0;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointer.java,v 1.3 2003/01/11 05:41:25 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:25 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DynaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:25 $\n  */\n public class DynaBeanPointer extends PropertyOwnerPointer {\n     private QName name;\n     private DynaBean dynaBean;\n \n-    public DynaBeanPointer(QName name, DynaBean dynaBean, Locale locale)\n-    {\n+    public DynaBeanPointer(QName name, DynaBean dynaBean, Locale locale) {\n         super(null, locale);\n         this.name = name;\n         this.dynaBean = dynaBean;\n         this.dynaBean = dynaBean;\n     }\n \n-    public PropertyPointer getPropertyPointer(){\n+    public PropertyPointer getPropertyPointer() {\n         return new DynaBeanPropertyPointer(this, dynaBean);\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return name;\n     }\n \n     /**\n      * Returns the bean itself\n      */\n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return dynaBean;\n     }\n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return dynaBean;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n     /**\n      * Returns 1.\n      */\n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }\n \n         return false;\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return name == null ? 0 : name.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof DynaBeanPointer)){\n+        if (!(object instanceof DynaBeanPointer)) {\n             return false;\n         }\n \n-        DynaBeanPointer other = (DynaBeanPointer)object;\n-        if (parent != other.parent){\n-            if (parent == null || !parent.equals(other.parent)){\n+        DynaBeanPointer other = (DynaBeanPointer) object;\n+        if (parent != other.parent) {\n+            if (parent == null || !parent.equals(other.parent)) {\n                 return false;\n             }\n         }\n \n-        if ((name == null && other.name != null) ||\n-                (name != null && !name.equals(other.name))){\n+        if ((name == null && other.name != null)\n+            || (name != null && !name.equals(other.name))) {\n             return false;\n         }\n \n-        int i_this = (index == WHOLE_COLLECTION ? 0 : index);\n-        int i_other = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n-        if (i_this != i_other){\n+        int iThis = (index == WHOLE_COLLECTION ? 0 : index);\n+        int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index);\n+        if (iThis != iOther) {\n             return false;\n         }\n \n     /**\n      * If there's a parent - parent's path, otherwise \"/\".\n      */\n-    public String asPath(){\n-        if (parent != null){\n+    public String asPath() {\n+        if (parent != null) {\n             return super.asPath();\n         }\n         return \"/\";\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPointerFactory.java,v 1.3 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * </a>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class DynaBeanPointerFactory implements NodePointerFactory {\n \n     public static final int DYNA_BEAN_POINTER_FACTORY_ORDER = 700;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return DYNA_BEAN_POINTER_FACTORY_ORDER;\n     }\n \n     public NodePointer createNodePointer(\n             QName name, Object bean, Locale locale)\n     {\n-        if (bean instanceof DynaBean){\n-            return new DynaBeanPointer(name, (DynaBean)bean, locale);\n+        if (bean instanceof DynaBean) {\n+            return new DynaBeanPointer(name, (DynaBean) bean, locale);\n         }\n         return null;\n     }\n     public NodePointer createNodePointer(\n             NodePointer parent, QName name, Object bean)\n     {\n-        if (bean instanceof DynaBean){\n-            return new DynaBeanPointer(parent, name, (DynaBean)bean);\n+        if (bean instanceof DynaBean) {\n+            return new DynaBeanPointer(parent, name, (DynaBean) bean);\n         }\n         return null;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.5 2002/11/28 01:02:05 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/11/28 01:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanPropertyPointer.java,v 1.6 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.beanutils.DynaBean;\n import org.apache.commons.beanutils.DynaClass;\n import org.apache.commons.beanutils.DynaProperty;\n-import org.apache.commons.jxpath.AbstractFactory;\n-import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n import org.apache.commons.jxpath.util.TypeUtils;\n  * Pointer pointing to a property of a DynaBean.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/11/28 01:02:05 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class DynaBeanPropertyPointer extends PropertyPointer {\n     private DynaBean dynaBean;\n     private String name;\n     private String[] names;\n \n-    public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean){\n+    public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) {\n         super(parent);\n         this.dynaBean = dynaBean;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return dynaBean.get(getPropertyName());\n     }\n \n     /**\n      * This type of node is auxiliary.\n      */\n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n     /**\n      * Number of the DP object's properties.\n      */\n-    public int getPropertyCount(){\n+    public int getPropertyCount() {\n         return getPropertyNames().length;\n     }\n \n      *\n      * @todo do something about the sorting\n      */\n-    public String[] getPropertyNames(){\n-        if (names == null){\n+    public String[] getPropertyNames() {\n+        if (names == null) {\n             DynaClass dynaClass = dynaBean.getDynaClass();\n             DynaProperty properties[] = dynaClass.getDynaProperties();\n             int count = properties.length;\n             boolean hasClass = dynaClass.getDynaProperty(\"class\") != null;\n-            if (hasClass){\n-                count --;       // Exclude \"class\" from properties\n+            if (hasClass) {\n+                count--;       // Exclude \"class\" from properties\n             }\n             names = new String[count];\n-            for (int i = 0, j = 0; i < properties.length; i++){\n+            for (int i = 0, j = 0; i < properties.length; i++) {\n                 String name = properties[i].getName();\n-                if (!hasClass || !name.equals(\"class\")){\n+                if (!hasClass || !name.equals(\"class\")) {\n                     names[j++] = name;\n                 }\n             }\n      * Returns the name of the currently selected property or \"*\"\n      * if none has been selected.\n      */\n-    public String getPropertyName(){\n-        if (name == null){\n+    public String getPropertyName() {\n+        if (name == null) {\n             String names[] = getPropertyNames();\n-            if (propertyIndex >=0 && propertyIndex < names.length){\n+            if (propertyIndex >= 0 && propertyIndex < names.length) {\n                 name = names[propertyIndex];\n             }\n             else {\n     /**\n      * Select a property by name.\n      */\n-    public void setPropertyName(String propertyName){\n+    public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n         this.name = propertyName;\n     }\n      * Index of the currently selected property in the list of all\n      * properties sorted alphabetically.\n      */\n-    public int getPropertyIndex(){\n-        if (propertyIndex == UNSPECIFIED_PROPERTY){\n+    public int getPropertyIndex() {\n+        if (propertyIndex == UNSPECIFIED_PROPERTY) {\n             String names[] = getPropertyNames();\n-            for (int i = 0; i < names.length; i++){\n-                if (names[i].equals(name)){\n+            for (int i = 0; i < names.length; i++) {\n+                if (names[i].equals(name)) {\n                     setPropertyIndex(i);\n                     break;\n                 }\n      * Index a property by its index in the list of all\n      * properties sorted alphabetically.\n      */\n-    public void setPropertyIndex(int index){\n-        if (propertyIndex != index){\n+    public void setPropertyIndex(int index) {\n+        if (propertyIndex != index) {\n             super.setPropertyIndex(index);\n             name = null;\n         }\n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         String name = getPropertyName();\n-        if (name.equals(\"*\")){\n+        if (name.equals(\"*\")) {\n             return null;\n         }\n \n         Object value;\n-        if (index == WHOLE_COLLECTION){\n+        if (index == WHOLE_COLLECTION) {\n             value = dynaBean.get(name);\n         }\n-        else if (isIndexedProperty()){\n+        else if (isIndexedProperty()) {\n             // DynaClass at this point is not based on whether\n             // the property is indeed indexed, but rather on\n             // whether it is an array or List. Therefore\n             try {\n                 value = dynaBean.get(name, index);\n             }\n-            catch (ArrayIndexOutOfBoundsException ex){\n+            catch (ArrayIndexOutOfBoundsException ex) {\n                 value = null;\n             }\n-            catch (IllegalArgumentException ex){\n+            catch (IllegalArgumentException ex) {\n                 value = dynaBean.get(name);\n                 value = ValueUtils.getValue(value, index);\n             }\n         }\n         else {\n             value = dynaBean.get(name);\n-            if (ValueUtils.isCollection(value)){\n+            if (ValueUtils.isCollection(value)) {\n                 value = ValueUtils.getValue(value, index);\n             }\n-            else if (index != 0){\n+            else if (index != 0) {\n                 value = null;\n             }\n         }\n     /**\n      * Returns true if the bean has the currently selected property\n      */\n-    protected boolean isActualProperty(){\n+    protected boolean isActualProperty() {\n         DynaClass dynaClass = dynaBean.getDynaClass();\n         return dynaClass.getDynaProperty(getPropertyName()) != null;\n     }\n \n-    protected boolean isIndexedProperty(){\n+    protected boolean isIndexedProperty() {\n         DynaClass dynaClass = dynaBean.getDynaClass();\n         DynaProperty property = dynaClass.getDynaProperty(name);\n         return property.isIndexed();\n      * change the value of the index'th element of the collection\n      * represented by the property.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         setValue(index, value);\n     }\n \n-    public NodePointer createPath(JXPathContext context, Object value){\n-        return createChild(context, getName(), index, value);\n-    }\n-\n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index, Object value)\n-    {\n-        // Ignore the name passed to us, use our own data\n-        if (index == WHOLE_COLLECTION) {\n-            setValue(index, value);\n-        }\n-        else if (isIndexedProperty()) {\n-            dynaBean.set(getPropertyName(), index, convert(value, true));\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (collection == null) {\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory\n-                    .createObject(\n-                        context,\n-                        this,\n-                        getBean(),\n-                        getPropertyName(),\n-                        0)) {\n-                    throw new JXPathException(\n-                        \"Factory could not create an object for path: \"\n-                            + asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0) {\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()) {\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                dynaBean.set(getPropertyName(), collection);\n-            }\n-\n-            ValueUtils.setValue(collection, index, value);\n-        }\n-        NodePointer ptr = (NodePointer) clone();\n-        ptr.setIndex(index);\n-        return ptr;\n-    }\n-\n-    public NodePointer createChild(JXPathContext context,\n-            QName name, int index)\n-    {\n-        if (isIndexedProperty()) {\n-            AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory\n-                .createObject(\n-                    context,\n-                    this,\n-                    dynaBean,\n-                    getPropertyName(),\n-                    index)) {\n-                throw new JXPathException(\n-                    \"Factory could not create an object for path: \" + asPath());\n-            }\n-        }\n-        else {\n-            // Ignore the name passed to us, use our own data\n-            Object collection = getBaseValue();\n-            if (collection == null) {\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory\n-                    .createObject(\n-                        context,\n-                        this,\n-                        dynaBean,\n-                        getPropertyName(),\n-                        index)) {\n-                    throw new JXPathException(\n-                        \"Factory could not create an object for path: \"\n-                            + asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0) {\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()) {\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                dynaBean.set(getPropertyName(), collection);\n-            }\n-        }\n-\n-        DynaBeanPropertyPointer pointer =\n-            (DynaBeanPropertyPointer) this.clone();\n-        pointer.setIndex(index);\n-        return pointer;\n-    }\n-\n-    public NodePointer createPath(JXPathContext context){\n-        if (getNode() == null) {\n-            AbstractFactory factory = getAbstractFactory(context);\n-            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory\n-                .createObject(\n-                    context,\n-                    this,\n-                    dynaBean,\n-                    getPropertyName(),\n-                    inx)) {\n-                throw new JXPathException(\n-                    \"Factory could not create an object for path: \" + asPath());\n-            }\n-        }\n-        return this;\n-    }\n-\n-    public void remove(){\n+    public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             dynaBean.set(getPropertyName(), null);\n         }\n         }\n     }\n \n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n-        AbstractFactory factory = context.getFactory();\n-        if (factory == null) {\n-            throw new JXPathException(\n-                \"Factory is not set on the JXPathContext - cannot create path: \"\n-                    + asPath());\n-        }\n-        return factory;\n-    }\n-\n-    private void setValue(int index, Object value){\n-        if (index == WHOLE_COLLECTION){\n+    private void setValue(int index, Object value) {\n+        if (index == WHOLE_COLLECTION) {\n             dynaBean.set(getPropertyName(), convert(value, false));\n         }\n-        else if (isIndexedProperty()){\n+        else if (isIndexedProperty()) {\n             dynaBean.set(getPropertyName(), index, convert(value, true));\n         }\n         else {\n    }\n \n \n-    private Object convert(Object value, boolean element){\n+    private Object convert(Object value, boolean element) {\n         DynaClass dynaClass = (DynaClass) dynaBean.getDynaClass();\n         DynaProperty property = dynaClass.getDynaProperty(getPropertyName());\n         Class type = property.getType();\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicAttributeIterator.java\n  * will always find that property (albeit with a null value).\n  *  \n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n- * @version $Id: DynamicAttributeIterator.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * @version $Id: DynamicAttributeIterator.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n  */\n public class DynamicAttributeIterator extends BeanAttributeIterator {\n \n         super(parent, name);\n     }\n \n-     protected void prepareForIndividualProperty(String name){\n-         ((DynamicPropertyPointer)getPropertyPointer()).setPropertyName(name);\n+     protected void prepareForIndividualProperty(String name) {\n+         ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);\n          super.prepareForIndividualProperty(name);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/28 01:01:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n \n /**\n- * A Pointer that points to an object with Dynamic Properties. It is used\n- * for the first element of a path; following elements will by of type PropertyPointer.\n+ * A  Pointer that points to an object with Dynamic Properties. It is used for\n+ * the first element of a path; following elements will by of type\n+ * PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class DynamicPointer extends PropertyOwnerPointer {\n     private QName name;\n         this.handler = handler;\n     }\n \n-    public PropertyPointer getPropertyPointer(){\n+    public PropertyPointer getPropertyPointer() {\n         return new DynamicPropertyPointer(this, handler);\n     }\n \n         return new DynamicPropertyIterator(this, property, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return new DynamicAttributeIterator(this, name);\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return name;\n     }\n \n     /**\n      * Returns the DP object iself.\n      */\n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return bean;\n     }\n     \n             || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n     }    \n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n     /**\n      * Returns 1.\n      */\n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }\n \n-    public String asPath(){\n-        if (parent != null){\n+    public String asPath() {\n+        if (parent != null) {\n             return super.asPath();\n         }\n         return \"/\";\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(bean) + name.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof DynamicPointer)){\n+        if (!(object instanceof DynamicPointer)) {\n             return false;\n         }\n \n-        DynamicPointer other = (DynamicPointer)object;\n+        DynamicPointer other = (DynamicPointer) object;\n         return bean == other.bean && name.equals(other.name);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/28 01:01:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointerFactory.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for Dynamic classes like Map.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class DynamicPointerFactory implements NodePointerFactory {\n \n     public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return DYNAMIC_POINTER_FACTORY_ORDER;\n     }\n \n-    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+    public NodePointer createNodePointer(\n+        QName name,\n+        Object bean,\n+        Locale locale) \n+    {\n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n-        if (bi.isDynamic()){\n-            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+        if (bi.isDynamic()) {\n+            DynamicPropertyHandler handler =\n+                ValueUtils.getDynamicPropertyHandler(\n+                    bi.getDynamicPropertyHandlerClass());\n             return new DynamicPointer(name, bean, handler, locale);\n         }\n         return null;\n     }\n \n-    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n-        if (bean == null){\n+    public NodePointer createNodePointer(\n+        NodePointer parent,\n+        QName name,\n+        Object bean) \n+    {\n+        if (bean == null) {\n             return new NullPointer(parent, name);\n         }\n \n         JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n-        if (bi.isDynamic()){\n-            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+        if (bi.isDynamic()) {\n+            DynamicPropertyHandler handler =\n+                ValueUtils.getDynamicPropertyHandler(\n+                    bi.getDynamicPropertyHandlerClass());\n             return new DynamicPointer(parent, name, bean, handler);\n         }\n         return null;\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n  * will always find that property (albeit with a null value).\n  * \n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n- * @version $Id: DynamicPropertyIterator.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n+ * @version $Id: DynamicPropertyIterator.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n  */\n public class DynamicPropertyIterator extends PropertyIterator {\n \n         super(pointer, name, reverse, startWith);\n     }\n \n-    protected void prepareForIndividualProperty(String name){\n-        ((DynamicPropertyPointer)getPropertyPointer()).setPropertyName(name);\n+    protected void prepareForIndividualProperty(String name) {\n+        ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);\n         super.prepareForIndividualProperty(name);\n    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/28 01:01:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyPointer.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.Arrays;\n \n-import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.DynamicPropertyHandler;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n import org.apache.commons.jxpath.util.ValueUtils;\n  * Pointer pointing to a property of an object with dynamic properties.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class DynamicPropertyPointer extends PropertyPointer {\n     private DynamicPropertyHandler handler;\n     /**\n      * This type of node is auxiliary.\n      */\n-    public boolean isContainer(){\n+    public boolean isContainer() {\n         return true;\n     }\n \n     /**\n      * Number of the DP object's properties.\n      */\n-    public int getPropertyCount(){\n+    public int getPropertyCount() {\n         return getPropertyNames().length;\n     }\n \n     /**\n      * Names of all properties, sorted alphabetically\n      */\n-    public String[] getPropertyNames(){\n-        if (names == null){\n+    public String[] getPropertyNames() {\n+        if (names == null) {\n             String allNames[] = handler.getPropertyNames(getBean());\n             names = new String[allNames.length];\n-            for (int i = 0; i < names.length; i++){\n+            for (int i = 0; i < names.length; i++) {\n                 names[i] = allNames[i];\n             }\n             Arrays.sort(names);\n-            if (requiredPropertyName != null){\n+            if (requiredPropertyName != null) {\n                 int inx = Arrays.binarySearch(names, requiredPropertyName);\n-                if (inx < 0){\n+                if (inx < 0) {\n                     allNames = names;\n                     names = new String[allNames.length + 1];\n                     names[0] = requiredPropertyName;\n      * Returns the name of the currently selected property or \"*\"\n      * if none has been selected.\n      */\n-    public String getPropertyName(){\n-        if (name == null){\n+    public String getPropertyName() {\n+        if (name == null) {\n             String names[] = getPropertyNames();\n-            if (propertyIndex >=0 && propertyIndex < names.length){\n+            if (propertyIndex >= 0 && propertyIndex < names.length) {\n                 name = names[propertyIndex];\n             }\n             else {\n      * set the property value though. In order to set the property\n      * value, call setValue().\n      */\n-    public void setPropertyName(String propertyName){\n+    public void setPropertyName(String propertyName) {\n         setPropertyIndex(UNSPECIFIED_PROPERTY);\n         this.name = propertyName;\n         requiredPropertyName = propertyName;\n-        if (names != null && Arrays.binarySearch(names, propertyName) < 0){\n+        if (names != null && Arrays.binarySearch(names, propertyName) < 0) {\n             names = null;\n         }\n     }\n      * Index of the currently selected property in the list of all\n      * properties sorted alphabetically.\n      */\n-    public int getPropertyIndex(){\n-        if (propertyIndex == UNSPECIFIED_PROPERTY){\n+    public int getPropertyIndex() {\n+        if (propertyIndex == UNSPECIFIED_PROPERTY) {\n             String names[] = getPropertyNames();\n-            for (int i = 0; i < names.length; i++){\n-                if (names[i].equals(name)){\n+            for (int i = 0; i < names.length; i++) {\n+                if (names[i].equals(name)) {\n                     setPropertyIndex(i);\n                     break;\n                 }\n      * Index a property by its index in the list of all\n      * properties sorted alphabetically.\n      */\n-    public void setPropertyIndex(int index){\n-        if (propertyIndex != index){\n+    public void setPropertyIndex(int index) {\n+        if (propertyIndex != index) {\n             super.setPropertyIndex(index);\n             name = null;\n         }\n      * Returns the value of the property, not an element of the collection\n      * represented by the property, if any.\n      */\n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return handler.getProperty(getBean(), getPropertyName());\n     }\n \n      * property. If the property is not a collection, index should be zero\n      * and the value will be the property itself.\n      */\n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         Object value;\n         if (index == WHOLE_COLLECTION) {\n             value = handler.getProperty(getBean(), getPropertyName());\n      * A dynamic property is always considered actual - all keys are apparently\n      * existing with possibly the value of null.\n      */\n-    protected boolean isActualProperty(){\n+    protected boolean isActualProperty() {\n         return true;\n     }\n \n      * change the value of the index'th element of the collection\n      * represented by the property.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         if (index == WHOLE_COLLECTION) {\n             handler.setProperty(getBean(), getPropertyName(), value);\n         }\n         }\n     }\n \n-    public NodePointer createPath(JXPathContext context, Object value){\n-        return createChild(context, getName(), index, value);\n-    }\n-\n-    public NodePointer createChild(JXPathContext context, QName name, int index, Object value){\n-        // Ignore the name passed to us, use our own data\n-        if (index == WHOLE_COLLECTION) {\n-            handler.setProperty(getBean(), getPropertyName(), value);\n-        }\n-        else {\n-            Object collection = getBaseValue();\n-            if (collection == null) {\n-                AbstractFactory factory = getAbstractFactory(context);\n-                if (!factory\n-                    .createObject(\n-                        context,\n-                        this,\n-                        getBean(),\n-                        getPropertyName(),\n-                        0)) {\n-                    throw new JXPathException(\n-                        \"Factory could not create an object for path: \"\n-                            + asPath());\n-                }\n-                collection = getBaseValue();\n-            }\n-\n-            if (index < 0) {\n-                throw new JXPathException(\"Index is less than 1: \" + asPath());\n-            }\n-\n-            if (index >= getLength()) {\n-                collection = ValueUtils.expandCollection(collection, index + 1);\n-                handler.setProperty(getBean(), getPropertyName(), collection);\n-            }\n-\n-            ValueUtils.setValue(collection, index, value);\n-        }\n-        NodePointer ptr = (NodePointer) clone();\n-        ptr.setIndex(index);\n-        return ptr;\n-    }\n-\n-    public NodePointer createChild(JXPathContext context, QName name, int index){\n+    public NodePointer createPath(JXPathContext context) {\n         // Ignore the name passed to us, use our own data\n         Object collection = getBaseValue();\n         if (collection == null) {\n             AbstractFactory factory = getAbstractFactory(context);\n-            if (!factory\n-                .createObject(context, this, getBean(), getPropertyName(), 0)) {\n-                throw new JXPathException(\n-                    \"Factory could not create an object for path: \" + asPath());\n-            }\n-            collection = getBaseValue();\n-        }\n-\n-        if (index < 0) {\n-            throw new JXPathException(\"Index is less than 1: \" + asPath());\n-        }\n-\n-        if (index >= getLength()) {\n-            collection = ValueUtils.expandCollection(collection, index + 1);\n-            handler.setProperty(getBean(), getPropertyName(), collection);\n-        }\n-\n-        DynamicPropertyPointer pointer = (DynamicPropertyPointer) this.clone();\n-        pointer.setIndex(index);\n-        return pointer;\n-    }\n-\n-    public NodePointer createPath(JXPathContext context){\n-        if (getNode() == null) {\n-            AbstractFactory factory = getAbstractFactory(context);\n-            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n-            if (!factory\n-                .createObject(\n+            boolean success =\n+                factory.createObject(\n                     context,\n                     this,\n                     getBean(),\n                     getPropertyName(),\n-                    inx)) {\n+                    0);\n+            if (!success) {\n                 throw new JXPathException(\n                     \"Factory could not create an object for path: \" + asPath());\n             }\n-        }\n+            collection = getBaseValue();\n+        }\n+\n+        if (index != WHOLE_COLLECTION) {\n+            if (index < 0) {\n+                throw new JXPathException(\"Index is less than 1: \" + asPath());\n+            }\n+    \n+            if (index >= getLength()) {\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                handler.setProperty(getBean(), getPropertyName(), collection);\n+            }\n+        }\n+        \n         return this;\n     }\n-\n-    public void remove(){\n+    \n+    public NodePointer createPath(JXPathContext context, Object value) {\n+        if (index == WHOLE_COLLECTION) {\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            createPath(context);\n+            ValueUtils.setValue(getBaseValue(), index, value);\n+        }\n+        return this;\n+    }\n+\n+    public void remove() {\n         if (index == WHOLE_COLLECTION) {\n             handler.setProperty(getBean(), getPropertyName(), null);\n         }\n         }\n     }\n \n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n         buffer.append(getParent().asPath());\n         if (buffer.length() == 0) {\n         return buffer.toString();\n     }\n \n-    private String escape(String string){\n+    private String escape(String string) {\n         int index = string.indexOf('\\'');\n-        while (index != -1){\n-            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&apos;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n-        while (index != -1){\n-            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&quot;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n         return string;\n     }\n \n-    private AbstractFactory getAbstractFactory(JXPathContext context){\n+    private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n-        if (factory == null){\n-            throw new JXPathException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        if (factory == null) {\n+            throw new JXPathException(\n+                \"Factory is not set on the JXPathContext - cannot create path: \"\n+                    + asPath());\n         }\n         return factory;\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:29:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n-import org.jdom.*;\n+import org.jdom.Attribute;\n+import org.jdom.Element;\n+import org.jdom.Namespace;\n \n /**\n  * An iterator of attributes of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMAttributeIterator implements NodeIterator {\n     private NodePointer parent;\n     private List attributes;\n     private int position = 0;\n \n-    public JDOMAttributeIterator(NodePointer parent, QName name){\n+    public JDOMAttributeIterator(NodePointer parent, QName name) {\n         this.parent = parent;\n         this.name = name;\n-        if (parent.getNode() instanceof Element){\n-            Element element = (Element)parent.getNode();\n+        if (parent.getNode() instanceof Element) {\n+            Element element = (Element) parent.getNode();\n //            System.err.println(\"ELEMENT: \" + element.getName());\n //            List a = element.getAttributes();\n-//            for (int i = 0; i < a.size(); i++){\n+//            for (int i = 0; i < a.size(); i++) {\n //                Attribute x = (Attribute)a.get(i);\n-//                System.err.println(\"ATTR: \" + x.getName() + \" \" + x.getNamespace());\n+//                System.err.println(\"ATTR: \" + x.getName() + \" \" + \n+//                              x.getNamespace());\n //            }\n             String prefix = name.getPrefix();\n             Namespace ns;\n-            if (prefix != null){\n-                if (prefix.equals(\"xml\")){\n+            if (prefix != null) {\n+                if (prefix.equals(\"xml\")) {\n                     ns = Namespace.XML_NAMESPACE;\n                 }\n                 else {\n                     ns = element.getNamespace(prefix);\n-                    if (ns == null){\n+                    if (ns == null) {\n                         // TBD: no attributes\n                         attributes = Collections.EMPTY_LIST;\n                         return;\n             }\n \n             String lname = name.getName();\n-            if (!lname.equals(\"*\")){\n+            if (!lname.equals(\"*\")) {\n                 attributes = new ArrayList();\n-                if (ns != null){\n+                if (ns != null) {\n                     Attribute attr = element.getAttribute(lname, ns);\n-//                    System.err.println(\"LNAME=\" + lname + \"  NS: \" + ns + \" ATTR: \" + attr);\n-                    if (attr != null){\n+//  System.err.println(\"LNAME=\" + lname + \"  NS: \" + ns + \" ATTR: \" + attr);\n+                    if (attr != null) {\n                         attributes.add(attr);\n                     }\n                 }\n             else {\n                 attributes = new ArrayList();\n                 List allAttributes = element.getAttributes();\n-                for (int i = 0; i < allAttributes.size(); i++){\n-                    Attribute attr = (Attribute)allAttributes.get(i);\n-                    if (attr.getNamespace().equals(ns)){\n+                for (int i = 0; i < allAttributes.size(); i++) {\n+                    Attribute attr = (Attribute) allAttributes.get(i);\n+                    if (attr.getNamespace().equals(ns)) {\n                         attributes.add(attr);\n                     }\n                 }\n     }\n \n     /*\n-    private boolean testAttr(Attr attr, QName testName){\n+    private boolean testAttr(Attr attr, QName testName) {\n         String nodePrefix = DOMNodePointer.getPrefix(attr);\n         String nodeLocalName = DOMNodePointer.getLocalName(attr);\n \n-        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")){\n-            return false;\n-        }\n-\n-        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")){\n+        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n+            return false;\n+        }\n+\n+        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n             return false;\n         }\n \n         String testLocalName = name.getName();\n-        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)){\n+        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n             String testPrefix = testName.getPrefix();\n \n-            if (equalStrings(testPrefix, nodePrefix)){\n+            if (equalStrings(testPrefix, nodePrefix)) {\n                 return true;\n             }\n \n             String testNS = null;\n-            if (testPrefix != null){\n+            if (testPrefix != null) {\n                 testNS = parent.getNamespaceURI(testPrefix);\n             }\n \n             String nodeNS = null;\n-            if (nodePrefix != null){\n+            if (nodePrefix != null) {\n                 nodeNS = parent.getNamespaceURI(nodePrefix);\n             }\n             return equalStrings(testNS, nodeNS);\n         return false;\n     }\n \n-    private static boolean equalStrings(String s1, String s2){\n-        if (s1 == null && s2 != null){\n-            return false;\n-        }\n-        if (s1 != null && !s1.equals(s2)){\n+    private static boolean equalStrings(String s1, String s2) {\n+        if (s1 == null && s2 != null) {\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)) {\n             return false;\n         }\n         return true;\n     }\n \n-    private Attr getAttribute(Element element, QName name){\n+    private Attr getAttribute(Element element, QName name) {\n         String testPrefix = name.getPrefix();\n         String testNS = null;\n \n-        if (testPrefix != null){\n+        if (testPrefix != null) {\n             testNS = parent.getNamespaceURI(testPrefix);\n         }\n \n-        if (testNS != null){\n+        if (testNS != null) {\n             Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n-            if (attr == null){\n+            if (attr == null) {\n                 // This may mean that the parser does not support NS for\n                 // attributes, example - the version of Crimson bundled\n                 // with JDK 1.4.0\n                 NamedNodeMap nnm = element.getAttributes();\n-                for (int i = 0; i < nnm.getLength(); i++){\n+                for (int i = 0; i < nnm.getLength(); i++) {\n                     attr = (Attr)nnm.item(i);\n-                    if (testAttr(attr, name)){\n+                    if (testAttr(attr, name)) {\n                         return attr;\n                     }\n                 }\n         }\n     }\n */\n-    public NodePointer getNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         }\n         int index = position - 1;\n-        if (index < 0){\n+        if (index < 0) {\n             index = 0;\n         }\n-        return new JDOMAttributePointer(parent, (Attribute)attributes.get(index));\n-    }\n-\n-    public int getPosition(){\n+        return new JDOMAttributePointer(\n+            parent,\n+            (Attribute) attributes.get(index));\n+    }\n+\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n-        if (attributes == null){\n+    public boolean setPosition(int position) {\n+        if (attributes == null) {\n             return false;\n         }\n         this.position = position;\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.4 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributePointer.java,v 1.5 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMAttributePointer extends NodePointer {\n     private Attribute attr;\n \n-    public JDOMAttributePointer(NodePointer parent, Attribute attr){\n+    public JDOMAttributePointer(NodePointer parent, Attribute attr) {\n         super(parent);\n         this.attr = attr;\n     }\n             JDOMNodePointer.getLocalName(attr));\n     }\n \n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return new QName(getNamespaceURI(),  attr.getName());\n     }\n \n-    public String getNamespaceURI(){\n+    public String getNamespaceURI() {\n         String uri = attr.getNamespaceURI();\n-        if (uri != null && uri.equals(\"\")){\n+        if (uri != null && uri.equals(\"\")) {\n             uri = null;\n         }\n         return uri;\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return attr;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         String value = attr.getValue();\n-        if (value == null){\n+        if (value == null) {\n             return null;\n         }\n         return value;\n     }\n \n-    public boolean isActual(){\n+    public boolean isActual() {\n         return true;\n     }\n \n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Sets the value of this attribute.\n      */\n-    public void setValue(Object value){\n-        attr.setValue((String)TypeUtils.convert(value, String.class));\n+    public void setValue(Object value) {\n+        attr.setValue((String) TypeUtils.convert(value, String.class));\n     }\n \n-    public void remove(){\n+    public void remove() {\n         attr.getParent().removeAttribute(attr);\n     }\n \n     /**\n      */\n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n-            if (buffer.length() == 0 ||\n-                    buffer.charAt(buffer.length()-1) != '/'){\n+            if (buffer.length() == 0\n+                || buffer.charAt(buffer.length() - 1) != '/') {\n                 buffer.append('/');\n             }\n         }\n         return buffer.toString();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(attr);\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof JDOMAttributePointer)){\n+        if (!(object instanceof JDOMAttributePointer)) {\n             return false;\n         }\n \n-        JDOMAttributePointer other = (JDOMAttributePointer)object;\n+        JDOMAttributePointer other = (JDOMAttributePointer) object;\n         return attr == other.attr;\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespaceIterator.java,v 1.3 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.model.jdom;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n  * An iterator of namespaces of a DOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMNamespaceIterator implements NodeIterator {\n     private NodePointer parent;\n     private Set prefixes;\n     private int position = 0;\n \n-    public JDOMNamespaceIterator(NodePointer parent){\n+    public JDOMNamespaceIterator(NodePointer parent) {\n         this.parent = parent;\n         Object node = parent.getNode();\n-        if (node instanceof Element){\n+        if (node instanceof Element) {\n             namespaces = new ArrayList();\n             prefixes = new HashSet();\n-            collectNamespaces((Element)parent.getNode());\n+            collectNamespaces((Element) parent.getNode());\n         }\n     }\n \n-    private void collectNamespaces(Element element){\n+    private void collectNamespaces(Element element) {\n         Namespace ns = element.getNamespace();\n-        if (ns != null && !prefixes.contains(ns.getPrefix())){\n+        if (ns != null && !prefixes.contains(ns.getPrefix())) {\n             namespaces.add(ns);\n             prefixes.add(ns.getPrefix());\n         }\n         List others = element.getAdditionalNamespaces();\n-        for (int i = 0; i < others.size(); i++){\n-            ns = (Namespace)others.get(i);\n-            if (ns != null && !prefixes.contains(ns.getPrefix())){\n+        for (int i = 0; i < others.size(); i++) {\n+            ns = (Namespace) others.get(i);\n+            if (ns != null && !prefixes.contains(ns.getPrefix())) {\n                 namespaces.add(ns);\n                 prefixes.add(ns.getPrefix());\n             }\n         }\n         Element parent = element.getParent();\n-        if (parent != null){\n+        if (parent != null) {\n             collectNamespaces(parent);\n         }\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (position == 0){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (position == 0) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         }\n         int index = position - 1;\n-        if (index < 0){\n+        if (index < 0) {\n             index = 0;\n         }\n-        Namespace ns = (Namespace)namespaces.get(index);\n+        Namespace ns = (Namespace) namespaces.get(index);\n         return new JDOMNamespacePointer(parent, ns.getPrefix(), ns.getURI());\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n+    public boolean setPosition(int position) {\n         this.position = position;\n         return position >= 1 && position <= namespaces.size();\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.4 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNamespacePointer.java,v 1.5 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Represents a namespace node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMNamespacePointer extends NodePointer {\n     private String prefix;\n     private String namespaceURI;\n \n-    public JDOMNamespacePointer(NodePointer parent, String prefix){\n+    public JDOMNamespacePointer(NodePointer parent, String prefix) {\n         super(parent);\n         this.prefix = prefix;\n     }\n         this.namespaceURI = namespaceURI;\n     }\n \n-    public QName getName(){\n+    public QName getName() {\n         return new QName(getNamespaceURI(), prefix);\n     }\n \n-    public Object getBaseValue(){\n+    public Object getBaseValue() {\n         return null;\n     }\n     \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public Object getImmediateNode(){\n+    public Object getImmediateNode() {\n         return getNamespaceURI();\n     }\n \n-    public String getNamespaceURI(){\n-        if (namespaceURI == null){\n+    public String getNamespaceURI() {\n+        if (namespaceURI == null) {\n             namespaceURI = parent.getNamespaceURI(prefix);\n         }\n         return namespaceURI;\n     }\n \n-    public boolean isLeaf(){\n+    public boolean isLeaf() {\n         return true;\n     }\n \n     /**\n      * Throws UnsupportedOperationException.\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         throw new UnsupportedOperationException(\"Cannot modify a namespace\");\n     }\n \n-    public String asPath(){\n+    public String asPath() {\n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n-            if (buffer.length() == 0 ||\n-                    buffer.charAt(buffer.length()-1) != '/'){\n+            if (buffer.length() == 0\n+                || buffer.charAt(buffer.length() - 1) != '/') {\n                 buffer.append('/');\n             }\n         }\n         return buffer.toString();\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return prefix.hashCode();\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof JDOMNamespacePointer)){\n+        if (!(object instanceof JDOMNamespacePointer)) {\n             return false;\n         }\n \n-        JDOMNamespacePointer other = (JDOMNamespacePointer)object;\n+        JDOMNamespacePointer other = (JDOMNamespacePointer) object;\n         return prefix.equals(other.prefix);\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java,v 1.2 2002/10/20 03:47:18 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/10/20 03:47:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodeIterator.java,v 1.3 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An iterator of children of a JDOM Node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/10/20 03:47:18 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMNodeIterator implements NodeIterator {\n     private NodePointer parent;\n             boolean reverse, NodePointer startWith)\n     {\n         this.parent = parent;\n-        if (startWith != null){\n+        if (startWith != null) {\n             this.child = startWith.getNode();\n         }\n         // TBD: optimize me for different node tests\n         Object node = parent.getNode();\n-        if (node instanceof Document){\n-            this.children = ((Document)node).getContent();\n-        }\n-        else if (node instanceof Element){\n-            this.children = ((Element)node).getContent();\n+        if (node instanceof Document) {\n+            this.children = ((Document) node).getContent();\n+        }\n+        else if (node instanceof Element) {\n+            this.children = ((Element) node).getContent();\n         }\n         else {\n             this.children = Collections.EMPTY_LIST;\n         this.reverse = reverse;\n     }\n \n-    public NodePointer getNodePointer(){\n-        if (child == null){\n-            if (!setPosition(1)){\n+    public NodePointer getNodePointer() {\n+        if (child == null) {\n+            if (!setPosition(1)) {\n                 return null;\n             }\n             position = 0;\n         return new JDOMNodePointer(parent, child);\n     }\n \n-    public int getPosition(){\n+    public int getPosition() {\n         return position;\n     }\n \n-    public boolean setPosition(int position){\n-        while (this.position < position){\n-            if (!next()){\n+    public boolean setPosition(int position) {\n+        while (this.position < position) {\n+            if (!next()) {\n                 return false;\n             }\n         }\n-        while (this.position > position){\n-            if (!previous()){\n+        while (this.position > position) {\n+            if (!previous()) {\n                 return false;\n             }\n         }\n      * So, this is implemented only for completeness and perhaps for\n      * those who use these iterators outside of XPath evaluation.\n      */\n-    private boolean previous(){\n+    private boolean previous() {\n         position--;\n-        if (!reverse){\n-            while (--index >= 0){\n-                child = children.get(index);\n-                if (testChild()){\n+        if (!reverse) {\n+            while (--index >= 0) {\n+                child = children.get(index);\n+                if (testChild()) {\n                     return true;\n                 }\n             }\n         }\n         else {\n-            for (;index < children.size(); index++){\n-                child = children.get(index);\n-                if (testChild()){\n+            for (; index < children.size(); index++) {\n+                child = children.get(index);\n+                if (testChild()) {\n                     return true;\n                 }\n             }\n         return false;\n     }\n \n-    private boolean next(){\n+    private boolean next() {\n         position++;\n-        if (!reverse){\n-            if (position == 1){\n+        if (!reverse) {\n+            if (position == 1) {\n                 index = 0;\n-                if (child != null){\n+                if (child != null) {\n                     index = children.indexOf(child) + 1;\n                 }\n             }\n             else {\n                 index++;\n             }\n-            for (;index < children.size(); index++){\n-                child = children.get(index);\n-                if (testChild()){\n+            for (; index < children.size(); index++) {\n+                child = children.get(index);\n+                if (testChild()) {\n                     return true;\n                 }\n             }\n             return false;\n         }\n         else {\n-            if (position == 1){\n+            if (position == 1) {\n                 index = children.size() - 1;\n-                if (child != null){\n+                if (child != null) {\n                     index = children.indexOf(child) - 1;\n                 }\n             }\n             else {\n                 index--;\n             }\n-            for (;index >= 0; index--){\n-                child = children.get(index);\n-                if (testChild()){\n+            for (; index >= 0; index--) {\n+                child = children.get(index);\n+                if (testChild()) {\n                     return true;\n                 }\n             }\n         }\n     }\n \n-    private boolean testChild(){\n+    private boolean testChild() {\n         return JDOMNodePointer.testNode(parent, child, nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.6 2002/11/29 06:44:16 dmitri Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/11/29 06:44:16 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,v 1.7 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.JXPathException;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.QName;\n-import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\n+import org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n import org.apache.commons.jxpath.util.TypeUtils;\n-import org.jdom.*;\n+import org.jdom.Attribute;\n+import org.jdom.CDATA;\n+import org.jdom.Comment;\n+import org.jdom.Document;\n+import org.jdom.Element;\n+import org.jdom.Namespace;\n+import org.jdom.ProcessingInstruction;\n+import org.jdom.Text;\n \n /**\n  * A Pointer that points to a DOM node.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2002/11/29 06:44:16 $\n+ * @version $Revision: 1.7 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMNodePointer extends NodePointer {\n     private Object node;\n     public static final String XMLNS_NAMESPACE_URI =\n             \"http://www.w3.org/2000/xmlns/\";\n \n-    public JDOMNodePointer(Object node, Locale locale){\n+    public JDOMNodePointer(Object node, Locale locale) {\n         super(null, locale);\n         this.node = node;\n     }\n \n-    public JDOMNodePointer(Object node, Locale locale, String id){\n+    public JDOMNodePointer(Object node, Locale locale, String id) {\n         super(null, locale);\n         this.node = node;\n         this.id = id;\n     }\n \n-    public JDOMNodePointer(NodePointer parent, Object node){\n+    public JDOMNodePointer(NodePointer parent, Object node) {\n         super(parent);\n         this.node = node;\n     }\n \n-    public NodeIterator childIterator(NodeTest test, boolean reverse,\n-                    NodePointer startWith) {\n+    public NodeIterator childIterator(\n+        NodeTest test,\n+        boolean reverse,\n+        NodePointer startWith) \n+    {\n         return new JDOMNodeIterator(this, test, reverse, startWith);\n     }\n \n-    public NodeIterator attributeIterator(QName name){\n+    public NodeIterator attributeIterator(QName name) {\n         return new JDOMAttributeIterator(this, name);\n     }\n \n-    public NodeIterator namespaceIterator(){\n+    public NodeIterator namespaceIterator() {\n         return new JDOMNamespaceIterator(this);\n     }\n \n-    public NodePointer namespacePointer(String prefix){\n+    public NodePointer namespacePointer(String prefix) {\n         return new JDOMNamespacePointer(this, prefix);\n     }\n \n-    public String getNamespaceURI(){\n-        if (node instanceof Element){\n-            Element element = (Element)node;\n+    public String getNamespaceURI() {\n+        if (node instanceof Element) {\n+            Element element = (Element) node;\n             String ns = element.getNamespaceURI();\n-            if (ns != null && ns.equals(\"\")){\n+            if (ns != null && ns.equals(\"\")) {\n                 ns = null;\n             }\n             return ns;\n         return null;\n     }\n \n-    public String getNamespaceURI(String prefix){\n-        if (node instanceof Element){\n-            Element element = (Element)node;\n+    public String getNamespaceURI(String prefix) {\n+        if (node instanceof Element) {\n+            Element element = (Element) node;\n             Namespace ns = element.getNamespace(prefix);\n-            if (ns == null){\n+            if (ns == null) {\n                 return null;\n             }\n             return ns.getURI();\n     }\n \n     public int compareChildNodePointers(\n-                NodePointer pointer1, NodePointer pointer2)\n+        NodePointer pointer1,\n+        NodePointer pointer2) \n     {\n         Object node1 = pointer1.getBaseValue();\n         Object node2 = pointer2.getBaseValue();\n-        if (node1 == node2){\n+        if (node1 == node2) {\n             return 0;\n         }\n \n-        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)){\n+        if ((node1 instanceof Attribute) && !(node2 instanceof Attribute)) {\n             return -1;\n         }\n-        else if (!(node1 instanceof Attribute) && (node2 instanceof Attribute)){\n+        else if (\n+            !(node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n             return 1;\n         }\n-        else if ((node1 instanceof Attribute) && (node2 instanceof Attribute)){\n-            List list = ((Element)getNode()).getAttributes();\n+        else if (\n+            (node1 instanceof Attribute) && (node2 instanceof Attribute)) {\n+            List list = ((Element) getNode()).getAttributes();\n             int length = list.size();\n-            for (int i = 0; i < length; i++){\n+            for (int i = 0; i < length; i++) {\n                 Object n = list.get(i);\n-                if (n == node1){\n+                if (n == node1) {\n                     return -1;\n                 }\n-                else if (n == node2){\n+                else if (n == node2) {\n                     return 1;\n                 }\n             }\n-            return 0;       // Should not happen\n-        }\n-\n-        if (!(node instanceof Element)){\n-            throw new RuntimeException(\"JXPath internal error: \" +\n-                    \"compareChildNodes called for \" + node);\n-        }\n-\n-        List children = ((Element)node).getContent();\n+            return 0; // Should not happen\n+        }\n+\n+        if (!(node instanceof Element)) {\n+            throw new RuntimeException(\n+                \"JXPath internal error: \"\n+                    + \"compareChildNodes called for \"\n+                    + node);\n+        }\n+\n+        List children = ((Element) node).getContent();\n         int length = children.size();\n-        for (int i = 0; i < length; i++){\n+        for (int i = 0; i < length; i++) {\n             Object n = children.get(i);\n-            if (n == node1){\n+            if (n == node1) {\n                 return -1;\n             }\n-            else if (n == node2){\n+            else if (n == node2) {\n                 return 1;\n             }\n         }\n         return node;\n     }\n \n-    public boolean isCollection(){\n+    public boolean isCollection() {\n         return false;\n     }\n     \n-    public int getLength(){\n+    public int getLength() {\n         return 1;\n     }    \n \n-    public boolean isLeaf(){\n-        if (node instanceof Element){\n-            return ((Element)node).getContent().size() == 0;\n-        }\n-        else if (node instanceof Document){\n-            return ((Document)node).getContent().size() == 0;\n+    public boolean isLeaf() {\n+        if (node instanceof Element) {\n+            return ((Element) node).getContent().size() == 0;\n+        }\n+        else if (node instanceof Document) {\n+            return ((Document) node).getContent().size() == 0;\n         }\n         return true;\n     }\n     public QName getName() {\n         String ns = null;\n         String ln = null;\n-        if (node instanceof Element){\n-            ns = ((Element)node).getNamespacePrefix();\n-            if (ns != null && ns.equals(\"\")){\n+        if (node instanceof Element) {\n+            ns = ((Element) node).getNamespacePrefix();\n+            if (ns != null && ns.equals(\"\")) {\n                 ns = null;\n             }\n-            ln = ((Element)node).getName();\n-        }\n-        else if (node instanceof ProcessingInstruction){\n-            ln = ((ProcessingInstruction)node).getTarget();\n+            ln = ((Element) node).getName();\n+        }\n+        else if (node instanceof ProcessingInstruction) {\n+            ln = ((ProcessingInstruction) node).getTarget();\n         }\n         return new QName(ns, ln);\n     }\n \n-    public QName getExpandedName(){\n+    public QName getExpandedName() {\n         return new QName(getNamespaceURI(), getName().getName());\n     }\n \n         return node;\n     }\n \n-    public Object getValue(){\n-        if (node instanceof Element){\n-            return ((Element)node).getTextTrim();\n-        }\n-        else if (node instanceof Comment){\n-            String text = ((Comment)node).getText();\n-            if (text != null){\n+    public Object getValue() {\n+        if (node instanceof Element) {\n+            return ((Element) node).getTextTrim();\n+        }\n+        else if (node instanceof Comment) {\n+            String text = ((Comment) node).getText();\n+            if (text != null) {\n                 text = text.trim();\n             }\n             return text;\n         }\n-        else if (node instanceof Text){\n-            return ((Text)node).getTextTrim();\n-        }\n-        else if (node instanceof CDATA){\n-            return ((CDATA)node).getTextTrim();\n-        }\n-        else if (node instanceof ProcessingInstruction){\n-            String text = ((ProcessingInstruction)node).getData();\n-            if (text != null){\n+        else if (node instanceof Text) {\n+            return ((Text) node).getTextTrim();\n+        }\n+        else if (node instanceof CDATA) {\n+            return ((CDATA) node).getTextTrim();\n+        }\n+        else if (node instanceof ProcessingInstruction) {\n+            String text = ((ProcessingInstruction) node).getData();\n+            if (text != null) {\n                 text = text.trim();\n             }\n             return text;\n         return null;\n     }\n \n-\n-    /**\n-     * @see org.apache.commons.jxpath.Pointer#setValue(Object)\n-     */\n-//        String string = null;\n-//        if (value != null){\n-//            string = (String)TypeUtils.convert(value, String.class);\n-//            if (string.equals(\"\")){\n-//                string = null;\n-//            }\n-//        }\n-//\n-//        if (node instanceof Text){\n-//            if (string != null){\n-//                ((Text)node).setText(string);\n-//            }\n-//            else {\n-//                nodeParent(node).removeContent((Text)node);\n-//            }\n-//        }\n-//        else {\n-//            Element element = (Element)node;\n-//            // First remove all text from the element\n-//            List content = new ArrayList(element.getContent());\n-//            for (int i = content.size(); --i >= 0;){\n-//                Object child = content.get(i);\n-//                if (child instanceof Text){\n-//                    element.removeContent((Text)node);\n-//                }\n-//                else if (child instanceof CDATA){\n-//                    element.removeContent((CDATA)node);\n-//                }\n-//            }\n-//            if (string != null){\n-//                element.addContent(new Text(string));\n-//            }\n-//        }\n-\n     public void setValue(Object value) {\n-        if (node instanceof Text){\n-            String string = (String)TypeUtils.convert(value, String.class);\n-            if (string != null && !string.equals(\"\")){\n-                ((Text)node).setText(string);\n+        if (node instanceof Text) {\n+            String string = (String) TypeUtils.convert(value, String.class);\n+            if (string != null && !string.equals(\"\")) {\n+                ((Text) node).setText(string);\n             }\n             else {\n-                nodeParent(node).removeContent((Text)node);\n+                nodeParent(node).removeContent((Text) node);\n             }\n         }\n         else {\n-            Element element = (Element)node;\n+            Element element = (Element) node;\n             element.getContent().clear();\n-                        \n-            if (value instanceof Element){\n-                Element valueElement = (Element)value;\n+\n+            if (value instanceof Element) {\n+                Element valueElement = (Element) value;\n                 addContent(valueElement.getContent());\n             }\n-            else if (value instanceof Document){\n-                Document valueDocument = (Document)value;                \n+            else if (value instanceof Document) {\n+                Document valueDocument = (Document) value;\n                 addContent(valueDocument.getContent());\n             }\n-            else if (value instanceof Text ||\n-                     value instanceof CDATA){\n-                String string = ((Text)value).getText();\n+            else if (value instanceof Text || value instanceof CDATA) {\n+                String string = ((Text) value).getText();\n                 element.addContent(new Text(string));\n             }\n-            else if (value instanceof ProcessingInstruction){\n-                ProcessingInstruction pi = (ProcessingInstruction)\n-                        ((ProcessingInstruction)value).clone();\n+            else if (value instanceof ProcessingInstruction) {\n+                ProcessingInstruction pi =\n+                    (ProcessingInstruction) ((ProcessingInstruction) value)\n+                        .clone();\n                 element.addContent(pi);\n             }\n-            else if (value instanceof Comment){\n-                Comment comment = (Comment)((Comment)value).clone();\n+            else if (value instanceof Comment) {\n+                Comment comment = (Comment) ((Comment) value).clone();\n                 element.addContent(comment);\n             }\n             else {\n-                String string = (String)TypeUtils.convert(value, String.class);\n-                if (string != null && !string.equals(\"\")){\n+                String string = (String) TypeUtils.convert(value, String.class);\n+                if (string != null && !string.equals(\"\")) {\n                     element.addContent(new Text(string));\n                 }\n             }\n         }\n+    } \n+      \n+    private void addContent(List content) {\n+        Element element = (Element) node;\n+        int count = content.size();\n+\n+        for (int i = 0; i < count; i++) {\n+            Object child = content.get(i);\n+            if (child instanceof Element) {\n+                child = ((Element) child).clone();\n+                element.addContent((Element) child);\n+            }\n+            else if (child instanceof Text) {\n+                child = ((Text) child).clone();\n+                element.addContent((Text) child);\n+            }\n+            else if (node instanceof CDATA) {\n+                child = ((CDATA) child).clone();\n+                element.addContent((CDATA) child);\n+            }\n+            else if (node instanceof ProcessingInstruction) {\n+                child = ((ProcessingInstruction) child).clone();\n+                element.addContent((ProcessingInstruction) child);\n+            }\n+            else if (node instanceof Comment) {\n+                child = ((Comment) child).clone();\n+                element.addContent((Comment) child);\n+            }\n+        }\n     }\n     \n-    private void addContent(List content){\n-        Element element = (Element)node;\n-        int count = content.size();\n-        \n-        for (int i = 0; i < count; i++){\n-            Object child = content.get(i);\n-            if (child instanceof Element){\n-                child = ((Element)child).clone();\n-                element.addContent((Element)child);\n-            }\n-            else if (child instanceof Text){\n-                child = ((Text)child).clone();\n-                element.addContent((Text)child);\n-            }\n-            else if (node instanceof CDATA){\n-                child = ((CDATA)child).clone();\n-                element.addContent((CDATA)child);\n-            }\n-            else if (node instanceof ProcessingInstruction){\n-                child = ((ProcessingInstruction)child).clone();\n-                element.addContent((ProcessingInstruction)child);\n-            }\n-            else if (node instanceof Comment){\n-                child = ((Comment)child).clone();\n-                element.addContent((Comment)child);\n-            }\n-        }\n-    }\n-    \n-    public boolean testNode(NodeTest test){\n+    public boolean testNode(NodeTest test) {\n         return testNode(this, node, test);\n     }\n \n     public static boolean testNode(\n-            NodePointer pointer, Object node, NodeTest test)\n+        NodePointer pointer,\n+        Object node,\n+        NodeTest test) \n     {\n-        if (test == null){\n+        if (test == null) {\n             return true;\n         }\n-        else if (test instanceof NodeNameTest){\n-            if (!(node instanceof Element)){\n+        else if (test instanceof NodeNameTest) {\n+            if (!(node instanceof Element)) {\n                 return false;\n             }\n \n-            QName testName = ((NodeNameTest)test).getNodeName();\n+            QName testName = ((NodeNameTest) test).getNodeName();\n             String testLocalName = testName.getName();\n             boolean wildcard = testLocalName.equals(\"*\");\n-            if (wildcard && testName.getPrefix() == null){\n+            if (wildcard && testName.getPrefix() == null) {\n                 return true;\n             }\n-             \n-            if (wildcard ||\n-                    testLocalName.equals(\n-                            JDOMNodePointer.getLocalName((Element)node))){\n+\n+            if (wildcard\n+                || testLocalName.equals(\n+                    JDOMNodePointer.getLocalName((Element) node))) {\n                 String testPrefix = testName.getPrefix();\n-                String nodePrefix = JDOMNodePointer.getPrefix((Element)node);\n-                if (equalStrings(testPrefix, nodePrefix)){\n+                String nodePrefix = JDOMNodePointer.getPrefix((Element) node);\n+                if (equalStrings(testPrefix, nodePrefix)) {\n                     return true;\n                 }\n \n                 String testNS = pointer.getNamespaceURI(testPrefix);\n-                if (testNS == null){\n+                if (testNS == null) {\n                     return false;\n                 }\n                 String nodeNS = pointer.getNamespaceURI(nodePrefix);\n                 return equalStrings(testNS, nodeNS);\n             }\n         }\n-        else if (test instanceof NodeTypeTest){\n-            switch (((NodeTypeTest)test).getNodeType()){\n-                case Compiler.NODE_TYPE_NODE:\n+        else if (test instanceof NodeTypeTest) {\n+            switch (((NodeTypeTest) test).getNodeType()) {\n+                case Compiler.NODE_TYPE_NODE :\n                     return node instanceof Element;\n-                case Compiler.NODE_TYPE_TEXT:\n-                    return (node instanceof Text) ||\n-                        (node instanceof CDATA);\n-                case Compiler.NODE_TYPE_COMMENT:\n+                case Compiler.NODE_TYPE_TEXT :\n+                    return (node instanceof Text) || (node instanceof CDATA);\n+                case Compiler.NODE_TYPE_COMMENT :\n                     return node instanceof Comment;\n-                case Compiler.NODE_TYPE_PI:\n+                case Compiler.NODE_TYPE_PI :\n                     return node instanceof ProcessingInstruction;\n             }\n             return false;\n         }\n-        else if (test instanceof ProcessingInstructionTest){\n-            if (node instanceof ProcessingInstruction){\n-                String testPI = ((ProcessingInstructionTest)test).getTarget();\n-                String nodePI = ((ProcessingInstruction)node).getTarget();\n+        else if (test instanceof ProcessingInstructionTest) {\n+            if (node instanceof ProcessingInstruction) {\n+                String testPI = ((ProcessingInstructionTest) test).getTarget();\n+                String nodePI = ((ProcessingInstruction) node).getTarget();\n                 return testPI.equals(nodePI);\n             }\n         }\n         return false;\n     }\n \n-    private static boolean equalStrings(String s1, String s2){\n-        if (s1 == null && s2 != null){\n+    private static boolean equalStrings(String s1, String s2) {\n+        if (s1 == null && s2 != null) {\n             return false;\n         }\n-        if (s1 != null && s2 == null){\n+        if (s1 != null && s2 == null) {\n             return false;\n         }\n \n-        if (s1 != null && !s1.trim().equals(s2.trim())){\n+        if (s1 != null && !s1.trim().equals(s2.trim())) {\n             return false;\n         }\n \n         return true;\n     }\n \n-    public static String getPrefix(Object node){\n-        if (node instanceof Element){\n-            String prefix = ((Element)node).getNamespacePrefix();\n+    public static String getPrefix(Object node) {\n+        if (node instanceof Element) {\n+            String prefix = ((Element) node).getNamespacePrefix();\n             return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n         }\n-        else if (node instanceof Attribute){\n-            String prefix = ((Attribute)node).getNamespacePrefix();\n+        else if (node instanceof Attribute) {\n+            String prefix = ((Attribute) node).getNamespacePrefix();\n             return (prefix == null || prefix.equals(\"\")) ? null : prefix;\n         }\n         return null;\n     }\n-\n-    public static String getLocalName(Object node){\n-        if (node instanceof Element){\n-            return ((Element)node).getName();\n-        }\n-        else if (node instanceof Attribute){\n-            return ((Attribute)node).getName();\n+    \n+    public static String getLocalName(Object node) {\n+        if (node instanceof Element) {\n+            return ((Element) node).getName();\n+        }\n+        else if (node instanceof Attribute) {\n+            return ((Attribute) node).getName();\n         }\n         return null;\n     }\n      * or its parent has the specified prefix <i>lang</i>.\n      * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n      */\n-    public boolean isLanguage(String lang){\n+    public boolean isLanguage(String lang) {\n         String current = getLanguage();\n-        if (current == null){\n+        if (current == null) {\n             return super.isLanguage(lang);\n         }\n         return current.toUpperCase().startsWith(lang.toUpperCase());\n     }\n \n-    protected String getLanguage(){\n+    protected String getLanguage() {\n         Object n = node;\n-        while (n != null){\n-            if (n instanceof Element){\n-                Element e = (Element)n;\n-                String attr = e.getAttributeValue(\"lang\",\n-                        Namespace.XML_NAMESPACE);\n-                if (attr != null && !attr.equals(\"\")){\n+        while (n != null) {\n+            if (n instanceof Element) {\n+                Element e = (Element) n;\n+                String attr =\n+                    e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n+                if (attr != null && !attr.equals(\"\")) {\n                     return attr;\n                 }\n             }\n         }\n         return null;\n     }\n-\n-    private Element nodeParent(Object node){\n-        if (node instanceof Element){\n-            return ((Element)node).getParent();\n-        }\n-        else if (node instanceof Text){\n-            return ((Text)node).getParent();\n-        }\n-        else if (node instanceof CDATA){\n-            return ((CDATA)node).getParent();\n-        }\n-        else if (node instanceof ProcessingInstruction){\n-            return ((ProcessingInstruction)node).getParent();\n-        }\n-        else if (node instanceof Comment){\n-            return ((Comment)node).getParent();\n+    \n+    private Element nodeParent(Object node) {\n+        if (node instanceof Element) {\n+            return ((Element) node).getParent();\n+        }\n+        else if (node instanceof Text) {\n+            return ((Text) node).getParent();\n+        }\n+        else if (node instanceof CDATA) {\n+            return ((CDATA) node).getParent();\n+        }\n+        else if (node instanceof ProcessingInstruction) {\n+            return ((ProcessingInstruction) node).getParent();\n+        }\n+        else if (node instanceof Comment) {\n+            return ((Comment) node).getParent();\n         }\n         return null;\n     }\n \n     public NodePointer createChild(\n-            JXPathContext context, QName name, int index)\n+        JXPathContext context,\n+        QName name,\n+        int index) \n     {\n-        if (index == WHOLE_COLLECTION){\n+        if (index == WHOLE_COLLECTION) {\n             index = 0;\n         }\n-        if (!getAbstractFactory(context).\n-                    createObject(context, this, node, name.toString(), index)){\n-            throw new JXPathException(\"Factory could not create \" +\n-                    \"a child node for path: \" +\n-                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n-        }\n-        NodeIterator it = childIterator(new NodeNameTest(name), false, null);\n-        if (it == null || !it.setPosition(index + 1)){\n-            throw new JXPathException(\"Factory could not create \" +\n-                    \"a child node for path: \" +\n-                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n-        }\n-        return it.getNodePointer();\n+        boolean success =\n+            getAbstractFactory(context).createObject(\n+                context,\n+                this,\n+                node,\n+                name.toString(),\n+                index);\n+        if (success) {\n+            NodeIterator it =\n+                childIterator(new NodeNameTest(name), false, null);\n+            if (it != null && it.setPosition(index + 1)) {\n+                return it.getNodePointer();\n+            }\n+        }\n+        throw new JXPathException(\n+            \"Factory could not create \"\n+                + \"a child node for path: \"\n+                + asPath()\n+                + \"/\"\n+                + name\n+                + \"[\"\n+                + (index + 1)\n+                + \"]\");\n     }\n \n     public NodePointer createChild(\n         return ptr;\n     }\n \n-    public NodePointer createAttribute(JXPathContext context, QName name){\n+    public NodePointer createAttribute(JXPathContext context, QName name) {\n         if (!(node instanceof Element)) {\n             return super.createAttribute(context, name);\n         }\n         return it.getNodePointer();\n     }\n \n-    public void remove(){\n+    public void remove() {\n         Element parent = nodeParent(node);\n-        if (parent == null){\n+        if (parent == null) {\n             throw new JXPathException(\"Cannot remove root JDOM node\");\n         }\n         parent.getContent().remove(node);\n     }\n \n-    public String asPath(){\n-        if (id != null){\n+    public String asPath() {\n+        if (id != null) {\n             return \"id('\" + escape(id) + \"')\";\n         }\n \n         StringBuffer buffer = new StringBuffer();\n-        if (parent != null){\n+        if (parent != null) {\n             buffer.append(parent.asPath());\n         }\n-        if (node instanceof Element){\n+        if (node instanceof Element) {\n             // If the parent pointer is not a JDOMNodePointer, it is\n             // the parent's responsibility to produce the node test part\n             // of the path\n-            if (parent instanceof JDOMNodePointer){\n-                if (buffer.length() == 0 ||\n-                        buffer.charAt(buffer.length()-1) != '/'){\n+            if (parent instanceof JDOMNodePointer) {\n+                if (buffer.length() == 0\n+                    || buffer.charAt(buffer.length() - 1) != '/') {\n                     buffer.append('/');\n                 }\n                 buffer.append(getName());\n                 buffer.append(']');\n             }\n         }\n-        else if (node instanceof Text || node instanceof CDATA){\n+        else if (node instanceof Text || node instanceof CDATA) {\n             buffer.append(\"/text()\");\n-            buffer.append('[').\n-                    append(getRelativePositionOfTextNode()).\n-                    append(']');\n-        }\n-        else if (node instanceof ProcessingInstruction){\n-            String target = ((ProcessingInstruction)node).getTarget();\n-            buffer.append(\"/processing-instruction(\\'\").\n-                    append(target).\n-                    append(\"')\");\n-            buffer.append('[').\n-                    append(getRelativePositionOfPI(target)).\n-                    append(']');\n+            buffer.append('[').append(getRelativePositionOfTextNode()).append(\n+                ']');\n+        }\n+        else if (node instanceof ProcessingInstruction) {\n+            String target = ((ProcessingInstruction) node).getTarget();\n+            buffer.append(\"/processing-instruction(\\'\").append(target).append(\n+                \"')\");\n+            buffer.append('[').append(getRelativePositionOfPI(target)).append(\n+                ']');\n         }\n         return buffer.toString();\n     }\n \n-    private String escape(String string){\n+    private String escape(String string) {\n         int index = string.indexOf('\\'');\n-        while (index != -1){\n-            string = string.substring(0, index) +\n-                    \"&apos;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&apos;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\'');\n         }\n         index = string.indexOf('\\\"');\n-        while (index != -1){\n-            string = string.substring(0, index) +\n-                    \"&quot;\" + string.substring(index + 1);\n+        while (index != -1) {\n+            string =\n+                string.substring(0, index)\n+                    + \"&quot;\"\n+                    + string.substring(index + 1);\n             index = string.indexOf('\\\"');\n         }\n         return string;\n     }\n \n-    private int getRelativePositionByName(){\n-        if (node instanceof Element){\n-            Element parent = ((Element)node).getParent();\n-            if (parent == null){\n+    private int getRelativePositionByName() {\n+        if (node instanceof Element) {\n+            Element parent = ((Element) node).getParent();\n+            if (parent == null) {\n                 return 1;\n             }\n             List children = parent.getContent();\n             int count = 0;\n-            String name = ((Element)node).getQualifiedName();\n-            for (int i = 0; i < children.size(); i++){\n+            String name = ((Element) node).getQualifiedName();\n+            for (int i = 0; i < children.size(); i++) {\n                 Object child = children.get(i);\n-                if ((child instanceof Element) &&\n-                    ((Element)child).getQualifiedName().equals(name)){\n+                if ((child instanceof Element)\n+                    && ((Element) child).getQualifiedName().equals(name)) {\n                     count++;\n                 }\n-                if (child == node){\n+                if (child == node) {\n                     break;\n                 }\n             }\n         return 1;\n     }\n \n-    private int getRelativePositionOfTextNode(){\n+    private int getRelativePositionOfTextNode() {\n         Element parent;\n-        if (node instanceof Text){\n-            parent = ((Text)node).getParent();\n+        if (node instanceof Text) {\n+            parent = ((Text) node).getParent();\n         }\n         else {\n-            parent = ((CDATA)node).getParent();\n-        }\n-        if (parent == null){\n+            parent = ((CDATA) node).getParent();\n+        }\n+        if (parent == null) {\n             return 1;\n         }\n         List children = parent.getContent();\n         int count = 0;\n-        for (int i = 0; i < children.size(); i++){\n+        for (int i = 0; i < children.size(); i++) {\n             Object child = children.get(i);\n-            if (child instanceof Text || child instanceof CDATA){\n+            if (child instanceof Text || child instanceof CDATA) {\n                 count++;\n             }\n-            if (child == node){\n+            if (child == node) {\n                 break;\n             }\n         }\n         return count;\n     }\n \n-    private int getRelativePositionOfPI(String target){\n+    private int getRelativePositionOfPI(String target) {\n         Element parent = ((ProcessingInstruction) node).getParent();\n         if (parent == null) {\n             return 1;\n         return count;\n     }\n \n-    public int hashCode(){\n+    public int hashCode() {\n         return System.identityHashCode(node);\n     }\n \n-    public boolean equals(Object object){\n-        if (object == this){\n+    public boolean equals(Object object) {\n+        if (object == this) {\n             return true;\n         }\n \n-        if (!(object instanceof JDOMNodePointer)){\n+        if (!(object instanceof JDOMNodePointer)) {\n             return false;\n         }\n \n-        JDOMNodePointer other = (JDOMNodePointer)object;\n+        JDOMNodePointer other = (JDOMNodePointer) object;\n         return node == other.node;\n     }\n-\n     private AbstractFactory getAbstractFactory(JXPathContext context) {\n         AbstractFactory factory = context.getFactory();\n         if (factory == null) {\n--- a/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java,v 1.1 2002/08/26 22:29:48 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:29:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMPointerFactory.java,v 1.2 2003/01/11 05:41:26 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Implements NodePointerFactory for DOM elements.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:48 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class JDOMPointerFactory implements NodePointerFactory {\n \n     public static final int JDOM_POINTER_FACTORY_ORDER = 110;\n \n-    public int getOrder(){\n+    public int getOrder() {\n         return JDOM_POINTER_FACTORY_ORDER;\n     }\n \n     public NodePointer createNodePointer(\n             QName name, Object bean, Locale locale)\n     {\n-        if (bean instanceof Document){\n+        if (bean instanceof Document) {\n             return new JDOMNodePointer(bean, locale);\n         }\n-        else if (bean instanceof Element){\n+        else if (bean instanceof Element) {\n             return new JDOMNodePointer(bean, locale);\n         }\n         return null;\n     public NodePointer createNodePointer(\n             NodePointer parent, QName name, Object bean)\n     {\n-        if (bean instanceof Document){\n+        if (bean instanceof Document) {\n             return new JDOMNodePointer(parent, bean);\n         }\n-        else if (bean instanceof Element){\n+        else if (bean instanceof Element) {\n             return new JDOMNodePointer(parent, bean);\n         }\n         return null;\n--- a/src/java/org/apache/commons/jxpath/servlet/Constants.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/Constants.java\n  * String constants for this package.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public final class Constants {\n \n     public static final String PAGE_SCOPE = \"page\";\n \n     /**\n-     * Attribute name used in page context, requst, session, and servlet context to store\n-     * the corresponding JXPathContext.\n+     * Attribute  name used in page context, requst, session, and servlet\n+     * context to store the corresponding JXPathContext.\n      */\n-    public static final String JXPATH_CONTEXT = \"org.apache.commons.jxpath.JXPATH_CONTEXT\";\n+    public static final String JXPATH_CONTEXT =\n+        \"org.apache.commons.jxpath.JXPATH_CONTEXT\";\n \n }\n--- a/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/HttpSessionHandler.java\n  * access to attributes of a HttpSession.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class HttpSessionHandler implements DynamicPropertyHandler {\n \n-    public String[] getPropertyNames(Object session){\n-        Enumeration e = ((HttpSession)session).getAttributeNames();\n+    public String[] getPropertyNames(Object session) {\n+        Enumeration e = ((HttpSession) session).getAttributeNames();\n         return Util.toStrings(e);\n     }\n \n-    public Object getProperty(Object session, String property){\n-        return ((HttpSession)session).getAttribute(property);\n+    public Object getProperty(Object session, String property) {\n+        return ((HttpSession) session).getAttribute(property);\n     }\n \n-    public void setProperty(Object session, String property, Object value){\n-        ((HttpSession)session).setAttribute(property, value);\n+    public void setProperty(Object session, String property, Object value) {\n+        ((HttpSession) session).setAttribute(property, value);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/JXPathServletContexts.java\n  * For example, the expression \"$session/foo\" extracts the value of the\n  * session attribute named \"foo\".\n  * <p>\n- * Following are some implementation details.\n- * There is a separate JXPathContext for each of the four scopes. These contexts are chained\n- * according to the nesting of the scopes.  So, the parent of the \"page\"\n- * JXPathContext is a \"request\" JXPathContext, whose parent is a \"session\"\n- * JXPathContext (that is if there is a session), whose parent is an \"application\"\n- * context.\n- * <p>\n- * The XPath context node for each context is the corresponding object: PageContext,\n- * ServletRequest, HttpSession or ServletContext.  This feature can be used by\n- * servlets.  A servlet can use one of the methods declared by this class and\n- * work with a specific JXPathContext for any scope.\n+ * Following are some implementation details. There is a separate JXPathContext\n+ * for each of the four scopes. These contexts are chained according to the\n+ * nesting of the scopes.  So, the parent of the \"page\" JXPathContext is a\n+ * \"request\" JXPathContext, whose parent is a \"session\" JXPathContext (that is\n+ * if there is a session), whose parent is an \"application\" context.\n+ * <p>\n+ * The  XPath context node for each context is the corresponding object:\n+ * PageContext, ServletRequest, HttpSession or ServletContext.  This feature can\n+ * be used by servlets.  A servlet can use one of the methods declared by this\n+ * class and work with a specific JXPathContext for any scope.\n  * <p>\n  * Since JXPath chains lookups for variables and extension functions, variables\n  * and extension function declared in the outer scopes are also available in\n  * the inner scopes.\n  * <p>\n- * Each of the four context declares exactly one variable, the value of which is the corresponding\n- * object: PageContext, etc.\n- * <p>\n- * The \"session\" variable will be undefined if there is no session for this servlet.\n- * JXPath does not automatically create sessions.\n+ * Each  of the four context declares exactly one variable, the value of which\n+ * is the corresponding object: PageContext, etc.\n+ * <p>\n+ * The  \"session\" variable will be undefined if there is no session for this\n+ * servlet. JXPath does not automatically create sessions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public final class JXPathServletContexts {\n \n     private static JXPathContextFactory factory;\n \n     static {\n-        JXPathIntrospector.registerDynamicClass(PageScopeContext.class, PageScopeContextHandler.class);\n+        JXPathIntrospector.registerDynamicClass(\n+            PageScopeContext.class,\n+            PageScopeContextHandler.class);\n         factory = JXPathContextFactory.newInstance();\n     }\n \n      * Returns a JXPathContext bound to the \"page\" scope. Caches that context\n      * within the PageContext itself.\n      */\n-    public static JXPathContext getPageContext(PageContext pageContext){\n-        JXPathContext context = (JXPathContext)pageContext.getAttribute(Constants.JXPATH_CONTEXT);\n-        if (context == null){\n-            JXPathIntrospector.registerDynamicClass(pageContext.getClass(), PageContextHandler.class);\n-            JXPathContext parentContext = getRequestContext(\n-                    pageContext.getRequest(), pageContext.getServletContext());\n+    public static JXPathContext getPageContext(PageContext pageContext) {\n+        JXPathContext context =\n+            (JXPathContext) pageContext.getAttribute(Constants.JXPATH_CONTEXT);\n+        if (context == null) {\n+            JXPathIntrospector.registerDynamicClass(\n+                pageContext.getClass(),\n+                PageContextHandler.class);\n+            JXPathContext parentContext =\n+                getRequestContext(\n+                    pageContext.getRequest(),\n+                    pageContext.getServletContext());\n             context = factory.newContext(parentContext, pageContext);\n-            context.setVariables(new KeywordVariables(Constants.PAGE_SCOPE, new PageScopeContext(pageContext)));\n+            context.setVariables(\n+                new KeywordVariables(\n+                    Constants.PAGE_SCOPE,\n+                    new PageScopeContext(pageContext)));\n             pageContext.setAttribute(Constants.JXPATH_CONTEXT, context);\n         }\n         return context;\n      * Returns a JXPathContext bound to the \"request\" scope. Caches that context\n      * within the request itself.\n      */\n-    public static JXPathContext getRequestContext(ServletRequest request, ServletContext servletContext){\n-        JXPathContext context = (JXPathContext)request.getAttribute(Constants.JXPATH_CONTEXT);\n-        if (context == null){\n+    public static JXPathContext getRequestContext(\n+        ServletRequest request,\n+        ServletContext servletContext) \n+    {\n+        JXPathContext context =\n+            (JXPathContext) request.getAttribute(Constants.JXPATH_CONTEXT);\n+        if (context == null) {\n             JXPathContext parentContext = null;\n-            if (request instanceof HttpServletRequest){\n-                HttpSession session = ((HttpServletRequest)request).getSession(false);\n-                if (session != null){\n+            if (request instanceof HttpServletRequest) {\n+                HttpSession session =\n+                    ((HttpServletRequest) request).getSession(false);\n+                if (session != null) {\n                     parentContext = getSessionContext(session, servletContext);\n                 }\n                 else {\n                     parentContext = getApplicationContext(servletContext);\n                 }\n             }\n-            JXPathIntrospector.registerDynamicClass(request.getClass(), ServletRequestHandler.class);\n+            JXPathIntrospector.registerDynamicClass(\n+                request.getClass(),\n+                ServletRequestHandler.class);\n             context = factory.newContext(parentContext, request);\n-            context.setVariables(new KeywordVariables(Constants.REQUEST_SCOPE, request));\n+            context.setVariables(\n+                new KeywordVariables(Constants.REQUEST_SCOPE, request));\n             request.setAttribute(Constants.JXPATH_CONTEXT, context);\n         }\n         return context;\n      * Returns a JXPathContext bound to the \"session\" scope. Caches that context\n      * within the session itself.\n      */\n-    public static JXPathContext getSessionContext(HttpSession session, ServletContext servletContext){\n-        JXPathContext context = (JXPathContext)session.getAttribute(Constants.JXPATH_CONTEXT);\n-        if (context == null){\n-            JXPathIntrospector.registerDynamicClass(session.getClass(), HttpSessionHandler.class);\n+    public static JXPathContext getSessionContext(\n+        HttpSession session,\n+        ServletContext servletContext) \n+    {\n+        JXPathContext context =\n+            (JXPathContext) session.getAttribute(Constants.JXPATH_CONTEXT);\n+        if (context == null) {\n+            JXPathIntrospector.registerDynamicClass(\n+                session.getClass(),\n+                HttpSessionHandler.class);\n             JXPathContext parentContext = getApplicationContext(servletContext);\n             context = factory.newContext(parentContext, session);\n-            context.setVariables(new KeywordVariables(Constants.SESSION_SCOPE, session));\n+            context.setVariables(\n+                new KeywordVariables(Constants.SESSION_SCOPE, session));\n             session.setAttribute(Constants.JXPATH_CONTEXT, context);\n         }\n         return context;\n     }\n \n     /**\n-     * Returns a JXPathContext bound to the \"application\" scope. Caches that context\n-     * within the servlet context itself.\n-     */\n-    public static JXPathContext getApplicationContext(ServletContext servletContext){\n-        JXPathContext context = (JXPathContext)servletContext.getAttribute(Constants.JXPATH_CONTEXT);\n-        if (context == null){\n-            JXPathIntrospector.registerDynamicClass(servletContext.getClass(), ServletContextHandler.class);\n+     * Returns  a JXPathContext bound to the \"application\" scope. Caches that\n+     * context within the servlet context itself.\n+     */\n+    public static JXPathContext getApplicationContext(\n+            ServletContext servletContext) \n+    {\n+        JXPathContext context =\n+            (JXPathContext) servletContext.getAttribute(\n+                Constants.JXPATH_CONTEXT);\n+        if (context == null) {\n+            JXPathIntrospector.registerDynamicClass(\n+                servletContext.getClass(),\n+                ServletContextHandler.class);\n             context = factory.newContext(null, servletContext);\n-            context.setVariables(new KeywordVariables(Constants.APPLICATION_SCOPE, servletContext));\n+            context.setVariables(\n+                new KeywordVariables(\n+                    Constants.APPLICATION_SCOPE,\n+                    servletContext));\n             servletContext.setAttribute(Constants.JXPATH_CONTEXT, context);\n         }\n         return context;\n--- a/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/KeywordVariables.java\n  * to a single object using a reserved name (keyword).\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/05/08 23:19:09 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class KeywordVariables implements Variables {\n \n     private String keyword;\n     private Object object;\n \n-    public KeywordVariables(String keyword, Object object){\n+    public KeywordVariables(String keyword, Object object) {\n         this.keyword = keyword;\n         this.object = object;\n     }\n \n-    public boolean isDeclaredVariable(String variable){\n+    public boolean isDeclaredVariable(String variable) {\n         return variable.equals(keyword);\n     }\n \n-    public Object getVariable(String variable){\n-        if (variable.equals(keyword)){\n+    public Object getVariable(String variable) {\n+        if (variable.equals(keyword)) {\n             return object;\n         }\n         return null;\n     }\n \n-    public void declareVariable(String variable, Object value){\n-        throw new UnsupportedOperationException(\"Cannot declare new keyword variables.\");\n+    public void declareVariable(String variable, Object value) {\n+        throw new UnsupportedOperationException(\n+            \"Cannot declare new keyword variables.\");\n     }\n \n-    public void undeclareVariable(String variable){\n-        throw new UnsupportedOperationException(\"Cannot declare new keyword variables.\");\n+    public void undeclareVariable(String variable) {\n+        throw new UnsupportedOperationException(\n+            \"Cannot declare new keyword variables.\");\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageContextHandler.java\n  * access to attributes of a PageContext in all scopes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class PageContextHandler implements DynamicPropertyHandler {\n \n-    public String[] getPropertyNames(Object pageContext){\n+    public String[] getPropertyNames(Object pageContext) {\n         ArrayList list = new ArrayList();\n-        Enumeration e = ((PageContext)pageContext).getAttributeNamesInScope(PageContext.PAGE_SCOPE);\n-        while (e.hasMoreElements()){\n+        Enumeration e =\n+            ((PageContext) pageContext).getAttributeNamesInScope(\n+                PageContext.PAGE_SCOPE);\n+        while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        e = ((PageContext)pageContext).getAttributeNamesInScope(PageContext.REQUEST_SCOPE);\n-        while (e.hasMoreElements()){\n+        e =\n+            ((PageContext) pageContext).getAttributeNamesInScope(\n+                PageContext.REQUEST_SCOPE);\n+        while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        e = ((PageContext)pageContext).getAttributeNamesInScope(PageContext.SESSION_SCOPE);\n-        while (e.hasMoreElements()){\n+        e =\n+            ((PageContext) pageContext).getAttributeNamesInScope(\n+                PageContext.SESSION_SCOPE);\n+        while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        e = ((PageContext)pageContext).getAttributeNamesInScope(PageContext.APPLICATION_SCOPE);\n-        while (e.hasMoreElements()){\n+        e =\n+            ((PageContext) pageContext).getAttributeNamesInScope(\n+                PageContext.APPLICATION_SCOPE);\n+        while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        return (String[])list.toArray(new String[0]);\n+        return (String[]) list.toArray(new String[0]);\n     }\n \n     /**\n      * Returns <code>pageContext.findAttribute(property)</code>.\n      */\n-    public Object getProperty(Object pageContext, String property){\n-        return ((PageContext)pageContext).findAttribute(property);\n+    public Object getProperty(Object pageContext, String property) {\n+        return ((PageContext) pageContext).findAttribute(property);\n     }\n \n-    public void setProperty(Object pageContext, String property, Object value){\n-        ((PageContext)pageContext).setAttribute(property, value, PageContext.PAGE_SCOPE);\n+    public void setProperty(\n+        Object pageContext,\n+        String property,\n+        Object value) \n+    {\n+        ((PageContext) pageContext).setAttribute(\n+            property,\n+            value,\n+            PageContext.PAGE_SCOPE);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContext.java\n  * \"$page/foo\" would only look in the \"page\" scope.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class PageScopeContext {\n     private PageContext pageContext;\n \n-    public PageScopeContext(PageContext pageContext){\n+    public PageScopeContext(PageContext pageContext) {\n         this.pageContext = pageContext;\n     }\n \n     /**\n      * Returns attributes of the pageContext declared in the \"page\" scope.\n      */\n-    public Enumeration getAttributeNames(){\n+    public Enumeration getAttributeNames() {\n         return pageContext.getAttributeNamesInScope(PageContext.PAGE_SCOPE);\n     }\n \n-    public Object getAttribute(String attribute){\n+    public Object getAttribute(String attribute) {\n         return pageContext.getAttribute(attribute, PageContext.PAGE_SCOPE);\n     }\n \n-    public void setAttribute(String attribute, Object value){\n+    public void setAttribute(String attribute, Object value) {\n         pageContext.setAttribute(attribute, value, PageContext.PAGE_SCOPE);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/PageScopeContextHandler.java\n  * access to attributes of a PageScopeContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class PageScopeContextHandler implements DynamicPropertyHandler {\n \n-    public String[] getPropertyNames(Object pageScope){\n-        Enumeration e = ((PageScopeContext)pageScope).getAttributeNames();\n+    public String[] getPropertyNames(Object pageScope) {\n+        Enumeration e = ((PageScopeContext) pageScope).getAttributeNames();\n         return Util.toStrings(e);\n     }\n \n-    public Object getProperty(Object pageScope, String property){\n-        return ((PageScopeContext)pageScope).getAttribute(property);\n+    public Object getProperty(Object pageScope, String property) {\n+        return ((PageScopeContext) pageScope).getAttribute(property);\n     }\n \n-    public void setProperty(Object pageScope, String property, Object value){\n-        ((PageScopeContext)pageScope).setAttribute(property, value);\n+    public void setProperty(Object pageScope, String property, Object value) {\n+        ((PageScopeContext) pageScope).setAttribute(property, value);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletContextHandler.java\n  * access to attributes of a ServletContext.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class ServletContextHandler implements DynamicPropertyHandler {\n \n-    public String[] getPropertyNames(Object context){\n-        Enumeration e = ((ServletContext)context).getAttributeNames();\n+    public String[] getPropertyNames(Object context) {\n+        Enumeration e = ((ServletContext) context).getAttributeNames();\n         return Util.toStrings(e);\n     }\n \n-    public Object getProperty(Object context, String property){\n-        return ((ServletContext)context).getAttribute(property);\n+    public Object getProperty(Object context, String property) {\n+        return ((ServletContext) context).getAttribute(property);\n     }\n \n-    public void setProperty(Object context, String property, Object value){\n-        ((ServletContext)context).setAttribute(property, value);\n+    public void setProperty(Object context, String property, Object value) {\n+        ((ServletContext) context).setAttribute(property, value);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/ServletRequestHandler.java\n  * access to attributes of a ServletRequest.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/24 04:05:39 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:26 $\n  */\n public class ServletRequestHandler implements DynamicPropertyHandler {\n \n-    public String[] getPropertyNames(Object request){\n-        Enumeration e = ((ServletRequest)request).getAttributeNames();\n+    public String[] getPropertyNames(Object request) {\n+        Enumeration e = ((ServletRequest) request).getAttributeNames();\n         return Util.toStrings(e);\n     }\n \n-    public Object getProperty(Object request, String property){\n-        return ((ServletRequest)request).getAttribute(property);\n+    public Object getProperty(Object request, String property) {\n+        return ((ServletRequest) request).getAttribute(property);\n     }\n \n-    public void setProperty(Object request, String property, Object value){\n-        ((ServletRequest)request).setAttribute(property, value);\n+    public void setProperty(Object request, String property, Object value) {\n+        ((ServletRequest) request).setAttribute(property, value);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/servlet/Util.java\n+++ b/src/java/org/apache/commons/jxpath/servlet/Util.java\n \n package org.apache.commons.jxpath.servlet;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n \n /**\n  * Turns an Enumeration of Strings into an array of Strings.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/08 21:01:00 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:26 $\n  */\n public final class Util {\n \n     private static final String[] STRING_ARRAY = new String[0];\n \n-    public static String[] toStrings(Enumeration e){\n+    public static String[] toStrings(Enumeration e) {\n         ArrayList list = new ArrayList(16);\n-        while (e.hasMoreElements()){\n+        while (e.hasMoreElements()) {\n             list.add(e.nextElement());\n         }\n-        return (String[])list.toArray(STRING_ARRAY);\n+        return (String[]) list.toArray(STRING_ARRAY);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n+++ b/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.2 2002/06/16 03:22:21 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/16 03:22:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/BasicTypeConverter.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.util;\n \n+import java.lang.reflect.Array;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Vector;\n+\n+import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.JXPathException;\n-import org.apache.commons.jxpath.ExpressionContext;\n import org.apache.commons.jxpath.Pointer;\n-import java.util.*;\n-import java.lang.reflect.*;\n \n /**\n  * The default implementation of TypeConverter.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/06/16 03:22:21 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class BasicTypeConverter implements TypeConverter {\n \n      * Returns true if it can convert the supplied\n      * object to the specified class.\n      */\n-    public boolean canConvert(Object object, Class toType){\n-        if (object == null){\n-            return true;\n-        }\n-\n-        if (toType == Object.class){\n+    public boolean canConvert(Object object, Class toType) {\n+        if (object == null) {\n+            return true;\n+        }\n+\n+        if (toType == Object.class) {\n             return true;\n         }\n \n         Class fromType = object.getClass();\n-        if (fromType.equals(toType)){\n-            return true;\n-        }\n-\n-        if (toType.isAssignableFrom(fromType)){\n-            return true;\n-        }\n-\n-        if (toType == String.class){\n-            return true;\n-        }\n-\n-        if (object instanceof Boolean){\n-            if (toType == boolean.class ||\n-                    Number.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof Number){\n-            if (toType.isPrimitive() ||\n-                    Number.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof Character){\n-            if (toType == char.class){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof String){\n-            if (toType.isPrimitive()){\n-                return true;\n-            }\n-            if (toType == Boolean.class ||\n-                    toType == Character.class ||\n-                    toType == Byte.class ||\n-                    toType == Short.class ||\n-                    toType == Integer.class ||\n-                    toType == Long.class ||\n-                    toType == Float.class ||\n-                    toType == Double.class){\n-                return true;\n-            }\n-        }\n-        else if (object instanceof ExpressionContext){\n-            if (Collection.class.isAssignableFrom(toType)){\n-                return true;\n-            }\n-            Pointer pointer = ((ExpressionContext)object).getContextNodePointer();\n-            if (pointer != null){\n+        if (fromType.equals(toType)) {\n+            return true;\n+        }\n+\n+        if (toType.isAssignableFrom(fromType)) {\n+            return true;\n+        }\n+\n+        if (toType == String.class) {\n+            return true;\n+        }\n+\n+        if (object instanceof Boolean) {\n+            if (toType == boolean.class\n+                || Number.class.isAssignableFrom(toType)) {\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Number) {\n+            if (toType.isPrimitive()\n+                || Number.class.isAssignableFrom(toType)) {\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Character) {\n+            if (toType == char.class) {\n+                return true;\n+            }\n+        }\n+        else if (object instanceof String) {\n+            if (toType.isPrimitive()) {\n+                return true;\n+            }\n+            if (toType == Boolean.class\n+                || toType == Character.class\n+                || toType == Byte.class\n+                || toType == Short.class\n+                || toType == Integer.class\n+                || toType == Long.class\n+                || toType == Float.class\n+                || toType == Double.class) {\n+                return true;\n+            }\n+        }\n+        else if (object instanceof ExpressionContext) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n+                return true;\n+            }\n+            Pointer pointer =\n+                ((ExpressionContext) object).getContextNodePointer();\n+            if (pointer != null) {\n                 Object value = pointer.getValue();\n                 return canConvert(value, toType);\n             }\n         }\n-        else if (fromType.isArray()){\n+        else if (fromType.isArray()) {\n             // Collection -> array\n-            if (toType.isArray()){\n+            if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n                 int length = Array.getLength(object);\n-                for (int i = 0; i < length; i++){\n+                for (int i = 0; i < length; i++) {\n                     Object value = Array.get(object, i);\n-                    if (!canConvert(value, cType)){\n+                    if (!canConvert(value, cType)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)){\n+            else if (Collection.class.isAssignableFrom(toType)) {\n                 return canCreateCollection(toType);\n             }\n-            else if (Array.getLength(object) == 1){\n+            else if (Array.getLength(object) == 1) {\n                 Object value = Array.get(object, 0);\n                 return canConvert(value, toType);\n             }\n         }\n-        else if (object instanceof Collection){\n+        else if (object instanceof Collection) {\n             // Collection -> array\n-            if (toType.isArray()){\n+            if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n-                Iterator it = ((Collection)object).iterator();\n-                while (it.hasNext()){\n+                Iterator it = ((Collection) object).iterator();\n+                while (it.hasNext()) {\n                     Object value = it.next();\n-                    if (!canConvert(value, cType)){\n+                    if (!canConvert(value, cType)) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)){\n+            else if (Collection.class.isAssignableFrom(toType)) {\n                 return canCreateCollection(toType);\n             }\n-            else if (((Collection)object).size() == 1){\n+            else if (((Collection) object).size() == 1) {\n                 Object value;\n-                if (object instanceof List){\n-                    value = ((List)object).get(0);\n+                if (object instanceof List) {\n+                    value = ((List) object).get(0);\n                 }\n                 else {\n-                    Iterator it = ((Collection)object).iterator();\n+                    Iterator it = ((Collection) object).iterator();\n                     value = it.next();\n                 }\n                 return canConvert(value, toType);\n         }\n         return false;\n     }\n-\n     /**\n      * Converts the supplied object to the specified\n      * type. Throws a runtime exception if the conversion is\n      * not possible.\n      */\n-    public Object convert(Object object, Class toType){\n-        if (object == null){\n-            if (toType.isPrimitive()){\n-                if (toType == boolean.class){\n-                    return Boolean.FALSE;\n-                }\n-                if (toType == char.class){\n-                    return new Character('\\0');\n-                }\n-                if (toType == byte.class){\n-                    return new Byte((byte)0);\n-                }\n-                if (toType == short.class){\n-                    return new Short((short)0);\n-                }\n-                if (toType == int.class){\n-                    return new Integer(0);\n-                }\n-                if (toType == long.class){\n-                    return new Long(0l);\n-                }\n-                if (toType == float.class){\n-                    return new Float(0.0f);\n-                }\n-                if (toType == double.class){\n-                    return new Double(0.0);\n-                }\n+    public Object convert(Object object, Class toType) {\n+        if (object == null) {\n+            if (toType.isPrimitive()) {\n+                return convertNullToPrimitive(toType);\n             }\n             return null;\n         }\n \n-        if (toType == Object.class){\n+        if (toType == Object.class) {\n             return object;\n         }\n \n-        if (object instanceof ExpressionContext){\n-            if (Collection.class.isAssignableFrom(toType)){\n-                List list = ((ExpressionContext)object).getContextNodeList();\n+        if (object instanceof ExpressionContext) {\n+            if (Collection.class.isAssignableFrom(toType)) {\n+                List list = ((ExpressionContext) object).getContextNodeList();\n                 Collection result = new ArrayList();\n-                if (toType == List.class || toType == ArrayList.class){\n+                if (toType == List.class || toType == ArrayList.class) {\n                     result = new ArrayList();\n                 }\n-                else if (toType == Vector.class){\n+                else if (toType == Vector.class) {\n                     result = new Vector();\n                 }\n-                else if (toType == Set.class || toType == HashSet.class){\n+                else if (toType == Set.class || toType == HashSet.class) {\n                     result = new HashSet();\n                 }\n                 int count = list.size();\n-                for (int i = 0; i < count; i++){\n-                    Pointer ptr = (Pointer)list.get(i);\n+                for (int i = 0; i < count; i++) {\n+                    Pointer ptr = (Pointer) list.get(i);\n                     result.add(ptr.getValue());\n                 }\n                 return result;\n             }\n             else {\n-                Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n+                Object value =\n+                    ((ExpressionContext) object)\n+                        .getContextNodePointer()\n+                        .getValue();\n                 return convert(value, toType);\n             }\n         }\n \n         Class fromType = object.getClass();\n-        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)){\n+        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) {\n             return object;\n         }\n \n-        if (toType == String.class){\n+        if (toType == String.class) {\n             return object.toString();\n         }\n \n-        if (object instanceof Boolean){\n-            if (toType == boolean.class){\n+        if (object instanceof Boolean) {\n+            if (toType == boolean.class) {\n                 return object;\n             }\n-            boolean value = ((Boolean)object).booleanValue();\n+            boolean value = ((Boolean) object).booleanValue();\n             return allocateNumber(toType, value ? 1 : 0);\n         }\n-        else if (object instanceof Number){\n-            double value = ((Number)object).doubleValue();\n-            if (toType == boolean.class || toType == Boolean.class){\n+        else if (object instanceof Number) {\n+            double value = ((Number) object).doubleValue();\n+            if (toType == boolean.class || toType == Boolean.class) {\n                 return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n             }\n-            if (toType.isPrimitive() ||\n-                    Number.class.isAssignableFrom(toType)){\n+            if (toType.isPrimitive()\n+                || Number.class.isAssignableFrom(toType)) {\n                 return allocateNumber(toType, value);\n             }\n         }\n-        else if (object instanceof Character){\n-            if (toType == char.class){\n+        else if (object instanceof Character) {\n+            if (toType == char.class) {\n                 return object;\n             }\n         }\n-        else if (object instanceof String){\n-            if (toType == boolean.class || toType == Boolean.class){\n-                return Boolean.valueOf((String)object);\n-            }\n-            if (toType == char.class || toType == Character.class){\n-                return new Character(((String)object).charAt(0));\n-            }\n-            if (toType == byte.class || toType == Byte.class){\n-                return new Byte((String)object);\n-            }\n-            if (toType == short.class || toType == Short.class){\n-                return new Short((String)object);\n-            }\n-            if (toType == int.class || toType == Integer.class){\n-                return new Integer((String)object);\n-            }\n-            if (toType == long.class || toType == Long.class){\n-                return new Long((String)object);\n-            }\n-            if (toType == float.class || toType == Float.class){\n-                return new Float((String)object);\n-            }\n-            if (toType == double.class || toType == Double.class){\n-                return new Double((String)object);\n-            }\n-        }\n-        else if (fromType.isArray()){\n+        else if (object instanceof String) {\n+            Object value = convertStringToPrimitive(object, toType);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        else if (fromType.isArray()) {\n             int length = Array.getLength(object);\n-            if (toType.isArray()){\n+            if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n \n                 Object array = Array.newInstance(cType, length);\n-                for (int i = 0; i < length; i++){\n+                for (int i = 0; i < length; i++) {\n                     Object value = Array.get(object, i);\n                     Array.set(array, i, convert(value, cType));\n                 }\n                 return array;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)){\n+            else if (Collection.class.isAssignableFrom(toType)) {\n                 Collection collection = allocateCollection(toType);\n-                for (int i = 0; i < length; i++){\n+                for (int i = 0; i < length; i++) {\n                     collection.add(Array.get(object, i));\n                 }\n                 return collection;\n             }\n-            else if (length == 1){\n+            else if (length == 1) {\n                 Object value = Array.get(object, 0);\n                 return convert(value, toType);\n             }\n         }\n-        else if (object instanceof Collection){\n+        else if (object instanceof Collection) {\n             int length = ((Collection) object).size();\n-            if (toType.isArray()){\n+            if (toType.isArray()) {\n                 Class cType = toType.getComponentType();\n                 Object array = Array.newInstance(cType, length);\n                 Iterator it = ((Collection) object).iterator();\n-                for (int i = 0; i < length; i++){\n+                for (int i = 0; i < length; i++) {\n                     Object value = it.next();\n                     Array.set(array, i, convert(value, cType));\n                 }\n                 return array;\n             }\n-            else if (Collection.class.isAssignableFrom(toType)){\n+            else if (Collection.class.isAssignableFrom(toType)) {\n                 Collection collection = allocateCollection(toType);\n                 collection.addAll((Collection) object);\n                 return collection;\n             }\n-            else if (length == 1){\n+            else if (length == 1) {\n                 Object value;\n-                if (object instanceof List){\n-                    value = ((List)object).get(0);\n+                if (object instanceof List) {\n+                    value = ((List) object).get(0);\n                 }\n                 else {\n-                    Iterator it = ((Collection)object).iterator();\n+                    Iterator it = ((Collection) object).iterator();\n                     value = it.next();\n                 }\n                 return convert(value, toType);\n             }\n         }\n-        throw new RuntimeException(\"Cannot convert \" + object.getClass() +\n-                \" to \" + toType);\n-    }\n-\n-    private static Number allocateNumber(Class type, double value){\n-        if (type == Byte.class || type == byte.class){\n-            return new Byte((byte)value);\n-        }\n-        if (type == Short.class || type == short.class){\n-            return new Short((short)value);\n-        }\n-        if (type == Integer.class || type == int.class){\n-            return new Integer((int)value);\n-        }\n-        if (type == Long.class || type == long.class){\n-            return new Long((long)value);\n-        }\n-        if (type == Float.class || type == float.class){\n-            return new Float((float)value);\n-        }\n-        if (type == Double.class || type == double.class){\n+        throw new RuntimeException(\n+            \"Cannot convert \" + object.getClass() + \" to \" + toType);\n+    }\n+\n+    private Object convertNullToPrimitive(Class toType) {\n+        if (toType == boolean.class) {\n+            return Boolean.FALSE;\n+        }\n+        if (toType == char.class) {\n+            return new Character('\\0');\n+        }\n+        if (toType == byte.class) {\n+            return new Byte((byte) 0);\n+        }\n+        if (toType == short.class) {\n+            return new Short((short) 0);\n+        }\n+        if (toType == int.class) {\n+            return new Integer(0);\n+        }\n+        if (toType == long.class) {\n+            return new Long(0L);\n+        }\n+        if (toType == float.class) {\n+            return new Float(0.0f);\n+        }\n+        if (toType == double.class) {\n+            return new Double(0.0);\n+        }\n+        return null;\n+    }\n+\n+    private Object convertStringToPrimitive(Object object, Class toType) {\n+        if (toType == boolean.class || toType == Boolean.class) {\n+            return Boolean.valueOf((String) object);\n+        }\n+        if (toType == char.class || toType == Character.class) {\n+            return new Character(((String) object).charAt(0));\n+        }\n+        if (toType == byte.class || toType == Byte.class) {\n+            return new Byte((String) object);\n+        }\n+        if (toType == short.class || toType == Short.class) {\n+            return new Short((String) object);\n+        }\n+        if (toType == int.class || toType == Integer.class) {\n+            return new Integer((String) object);\n+        }\n+        if (toType == long.class || toType == Long.class) {\n+            return new Long((String) object);\n+        }\n+        if (toType == float.class || toType == Float.class) {\n+            return new Float((String) object);\n+        }\n+        if (toType == double.class || toType == Double.class) {\n+            return new Double((String) object);\n+        }\n+        return null;\n+    }\n+    \n+    private static Number allocateNumber(Class type, double value) {\n+        if (type == Byte.class || type == byte.class) {\n+            return new Byte((byte) value);\n+        }\n+        if (type == Short.class || type == short.class) {\n+            return new Short((short) value);\n+        }\n+        if (type == Integer.class || type == int.class) {\n+            return new Integer((int) value);\n+        }\n+        if (type == Long.class || type == long.class) {\n+            return new Long((long) value);\n+        }\n+        if (type == Float.class || type == float.class) {\n+            return new Float((float) value);\n+        }\n+        if (type == Double.class || type == double.class) {\n             return new Double(value);\n         }\n         return null;\n     }\n \n-    private static boolean canCreateCollection(Class type){\n-        if (!type.isInterface() && ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n-            return true;\n-        }\n-\n-        if (type == List.class){\n-            return true;\n-        }\n-\n-        if (type == Set.class){\n+    private static boolean canCreateCollection(Class type) {\n+        if (!type.isInterface()\n+            && ((type.getModifiers() | Modifier.ABSTRACT) == 0)) {\n+            return true;\n+        }\n+\n+        if (type == List.class) {\n+            return true;\n+        }\n+\n+        if (type == Set.class) {\n             return true;\n         }\n         return false;\n     }\n \n-    private static Collection allocateCollection(Class type){\n-        if (!type.isInterface() &&\n-                ((type.getModifiers() | Modifier.ABSTRACT) == 0)){\n+    private static Collection allocateCollection(Class type) {\n+        if (!type.isInterface()\n+            && ((type.getModifiers() | Modifier.ABSTRACT) == 0)) {\n             try {\n-                return (Collection)type.newInstance();\n-            }\n-            catch(Exception ex){\n-                throw new JXPathException(\"Cannot create collection of type: \"\n-                        + type, ex);\n-            }\n-        }\n-\n-        if (type == List.class){\n+                return (Collection) type.newInstance();\n+            }\n+            catch (Exception ex) {\n+                throw new JXPathException(\n+                    \"Cannot create collection of type: \" + type,\n+                    ex);\n+            }\n+        }\n+\n+        if (type == List.class) {\n             return new ArrayList();\n         }\n-        if (type == Set.class){\n+        if (type == Set.class) {\n             return new HashSet();\n         }\n         throw new RuntimeException(\"Cannot create collection of type: \" + type);\n--- a/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java,v 1.2 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/MethodLookupUtils.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * as constructors based on a name and list of parameters.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class MethodLookupUtils {\n \n     private static final int EXACT_MATCH = 2;\n     private static final Object[] EMPTY_ARRAY = new Object[0];\n \n-    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n+     public static Constructor lookupConstructor(\n+        Class targetClass,\n+        Object[] parameters) \n+     {\n         boolean tryExact = true;\n         int count = parameters.length;\n         Class types[] = new Class[count];\n-        for (int i = 0; i < count; i++){\n+        for (int i = 0; i < count; i++) {\n             Object param = parameters[i];\n-            if (param != null){\n+            if (param != null) {\n                 types[i] = param.getClass();\n             }\n             else {\n \n         Constructor constructor = null;\n \n-        if (tryExact){\n+        if (tryExact) {\n             // First - without type conversion\n             try {\n                 constructor = targetClass.getConstructor(types);\n-                if (constructor != null){\n+                if (constructor != null) {\n                     return constructor;\n                 }\n             }\n-            catch (NoSuchMethodException ex){\n+            catch (NoSuchMethodException ex) {\n+                // Ignore\n             }\n         }\n \n \n         // Then - with type conversion\n         Constructor[] constructors = targetClass.getConstructors();\n-        for (int i = 0; i < constructors.length; i++){\n-            int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters);\n-            if (match != NO_MATCH){\n-                if (match > currentMatch){\n+        for (int i = 0; i < constructors.length; i++) {\n+            int match =\n+                matchParameterTypes(\n+                    constructors[i].getParameterTypes(),\n+                    parameters);\n+            if (match != NO_MATCH) {\n+                if (match > currentMatch) {\n                     constructor = constructors[i];\n                     currentMatch = match;\n                     ambiguous = false;\n                 }\n-                else if (match == currentMatch){\n+                else if (match == currentMatch) {\n                     ambiguous = true;\n                 }\n             }\n         }\n-        if (ambiguous){\n-            throw new JXPathException(\"Ambigous constructor \" + Arrays.asList(parameters));\n+        if (ambiguous) {\n+            throw new JXPathException(\n+                \"Ambigous constructor \" + Arrays.asList(parameters));\n         }\n         return constructor;\n     }\n \n-    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n+    public static Method lookupStaticMethod(\n+        Class targetClass,\n+        String name,\n+        Object[] parameters) \n+    {\n         boolean tryExact = true;\n         int count = parameters.length;\n         Class types[] = new Class[count];\n-        for (int i = 0; i < count; i++){\n+        for (int i = 0; i < count; i++) {\n             Object param = parameters[i];\n-            if (param != null){\n+            if (param != null) {\n                 types[i] = param.getClass();\n             }\n             else {\n \n         Method method = null;\n \n-        if (tryExact){\n+        if (tryExact) {\n             // First - without type conversion\n             try {\n                 method = targetClass.getMethod(name, types);\n-                if (method != null && Modifier.isStatic(method.getModifiers())){\n+                if (method != null\n+                    && Modifier.isStatic(method.getModifiers())) {\n                     return method;\n                 }\n             }\n-            catch (NoSuchMethodException ex){\n+            catch (NoSuchMethodException ex) {\n+                // Ignore\n             }\n         }\n \n \n         // Then - with type conversion\n         Method[] methods = targetClass.getMethods();\n-        for (int i = 0; i < methods.length; i++){\n-            if (Modifier.isStatic(methods[i].getModifiers()) &&\n-                    methods[i].getName().equals(name)){\n-                int match = matchParameterTypes(methods[i].getParameterTypes(), parameters);\n-                if (match != NO_MATCH){\n-                    if (match > currentMatch){\n+        for (int i = 0; i < methods.length; i++) {\n+            if (Modifier.isStatic(methods[i].getModifiers())\n+                && methods[i].getName().equals(name)) {\n+                int match =\n+                    matchParameterTypes(\n+                        methods[i].getParameterTypes(),\n+                        parameters);\n+                if (match != NO_MATCH) {\n+                    if (match > currentMatch) {\n                         method = methods[i];\n                         currentMatch = match;\n                         ambiguous = false;\n                     }\n-                    else if (match == currentMatch){\n+                    else if (match == currentMatch) {\n                         ambiguous = true;\n                     }\n                 }\n             }\n         }\n-        if (ambiguous){\n+        if (ambiguous) {\n             throw new JXPathException(\"Ambigous method call: \" + name);\n         }\n         return method;\n     }\n \n-    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n-        if (parameters.length < 1 || parameters[0] == null){\n+    public static Method lookupMethod(\n+        Class targetClass,\n+        String name,\n+        Object[] parameters) \n+    {\n+        if (parameters.length < 1 || parameters[0] == null) {\n             return null;\n         }\n \n-        if (matchType(targetClass, parameters[0]) == NO_MATCH){\n+        if (matchType(targetClass, parameters[0]) == NO_MATCH) {\n             return null;\n         }\n \n         int count = parameters.length - 1;\n         Class types[] = new Class[count];\n         Object arguments[] = new Object[count];\n-        for (int i = 0; i < count; i++){\n-            Object param = parameters[i+1];\n+        for (int i = 0; i < count; i++) {\n+            Object param = parameters[i + 1];\n             arguments[i] = param;\n-            if (param != null){\n+            if (param != null) {\n                 types[i] = param.getClass();\n             }\n             else {\n \n         Method method = null;\n \n-        if (tryExact){\n+        if (tryExact) {\n             // First - without type conversion\n             try {\n                 method = targetClass.getMethod(name, types);\n-                if (method != null && !Modifier.isStatic(method.getModifiers())){\n+                if (method != null\n+                    && !Modifier.isStatic(method.getModifiers())) {\n                     return method;\n                 }\n             }\n-            catch (NoSuchMethodException ex){\n+            catch (NoSuchMethodException ex) {\n+                // Ignore\n             }\n         }\n \n \n         // Then - with type conversion\n         Method[] methods = targetClass.getMethods();\n-        for (int i = 0; i < methods.length; i++){\n-            if (!Modifier.isStatic(methods[i].getModifiers()) &&\n-                    methods[i].getName().equals(name)){\n-                int match = matchParameterTypes(methods[i].getParameterTypes(), arguments);\n-                if (match != NO_MATCH){\n-                    if (match > currentMatch){\n+        for (int i = 0; i < methods.length; i++) {\n+            if (!Modifier.isStatic(methods[i].getModifiers())\n+                && methods[i].getName().equals(name)) {\n+                int match =\n+                    matchParameterTypes(\n+                        methods[i].getParameterTypes(),\n+                        arguments);\n+                if (match != NO_MATCH) {\n+                    if (match > currentMatch) {\n                         method = methods[i];\n                         currentMatch = match;\n                         ambiguous = false;\n                     }\n-                    else if (match == currentMatch){\n+                    else if (match == currentMatch) {\n                         ambiguous = true;\n                     }\n                 }\n             }\n         }\n-        if (ambiguous){\n+        if (ambiguous) {\n             throw new JXPathException(\"Ambigous method call: \" + name);\n         }\n         return method;\n     }\n \n-    private static int matchParameterTypes(Class types[], Object parameters[]){\n+    private static int matchParameterTypes(\n+        Class types[],\n+        Object parameters[]) \n+    {\n         int pi = 0;\n-        if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+        if (types.length >= 1\n+            && ExpressionContext.class.isAssignableFrom(types[0])) {\n             pi++;\n         }\n-        if (types.length != parameters.length + pi){\n+        if (types.length != parameters.length + pi) {\n             return NO_MATCH;\n         }\n         int totalMatch = EXACT_MATCH;\n-        for (int i = 0; i < parameters.length; i++){\n+        for (int i = 0; i < parameters.length; i++) {\n             int match = matchType(types[i + pi], parameters[i]);\n-            if (match == NO_MATCH){\n+            if (match == NO_MATCH) {\n                 return NO_MATCH;\n             }\n-            if (match < totalMatch){\n+            if (match < totalMatch) {\n                 totalMatch = match;\n             }\n         }\n         return totalMatch;\n     }\n \n-    private static int matchType(Class expected, Object object){\n-        if (object == null){\n+    private static int matchType(Class expected, Object object) {\n+        if (object == null) {\n             return APPROXIMATE_MATCH;\n         }\n \n         Class actual = object.getClass();\n \n-        if (expected.equals(actual)){\n+        if (expected.equals(actual)) {\n             return EXACT_MATCH;\n         }\n-        if (expected.isAssignableFrom(actual)){\n+        if (expected.isAssignableFrom(actual)) {\n             return EXACT_MATCH;\n         }\n \n-        if (TypeUtils.canConvert(object, expected)){\n+        if (TypeUtils.canConvert(object, expected)) {\n             return APPROXIMATE_MATCH;\n         }\n \n--- a/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.9 2002/11/26 01:20:07 dmitri Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/11/26 01:20:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.10 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Global type conversion utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.9 $ $Date: 2002/11/26 01:20:07 $\n+ * @version $Revision: 1.10 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TypeUtils {\n     private static TypeConverter typeConverter = new BasicTypeConverter();\n     /**\n      * Install an alternative type converter.\n      */\n-    public static synchronized void setTypeConverter(TypeConverter converter){\n+    public static synchronized void setTypeConverter(TypeConverter converter) {\n         typeConverter = converter;\n     }\n \n     /**\n      * Returns the current type converter.\n      */\n-    public static TypeConverter getTypeConverter(){\n+    public static TypeConverter getTypeConverter() {\n         return typeConverter;\n     }\n \n      * Returns true if the global converter can convert the supplied\n      * object to the specified type.\n      */\n-    public static boolean canConvert(Object object, Class toType){\n+    public static boolean canConvert(Object object, Class toType) {\n         return typeConverter.canConvert(object, toType);\n     }\n \n      * Converts the supplied object to the specified type. May\n      * throw a RuntimeException.\n      */\n-    public static Object convert(Object object, Class toType){\n+    public static Object convert(Object object, Class toType) {\n         return typeConverter.convert(object, toType);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.11 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.12 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.Array;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n \n import org.apache.commons.jxpath.DynamicPropertyHandler;\n import org.apache.commons.jxpath.JXPathException;\n  * Collection and property access utilities.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.12 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class ValueUtils {\n     private static Map dynamicPropertyHandlerMap = new HashMap();\n     /**\n      * Returns true if the object is an array or a Collection\n      */\n-    public static boolean isCollection(Object value){\n-        if (value == null){\n+    public static boolean isCollection(Object value) {\n+        if (value == null) {\n             return false;\n         }\n-        else if (value.getClass().isArray()){\n+        else if (value.getClass().isArray()) {\n             return true;\n         }\n-        else if (value instanceof Collection){\n+        else if (value instanceof Collection) {\n             return true;\n         }\n         return false;\n      * -1 if it is definitely not\n      * and 0 if it may be a collection in some cases.\n      */\n-    public static int getCollectionHint(Class clazz){\n-        if (clazz.isArray()){\n+    public static int getCollectionHint(Class clazz) {\n+        if (clazz.isArray()) {\n             return 1;\n         }\n         \n-        if (Collection.class.isAssignableFrom(clazz)){\n+        if (Collection.class.isAssignableFrom(clazz)) {\n             return 1;\n         }\n         \n-        if (clazz.isPrimitive()){\n+        if (clazz.isPrimitive()) {\n             return -1;\n         }\n         \n-        if (clazz.isInterface()){\n+        if (clazz.isInterface()) {\n             return 0;\n         }\n         \n-        if (Modifier.isFinal(clazz.getModifiers())){\n+        if (Modifier.isFinal(clazz.getModifiers())) {\n             return -1;\n         }\n                 \n      * Returns the length of the supplied collection. If the supplied object\n      * is not a collection, returns 1. If collection is null, returns 0.\n      */\n-    public static int getLength(Object collection){\n-        if (collection == null){\n+    public static int getLength(Object collection) {\n+        if (collection == null) {\n             return 0;\n         }\n-        else if (collection.getClass().isArray()){\n+        else if (collection.getClass().isArray()) {\n             return Array.getLength(collection);\n         }\n-        else if (collection instanceof Collection){\n-            return ((Collection)collection).size();\n+        else if (collection instanceof Collection) {\n+            return ((Collection) collection).size();\n         }\n         else {\n             return 1;\n      * is null, returns an empty iterator. If the argument is not\n      * a collection, returns an iterator that produces just that one object.\n      */\n-    public static Iterator iterate(Object collection){\n-        if (collection == null){\n+    public static Iterator iterate(Object collection) {\n+        if (collection == null) {\n             return Collections.EMPTY_LIST.iterator();\n         }\n-        if (collection.getClass().isArray()){\n+        if (collection.getClass().isArray()) {\n             int length = Array.getLength(collection);\n-            if (length == 0){\n+            if (length == 0) {\n                 return Collections.EMPTY_LIST.iterator();\n             }\n             ArrayList list = new ArrayList();\n-            for (int i = 0; i < length; i++){\n+            for (int i = 0; i < length; i++) {\n                 list.add(Array.get(collection, i));\n             }\n             return list.iterator();\n         }\n-        else if (collection instanceof Collection){\n-            return ((Collection)collection).iterator();\n+        else if (collection instanceof Collection) {\n+            return ((Collection) collection).iterator();\n         }\n         else {\n             return Collections.singletonList(collection).iterator();\n      * Grows the collection if necessary to the specified size. Returns\n      * the new, expanded collection.\n      */\n-    public static Object expandCollection(Object collection, int size){\n-        if (collection == null){\n+    public static Object expandCollection(Object collection, int size) {\n+        if (collection == null) {\n             return null;\n         }\n-        else if (collection.getClass().isArray()){\n-            Object bigger = Array.newInstance(\n-                  collection.getClass().getComponentType(), size);\n+        else if (collection.getClass().isArray()) {\n+            Object bigger =\n+                Array.newInstance(\n+                    collection.getClass().getComponentType(),\n+                    size);\n             System.arraycopy(\n-                  collection, 0, bigger, 0, Array.getLength(collection));\n+                collection,\n+                0,\n+                bigger,\n+                0,\n+                Array.getLength(collection));\n             return bigger;\n         }\n-        else if (collection instanceof Collection){\n-            while (((Collection)collection).size() < size){\n-                ((Collection)collection).add(null);\n+        else if (collection instanceof Collection) {\n+            while (((Collection) collection).size() < size) {\n+                ((Collection) collection).add(null);\n             }\n             return collection;\n         }\n         else {\n-            throw new JXPathException(\"Cannot turn \" + collection.getClass().getName() +\n-                    \" into a collection of size \" + size);\n+            throw new JXPathException(\n+                \"Cannot turn \"\n+                    + collection.getClass().getName()\n+                    + \" into a collection of size \"\n+                    + size);\n         }\n     }\n \n     /**\n      * Returns the index'th element from the supplied collection.\n      */\n-    public static Object remove(Object collection, int index){\n-        if (collection == null){\n+    public static Object remove(Object collection, int index) {\n+        if (collection == null) {\n             return null;\n         }\n-        else if (collection.getClass().isArray()){\n+        else if (collection.getClass().isArray()) {\n             int length = Array.getLength(collection);\n-            Object smaller = Array.newInstance(\n-                  collection.getClass().getComponentType(), length-1);\n-            if (index > 0){\n+            Object smaller =\n+                Array.newInstance(\n+                    collection.getClass().getComponentType(),\n+                    length - 1);\n+            if (index > 0) {\n                 System.arraycopy(collection, 0, smaller, 0, index);\n             }\n-            if (index < length - 1){\n-                System.arraycopy(collection, index + 1, smaller,\n-                        index, length - index - 1);\n+            if (index < length - 1) {\n+                System.arraycopy(\n+                    collection,\n+                    index + 1,\n+                    smaller,\n+                    index,\n+                    length - index - 1);\n             }\n             return smaller;\n         }\n-        else if (collection instanceof List){\n-            int size = ((List)collection).size();\n-            if (index < size){\n-                ((List)collection).remove(index);\n+        else if (collection instanceof List) {\n+            int size = ((List) collection).size();\n+            if (index < size) {\n+                ((List) collection).remove(index);\n             }\n             return collection;\n         }\n-        else if (collection instanceof Collection){\n-            Iterator it = ((Collection)collection).iterator();\n-            for (int i = 0; i < index; i++){\n-                if (!it.hasNext()){\n+        else if (collection instanceof Collection) {\n+            Iterator it = ((Collection) collection).iterator();\n+            for (int i = 0; i < index; i++) {\n+                if (!it.hasNext()) {\n                     break;\n                 }\n                 it.next();\n             }\n-            if (it.hasNext()){\n+            if (it.hasNext()) {\n                 it.next();\n                 it.remove();\n             }\n             return collection;\n         }\n         else {\n-            throw new JXPathException(\"Cannot remove \" +\n-                    collection.getClass().getName() + \"[\" + index + \"]\");\n+            throw new JXPathException(\n+                \"Cannot remove \"\n+                    + collection.getClass().getName()\n+                    + \"[\"\n+                    + index\n+                    + \"]\");\n         }\n     }\n \n     /**\n      * Returns the index'th element of the supplied collection.\n      */\n-    public static Object getValue(Object collection, int index){\n+    public static Object getValue(Object collection, int index) {\n         Object value = collection;\n-        if (collection != null){\n-            if (collection.getClass().isArray()){\n-                if (index < 0 || index >= Array.getLength(collection)){\n+        if (collection != null) {\n+            if (collection.getClass().isArray()) {\n+                if (index < 0 || index >= Array.getLength(collection)) {\n                     return null;\n                 }\n                 value = Array.get(collection, index);\n             }\n-            else if (collection instanceof List){\n-                if (index < 0 || index >= ((List)collection).size()){\n+            else if (collection instanceof List) {\n+                if (index < 0 || index >= ((List) collection).size()) {\n                     return null;\n                 }\n-                value = ((List)collection).get(index);\n-            }\n-            else if (collection instanceof Collection){\n+                value = ((List) collection).get(index);\n+            }\n+            else if (collection instanceof Collection) {\n                 int i = 0;\n-                Iterator it = ((Collection)collection).iterator();\n-                for (; i < index; i++){\n+                Iterator it = ((Collection) collection).iterator();\n+                for (; i < index; i++) {\n                     it.next();\n                 }\n-                if (it.hasNext()){\n+                if (it.hasNext()) {\n                     value = it.next();\n                 }\n                 else {\n      * Modifies the index'th element of the supplied collection.\n      * Converts the value to the required type if necessary.\n      */\n-    public static void setValue(Object collection, int index, Object value){\n-        if (collection != null){\n-            if (collection.getClass().isArray()){\n-                Array.set(collection, index,\n+    public static void setValue(Object collection, int index, Object value) {\n+        if (collection != null) {\n+            if (collection.getClass().isArray()) {\n+                Array.set(\n+                    collection,\n+                    index,\n                     convert(value, collection.getClass().getComponentType()));\n             }\n-            else if (collection instanceof List){\n-                ((List)collection).set(index, value);\n-            }\n-            else if (collection instanceof Collection){\n+            else if (collection instanceof List) {\n+                ((List) collection).set(index, value);\n+            }\n+            else if (collection instanceof Collection) {\n                 throw new UnsupportedOperationException(\n-                        \"Cannot set value of an element of a \" +\n-                        collection.getClass().getName());\n+                    \"Cannot set value of an element of a \"\n+                        + collection.getClass().getName());\n             }\n         }\n     }\n      * Returns the value of the bean's property represented by\n      * the supplied property descriptor.\n      */\n-    public static Object getValue(Object bean,\n-                    PropertyDescriptor propertyDescriptor){\n+    public static Object getValue(\n+        Object bean,\n+        PropertyDescriptor propertyDescriptor) \n+    {\n         Object value;\n         try {\n             Method method =\n                 getAccessibleMethod(propertyDescriptor.getReadMethod());\n-            if (method == null){\n+            if (method == null) {\n                 throw new JXPathException(\"No read method\");\n             }\n             value = method.invoke(bean, new Object[0]);\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             throw new JXPathException(\n-                \"Cannot access property: \" +\n-                    (bean == null ? \"null\" : bean.getClass().getName()) +\n-                    \".\" + propertyDescriptor.getName(), ex);\n+                \"Cannot access property: \"\n+                    + (bean == null ? \"null\" : bean.getClass().getName())\n+                    + \".\"\n+                    + propertyDescriptor.getName(),\n+                ex);\n         }\n         return value;\n     }\n      * Modifies the value of the bean's property represented by\n      * the supplied property descriptor.\n      */\n-    public static void setValue(Object bean,\n-            PropertyDescriptor propertyDescriptor, Object value){\n+    public static void setValue(\n+        Object bean,\n+        PropertyDescriptor propertyDescriptor,\n+        Object value) \n+    {\n         try {\n             Method method =\n                 getAccessibleMethod(propertyDescriptor.getWriteMethod());\n-            if (method == null){\n+            if (method == null) {\n                 throw new JXPathException(\"No write method\");\n             }\n             value = convert(value, propertyDescriptor.getPropertyType());\n-            value = method.invoke(bean, new Object[]{value});\n-        }\n-        catch (Exception ex){\n+            value = method.invoke(bean, new Object[] { value });\n+        }\n+        catch (Exception ex) {\n             throw new JXPathException(\n-                \"Cannot modify property: \" +\n-                    (bean == null ? \"null\" : bean.getClass().getName()) +\n-                    \".\" + propertyDescriptor.getName(), ex);\n-        }\n-    }\n-\n-    private static Object convert(Object value, Class type){\n+                \"Cannot modify property: \"\n+                    + (bean == null ? \"null\" : bean.getClass().getName())\n+                    + \".\"\n+                    + propertyDescriptor.getName(),\n+                ex);\n+        }\n+    }\n+\n+    private static Object convert(Object value, Class type) {\n         try {\n             return TypeUtils.convert(value, type);\n         }\n-        catch (Exception ex){\n-            throw new JXPathException(\"Cannot convert value of class \" +\n-                    (value == null ? \"null\" : value.getClass().getName()) +\n-                    \" to type \" + type, ex);\n+        catch (Exception ex) {\n+            throw new JXPathException(\n+                \"Cannot convert value of class \"\n+                    + (value == null ? \"null\" : value.getClass().getName())\n+                    + \" to type \"\n+                    + type,\n+                ex);\n         }\n     }\n \n      * Returns the index'th element of the bean's property represented by\n      * the supplied property descriptor.\n      */\n-    public static Object getValue(Object bean,\n-            PropertyDescriptor propertyDescriptor, int index){\n-        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+    public static Object getValue(\n+        Object bean,\n+        PropertyDescriptor propertyDescriptor,\n+        int index) \n+    {\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n                 IndexedPropertyDescriptor ipd =\n-                    (IndexedPropertyDescriptor)propertyDescriptor;\n+                    (IndexedPropertyDescriptor) propertyDescriptor;\n                 Method method = ipd.getIndexedReadMethod();\n-                if (method != null){\n-                    return method.invoke(bean, new Object[]{new Integer(index)});\n-                }\n-            }\n-            catch (Exception ex){\n+                if (method != null) {\n+                    return method.invoke(\n+                        bean,\n+                        new Object[] { new Integer(index)});\n+                }\n+            }\n+            catch (Exception ex) {\n                 throw new JXPathException(\n                     \"Cannot access property: \" + propertyDescriptor.getName(),\n                     ex);\n      * the supplied property descriptor. Converts the value to the required\n      * type if necessary.\n      */\n-    public static void setValue(Object bean,\n-              PropertyDescriptor propertyDescriptor, int index, Object value){\n-        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+    public static void setValue(\n+        Object bean,\n+        PropertyDescriptor propertyDescriptor,\n+        int index,\n+        Object value) \n+    {\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor) {\n             try {\n                 IndexedPropertyDescriptor ipd =\n-                      (IndexedPropertyDescriptor)propertyDescriptor;\n+                    (IndexedPropertyDescriptor) propertyDescriptor;\n                 Method method = ipd.getIndexedWriteMethod();\n-                if (method != null){\n-                    method.invoke(bean,\n-                        new Object[]{new Integer(index),\n-                                     convert(value, ipd.getIndexedPropertyType())});\n+                if (method != null) {\n+                    method.invoke(\n+                        bean,\n+                        new Object[] {\n+                            new Integer(index),\n+                            convert(value, ipd.getIndexedPropertyType())});\n                     return;\n                 }\n             }\n-            catch (Exception ex){\n-                throw new RuntimeException(\"Cannot access property: \" +\n-                    propertyDescriptor.getName() + \", \" + ex.getMessage());\n+            catch (Exception ex) {\n+                ex.printStackTrace();\n+                throw new RuntimeException(\n+                    \"Cannot access property: \"\n+                        + propertyDescriptor.getName()\n+                        + \", \"\n+                        + ex.getMessage());\n             }\n         }\n         // We will fall through if there is no indexed read\n         Object collection = getValue(bean, propertyDescriptor);\n-        if (isCollection(collection)){\n+        if (isCollection(collection)) {\n             setValue(collection, index, value);\n         }\n-        else if (index == 0){\n+        else if (index == 0) {\n             setValue(bean, propertyDescriptor, value);\n         }\n         else {\n-            throw new RuntimeException(\"Not a collection: \" + propertyDescriptor.getName());\n+            throw new RuntimeException(\n+                \"Not a collection: \" + propertyDescriptor.getName());\n         }\n     }\n \n      * Returns a shared instance of the dynamic property handler class\n      * returned by <code>getDynamicPropertyHandlerClass()</code>.\n      */\n-    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz){\n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) \n+    {\n         DynamicPropertyHandler handler =\n-            (DynamicPropertyHandler)dynamicPropertyHandlerMap.get(clazz);\n-        if (handler == null){\n+            (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz);\n+        if (handler == null) {\n             try {\n-                handler = (DynamicPropertyHandler)clazz.newInstance();\n-            }\n-            catch (Exception ex){\n+                handler = (DynamicPropertyHandler) clazz.newInstance();\n+            }\n+            catch (Exception ex) {\n                 throw new JXPathException(\n                     \"Cannot allocate dynamic property handler of class \"\n-                    + clazz.getName(), ex);\n+                        + clazz.getName(),\n+                    ex);\n             }\n             dynamicPropertyHandlerMap.put(clazz, handler);\n         }\n      * @param methodName Method name of the method we wish to call\n      * @param parameterTypes The parameter type signatures\n      */\n-    private static Method getAccessibleMethodFromInterfaceNest\n-        (Class clazz, String methodName, Class parameterTypes[]) {\n+    private static Method getAccessibleMethodFromInterfaceNest(\n+        Class clazz,\n+        String methodName,\n+        Class parameterTypes[]) \n+    {\n \n         Method method = null;\n \n         for (int i = 0; i < interfaces.length; i++) {\n \n             // Is this interface public?\n-            if (!Modifier.isPublic(interfaces[i].getModifiers()))\n+            if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n                 continue;\n+            }\n \n             // Does the method exist on this interface?\n             try {\n-                method = interfaces[i].getDeclaredMethod(methodName,\n-                                                         parameterTypes);\n-            } catch (NoSuchMethodException e) {\n+                method =\n+                    interfaces[i].getDeclaredMethod(methodName, parameterTypes);\n+            }\n+            catch (NoSuchMethodException e) {\n                 ;\n             }\n-            if (method != null)\n+            if (method != null) {\n                 break;\n-\n+            }\n+            \n             // Recursively check our parent interfaces\n             method =\n-                getAccessibleMethodFromInterfaceNest(interfaces[i],\n-                                                     methodName,\n-                                                     parameterTypes);\n-            if (method != null)\n+                getAccessibleMethodFromInterfaceNest(\n+                    interfaces[i],\n+                    methodName,\n+                    parameterTypes);\n+            if (method != null) {\n                 break;\n-\n+            }\n         }\n \n         // Return whatever we have found\n--- a/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DOMParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DOMParser.java,v 1.1 2002/08/10 01:28:49 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/10 01:28:49 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DOMParser.java,v 1.2 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An implementation of the XMLParser interface that produces a DOM Document.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/10 01:28:49 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class DOMParser implements XMLParser {\n \n-    public Object parseXML(InputStream stream){\n+    public Object parseXML(InputStream stream) {\n         try {\n             DocumentBuilderFactory factory =\n                     DocumentBuilderFactory.newInstance();\n             return factory.newDocumentBuilder().parse(stream);\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             throw new JXPathException(\"DOM parser error\", ex);\n         }\n     }\n--- a/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n+++ b/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java,v 1.3 2002/08/26 22:52:09 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/08/26 22:52:09 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/DocumentContainer.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * read at all.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/08/26 22:52:09 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class DocumentContainer implements Container {\n \n      * Use getClass().getResource(resourceName) to load XML from a\n      * resource file.\n      */\n-    public DocumentContainer(URL xmlURL){\n+    public DocumentContainer(URL xmlURL) {\n         this(xmlURL, MODEL_DOM);\n     }\n \n     /**\n-     * @param URL is a URL for an XML file. Use getClass().getResource(resourceName)\n-     * to load XML from a resource file.\n+     * @param  URL is a URL for an XML file. Use getClass().getResource\n+     * (resourceName) to load XML from a resource file.\n      *\n      * @param model is one of the MODEL_* constants defined in this class. It\n      *   determines which parser should be used to load the XML.\n      */\n-    public DocumentContainer(URL xmlURL, String model){\n+    public DocumentContainer(URL xmlURL, String model) {\n         this.xmlURL = xmlURL;\n-        if (xmlURL == null){\n+        if (xmlURL == null) {\n             throw new JXPathException(\"XML URL is null\");\n         }\n         this.model = model;\n     /**\n      * Reads XML, caches it internally and returns the Document.\n      */\n-    public Object getValue(){\n-        if (document == null){\n+    public Object getValue() {\n+        if (document == null) {\n             try {\n                 InputStream stream = null;\n                 try {\n-                    if (xmlURL != null){\n+                    if (xmlURL != null) {\n                         stream = xmlURL.openStream();\n                     }\n                     document = getParser(model).parseXML(stream);\n                 }\n                 finally {\n-                    if (stream != null){\n+                    if (stream != null) {\n                         stream.close();\n                     }\n                 }\n             }\n-            catch (Exception ex){\n+            catch (Exception ex) {\n                 throw new JXPathException(\n                     \"Cannot read XML from: \" + xmlURL.toString(),\n                     ex);\n     /**\n      * Throws an UnsupportedOperationException\n      */\n-    public void setValue(Object value){\n+    public void setValue(Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n     /**\n      * Maps a model type to a parser.\n      */\n-    private static final XMLParser getParser(String model){\n-        XMLParser parser = (XMLParser)parsers.get(model);\n-        if (parser == null){\n-            String className = (String)parserClasses.get(model);\n-            if (className == null){\n+    private static final XMLParser getParser(String model) {\n+        XMLParser parser = (XMLParser) parsers.get(model);\n+        if (parser == null) {\n+            String className = (String) parserClasses.get(model);\n+            if (className == null) {\n                 throw new JXPathException(\"Unsupported XML model: \" + model);\n             }\n             try {\n                 Class clazz = Class.forName(className);\n-                parser = (XMLParser)clazz.newInstance();\n+                parser = (XMLParser) clazz.newInstance();\n             }\n-            catch (Exception ex){\n-                throw new JXPathException(\"Cannot allocate XMLParser: \" +\n-                        className);\n+            catch (Exception ex) {\n+                throw new JXPathException(\n+                    \"Cannot allocate XMLParser: \" + className);\n             }\n             parsers.put(model, parser);\n         }\n--- a/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n+++ b/src/java/org/apache/commons/jxpath/xml/JDOMParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/JDOMParser.java,v 1.1 2002/08/26 22:29:49 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/08/26 22:29:49 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/xml/JDOMParser.java,v 1.2 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * An implementation of the XMLParser interface that produces a JDOM Document.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/08/26 22:29:49 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class JDOMParser implements XMLParser {\n \n-    public Object parseXML(InputStream stream){\n+    public Object parseXML(InputStream stream) {\n         try {\n             SAXBuilder builder = new SAXBuilder();\n             return builder.build(stream);\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             throw new JXPathException(\"JDOM parser error\", ex);\n         }\n     }\n--- a/src/test/org/apache/commons/jxpath/TestBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.3 2002/10/20 03:48:21 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/20 03:48:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.*;\n \n+import org.apache.commons.jxpath.util.ValueUtils;\n+\n /**\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/10/20 03:48:21 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TestBean {\n \n     }\n \n     public void setIntegers(int index, int value){\n+        if (index >= array.length){\n+            array = (int[])ValueUtils.expandCollection(array, index + 1);\n+        }\n         array[index] = value;\n     }\n \n--- a/src/test/org/apache/commons/jxpath/TestMixedModelBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestMixedModelBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestMixedModelBean.java,v 1.2 2003/01/10 02:11:28 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2003/01/10 02:11:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestMixedModelBean.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Mixed model test bean: Java, collections, map, DOM, Container.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2003/01/10 02:11:28 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TestMixedModelBean {\n     private String string;\n     public int[][] getMatrix(){\n         return matrix;\n     }\n+    \n+    public void setMatrix(int[][] matrix){\n+        this.matrix = matrix;\n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.5 2003/01/10 02:11:29 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/01/10 02:11:29 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.6 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2003/01/10 02:11:29 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/11 05:41:27 $\n  */\n \n public abstract class BeanModelTestCase extends JXPathTestCase\n     public void testCreatePathExpandNewCollection(){\n         context.setValue(\"beans\", null);\n \n-        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n-        // factory.createObject(..., testBean, \"beans\", 2)\n+        // Calls factory.createObject(..., testBean, \"beans\", 2), \n+        // then  factory.createObject(..., testBean, \"beans\", 2)\n         assertXPathCreatePath(context,\n                 \"/beans[2]/int\",\n                 new Integer(1),\n     public void testCreatePathAndSetValueExpandNewCollection(){\n         context.setValue(\"beans\", null);\n \n-        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n-        // factory.createObject(..., testBean, \"beans\", 2)\n+        // Calls factory.createObject(..., testBean, \"beans\", 2), \n+        // then factory.createObject(..., testBean, \"beans\", 2)\n         assertXPathCreatePathAndSetValue(context,\n                 \"/beans[2]/int\",\n                 new Integer(2),\n     }\n \n     public void testCreatePathExpandExistingCollection(){\n+        // Calls factory.createObject(..., TestBean, \"integers\", 5)\n+        // to expand collection\n+        assertXPathCreatePathAndSetValue(context,\n+            \"/integers[5]\",\n+            new Integer(3),\n+            \"/integers[5]\");     \n+    }\n+    \n+    public void testCreatePathExpandExistingCollectionAndSetProperty(){\n         // Another, but the collection already exists\n         assertXPathCreatePath(context,\n                 \"/beans[3]/int\",\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-        // Calls factory.expandCollection(..., nestedBean, \"strings\", 2)\n+        // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n         assertXPathCreatePath(context,\n                 \"/nestedBean/strings[2]\",\n                 \"String 2\",\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-        // Calls factory.expandCollection(..., nestedBean, \"strings\", 2)\n+        // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n         assertXPathCreatePathAndSetValue(context,\n                 \"/nestedBean/strings[2]\",\n                 \"Test\",\n                 \"/nestedBean/strings[2]\");\n     }\n-\n+        \n     public void testRemovePathPropertyValue(){\n         // Remove property value\n         context.removePath(\"nestedBean/int\");\n--- a/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java,v 1.3 2003/01/10 02:11:29 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/01/10 02:11:29 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with mixed model: beans, maps, DOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2003/01/10 02:11:29 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n  */\n \n public class MixedModelTest extends JXPathTestCase\n         }        \n         assertTrue(\"Exception setting value of non-existent element\", ex);\n     }\n+    \n+    public void testCreatePathAndSetValueWithMatrix(){\n+        \n+        context.setValue(\"matrix\", null);\n+        \n+        // Calls factory.createObject(..., TestMixedModelBean, \"matrix\")\n+        // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n+        assertXPathCreatePathAndSetValue(context,\n+                \"/matrix[1]/.[1]\",\n+                new Integer(4),\n+                \"/matrix[1]/.[1]\");        \n+    }    \n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TestMixedModelFactory extends AbstractFactory {\n \n             if (bean.getBeans() == null || index >= bean.getBeans().length){\n                 bean.setBeans(new NestedTestBean[index + 1]);\n             }\n-            ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n+            bean.getBeans()[index] = new NestedTestBean(\"newName\");\n             return true;\n         }\n         else if (name.equals(\"map\")){\n             ((Map)parent).put(name, tb);\n             return true;\n         }\n+        else if (name.equals(\"matrix\")){\n+            int[][] matrix = new int[2][];\n+            matrix[0] = new int[1];\n+//            matrix[1] = new int[2];\n+            ((TestMixedModelBean)parent).setMatrix(matrix);\n+            return true;\n+        }\n         return false;\n     }\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:33:35 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TestBeanFactory extends AbstractFactory {\n \n         if (name.equals(\"nestedBean\")) {\n             ((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n             return true;\n-        } else if (name.equals(\"beans\")) {\n+        }\n+        else if (name.equals(\"beans\")) {\n             TestBean bean = (TestBean) parent;\n             if (bean.getBeans() == null || index >= bean.getBeans().length) {\n                 bean.setBeans(new NestedTestBean[index + 1]);\n             }\n-            ((TestBean) parent).getBeans()[index] =\n-                new NestedTestBean(\"newName\");\n+            bean.getBeans()[index] = new NestedTestBean(\"newName\");\n             return true;\n         }\n-        return false;   }\n+        else if (name.equals(\"integers\")){    \n+            // This will implicitly expand the collection        \n+            ((TestBean)parent).setIntegers(index, 0);\n+            return true;\n+        }\n+        return false;\n+    }\n \n     /**\n      * Create a new object and set it on the specified variable\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.3 2002/11/26 01:33:35 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:33:35 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/11 05:41:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:35 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n  */\n public class TestDynaBeanFactory extends AbstractFactory {\n \n                 \"nestedBean\",\n                 new NestedTestBean(\"newName\"));\n             return true;\n-        } else if (name.equals(\"beans\")) {\n+        }\n+        else if (name.equals(\"beans\")) {\n             DynaBean bean = (DynaBean) parent;\n             Object beans[] = (Object[]) bean.get(\"beans\");\n             if (beans == null || index >= beans.length) {\n                 bean.set(\"beans\", beans);\n             }\n             beans[index] = new NestedTestBean(\"newName\");\n+            return true;\n+        }\n+        else if (name.equals(\"integers\")) {\n+            DynaBean bean = (DynaBean) parent;\n+            bean.set(\"integers\", index, new Integer(0));\n             return true;\n         }\n         return false;", "timestamp": 1042263687, "metainfo": ""}