{"sha": "02d8160f14dd155a86bb1022cd6fdd5dbee7421c", "log": "Placated stylecheck   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.5 2003/01/11 05:41:22 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/01/11 05:41:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathCompiledExpression.java,v 1.6 2003/01/20 00:00:26 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/20 00:00:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2003/01/11 05:41:22 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/20 00:00:26 $\n  */\n public class JXPathCompiledExpression implements CompiledExpression {\n \n         this.expression = expression;\n     }\n \n+    protected String getXPath() {\n+        return xpath;\n+    }\n+\n+    protected Expression getExpression() {\n+        return expression;\n+    }\n+\n+    public String toString() {\n+        return xpath;\n+    }\n+    \n     /**\n      * @see CompiledExpression#getValue(JXPathContext)\n      */\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.30 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.30 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.31 2003/01/20 00:00:26 dmitri Exp $\n+ * $Revision: 1.31 $\n+ * $Date: 2003/01/20 00:00:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n \n import junit.framework.TestCase;\n \n  * Abstract superclass for various JXPath tests.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.30 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.31 $ $Date: 2003/01/20 00:00:26 $\n  */\n \n-public abstract class JXPathTestCase extends TestCase\n-{\n+public abstract class JXPathTestCase extends TestCase {\n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public JXPathTestCase(String name)\n-    {\n+    public JXPathTestCase(String name) {\n         super(name);\n     }\n     \n                 String xpath, Collection expected)\n     {\n         Collection actual;\n-        if (expected instanceof List){\n+        if (expected instanceof List) {\n             actual = new ArrayList();\n         }\n         else {\n             actual = new HashSet();\n         }\n         Iterator it = ctx.iterate(xpath);\n-        while (it.hasNext()){\n+        while (it.hasNext()) {\n             actual.add(it.next());\n         }\n         assertEquals(\"Evaluating value iterator <\" + xpath + \">\",\n                 expected, actual);\n     }\n \n-    protected void assertXPathPointerIterator(JXPathContext ctx,\n-                String xpath, Collection expected)\n+    protected void assertXPathPointerIterator(\n+        JXPathContext ctx,\n+        String xpath,\n+        Collection expected) \n     {\n         Collection actual;\n-        if (expected instanceof List){\n+        if (expected instanceof List) {\n             actual = new ArrayList();\n         }\n         else {\n             actual = new HashSet();\n         }\n         Iterator it = ctx.iteratePointers(xpath);\n-        while (it.hasNext()){\n-            Pointer pointer = (Pointer)it.next();\n+        while (it.hasNext()) {\n+            Pointer pointer = (Pointer) it.next();\n             actual.add(pointer.toString());\n         }\n-        assertEquals(\"Evaluating pointer iterator <\" + xpath + \">\",\n-                expected, actual);\n-    }\n-\n-    protected void assertDocumentOrder(JXPathContext context, \n-            String path1, String path2, int expected)\n-    {\n-        NodePointer np1 = (NodePointer)context.getPointer(path1);\n-        NodePointer np2 = (NodePointer)context.getPointer(path2);\n+        assertEquals(\n+            \"Evaluating pointer iterator <\" + xpath + \">\",\n+            expected,\n+            actual);\n+    }\n+\n+    protected void assertDocumentOrder(\n+        JXPathContext context,\n+        String path1,\n+        String path2,\n+        int expected) \n+    {\n+        NodePointer np1 = (NodePointer) context.getPointer(path1);\n+        NodePointer np2 = (NodePointer) context.getPointer(path2);\n         int res = np1.compareTo(np2);\n-        if (res < 0){\n+        if (res < 0) {\n             res = -1;\n         }\n-        else if (res > 0){\n+        else if (res > 0) {\n             res = 1;\n         }\n-        assertEquals(\"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\", \n-                expected, res);\n-    }    \n-\n-    protected static List list(){\n+        assertEquals(\n+            \"Comparing paths '\" + path1 + \"' and '\" + path2 + \"'\",\n+            expected,\n+            res);\n+    }\n+\n+    protected static List list() {\n         return Collections.EMPTY_LIST;\n     }\n \n-    protected static List list(Object o1){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        return list;\n-    }\n-\n-    protected static List list(Object o1, Object o2){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        list.add(o2);\n-        return list;\n-    }\n-\n-    protected static List list(Object o1, Object o2, Object o3){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        list.add(o2);\n-        list.add(o3);\n-        return list;\n-    }\n-\n-    protected static Set set(Object o1, Object o2, Object o3){\n-        Set list = new HashSet();\n-        list.add(o1);\n-        list.add(o2);\n-        list.add(o3);\n-        return list;\n-    }\n-\n-    protected static List list(Object o1, Object o2, Object o3, Object o4){\n-        List list = new ArrayList();\n-        list.add(o1);\n-        list.add(o2);\n-        list.add(o3);\n-        list.add(o4);\n-        return list;\n-    }\n-\n-    protected static Set set(Object o1, Object o2, Object o3, Object o4){\n+    protected static List list(Object o1) {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2) {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3) {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3) {\n+        Set list = new HashSet();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        return list;\n+    }\n+\n+    protected static List list(Object o1, Object o2, Object o3, Object o4) {\n+        List list = new ArrayList();\n+        list.add(o1);\n+        list.add(o2);\n+        list.add(o3);\n+        list.add(o4);\n+        return list;\n+    }\n+\n+    protected static Set set(Object o1, Object o2, Object o3, Object o4) {\n         Set list = new HashSet();\n         list.add(o1);\n         list.add(o2);\n     }\n \n     protected static Set set(Object o1, Object o2, Object o3, \n-                Object o4, Object o5){\n+                Object o4, Object o5) \n+    {\n         Set list = new HashSet();\n         list.add(o1);\n         list.add(o2);\n--- a/src/test/org/apache/commons/jxpath/JXPathTestSuite.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestSuite.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestSuite.java,v 1.2 2002/11/28 01:02:05 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/28 01:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestSuite.java,v 1.3 2003/01/20 00:00:26 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n \n+import org.apache.commons.jxpath.ri.JXPathCompiledExpressionTest;\n import org.apache.commons.jxpath.ri.axes.SimplePathInterpreterTest;\n import org.apache.commons.jxpath.ri.compiler.ContextDependencyTest;\n import org.apache.commons.jxpath.ri.compiler.CoreFunctionTest;\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/28 01:02:05 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:26 $\n  */\n \n-public class JXPathTestSuite extends TestCase\n-{\n+public class JXPathTestSuite extends TestCase {\n     private static boolean enabled = true;\n \n     /**\n         TestRunner.run(suite());\n     }\n \n-    public JXPathTestSuite(String name){\n+    public JXPathTestSuite(String name) {\n         super(name);\n     }\n \n     /**\n      * Return the tests included in this test suite.\n      */\n-    public static Test suite()\n-    {\n+    public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        suite.addTestSuite(JXPathCompiledExpressionTest.class);\n         suite.addTestSuite(SimplePathInterpreterTest.class);\n         suite.addTestSuite(ContextDependencyTest.class);\n         suite.addTestSuite(CoreFunctionTest.class);\n--- a/src/test/org/apache/commons/jxpath/NestedTestBean.java\n+++ b/src/test/org/apache/commons/jxpath/NestedTestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/NestedTestBean.java,v 1.4 2002/10/13 03:25:48 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/10/13 03:25:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/NestedTestBean.java,v 1.5 2003/01/20 00:00:26 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/20 00:00:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * A general purpose JavaBean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/10/13 03:25:48 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/20 00:00:26 $\n  */\n public class NestedTestBean {\n     private String name = \"Name 0\";\n     private int integer = 1;\n \n-    public NestedTestBean(){\n+    public NestedTestBean() {\n     }\n \n-    public NestedTestBean(String name){\n+    public NestedTestBean(String name) {\n         this.name = name;\n     }\n \n-    public void setName(String name){\n+    public void setName(String name) {\n         this.name = name;\n     }\n \n     /**\n      * A read-only boolean property\n      */\n-    public boolean isBoolean(){\n+    public boolean isBoolean() {\n         return false;\n     }\n \n     /**\n      * A read-only int property\n      */\n-    public int getInt(){\n+    public int getInt() {\n         return integer;\n     }\n \n-    public void setInt(int value){\n+    public void setInt(int value) {\n         this.integer = value;\n     }\n \n     /**\n      * A read-only String property\n      */\n-    public String getName(){\n+    public String getName() {\n         return name;\n     }\n \n-    private String[] strings = new String[]{\"String 1\", \"String 2\", \"String 3\"};\n+    private String[] strings =\n+        new String[] { \"String 1\", \"String 2\", \"String 3\" };\n \n-    public String[] getStrings(){\n+    public String[] getStrings() {\n         return strings;\n     }\n \n-    public void setStrings(String[] array){\n+    public void setStrings(String[] array) {\n         strings = array;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"Nested: \" + name;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/TestBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestBean.java,v 1.5 2003/01/20 00:00:26 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/20 00:00:26 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.apache.commons.jxpath.util.ValueUtils;\n \n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/20 00:00:26 $\n  */\n public class TestBean {\n \n     // ------------------------------------------------------------- Properties\n-\n \n     /**\n      * An array of nested java beans.\n         beans[1].setInt(3);\n     }\n \n-    public NestedTestBean[] getBeans(){\n+    public NestedTestBean[] getBeans() {\n         return beans;\n     }\n \n-    public void setBeans(NestedTestBean[] beans){\n+    public void setBeans(NestedTestBean[] beans) {\n         this.beans = beans;\n     }\n \n      * A boolean property.\n      */\n     private boolean bool = false;\n-    public boolean getBoolean(){\n+    public boolean getBoolean() {\n         return bool;\n     }\n \n-    public void setBoolean(boolean bool){\n+    public void setBoolean(boolean bool) {\n         this.bool = bool;\n     }\n \n     /**\n      * A read-only integer property\n      */\n-    public int getInt(){\n+    public int getInt() {\n         return integer;\n     }\n \n-    public void setInt(int integer){\n+    public void setInt(int integer) {\n         this.integer = integer;\n     }\n \n     /**\n      * A read-only array of integers\n      */\n-    private int[] array = {1, 2, 3, 4};\n-    public int[] getIntegers(){\n+    private int[] array = { 1, 2, 3, 4 };\n+    public int[] getIntegers() {\n         return array;\n     }\n \n-    public int getIntegers(int index){\n+    public int getIntegers(int index) {\n         return array[index];\n     }\n \n-    public void setIntegers(int index, int value){\n-        if (index >= array.length){\n-            array = (int[])ValueUtils.expandCollection(array, index + 1);\n+    public void setIntegers(int index, int value) {\n+        if (index >= array.length) {\n+            array = (int[]) ValueUtils.expandCollection(array, index + 1);\n         }\n         array[index] = value;\n     }\n      * A heterogeneous list: String, Integer, NestedTestBean\n      */\n     private ArrayList list;\n-    public List getList(){\n-        if (list == null){\n+    public List getList() {\n+        if (list == null) {\n             list = new ArrayList();\n             list.add(\"String 3\");\n             list.add(new Integer(3));\n         map.put(\"Key2\", new NestedTestBean(\"Name 6\"));\n     }\n \n-    public Map getMap(){\n+    public Map getMap() {\n         return map;\n     }\n \n-    public void setMap(Map map){\n-        this.map = (HashMap)map;\n+    public void setMap(Map map) {\n+        this.map = (HashMap) map;\n     }\n \n     /**\n      * A nested read-only java bean\n      */\n     private NestedTestBean nestedBean = new NestedTestBean(\"Name 0\");\n-    public NestedTestBean getNestedBean(){\n+    public NestedTestBean getNestedBean() {\n         return nestedBean;\n     }\n \n-    public void setNestedBean(NestedTestBean bean){\n+    public void setNestedBean(NestedTestBean bean) {\n         this.nestedBean = bean;\n     }\n \n     /**\n      * Returns a NestedTestBean: testing recognition of generic objects\n      */\n-    public Object getObject(){\n+    public Object getObject() {\n         return object;\n     }\n \n     /**\n      * Returns an array of ints: testing recognition of generic objects\n      */\n-    public Object getObjects(){\n+    public Object getObjects() {\n         return getIntegers();\n     }\n \n      * A heterogeneous set: String, Integer, NestedTestBean\n      */\n     private HashSet set;\n-    public Set getSet(){\n-        if (set == null){\n+    public Set getSet() {\n+        if (set == null) {\n             set = new HashSet();\n             set.add(\"String 4\");\n             set.add(new Integer(4));\n         return set;\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"ROOT\";\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/TestMixedModelBean.java\n+++ b/src/test/org/apache/commons/jxpath/TestMixedModelBean.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestMixedModelBean.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestMixedModelBean.java,v 1.4 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import org.apache.commons.jxpath.xml.DocumentContainer;\n import org.w3c.dom.Document;\n  * Mixed model test bean: Java, collections, map, DOM, Container.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class TestMixedModelBean {\n     private String string;\n     private List list;\n     private int[][] matrix;\n \n-    public TestMixedModelBean(){\n+    public TestMixedModelBean() {\n         string = \"string\";\n         bean = new TestBean();\n         map = new HashMap();\n         list = new ArrayList();\n \n         container = new DocumentContainer(getClass().getResource(\"Vendor.xml\"));\n-        document = (Document)container.getValue();\n+        document = (Document) container.getValue();\n         element = document.getDocumentElement();\n \n         map.put(\"string\", string);\n         list.add(document);\n         list.add(element);\n         list.add(container);\n-        \n+\n         matrix = new int[1][];\n         matrix[0] = new int[1];\n         matrix[0][0] = 3;\n     }\n \n-    public String getString(){\n+    public String getString() {\n         return string;\n     }\n-    \n+\n     public TestBean getBean() {\n         return bean;\n     }\n-    \n-    public Map getMap(){\n+\n+    public Map getMap() {\n         return map;\n     }\n \n     public List getList() {\n         return list;\n     }\n-        \n+\n     public Document getDocument() {\n         return document;\n     }\n-    \n+\n     public Element getElement() {\n         return element;\n     }\n-    \n-    public Container getContainer(){\n+\n+    public Container getContainer() {\n         return container;\n     }\n-    \n-    public int[][] getMatrix(){\n+\n+    public int[][] getMatrix() {\n         return matrix;\n     }\n-    \n-    public void setMatrix(int[][] matrix){\n+\n+    public void setMatrix(int[][] matrix) {\n         this.matrix = matrix;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/TestNull.java\n+++ b/src/test/org/apache/commons/jxpath/TestNull.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestNull.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/TestNull.java,v 1.3 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class TestNull {\n \n     private Object nothing = null;\n-    public Object getNothing(){\n+    public Object getNothing() {\n         return nothing;\n     }\n \n-    public void setNothing(Object something){\n+    public void setNothing(Object something) {\n         this.nothing = something;\n     }\n \n     /**\n      */\n-    private static String[] array = {\"a\", null, \"b\"};\n-    public String[] getArray(){\n+    private static String[] array = { \"a\", null, \"b\" };\n+    public String[] getArray() {\n         return array;\n     }\n \n     private TestNull child;\n \n-    public TestNull getChild(){\n-        if (child == null){\n+    public TestNull getChild() {\n+        if (child == null) {\n             child = new TestNull();\n         }\n         return child;\n--- /dev/null\n+++ b/src/test/org/apache/commons/jxpath/ri/JXPathCompiledExpressionTest.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/JXPathCompiledExpressionTest.java,v 1.1 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/20 00:00:27 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.jxpath.ri;\n+\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+\n+/**\n+ * Test compiler.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2003/01/20 00:00:27 $\n+ */\n+\n+public class JXPathCompiledExpressionTest extends JXPathTestCase {\n+    \n+    /**\n+     * Construct a new instance of this test case.\n+     *\n+     * @param name Name of the test case\n+     */\n+    public JXPathCompiledExpressionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testConstant() {\n+        assertXPathExpression(\"1\", Constant.class);\n+        assertXPathExpression(\"1.5\", Constant.class);\n+        assertXPathExpression(\"'foo'\", Constant.class);\n+    }\n+    \n+    public void testCoreFunction() {\n+        assertXPathExpression(\"last()\", CoreFunction.class);\n+        assertXPathExpression(\"position()\", CoreFunction.class);\n+        assertXPathExpression(\"count(book)\", CoreFunction.class);\n+        assertXPathExpression(\"id(13)\", CoreFunction.class);\n+        assertXPathExpression(\"local-name()\", CoreFunction.class);\n+        assertXPathExpression(\"local-name(book)\", CoreFunction.class);\n+        assertXPathExpression(\"namespace-uri()\", CoreFunction.class);\n+        assertXPathExpression(\"namespace-uri(book)\", CoreFunction.class);\n+        assertXPathExpression(\"name()\", CoreFunction.class);\n+        assertXPathExpression(\"name(book)\", CoreFunction.class);\n+        assertXPathExpression(\"string(3)\", CoreFunction.class);\n+        assertXPathExpression(\"concat('a', 'b')\", CoreFunction.class);\n+        assertXPathExpression(\"starts-with('a', 'b')\", CoreFunction.class);\n+        assertXPathExpression(\"contains('a', 'b')\", CoreFunction.class);\n+        assertXPathExpression(\"substring-before('a', 1)\", CoreFunction.class);\n+        assertXPathExpression(\"substring-after('a', 2)\", CoreFunction.class);\n+        assertXPathExpression(\"substring('a', 2)\", CoreFunction.class);\n+        assertXPathExpression(\"substring('a', 2, 3)\", CoreFunction.class);\n+        assertXPathExpression(\"string-length('a')\", CoreFunction.class);\n+        assertXPathExpression(\"normalize-space('a')\", CoreFunction.class);\n+        assertXPathExpression(\"translate('a', 'b', 'c')\", CoreFunction.class);\n+        assertXPathExpression(\"boolean('true')\", CoreFunction.class);\n+        assertXPathExpression(\"not(1)\", CoreFunction.class);\n+        assertXPathExpression(\"true()\", CoreFunction.class);\n+        assertXPathExpression(\"false()\", CoreFunction.class);\n+        assertXPathExpression(\"lang('fr')\", CoreFunction.class);\n+        assertXPathExpression(\"number('12')\", CoreFunction.class);\n+        assertXPathExpression(\"sum(book/price)\", CoreFunction.class);\n+        assertXPathExpression(\"floor(11.4)\", CoreFunction.class);\n+        assertXPathExpression(\"ceiling(11.4)\", CoreFunction.class);\n+        assertXPathExpression(\"round(11.4)\", CoreFunction.class);\n+        assertXPathExpression(\"key('title', 'Hobbit')\", CoreFunction.class);\n+    }\n+    \n+    public void testCoreOperationAnd() {\n+        assertXPathExpression(\n+            \"2 and 4\",\n+            CoreOperationAnd.class);\n+\n+        assertXPathExpression(\n+            \"2 > 1 and 4 < 5\",\n+            CoreOperationAnd.class);            \n+    }\n+        \n+    public void testCoreOperationOr() {\n+        assertXPathExpression(\n+            \"2 or 4\",\n+            CoreOperationOr.class);\n+\n+        assertXPathExpression(\n+            \"2 > 1 or 4 < 5\",\n+            CoreOperationOr.class);\n+\n+        assertXPathExpression(\n+            \"1 > 1 and 2 <= 2 or 3 = 4\",\n+            CoreOperationOr.class);\n+    }\n+\n+    public void testCoreOperationEqual() {\n+        assertXPathExpression(\n+            \"2 = 4\",\n+            CoreOperationEqual.class);\n+\n+        assertXPathExpression(\n+            \"2 + 1 = 3\",\n+            CoreOperationEqual.class);\n+    }\n+    \n+    public void testCoreOperationNameAttributeTest() {\n+        assertXPathExpression(\n+            \"@name = 'bar'\",\n+            NameAttributeTest.class);\n+    }\n+\n+    public void testCoreOperationNotEqual() {\n+        assertXPathExpression(\n+            \"2 != 4\",\n+            CoreOperationNotEqual.class);\n+\n+        assertXPathExpression(\n+            \"2 + 1 != 3\",\n+            CoreOperationNotEqual.class);\n+    }\n+\n+    public void testCoreOperationLessThan() {\n+        assertXPathExpression(\n+            \"3<4\",\n+            CoreOperationLessThan.class,\n+            \"3 < 4\");\n+\n+        assertXPathExpression(\n+            \"3<(2>=1)\",\n+            CoreOperationLessThan.class,\n+            \"3 < (2 >= 1)\");\n+    }\n+    \n+    public void testCoreOperationLessThanOrEqual() {\n+        assertXPathExpression(\n+            \"3<=4\",\n+            CoreOperationLessThanOrEqual.class,\n+            \"3 <= 4\");\n+\n+        assertXPathExpression(\n+            \"3<=(2>=1)\",\n+            CoreOperationLessThanOrEqual.class,\n+            \"3 <= (2 >= 1)\");\n+    }\n+\n+    public void testCoreOperationGreaterThan() {\n+        assertXPathExpression(\n+            \"3>4\",\n+            CoreOperationGreaterThan.class,\n+            \"3 > 4\");\n+\n+        assertXPathExpression(\n+            \"3>(2>=1)\",\n+            CoreOperationGreaterThan.class,\n+            \"3 > (2 >= 1)\");\n+\n+        assertXPathExpression(\n+            \"1 > (1 and 2 <= (2 or 3) = 4)\",\n+            CoreOperationGreaterThan.class);\n+    }\n+    \n+    public void testCoreOperationGreaterThanOrEqual() {\n+        assertXPathExpression(\n+            \"3>=4\",\n+            CoreOperationGreaterThanOrEqual.class,\n+            \"3 >= 4\");\n+\n+        assertXPathExpression(\n+            \"3>=(2>=1)\",\n+            CoreOperationGreaterThanOrEqual.class,\n+            \"3 >= (2 >= 1)\");\n+    }\n+\n+    public void testCoreOperationDivide() {\n+        assertXPathExpression(\n+            \"2 div 4\",\n+            CoreOperationDivide.class);\n+\n+        assertXPathExpression(\n+            \"2|3 div -3\",\n+            CoreOperationDivide.class,\n+            \"2 | 3 div -3\");\n+    }\n+\n+    public void testCoreOperationMod() {\n+        assertXPathExpression(\n+            \"2 mod 4\",\n+            CoreOperationMod.class);\n+\n+        assertXPathExpression(\n+            \"2|3 mod -3\",\n+            CoreOperationMod.class,\n+            \"2 | 3 mod -3\");\n+    }\n+\n+    public void testCoreOperationMultiply() {\n+        assertXPathExpression(\n+            \"2*4\",\n+            CoreOperationMultiply.class,\n+            \"2 * 4\");\n+            \n+        assertXPathExpression(\n+            \"2*(3 + 1)\",\n+            CoreOperationMultiply.class,\n+            \"2 * (3 + 1)\");\n+    }\n+    \n+    public void testCoreOperationMinus() {\n+        assertXPathExpression(\n+            \"1 - 1\",\n+            CoreOperationSubtract.class);\n+            \n+        assertXPathExpression(\n+            \"1 - 1 - 2\",\n+            CoreOperationSubtract.class);\n+            \n+        assertXPathExpression(\n+            \"1 - (1 - 2)\",\n+            CoreOperationSubtract.class);\n+    }\n+    \n+    public void testCoreOperationSum() {\n+        assertXPathExpression(\n+            \"3 + 1 + 4\", \n+            CoreOperationAdd.class);\n+            \n+        assertXPathExpression(\n+            \"(3 + 1) + 4\",\n+            CoreOperationAdd.class,\n+            \"3 + 1 + 4\");\n+            \n+        assertXPathExpression(\n+            \"3 + (1 + 4)\",\n+            CoreOperationAdd.class,\n+            \"3 + 1 + 4\");\n+            \n+        assertXPathExpression(\n+            \"3 + -1\", \n+            CoreOperationAdd.class, \n+            \"3 + -1\");\n+            \n+        assertXPathExpression(\n+            \"2*-3 + -1\",\n+            CoreOperationAdd.class,\n+            \"2 * -3 + -1\");\n+    }\n+    \n+    public void testCoreOperationUnaryMinus() {\n+        assertXPathExpression(\"-3\", CoreOperationNegate.class);\n+        assertXPathExpression(\"-(3 + 1)\", CoreOperationNegate.class);\n+    }\n+\n+    public void testCoreOperationUnion() {\n+        assertXPathExpression(\n+            \"3 | 1 | 4\",\n+            CoreOperationUnion.class);\n+    }\n+    \n+    public void testExpressionPath() {\n+        assertXPathExpression(\n+            \"$x/foo/bar\",\n+            ExpressionPath.class);        \n+        assertXPathExpression(\n+            \"(2 + 2)/foo/bar\",\n+            ExpressionPath.class);        \n+        assertXPathExpression(\n+            \"$x[3][2 + 2]/foo/bar\",\n+            ExpressionPath.class);        \n+    }\n+    \n+    public void testExtensionFunction() {\n+        assertXPathExpression(\n+            \"my:function(3, other.function())\",\n+            ExtensionFunction.class);        \n+    }\n+ \n+    public void testLocationPathAxisSelf() {\n+        assertXPathExpression(\n+            \"self::foo:bar\",\n+            LocationPath.class);\n+                 \n+        assertXPathExpression(\n+            \".\",\n+            LocationPath.class);     \n+    }\n+    \n+    public void testLocationPathAxisChild() {\n+        assertXPathExpression(\n+            \"child::foo:bar\",\n+            LocationPath.class,\n+            \"foo:bar\");\n+                 \n+        assertXPathExpression(\n+            \"foo:bar\",\n+            LocationPath.class);\n+                 \n+        assertXPathExpression(\n+            \"/foo:bar\",\n+            LocationPath.class);\n+                 \n+        assertXPathExpression(\n+            \"/foo/bar\",\n+            LocationPath.class);     \n+\n+        assertXPathExpression(\n+            \"*\",\n+            LocationPath.class);\n+                 \n+        assertXPathExpression(\n+            \"foo:*\",\n+            LocationPath.class);\n+                 \n+    }\n+    \n+    public void testLocationPathAxisParent() {\n+        assertXPathExpression(\n+            \"parent::foo:bar\",\n+            LocationPath.class);\n+                 \n+        assertXPathExpression(\n+            \"..\",\n+            LocationPath.class);     \n+    }\n+    \n+    public void testLocationPathAxisAttribute() {\n+        assertXPathExpression(\n+            \"attribute::foo:bar\",\n+            LocationPath.class,\n+            \"@foo:bar\");\n+\n+        assertXPathExpression(\n+            \"@foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"../@foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"@*\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"@*[last()]\",\n+            LocationPath.class);\n+    }\n+    \n+    public void testLocationPathAxisDescendant() {\n+        assertXPathExpression(\n+            \"descendant::foo:bar\",\n+            LocationPath.class);\n+    }\n+    \n+    public void testLocationPathAxisDescendantOrSelf() {\n+        assertXPathExpression(\n+            \"descendant-or-self::foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"//foo\", \n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"foo//bar\", \n+            LocationPath.class);\n+    }\n+    \n+    public void testLocationPathAxisOther() {\n+        assertXPathExpression(\n+            \"ancestor::foo:bar\",\n+            LocationPath.class);\n+            \n+        assertXPathExpression(\n+            \"ancestor-or-self::foo:bar\",\n+            LocationPath.class);\n+            \n+        assertXPathExpression(\n+            \"namespace::foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"preceding::foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"preceding-sibling::foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"following::foo:bar\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"following-sibling::foo:bar\",\n+            LocationPath.class);\n+    }\n+    \n+    public void testLocationPathNodeTest() {\n+        assertXPathExpression(\n+            \"node()\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"text()\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"comment()\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"processing-instruction()\",\n+            LocationPath.class);\n+\n+        assertXPathExpression(\n+            \"processing-instruction('test')\",\n+            LocationPath.class);\n+    }\n+    \n+    public void testVariableReference() {\n+        assertXPathExpression(\n+            \"$x\",\n+            VariableReference.class);                \n+\n+        assertXPathExpression(\n+            \"$x:y\",\n+            VariableReference.class);\n+    }\n+    \n+    /**\n+     * Compiles the xpath into an Expression, checks the expression\n+     * class, converts the expression to string and checks that the string\n+     * matches the expected one.\n+     */\n+    private void assertXPathExpression(\n+        String xpath,\n+        Class expectedClass,\n+        String expected) \n+    {\n+        JXPathCompiledExpression expression =\n+            (JXPathCompiledExpression) JXPathContext.compile(xpath);\n+        \n+        assertEquals(\n+            \"Expression class for \" + xpath,\n+            expectedClass,\n+            expression.getExpression().getClass());\n+            \n+        assertEquals(\n+            \"Expression toString() for \" + xpath,\n+            expected,\n+            expression.getExpression().toString());\n+    }\n+    \n+    private void assertXPathExpression(\n+        String xpath,\n+        Class expectedClass) \n+    {\n+        assertXPathExpression(xpath, expectedClass, xpath);\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/SimplePathInterpreterTest.java\n package org.apache.commons.jxpath.ri.axes;\n \n+import java.util.HashMap;\n+\n import junit.framework.TestCase;\n \n import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.TestNull;\n-import org.apache.commons.jxpath.NestedTestBean;\n-import org.apache.commons.jxpath.ri.model.*;\n-import org.apache.commons.jxpath.ri.model.beans.*;\n-import org.apache.commons.jxpath.ri.model.dom.*;\n-import org.apache.commons.jxpath.ri.model.dynamic.*;\n-\n-import java.util.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.VariablePointer;\n+import org.apache.commons.jxpath.ri.model.beans.BeanPointer;\n+import org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer;\n+import org.apache.commons.jxpath.ri.model.beans.CollectionPointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullElementPointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullPointer;\n+import org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer;\n+import org.apache.commons.jxpath.ri.model.beans.TestBeanFactory;\n+import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;\n+import org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer;\n+import org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer;\n \n public class SimplePathInterpreterTest extends TestCase {\n \n         context.setFactory(new TestBeanFactory());\n     }\n \n-    public void test_doStep_noPredicates_propertyOwner(){\n+    public void testDoStepNoPredicatesPropertyOwner() {\n         // Existing scalar property\n         assertValueAndPointer(\"/int\",\n                 new Integer(1),\n                 \"BbC\");\n     }\n \n-    public void test_doStep_noPredicates_standard(){\n+    public void testDoStepNoPredicatesStandard() {\n         // Existing DOM node\n         assertValueAndPointer(\"/vendor/location/address/city\",\n                 \"Fruit Market\",\n                 \"BbMMMMn\");\n     }\n \n-    public void test_doStep_predicates_propertyOwner(){\n+    public void testDoStepPredicatesPropertyOwner() {\n         // missingProperty[@name=foo]\n         assertNullPointer(\"/foo[@name='foo']\",\n                 \"/foo[@name='foo']\",\n                 \"Bn\");\n     }\n \n-    public void test_doStep_predicates_standard(){\n+    public void testDoStepPredicatesStandard() {\n         // Looking for an actual XML attribute called \"name\"\n         // nodeProperty/name[@name=value]\n         assertValueAndPointer(\"/vendor/contact[@name='jack']\",\n                 \"BbMM\");\n     }\n \n-    public void test_doPredicate_name(){\n+    public void testDoPredicateName() {\n         // existingProperty[@name=existingProperty]\n         assertValueAndPointer(\"/nestedBean[@name='int']\",\n                 new Integer(1),\n                 \"BbDdM\");\n     }\n \n-    public void test_doPredicates_standard(){\n+    public void testDoPredicatesStandard() {\n         // bean/map/collection/node\n         assertValueAndPointer(\"map[@name='Key3'][@name='fruitco']\",\n                 context.getValue(\"/vendor\"),\n                 \"BbMM\");\n     }\n \n-    public void test_doPredicate_index(){\n+    public void testDoPredicateIndex() {\n         // Existing dynamic property + existing property + index\n         assertValueAndPointer(\"/map[@name='Key2'][@name='strings'][2]\",\n                 \"String 2\",\n                 \"BbB\");\n     }\n \n-    public void testInterpretExpressionPath(){\n+    public void testInterpretExpressionPath() {\n         context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n         context.getVariables().declareVariable(\"testnull\", new TestNull());\n \n         assertEquals(\"Checking signature: \" + path,\n                 expectedSignature, pointerSignature(pointer));\n         \n-        Pointer vPointer = ((NodePointer)pointer).getValuePointer();\n+        Pointer vPointer = ((NodePointer) pointer).getValuePointer();\n         assertEquals(\"Checking value pointer signature: \" + path,\n                 expectedValueSignature, pointerSignature(vPointer));\n     }\n         assertEquals(\"Checking Signature: \" + path,\n                     expectedSignature, pointerSignature(pointer));\n                 \n-        Pointer vPointer = ((NodePointer)pointer).getValuePointer();\n+        Pointer vPointer = ((NodePointer) pointer).getValuePointer();\n         assertTrue(\"Null path is null: \" + path,\n-                    !((NodePointer)vPointer).isActual());\n+                    !((NodePointer) vPointer).isActual());\n         assertEquals(\"Checking value pointer signature: \" + path,\n                     expectedSignature + \"N\", pointerSignature(vPointer));\n     }\n      * we will get a signature which will contain a single character\n      * per pointer in the chain, representing that pointer's type.\n      */\n-    private String pointerSignature(Pointer pointer){\n-        if (pointer == null){\n+    private String pointerSignature(Pointer pointer) {\n+        if (pointer == null) {\n             return \"\";\n         }\n \n         char type = '?';\n-        if (pointer instanceof NullPointer){                 type = 'N'; }\n-        else if (pointer instanceof NullPropertyPointer){    type = 'n'; }\n-        else if (pointer instanceof NullElementPointer){     type = 'E'; }\n-        else if (pointer instanceof VariablePointer){        type = 'V'; }\n-        else if (pointer instanceof CollectionPointer){      type = 'C'; }\n-        else if (pointer instanceof BeanPointer){            type = 'B'; }\n-        else if (pointer instanceof BeanPropertyPointer){    type = 'b'; }\n-        else if (pointer instanceof DynamicPointer){         type = 'D'; }\n-        else if (pointer instanceof DynamicPropertyPointer){ type = 'd'; }\n-        else if (pointer instanceof DOMNodePointer){         type = 'M'; }\n+        if (pointer instanceof NullPointer) {                 type = 'N'; }\n+        else if (pointer instanceof NullPropertyPointer) {    type = 'n'; }\n+        else if (pointer instanceof NullElementPointer) {     type = 'E'; }\n+        else if (pointer instanceof VariablePointer) {        type = 'V'; }\n+        else if (pointer instanceof CollectionPointer) {      type = 'C'; }\n+        else if (pointer instanceof BeanPointer) {            type = 'B'; }\n+        else if (pointer instanceof BeanPropertyPointer) {    type = 'b'; }\n+        else if (pointer instanceof DynamicPointer) {         type = 'D'; }\n+        else if (pointer instanceof DynamicPropertyPointer) { type = 'd'; }\n+        else if (pointer instanceof DOMNodePointer) {         type = 'M'; }\n         else {\n             System.err.println(\"UNKNOWN TYPE: \" + pointer.getClass());\n         }\n-        return pointerSignature(((NodePointer)pointer).getParent()) + type;\n+        return pointerSignature(((NodePointer) pointer).getParent()) + type;\n     }\n }\n \n--- a/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java\n+++ b/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/axes/TestBeanWithNode.java,v 1.2 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test bean for mixed model JUnit tests.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class TestBeanWithNode extends TestBean {\n     private Object node;\n     private Object object;\n \n-    public Object getVendor(){\n+    public Object getVendor() {\n         return node;\n     }\n \n-    public Object[] getVendors(){\n-        return new Object[]{node};\n+    public Object[] getVendors() {\n+        return new Object[] { node };\n     }\n \n-    public void setVendor(Object node){\n+    public void setVendor(Object node) {\n         this.node = node;\n     }\n \n-    public Object getObject(){\n+    public Object getObject() {\n         return object;\n     }\n \n-    public void setObject(Object object){\n+    public void setObject(Object object) {\n         this.object = object;\n     }\n \n-    public static TestBeanWithNode createTestBeanWithDOM(){\n-        DocumentContainer docCtr = new DocumentContainer(\n+    public static TestBeanWithNode createTestBeanWithDOM() {\n+        DocumentContainer docCtr =\n+            new DocumentContainer(\n                 JXPathTestCase.class.getResource(\"Vendor.xml\"));\n-        Document doc = (Document)docCtr.getValue();\n+        Document doc = (Document) docCtr.getValue();\n         TestBeanWithNode tbwdom = new TestBeanWithNode();\n         tbwdom.setVendor(doc.getDocumentElement());\n         tbwdom.setObject(docCtr);\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ContextDependencyTest.java,v 1.2 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests the determination of whether an expression is context dependent.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:27 $\n  */\n \n-public class ContextDependencyTest extends JXPathTestCase\n-{\n-    public ContextDependencyTest(String name){\n+public class ContextDependencyTest extends JXPathTestCase {\n+    public ContextDependencyTest(String name) {\n         super(name);\n     }\n \n-    public void testContextDependency(){\n+    public void testContextDependency() {\n         testContextDependency(\"1\", false);\n         testContextDependency(\"$x\", false);\n         testContextDependency(\"/foo\", false);\n         testContextDependency(\"test:func(3, foo)\", true);\n     }\n \n-    public void testContextDependency(String xpath, boolean expected){\n-        Expression expr = \n-            (Expression)Parser.parseExpression(xpath, new TreeCompiler());\n-        \n-        assertEquals(\"Context dependency <\" + xpath + \">\", \n-                expected, \n-                expr.isContextDependent());\n-    }   \n+    public void testContextDependency(String xpath, boolean expected) {\n+        Expression expr =\n+            (Expression) Parser.parseExpression(xpath, new TreeCompiler());\n+\n+        assertEquals(\n+            \"Context dependency <\" + xpath + \">\",\n+            expected,\n+            expr.isContextDependent());\n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreFunctionTest.java,v 1.3 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test basic functionality of JXPath - core functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:27 $\n  */\n \n-public class CoreFunctionTest extends JXPathTestCase\n-{\n+public class CoreFunctionTest extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public CoreFunctionTest(String name){\n+    public CoreFunctionTest(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(new TestMixedModelBean());\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"nan\", new Double(Double.NaN));\n         }\n     }\n \n-    public void testCoreFunctions(){\n-        assertXPathValue(context,\"string(2)\", \"2\");\n-        assertXPathValue(context,\"string($nan)\", \"NaN\");\n-        assertXPathValue(context,\"string(-$nan)\", \"NaN\");\n-        assertXPathValue(context,\"string(-2 div 0)\", \"-Infinity\");\n-        assertXPathValue(context,\"string(2 div 0)\", \"Infinity\");\n-        assertXPathValue(context,\"concat('a', 'b', 'c')\", \"abc\");\n-        assertXPathValue(context,\"starts-with('abc', 'ab')\", Boolean.TRUE);\n-        assertXPathValue(context,\"starts-with('xabc', 'ab')\", Boolean.FALSE);\n-        assertXPathValue(context,\"contains('xabc', 'ab')\", Boolean.TRUE);\n-        assertXPathValue(context,\"contains('xabc', 'ba')\", Boolean.FALSE);\n-        assertXPathValue(context,\"substring-before('1999/04/01', '/')\", \"1999\");\n-        assertXPathValue(context,\"substring-after('1999/04/01', '/')\", \"04/01\");\n-        assertXPathValue(context,\"substring('12345', 2, 3)\", \"234\");\n-        assertXPathValue(context,\"substring('12345', 2)\", \"2345\");\n-        assertXPathValue(context,\"substring('12345', 1.5, 2.6)\", \"234\");\n-        assertXPathValue(context,\"substring('12345', 0, 3)\", \"12\");\n-        assertXPathValue(context,\"substring('12345', 0 div 0, 3)\", \"\");\n-        assertXPathValue(context,\"substring('12345', 1, 0 div 0)\", \"\");\n-        assertXPathValue(context,\"substring('12345', -42, 1 div 0)\", \"12345\");\n-        assertXPathValue(context,\"substring('12345', -1 div 0, 1 div 0)\", \"\");\n-        assertXPathValue(context,\"string-length('12345')\", new Double(5));\n-        assertXPathValue(context,\"normalize-space(' abc  def  ')\", \"abc def\");\n-        assertXPathValue(context,\"normalize-space('abc def')\", \"abc def\");\n-        assertXPathValue(context,\"normalize-space('   ')\", \"\");\n-        assertXPathValue(context,\"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\");\n-        assertXPathValue(context,\"boolean(1)\", Boolean.TRUE);\n-        assertXPathValue(context,\"boolean(0)\", Boolean.FALSE);\n-        assertXPathValue(context,\"boolean('x')\", Boolean.TRUE);\n-        assertXPathValue(context,\"boolean('')\", Boolean.FALSE);\n-        \n-        assertXPathValue(context,\"true()\", Boolean.TRUE);\n-        assertXPathValue(context,\"false()\", Boolean.FALSE);\n-        assertXPathValue(context,\"not(false())\", Boolean.TRUE);\n-        assertXPathValue(context,\"not(true())\", Boolean.FALSE);\n-        assertXPathValue(context,\"number('1')\", new Double(1));\n-        assertXPathValue(context,\"floor(1.5)\", new Double(1));\n-        assertXPathValue(context,\"floor(-1.5)\", new Double(-2));\n-        assertXPathValue(context,\"ceiling(1.5)\", new Double(2));\n-        assertXPathValue(context,\"ceiling(-1.5)\", new Double(-1));\n-        assertXPathValue(context,\"round(1.5)\", new Double(2));\n-        assertXPathValue(context,\"round(-1.5)\", new Double(-1));\n-        assertXPathValue(context,\"null()\", null);\n+    public void testCoreFunctions() {\n+        assertXPathValue(context, \"string(2)\", \"2\");\n+        assertXPathValue(context, \"string($nan)\", \"NaN\");\n+        assertXPathValue(context, \"string(-$nan)\", \"NaN\");\n+        assertXPathValue(context, \"string(-2 div 0)\", \"-Infinity\");\n+        assertXPathValue(context, \"string(2 div 0)\", \"Infinity\");\n+        assertXPathValue(context, \"concat('a', 'b', 'c')\", \"abc\");\n+        assertXPathValue(context, \"starts-with('abc', 'ab')\", Boolean.TRUE);\n+        assertXPathValue(context, \"starts-with('xabc', 'ab')\", Boolean.FALSE);\n+        assertXPathValue(context, \"contains('xabc', 'ab')\", Boolean.TRUE);\n+        assertXPathValue(context, \"contains('xabc', 'ba')\", Boolean.FALSE);\n+        assertXPathValue(\n+            context,\n+            \"substring-before('1999/04/01', '/')\",\n+            \"1999\");\n+        assertXPathValue(\n+            context,\n+            \"substring-after('1999/04/01', '/')\",\n+            \"04/01\");\n+        assertXPathValue(context, \"substring('12345', 2, 3)\", \"234\");\n+        assertXPathValue(context, \"substring('12345', 2)\", \"2345\");\n+        assertXPathValue(context, \"substring('12345', 1.5, 2.6)\", \"234\");\n+        assertXPathValue(context, \"substring('12345', 0, 3)\", \"12\");\n+        assertXPathValue(context, \"substring('12345', 0 div 0, 3)\", \"\");\n+        assertXPathValue(context, \"substring('12345', 1, 0 div 0)\", \"\");\n+        assertXPathValue(context, \"substring('12345', -42, 1 div 0)\", \"12345\");\n+        assertXPathValue(context, \"substring('12345', -1 div 0, 1 div 0)\", \"\");\n+        assertXPathValue(context, \"string-length('12345')\", new Double(5));\n+        assertXPathValue(context, \"normalize-space(' abc  def  ')\", \"abc def\");\n+        assertXPathValue(context, \"normalize-space('abc def')\", \"abc def\");\n+        assertXPathValue(context, \"normalize-space('   ')\", \"\");\n+        assertXPathValue(context, \"translate('--aaa--', 'abc-', 'ABC')\", \"AAA\");\n+        assertXPathValue(context, \"boolean(1)\", Boolean.TRUE);\n+        assertXPathValue(context, \"boolean(0)\", Boolean.FALSE);\n+        assertXPathValue(context, \"boolean('x')\", Boolean.TRUE);\n+        assertXPathValue(context, \"boolean('')\", Boolean.FALSE);\n+\n+        assertXPathValue(context, \"true()\", Boolean.TRUE);\n+        assertXPathValue(context, \"false()\", Boolean.FALSE);\n+        assertXPathValue(context, \"not(false())\", Boolean.TRUE);\n+        assertXPathValue(context, \"not(true())\", Boolean.FALSE);\n+        assertXPathValue(context, \"number('1')\", new Double(1));\n+        assertXPathValue(context, \"floor(1.5)\", new Double(1));\n+        assertXPathValue(context, \"floor(-1.5)\", new Double(-2));\n+        assertXPathValue(context, \"ceiling(1.5)\", new Double(2));\n+        assertXPathValue(context, \"ceiling(-1.5)\", new Double(-1));\n+        assertXPathValue(context, \"round(1.5)\", new Double(2));\n+        assertXPathValue(context, \"round(-1.5)\", new Double(-1));\n+        assertXPathValue(context, \"null()\", null);\n     }\n \n-    public void testIDFunction(){\n-        context.setIdentityManager(new IdentityManager(){\n-            public Pointer getPointerByID(JXPathContext context, String id){\n-                NodePointer ptr = (NodePointer)context.\n-                        getPointer(\"/document\");\n+    public void testIDFunction() {\n+        context.setIdentityManager(new IdentityManager() {\n+            public Pointer getPointerByID(JXPathContext context, String id) {\n+                NodePointer ptr = (NodePointer) context.getPointer(\"/document\");\n                 ptr = ptr.getValuePointer();\n                 return ptr.getPointerByID(context, id);\n             }\n         });\n \n-        assertXPathValueAndPointer(context,\n-                \"id(101)//street\",\n-                \"Tangerine Drive\",\n-                \"id('101')/address[1]/street[1]\");\n+        assertXPathValueAndPointer(\n+            context,\n+            \"id(101)//street\",\n+            \"Tangerine Drive\",\n+            \"id('101')/address[1]/street[1]\");\n \n-        assertXPathPointerLenient(context,\n-                \"id(105)/address/street\",\n-                \"id(105)/address/street\");\n+        assertXPathPointerLenient(\n+            context,\n+            \"id(105)/address/street\",\n+            \"id(105)/address/street\");\n     }\n-    \n-    public void testKeyFunction(){\n-        context.setKeyManager(new KeyManager(){\n-            public Pointer getPointerByKey(JXPathContext context,\n-                                            String key, String value){\n+\n+    public void testKeyFunction() {\n+        context.setKeyManager(new KeyManager() {\n+            public Pointer getPointerByKey(\n+                JXPathContext context,\n+                String key,\n+                String value) \n+            {\n                 return NodePointer.newNodePointer(null, \"42\", null);\n             }\n         });\n-        \n-        assertEquals(\"Test key\", \"42\",\n-            context.getValue(\"key('a', 'b')\"));\n+\n+        assertEquals(\"Test key\", \"42\", context.getValue(\"key('a', 'b')\"));\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/CoreOperationTest.java,v 1.2 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * operations.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:27 $\n  */\n \n-public class CoreOperationTest extends JXPathTestCase\n-{\n+public class CoreOperationTest extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public CoreOperationTest(String name){\n+    public CoreOperationTest(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(null);\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"integer\", new Integer(1));\n         }\n     }\n \n-    public void testInfoSetTypes(){\n+    public void testInfoSetTypes() {\n \n         // Numbers\n-        assertXPathValue(context, \"1\",  new Double(1.0));\n+        assertXPathValue(context, \"1\", new Double(1.0));\n         assertXPathPointer(context, \"1\", \"1\");\n-        assertXPathValueIterator(context,\"1\", list(new Double(1.0)));\n+        assertXPathValueIterator(context, \"1\", list(new Double(1.0)));\n \n         assertXPathPointerIterator(context, \"1\", list(\"1\"));\n \n-        assertXPathValue(context,\"-1\", new Double(-1.0));\n-        assertXPathValue(context,\"2 + 2\", new Double(4.0));\n-        assertXPathValue(context,\"3 - 2\", new Double(1.0));\n-        assertXPathValue(context,\"1 + 2 + 3 - 4 + 5\", new Double(7.0));\n-        assertXPathValue(context,\"3 * 2\", new Double(3.0*2.0));\n-        assertXPathValue(context,\"3 div 2\", new Double(3.0/2.0));\n-        assertXPathValue(context,\"5 mod 2\", new Double(1.0));\n+        assertXPathValue(context, \"-1\", new Double(-1.0));\n+        assertXPathValue(context, \"2 + 2\", new Double(4.0));\n+        assertXPathValue(context, \"3 - 2\", new Double(1.0));\n+        assertXPathValue(context, \"1 + 2 + 3 - 4 + 5\", new Double(7.0));\n+        assertXPathValue(context, \"3 * 2\", new Double(3.0 * 2.0));\n+        assertXPathValue(context, \"3 div 2\", new Double(3.0 / 2.0));\n+        assertXPathValue(context, \"5 mod 2\", new Double(1.0));\n \n         // This test produces a different result with Xalan?\n-        assertXPathValue(context,\"5.9 mod 2.1\", new Double(1.0));\n+        assertXPathValue(context, \"5.9 mod 2.1\", new Double(1.0));\n \n-        assertXPathValue(context,\"5 mod -2\", new Double(1.0));\n-        assertXPathValue(context,\"-5 mod 2\", new Double(-1.0));\n-        assertXPathValue(context,\"-5 mod -2\", new Double(-1.0));\n-        assertXPathValue(context,\"1 < 2\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 > 2\", Boolean.FALSE);\n-        assertXPathValue(context,\"1 <= 1\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 >= 2\", Boolean.FALSE);\n-        assertXPathValue(context,\"3 > 2 > 1\", Boolean.FALSE);\n-        assertXPathValue(context,\"3 > 2 and 2 > 1\", Boolean.TRUE);\n-        assertXPathValue(context,\"3 > 2 and 2 < 1\", Boolean.FALSE);\n-        assertXPathValue(context,\"3 < 2 or 2 > 1\", Boolean.TRUE);\n-        assertXPathValue(context,\"3 < 2 or 2 < 1\", Boolean.FALSE);\n-        assertXPathValue(context,\"1 = 1\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 = '1'\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 > 2 = 2 > 3\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 > 2 = 0\", Boolean.TRUE);\n-        assertXPathValue(context,\"1 = 2\", Boolean.FALSE);\n+        assertXPathValue(context, \"5 mod -2\", new Double(1.0));\n+        assertXPathValue(context, \"-5 mod 2\", new Double(-1.0));\n+        assertXPathValue(context, \"-5 mod -2\", new Double(-1.0));\n+        assertXPathValue(context, \"1 < 2\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 > 2\", Boolean.FALSE);\n+        assertXPathValue(context, \"1 <= 1\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 >= 2\", Boolean.FALSE);\n+        assertXPathValue(context, \"3 > 2 > 1\", Boolean.FALSE);\n+        assertXPathValue(context, \"3 > 2 and 2 > 1\", Boolean.TRUE);\n+        assertXPathValue(context, \"3 > 2 and 2 < 1\", Boolean.FALSE);\n+        assertXPathValue(context, \"3 < 2 or 2 > 1\", Boolean.TRUE);\n+        assertXPathValue(context, \"3 < 2 or 2 < 1\", Boolean.FALSE);\n+        assertXPathValue(context, \"1 = 1\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 = '1'\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 > 2 = 2 > 3\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 > 2 = 0\", Boolean.TRUE);\n+        assertXPathValue(context, \"1 = 2\", Boolean.FALSE);\n \n-        assertXPathValue(context, \n-                \"$integer\",\n-                new Double(1), \n-                Double.class);\n-                \n-        assertXPathValue(context, \n-                \"2 + 3\",\n-                \"5.0\",\n-                String.class);\n-                \n-        assertXPathValue(context, \n-                \"2 + 3\",\n-                Boolean.TRUE, \n-                boolean.class);\n-                \n-        assertXPathValue(context, \n-                \"'true'\",\n-                Boolean.TRUE, \n-                Boolean.class);\n+        assertXPathValue(context, \"$integer\", new Double(1), Double.class);\n+\n+        assertXPathValue(context, \"2 + 3\", \"5.0\", String.class);\n+\n+        assertXPathValue(context, \"2 + 3\", Boolean.TRUE, boolean.class);\n+\n+        assertXPathValue(context, \"'true'\", Boolean.TRUE, Boolean.class);\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.3 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java,v 1.4 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test extension functions.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/20 00:00:27 $\n  */\n \n-public class ExtensionFunctionTest extends JXPathTestCase\n-{\n+public class ExtensionFunctionTest extends JXPathTestCase {\n     private Functions functions;\n     private JXPathContext context;\n \n      *\n      * @param name Name of the test case\n      */\n-    public ExtensionFunctionTest(String name){\n+    public ExtensionFunctionTest(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(new TestBean());\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"test\", new TestFunctions(4, \"test\"));\n-           \n+\n             FunctionLibrary lib = new FunctionLibrary();\n             lib.addFunctions(new ClassFunctions(TestFunctions.class, \"test\"));\n             lib.addFunctions(new ClassFunctions(TestFunctions2.class, \"test\"));\n             lib.addFunctions(new PackageFunctions(\"\", \"call\"));\n             lib.addFunctions(\n-                    new PackageFunctions(\n-                            \"org.apache.commons.jxpath.ri.compiler.\", \n-                            \"jxpathtest\"));\n+                new PackageFunctions(\n+                    \"org.apache.commons.jxpath.ri.compiler.\",\n+                    \"jxpathtest\"));\n             context.setFunctions(lib);\n         }\n         functions = new ClassFunctions(TestFunctions.class, \"test\");\n     }\n-    \n-    public void testConstructorLookup(){\n-        Object[] args = new Object[]{new Integer(1), \"x\"};\n+\n+    public void testConstructorLookup() {\n+        Object[] args = new Object[] { new Integer(1), \"x\" };\n         Function func = functions.getFunction(\"test\", \"new\", args);\n-        \n-        assertEquals(\"test:new(1, x)\", \n-            func.invoke(new Context(null), args).toString(), \n+\n+        assertEquals(\n+            \"test:new(1, x)\",\n+            func.invoke(new Context(null), args).toString(),\n             \"foo=1; bar=x\");\n     }\n-    \n-    public void testConstructorLookupWithExpressionContext(){\n-        Object[] args = new Object[]{\"baz\"};\n-        Function func =functions.getFunction(\"test\", \"new\", args);\n-        assertEquals(\"test:new('baz')\", \n-                func.invoke(new Context(new Integer(1)), args).toString(), \n-                \"foo=1; bar=baz\");\n-    }\n-    \n-    public void testStaticMethodLookup(){\n-        Object[] args = new Object[]{new Integer(1), \"x\"};\n-        Function func =functions.getFunction(\"test\", \"build\", args);\n-        assertEquals(\"test:build(1, x)\", \n-                func.invoke(new Context(null), args).toString(), \n-                \"foo=1; bar=x\");\n-    }\n-    \n-    public void testStaticMethodLookupWithConversion(){\n-        Object[] args = new Object[]{\"7\", new Integer(1)};\n-        Function func =functions.getFunction(\"test\", \"build\", args);\n-        assertEquals(\"test:build('7', 1)\", \n-                func.invoke(new Context(null), args).toString(), \n-                \"foo=7; bar=1\");\n-    }\n-    \n-    public void testMethodLookup(){\n-        Object[] args = new Object[]{new TestFunctions()};\n-        Function func =functions.getFunction(\"test\", \"getFoo\", args);\n-        assertEquals(\"test:getFoo($test, 1, x)\", \n-                func.invoke(new Context(null), args).toString(), \n-                \"0\");\n-    }\n-    \n-    public void testStaticMethodLookupWithExpressionContext(){\n+\n+    public void testConstructorLookupWithExpressionContext() {\n+        Object[] args = new Object[] { \"baz\" };\n+        Function func = functions.getFunction(\"test\", \"new\", args);\n+        assertEquals(\n+            \"test:new('baz')\",\n+            func.invoke(new Context(new Integer(1)), args).toString(),\n+            \"foo=1; bar=baz\");\n+    }\n+\n+    public void testStaticMethodLookup() {\n+        Object[] args = new Object[] { new Integer(1), \"x\" };\n+        Function func = functions.getFunction(\"test\", \"build\", args);\n+        assertEquals(\n+            \"test:build(1, x)\",\n+            func.invoke(new Context(null), args).toString(),\n+            \"foo=1; bar=x\");\n+    }\n+\n+    public void testStaticMethodLookupWithConversion() {\n+        Object[] args = new Object[] { \"7\", new Integer(1)};\n+        Function func = functions.getFunction(\"test\", \"build\", args);\n+        assertEquals(\n+            \"test:build('7', 1)\",\n+            func.invoke(new Context(null), args).toString(),\n+            \"foo=7; bar=1\");\n+    }\n+\n+    public void testMethodLookup() {\n+        Object[] args = new Object[] { new TestFunctions()};\n+        Function func = functions.getFunction(\"test\", \"getFoo\", args);\n+        assertEquals(\n+            \"test:getFoo($test, 1, x)\",\n+            func.invoke(new Context(null), args).toString(),\n+            \"0\");\n+    }\n+\n+    public void testStaticMethodLookupWithExpressionContext() {\n         Object[] args = new Object[0];\n-        Function func =functions.getFunction(\"test\", \"path\", args);\n-        assertEquals(\"test:path()\", \n-                func.invoke(new Context(new Integer(1)), args), \n-                \"1\");\n-    }\n-    \n-    public void testMethodLookupWithExpressionContext(){\n-        Object[] args = new Object[]{new TestFunctions()};\n-        Function func =functions.getFunction(\"test\", \"instancePath\", args);\n-        assertEquals(\"test:instancePath()\", \n-                func.invoke(new Context(new Integer(1)), args), \n-                \"1\");\n-    }\n-    \n-    public void testMethodLookupWithExpressionContextAndArgument(){\n-        Object[] args = new Object[]{new TestFunctions(), \"*\"};\n-        Function func =functions.getFunction(\"test\", \"pathWithSuffix\", args);\n-        assertEquals(\"test:pathWithSuffix('*')\", \n-                func.invoke(new Context(new Integer(1)), args), \n-                \"1*\");\n-    }    \n-\n-    public void testAllocation(){ \n-        \n+        Function func = functions.getFunction(\"test\", \"path\", args);\n+        assertEquals(\n+            \"test:path()\",\n+            func.invoke(new Context(new Integer(1)), args),\n+            \"1\");\n+    }\n+\n+    public void testMethodLookupWithExpressionContext() {\n+        Object[] args = new Object[] { new TestFunctions()};\n+        Function func = functions.getFunction(\"test\", \"instancePath\", args);\n+        assertEquals(\n+            \"test:instancePath()\",\n+            func.invoke(new Context(new Integer(1)), args),\n+            \"1\");\n+    }\n+\n+    public void testMethodLookupWithExpressionContextAndArgument() {\n+        Object[] args = new Object[] { new TestFunctions(), \"*\" };\n+        Function func = functions.getFunction(\"test\", \"pathWithSuffix\", args);\n+        assertEquals(\n+            \"test:pathWithSuffix('*')\",\n+            func.invoke(new Context(new Integer(1)), args),\n+            \"1*\");\n+    }\n+\n+    public void testAllocation() {\n+\n         // Allocate new object using the default constructor\n-        assertXPathValue(context, \n-                \"string(test:new())\", \n-                \"foo=0; bar=null\");\n-                \n+        assertXPathValue(context, \"string(test:new())\", \"foo=0; bar=null\");\n+\n         // Allocate new object using PackageFunctions and class name\n-        assertXPathValue(context, \n-                \"string(jxpathtest:TestFunctions.new())\", \n-                \"foo=0; bar=null\");\n-                \n+        assertXPathValue(\n+            context,\n+            \"string(jxpathtest:TestFunctions.new())\",\n+            \"foo=0; bar=null\");\n+\n         // Allocate new object using a fully qualified class name\n-        assertXPathValue(context, \n-                \"string(\" + TestFunctions.class.getName() + \".new())\", \n-                \"foo=0; bar=null\");\n-                \n+        assertXPathValue(\n+            context,\n+            \"string(\" + TestFunctions.class.getName() + \".new())\",\n+            \"foo=0; bar=null\");\n+\n         // Allocate new object using a custom constructor\n-        assertXPathValue(context, \n-                \"string(test:new(3, 'baz'))\", \n-                \"foo=3; bar=baz\");\n-                \n+        assertXPathValue(\n+            context,\n+            \"string(test:new(3, 'baz'))\",\n+            \"foo=3; bar=baz\");\n+\n         // Allocate new object using a custom constructor - type conversion\n-        assertXPathValue(context, \n-                \"string(test:new('3', 4))\", \n-                \"foo=3; bar=4.0\");                \n-    }\n-\n-    public void testMethodCall(){ \n-        assertXPathValue(context, \n-                \"length('foo')\", \n-                new Integer(3));\n-                \n+        assertXPathValue(context, \"string(test:new('3', 4))\", \"foo=3; bar=4.0\");\n+    }\n+\n+    public void testMethodCall() {\n+        assertXPathValue(context, \"length('foo')\", new Integer(3));\n+\n         // We are just calling a method - prefix is ignored\n-        assertXPathValue(context, \n-                \"call:substring('foo', 1, 2)\", \n-                \"o\");\n-        \n+        assertXPathValue(context, \"call:substring('foo', 1, 2)\", \"o\");\n+\n         // Invoke a function implemented as a regular method\n-        assertXPathValue(context, \n-                \"string(test:getFoo($test))\", \n-                \"4\");\n-        \n+        assertXPathValue(context, \"string(test:getFoo($test))\", \"4\");\n+\n         // Note that the prefix is ignored anyway, we are just calling a method\n-        assertXPathValue(context, \n-                \"string(call:getFoo($test))\", \n-                \"4\");\n-        \n+        assertXPathValue(context, \"string(call:getFoo($test))\", \"4\");\n+\n         // We don't really need to supply a prefix in this case\n-        assertXPathValue(context, \n-                \"string(getFoo($test))\", \n-                \"4\");                \n+        assertXPathValue(context, \"string(getFoo($test))\", \"4\");\n \n         // Method with two arguments\n-        assertXPathValue(context, \n-                \"string(test:setFooAndBar($test, 7, 'biz'))\", \n-                \"foo=7; bar=biz\");\n-    }\n-\n-    public void testStaticMethodCall(){ \n-                                \n-        assertXPathValue(context, \n-                \"string(test:build(8, 'goober'))\", \n-                \"foo=8; bar=goober\");\n-                \n+        assertXPathValue(\n+            context,\n+            \"string(test:setFooAndBar($test, 7, 'biz'))\",\n+            \"foo=7; bar=biz\");\n+    }\n+\n+    public void testStaticMethodCall() {\n+\n+        assertXPathValue(\n+            context,\n+            \"string(test:build(8, 'goober'))\",\n+            \"foo=8; bar=goober\");\n+\n         // Call a static method using PackageFunctions and class name\n-        assertXPathValue(context, \n-                \"string(jxpathtest:TestFunctions.build(8, 'goober'))\", \n-                \"foo=8; bar=goober\");\n-        \n+        assertXPathValue(\n+            context,\n+            \"string(jxpathtest:TestFunctions.build(8, 'goober'))\",\n+            \"foo=8; bar=goober\");\n+\n         // Call a static method with a fully qualified class name\n-        assertXPathValue(context, \n-                \"string(\" + TestFunctions.class.getName() + \n-                        \".build(8, 'goober'))\", \n-                \"foo=8; bar=goober\");\n-                \n+        assertXPathValue(\n+            context,\n+            \"string(\" + TestFunctions.class.getName() + \".build(8, 'goober'))\",\n+            \"foo=8; bar=goober\");\n+\n         // Two ClassFunctions are sharing the same prefix.\n         // This is TestFunctions2\n-        assertXPathValue(context, \n-                \"string(test:increment(8))\", \n-                \"9\");\n-                \n-    }\n-\n-    public void testExpressionContext(){ \n+        assertXPathValue(context, \"string(test:increment(8))\", \"9\");\n+\n+    }\n+\n+    public void testExpressionContext() {\n         // Execute an extension function for each node while searching\n         // The function uses ExpressionContext to get to the current\n         // node.\n-        assertXPathValue(context, \n-                \"//.[test:isMap()]/Key1\", \n-                \"Value 1\");\n-                \n+        assertXPathValue(context, \"//.[test:isMap()]/Key1\", \"Value 1\");\n+\n         // The function uses ExpressionContext to get to all\n         // nodes in the context that is passed to it.\n-        assertXPathValue(context, \n-                \"count(//.[test:count(strings) = 3])\", \n-                new Double(7));\n+        assertXPathValue(\n+            context,\n+            \"count(//.[test:count(strings) = 3])\",\n+            new Double(7));\n \n         // The function uses ExpressionContext to get to the current\n         // pointer and returns its path.\n-        assertXPathValue(context, \n-                \"/beans[contains(test:path(), '[2]')]/name\", \n-                \"Name 2\");\n-    }\n-    \n+        assertXPathValue(\n+            context,\n+            \"/beans[contains(test:path(), '[2]')]/name\",\n+            \"Name 2\");\n+    }\n+\n     private static class Context implements ExpressionContext {\n         private Object object;\n \n-        public Context(Object object){\n+        public Context(Object object) {\n             this.object = object;\n         }\n \n-        public Pointer getContextNodePointer(){\n-            return NodePointer.newNodePointer(null, object, Locale.getDefault());\n-        }\n-\n-        public List getContextNodeList(){\n+        public Pointer getContextNodePointer() {\n+            return NodePointer.newNodePointer(\n+                null,\n+                object,\n+                Locale.getDefault());\n+        }\n+\n+        public List getContextNodeList() {\n             return null;\n         }\n \n-        public JXPathContext getJXPathContext(){\n+        public JXPathContext getJXPathContext() {\n             return null;\n         }\n \n-        public int getPosition(){\n+        public int getPosition() {\n             return 0;\n         }\n     }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.2 2002/11/26 01:33:34 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:33:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java,v 1.3 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:33:34 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class TestFunctions {\n \n     private int foo;\n     private String bar;\n \n-    public TestFunctions(){\n+    public TestFunctions() {\n     }\n \n-    public TestFunctions(int foo, String bar){\n+    public TestFunctions(int foo, String bar) {\n         this.foo = foo;\n         this.bar = bar;\n     }\n \n-    public TestFunctions(ExpressionContext context, String bar){\n-        this.foo = ((Number)context.getContextNodePointer().getValue()).\n-                intValue();\n+    public TestFunctions(ExpressionContext context, String bar) {\n+        this.foo =\n+            ((Number) context.getContextNodePointer().getValue()).intValue();\n         this.bar = bar;\n     }\n \n-    public int getFoo(){\n+    public int getFoo() {\n         return foo;\n     }\n \n-    public String getBar(){\n+    public String getBar() {\n         return bar;\n     }\n \n-    public void doit(){\n+    public void doit() {\n     }\n \n-    public TestFunctions setFooAndBar(int foo, String bar){\n+    public TestFunctions setFooAndBar(int foo, String bar) {\n         this.foo = foo;\n         this.bar = bar;\n         return this;\n     }\n \n-    public static TestFunctions build(int foo, String bar){\n+    public static TestFunctions build(int foo, String bar) {\n         return new TestFunctions(foo, bar);\n     }\n \n-    public String toString(){\n+    public String toString() {\n         return \"foo=\" + foo + \"; bar=\" + bar;\n     }\n \n-    public static String path(ExpressionContext context){\n+    public static String path(ExpressionContext context) {\n         return context.getContextNodePointer().asPath();\n     }\n \n-    public String instancePath(ExpressionContext context){\n+    public String instancePath(ExpressionContext context) {\n         return context.getContextNodePointer().asPath();\n     }\n \n-    public String pathWithSuffix(ExpressionContext context, String suffix){\n+    public String pathWithSuffix(ExpressionContext context, String suffix) {\n         return context.getContextNodePointer().asPath() + suffix;\n     }\n \n-    public String className(ExpressionContext context, ExpressionContext child){\n+    public String className(\n+        ExpressionContext context,\n+        ExpressionContext child) \n+    {\n         return context.getContextNodePointer().asPath();\n     }\n \n     /**\n      * Returns true if the current node in the current context is a map\n      */\n-    public static boolean isMap(ExpressionContext context){\n+    public static boolean isMap(ExpressionContext context) {\n         Pointer ptr = context.getContextNodePointer();\n         return ptr == null ? false : (ptr.getValue() instanceof Map);\n     }\n      * Returns the number of nodes in the context that is passed as\n      * the first argument.\n      */\n-    public static int count(ExpressionContext context, Collection col){\n+    public static int count(ExpressionContext context, Collection col) {\n         return col.size();\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions2.java,v 1.3 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class TestFunctions2 {\n \n-    public static int increment(int i){\n+    public static int increment(int i) {\n         return i + 1;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableFactory.java,v 1.2 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:27 $\n  */\n public class VariableFactory extends AbstractFactory {\n \n     /**\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n-        if (name.equals(\"testArray\")){\n-            ((TestBean[])parent)[index] = new TestBean();\n+    public boolean createObject(\n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n+    {\n+        if (name.equals(\"testArray\")) {\n+            ((TestBean[]) parent)[index] = new TestBean();\n             return true;\n         }\n-        else if (name.equals(\"stringArray\")){\n-            ((String[])parent)[index] = \"\";\n+        else if (name.equals(\"stringArray\")) {\n+            ((String[]) parent)[index] = \"\";\n             return true;\n         }\n-        else if (name.equals(\"array\")){\n-            ((String[])parent)[index] = \"\";\n+        else if (name.equals(\"array\")) {\n+            ((String[]) parent)[index] = \"\";\n             return true;\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Create a new object and set it on the specified variable\n      */\n-    public boolean declareVariable(JXPathContext context, String name){\n-        if (name.equals(\"test\")){\n+    public boolean declareVariable(JXPathContext context, String name) {\n+        if (name.equals(\"test\")) {\n             context.getVariables().declareVariable(name, new TestBean());\n             return true;\n         }\n-        else if (name.equals(\"testArray\")){\n+        else if (name.equals(\"testArray\")) {\n             context.getVariables().declareVariable(name, new TestBean[0]);\n             return true;\n         }\n-        else if (name.equals(\"stringArray\")){\n-            context.getVariables().declareVariable(name, new String[]{\"Value1\"});\n+        else if (name.equals(\"stringArray\")) {\n+            context.getVariables().declareVariable(\n+                name,\n+                new String[] { \"Value1\" });\n             return true;\n         }\n         context.getVariables().declareVariable(name, null);\n--- a/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/compiler/VariableTest.java,v 1.2 2003/01/20 00:00:27 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:27 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * operations.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:27 $\n  */\n \n-public class VariableTest extends JXPathTestCase\n-{\n+public class VariableTest extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public VariableTest(String name){\n+    public VariableTest(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(null);\n             context.setFactory(new VariableFactory());\n-        \n+\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"a\", new Double(1));\n             vars.declareVariable(\"b\", new Double(1));\n-            vars.declareVariable(\"c\", null);            \n-            vars.declareVariable(\"d\", new String[]{\"a\", \"b\"});\n+            vars.declareVariable(\"c\", null);\n+            vars.declareVariable(\"d\", new String[] { \"a\", \"b\" });\n             vars.declareVariable(\"integer\", new Integer(1));\n             vars.declareVariable(\"nan\", new Double(Double.NaN));\n             vars.declareVariable(\"x\", null);\n         }\n     }\n \n-    public void testVariables(){\n+    public void testVariables() {\n         // Variables\n-        assertXPathValueAndPointer(context,\n-                \"$a\", \n-                new Double(1),\n-                \"$a\");\n-    }\n-    \n-    public void testVariablesInExpressions(){\n-        assertXPathValue(context,\n-                \"$a = $b\", \n-                Boolean.TRUE);\n-                \n-        assertXPathValue(context,\n-                \"$a = $nan\", \n-                Boolean.FALSE);\n-\n-        assertXPathValue(context,\n-                \"$a + 1\", \n-                new Double(2));\n-\n-        assertXPathValue(context,\n-                \"$c\", \n-                null);\n-                \n-        assertXPathValue(context, \n-                \"$d[2]\",  \n-                \"b\");\n-    }\n-    \n-    public void testInvalidVariableName(){                \n+        assertXPathValueAndPointer(context, \"$a\", new Double(1), \"$a\");\n+    }\n+\n+    public void testVariablesInExpressions() {\n+        assertXPathValue(context, \"$a = $b\", Boolean.TRUE);\n+\n+        assertXPathValue(context, \"$a = $nan\", Boolean.FALSE);\n+\n+        assertXPathValue(context, \"$a + 1\", new Double(2));\n+\n+        assertXPathValue(context, \"$c\", null);\n+\n+        assertXPathValue(context, \"$d[2]\", \"b\");\n+    }\n+\n+    public void testInvalidVariableName() {\n         boolean exception = false;\n         try {\n             context.getValue(\"$none\");\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             exception = true;\n         }\n-        assertTrue(\"Evaluating '$none', expected exception - did not get it\", \n-                exception);\n+        assertTrue(\n+            \"Evaluating '$none', expected exception - did not get it\",\n+            exception);\n \n         exception = false;\n         try {\n             context.setValue(\"$none\", new Integer(1));\n         }\n-        catch (Exception ex){\n+        catch (Exception ex) {\n             exception = true;\n         }\n-        assertTrue(\"Setting '$none = 1', expected exception - did not get it\", \n+        assertTrue(\n+            \"Setting '$none = 1', expected exception - did not get it\",\n             exception);\n     }\n-    \n-    public void testNestedContext(){\n-        JXPathContext nestedContext = \n-                JXPathContext.newContext(context, null);\n-\n-        assertXPathValue(nestedContext, \n-                \"$a\",  \n-                new Double(1));\n-    }    \n-    \n-    public void testSetValue(){        \n-        assertXPathSetValue(context, \n-                \"$x\",\n-                new Integer(1));\n-    }\n-    \n-    public void testCreatePathDeclareVariable(){\n+\n+    public void testNestedContext() {\n+        JXPathContext nestedContext = JXPathContext.newContext(context, null);\n+\n+        assertXPathValue(nestedContext, \"$a\", new Double(1));\n+    }\n+\n+    public void testSetValue() {\n+        assertXPathSetValue(context, \"$x\", new Integer(1));\n+    }\n+\n+    public void testCreatePathDeclareVariable() {\n         // Calls factory.declareVariable(\"string\")\n-        assertXPathCreatePath(context, \n-                \"$string\", \n-                null,\n-                \"$string\");\n-    }\n-    \n-    public void testCreatePathAndSetValueDeclareVariable(){\n+        assertXPathCreatePath(context, \"$string\", null, \"$string\");\n+    }\n+\n+    public void testCreatePathAndSetValueDeclareVariable() {\n         // Calls factory.declareVariable(\"string\")\n-        assertXPathCreatePathAndSetValue(context, \n-                \"$string\", \n-                \"Value\",\n-                \"$string\");\n-    }\n-    \n-    public void testCreatePathDeclareVariableSetCollectionElement(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"$string\",\n+            \"Value\",\n+            \"$string\");\n+    }\n+\n+    public void testCreatePathDeclareVariableSetCollectionElement() {\n         // Calls factory.declareVariable(\"stringArray\"). \n         // The factory needs to create a collection\n-        assertXPathCreatePath(context, \n-                \"$stringArray[2]\", \n-                \"\",\n-                \"$stringArray[2]\");\n-        \n+        assertXPathCreatePath(\n+            context,\n+            \"$stringArray[2]\",\n+            \"\",\n+            \"$stringArray[2]\");\n+\n         // See if the factory populated the first element as well\n-        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \n-                \"Value1\", \n-                context.getValue(\"$stringArray[1]\"));\n-    }\n-\n-    public void testCreateAndSetValuePathDeclareVariableSetCollectionElement(){\n+        assertEquals(\n+            \"Created <\" + \"$stringArray[1]\" + \">\",\n+            \"Value1\",\n+            context.getValue(\"$stringArray[1]\"));\n+    }\n+\n+    public void testCreateAndSetValuePathDeclareVariableSetCollectionElement() {\n         // Calls factory.declareVariable(\"stringArray\"). \n         // The factory needs to create a collection\n-        assertXPathCreatePathAndSetValue(context, \n-                \"$stringArray[2]\", \n-                \"Value2\",\n-                \"$stringArray[2]\");\n-        \n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"$stringArray[2]\",\n+            \"Value2\",\n+            \"$stringArray[2]\");\n+\n         // See if the factory populated the first element as well\n-        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \n-                \"Value1\", \n-                context.getValue(\"$stringArray[1]\"));\n-    }\n-\n-    public void testCreatePathExpandCollection(){\n-        context.getVariables().\n-            declareVariable(\"array\", new String[]{\"Value1\"});\n+        assertEquals(\n+            \"Created <\" + \"$stringArray[1]\" + \">\",\n+            \"Value1\",\n+            context.getValue(\"$stringArray[1]\"));\n+    }\n+\n+    public void testCreatePathExpandCollection() {\n+        context.getVariables().declareVariable(\n+            \"array\",\n+            new String[] { \"Value1\" });\n \n         // Does not involve factory at all - just expands the collection\n-        assertXPathCreatePath(context, \n-                \"$array[2]\", \n-                \"\", \n-                \"$array[2]\");\n+        assertXPathCreatePath(context, \"$array[2]\", \"\", \"$array[2]\");\n \n         // Make sure it is still the same array\n-        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \n-                \"Value1\", \n-                context.getValue(\"$array[1]\"));\n-    }\n-\n-    public void testCreatePathAndSetValueExpandCollection(){\n-        context.getVariables().\n-            declareVariable(\"array\", new String[]{\"Value1\"});\n+        assertEquals(\n+            \"Created <\" + \"$array[1]\" + \">\",\n+            \"Value1\",\n+            context.getValue(\"$array[1]\"));\n+    }\n+\n+    public void testCreatePathAndSetValueExpandCollection() {\n+        context.getVariables().declareVariable(\n+            \"array\",\n+            new String[] { \"Value1\" });\n \n         // Does not involve factory at all - just expands the collection\n-        assertXPathCreatePathAndSetValue(context, \n-                \"$array[2]\", \n-                \"Value2\", \n-                \"$array[2]\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"$array[2]\",\n+            \"Value2\",\n+            \"$array[2]\");\n \n         // Make sure it is still the same array\n-        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \n-                \"Value1\", \n-                context.getValue(\"$array[1]\"));\n-    }\n-\n-    public void testCreatePathDeclareVariableSetProperty(){\n+        assertEquals(\n+            \"Created <\" + \"$array[1]\" + \">\",\n+            \"Value1\",\n+            context.getValue(\"$array[1]\"));\n+    }\n+\n+    public void testCreatePathDeclareVariableSetProperty() {\n         // Calls factory.declareVariable(\"test\"). \n         // The factory should create a TestBean\n-        assertXPathCreatePath(context, \n-                \"$test/boolean\", \n-                Boolean.FALSE, \n-                \"$test/boolean\");\n-\n-    }\n-\n-    public void testCreatePathAndSetValueDeclareVariableSetProperty(){\n+        assertXPathCreatePath(\n+            context,\n+            \"$test/boolean\",\n+            Boolean.FALSE,\n+            \"$test/boolean\");\n+\n+    }\n+\n+    public void testCreatePathAndSetValueDeclareVariableSetProperty() {\n         // Calls factory.declareVariable(\"test\"). \n         // The factory should create a TestBean\n-        assertXPathCreatePathAndSetValue(context, \n-                \"$test/boolean\", \n-                Boolean.TRUE, \n-                \"$test/boolean\");\n-\n-    }\n-\n-    public void testCreatePathDeclareVariableSetCollectionElementProperty(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"$test/boolean\",\n+            Boolean.TRUE,\n+            \"$test/boolean\");\n+\n+    }\n+\n+    public void testCreatePathDeclareVariableSetCollectionElementProperty() {\n         // Calls factory.declareVariable(\"testArray\").\n         // The factory should create a collection of TestBeans.\n         // Then calls factory.createObject(..., collection, \"testArray\", 1).\n         // That one should produce an instance of TestBean and \n         // put it in the collection at index 1.\n-        assertXPathCreatePath(context, \n-                \"$testArray[2]/boolean\", \n-                Boolean.FALSE, \n-                \"$testArray[2]/boolean\");\n-    }\n-    \n-    public void testCreatePathAndSetValueDeclVarSetCollectionElementProperty(){\n+        assertXPathCreatePath(\n+            context,\n+            \"$testArray[2]/boolean\",\n+            Boolean.FALSE,\n+            \"$testArray[2]/boolean\");\n+    }\n+\n+    public void testCreatePathAndSetValueDeclVarSetCollectionElementProperty() {\n         // Calls factory.declareVariable(\"testArray\").\n         // The factory should create a collection of TestBeans.\n         // Then calls factory.createObject(..., collection, \"testArray\", 1).\n         // That one should produce an instance of TestBean and \n         // put it in the collection at index 1.\n-        assertXPathCreatePathAndSetValue(context, \n-                \"$testArray[2]/boolean\", \n-                Boolean.TRUE, \n-                \"$testArray[2]/boolean\");\n-    }\n-    \n-    public void testRemovePathUndeclareVariable(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"$testArray[2]/boolean\",\n+            Boolean.TRUE,\n+            \"$testArray[2]/boolean\");\n+    }\n+\n+    public void testRemovePathUndeclareVariable() {\n         // Undeclare variable\n         context.getVariables().declareVariable(\"temp\", \"temp\");\n         context.removePath(\"$temp\");\n-        assertTrue(\"Undeclare variable\",\n-                !context.getVariables().isDeclaredVariable(\"temp\"));\n-\n-    }\n-    \n-    public void testRemovePathArrayElement(){\n+        assertTrue(\n+            \"Undeclare variable\",\n+            !context.getVariables().isDeclaredVariable(\"temp\"));\n+\n+    }\n+\n+    public void testRemovePathArrayElement() {\n         // Remove array element - reassigns the new array to the var\n-        context.getVariables().\n-                declareVariable(\"temp\", new String[]{\"temp1\", \"temp2\"});\n+        context.getVariables().declareVariable(\n+            \"temp\",\n+            new String[] { \"temp1\", \"temp2\" });\n         context.removePath(\"$temp[1]\");\n-        assertEquals(\"Remove array element\", \"temp2\",\n-                    context.getValue(\"$temp[1]\"));\n-    }\n-    \n-    public void testRemovePathCollectionElement(){\n+        assertEquals(\n+            \"Remove array element\",\n+            \"temp2\",\n+            context.getValue(\"$temp[1]\"));\n+    }\n+\n+    public void testRemovePathCollectionElement() {\n         // Remove list element - does not create a new list\n-        context.getVariables().\n-                declareVariable(\"temp\", list(\"temp1\", \"temp2\"));\n+        context.getVariables().declareVariable(\"temp\", list(\"temp1\", \"temp2\"));\n         context.removePath(\"$temp[1]\");\n-        assertEquals(\"Remove collection element\", \"temp2\",\n-                    context.getValue(\"$temp[1]\"));\n+        assertEquals(\n+            \"Remove collection element\",\n+            \"temp2\",\n+            context.getValue(\"$temp[1]\"));\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.7 2003/01/12 01:52:57 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/01/12 01:52:57 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/BeanModelTestCase.java,v 1.8 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model;\n \n-import java.util.*;\n-\n-import org.apache.commons.jxpath.*;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.JXPathTestCase;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.compiler.NodeNameTest;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n  * Abstract superclass for Bean access with JXPath.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2003/01/12 01:52:57 $\n+ * @version $Revision: 1.8 $ $Date: 2003/01/20 00:00:28 $\n  */\n \n-public abstract class BeanModelTestCase extends JXPathTestCase\n-{\n+public abstract class BeanModelTestCase extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public BeanModelTestCase(String name){\n+    public BeanModelTestCase(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(createContextBean());\n             context.setLocale(Locale.US);\n             context.setFactory(getAbstractFactory());\n     /**\n      * Test property iterators, the core of the graph traversal engine\n      */\n-    public void testIndividualIterators(){\n+    public void testIndividualIterators() {\n         testIndividual(+1, 0, true, false, 0);\n         testIndividual(-1, 0, true, false, 4);\n \n         testIndividual(0, 0, false, true, 4);\n     }\n \n-    private void testIndividual(int relativePropertyIndex, int offset,\n-                boolean useStartLocation, boolean reverse, int expected)\n+    private void testIndividual(\n+        int relativePropertyIndex,\n+        int offset,\n+        boolean useStartLocation,\n+        boolean reverse,\n+        int expected) \n     {\n         PropertyOwnerPointer root =\n             (PropertyOwnerPointer) NodePointer.newNodePointer(\n     /**\n      * Test property iterators with multiple properties returned\n      */\n-    public void testMultipleIterators(){\n+    public void testMultipleIterators() {\n         testMultiple(0, 0, true, false, 20);\n \n         testMultiple(3, 0, true, false, 16);\n         testMultiple(3, 3, true, false, 13);\n     }\n \n-    private void testMultiple(int propertyIndex, int offset,\n-                boolean useStartLocation, boolean reverse, int expected)\n+    private void testMultiple(\n+        int propertyIndex,\n+        int offset,\n+        boolean useStartLocation,\n+        boolean reverse,\n+        int expected) \n     {\n         PropertyOwnerPointer root =\n-                (PropertyOwnerPointer)NodePointer.newNodePointer(\n-                        new QName(null, \"root\"), createContextBean(),\n-                        Locale.getDefault());\n+            (PropertyOwnerPointer) NodePointer.newNodePointer(\n+                new QName(null, \"root\"),\n+                createContextBean(),\n+                Locale.getDefault());\n         NodeIterator it;\n \n         PropertyPointer start = null;\n \n-        if (useStartLocation){\n+        if (useStartLocation) {\n             start = root.getPropertyPointer();\n             start.setPropertyIndex(propertyIndex);\n             start.setIndex(offset);\n         it = root.childIterator(null, reverse, start);\n \n         int size = 0;\n-        while(it.setPosition(it.getPosition() + 1)){\n+        while (it.setPosition(it.getPosition() + 1)) {\n //            System.err.println(\"LOC: \" + it.getCurrentNodePointer());\n             size++;\n         }\n-        assertEquals(\"ITERATIONS: Multiple, propertyIndex=\" + propertyIndex +\n-            \", offset=\" + offset + \", useStartLocation=\" + useStartLocation +\n-            \", reverse=\" + reverse, expected, size);\n-    }\n-\n-    private int relativeProperty(PropertyPointer holder, int offset){\n+        assertEquals(\n+            \"ITERATIONS: Multiple, propertyIndex=\"\n+                + propertyIndex\n+                + \", offset=\"\n+                + offset\n+                + \", useStartLocation=\"\n+                + useStartLocation\n+                + \", reverse=\"\n+                + reverse,\n+            expected,\n+            size);\n+    }\n+\n+    private int relativeProperty(PropertyPointer holder, int offset) {\n         String[] names = holder.getPropertyNames();\n-        for (int i = 0; i < names.length; i++){\n-            if (names[i].equals(\"integers\")){\n+        for (int i = 0; i < names.length; i++) {\n+            if (names[i].equals(\"integers\")) {\n                 return i + offset;\n             }\n         }\n         return -1;\n     }\n \n-    public void testIteratePropertyArrayWithHasNext(){\n+    public void testIteratePropertyArrayWithHasNext() {\n         JXPathContext context = JXPathContext.newContext(createContextBean());\n         Iterator it = context.iteratePointers(\"/integers\");\n         List actual = new ArrayList();\n             actual);\n     }\n \n-    public void testIterateAndSet(){\n+    public void testIterateAndSet() {\n         JXPathContext context = JXPathContext.newContext(createContextBean());\n \n         Iterator it = context.iteratePointers(\"beans/int\");\n         int i = 5;\n-        while (it.hasNext()){\n-            NodePointer pointer = (NodePointer)it.next();\n+        while (it.hasNext()) {\n+            NodePointer pointer = (NodePointer) it.next();\n             pointer.setValue(new Integer(i++));\n         }\n \n         it = context.iteratePointers(\"beans/int\");\n         List actual = new ArrayList();\n-        while (it.hasNext()){\n-            actual.add(((Pointer)it.next()).getValue());\n-        }\n-        assertEquals(\"Iterating <\" + \"beans/int\" + \">\",\n-                list(new Integer(5), new Integer(6)), actual);\n+        while (it.hasNext()) {\n+            actual.add(((Pointer) it.next()).getValue());\n+        }\n+        assertEquals(\n+            \"Iterating <\" + \"beans/int\" + \">\",\n+            list(new Integer(5), new Integer(6)),\n+            actual);\n     }\n \n     /**\n         context.setValue(\"/beans[2]/name\", \"Name 2\");\n         assertXPathValue(context, \"/beans[2]/name\", \"Name 2\");\n \n-        int iter_count = 0;\n+        int iterCount = 0;\n         Iterator iter = context.iteratePointers(\"/beans/name\");\n         while (iter.hasNext()) {\n-            iter_count++;\n+            iterCount++;\n             Pointer pointer = (Pointer) iter.next();\n             String s = (String) pointer.getValue();\n             s = s + \"suffix\";\n                 s,\n                 context.getValue(pointer.asPath()));\n         }\n-        assertEquals(\"Iteration count\", 2, iter_count);\n+        assertEquals(\"Iteration count\", 2, iterCount);\n \n         assertXPathValue(context, \"/beans[1]/name\", \"Name 1suffix\");\n         assertXPathValue(context, \"/beans[2]/name\", \"Name 2suffix\");\n     }\n \n-    public void testRoot(){\n-        assertXPathValueAndPointer(context,\n-                \"/\",\n-                context.getContextBean(),\n-                \"/\");\n-    }\n-\n-    public void testAxisAncestor(){\n+    public void testRoot() {\n+        assertXPathValueAndPointer(context, \"/\", context.getContextBean(), \"/\");\n+    }\n+\n+    public void testAxisAncestor() {\n         // ancestor::\n-        assertXPathValue(context,\n-                \"int/ancestor::root = /\",\n-                Boolean.TRUE);\n-\n-        assertXPathValue(context,\n-                \"count(beans/name/ancestor-or-self::node())\",\n-                new Double(5));\n-\n-        assertXPathValue(context,\n-                \"beans/name/ancestor-or-self::node()[3] = /\",\n-                Boolean.TRUE);\n-    }\n-\n-    public void testAxisChild(){\n-        assertXPathValue(context,\n-                \"boolean\",\n-                Boolean.FALSE);\n-\n-        assertXPathPointer(context,\n-                \"boolean\",\n-                \"/boolean\");\n-\n-        assertXPathPointerIterator(context,\n-                \"boolean\",\n-                list(\"/boolean\"));\n+        assertXPathValue(context, \"int/ancestor::root = /\", Boolean.TRUE);\n+\n+        assertXPathValue(\n+            context,\n+            \"count(beans/name/ancestor-or-self::node())\",\n+            new Double(5));\n+\n+        assertXPathValue(\n+            context,\n+            \"beans/name/ancestor-or-self::node()[3] = /\",\n+            Boolean.TRUE);\n+    }\n+\n+    public void testAxisChild() {\n+        assertXPathValue(context, \"boolean\", Boolean.FALSE);\n+\n+        assertXPathPointer(context, \"boolean\", \"/boolean\");\n+\n+        assertXPathPointerIterator(context, \"boolean\", list(\"/boolean\"));\n \n         // Count elements in a child collection\n-        assertXPathValue(context,\n-                \"count(set)\",\n-                new Double(3));\n+        assertXPathValue(context, \"count(set)\", new Double(3));\n \n //        assertXPathValue(context,\"boolean/class/name\", \"java.lang.Boolean\");\n \n         // Child with namespace - should not find any\n-        assertXPathValueIterator(context,\n-                \"foo:boolean\",\n-                list());\n+        assertXPathValueIterator(context, \"foo:boolean\", list());\n \n         // Count all children with a wildcard\n-        assertXPathValue(context,\n-                \"count(*)\",\n-                new Double(21));\n+        assertXPathValue(context, \"count(*)\", new Double(21));\n \n         // Same, constrained by node type = node()\n-        assertXPathValue(context,\n-                \"count(child::node())\",\n-                new Double(21));\n-    }\n-\n-    public void testAxisChildNestedBean(){\n+        assertXPathValue(context, \"count(child::node())\", new Double(21));\n+    }\n+\n+    public void testAxisChildNestedBean() {\n         // Nested bean\n-        assertXPathValue(context,\n-                \"nestedBean/name\",\n-                \"Name 0\");\n-\n-        assertXPathPointer(context,\n-                \"nestedBean/name\",\n-                \"/nestedBean/name\");\n-\n-        assertXPathPointerIterator(context,\n-                \"nestedBean/name\",\n-                list(\"/nestedBean/name\"));\n-    }\n-\n-    public void testAxisChildNestedCollection(){\n-        assertXPathValueIterator(context,\n-                \"integers\",\n-                list(new Integer(1), new Integer(2),\n-                     new Integer(3), new Integer(4)));\n-\n-        assertXPathPointer(context,\n-                \"integers\",\n-                \"/integers\");\n-\n-        assertXPathPointerIterator(context,\n-                \"integers\",\n-                list(\"/integers[1]\", \"/integers[2]\",\n-                     \"/integers[3]\", \"/integers[4]\"));\n-    }\n-\n-    public void testIndexPredicate(){\n-        assertXPathValue(context,\n-                \"integers[2]\",\n-                new Integer(2));\n-\n-        assertXPathPointer(context,\n-                \"integers[2]\",\n-                \"/integers[2]\");\n-\n-        assertXPathPointerIterator(context,\n-                \"integers[2]\",\n-                list(\"/integers[2]\"));\n-\n-        assertXPathValue(context,\n-                \"beans[1]/name\",\n-                \"Name 1\");\n-\n-        assertXPathPointer(context,\n-                \"beans[1]/name\",\n-                \"/beans[1]/name\");\n-\n-        assertXPathValueIterator(context,\n-                \"beans[1]/strings\",\n-                list(\"String 1\", \"String 2\", \"String 3\"));\n-\n-        assertXPathValueIterator(context,\n-                \"beans/strings[2]\",\n-                list(\"String 2\", \"String 2\"));\n+        assertXPathValue(context, \"nestedBean/name\", \"Name 0\");\n+\n+        assertXPathPointer(context, \"nestedBean/name\", \"/nestedBean/name\");\n+\n+        assertXPathPointerIterator(\n+            context,\n+            \"nestedBean/name\",\n+            list(\"/nestedBean/name\"));\n+    }\n+\n+    public void testAxisChildNestedCollection() {\n+        assertXPathValueIterator(\n+            context,\n+            \"integers\",\n+            list(\n+                new Integer(1),\n+                new Integer(2),\n+                new Integer(3),\n+                new Integer(4)));\n+\n+        assertXPathPointer(context, \"integers\", \"/integers\");\n+\n+        assertXPathPointerIterator(\n+            context,\n+            \"integers\",\n+            list(\n+                \"/integers[1]\",\n+                \"/integers[2]\",\n+                \"/integers[3]\",\n+                \"/integers[4]\"));\n+    }\n+\n+    public void testIndexPredicate() {\n+        assertXPathValue(context, \"integers[2]\", new Integer(2));\n+\n+        assertXPathPointer(context, \"integers[2]\", \"/integers[2]\");\n+\n+        assertXPathPointerIterator(\n+            context,\n+            \"integers[2]\",\n+            list(\"/integers[2]\"));\n+\n+        assertXPathValue(context, \"beans[1]/name\", \"Name 1\");\n+\n+        assertXPathPointer(context, \"beans[1]/name\", \"/beans[1]/name\");\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[1]/strings\",\n+            list(\"String 1\", \"String 2\", \"String 3\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans/strings[2]\",\n+            list(\"String 2\", \"String 2\"));\n \n         // Find the first match\n-        assertXPathValue(context,\n-                \"beans/strings[2]\",\n-                \"String 2\");\n+        assertXPathValue(context, \"beans/strings[2]\", \"String 2\");\n \n         // Indexing in a set collected from a UnionContext\n-        assertXPathValue(context,\n-                \"(beans/strings[2])[1]\",\n-                \"String 2\");\n-    }\n-\n-    public void testAxisDescendant(){\n-       // descendant::\n-        assertXPathValue(context,\n-                \"count(descendant::node())\",\n-                new Double(65));\n+        assertXPathValue(context, \"(beans/strings[2])[1]\", \"String 2\");\n+    }\n+\n+    public void testAxisDescendant() {\n+        // descendant::\n+        assertXPathValue(context, \"count(descendant::node())\", new Double(65));\n \n         // Should not find any descendants with name root\n-        assertXPathValue(context,\n-                \"count(descendant::root)\",\n-                new Double(0));\n-\n-        assertXPathValue(context,\n-                \"count(descendant::name)\",\n-                new Double(7));\n-    }\n-\n-    public void testAxisDescendantOrSelf(){\n+        assertXPathValue(context, \"count(descendant::root)\", new Double(0));\n+\n+        assertXPathValue(context, \"count(descendant::name)\", new Double(7));\n+    }\n+\n+    public void testAxisDescendantOrSelf() {\n         // descendant-or-self::\n-        assertXPathValueIterator(context,\n-                \"descendant-or-self::name\",\n-                set(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n-                     \"Name 0\", \"Name 5\", \"Name 4\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"descendant-or-self::name\",\n+            set(\n+                \"Name 1\",\n+                \"Name 2\",\n+                \"Name 3\",\n+                \"Name 6\",\n+                \"Name 0\",\n+                \"Name 5\",\n+                \"Name 4\"));\n \n         // Same - abbreviated syntax\n-        assertXPathValueIterator(context,\n-                \"//name\",\n-                set(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n-                     \"Name 0\", \"Name 5\", \"Name 4\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"//name\",\n+            set(\n+                \"Name 1\",\n+                \"Name 2\",\n+                \"Name 3\",\n+                \"Name 6\",\n+                \"Name 0\",\n+                \"Name 5\",\n+                \"Name 4\"));\n \n         // See that it actually finds self\n-        assertXPathValue(context,\n-                \"count(descendant-or-self::root)\",\n-                new Double(1));\n+        assertXPathValue(\n+            context,\n+            \"count(descendant-or-self::root)\",\n+            new Double(1));\n \n         // Combine descendant-or-self:: and and self::\n-        assertXPathValue(context,\n-                \"count(nestedBean//.)\",\n-                new Double(7));\n+        assertXPathValue(context, \"count(nestedBean//.)\", new Double(7));\n \n         // Combine descendant-or-self:: and and self::name\n-        assertXPathValue(context,\n-                \"count(//self::beans)\",\n-                new Double(2));\n+        assertXPathValue(context, \"count(//self::beans)\", new Double(2));\n \n         // Count all nodes in the tree\n-        assertXPathValue(context,\n-                \"count(descendant-or-self::node())\",\n-                new Double(66));\n-\n-    }\n-\n-    public void testAxisFollowing(){\n+        assertXPathValue(\n+            context,\n+            \"count(descendant-or-self::node())\",\n+            new Double(66));\n+\n+    }\n+\n+    public void testAxisFollowing() {\n         // following::\n-        assertXPathValue(context,\n-                \"count(nestedBean/strings[2]/following::node())\",\n-                new Double(21));\n-\n-        assertXPathValue(context,\n-                \"count(nestedBean/strings[2]/following::strings)\",\n-                new Double(7));\n-    }\n-\n-    public void testAxisFollowingSibling(){\n+        assertXPathValue(\n+            context,\n+            \"count(nestedBean/strings[2]/following::node())\",\n+            new Double(21));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(nestedBean/strings[2]/following::strings)\",\n+            new Double(7));\n+    }\n+\n+    public void testAxisFollowingSibling() {\n         // following-sibling::\n-        assertXPathValue(context,\n-                \"count(/nestedBean/following-sibling::node())\",\n-                new Double(8));\n-\n-        assertXPathValue(context,\n-                \"count(/nestedBean/following-sibling::object)\",\n-                new Double(1));\n+        assertXPathValue(\n+            context,\n+            \"count(/nestedBean/following-sibling::node())\",\n+            new Double(8));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(/nestedBean/following-sibling::object)\",\n+            new Double(1));\n \n         // Combine parent:: and following-sibling::\n-        assertXPathValue(context,\n-                \"count(/nestedBean/boolean/../following-sibling::node())\",\n-                new Double(8));\n-\n-        assertXPathValue(context,\n-                \"count(/nestedBean/boolean/../following-sibling::object)\",\n-                new Double(1));\n+        assertXPathValue(\n+            context,\n+            \"count(/nestedBean/boolean/../following-sibling::node())\",\n+            new Double(8));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(/nestedBean/boolean/../following-sibling::object)\",\n+            new Double(1));\n \n         // Combine descendant:: and following-sibling::\n-        assertXPathValue(context,\n-                \"count(/descendant::boolean/following-sibling::node())\",\n-                new Double(53));\n-\n-        assertXPathValue(context,\n-                \"count(/descendant::boolean/following-sibling::name)\",\n-                new Double(7));\n-    }\n-\n-    public void testAxisParent(){\n+        assertXPathValue(\n+            context,\n+            \"count(/descendant::boolean/following-sibling::node())\",\n+            new Double(53));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(/descendant::boolean/following-sibling::name)\",\n+            new Double(7));\n+    }\n+\n+    public void testAxisParent() {\n         // parent::\n-        assertXPathValue(context,\n-                \"count(/beans/..)\",\n-                new Double(1));\n-\n-        assertXPathValue(context,\n-                \"count(//..)\",\n-                new Double(9));\n-\n-        assertXPathValue(context,\n-                \"count(//../..)\",\n-                new Double(2));\n-\n-        assertXPathValueIterator(context,\n-                \"//parent::beans/name\",\n-                list(\"Name 1\", \"Name 2\"));\n-    }\n-\n-    public void testAxisPreceding(){\n+        assertXPathValue(context, \"count(/beans/..)\", new Double(1));\n+\n+        assertXPathValue(context, \"count(//..)\", new Double(9));\n+\n+        assertXPathValue(context, \"count(//../..)\", new Double(2));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"//parent::beans/name\",\n+            list(\"Name 1\", \"Name 2\"));\n+    }\n+\n+    public void testAxisPreceding() {\n         // preceding::\n-        assertXPathValue(context,\n-                \"count(beans[2]/int/preceding::node())\",\n-                new Double(8));\n-\n-        assertXPathValue(context,\n-                \"count(beans[2]/int/preceding::boolean)\",\n-                new Double(2));\n-    }\n-\n-    public void testAxisPrecedingSibling(){\n+        assertXPathValue(\n+            context,\n+            \"count(beans[2]/int/preceding::node())\",\n+            new Double(8));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(beans[2]/int/preceding::boolean)\",\n+            new Double(2));\n+    }\n+\n+    public void testAxisPrecedingSibling() {\n         // preceding-sibling::\n-        assertXPathValue(context,\n-                \"count(/boolean/preceding-sibling::node())\",\n-                new Double(2));\n-\n-        assertXPathValue(context,\n-                \"count(/nestedBean/int/../preceding-sibling::node())\",\n-                new Double(12));\n-\n-        assertXPathValue(context,\n-                \"count(/descendant::int/preceding-sibling::node())\",\n-                new Double(10));\n-    }\n-\n-    public void testAxisSelf(){\n+        assertXPathValue(\n+            context,\n+            \"count(/boolean/preceding-sibling::node())\",\n+            new Double(2));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(/nestedBean/int/../preceding-sibling::node())\",\n+            new Double(12));\n+\n+        assertXPathValue(\n+            context,\n+            \"count(/descendant::int/preceding-sibling::node())\",\n+            new Double(10));\n+    }\n+\n+    public void testAxisSelf() {\n         // self::\n-        assertXPathValue(context,\n-                \"self::node() = /\",\n-                Boolean.TRUE);\n-\n-        assertXPathValue(context,\n-                \"self::root = /\",\n-                Boolean.TRUE);\n-    }\n-\n-    public void testUnion(){\n+        assertXPathValue(context, \"self::node() = /\", Boolean.TRUE);\n+\n+        assertXPathValue(context, \"self::root = /\", Boolean.TRUE);\n+    }\n+\n+    public void testUnion() {\n         // Union - note corrected document order\n-        assertXPathValueIterator(context,\n-                \"integers | beans[1]/strings\",\n-                list(\"String 1\", \"String 2\", \"String 3\",\n-                     new Integer(1), new Integer(2),\n-                     new Integer(3), new Integer(4)));\n-\n-        assertXPathValue(context,\n-                \"count((integers | beans[1]/strings)[contains(., '1')])\",\n-                new Double(2));\n-\n-        assertXPathValue(context,\n-                \"count((integers | beans[1]/strings)[name(.) = 'strings'])\",\n-                new Double(3));\n+        assertXPathValueIterator(\n+            context,\n+            \"integers | beans[1]/strings\",\n+            list(\n+                \"String 1\",\n+                \"String 2\",\n+                \"String 3\",\n+                new Integer(1),\n+                new Integer(2),\n+                new Integer(3),\n+                new Integer(4)));\n+\n+        assertXPathValue(\n+            context,\n+            \"count((integers | beans[1]/strings)[contains(., '1')])\",\n+            new Double(2));\n+\n+        assertXPathValue(\n+            context,\n+            \"count((integers | beans[1]/strings)[name(.) = 'strings'])\",\n+            new Double(3));\n \n         // Note that the following is different from \"integer[2]\" -\n         // it is a filter expression\n-        assertXPathValue(context,\n-                \"(integers)[2]\",\n-                new Integer(2));\n-     }\n-\n-    public void testAxisAttribute(){\n+        assertXPathValue(context, \"(integers)[2]\", new Integer(2));\n+    }\n+\n+    public void testAxisAttribute() {\n         // Attributes are just like children to beans\n-        assertXPathValue(context,\n-                \"count(@*)\",\n-                new Double(21.0));\n+        assertXPathValue(context, \"count(@*)\", new Double(21.0));\n \n         // Unknown attribute\n-        assertXPathValueLenient(context,\n-                \"@foo\",\n-                null);\n+        assertXPathValueLenient(context, \"@foo\", null);\n     }\n \n     /**\n      * Testing the pseudo-attribute \"name\" that java beans\n      * objects appear to have.\n      */\n-    public void testAttributeName(){\n-        assertXPathValue(context,\n-                \"nestedBean[@name = 'int']\",\n-                new Integer(1));\n-\n-        assertXPathPointer(context,\n-                \"nestedBean[@name = 'int']\",\n-                \"/nestedBean/int\");\n+    public void testAttributeName() {\n+        assertXPathValue(context, \"nestedBean[@name = 'int']\", new Integer(1));\n+\n+        assertXPathPointer(\n+            context,\n+            \"nestedBean[@name = 'int']\",\n+            \"/nestedBean/int\");\n     }\n \n     public void testAttributeLang() {\n \n-        assertXPathValue(context, \n-            \"@xml:lang\", \n-            \"en-US\");\n-\n-        assertXPathValue(context, \n-            \"count(@xml:*)\", \n-            new Double(1));\n-\n-        assertXPathValue(context, \n-            \"lang('en')\", \n-            Boolean.TRUE);\n-            \n-        assertXPathValue(context, \n-            \"lang('fr')\", \n-            Boolean.FALSE);\n-    }\n-    \n-    public void testCoreFunctions(){\n-            \n-        assertXPathValue(context, \n-            \"boolean(boolean)\", \n-            Boolean.TRUE);\n-\n-        assertXPathValue(context,\n-            \"boolean(boolean = false())\",\n-            Boolean.TRUE);\n-            \n+        assertXPathValue(context, \"@xml:lang\", \"en-US\");\n+\n+        assertXPathValue(context, \"count(@xml:*)\", new Double(1));\n+\n+        assertXPathValue(context, \"lang('en')\", Boolean.TRUE);\n+\n+        assertXPathValue(context, \"lang('fr')\", Boolean.FALSE);\n+    }\n+\n+    public void testCoreFunctions() {\n+\n+        assertXPathValue(context, \"boolean(boolean)\", Boolean.TRUE);\n+\n+        assertXPathValue(context, \"boolean(boolean = false())\", Boolean.TRUE);\n+\n         assertXPathValue(\n             context,\n             \"boolean(integers[position() < 3])\",\n             Boolean.TRUE);\n-            \n+\n         assertXPathValue(\n             context,\n             \"boolean(integers[position() > 4])\",\n             Boolean.FALSE);\n-            \n-        assertXPathValue(context, \n-            \"sum(integers)\", \n-            new Double(10));\n-    }\n-\n-    public void testBooleanPredicate(){\n+\n+        assertXPathValue(context, \"sum(integers)\", new Double(10));\n+    }\n+\n+    public void testBooleanPredicate() {\n         // use child axis\n-        \n+\n         // bean[1]/int = 1\n         // bean[2]/int = 3\n-        \n-        assertXPathValue(context,\n-                \"beans[int > 2]/name\",\n-                \"Name 2\");\n-\n-        assertXPathValueIterator(context,\n-                \"beans[int > 2]/name\",\n-                list(\"Name 2\"));\n-\n-        assertXPathValueIterator(context,\n-                \"beans[int >= 1]/name\",\n-                list(\"Name 1\", \"Name 2\"));\n-                \n-        assertXPathValueIterator(context,\n-                \"beans[int < 2]/name\",\n-                list(\"Name 1\"));\n-                \n-        assertXPathValueIterator(context,\n-                \"beans[int <= 3]/name\",\n-                list(\"Name 1\", \"Name 2\"));\n+\n+        assertXPathValue(context, \"beans[int > 2]/name\", \"Name 2\");\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[int > 2]/name\",\n+            list(\"Name 2\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[int >= 1]/name\",\n+            list(\"Name 1\", \"Name 2\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[int < 2]/name\",\n+            list(\"Name 1\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"beans[int <= 3]/name\",\n+            list(\"Name 1\", \"Name 2\"));\n \n         assertXPathValueIterator(\n             context,\n             list(\"String 1\", \"String 2\", \"String 3\"));\n \n         // use some fancy axis and the child axis in the predicate\n-        assertXPathValueIterator(context,\n-                \"//self::node()[name = 'Name 0']/name\",\n-                list(\"Name 0\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"//self::node()[name = 'Name 0']/name\",\n+            list(\"Name 0\"));\n \n         // use context-dependent function in the predicate\n-        assertXPathValue(context,\n-                \"beans/strings[name(.)='strings'][2]\",\n-                \"String 2\");\n+        assertXPathValue(\n+            context,\n+            \"beans/strings[name(.)='strings'][2]\",\n+            \"String 2\");\n \n         // use context-independent function in the predicate\n-        assertXPathValueIterator(context,\n-                \"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n-                list(\"Name 1\", \"Name 2\", \"Name 3\", \"Name 6\",\n-                     \"Name 0\", \"Name 5\", \"Name 4\"));\n-\n-        assertXPathValueIterator(context,\n-                \"integers[position()<3]\",\n-                list(new Integer(1), new Integer(2)));\n-    }\n-\n-    public void testBooleanPredicateWithSearch(){\n-        context.getVariables().declareVariable(\n-            \"numbers\",\n-            new String[] { \"2\", \"3\" });\n-\n-        context.setValue(\"/beans[1]/strings\", new String[] { \"1\", \"2\" });\n-        context.setValue(\"/beans[2]/strings\", new String[] { \"3\", \"4\" });\n-\n-        // Find beans with any string == 2        \n-        assertXPathValueIterator(context,\n-            \"/beans[strings = '2']/name\",\n-            list(\"Name 1\")\n-        );\n-\n-        // Find beans with any string in the variable $numbers\n-        assertXPathValueIterator(context,\n-            \"/beans[strings = $numbers]/name\",\n-            list(\"Name 1\", \"Name 2\")\n-        );\n-\n-        // Find beans without any strings == 2\n-        assertXPathValueIterator(context,\n-            \"/beans[strings != '2']/name\",\n-            list(\"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings > '1']/name\",\n-            list(\"Name 1\", \"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings > $numbers]/name\",\n-            list(\"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings >= '2']/name\",\n-            list(\"Name 1\", \"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings >= '3']/name\",\n-            list(\"Name 2\")\n-        );\n+        assertXPathValueIterator(\n+            context,\n+            \"//self::node()[name(.) = concat('n', 'a', 'm', 'e')]\",\n+            list(\n+                \"Name 1\",\n+                \"Name 2\",\n+                \"Name 3\",\n+                \"Name 6\",\n+                \"Name 0\",\n+                \"Name 5\",\n+                \"Name 4\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"integers[position()<3]\",\n+            list(new Integer(1), new Integer(2)));\n+            \n+        context.getVariables().declareVariable(\"temp\", context.getValue(\"beans\"));\n         \n-        assertXPathValueIterator(context,\n-            \"/beans[strings < '4']/name\",\n-            list(\"Name 1\", \"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings < 3]/name\",\n-            list(\"Name 1\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings <= '3']/name\",\n-            list(\"Name 1\", \"Name 2\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/beans[strings <= '2']/name\",\n-            list(\"Name 1\")\n-        );\n-    }\n-    \n-    public void testDocumentOrder(){\n-        assertDocumentOrder(context,\n-                \"boolean\", \"int\", -1);\n-\n-        assertDocumentOrder(context,\n-                \"integers[1]\", \"integers[2]\", -1);\n-\n-        assertDocumentOrder(context,\n-                \"integers[1]\", \"integers[1]\", 0);\n-\n-        assertDocumentOrder(context,\n-                \"nestedBean/int\", \"nestedBean\", 1);\n-\n-        assertDocumentOrder(context,\n-                \"nestedBean/int\", \"nestedBean/strings\", -1);\n-\n-        assertDocumentOrder(context,\n-                \"nestedBean/int\", \"object/int\", -1);\n-    }\n-\n-    public void testSetPropertyValue(){\n+        assertXPathValueIterator(\n+            context,\n+            \"$temp[int < 2]/int\",\n+            list(new Integer(1)));\n+    }\n+\n+    public void testDocumentOrder() {\n+        assertDocumentOrder(context, \"boolean\", \"int\", -1);\n+\n+        assertDocumentOrder(context, \"integers[1]\", \"integers[2]\", -1);\n+\n+        assertDocumentOrder(context, \"integers[1]\", \"integers[1]\", 0);\n+\n+        assertDocumentOrder(context, \"nestedBean/int\", \"nestedBean\", 1);\n+\n+        assertDocumentOrder(\n+            context,\n+            \"nestedBean/int\",\n+            \"nestedBean/strings\",\n+            -1);\n+\n+        assertDocumentOrder(context, \"nestedBean/int\", \"object/int\", -1);\n+    }\n+\n+    public void testSetPropertyValue() {\n         // Simple property\n-        assertXPathSetValue(context,\n-                \"int\",\n-                new Integer(2));\n+        assertXPathSetValue(context, \"int\", new Integer(2));\n \n         // Simple property with conversion from string\n-        assertXPathSetValue(context,\n-                \"int\",\n-                \"3\",\n-                new Integer(3));\n+        assertXPathSetValue(context, \"int\", \"3\", new Integer(3));\n \n         // Simple property with conversion from array\n-        assertXPathSetValue(context,\n-                \"int\",\n-                new int[]{4},\n-                new Integer(4));\n+        assertXPathSetValue(context, \"int\", new int[] { 4 }, new Integer(4));\n \n         // Attribute (which is the same as a child for beans\n-        assertXPathSetValue(context,\n-                \"@int\",\n-                new Integer(10));\n-    }\n-\n-    public void testSetCollectionElement(){\n+        assertXPathSetValue(context, \"@int\", new Integer(10));\n+    }\n+\n+    public void testSetCollectionElement() {\n         // Collection element\n-        assertXPathSetValue(context,\n-                \"integers[2]\",\n-                new Integer(5));\n+        assertXPathSetValue(context, \"integers[2]\", new Integer(5));\n \n         // Collection element with conversion\n-        assertXPathSetValue(context,\n-                \"integers[2]\",\n-                new int[]{6},\n-                new Integer(6));\n-    }\n-\n-    public void testSetContextDependentNode(){\n+        assertXPathSetValue(\n+            context,\n+            \"integers[2]\",\n+            new int[] { 6 },\n+            new Integer(6));\n+    }\n+\n+    public void testSetContextDependentNode() {\n         // Find node without using SimplePathInterpreter\n-        assertXPathSetValue(context,\n-                \"integers[position() = 1]\",\n-                new Integer(8));\n+        assertXPathSetValue(\n+            context,\n+            \"integers[position() = 1]\",\n+            new Integer(8));\n \n         // Find node without using SimplePathInterpreter and set its property\n-        assertXPathSetValue(context,\n-                \"beans[name = 'Name 1']/int\",\n-                new Integer(9));\n-\n-    }\n-\n-    public void testSetNonPrimitiveValue(){\n+        assertXPathSetValue(\n+            context,\n+            \"beans[name = 'Name 1']/int\",\n+            new Integer(9));\n+\n+    }\n+\n+    public void testSetNonPrimitiveValue() {\n         // First, let's see if we can set a collection element to null\n-        assertXPathSetValue(context,\n-                \"beans[2]\",\n-                null);\n+        assertXPathSetValue(context, \"beans[2]\", null);\n \n         // Now, assign it a whole bean\n         context.setValue(\"beans[2]\", new NestedTestBean(\"Name 9\"));\n \n-        assertEquals(\"Modified <\" + \"beans[2]/name\" + \">\",\n-            \"Name 9\", context.getValue(\"beans[2]/name\"));\n-    }\n-\n-    public void testCreatePath(){\n+        assertEquals(\n+            \"Modified <\" + \"beans[2]/name\" + \">\",\n+            \"Name 9\",\n+            context.getValue(\"beans[2]/name\"));\n+    }\n+\n+    public void testCreatePath() {\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-        assertXPathCreatePath(context,\n-                \"/nestedBean/int\",\n-                new Integer(1),\n-                \"/nestedBean/int\");\n-    }\n-\n-    public void testCreatePathAndSetValue(){\n+        assertXPathCreatePath(\n+            context,\n+            \"/nestedBean/int\",\n+            new Integer(1),\n+            \"/nestedBean/int\");\n+    }\n+\n+    public void testCreatePathAndSetValue() {\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-        assertXPathCreatePathAndSetValue(context,\n-                \"/nestedBean/int\",\n-                new Integer(2),\n-                \"/nestedBean/int\");\n-    }\n-\n-    public void testCreatePathExpandNewCollection(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/nestedBean/int\",\n+            new Integer(2),\n+            \"/nestedBean/int\");\n+    }\n+\n+    public void testCreatePathExpandNewCollection() {\n         context.setValue(\"beans\", null);\n \n         // Calls factory.createObject(..., testBean, \"beans\", 2), \n         // then  factory.createObject(..., testBean, \"beans\", 2)\n-        assertXPathCreatePath(context,\n-                \"/beans[2]/int\",\n-                new Integer(1),\n-                \"/beans[2]/int\");\n-    }\n-\n-    public void testCreatePathAndSetValueExpandNewCollection(){\n+        assertXPathCreatePath(\n+            context,\n+            \"/beans[2]/int\",\n+            new Integer(1),\n+            \"/beans[2]/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueExpandNewCollection() {\n         context.setValue(\"beans\", null);\n \n         // Calls factory.createObject(..., testBean, \"beans\", 2), \n         // then factory.createObject(..., testBean, \"beans\", 2)\n-        assertXPathCreatePathAndSetValue(context,\n-                \"/beans[2]/int\",\n-                new Integer(2),\n-                \"/beans[2]/int\");\n-    }\n-\n-    public void testCreatePathExpandExistingCollection(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/beans[2]/int\",\n+            new Integer(2),\n+            \"/beans[2]/int\");\n+    }\n+\n+    public void testCreatePathExpandExistingCollection() {\n         // Calls factory.createObject(..., TestBean, \"integers\", 5)\n         // to expand collection\n-        assertXPathCreatePathAndSetValue(context,\n+        assertXPathCreatePathAndSetValue(\n+            context,\n             \"/integers[5]\",\n             new Integer(3),\n-            \"/integers[5]\");     \n-    }\n-    \n-    public void testCreatePathExpandExistingCollectionAndSetProperty(){\n+            \"/integers[5]\");\n+    }\n+\n+    public void testCreatePathExpandExistingCollectionAndSetProperty() {\n         // Another, but the collection already exists\n-        assertXPathCreatePath(context,\n-                \"/beans[3]/int\",\n-                new Integer(1),\n-                \"/beans[3]/int\");\n-    }\n-\n-    public void testCreatePathAndSetValueExpandExistingCollection(){\n+        assertXPathCreatePath(\n+            context,\n+            \"/beans[3]/int\",\n+            new Integer(1),\n+            \"/beans[3]/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueExpandExistingCollection() {\n         // Another, but the collection already exists\n-        assertXPathCreatePathAndSetValue(context,\n-                \"/beans[3]/int\",\n-                new Integer(2),\n-                \"/beans[3]/int\");\n-    }\n-\n-    public void testCreatePathCreateBeanExpandCollection(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/beans[3]/int\",\n+            new Integer(2),\n+            \"/beans[3]/int\");\n+    }\n+\n+    public void testCreatePathCreateBeanExpandCollection() {\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n         // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n-        assertXPathCreatePath(context,\n-                \"/nestedBean/strings[2]\",\n-                \"String 2\",\n-                \"/nestedBean/strings[2]\");\n-    }\n-\n-    public void testCreatePathAndSetValueCreateBeanExpandCollection(){\n+        assertXPathCreatePath(\n+            context,\n+            \"/nestedBean/strings[2]\",\n+            \"String 2\",\n+            \"/nestedBean/strings[2]\");\n+    }\n+\n+    public void testCreatePathAndSetValueCreateBeanExpandCollection() {\n         context.setValue(\"nestedBean\", null);\n \n         // Calls factory.createObject(..., TestBean, \"nestedBean\")\n         // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n-        assertXPathCreatePathAndSetValue(context,\n-                \"/nestedBean/strings[2]\",\n-                \"Test\",\n-                \"/nestedBean/strings[2]\");\n-    }\n-        \n-    public void testRemovePathPropertyValue(){\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/nestedBean/strings[2]\",\n+            \"Test\",\n+            \"/nestedBean/strings[2]\");\n+    }\n+\n+    public void testRemovePathPropertyValue() {\n         // Remove property value\n         context.removePath(\"nestedBean/int\");\n-        assertEquals(\"Remove property value\", new Integer(0),\n-                    context.getValue(\"nestedBean/int\"));\n-    }\n-\n-    public void testRemovePathArrayElement(){\n+        assertEquals(\n+            \"Remove property value\",\n+            new Integer(0),\n+            context.getValue(\"nestedBean/int\"));\n+    }\n+\n+    public void testRemovePathArrayElement() {\n         // Assigns a new array to the property\n         context.removePath(\"nestedBean/strings[1]\");\n-        assertEquals(\"Remove array element\", \"String 2\",\n-                    context.getValue(\"nestedBean/strings[1]\"));\n-    }\n-\n-    public void testRemovePathBeanValue(){\n+        assertEquals(\n+            \"Remove array element\",\n+            \"String 2\",\n+            context.getValue(\"nestedBean/strings[1]\"));\n+    }\n+\n+    public void testRemovePathBeanValue() {\n         context.removePath(\"nestedBean\");\n-        assertEquals(\"Remove collection element\", null,\n-                    context.getValue(\"nestedBean\"));\n+        assertEquals(\n+            \"Remove collection element\",\n+            null,\n+            context.getValue(\"nestedBean\"));\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/ExceptionPropertyTestBean.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/ExceptionPropertyTestBean.java\n /**\n  * \n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n- * @version $Id: ExceptionPropertyTestBean.java,v 1.1 2002/11/28 01:02:05 dmitri Exp $\n+ * @version $Id: ExceptionPropertyTestBean.java,v 1.2 2003/01/20 00:00:28 dmitri Exp $\n  */\n public class ExceptionPropertyTestBean {\n \n-    public String getErrorString(){\n+    public String getErrorString() {\n         throw new RuntimeException(\"errorString\");\n     }\n-    \n-    public String[] getErrorStringArray(){\n+\n+    public String[] getErrorStringArray() {\n         throw new RuntimeException(\"errorStringArray\");\n     }\n \n-    public TestBean getErrorBean(){\n+    public TestBean getErrorBean() {\n         throw new RuntimeException(\"errorBean\");\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/MixedModelTest.java,v 1.5 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with mixed model: beans, maps, DOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/20 00:00:28 $\n  */\n \n-public class MixedModelTest extends JXPathTestCase\n-{\n+public class MixedModelTest extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public MixedModelTest(String name){\n+    public MixedModelTest(String name) {\n         super(name);\n     }\n \n     /**\n      * Return the tests included in this test suite.\n      */\n-    public static Test suite(){\n+    public static Test suite() {\n         return (new TestSuite(MixedModelTest.class));\n     }\n \n-    public void setUp(){\n+    public void setUp() {\n         TestMixedModelBean bean = new TestMixedModelBean();\n         context = JXPathContext.newContext(bean);\n         context.setFactory(new TestMixedModelFactory());\n         vars.declareVariable(\"element\", bean.getElement());\n         vars.declareVariable(\"container\", bean.getContainer());\n         vars.declareVariable(\"testnull\", new TestNull());\n-        \n+\n         int[][] matrix = new int[1][];\n         matrix[0] = new int[1];\n         matrix[0][0] = 3;\n         vars.declareVariable(\"matrix\", matrix);\n     }\n \n-    public void testVarPrimitive(){\n-        assertXPathValueAndPointer(context,\n-                \"$string\",\n-                \"string\",\n-                \"$string\");\n-    }\n-\n-    public void testVarBean(){\n-        assertXPathValueAndPointer(context,\n-                \"$bean/int\",\n-                new Integer(1),\n-                \"$bean/int\");\n-    }\n-\n-    public void testVarMap(){\n-        assertXPathValueAndPointer(context,\n-                \"$map/string\",\n-                \"string\",\n-                \"$map[@name='string']\");\n-    }\n-\n-    public void testVarList(){\n-        assertXPathValueAndPointer(context,\n-                \"$list[1]\",\n-                \"string\",\n-                \"$list[1]\");\n-    }\n-\n-    public void testVarDocument(){\n-        assertXPathValueAndPointer(context,\n-                \"$document/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"$document/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testVarElement(){\n-        assertXPathValueAndPointer(context,\n-                \"$element/location/address/city\",\n-                \"Fruit Market\",\n-                \"$element/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testVarContainer(){\n-        assertXPathValueAndPointer(context,\n-                \"$container/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"$container/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n+    public void testVar() {\n+        context.getVariables().declareVariable(\"foo:bar\", \"baz\");\n+\n+        assertXPathValueAndPointer(context, \n+            \"$foo:bar\", \n+            \"baz\", \n+            \"$foo:bar\");\n+        \n+    }\n+    \n+    public void testVarPrimitive() {\n+        assertXPathValueAndPointer(context, \"$string\", \"string\", \"$string\");\n+    }\n+\n+    public void testVarBean() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$bean/int\",\n+            new Integer(1),\n+            \"$bean/int\");\n+    }\n+\n+    public void testVarMap() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$map/string\",\n+            \"string\",\n+            \"$map[@name='string']\");\n+    }\n+\n+    public void testVarList() {\n+        assertXPathValueAndPointer(context, \"$list[1]\", \"string\", \"$list[1]\");\n+    }\n+\n+    public void testVarDocument() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$document/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"$document/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testVarElement() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$element/location/address/city\",\n+            \"Fruit Market\",\n+            \"$element/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testVarContainer() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$container/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"$container/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n \n     // ----------------------------------------------------------------------\n \n-    public void testBeanPrimitive(){\n-        assertXPathValueAndPointer(context,\n-                \"string\",\n-                \"string\",\n-                \"/string\");\n-    }\n-\n-    public void testBeanBean(){\n-        assertXPathValueAndPointer(context,\n-                \"bean/int\",\n-                new Integer(1),\n-                \"/bean/int\");\n-    }\n-\n-    public void testBeanMap(){\n-        assertXPathValueAndPointer(context,\n-                \"map/string\",\n-                \"string\",\n-                \"/map[@name='string']\");\n-    }\n-\n-    public void testBeanList(){\n-        assertXPathValueAndPointer(context,\n-                \"list[1]\",\n-                \"string\",\n-                \"/list[1]\");\n-    }\n-\n-    public void testBeanDocument(){\n-        assertXPathValueAndPointer(context,\n-                \"document/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/document/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testBeanElement(){\n-        assertXPathValueAndPointer(context,\n-                \"element/location/address/city\",\n-                \"Fruit Market\",\n-                \"/element/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testBeanContainer(){\n-        assertXPathValueAndPointer(context,\n-                \"container/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/container/vendor[1]/location[2]/address[1]/city[1]\");\n+    public void testBeanPrimitive() {\n+        assertXPathValueAndPointer(context, \"string\", \"string\", \"/string\");\n+    }\n+\n+    public void testBeanBean() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"bean/int\",\n+            new Integer(1),\n+            \"/bean/int\");\n+    }\n+\n+    public void testBeanMap() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/string\",\n+            \"string\",\n+            \"/map[@name='string']\");\n+    }\n+\n+    public void testBeanList() {\n+        assertXPathValueAndPointer(context, \"list[1]\", \"string\", \"/list[1]\");\n+    }\n+\n+    public void testBeanDocument() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"document/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/document/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testBeanElement() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"element/location/address/city\",\n+            \"Fruit Market\",\n+            \"/element/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testBeanContainer() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"container/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/container/vendor[1]/location[2]/address[1]/city[1]\");\n     }\n \n     // ----------------------------------------------------------------------\n \n-    public void testMapPrimitive(){\n-        assertXPathValueAndPointer(context,\n-                \"map/string\",\n-                \"string\",\n-                \"/map[@name='string']\");\n-    }\n-\n-    public void testMapBean(){\n-        assertXPathValueAndPointer(context,\n-                \"map/bean/int\",\n-                new Integer(1),\n-                \"/map[@name='bean']/int\");\n-    }\n-\n-    public void testMapMap(){\n-        assertXPathValueAndPointer(context,\n-                \"map/map/string\",\n-                \"string\",\n-                \"/map[@name='map'][@name='string']\");\n-    }\n-\n-    public void testMapList(){\n-        assertXPathValueAndPointer(context,\n-                \"map/list[1]\",\n-                \"string\",\n-                \"/map[@name='list'][1]\");\n-    }\n-\n-    public void testMapDocument(){\n-        assertXPathValueAndPointer(context,\n-                \"map/document/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/map[@name='document']\" +\n-                        \"/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testMapElement(){\n-        assertXPathValueAndPointer(context,\n-                \"map/element/location/address/city\",\n-                \"Fruit Market\",\n-                \"/map[@name='element']/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testMapContainer(){\n-        assertXPathValueAndPointer(context,\n-                \"map/container/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/map[@name='container']\" +\n-                        \"/vendor[1]/location[2]/address[1]/city[1]\");\n+    public void testMapPrimitive() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/string\",\n+            \"string\",\n+            \"/map[@name='string']\");\n+    }\n+\n+    public void testMapBean() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/bean/int\",\n+            new Integer(1),\n+            \"/map[@name='bean']/int\");\n+    }\n+\n+    public void testMapMap() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/map/string\",\n+            \"string\",\n+            \"/map[@name='map'][@name='string']\");\n+    }\n+\n+    public void testMapList() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/list[1]\",\n+            \"string\",\n+            \"/map[@name='list'][1]\");\n+    }\n+\n+    public void testMapDocument() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/document/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/map[@name='document']\"\n+                + \"/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testMapElement() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/element/location/address/city\",\n+            \"Fruit Market\",\n+            \"/map[@name='element']/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testMapContainer() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"map/container/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/map[@name='container']\"\n+                + \"/vendor[1]/location[2]/address[1]/city[1]\");\n     }\n \n     // ----------------------------------------------------------------------\n \n-    public void testListPrimitive(){\n-        assertXPathValueAndPointer(context,\n-                \"list[1]\",\n-                \"string\",\n-                \"/list[1]\");\n-    }\n-\n-    public void testListBean(){\n-        assertXPathValueAndPointer(context,\n-                \"list[2]/int\",\n-                new Integer(1),\n-                \"/list[2]/int\");\n-    }\n-\n-    public void testListMap(){\n-        assertXPathValueAndPointer(context,\n-                \"list[3]/string\",\n-                \"string\",\n-                \"/list[3][@name='string']\");\n-    }\n-\n-    public void testListList(){\n+    public void testListPrimitive() {\n+        assertXPathValueAndPointer(context, \"list[1]\", \"string\", \"/list[1]\");\n+    }\n+\n+    public void testListBean() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[2]/int\",\n+            new Integer(1),\n+            \"/list[2]/int\");\n+    }\n+\n+    public void testListMap() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[3]/string\",\n+            \"string\",\n+            \"/list[3][@name='string']\");\n+    }\n+\n+    public void testListList() {\n         /** @todo: what is this supposed to do? Should we stick to XPath,\n          *  in which case [1] is simply ignored, or Java, in which case\n          *  it is supposed to extract the first element from the list?\n //                \"string2\",\n //                \"/list[4][1]\");\n \n-        assertXPathValueAndPointer(context,\n-                \"list[4]/.[1]\",\n-                \"string2\",\n-                \"/list[4]/.[1]\");\n-    }\n-\n-    public void testListDocument(){\n-        assertXPathValueAndPointer(context,\n-                \"list[5]/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/list[5]/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testListElement(){\n-        assertXPathValueAndPointer(context,\n-                \"list[6]/location/address/city\",\n-                \"Fruit Market\",\n-                \"/list[6]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testListContainer(){\n-        assertXPathValueAndPointer(context,\n-                \"list[7]/vendor/location/address/city\",\n-                \"Fruit Market\",\n-                \"/list[7]/vendor[1]/location[2]/address[1]/city[1]\");\n-    }\n-\n-    public void testNull(){\n-\n-        assertXPathPointerLenient(context, \n-                \"$null\", \n-                \"$null\");\n-                \n-        assertXPathPointerLenient(context, \n-                \"$null[3]\", \n-                \"$null[3]\");\n-                \n-        assertXPathPointerLenient(context, \n-                \"$testnull/nothing\", \n-                \"$testnull/nothing\");\n-                \n-        assertXPathPointerLenient(context, \n-                \"$testnull/nothing[2]\", \n-                \"$testnull/nothing[2]\");\n-        \n-        assertXPathPointerLenient(context, \n-                \"beans[8]/int\", \n-                \"/beans[8]/int\");\n-        \n-        assertXPathValueIterator(context, \n-                \"$testnull/nothing[1]\", \n-                Collections.EMPTY_LIST);\n-                \n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[4]/.[1]\",\n+            \"string2\",\n+            \"/list[4]/.[1]\");\n+    }\n+\n+    public void testListDocument() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[5]/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/list[5]/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testListElement() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[6]/location/address/city\",\n+            \"Fruit Market\",\n+            \"/list[6]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testListContainer() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"list[7]/vendor/location/address/city\",\n+            \"Fruit Market\",\n+            \"/list[7]/vendor[1]/location[2]/address[1]/city[1]\");\n+    }\n+\n+    public void testNull() {\n+\n+        assertXPathPointerLenient(context, \"$null\", \"$null\");\n+\n+        assertXPathPointerLenient(context, \"$null[3]\", \"$null[3]\");\n+\n+        assertXPathPointerLenient(\n+            context,\n+            \"$testnull/nothing\",\n+            \"$testnull/nothing\");\n+\n+        assertXPathPointerLenient(\n+            context,\n+            \"$testnull/nothing[2]\",\n+            \"$testnull/nothing[2]\");\n+\n+        assertXPathPointerLenient(context, \"beans[8]/int\", \"/beans[8]/int\");\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"$testnull/nothing[1]\",\n+            Collections.EMPTY_LIST);\n+\n         JXPathContext ctx = JXPathContext.newContext(new TestNull());\n-        assertXPathValue(ctx, \n-                \"nothing\", \n-                null);\n-                \n-        assertXPathValue(ctx, \n-                \"child/nothing\", \n-                null);\n-                \n-        assertXPathValue(ctx, \n-                \"array[2]\", \n-                null);\n-                \n-        assertXPathValueLenient(ctx, \n-                \"nothing/something\", \n-                null);\n-                \n-        assertXPathValueLenient(ctx, \n-                \"array[2]/something\", \n-                null);\n-    }\n-    \n-    public void testRootAsCollection(){\n-        assertXPathValue(context, \n-                \".[1]/string\",\n-                \"string\");\n-    }\n-    \n-    public void testCreatePath(){\n+        assertXPathValue(ctx, \"nothing\", null);\n+\n+        assertXPathValue(ctx, \"child/nothing\", null);\n+\n+        assertXPathValue(ctx, \"array[2]\", null);\n+\n+        assertXPathValueLenient(ctx, \"nothing/something\", null);\n+\n+        assertXPathValueLenient(ctx, \"array[2]/something\", null);\n+    }\n+\n+    public void testRootAsCollection() {\n+        assertXPathValue(context, \".[1]/string\", \"string\");\n+    }\n+\n+    public void testCreatePath() {\n         context = JXPathContext.newContext(new TestBean());\n         context.setFactory(new TestMixedModelFactory());\n-        \n-        TestBean bean = (TestBean)context.getContextBean();\n+\n+        TestBean bean = (TestBean) context.getContextBean();\n         bean.setMap(null);\n \n-        assertXPathCreatePath(context, \n-                \"/map[@name='TestKey5']/nestedBean/int\", \n-                new Integer(1),\n-                \"/map[@name='TestKey5']/nestedBean/int\");\n-                \n+        assertXPathCreatePath(\n+            context,\n+            \"/map[@name='TestKey5']/nestedBean/int\",\n+            new Integer(1),\n+            \"/map[@name='TestKey5']/nestedBean/int\");\n+\n         bean.setMap(null);\n-        assertXPathCreatePath(context, \n-                \"/map[@name='TestKey5']/beans[2]/int\", \n-                new Integer(1),\n-                \"/map[@name='TestKey5']/beans[2]/int\");\n-    }\n-    \n+        assertXPathCreatePath(\n+            context,\n+            \"/map[@name='TestKey5']/beans[2]/int\",\n+            new Integer(1),\n+            \"/map[@name='TestKey5']/beans[2]/int\");\n+    }\n+\n     /**\n      * Test JXPath.iterate() with map containing an array\n      */\n-    public void testIterateArray(){\n+    public void testIterateArray() {\n         Map map = new HashMap();\n-        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+        map.put(\"foo\", new String[] { \"a\", \"b\", \"c\" });\n \n         JXPathContext context = JXPathContext.newContext(map);\n \n-        assertXPathValueIterator(context,\n-            \"foo\",\n-            list(\"a\", \"b\", \"c\"));\n-    }\n-\n-    public void testIteratePointersArray(){\n+        assertXPathValueIterator(context, \"foo\", list(\"a\", \"b\", \"c\"));\n+    }\n+\n+    public void testIteratePointersArray() {\n         Map map = new HashMap();\n-        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+        map.put(\"foo\", new String[] { \"a\", \"b\", \"c\" });\n \n         JXPathContext context = JXPathContext.newContext(map);\n \n         Iterator it = context.iteratePointers(\"foo\");\n         List actual = new ArrayList();\n-        while (it.hasNext()){\n-            Pointer ptr = (Pointer)it.next();\n+        while (it.hasNext()) {\n+            Pointer ptr = (Pointer) it.next();\n             actual.add(context.getValue(ptr.asPath()));\n         }\n-        assertEquals(\"Iterating pointers <\" + \"foo\" + \">\",\n-                list(\"a\", \"b\", \"c\"), actual);\n-    }\n-\n-    public void testIteratePointersArrayElementWithVariable(){\n+        assertEquals(\n+            \"Iterating pointers <\" + \"foo\" + \">\",\n+            list(\"a\", \"b\", \"c\"),\n+            actual);\n+    }\n+\n+    public void testIteratePointersArrayElementWithVariable() {\n         Map map = new HashMap();\n-        map.put(\"foo\", new String[]{\"a\", \"b\", \"c\"});\n+        map.put(\"foo\", new String[] { \"a\", \"b\", \"c\" });\n \n         JXPathContext context = JXPathContext.newContext(map);\n         context.getVariables().declareVariable(\"x\", new Integer(2));\n         Iterator it = context.iteratePointers(\"foo[$x]\");\n         List actual = new ArrayList();\n-        while (it.hasNext()){\n-            Pointer ptr = (Pointer)it.next();\n+        while (it.hasNext()) {\n+            Pointer ptr = (Pointer) it.next();\n             actual.add(context.getValue(ptr.asPath()));\n         }\n         assertEquals(\"Iterating pointers <\" + \"foo\" + \">\", list(\"b\"), actual);\n     }\n \n-    public void testIterateVector(){\n+    public void testIterateVector() {\n         Map map = new HashMap();\n         Vector vec = new Vector();\n         vec.add(new HashMap());\n \n         map.put(\"vec\", vec);\n         JXPathContext context = JXPathContext.newContext(map);\n-        assertXPathPointerIterator(context,\n+        assertXPathPointerIterator(\n+            context,\n             \"/vec\",\n             list(\"/.[@name='vec'][1]\", \"/.[@name='vec'][2]\"));\n     }\n-    \n-    public void testErrorProperty(){\n+\n+    public void testErrorProperty() {\n         context.getVariables().declareVariable(\n             \"e\",\n             new ExceptionPropertyTestBean());\n-         \n-        boolean ex = false;   \n+\n+        boolean ex = false;\n         try {\n             assertXPathValue(context, \"$e/errorString\", null);\n         }\n-        catch (Throwable t){\n+        catch (Throwable t) {\n             ex = true;\n         }\n         assertTrue(\"Legitimate exception accessing property\", ex);\n-        \n-        assertXPathPointer(context, \n-            \"$e/errorString\", \n-            \"$e/errorString\");\n-\n-        assertXPathPointerLenient(context,\n+\n+        assertXPathPointer(context, \"$e/errorString\", \"$e/errorString\");\n+\n+        assertXPathPointerLenient(\n+            context,\n             \"$e/errorStringArray[1]\",\n             \"$e/errorStringArray[1]\");\n-            \n-        assertXPathPointerIterator(context,\n+\n+        assertXPathPointerIterator(\n+            context,\n             \"$e/errorString\",\n             list(\"$e/errorString\"));\n \n-        assertXPathPointerIterator(context,\n+        assertXPathPointerIterator(\n+            context,\n             \"$e//error\",\n             Collections.EMPTY_LIST);\n     }\n-    \n-    public void testMatrix(){\n-        assertXPathValueAndPointer(context,\n-               \"$matrix[1]/.[1]\",\n-               new Integer(3),\n-               \"$matrix[1]/.[1]\");\n-                \n+\n+    public void testMatrix() {\n+        assertXPathValueAndPointer(\n+            context,\n+            \"$matrix[1]/.[1]\",\n+            new Integer(3),\n+            \"$matrix[1]/.[1]\");\n+\n         context.setValue(\"$matrix[1]/.[1]\", new Integer(2));\n \n-        assertXPathValueAndPointer(context,\n-              \"matrix[1]/.[1]\",\n-              new Integer(3),\n-              \"/matrix[1]/.[1]\");\n-                \n+        assertXPathValueAndPointer(\n+            context,\n+            \"matrix[1]/.[1]\",\n+            new Integer(3),\n+            \"/matrix[1]/.[1]\");\n+\n         context.setValue(\"matrix[1]/.[1]\", \"2\");\n-      \n+\n         assertXPathValue(context, \"matrix[1]/.[1]\", new Integer(2));\n-      \n+\n         context.getVariables().declareVariable(\n             \"wholebean\",\n             context.getContextBean());\n-            \n-        assertXPathValueAndPointer(context,\n+\n+        assertXPathValueAndPointer(\n+            context,\n             \"$wholebean/matrix[1]/.[1]\",\n             new Integer(2),\n             \"$wholebean/matrix[1]/.[1]\");\n         try {\n             context.setValue(\"$wholebean/matrix[1]/.[2]\", \"4\");\n         }\n-        catch (Exception e){\n+        catch (Exception e) {\n             ex = true;\n-        }        \n+        }\n         assertTrue(\"Exception setting value of non-existent element\", ex);\n-        \n+\n         ex = false;\n         try {\n             context.setValue(\"$wholebean/matrix[2]/.[1]\", \"4\");\n         }\n-        catch (Exception e){\n+        catch (Exception e) {\n             ex = true;\n-        }        \n+        }\n         assertTrue(\"Exception setting value of non-existent element\", ex);\n     }\n-    \n-    public void testCreatePathAndSetValueWithMatrix(){\n-        \n+\n+    public void testCreatePathAndSetValueWithMatrix() {\n+\n         context.setValue(\"matrix\", null);\n-        \n+\n         // Calls factory.createObject(..., TestMixedModelBean, \"matrix\")\n         // Calls factory.createObject(..., nestedBean, \"strings\", 2)\n-        assertXPathCreatePathAndSetValue(context,\n-                \"/matrix[1]/.[1]\",\n-                new Integer(4),\n-                \"/matrix[1]/.[1]\");        \n-    }    \n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/matrix[1]/.[1]\",\n+            new Integer(4),\n+            \"/matrix[1]/.[1]\");\n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.3 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/TestMixedModelFactory.java,v 1.4 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.HashMap;\n import java.util.Map;\n \n-import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n+import org.apache.commons.jxpath.TestMixedModelBean;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.4 $ $Date: 2003/01/20 00:00:28 $\n  */\n public class TestMixedModelFactory extends AbstractFactory {\n \n      * Create a new instance and put it in the collection on the parent object.\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-    public boolean createObject(JXPathContext context, Pointer pointer, Object parent, String name, int index){\n-        if (name.equals(\"nestedBean\")){\n-            ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n+    public boolean createObject(\n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n+    {\n+        if (name.equals(\"nestedBean\")) {\n+            ((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n             return true;\n         }\n-        else if (name.equals(\"beans\")){\n-            TestBean bean = (TestBean)parent;\n-            if (bean.getBeans() == null || index >= bean.getBeans().length){\n+        else if (name.equals(\"beans\")) {\n+            TestBean bean = (TestBean) parent;\n+            if (bean.getBeans() == null || index >= bean.getBeans().length) {\n                 bean.setBeans(new NestedTestBean[index + 1]);\n             }\n             bean.getBeans()[index] = new NestedTestBean(\"newName\");\n             return true;\n         }\n-        else if (name.equals(\"map\")){\n-            ((TestBean)parent).setMap(new HashMap());\n+        else if (name.equals(\"map\")) {\n+            ((TestBean) parent).setMap(new HashMap());\n             return true;\n         }\n-        else if (name.equals(\"TestKey5\")){\n+        else if (name.equals(\"TestKey5\")) {\n             TestBean tb = new TestBean();\n             tb.setNestedBean(null);\n             tb.setBeans(null);\n-            ((Map)parent).put(name, tb);\n+            ((Map) parent).put(name, tb);\n             return true;\n         }\n-        else if (name.equals(\"matrix\")){\n+        else if (name.equals(\"matrix\")) {\n             int[][] matrix = new int[2][];\n             matrix[0] = new int[1];\n-//            matrix[1] = new int[2];\n-            ((TestMixedModelBean)parent).setMatrix(matrix);\n+            //            matrix[1] = new int[2];\n+             ((TestMixedModelBean) parent).setMatrix(matrix);\n             return true;\n         }\n         return false;\n     }\n \n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.8 2003/01/12 05:21:50 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2003/01/12 05:21:50 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/XMLModelTestCase.java,v 1.9 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * DOM, JDOM etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2003/01/12 05:21:50 $\n+ * @version $Revision: 1.9 $ $Date: 2003/01/20 00:00:28 $\n  */\n \n-public abstract class XMLModelTestCase extends JXPathTestCase\n-{\n+public abstract class XMLModelTestCase extends JXPathTestCase {\n     private JXPathContext context;\n \n     /**\n      *\n      * @param name Name of the test case\n      */\n-    public XMLModelTestCase(String name){\n+    public XMLModelTestCase(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             DocumentContainer docCtr = createDocumentContainer();\n             context = createContext();\n             Variables vars = context.getVariables();\n             vars.declareVariable(\"document\", docCtr.getValue());\n             vars.declareVariable(\"container\", docCtr);\n-            vars.declareVariable(\"element\", \n-            context.getPointer(\"vendor/location/address/street\").getNode());\n+            vars.declareVariable(\n+                \"element\",\n+                context.getPointer(\"vendor/location/address/street\").getNode());\n         }\n     }\n \n     protected abstract String getModel();\n \n-    protected DocumentContainer createDocumentContainer(){\n+    protected DocumentContainer createDocumentContainer() {\n         return new DocumentContainer(\n-                JXPathTestCase.class.getResource(\"Vendor.xml\"),\n-                getModel());\n-    }\n-    \n+            JXPathTestCase.class.getResource(\"Vendor.xml\"),\n+            getModel());\n+    }\n+\n     protected abstract AbstractFactory getAbstractFactory();\n \n-    protected JXPathContext createContext(){\n+    protected JXPathContext createContext() {\n         JXPathContext context =\n-                JXPathContext.newContext(createDocumentContainer());\n+            JXPathContext.newContext(createDocumentContainer());\n         context.setFactory(getAbstractFactory());\n         return context;\n     }\n      * An XML signature is used to determine if we have the right result\n      * after a modification of XML by JXPath.  It is basically a piece\n      * of simplified XML.\n-     */    \n-    protected abstract String getXMLSignature(Object node, \n-            boolean elements, boolean attributes, boolean text, boolean pi);\n-\n-    protected void assertXMLSignature(JXPathContext context,\n-            String path, String signature,\n-            boolean elements, boolean attributes, boolean text, boolean pi)\n+     */\n+    protected abstract String getXMLSignature(\n+        Object node,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi);\n+\n+    protected void assertXMLSignature(\n+        JXPathContext context,\n+        String path,\n+        String signature,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n     {\n         Object node = context.getPointer(path).getNode();\n         String sig = getXMLSignature(node, elements, attributes, text, pi);\n         assertEquals(\"XML Signature mismatch: \", signature, sig);\n     }\n-    \n+\n     // ------------------------------------------------ Individual Test Methods\n \n-    public void testDocumentOrder(){\n-        assertDocumentOrder(context, \n-                \"vendor/location\", \n-                \"vendor/location/address/street\", \n-                -1);\n-                \n-        assertDocumentOrder(context, \n-                \"vendor/location[@id = '100']\", \n-                \"vendor/location[@id = '101']\", \n-                -1);\n-                \n-        assertDocumentOrder(context, \n-                \"vendor//price:amount\", \n-                \"vendor/location\", \n-                1);\n-    }\n-\n-    public void testSetValue(){\n-        assertXPathSetValue(context,\n-                \"vendor/location[@id = '100']\",\n-                \"New Text\");\n-        \n-        assertXMLSignature(context,\n-                \"vendor/location[@id = '100']\",\n-                \"<E>New Text</E>\",\n-                false, false, true, false);\n-                \n-        assertXPathSetValue(context,\n-                \"vendor/location[@id = '101']\",\n-                \"Replacement Text\");\n-\n-        assertXMLSignature(context,\n-                \"vendor/location[@id = '101']\",\n-                \"<E>Replacement Text</E>\",\n-                false, false, true, false);                \n-    }\n-    \n+    public void testDocumentOrder() {\n+        assertDocumentOrder(\n+            context,\n+            \"vendor/location\",\n+            \"vendor/location/address/street\",\n+            -1);\n+\n+        assertDocumentOrder(\n+            context,\n+            \"vendor/location[@id = '100']\",\n+            \"vendor/location[@id = '101']\",\n+            -1);\n+\n+        assertDocumentOrder(\n+            context,\n+            \"vendor//price:amount\",\n+            \"vendor/location\",\n+            1);\n+    }\n+\n+    public void testSetValue() {\n+        assertXPathSetValue(\n+            context,\n+            \"vendor/location[@id = '100']\",\n+            \"New Text\");\n+\n+        assertXMLSignature(\n+            context,\n+            \"vendor/location[@id = '100']\",\n+            \"<E>New Text</E>\",\n+            false,\n+            false,\n+            true,\n+            false);\n+\n+        assertXPathSetValue(\n+            context,\n+            \"vendor/location[@id = '101']\",\n+            \"Replacement Text\");\n+\n+        assertXMLSignature(\n+            context,\n+            \"vendor/location[@id = '101']\",\n+            \"<E>Replacement Text</E>\",\n+            false,\n+            false,\n+            true,\n+            false);\n+    }\n+\n     /**\n      * Test JXPathContext.createPath() with various arguments\n      */\n-    public void testCreatePath(){\n+    public void testCreatePath() {\n         // Create a DOM element\n-        assertXPathCreatePath(context, \n-                \"/vendor[1]/location[3]\", \n-                \"\",\n-                \"/vendor[1]/location[3]\");\n+        assertXPathCreatePath(\n+            context,\n+            \"/vendor[1]/location[3]\",\n+            \"\",\n+            \"/vendor[1]/location[3]\");\n \n         // Create a DOM element with contents\n-        assertXPathCreatePath(context, \n-                \"/vendor[1]/location[3]/address/street\", \n-                \"\",\n-                \"/vendor[1]/location[3]/address[1]/street[1]\");\n+        assertXPathCreatePath(\n+            context,\n+            \"/vendor[1]/location[3]/address/street\",\n+            \"\",\n+            \"/vendor[1]/location[3]/address[1]/street[1]\");\n \n         // Create a DOM attribute\n-        assertXPathCreatePath(context, \n-                \"/vendor[1]/location[2]/@manager\", \n-                \"\",\n-                \"/vendor[1]/location[2]/@manager\");\n-\n-        assertXPathCreatePath(context, \n-                \"/vendor[1]/location[1]/@name\", \n-                \"local\",\n-                \"/vendor[1]/location[1]/@name\");\n-    }\n-\n+        assertXPathCreatePath(\n+            context,\n+            \"/vendor[1]/location[2]/@manager\",\n+            \"\",\n+            \"/vendor[1]/location[2]/@manager\");\n+\n+        assertXPathCreatePath(\n+            context,\n+            \"/vendor[1]/location[1]/@name\",\n+            \"local\",\n+            \"/vendor[1]/location[1]/@name\");\n+    }\n \n     /**\n      * Test JXPath.createPathAndSetValue() with various arguments\n      */\n-    public void testCreatePathAndSetValue(){\n+    public void testCreatePathAndSetValue() {\n         // Create a XML element\n-        assertXPathCreatePathAndSetValue(context, \n-                \"vendor/location[3]\", \n-                \"\",\n-                \"/vendor[1]/location[3]\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"vendor/location[3]\",\n+            \"\",\n+            \"/vendor[1]/location[3]\");\n \n         // Create a DOM element with contents\n-        assertXPathCreatePathAndSetValue(context, \n-                \"vendor/location[3]/address/street\", \n-                \"Lemon Circle\",\n-                \"/vendor[1]/location[3]/address[1]/street[1]\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"vendor/location[3]/address/street\",\n+            \"Lemon Circle\",\n+            \"/vendor[1]/location[3]/address[1]/street[1]\");\n \n         // Create an attribute\n-        assertXPathCreatePathAndSetValue(context, \n-                \"vendor/location[2]/@manager\", \n-                \"John Doe\",\n-                \"/vendor[1]/location[2]/@manager\");\n-                \n-        assertXPathCreatePathAndSetValue(context,\n-                \"vendor/location[1]/@manager\", \n-                \"John Doe\",\n-                \"/vendor[1]/location[1]/@manager\");\n-\n-        assertXPathCreatePathAndSetValue(context, \n-                \"vendor/product/name/attribute::price:language\", \n-                \"English\",\n-                \"/vendor[1]/product[1]/name[1]/@price:language\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"vendor/location[2]/@manager\",\n+            \"John Doe\",\n+            \"/vendor[1]/location[2]/@manager\");\n+\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"vendor/location[1]/@manager\",\n+            \"John Doe\",\n+            \"/vendor[1]/location[1]/@manager\");\n+\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"vendor/product/name/attribute::price:language\",\n+            \"English\",\n+            \"/vendor[1]/product[1]/name[1]/@price:language\");\n     }\n \n     /**\n      * Test JXPathContext.removePath() with various arguments\n      */\n-    public void testRemovePath(){\n+    public void testRemovePath() {\n         // Remove XML nodes\n         context.removePath(\"vendor/location[@id = '101']//street/text()\");\n-        assertEquals(\"Remove DOM text\", \"\",\n-                    context.getValue(\"vendor/location[@id = '101']//street\"));\n+        assertEquals(\n+            \"Remove DOM text\",\n+            \"\",\n+            context.getValue(\"vendor/location[@id = '101']//street\"));\n \n         context.removePath(\"vendor/location[@id = '101']//street\");\n-        assertEquals(\"Remove DOM element\", new Double(0),\n-                    context.getValue(\"count(vendor/location[@id = '101']//street)\"));\n+        assertEquals(\n+            \"Remove DOM element\",\n+            new Double(0),\n+            context.getValue(\"count(vendor/location[@id = '101']//street)\"));\n \n         context.removePath(\"vendor/location[@id = '100']/@name\");\n-        assertEquals(\"Remove DOM attribute\", new Double(0),\n-                    context.getValue(\"count(vendor/location[@id = '100']/@name)\"));\n-    }\n-\n-    public void testID(){\n-        context.setIdentityManager(new IdentityManager(){\n-            public Pointer getPointerByID(JXPathContext context, String id){\n-                NodePointer ptr = (NodePointer)context.getPointer(\"/\");\n-                ptr = ptr.getValuePointer();        // Unwrap the container\n+        assertEquals(\n+            \"Remove DOM attribute\",\n+            new Double(0),\n+            context.getValue(\"count(vendor/location[@id = '100']/@name)\"));\n+    }\n+\n+    public void testID() {\n+        context.setIdentityManager(new IdentityManager() {\n+            public Pointer getPointerByID(JXPathContext context, String id) {\n+                NodePointer ptr = (NodePointer) context.getPointer(\"/\");\n+                ptr = ptr.getValuePointer(); // Unwrap the container\n                 return ptr.getPointerByID(context, id);\n             }\n         });\n \n-        assertXPathValueAndPointer(context,\n-                \"id(101)//street\",\n-                \"Tangerine Drive\",\n-                \"id('101')/address[1]/street[1]\");\n-\n-        assertXPathPointerLenient(context,\n-                \"id(105)/address/street\",\n-                \"id(105)/address/street\");\n+        assertXPathValueAndPointer(\n+            context,\n+            \"id(101)//street\",\n+            \"Tangerine Drive\",\n+            \"id('101')/address[1]/street[1]\");\n+\n+        assertXPathPointerLenient(\n+            context,\n+            \"id(105)/address/street\",\n+            \"id(105)/address/street\");\n     }\n \n     public void testAxisChild() {\n-        assertXPathValue(context,\n-                \"vendor/location/address/street\",\n-                \"Orchard Road\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/location/address/street\",\n+            \"Orchard Road\");\n \n         // child:: - first child does not match, need to search\n-        assertXPathValue(context,\n-                \"vendor/location/address/city\",\n-                \"Fruit Market\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/location/address/city\",\n+            \"Fruit Market\");\n         // local-name(qualified)\n-        assertXPathValue(context,\n-                \"local-name(vendor/product/price:amount)\",\n-                \"amount\");\n+        assertXPathValue(\n+            context,\n+            \"local-name(vendor/product/price:amount)\",\n+            \"amount\");\n \n         // local-name(non-qualified)\n-        assertXPathValue(context,\n-                \"local-name(vendor/location)\",\n-                \"location\");\n+        assertXPathValue(context, \"local-name(vendor/location)\", \"location\");\n \n         // name (qualified)\n-        assertXPathValue(context,\n-                \"name(vendor/product/price:amount)\",\n-                \"priceNS:amount\");\n+        assertXPathValue(\n+            context,\n+            \"name(vendor/product/price:amount)\",\n+            \"priceNS:amount\");\n \n         // name (non-qualified)\n-        assertXPathValue(context,\n-                \"name(vendor/location)\",\n-                \"location\");\n+        assertXPathValue(context, \"name(vendor/location)\", \"location\");\n \n         // namespace-uri (qualified)\n-        assertXPathValue(context,\n-                \"namespace-uri(vendor/product/price:amount)\",\n-                \"priceNS\");\n+        assertXPathValue(\n+            context,\n+            \"namespace-uri(vendor/product/price:amount)\",\n+            \"priceNS\");\n \n         // default namespace does not affect search\n-        assertXPathValue(context,\n-                \"vendor/product/prix\",\n-                \"934.99\");\n+        assertXPathValue(context, \"vendor/product/prix\", \"934.99\");\n \n         // child:: with a wildcard\n-        assertXPathValue(context,\n-                \"count(vendor/product/price:*)\",\n-                new Double(2));\n+        assertXPathValue(\n+            context,\n+            \"count(vendor/product/price:*)\",\n+            new Double(2));\n \n         // child:: with a namespace and wildcard\n-        assertXPathValue(context,\n-                \"count(vendor/product/value:*)\",\n-                new Double(2));\n+        assertXPathValue(\n+            context,\n+            \"count(vendor/product/value:*)\",\n+            new Double(2));\n \n         // child:: with the default namespace\n-        assertXPathValue(context,\n-                \"count(vendor/product/*)\",\n-                new Double(4));\n+        assertXPathValue(context, \"count(vendor/product/*)\", new Double(4));\n \n         // child:: with a qualified name\n-        assertXPathValue(context,\n-                \"vendor/product/price:amount\",\n-                \"45.95\");\n+        assertXPathValue(context, \"vendor/product/price:amount\", \"45.95\");\n     }\n \n     public void testAxisChildIndexPredicate() {\n-        assertXPathValue(context,\n-                \"vendor/location[2]/address/street\",\n-                \"Tangerine Drive\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/location[2]/address/street\",\n+            \"Tangerine Drive\");\n     }\n \n     public void testAxisDescendant() {\n         // descendant::\n-        assertXPathValue(context,\n-                \"//street\",\n-                \"Orchard Road\");\n+        assertXPathValue(context, \"//street\", \"Orchard Road\");\n \n         // descendent:: with a namespace and wildcard\n-        assertXPathValue(context,\n-                \"count(//price:*)\",\n-                new Double(2));\n-                \n-        assertXPathValueIterator(context,\n-                \"vendor//saleEnds\",\n-                list(\"never\"));\n-\n-        assertXPathValueIterator(context,\n-                \"vendor//promotion\",\n-                list(\"\"));\n-\n-        assertXPathValueIterator(context,\n-                \"vendor//saleEnds[../@stores = 'all']\",\n-                list(\"never\"));\n-\n-        assertXPathValueIterator(context,\n-                \"vendor//promotion[../@stores = 'all']\",\n-                list(\"\"));\n-    }\n-    \n+        assertXPathValue(context, \"count(//price:*)\", new Double(2));\n+\n+        assertXPathValueIterator(context, \"vendor//saleEnds\", list(\"never\"));\n+\n+        assertXPathValueIterator(context, \"vendor//promotion\", list(\"\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor//saleEnds[../@stores = 'all']\",\n+            list(\"never\"));\n+\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor//promotion[../@stores = 'all']\",\n+            list(\"\"));\n+    }\n+\n     public void testAxisParent() {\n         // parent::\n-        assertXPathPointer(context,\n-                \"//street/..\",\n-                \"/vendor[1]/location[1]/address[1]\");\n+        assertXPathPointer(\n+            context,\n+            \"//street/..\",\n+            \"/vendor[1]/location[1]/address[1]\");\n \n         // parent:: (note reverse document order)\n-        assertXPathPointerIterator(context,\n-                \"//street/..\",\n-                list(\"/vendor[1]/location[2]/address[1]\",\n-                     \"/vendor[1]/location[1]/address[1]\"));\n+        assertXPathPointerIterator(\n+            context,\n+            \"//street/..\",\n+            list(\n+                \"/vendor[1]/location[2]/address[1]\",\n+                \"/vendor[1]/location[1]/address[1]\"));\n \n         // parent:: with a namespace and wildcard\n-        assertXPathValue(context,\n-                \"vendor/product/price:sale/saleEnds/parent::price:*\" +\n-                        \"/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:sale/saleEnds/parent::price:*\" + \"/saleEnds\",\n+            \"never\");\n     }\n \n     public void testAxisFollowingSibling() {\n         // following-sibling::\n-        assertXPathValue(context,\n-                \"vendor/location[.//employeeCount = 10]/\" +\n-                        \"following-sibling::location//street\",\n-                \"Tangerine Drive\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/location[.//employeeCount = 10]/\"\n+                + \"following-sibling::location//street\",\n+            \"Tangerine Drive\");\n \n         // following-sibling:: produces the correct pointer\n-        assertXPathPointer(context,\n-                \"vendor/location[.//employeeCount = 10]/\" +\n-                        \"following-sibling::location//street\",\n-                \"/vendor[1]/location[2]/address[1]/street[1]\");\n+        assertXPathPointer(\n+            context,\n+            \"vendor/location[.//employeeCount = 10]/\"\n+                + \"following-sibling::location//street\",\n+            \"/vendor[1]/location[2]/address[1]/street[1]\");\n     }\n \n     public void testAxisPrecedingSibling() {\n         // preceding-sibling:: produces the correct pointer\n-        assertXPathPointer(context,\n-                \"//location[2]/preceding-sibling::location//street\",\n-                \"/vendor[1]/location[1]/address[1]/street[1]\");\n+        assertXPathPointer(\n+            context,\n+            \"//location[2]/preceding-sibling::location//street\",\n+            \"/vendor[1]/location[1]/address[1]/street[1]\");\n     }\n \n     public void testAxisAttribute() {\n         // attribute::\n-        assertXPathValue(context,\n-                \"vendor/location/@id\",\n-                \"100\");\n+        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n \n         // attribute:: produces the correct pointer\n-        assertXPathPointer(context,\n-                \"vendor/location/@id\",\n-                \"/vendor[1]/location[1]/@id\");\n+        assertXPathPointer(\n+            context,\n+            \"vendor/location/@id\",\n+            \"/vendor[1]/location[1]/@id\");\n \n         // iterate over attributes\n-        assertXPathValueIterator(context,\n-                \"vendor/location/@id\",\n-                list(\"100\", \"101\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor/location/@id\",\n+            list(\"100\", \"101\"));\n \n         // Using different prefixes for the same namespace\n-        assertXPathValue(context,\n-                \"vendor/product/price:amount/@price:discount\",\n-                \"10%\");\n-        assertXPathValue(context,\n-                \"vendor/product/value:amount/@value:discount\",\n-                \"10%\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:amount/@price:discount\",\n+            \"10%\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/value:amount/@value:discount\",\n+            \"10%\");\n \n         // namespace uri for an attribute\n-        assertXPathValue(context,\n-                \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n-                \"priceNS\");\n+        assertXPathValue(\n+            context,\n+            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n+            \"priceNS\");\n \n         // local name of an attribute\n-        assertXPathValue(context,\n-                \"local-name(vendor/product/price:amount/@price:discount)\",\n-                \"discount\");\n+        assertXPathValue(\n+            context,\n+            \"local-name(vendor/product/price:amount/@price:discount)\",\n+            \"discount\");\n \n         // name for an attribute\n-        assertXPathValue(context,\n-                \"name(vendor/product/price:amount/@price:discount)\",\n-                \"priceNS:discount\");\n+        assertXPathValue(\n+            context,\n+            \"name(vendor/product/price:amount/@price:discount)\",\n+            \"priceNS:discount\");\n \n         // attribute:: with the default namespace\n-        assertXPathValue(context,\n-                \"vendor/product/price:amount/@discount\",\n-                \"20%\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:amount/@discount\",\n+            \"20%\");\n \n         // namespace uri of an attribute with the default namespace\n-        assertXPathValue(context,\n-                \"namespace-uri(vendor/product/price:amount/@discount)\",\n-                \"\");\n+        assertXPathValue(\n+            context,\n+            \"namespace-uri(vendor/product/price:amount/@discount)\",\n+            \"\");\n \n         // local name of an attribute with the default namespace\n-        assertXPathValue(context,\n-                \"local-name(vendor/product/price:amount/@discount)\",\n-                \"discount\");\n+        assertXPathValue(\n+            context,\n+            \"local-name(vendor/product/price:amount/@discount)\",\n+            \"discount\");\n \n         // name of an attribute with the default namespace\n-        assertXPathValue(context,\n-                \"name(vendor/product/price:amount/@discount)\",\n-                \"discount\");\n+        assertXPathValue(\n+            context,\n+            \"name(vendor/product/price:amount/@discount)\",\n+            \"discount\");\n \n         // attribute:: with a namespace and wildcard\n-        assertXPathValueIterator(context,\n-                \"vendor/product/price:amount/@price:*\",\n-                list(\"10%\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor/product/price:amount/@price:*\",\n+            list(\"10%\"));\n \n         // attribute:: with a wildcard\n-        assertXPathValueIterator(context,\n-                \"vendor/location[1]/@*\",\n-                set(\"100\", \"\", \"local\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor/location[1]/@*\",\n+            set(\"100\", \"\", \"local\"));\n \n         // attribute:: with default namespace and wildcard\n-        assertXPathValueIterator(context,\n-                \"vendor/product/price:amount/@*\",\n-                list(\"20%\"));\n-\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor/product/price:amount/@*\",\n+            list(\"20%\"));\n \n         // Empty attribute\n-        assertXPathValue(context,\n-                \"vendor/location/@manager\",\n-                \"\");\n+        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n \n         // Missing attribute\n-        assertXPathValueLenient(context,\n-                \"vendor/location/@missing\",\n-                null);\n+        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n \n         // Missing attribute with namespace\n-        assertXPathValueLenient(context,\n-                \"vendor/location/@miss:missing\",\n-                null);\n-                \n+        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n+\n         // Using attribute in a predicate\n-        assertXPathValue(context,\n-                \"vendor/location[@id='101']//street\",\n-                \"Tangerine Drive\");\n-    }\n-    \n+        assertXPathValue(\n+            context,\n+            \"vendor/location[@id='101']//street\",\n+            \"Tangerine Drive\");\n+    }\n+\n     public void testAxisNamespace() {\n         // namespace::\n-        assertXPathValueAndPointer(context,\n-                \"vendor/product/prix/namespace::price\",\n-                \"priceNS\",\n-                \"/vendor[1]/product[1]/prix[1]/namespace::price\");\n+        assertXPathValueAndPointer(\n+            context,\n+            \"vendor/product/prix/namespace::price\",\n+            \"priceNS\",\n+            \"/vendor[1]/product[1]/prix[1]/namespace::price\");\n \n         // namespace::*\n-        assertXPathValue(context,\n-                \"count(vendor/product/namespace::*)\",\n-                new Double(3));\n+        assertXPathValue(\n+            context,\n+            \"count(vendor/product/namespace::*)\",\n+            new Double(3));\n \n         // name of namespace\n-        assertXPathValue(context,\n-                \"name(vendor/product/prix/namespace::price)\",\n-                \"priceNS:price\");\n+        assertXPathValue(\n+            context,\n+            \"name(vendor/product/prix/namespace::price)\",\n+            \"priceNS:price\");\n \n         // local name of namespace\n-        assertXPathValue(context,\n-                \"local-name(vendor/product/prix/namespace::price)\",\n-                \"price\");\n+        assertXPathValue(\n+            context,\n+            \"local-name(vendor/product/prix/namespace::price)\",\n+            \"price\");\n     }\n \n     public void testAxisAncestor() {\n         // ancestor::\n-        assertXPathValue(context,\n-                \"vendor/product/price:sale/saleEnds/\" +\n-                        \"ancestor::price:sale/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:sale/saleEnds/\"\n+                + \"ancestor::price:sale/saleEnds\",\n+            \"never\");\n \n         // ancestor:: with a wildcard\n-        assertXPathValue(context,\n-                \"vendor/product/price:sale/saleEnds/ancestor::price:*\" +\n-                        \"/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:sale/saleEnds/ancestor::price:*\"\n+                + \"/saleEnds\",\n+            \"never\");\n     }\n \n     public void testAxisAncestorOrSelf() {\n         // ancestor-or-self::\n-        assertXPathValue(context,\n-                \"vendor/product/price:sale/\" +\n-                        \"ancestor-or-self::price:sale/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"vendor/product/price:sale/\"\n+                + \"ancestor-or-self::price:sale/saleEnds\",\n+            \"never\");\n     }\n \n     public void testAxisFollowing() {\n-        assertXPathValueIterator(context,\n-                \"vendor/contact/following::location//street\",\n-                list(\"Orchard Road\", \"Tangerine Drive\"));\n+        assertXPathValueIterator(\n+            context,\n+            \"vendor/contact/following::location//street\",\n+            list(\"Orchard Road\", \"Tangerine Drive\"));\n \n         // following:: with a namespace\n-        assertXPathValue(context,\n-                \"//location/following::price:sale/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"//location/following::price:sale/saleEnds\",\n+            \"never\");\n     }\n \n     public void testAxisSelf() {\n         // self:: with a namespace\n-        assertXPathValue(context,\n-                \"//price:sale/self::price:sale/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"//price:sale/self::price:sale/saleEnds\",\n+            \"never\");\n \n         // self:: with an unmatching name\n-        assertXPathValueLenient(context,\n-                \"//price:sale/self::x/saleEnds\",\n-                null);\n+        assertXPathValueLenient(context, \"//price:sale/self::x/saleEnds\", null);\n     }\n \n     public void testNodeTypeComment() {\n         // comment()\n-        assertXPathValue(context,\n-                \"//product/comment()\",\n-                \"We are not buying this product, ever\");\n+        assertXPathValue(\n+            context,\n+            \"//product/comment()\",\n+            \"We are not buying this product, ever\");\n     }\n \n     public void testNodeTypeText() {\n         // text()\n-        assertXPathValue(context,\n-                \"//product/text()[. != '']\",\n-                \"We love this product.\");\n+        assertXPathValue(\n+            context,\n+            \"//product/text()[. != '']\",\n+            \"We love this product.\");\n \n         // text() pointer\n-        assertXPathPointer(context,\n-                \"//product/text()\",\n-                \"/vendor[1]/product[1]/text()[1]\");\n+        assertXPathPointer(\n+            context,\n+            \"//product/text()\",\n+            \"/vendor[1]/product[1]/text()[1]\");\n \n     }\n \n     public void testNodeTypeProcessingInstruction() {\n         // processing-instruction() without an argument\n-        assertXPathValue(context,\n-                \"//product/processing-instruction()\",\n-                \"do not show anybody\");\n+        assertXPathValue(\n+            context,\n+            \"//product/processing-instruction()\",\n+            \"do not show anybody\");\n \n         // processing-instruction() with an argument\n-        assertXPathValue(context,\n-                \"//product/processing-instruction('report')\",\n-                \"average only\");\n+        assertXPathValue(\n+            context,\n+            \"//product/processing-instruction('report')\",\n+            \"average only\");\n \n         // processing-instruction() pointer without an argument\n-        assertXPathPointer(context,\n-                \"//product/processing-instruction('report')\",\n-                \"/vendor[1]/product[1]/processing-instruction('report')[1]\");\n+        assertXPathPointer(\n+            context,\n+            \"//product/processing-instruction('report')\",\n+            \"/vendor[1]/product[1]/processing-instruction('report')[1]\");\n \n         // processing-instruction name\n-        assertXPathValue(context,\n-                \"name(//product/processing-instruction()[1])\",\n-                \"security\");\n+        assertXPathValue(\n+            context,\n+            \"name(//product/processing-instruction()[1])\",\n+            \"security\");\n     }\n \n     public void testLang() {\n         // xml:lang built-in attribute\n-        assertXPathValue(context,\n-                \"//product/prix/@xml:lang\",\n-                \"fr\");\n+        assertXPathValue(context, \"//product/prix/@xml:lang\", \"fr\");\n \n         // lang() used the built-in xml:lang attribute\n-        assertXPathValue(context,\n-                \"//product/prix[lang('fr')]\",\n-                \"934.99\");\n+        assertXPathValue(context, \"//product/prix[lang('fr')]\", \"934.99\");\n \n         // Default language\n-        assertXPathValue(context,\n-                \"//product/price:sale[lang('en')]/saleEnds\",\n-                \"never\");\n+        assertXPathValue(\n+            context,\n+            \"//product/price:sale[lang('en')]/saleEnds\",\n+            \"never\");\n     }\n \n     public void testDocument() {\n-        assertXPathValue(context,\n-                \"$document/vendor/location[1]//street\",\n-                \"Orchard Road\");\n-\n-        assertXPathPointer(context,\n-                \"$document/vendor/location[1]//street\",\n-                \"$document/vendor[1]/location[1]/address[1]/street[1]\");\n-\n-        assertXPathValue(context,\n-                \"$document/vendor//street\",\n-                \"Orchard Road\");\n+        assertXPathValue(\n+            context,\n+            \"$document/vendor/location[1]//street\",\n+            \"Orchard Road\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"$document/vendor/location[1]//street\",\n+            \"$document/vendor[1]/location[1]/address[1]/street[1]\");\n+\n+        assertXPathValue(context, \"$document/vendor//street\", \"Orchard Road\");\n     }\n \n     public void testContainer() {\n-        assertXPathValue(context,\n-                \"$container/vendor//street\",\n-                \"Orchard Road\");\n-\n-        assertXPathValue(context,\n-                \"$container//street\",\n-                \"Orchard Road\");\n-\n-        assertXPathPointer(context,\n-                \"$container//street\",\n-                \"$container/vendor[1]/location[1]/address[1]/street[1]\");\n+        assertXPathValue(context, \"$container/vendor//street\", \"Orchard Road\");\n+\n+        assertXPathValue(context, \"$container//street\", \"Orchard Road\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"$container//street\",\n+            \"$container/vendor[1]/location[1]/address[1]/street[1]\");\n \n         // Conversion to number\n-        assertXPathValue(context,\n-                \"number(vendor/location/employeeCount)\",\n-                new Double(10));\n-    }\n-    \n+        assertXPathValue(\n+            context,\n+            \"number(vendor/location/employeeCount)\",\n+            new Double(10));\n+    }\n+\n     public void testElementInVariable() {\n-        assertXPathValue(context,\n-                \"$element\",\n-                \"Orchard Road\");                \n+        assertXPathValue(context, \"$element\", \"Orchard Road\");\n     }\n \n     public void testTypeConversions() {\n         // Implicit conversion to number\n-        assertXPathValue(context,\n-                \"vendor/location/employeeCount + 1\",\n-                new Double(11));\n+        assertXPathValue(\n+            context,\n+            \"vendor/location/employeeCount + 1\",\n+            new Double(11));\n \n         // Implicit conversion to boolean\n-        assertXPathValue(context,\n-                \"vendor/location/employeeCount and true()\",\n-                Boolean.TRUE);\n-    }\n-    \n-    public void testBooleanFunction(){\n-        assertXPathValue(context,\n+        assertXPathValue(\n+            context,\n+            \"vendor/location/employeeCount and true()\",\n+            Boolean.TRUE);\n+    }\n+\n+    public void testBooleanFunction() {\n+        assertXPathValue(\n+            context,\n             \"boolean(vendor//saleEnds[../@stores = 'all'])\",\n             Boolean.TRUE);\n \n-        assertXPathValue(context,\n+        assertXPathValue(\n+            context,\n             \"boolean(vendor//promotion[../@stores = 'all'])\",\n             Boolean.TRUE);\n \n-        assertXPathValue(context,\n+        assertXPathValue(\n+            context,\n             \"boolean(vendor//promotion[../@stores = 'some'])\",\n             Boolean.FALSE);\n-     }    \n-     \n-    public void testBooleanPredicateWithSearch(){\n-        \n-        assertXPathValueIterator(context,\n-            \"/vendor/inventory[department/count < 10]/name\",\n-            list(\"Watermelon\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/vendor/inventory[department/count >= 100]/name\",\n-            list(\"Cantaloupe\")\n-        );\n-\n-        assertXPathValueIterator(context,\n-            \"/vendor/inventory[department/count = 3]/name\",\n-            list(\"Watermelon\")\n-        );\n-        \n-        assertXPathValueIterator(context,\n-            \"/vendor/inventory[department/count != 3]/name\",\n-            list(\"Cantaloupe\")\n-        );\n-    }     \n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java,v 1.2 2002/11/26 01:20:08 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/11/26 01:20:08 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/BeanModelTest.java,v 1.3 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with JavaBeans\n *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/11/26 01:20:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/20 00:00:28 $\n  */\n \n-public class BeanModelTest extends BeanModelTestCase\n-{\n+public class BeanModelTest extends BeanModelTestCase {\n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public BeanModelTest(String name){\n+    public BeanModelTest(String name) {\n         super(name);\n     }\n \n     /**\n      * Return the tests included in this test suite.\n      */\n-    public static TestSuite suite(){\n+    public static TestSuite suite() {\n         return (new TestSuite(BeanModelTest.class));\n     }\n \n-    protected Object createContextBean(){\n+    protected Object createContextBean() {\n         return new TestBean();\n     }\n \n-    protected AbstractFactory getAbstractFactory(){\n+    protected AbstractFactory getAbstractFactory() {\n         return new TestBeanFactory();\n     }\n \n--- a/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/beans/TestBeanFactory.java,v 1.5 2003/01/20 00:00:28 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/20 00:00:28 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.beans;\n \n-import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/20 00:00:28 $\n  */\n public class TestBeanFactory extends AbstractFactory {\n \n     /**\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-    public boolean createObject(JXPathContext context, \n-                Pointer pointer, Object parent, String name, int index)\n+    public boolean createObject(\n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n     {\n         if (name.equals(\"nestedBean\")) {\n             ((TestBean) parent).setNestedBean(new NestedTestBean(\"newName\"));\n             bean.getBeans()[index] = new NestedTestBean(\"newName\");\n             return true;\n         }\n-        else if (name.equals(\"integers\")){    \n+        else if (name.equals(\"integers\")) {\n             // This will implicitly expand the collection        \n-            ((TestBean)parent).setIntegers(index, 0);\n+             ((TestBean) parent).setIntegers(index, 0);\n             return true;\n         }\n         return false;\n     /**\n      * Create a new object and set it on the specified variable\n      */\n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.5 2002/11/26 01:33:35 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/11/26 01:33:35 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/DOMModelTest.java,v 1.6 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests JXPath with DOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/11/26 01:33:35 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/20 00:00:29 $\n  */\n \n-public class DOMModelTest extends XMLModelTestCase\n-{\n+public class DOMModelTest extends XMLModelTestCase {\n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public DOMModelTest(String name){\n+    public DOMModelTest(String name) {\n         super(name);\n     }\n-    \n+\n     /**\n      * Return the tests included in this test suite.\n      */\n-    public static Test suite(){\n+    public static Test suite() {\n         return (new TestSuite(DOMModelTest.class));\n     }\n \n-    protected String getModel(){\n+    protected String getModel() {\n         return DocumentContainer.MODEL_DOM;\n     }\n-    \n-    protected AbstractFactory getAbstractFactory(){\n+\n+    protected AbstractFactory getAbstractFactory() {\n         return new TestDOMFactory();\n     }\n-    \n-    protected String getXMLSignature(Object node, \n-            boolean elements, boolean attributes, boolean text, boolean pi){\n+\n+    protected String getXMLSignature(\n+        Object node,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n+    {\n         StringBuffer buffer = new StringBuffer();\n         appendXMLSignature(buffer, node, elements, attributes, text, pi);\n         return buffer.toString();\n     }\n-    \n-    private void appendXMLSignature(StringBuffer buffer, Object object, \n-            boolean elements, boolean attributes, boolean text, boolean pi){\n-        Node node = (Node)object;\n+\n+    private void appendXMLSignature(\n+        StringBuffer buffer,\n+        Object object,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n+    {\n+        Node node = (Node) object;\n         int type = node.getNodeType();\n-        switch (type){\n-            case Node.DOCUMENT_NODE:\n+        switch (type) {\n+            case Node.DOCUMENT_NODE :\n                 buffer.append(\"<D>\");\n-                appendXMLSignature(buffer, node.getChildNodes(), \n-                        elements, attributes, text, pi);\n+                appendXMLSignature(\n+                    buffer,\n+                    node.getChildNodes(),\n+                    elements,\n+                    attributes,\n+                    text,\n+                    pi);\n                 buffer.append(\"</D\");\n                 break;\n-                \n-            case Node.ELEMENT_NODE:\n-                String tag = elements ? ((Element)node).getTagName() : \"E\";\n+\n+            case Node.ELEMENT_NODE :\n+                String tag = elements ? ((Element) node).getTagName() : \"E\";\n                 buffer.append(\"<\");\n                 buffer.append(tag);\n                 buffer.append(\">\");\n-                appendXMLSignature(buffer, node.getChildNodes(), \n-                        elements, attributes, text, pi);\n+                appendXMLSignature(\n+                    buffer,\n+                    node.getChildNodes(),\n+                    elements,\n+                    attributes,\n+                    text,\n+                    pi);\n                 buffer.append(\"</\");\n                 buffer.append(tag);\n-                buffer.append(\">\");                    \n+                buffer.append(\">\");\n                 break;\n-                \n-            case Node.TEXT_NODE:\n-            case Node.CDATA_SECTION_NODE:\n-                if (text){\n+\n+            case Node.TEXT_NODE :\n+            case Node.CDATA_SECTION_NODE :\n+                if (text) {\n                     String string = node.getNodeValue();\n                     string = string.replace('\\n', '=');\n                     buffer.append(string);\n                 break;\n         }\n     }\n-    \n-    private void appendXMLSignature(StringBuffer buffer, NodeList children, \n-            boolean elements, boolean attributes, boolean text, boolean pi)\n+\n+    private void appendXMLSignature(\n+        StringBuffer buffer,\n+        NodeList children,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n     {\n-        for (int i = 0; i < children.getLength(); i++){\n-            appendXMLSignature(buffer, children.item(i), \n-                    elements, attributes, text, pi);\n+        for (int i = 0; i < children.getLength(); i++) {\n+            appendXMLSignature(\n+                buffer,\n+                children.item(i),\n+                elements,\n+                attributes,\n+                text,\n+                pi);\n         }\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dom/TestDOMFactory.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n public class TestDOMFactory extends AbstractFactory {\n \n     /**\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-    public boolean createObject(JXPathContext context, \n-                Pointer pointer, Object parent, String name, int index)\n+    public boolean createObject(\n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n     {\n-        if (name.equals(\"location\") || \n-                name.equals(\"address\") || \n-                name.equals(\"street\")){\n-            addDOMElement((Node)parent, index, name);\n+        if (name.equals(\"location\")\n+            || name.equals(\"address\")\n+            || name.equals(\"street\")) {\n+            addDOMElement((Node) parent, index, name);\n             return true;\n         }\n         return false;\n     }\n \n-    private void addDOMElement(Node parent, int index, String tag){\n+    private void addDOMElement(Node parent, int index, String tag) {\n         Node child = parent.getFirstChild();\n         int count = 0;\n-        while (child != null){\n-            if (child.getNodeName().equals(tag)){\n+        while (child != null) {\n+            if (child.getNodeName().equals(tag)) {\n                 count++;\n             }\n             child = child.getNextSibling();\n         }\n \n         // Keep inserting new elements until we have index + 1 of them\n-        while (count <= index){\n+        while (count <= index) {\n             Node newElement = parent.getOwnerDocument().createElement(tag);\n             parent.appendChild(newElement);\n             count++;\n         }\n     }\n \n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/DynaBeanModelTest.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n package org.apache.commons.jxpath.ri.model.dynabeans;\n \n+import junit.framework.TestSuite;\n+\n import org.apache.commons.beanutils.WrapDynaBean;\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.TestBean;\n import org.apache.commons.jxpath.ri.model.BeanModelTestCase;\n \n-import junit.framework.*;\n-\n /**\n  * Test for support of DynaBeans (see BeanUtils)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n \n-public class DynaBeanModelTest extends BeanModelTestCase\n-{\n-    public DynaBeanModelTest(String name)\n-    {\n+public class DynaBeanModelTest extends BeanModelTestCase {\n+    public DynaBeanModelTest(String name) {\n         super(name);\n     }\n \n-    public static TestSuite suite(){\n-//        return (new TestSuite(BeanModelTest.class));\n-        TestSuite s = new TestSuite();\n-        s.addTest(new DynaBeanModelTest(\"testAxisParent\"));\n-        return s;\n+    public static TestSuite suite() {\n+        return new TestSuite(DynaBeanModelTest.class);\n+//        TestSuite s = new TestSuite();\n+//        s.addTest(new DynaBeanModelTest(\"testAxisParent\"));\n+//        return s;\n     }\n \n-    protected Object createContextBean(){\n+    protected Object createContextBean() {\n         return new WrapDynaBean(new TestBean());\n     }\n \n-    protected AbstractFactory getAbstractFactory(){\n+    protected AbstractFactory getAbstractFactory() {\n         return new TestDynaBeanFactory();\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.4 2003/01/11 05:41:27 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/01/11 05:41:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynabeans/TestDynaBeanFactory.java,v 1.5 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.model.dynabeans;\n \n import org.apache.commons.beanutils.DynaBean;\n-import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/01/11 05:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/01/20 00:00:29 $\n  */\n public class TestDynaBeanFactory extends AbstractFactory {\n \n     /**\n      */\n     public boolean createObject(\n-            JXPathContext context,\n-            Pointer pointer,\n-            Object parent,\n-            String name,\n-            int index) \n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n     {\n         if (name.equals(\"nestedBean\")) {\n             ((DynaBean) parent).set(\n         return false;\n     }\n \n-\n     /**\n      */\n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         context.getVariables().declareVariable(name, null);\n         return true;\n     }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java,v 1.1 2002/11/28 01:01:30 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/28 01:01:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * @todo more iterator testing with maps\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/11/28 01:01:30 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n \n-public class DynamicPropertiesModelTest extends JXPathTestCase\n-{\n+public class DynamicPropertiesModelTest extends JXPathTestCase {\n     private static boolean enabled = true;\n     private JXPathContext context;\n \n      *\n      * @param name Name of the test case\n      */\n-    public DynamicPropertiesModelTest(String name){\n+    public DynamicPropertiesModelTest(String name) {\n         super(name);\n     }\n \n-    public void setUp(){\n-        if (context == null){\n+    public void setUp() {\n+        if (context == null) {\n             context = JXPathContext.newContext(new TestBean());\n             context.setFactory(new TestDynamicPropertyFactory());\n         }\n     }\n \n-    public void testAxisChild(){\n-        assertXPathValue(context,\n-                \"map/Key1\",\n-                \"Value 1\");\n-\n-        assertXPathPointer(context,\n-                \"map/Key1\",\n-                \"/map[@name='Key1']\");\n-\n-        assertXPathValue(context,\n-                \"map/Key2/name\",\n-                \"Name 6\");\n-\n-        assertXPathPointer(context,\n-                \"map/Key2/name\",\n-                \"/map[@name='Key2']/name\");\n-    }\n-\n-    public void testAxisDescendant(){\n-        assertXPathValue(context,\n-                \"//Key1\",\n-                \"Value 1\");\n+    public void testAxisChild() {\n+        assertXPathValue(context, \"map/Key1\", \"Value 1\");\n+\n+        assertXPathPointer(context, \"map/Key1\", \"/map[@name='Key1']\");\n+\n+        assertXPathValue(context, \"map/Key2/name\", \"Name 6\");\n+\n+        assertXPathPointer(context, \"map/Key2/name\", \"/map[@name='Key2']/name\");\n+    }\n+\n+    public void testAxisDescendant() {\n+        assertXPathValue(context, \"//Key1\", \"Value 1\");\n     }\n \n     /**\n      * Testing the pseudo-attribute \"name\" that dynamic property\n      * objects appear to have.\n      */\n-    public void testAttributeName(){\n-        assertXPathValue(context,\n-                \"map[@name = 'Key1']\",\n-                \"Value 1\");\n-\n-        assertXPathPointer(context,\n-                \"map[@name = 'Key1']\",\n-                \"/map[@name='Key1']\");\n-\n-        assertXPathPointerLenient(context,\n-                \"map[@name = 'Key&quot;&apos;&quot;&apos;1']\",\n-                \"/map[@name='Key&quot;&apos;&quot;&apos;1']\");\n-\n-        assertXPathValue(context,\n-                \"/.[@name='map']/Key2/name\",\n-                \"Name 6\");\n-\n-        assertXPathPointer(context,\n-                \"/.[@name='map']/Key2/name\",\n-                \"/map[@name='Key2']/name\");\n+    public void testAttributeName() {\n+        assertXPathValue(context, \"map[@name = 'Key1']\", \"Value 1\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"map[@name = 'Key1']\",\n+            \"/map[@name='Key1']\");\n+\n+        assertXPathPointerLenient(\n+            context,\n+            \"map[@name = 'Key&quot;&apos;&quot;&apos;1']\",\n+            \"/map[@name='Key&quot;&apos;&quot;&apos;1']\");\n+\n+        assertXPathValue(context, \"/.[@name='map']/Key2/name\", \"Name 6\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"/.[@name='map']/Key2/name\",\n+            \"/map[@name='Key2']/name\");\n \n         // Bean in a map\n-        assertXPathValue(context,\n-                \"/map[@name='Key2'][@name='name']\",\n-                \"Name 6\");\n-\n-        assertXPathPointer(context,\n-                \"/map[@name='Key2'][@name='name']\",\n-                \"/map[@name='Key2']/name\");\n+        assertXPathValue(context, \"/map[@name='Key2'][@name='name']\", \"Name 6\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"/map[@name='Key2'][@name='name']\",\n+            \"/map[@name='Key2']/name\");\n \n         // Map in a bean in a map\n-        assertXPathValue(context,\n-                \"/.[@name='map'][@name='Key2'][@name='name']\",\n-                \"Name 6\");\n-\n-        assertXPathPointer(context,\n-                \"/.[@name='map'][@name='Key2'][@name='name']\",\n-                \"/map[@name='Key2']/name\");\n-    }\n-    \n-    public void testSetPrimitiveValue(){\n-        assertXPathSetValue(context, \n-                \"map/Key1\",\n-                new Integer(6));\n-    }\n-    \n-    public void testSetCollection(){\n+        assertXPathValue(\n+            context,\n+            \"/.[@name='map'][@name='Key2'][@name='name']\",\n+            \"Name 6\");\n+\n+        assertXPathPointer(\n+            context,\n+            \"/.[@name='map'][@name='Key2'][@name='name']\",\n+            \"/map[@name='Key2']/name\");\n+    }\n+\n+    public void testSetPrimitiveValue() {\n+        assertXPathSetValue(context, \"map/Key1\", new Integer(6));\n+    }\n+\n+    public void testSetCollection() {\n         // See if we can assign a whole collection        \n         context.setValue(\n-                \"map/Key1\", \n-                new Integer[]{new Integer(7), new Integer(8)});\n-        \n+            \"map/Key1\",\n+            new Integer[] { new Integer(7), new Integer(8)});\n+\n         // And then an element in that collection\n-        assertXPathSetValue(context,\n-                \"map/Key1[1]\", \n-                new Integer(9));\n-    }\n-    \n-    public void testSetNewKey(){\n-        assertXPathSetValue(context,\n-                \"map/Key4\", \n-                new Integer(7));\n-    }\n-    \n-    public void testCreatePath(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathSetValue(context, \"map/Key1[1]\", new Integer(9));\n+    }\n+\n+    public void testSetNewKey() {\n+        assertXPathSetValue(context, \"map/Key4\", new Integer(7));\n+    }\n+\n+    public void testCreatePath() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // sets the value\n-        assertXPathCreatePath(context, \n-                \"/map[@name='TestKey1']\", \n-                \"\", \n-                \"/map[@name='TestKey1']\");\n-    }\n-    \n-    public void testCreatePathAndSetValue(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathCreatePath(\n+            context,\n+            \"/map[@name='TestKey1']\",\n+            \"\",\n+            \"/map[@name='TestKey1']\");\n+    }\n+\n+    public void testCreatePathAndSetValue() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // sets the value\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map[@name='TestKey1']\", \n-                \"Test\", \n-                \"/map[@name='TestKey1']\");\n-    }\n-    \n-    public void testCreatePathCreateBean(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map[@name='TestKey1']\",\n+            \"Test\",\n+            \"/map[@name='TestKey1']\");\n+    }\n+\n+    public void testCreatePathCreateBean() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // then factory.createObject(..., map, \"TestKey2\"), then\n         // sets the value\n-        assertXPathCreatePath(context, \n-                \"/map[@name='TestKey2']/int\", \n-                new Integer(1),\n-                \"/map[@name='TestKey2']/int\");\n-    }\n-    \n-    public void testCreatePathAndSetValueCreateBean(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathCreatePath(\n+            context,\n+            \"/map[@name='TestKey2']/int\",\n+            new Integer(1),\n+            \"/map[@name='TestKey2']/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueCreateBean() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Calls factory.createObject(..., testBean, \"map\"), then\n         // then factory.createObject(..., map, \"TestKey2\"), then\n         // sets the value\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map[@name='TestKey2']/int\", \n-                new Integer(4),\n-                \"/map[@name='TestKey2']/int\");\n-    }\n-    \n-    public void testCreatePathCollectionElement(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n-\n-        assertXPathCreatePath(context, \n-                \"/map/TestKey3[2]\", \n-                null,\n-                \"/map[@name='TestKey3'][2]\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map[@name='TestKey2']/int\",\n+            new Integer(4),\n+            \"/map[@name='TestKey2']/int\");\n+    }\n+\n+    public void testCreatePathCollectionElement() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n+        assertXPathCreatePath(\n+            context,\n+            \"/map/TestKey3[2]\",\n+            null,\n+            \"/map[@name='TestKey3'][2]\");\n \n         // Should be the same as the one before\n-        assertXPathCreatePath(context, \n-                \"/map[@name='TestKey3'][3]\", \n-                null,\n-                \"/map[@name='TestKey3'][3]\");\n-    }\n-    \n-    public void testCreatePathAndSetValueCollectionElement(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n-\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map/TestKey3[2]\", \n-                \"Test1\",\n-                \"/map[@name='TestKey3'][2]\");\n+        assertXPathCreatePath(\n+            context,\n+            \"/map[@name='TestKey3'][3]\",\n+            null,\n+            \"/map[@name='TestKey3'][3]\");\n+    }\n+\n+    public void testCreatePathAndSetValueCollectionElement() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map/TestKey3[2]\",\n+            \"Test1\",\n+            \"/map[@name='TestKey3'][2]\");\n \n         // Should be the same as the one before\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map[@name='TestKey3'][3]\", \n-                \"Test2\",\n-                \"/map[@name='TestKey3'][3]\");\n-    }\n-    \n-    public void testCreatePathNewCollectionElement(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map[@name='TestKey3'][3]\",\n+            \"Test2\",\n+            \"/map[@name='TestKey3'][3]\");\n+    }\n+\n+    public void testCreatePathNewCollectionElement() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Create an element of a dynamic map element, which is a collection\n-        assertXPathCreatePath(context, \n-                \"/map/TestKey4[1]/int\", \n-                new Integer(1),\n-                \"/map[@name='TestKey4'][1]/int\");\n+        assertXPathCreatePath(\n+            context,\n+            \"/map/TestKey4[1]/int\",\n+            new Integer(1),\n+            \"/map[@name='TestKey4'][1]/int\");\n \n         bean.getMap().remove(\"TestKey4\");\n \n         // Should be the same as the one before\n-        assertXPathCreatePath(context, \n-                \"/map/TestKey4[1]/int\", \n-                new Integer(1),\n-                \"/map[@name='TestKey4'][1]/int\");\n-    }\n-    \n-    public void testCreatePathAndSetValueNewCollectionElement(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-        bean.setMap(null);\n-        \n+        assertXPathCreatePath(\n+            context,\n+            \"/map/TestKey4[1]/int\",\n+            new Integer(1),\n+            \"/map[@name='TestKey4'][1]/int\");\n+    }\n+\n+    public void testCreatePathAndSetValueNewCollectionElement() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+        bean.setMap(null);\n+\n         // Create an element of a dynamic map element, which is a collection\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map/TestKey4[1]/int\", \n-                new Integer(2),\n-                \"/map[@name='TestKey4'][1]/int\");\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map/TestKey4[1]/int\",\n+            new Integer(2),\n+            \"/map[@name='TestKey4'][1]/int\");\n \n         bean.getMap().remove(\"TestKey4\");\n \n         // Should be the same as the one before\n-        assertXPathCreatePathAndSetValue(context, \n-                \"/map/TestKey4[1]/int\", \n-                new Integer(3),\n-                \"/map[@name='TestKey4'][1]/int\");\n-    }\n-    \n-    public void testRemovePath(){\n-        TestBean bean = (TestBean)context.getContextBean();\n+        assertXPathCreatePathAndSetValue(\n+            context,\n+            \"/map/TestKey4[1]/int\",\n+            new Integer(3),\n+            \"/map[@name='TestKey4'][1]/int\");\n+    }\n+\n+    public void testRemovePath() {\n+        TestBean bean = (TestBean) context.getContextBean();\n         bean.getMap().put(\"TestKey1\", \"test\");\n \n         // Remove dynamic property\n         context.removePath(\"map[@name = 'TestKey1']\");\n-        assertEquals(\"Remove dynamic property value\", null,\n-                    context.getValue(\"map[@name = 'TestKey1']\"));\n-    }\n-    \n-    public void testRemovePathArrayElement(){\n-        TestBean bean = (TestBean)context.getContextBean();\n-\n-        bean.getMap().put(\"TestKey2\", new String[]{\"temp1\", \"temp2\"});\n+        assertEquals(\n+            \"Remove dynamic property value\",\n+            null,\n+            context.getValue(\"map[@name = 'TestKey1']\"));\n+    }\n+\n+    public void testRemovePathArrayElement() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+\n+        bean.getMap().put(\"TestKey2\", new String[] { \"temp1\", \"temp2\" });\n         context.removePath(\"map[@name = 'TestKey2'][1]\");\n-        assertEquals(\"Remove dynamic property collection element\", \"temp2\",\n-                    context.getValue(\"map[@name = 'TestKey2'][1]\"));\n+        assertEquals(\n+            \"Remove dynamic property collection element\",\n+            \"temp2\",\n+            context.getValue(\"map[@name = 'TestKey2'][1]\"));\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynamic/TestDynamicPropertyFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynamic/TestDynamicPropertyFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/TestDynamicPropertyFactory.java,v 1.1 2002/11/28 01:02:05 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/28 01:02:05 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/TestDynamicPropertyFactory.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.Map;\n import java.util.Vector;\n \n-import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.AbstractFactory;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.NestedTestBean;\n+import org.apache.commons.jxpath.Pointer;\n+import org.apache.commons.jxpath.TestBean;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/11/28 01:02:05 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n public class TestDynamicPropertyFactory extends AbstractFactory {\n \n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n     public boolean createObject(\n-            JXPathContext context,\n-            Pointer pointer,\n-            Object parent,\n-            String name,\n-            int index) \n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n     {\n         if (name.equals(\"map\")) {\n             ((TestBean) parent).setMap(new HashMap());\n             return true;\n-        } else if (name.equals(\"TestKey1\")) {\n+        }\n+        else if (name.equals(\"TestKey1\")) {\n             ((Map) parent).put(name, \"\");\n             return true;\n-        } else if (name.equals(\"TestKey2\")) {\n+        }\n+        else if (name.equals(\"TestKey2\")) {\n             ((Map) parent).put(name, new NestedTestBean(\"newName\"));\n             return true;\n-        } else if (name.equals(\"TestKey3\")) {\n+        }\n+        else if (name.equals(\"TestKey3\")) {\n             Vector v = new Vector();\n             for (int i = 0; i <= index; i++) {\n                 v.add(null);\n             }\n             ((Map) parent).put(name, v);\n             return true;\n-        } else if (name.equals(\"TestKey4\")) {\n+        }\n+        else if (name.equals(\"TestKey4\")) {\n             ((Map) parent).put(name, new Object[] { new TestBean()});\n             return true;\n         }\n         return false;\n     }\n \n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.5 2002/11/26 01:33:35 dmitri Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/11/26 01:33:35 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/JDOMModelTest.java,v 1.6 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.AbstractFactory;\n import org.apache.commons.jxpath.ri.model.XMLModelTestCase;\n import org.apache.commons.jxpath.xml.DocumentContainer;\n-import org.jdom.*;\n+import org.jdom.CDATA;\n+import org.jdom.Document;\n+import org.jdom.Element;\n+import org.jdom.Text;\n \n /**\n  * Tests JXPath with JDOM\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.5 $ $Date: 2002/11/26 01:33:35 $\n+ * @version $Revision: 1.6 $ $Date: 2003/01/20 00:00:29 $\n  */\n \n-public class JDOMModelTest extends XMLModelTestCase\n-{\n+public class JDOMModelTest extends XMLModelTestCase {\n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public JDOMModelTest(String name){\n+    public JDOMModelTest(String name) {\n         super(name);\n     }\n \n     /**\n      * Return the tests included in this test suite.\n      */\n-    public static Test suite(){\n+    public static Test suite() {\n         return (new TestSuite(JDOMModelTest.class));\n     }\n \n-    protected String getModel(){\n+    protected String getModel() {\n         return DocumentContainer.MODEL_JDOM;\n     }\n \n-    public void testID(){\n+    public void testID() {\n         // id() is not supported by JDOM\n     }\n \n-    protected AbstractFactory getAbstractFactory(){\n+    protected AbstractFactory getAbstractFactory() {\n         return new TestJDOMFactory();\n     }\n-    \n-    protected String getXMLSignature(Object node, \n-            boolean elements, boolean attributes, boolean text, boolean pi){\n+\n+    protected String getXMLSignature(\n+        Object node,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n+    {\n         StringBuffer buffer = new StringBuffer();\n         appendXMLSignature(buffer, node, elements, attributes, text, pi);\n         return buffer.toString();\n     }\n-    \n-    private void appendXMLSignature(StringBuffer buffer, Object object, \n-            boolean elements, boolean attributes, boolean text, boolean pi){\n-        if (object instanceof Document){\n+\n+    private void appendXMLSignature(\n+        StringBuffer buffer,\n+        Object object,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n+    {\n+        if (object instanceof Document) {\n             buffer.append(\"<D>\");\n-            appendXMLSignature(buffer, ((Document)object).getContent(), \n-                    elements, attributes, text, pi);\n+            appendXMLSignature(\n+                buffer,\n+                ((Document) object).getContent(),\n+                elements,\n+                attributes,\n+                text,\n+                pi);\n             buffer.append(\"</D\");\n         }\n-        else if (object instanceof Element){\n-            String tag = elements ? ((Element)object).getName() : \"E\";\n+        else if (object instanceof Element) {\n+            String tag = elements ? ((Element) object).getName() : \"E\";\n             buffer.append(\"<\");\n             buffer.append(tag);\n             buffer.append(\">\");\n-            appendXMLSignature(buffer, ((Element)object).getContent(), \n-                    elements, attributes, text, pi);\n+            appendXMLSignature(\n+                buffer,\n+                ((Element) object).getContent(),\n+                elements,\n+                attributes,\n+                text,\n+                pi);\n             buffer.append(\"</\");\n             buffer.append(tag);\n-            buffer.append(\">\");                 \n+            buffer.append(\">\");\n         }\n-        else if (object instanceof Text || object instanceof CDATA){\n-            if (text){\n-                String string = ((Text)object).getText();\n+        else if (object instanceof Text || object instanceof CDATA) {\n+            if (text) {\n+                String string = ((Text) object).getText();\n                 string = string.replace('\\n', '=');\n                 buffer.append(string);\n             }\n         }\n     }\n-    \n-    private void appendXMLSignature(StringBuffer buffer, List children, \n-            boolean elements, boolean attributes, boolean text, boolean pi)\n+\n+    private void appendXMLSignature(\n+        StringBuffer buffer,\n+        List children,\n+        boolean elements,\n+        boolean attributes,\n+        boolean text,\n+        boolean pi) \n     {\n-        for (int i = 0; i < children.size(); i++){\n-            appendXMLSignature(buffer, children.get(i), \n-                    elements, attributes, text, pi);\n+        for (int i = 0; i < children.size(); i++) {\n+            appendXMLSignature(\n+                buffer,\n+                children.get(i),\n+                elements,\n+                attributes,\n+                text,\n+                pi);\n         }\n-    }  \n+    }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java,v 1.1 2002/10/20 03:48:22 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:22 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/jdom/TestJDOMFactory.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n public class TestJDOMFactory extends AbstractFactory {\n \n      * Create a new instance and put it in the collection on the parent object.\n      * Return <b>false</b> if this factory cannot create the requested object.\n      */\n-    public boolean createObject(JXPathContext context, \n-                Pointer pointer, Object parent, String name, int index)\n+    public boolean createObject(\n+        JXPathContext context,\n+        Pointer pointer,\n+        Object parent,\n+        String name,\n+        int index) \n     {\n-        if (name.equals(\"location\") || \n-                name.equals(\"address\") || name.equals(\"street\")){\n-            addJDOMElement((Element)parent, index, name);\n+        if (name.equals(\"location\")\n+            || name.equals(\"address\")\n+            || name.equals(\"street\")) {\n+            addJDOMElement((Element) parent, index, name);\n             return true;\n         }\n         return false;\n     }\n \n-    private void addJDOMElement(Element parent, int index, String tag){\n+    private void addJDOMElement(Element parent, int index, String tag) {\n         List children = parent.getContent();\n         int count = 0;\n-        for (int i = 0; i < children.size(); i++){\n+        for (int i = 0; i < children.size(); i++) {\n             Object child = children.get(i);\n-            if (child instanceof Element &&\n-                    ((Element)child).getQualifiedName().equals(tag)){\n+            if (child instanceof Element\n+                && ((Element) child).getQualifiedName().equals(tag)) {\n                 count++;\n             }\n         }\n \n         // Keep inserting new elements until we have index + 1 of them\n-        while (count <= index){\n+        while (count <= index) {\n             // In a real factory we would need to do the right thing with\n             // the namespace prefix.\n             Element newElement = new Element(tag);\n         }\n     }\n \n-    public boolean declareVariable(JXPathContext context, String name){\n+    public boolean declareVariable(JXPathContext context, String name) {\n         return false;\n     }\n }\n--- a/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java\n+++ b/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java,v 1.1 2002/10/20 03:48:23 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/10/20 03:48:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/util/BasicTypeConverterTest.java,v 1.2 2003/01/20 00:00:29 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/20 00:00:29 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * Tests BasicTypeConverter\n  * \n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/10/20 03:48:23 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/20 00:00:29 $\n  */\n \n-public class BasicTypeConverterTest extends TestCase\n-{\n+public class BasicTypeConverterTest extends TestCase {\n     /**\n      * Construct a new instance of this test case.\n      *\n      * @param name Name of the test case\n      */\n-    public BasicTypeConverterTest(String name)\n-    {\n+    public BasicTypeConverterTest(String name) {\n         super(name);\n     }\n-    \n-    public void testPrimitiveToString(){\n+\n+    public void testPrimitiveToString() {\n+        assertConversion(new Integer(1), String.class, \"1\");\n+    }\n+\n+    public void testArrayToList() {\n         assertConversion(\n-                new Integer(1), \n-                String.class, \n-                \"1\");\n+            new int[] { 1, 2 },\n+            List.class,\n+            Arrays.asList(new Object[] { new Integer(1), new Integer(2)}));\n     }\n-    \n-    public void testArrayToList(){\n+\n+    public void testArrayToArray() {\n         assertConversion(\n-                new int[]{1, 2}, \n-                List.class,\n-                Arrays.asList(new Object[]{new Integer(1), new Integer(2)}));\n+            new int[] { 1, 2 },\n+            String[].class,\n+            Arrays.asList(new String[] { \"1\", \"2\" }));\n     }\n-    \n-    public void testArrayToArray(){\n+\n+    public void testListToArray() {\n         assertConversion(\n-                new int[]{1, 2}, \n-                String[].class,\n-                Arrays.asList(new String[]{\"1\", \"2\"}));\n+            Arrays.asList(new Integer[] { new Integer(1), new Integer(2)}),\n+            String[].class,\n+            Arrays.asList(new String[] { \"1\", \"2\" }));\n+\n+        assertConversion(\n+            Arrays.asList(new String[] { \"1\", \"2\" }),\n+            int[].class,\n+            Arrays.asList(new Integer[] { new Integer(1), new Integer(2)}));\n     }\n-    \n-    public void testListToArray(){\n-        assertConversion(\n-                Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}),\n-                String[].class,\n-                Arrays.asList(new String[]{\"1\", \"2\"}));\n-                \n-        assertConversion(\n-                Arrays.asList(new String[]{\"1\", \"2\"}),\n-                int[].class,\n-                Arrays.asList(new Integer[]{new Integer(1), new Integer(2)}));\n-    }\n-    \n-    public void testInvalidConversion(){\n+\n+    public void testInvalidConversion() {\n         boolean exception = false;\n         try {\n-            TypeUtils.convert(\n-                    \"'foo'\",\n-                    Date.class);\n+            TypeUtils.convert(\"'foo'\", Date.class);\n         }\n-        catch (Throwable ex){\n+        catch (Throwable ex) {\n             exception = true;\n         }\n         assertTrue(\"Type conversion exception\", exception);\n     }\n-    \n+\n     public void assertConversion(Object from, Class toType, Object expected) {\n         boolean can = TypeUtils.canConvert(from, toType);\n-        assertTrue(\"Can convert: \" + from.getClass() + \n-                \" to \" + toType, can);\n+        assertTrue(\"Can convert: \" + from.getClass() + \" to \" + toType, can);\n         Object result = TypeUtils.convert(from, toType);\n-        if (result.getClass().isArray()){\n+        if (result.getClass().isArray()) {\n             ArrayList list = new ArrayList();\n-            for (int j = 0; j < Array.getLength(result); j++){\n+            for (int j = 0; j < Array.getLength(result); j++) {\n                 list.add(Array.get(result, j));\n             }\n             result = list;\n         }\n-        assertEquals(\"Convert: \" + from.getClass() + \n-                \" to \" + toType, expected, result);\n+        assertEquals(\n+            \"Convert: \" + from.getClass() + \" to \" + toType,\n+            expected,\n+            result);\n     }\n }", "timestamp": 1043020829, "metainfo": ""}