{"sha": "26ed002f4905b94a6a4275f9ad263cb8a2cadf00", "log": "Fixed an issue with searches in graphs containing DynamicPropertyHandlers   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SimplePathInterpreter.java\n      * a) represents the requested path and\n      * b) can be used for creation of missing nodes in the path.\n      */\n-    private static NodePointer createNullPointer(\n+    public static NodePointer createNullPointer(\n             EvalContext context, NodePointer parent, Step[] steps,\n             int currentStep)\n     {\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/Path.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.10 2003/10/09 21:31:39 rdonkin Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/10/09 21:31:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/Path.java,v 1.11 2004/01/23 01:10:20 dmitri Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2004/01/23 01:10:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.axes.AttributeContext;\n import org.apache.commons.jxpath.ri.axes.ChildContext;\n import org.apache.commons.jxpath.ri.axes.DescendantContext;\n+import org.apache.commons.jxpath.ri.axes.InitialContext;\n import org.apache.commons.jxpath.ri.axes.NamespaceContext;\n import org.apache.commons.jxpath.ri.axes.ParentContext;\n import org.apache.commons.jxpath.ri.axes.PrecedingOrFollowingContext;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.10 $ $Date: 2003/10/09 21:31:39 $\n+ * @version $Revision: 1.11 $ $Date: 2004/01/23 01:10:20 $\n  */\n public abstract class Path extends Expression {\n \n             basic = true;\n             Step[] steps = getSteps();\n             for (int i = 0; i < steps.length; i++) {\n-                boolean accepted = false;\n-                if (steps[i].getAxis() == Compiler.AXIS_SELF\n-                    && (steps[i].getNodeTest() instanceof NodeTypeTest)\n-                    && ((NodeTypeTest) steps[i].getNodeTest()).getNodeType()\n-                        == Compiler.NODE_TYPE_NODE) {\n-                    accepted = true;\n-                }\n-                else if (\n-                    (steps[i].getAxis() == Compiler.AXIS_CHILD\n-                        || steps[i].getAxis() == Compiler.AXIS_ATTRIBUTE)\n-                        && (steps[i].getNodeTest() instanceof NodeNameTest)\n-                        && !((NodeNameTest) steps[i].getNodeTest())\n-                            .getNodeName()\n-                            .getName()\n-                            .equals(\n-                            \"*\")) {\n-                    accepted = true;\n-                }\n-                if (accepted) {\n-                    accepted = areBasicPredicates(steps[i].getPredicates());\n-                }\n-                if (!accepted) {\n+                if (!isSimpleStep(steps[i])){\n                     basic = false;\n                     break;\n                 }\n             }\n         }\n         return basic;\n+    }\n+\n+    /**\n+     * A Step is \"simple\" if it takes one of these forms: \".\", \"/foo\",\n+     * \"@bar\", \"/foo[3]\". If there are predicates, they should be \n+     * context independent for the step to still be considered simple.\n+     */\n+    protected boolean isSimpleStep(Step step) {\n+        if (step.getAxis() == Compiler.AXIS_SELF) {\n+            NodeTest nodeTest = step.getNodeTest();\n+            if (!(nodeTest instanceof NodeTypeTest)) {\n+                return false;\n+            }\n+            int nodeType = ((NodeTypeTest) nodeTest).getNodeType();\n+            if (nodeType != Compiler.NODE_TYPE_NODE) {\n+                return false;\n+            }\n+            return areBasicPredicates(step.getPredicates());\n+        }\n+        else if (step.getAxis() == Compiler.AXIS_CHILD\n+                || step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n+            NodeTest nodeTest = step.getNodeTest();\n+            if (!(nodeTest instanceof NodeNameTest)){\n+                return false;\n+            }\n+            \n+            String name = ((NodeNameTest) nodeTest).getNodeName().getName();\n+            if (name.equals(\"*\")) {\n+                return false;\n+            }\n+            return areBasicPredicates(step.getPredicates());\n+        }\n+        return false;\n     }\n \n     protected boolean areBasicPredicates(Expression predicates[]) {\n         }\n     }\n \n+    /**\n+     * The idea here is to return a NullPointer rather than null if that's at\n+     * all possible. Take for example this path: \"//map/key\". Let's say, \"map\"\n+     * is an existing node, but \"key\" is not there. We will create a\n+     * NullPointer that can be used to set/create the \"key\" property.\n+     * <p>\n+     * However, a path like \"//key\" would still produce null, because we have\n+     * no way of knowing where \"key\" would be if it existed.\n+     * </p>\n+     * <p>\n+     * To accomplish this, we first try the path itself. If it does not find\n+     * anything, we chop off last step of the path, as long as it is a simple\n+     * one like child:: or attribute:: and try to evaluate the truncated path.\n+     * If it finds exactly one node - create a NullPointer and return. If it\n+     * fails, chop off another step and repeat. If it finds more than one\n+     * location - return null.\n+     * </p>\n+     */\n     private Pointer searchForPath(EvalContext context) {\n-        for (int i = 0; i < steps.length; i++) {\n+        EvalContext ctx = buildContextChain(context, steps.length, true);\n+        Pointer pointer = ctx.getSingleNodePointer();\n+        \n+        if (pointer != null) {\n+            return pointer;\n+        }\n+        \n+        for (int i = steps.length; --i > 0;) {\n+            if (!isSimpleStep(steps[i])) {\n+                return null;\n+            }\n+            ctx = buildContextChain(context, i, true);\n+            if (ctx.hasNext()) {\n+                Pointer partial = (Pointer) ctx.next();\n+                if (ctx.hasNext()) {\n+                    // If we find another location - the search is\n+                    // ambiguous, so we report failure\n+                    return null;\n+                }\n+                if (partial instanceof NodePointer) {\n+                    return SimplePathInterpreter.createNullPointer(\n+                            context,\n+                            (NodePointer) partial,\n+                            steps,\n+                            i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given a root context, walks a path therefrom and builds a context\n+     * that contains all nodes matching the path.\n+     */\n+    protected EvalContext evalSteps(EvalContext context) {\n+        return buildContextChain(context, steps.length, false);\n+    }\n+\n+    private EvalContext buildContextChain(\n+            EvalContext context,\n+            int stepCount,\n+            boolean createInitialContext) \n+    {\n+        if (createInitialContext) {\n+            context = new InitialContext(context);\n+        }\n+        if (steps.length == 0) {\n+            return context;\n+        }\n+        for (int i = 0; i < stepCount; i++) {\n             context =\n                 createContextForStep(\n                     context,\n                 }\n             }\n         }\n-\n-        return context.getSingleNodePointer();\n-    }\n-\n-    /**\n-     * Given a root context, walks a path therefrom and builds a context\n-     * that contains all nodes matching the path.\n-     */\n-    protected EvalContext evalSteps(EvalContext context) {\n-        if (steps.length == 0) {\n-            return context;\n-        }\n-\n-        for (int i = 0; i < steps.length; i++) {\n-            context =\n-                createContextForStep(\n-                    context,\n-                    steps[i].getAxis(),\n-                    steps[i].getNodeTest());\n-            Expression predicates[] = steps[i].getPredicates();\n-            if (predicates != null) {\n-                for (int j = 0; j < predicates.length; j++) {\n-                    context = new PredicateContext(context, predicates[j]);\n-                }\n-            }\n-        }\n-\n         return context;\n     }\n-\n+    \n     /**\n      * Different axes are serviced by different contexts. This method\n      * allocates the right context for the supplied step.\n         NodeTest nodeTest) \n     {\n         switch (axis) {\n-            case Compiler.AXIS_ANCESTOR :\n-                return new AncestorContext(context, false, nodeTest);\n-            case Compiler.AXIS_ANCESTOR_OR_SELF :\n-                return new AncestorContext(context, true, nodeTest);\n-            case Compiler.AXIS_ATTRIBUTE :\n-                return new AttributeContext(context, nodeTest);\n-            case Compiler.AXIS_CHILD :\n-                return new ChildContext(context, nodeTest, false, false);\n-            case Compiler.AXIS_DESCENDANT :\n-                return new DescendantContext(context, false, nodeTest);\n-            case Compiler.AXIS_DESCENDANT_OR_SELF :\n-                return new DescendantContext(context, true, nodeTest);\n-            case Compiler.AXIS_FOLLOWING :\n-                return new PrecedingOrFollowingContext(\n-                    context,\n-                    nodeTest,\n-                    false);\n-            case Compiler.AXIS_FOLLOWING_SIBLING :\n-                return new ChildContext(context, nodeTest, true, false);\n-            case Compiler.AXIS_NAMESPACE :\n-                return new NamespaceContext(context, nodeTest);\n-            case Compiler.AXIS_PARENT :\n-                return new ParentContext(context, nodeTest);\n-            case Compiler.AXIS_PRECEDING :\n-                return new PrecedingOrFollowingContext(context, nodeTest, true);\n-            case Compiler.AXIS_PRECEDING_SIBLING :\n-                return new ChildContext(context, nodeTest, true, true);\n-            case Compiler.AXIS_SELF :\n-                return new SelfContext(context, nodeTest);\n+        case Compiler.AXIS_ANCESTOR :\n+            return new AncestorContext(context, false, nodeTest);\n+        case Compiler.AXIS_ANCESTOR_OR_SELF :\n+            return new AncestorContext(context, true, nodeTest);\n+        case Compiler.AXIS_ATTRIBUTE :\n+            return new AttributeContext(context, nodeTest);\n+        case Compiler.AXIS_CHILD :\n+            return new ChildContext(context, nodeTest, false, false);\n+        case Compiler.AXIS_DESCENDANT :\n+            return new DescendantContext(context, false, nodeTest);\n+        case Compiler.AXIS_DESCENDANT_OR_SELF :\n+            return new DescendantContext(context, true, nodeTest);\n+        case Compiler.AXIS_FOLLOWING :\n+            return new PrecedingOrFollowingContext(context, nodeTest, false);\n+        case Compiler.AXIS_FOLLOWING_SIBLING :\n+            return new ChildContext(context, nodeTest, true, false);\n+        case Compiler.AXIS_NAMESPACE :\n+            return new NamespaceContext(context, nodeTest);\n+        case Compiler.AXIS_PARENT :\n+            return new ParentContext(context, nodeTest);\n+        case Compiler.AXIS_PRECEDING :\n+            return new PrecedingOrFollowingContext(context, nodeTest, true);\n+        case Compiler.AXIS_PRECEDING_SIBLING :\n+            return new ChildContext(context, nodeTest, true, true);\n+        case Compiler.AXIS_SELF :\n+            return new SelfContext(context, nodeTest);\n         }\n         return null; // Never happens\n     }\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.14 2003/10/09 21:31:40 rdonkin Exp $\n- * $Revision: 1.14 $\n- * $Date: 2003/10/09 21:31:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.15 2004/01/23 01:10:21 dmitri Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2004/01/23 01:10:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.14 $ $Date: 2003/10/09 21:31:40 $\n+ * @version $Revision: 1.15 $ $Date: 2004/01/23 01:10:21 $\n  */\n public class NullPropertyPointer extends PropertyPointer {\n \n                 \"Cannot set property \"\n                     + asPath()\n                     + \", the target object is null\");\n+        }\n+        else if (parent instanceof PropertyOwnerPointer &&\n+                ((PropertyOwnerPointer) parent).\n+                    isDynamicPropertyDeclarationSupported()){\n+            // If the parent property owner can create\n+            // a property automatically - let it do so\n+            PropertyPointer propertyPointer =\n+                ((PropertyOwnerPointer) parent).getPropertyPointer();\n+            propertyPointer.setPropertyName(propertyName);\n+            propertyPointer.setValue(value);\n         }\n         else {\n             throw new JXPathException(\n--- a/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.15 2003/10/09 21:31:40 rdonkin Exp $\n- * $Revision: 1.15 $\n- * $Date: 2003/10/09 21:31:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.16 2004/01/23 01:10:21 dmitri Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2004/01/23 01:10:21 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * a collection.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.15 $ $Date: 2003/10/09 21:31:40 $\n+ * @version $Revision: 1.16 $ $Date: 2004/01/23 01:10:21 $\n  */\n public abstract class PropertyOwnerPointer extends NodePointer {\n \n     }\n \n     public abstract PropertyPointer getPropertyPointer();\n+    \n+    /**\n+     * @return true if the property owner can set a property \"does not exist\".\n+     *         A good example is a Map. You can always assign a value to any\n+     *         key even if it has never been \"declared\".\n+     */\n+    public boolean isDynamicPropertyDeclarationSupported() {\n+        return false;\n+    }\n \n     public int compareChildNodePointers(\n         NodePointer pointer1,\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java,v 1.4 2003/10/09 21:31:41 rdonkin Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/10/09 21:31:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPointer.java,v 1.5 2004/01/23 01:10:20 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2004/01/23 01:10:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.QName;\n import org.apache.commons.jxpath.ri.model.NodeIterator;\n import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.PropertyIterator;\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n import org.apache.commons.jxpath.ri.model.beans.PropertyPointer;\n \n  * PropertyPointer.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2003/10/09 21:31:41 $\n+ * @version $Revision: 1.5 $ $Date: 2004/01/23 01:10:20 $\n  */\n public class DynamicPointer extends PropertyOwnerPointer {\n     private QName name;\n     public NodeIterator createNodeIterator(\n                 String property, boolean reverse, NodePointer startWith)\n     {\n-        return new DynamicPropertyIterator(this, property, reverse, startWith);\n+        return new PropertyIterator(this, property, reverse, startWith);\n     }\n \n     public NodeIterator attributeIterator(QName name) {\n     public QName getName() {\n         return name;\n     }\n-\n+    \n+    public boolean isDynamicPropertyDeclarationSupported() {\n+        return true;\n+    }\n+    \n     /**\n      * Returns the DP object iself.\n      */\n--- a/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertyIterator.java\n import org.apache.commons.jxpath.ri.model.beans.PropertyOwnerPointer;\n \n /**\n- * <code>DynamicPropertyIterator</code> is different from a regular\n- * <code>PropertyIterator</code> in that given a property name it\n- * will always find that property (albeit with a null value).\n+ * @deprecated - no longer needed, as it is identical to PropertyIterator.\n  * \n  * @author <a href=\"mailto:dmitri@apache.org\">Dmitri Plotnikov</a>\n- * @version $Id: DynamicPropertyIterator.java,v 1.3 2003/10/09 21:31:41 rdonkin Exp $\n+ * @version $Id: DynamicPropertyIterator.java,v 1.4 2004/01/23 01:10:20 dmitri Exp $\n  */\n public class DynamicPropertyIterator extends PropertyIterator {\n \n     {\n         super(pointer, name, reverse, startWith);\n     }\n-\n-    protected void prepareForIndividualProperty(String name) {\n-        ((DynamicPropertyPointer) getPropertyPointer()).setPropertyName(name);\n-        super.prepareForIndividualProperty(name);\n-   }\n }\n--- a/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n+++ b/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java,v 1.6 2003/10/09 21:31:44 rdonkin Exp $\n- * $Revision: 1.6 $\n- * $Date: 2003/10/09 21:31:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/ri/model/dynamic/DynamicPropertiesModelTest.java,v 1.7 2004/01/23 01:10:20 dmitri Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2004/01/23 01:10:20 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * @todo more iterator testing with maps\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.6 $ $Date: 2003/10/09 21:31:44 $\n+ * @version $Revision: 1.7 $ $Date: 2004/01/23 01:10:20 $\n  */\n \n public class DynamicPropertiesModelTest extends JXPathTestCase {\n         assertXPathSetValue(context, \"map/Key1[1]\", new Integer(9));\n     }\n \n+    /**\n+     * The key does not exist, but the assignment should succeed anyway,\n+     * because you should always be able to store anything in a Map.\n+     */\n     public void testSetNewKey() {\n+        // Using a \"simple\" path\n         assertXPathSetValue(context, \"map/Key4\", new Integer(7));\n+        \n+        // Using a \"non-simple\" path\n+        assertXPathPointerLenient(context, \"//map/Key5\", \"/map/Key5\");\n+        \n+        assertXPathSetValue(context, \"//map/Key5\", new Integer(8));\n     }\n \n     public void testCreatePath() {\n         assertXPathValueIterator(\n             context,\n             \"/map/stuff[@name='fruit']\",\n-            list(\"apple\", \"banana\"));\n+            list(\"apple\", \"banana\"));        \n+    }\n+\n+    public void testMapOfMaps() {\n+        TestBean bean = (TestBean) context.getContextBean();\n+\n+        Map fruit = new HashMap();\n+        fruit.put(\"apple\", \"green\");\n+        fruit.put(\"orange\", \"red\");\n+        \n+        Map meat = new HashMap();\n+        meat.put(\"pork\", \"pig\");\n+        meat.put(\"beef\", \"cow\");\n+        \n+        bean.getMap().put(\"fruit\", fruit);        \n+        bean.getMap().put(\"meat\", meat);        \n+                \n+        assertXPathPointer(\n+            context,\n+            \"//beef\",\n+            \"/map[@name='meat'][@name='beef']\");\n+        \n+        assertXPathPointer(\n+            context,\n+            \"map//apple\",\n+            \"/map[@name='fruit'][@name='apple']\");\n+\n+        // Ambiguous search - will return nothing\n+        assertXPathPointerLenient(context, \"map//banana\", \"null()\");\n+        \n+        // Unambiguous, even though the particular key is missing \n+        assertXPathPointerLenient(\n+            context,\n+            \"//fruit/pear\",\n+            \"/map[@name='fruit']/pear\");\n     }\n }", "timestamp": 1074820221, "metainfo": ""}