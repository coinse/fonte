{"sha": "a6e246c774fb91eefeadf28c46a10e768ac8cc7b", "log": "Major refactoring   ", "commit": "\n--- a/src/java/org/apache/commons/jxpath/AbstractFactory.java\n+++ b/src/java/org/apache/commons/jxpath/AbstractFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.1 2002/04/10 03:40:19 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/10 03:40:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/AbstractFactory.java,v 1.2 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * return true to indicate that the factory has successfully created the described object.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:19 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:31 $\n  */\n public abstract class AbstractFactory {\n \n      * to the factory to infer which one it is. If it is a collection, the\n      * factory should check if the collection exists.  If not, it should create\n      * the collection. Then it should create the index'th element of the collection\n-     * and return it.\n+     * and return true.\n      * <p>\n      * If the parameters describe an individual object, the factory should only\n      * create an object if index == 0.\n     }\n \n     /**\n-     * The factory should expand the collection to the specified size and return true. If\n-     * it cannot expand the collection, it should return false.\n-     */\n-    public boolean expandCollection(JXPathContext context, Pointer pointer, Object parent, String name, int size){\n-        return false;\n-    }\n-\n-    /**\n      * Create a new object and set it on the specified variable\n      */\n     public boolean declareVariable(JXPathContext context, String name){\n--- a/src/java/org/apache/commons/jxpath/ClassFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/ClassFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ClassFunctions.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n import java.lang.reflect.*;\n import org.apache.commons.jxpath.functions.*;\n+import org.apache.commons.jxpath.util.*;\n \n /**\n  * Extension functions provided by a Java class.\n  * the method.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public class ClassFunctions implements Functions {\n     private Class functionClass;\n         }\n \n         if (name.equals(\"new\")){\n-            Constructor constructor = Types.lookupConstructor(functionClass, parameters);\n+            Constructor constructor = TypeUtils.lookupConstructor(functionClass, parameters);\n             if (constructor != null){\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n-            Method method = Types.lookupStaticMethod(functionClass, name, parameters);\n+            Method method = TypeUtils.lookupStaticMethod(functionClass, name, parameters);\n             if (method != null){\n                 return new MethodFunction(method);\n             }\n \n-            method = Types.lookupMethod(functionClass, name, parameters);\n+            method = TypeUtils.lookupMethod(functionClass, name, parameters);\n             if (method != null){\n                 return new MethodFunction(method);\n             }\n--- a/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.2 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBasicBeanInfo.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * See java.beans.BeanInfo, java.beans.Introspector\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public class JXPathBasicBeanInfo implements JXPathBeanInfo {\n     private boolean atomic = false;\n     private Class clazz;\n     private PropertyDescriptor propertyDescriptors[];\n+    private String[] propertyNames;\n     private Class dynamicPropertyHandlerClass;\n \n     public JXPathBasicBeanInfo(Class clazz){\n         return propertyDescriptors;\n     }\n \n+    public PropertyDescriptor getPropertyDescriptor(String propertyName){\n+        if (propertyNames == null){\n+            PropertyDescriptor[] pds = getPropertyDescriptors();\n+            propertyNames = new String[pds.length];\n+            for (int i = 0; i < pds.length; i++){\n+                propertyNames[i] = pds[i].getName();\n+            }\n+        }\n+//        int inx = Arrays.binarySearch(propertyNames, propertyName);\n+//        if (inx < 0){\n+//            return null;\n+//        }\n+        for (int i = 0; i < propertyNames.length; i++){\n+            if (propertyNames[i] == propertyName){\n+                return propertyDescriptors[i];\n+            }\n+        }\n+\n+        for (int i = 0; i < propertyNames.length; i++){\n+            if (propertyNames[i].equals(propertyName)){\n+                return propertyDescriptors[i];\n+            }\n+        }\n+        return null;\n+    }\n+\n     /**\n      * For a dynamic class, returns the corresponding DynamicPropertyHandler class.\n      */\n--- a/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n+++ b/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java,v 1.2 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/JXPathBeanInfo.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * \"com.foo.BarXBeanInfo\" and make it implement the JXPathBeanInfo interface.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public interface JXPathBeanInfo  {\n \n     PropertyDescriptor[] getPropertyDescriptors();\n \n     /**\n+     * Returns a PropertyDescriptor for the specified name or null if there\n+     * is no such property.\n+     */\n+    PropertyDescriptor getPropertyDescriptor(String propertyName);\n+\n+    /**\n      * For dynamic objects, returns the class implementing\n      * the DynamicPropertyHandler interface. That class can\n      * be used to access dynamic properties.\n--- a/src/java/org/apache/commons/jxpath/PackageFunctions.java\n+++ b/src/java/org/apache/commons/jxpath/PackageFunctions.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/PackageFunctions.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n import java.lang.reflect.*;\n import org.apache.commons.jxpath.functions.*;\n+import org.apache.commons.jxpath.util.*;\n \n /**\n  * Extension functions provided by Java classes.  The class prefix specified\n \n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public class PackageFunctions implements Functions {\n     private String classPrefix;\n                 }\n             }\n             if (target != null){\n-                Method method = Types.lookupMethod(target.getClass(), name, parameters);\n+                Method method = TypeUtils.lookupMethod(target.getClass(), name, parameters);\n                 if (method != null){\n                     return new MethodFunction(method);\n                 }\n         }\n \n         if (methodName.endsWith(\"new\")){\n-            Constructor constructor = Types.lookupConstructor(functionClass, parameters);\n+            Constructor constructor = TypeUtils.lookupConstructor(functionClass, parameters);\n             if (constructor != null){\n                 return new ConstructorFunction(constructor);\n             }\n         }\n         else {\n-            Method method = Types.lookupStaticMethod(functionClass, methodName, parameters);\n+            Method method = TypeUtils.lookupStaticMethod(functionClass, methodName, parameters);\n             if (method != null){\n                 return new MethodFunction(method);\n             }\n--- a/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/ConstructorFunction.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n import java.lang.reflect.*;\n import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n \n /**\n  * An extension function that creates an instance using a constructor.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public class ConstructorFunction implements Function {\n \n                 args[0] = context;\n             }\n             for (int i = 0; i < parameters.length; i++){\n-                args[i + pi] = Types.convert(parameters[i], types[i]);\n+                args[i + pi] = TypeUtils.convert(parameters[i], types[i]);\n             }\n             return constructor.newInstance(args);\n         }\n--- a/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n+++ b/src/java/org/apache/commons/jxpath/functions/MethodFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.2 2002/04/10 03:40:19 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/functions/MethodFunction.java,v 1.3 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import java.util.*;\n import java.lang.reflect.*;\n import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.util.*;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:19 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:31 $\n  */\n public class MethodFunction implements Function {\n \n                     args[0] = context;\n                 }\n                 for (int i = 0; i < parameters.length; i++){\n-                    args[i + pi] = Types.convert(parameters[i], types[i + pi]);\n+                    args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]);\n                 }\n             }\n             else {\n                 if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n                     pi = 1;\n                 }\n-                target = Types.convert(parameters[0], method.getDeclaringClass());\n+                target = TypeUtils.convert(parameters[0], method.getDeclaringClass());\n                 args = new Object[parameters.length - 1 + pi];\n                 if (pi == 1){\n                     args[0] = context;\n                 }\n                 for (int i = 1; i < parameters.length; i++){\n-                    args[pi + i - 1] = Types.convert(parameters[i], types[i - 1]);\n+                    args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i - 1]);\n                 }\n             }\n \n--- a/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/EvalContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.7 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/EvalContext.java,v 1.8 2002/04/21 21:52:31 dmitri Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/04/21 21:52:31 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri;\n \n import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n import org.apache.commons.jxpath.ri.axes.*;\n import org.apache.commons.jxpath.Function;\n import org.apache.commons.jxpath.ExpressionContext;\n  * implement behavior of various XPath axes: \"child::\", \"parent::\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.7 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.8 $ $Date: 2002/04/21 21:52:31 $\n  */\n public abstract class EvalContext {\n     protected EvalContext parentContext;\n         }\n \n         if (l instanceof NodePointer){\n-            l = ((NodePointer)l).getPrimitiveValue();\n+            l = ((NodePointer)l).getCanonicalValue();\n         }\n         if (r instanceof NodePointer){\n-            r = ((NodePointer)r).getPrimitiveValue();\n+            r = ((NodePointer)r).getCanonicalValue();\n         }\n \n         if (l instanceof Boolean || r instanceof Boolean){\n         while(nextSet()){\n             while(next()){\n                 NodePointer pointer = getCurrentNodePointer();\n-                set.add(pointer.getPrimitiveValue());\n+                set.add(pointer.getCanonicalValue());\n             }\n         }\n         return set;\n             return \"\";\n         }\n         else if (object instanceof NodePointer){\n-            return stringValue(((NodePointer)object).getPrimitiveValue());\n+            return stringValue(((NodePointer)object).getCanonicalValue());\n         }\n         else if (object instanceof EvalContext){\n             EvalContext ctx = (EvalContext)object;\n             return number(stringValue(object));\n         }\n         else if (object instanceof NodePointer){\n-            return number(((NodePointer)object).getPrimitiveValue());\n+            return number(((NodePointer)object).getCanonicalValue());\n         }\n //        else if (object instanceof Node){\n //            System.err.println(\"HERE\");\n             return value;\n         }\n         else if (object instanceof NodePointer){\n-            return doubleValue(((NodePointer)object).getPrimitiveValue());\n+            return doubleValue(((NodePointer)object).getCanonicalValue());\n         }\n         else if (object instanceof EvalContext){\n             return doubleValue(stringValue(object));\n             return ((String)object).length() != 0;\n         }\n         else if (object instanceof NodePointer){\n-            return booleanValue(((NodePointer)object).getPrimitiveValue());\n+            return booleanValue(((NodePointer)object).getCanonicalValue());\n         }\n         return false;\n     }\n         return evalSteps(new InitialContext(rootContext), path, firstMatch);\n     }\n \n-\n-    private static final Object FAILURE = new Object();\n-\n-    /**\n-     * Attempts to evaluate a simple path without traversing contexts -\n-     * straight from a NodePointer to a NodePointer. This only works\n-     * in some cases though. Specifically, it works with JavaBeans\n-     * and objects with Dynamic Properties, but does not work with\n-     * DOM objects.\n-     */\n-    private Object tryBasicPath(NodePointer parentPointer, Step steps[]){\n+    /**\n+     * Walks a location path in a highly simplified fashion: from pointer to\n+     * pointer, no contexts.  This is only possible if the path consists of\n+     * simple steps like \"/foo[3]\" and is context-independent.\n+     */\n+    private NodePointer interpretBasicPath(NodePointer parentPointer, Step steps[]){\n         if (parentPointer == null){\n-            return FAILURE;\n+            return null;\n         }\n \n         NodePointer pointer = (NodePointer)parentPointer.clone();\n+        while (pointer != null && !pointer.isNode()){\n+            pointer = pointer.getValuePointer();\n+        }\n+\n         for (int i = 0; i < steps.length; i++){\n-            pointer = getPropertyPointer(pointer, ((NodeNameTest)steps[i].getNodeTest()).getNodeName().getName());\n-            if (pointer == null){\n-                return FAILURE;\n-            }\n-\n-            Expression predicates[] = steps[i].getPredicates();\n-            if (predicates != null && predicates.length != 0){\n-                pointer = processBasicPredicates(pointer, predicates);\n+            Step step = steps[i];\n+            int defaultIndex = (i == steps.length - 1 ? -1 : 0);\n+            QName name = ((NodeNameTest)step.getNodeTest()).getNodeName();\n+            Expression predicates[] = step.getPredicates();\n+\n+            // The following complicated logic is designed to translate\n+            // an xpath like \"foo[@name='x'][@name='y'][3]/bar/baz[4]\" into\n+            // a sequence of \"single steps\", each of which takes a node pointer,\n+            // a name and an optional index and gets you another node pointer.\n+\n+            // Note: if the last step is not indexed, the default index used\n+            // for that very last step is \"-1\", that is \"do not index at all\",\n+            // not \"0\" as in all preceeding steps.\n+\n+            int count = (predicates == null ? 0 : predicates.length);\n+            if (count == 0){\n+                pointer = singleStep(pointer, name, defaultIndex, false);\n             }\n             else {\n-                // If we are in the middle of a path, we interpret\n-                // a component like \"foo\" as \"foo[1]\"\n-                if (i < steps.length - 1){\n-                    pointer.setIndex(0);\n-                }\n-            }\n-        }\n-//        System.err.println(\"RETURNING: \" + pointer);\n-        return pointer;\n-    }\n-\n-    private NodePointer processBasicPredicates(NodePointer pointer, Expression[] predicates){\n-        if (predicates == null || predicates.length == 0){\n-            return pointer;\n-        }\n-\n-        for (int i = 0; pointer != null && i < predicates.length; i++){\n-            Expression expr = (Expression)predicates[i].getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n-            if (expr != null){\n-                String prop = stringValue(eval(expr, true));\n-                pointer = getPropertyPointer(pointer, prop);\n-                if (pointer instanceof NullPropertyPointer){\n-                    ((NullPropertyPointer)pointer).setDynamic(true);\n-                }\n-            }\n-            else {\n-                Object predicate = eval(predicates[i], true);\n-                if (predicate instanceof EvalContext){\n-                    predicate = ((EvalContext)predicate).getContextNodePointer();\n-                }\n-                if (predicate instanceof NodePointer){\n-                    predicate = ((NodePointer)predicate).getPrimitiveValue();\n-                }\n-                if (predicate == null){\n-                    throw new RuntimeException(\"Predicate is null: \" + predicates[i]);\n-                }\n-                if (predicate instanceof Number){\n-                    int index = (int)(doubleValue(predicate) + 0.5);\n-                    if (index > 0 && index <= pointer.getLength()){\n-                        pointer.setIndex(index - 1);\n+                Expression lastIndexPredicate = null;\n+                if (predicates[count - 1].\n+                            getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+                    lastIndexPredicate = predicates[count - 1];\n+                }\n+\n+                if (lastIndexPredicate != null){\n+                    int index = indexFromPredicate(lastIndexPredicate);\n+                    if (count == 1){\n+                        pointer = singleStep(pointer, name, index, false);\n                     }\n                     else {\n-                        pointer = new NullElementPointer(pointer, index - 1);\n+                        pointer = singleStep(pointer, name, -1, false);\n+                        for (int j = 0; j < count - 1; j++){\n+                            String key = keyFromPredicate(predicates[j]);\n+                            if (j < count - 2){\n+                                pointer = singleStep(pointer, key, -1, true);\n+                            }\n+                            else {\n+                                pointer = singleStep(pointer, key, index, true);\n+                            }\n+                        }\n                     }\n                 }\n-                else if (!booleanValue(predicate)){\n-                    pointer = null;\n+                else {\n+                    pointer = singleStep(pointer, name, -1, false);\n+                    for (int j = 0; j < count; j++){\n+                        String key = keyFromPredicate(predicates[j]);\n+                        if (j < count - 1){\n+                            pointer = singleStep(pointer, key, -1, true);\n+                        }\n+                        else {\n+                            pointer = singleStep(pointer, key, defaultIndex, true);\n+                        }\n+                    }\n                 }\n             }\n         }\n         return pointer;\n     }\n \n-    private NodePointer getPropertyPointer(NodePointer ptr, String property){\n-        NodePointer pointer = ptr;\n-        while (true){\n-            if (pointer instanceof VariablePointer){\n-                pointer = ((VariablePointer)pointer).getValuePointer();\n-            }\n-            else if (pointer instanceof ContainerPointer){\n-                pointer = ((ContainerPointer)pointer).getValuePointer();\n+    /**\n+     * Interprets predicates for the root expression of an Expression Path without creating\n+     * any intermediate contexts.  This is an option used for optimization when the path\n+     * has a simple structure and predicates are context-independent.\n+     */\n+    private NodePointer interpretBasicPredicates(NodePointer pointer, Expression predicates[]){\n+        if (predicates == null || predicates.length == 0 || pointer == null){\n+            return pointer;\n+        }\n+\n+        // The following complicated logic is designed to translate\n+        // an xpath like \"$foo[@name='x'][@name='y'][3]\" into\n+        // a sequence of \"single steps\", each of which takes a node pointer,\n+        // a name and an optional index and gets you another node pointer.\n+\n+        int count = predicates.length;\n+        Expression lastIndexPredicate = null;\n+        if (predicates[count - 1].\n+                    getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT) == null){\n+            lastIndexPredicate = predicates[count - 1];\n+        }\n+\n+        if (lastIndexPredicate != null){\n+            int index = indexFromPredicate(lastIndexPredicate);\n+            if (count == 1){\n+                if (index >= 0 && index < pointer.getLength()){\n+                    pointer.setIndex(index);\n+                }\n+                else {\n+                    pointer = new NullElementPointer(pointer, index);\n+                }\n             }\n             else {\n-                break;\n-            }\n-        }\n-\n-        if (pointer != null && !(pointer instanceof PropertyOwnerPointer)){\n-            return null;\n-        }\n-\n-        PropertyPointer prop;\n-        if (pointer != null){\n-            prop = ((PropertyOwnerPointer)pointer).getPropertyPointer();\n+                for (int j = 0; j < count - 1; j++){\n+                    String key = keyFromPredicate(predicates[j]);\n+                    if (j < count - 2){\n+                        pointer = singleStep(pointer, key, -1, true);\n+                    }\n+                    else {\n+                        pointer = singleStep(pointer, key, index, true);\n+                    }\n+                }\n+            }\n         }\n         else {\n-            prop = new NullPropertyPointer(ptr);\n-        }\n-\n-        prop.setPropertyName(property);\n-        return prop.childNodePointer();\n+            for (int j = 0; j < count; j++){\n+                String key = keyFromPredicate(predicates[j]);\n+                if (j < count - 1){\n+                    pointer = singleStep(pointer, key, -1, true);\n+                }\n+                else {\n+                    pointer = singleStep(pointer, key, -1, true);\n+                }\n+            }\n+        }\n+        return pointer;\n+    }\n+\n+    /**\n+     * @param property can be either a name or a QName\n+     */\n+    private NodePointer singleStep(NodePointer parent, Object property, int index, boolean dynamic){\n+        if (parent instanceof PropertyOwnerPointer){\n+            PropertyPointer pointer = ((PropertyOwnerPointer)parent).getPropertyPointer();\n+            String name;\n+            if (property instanceof QName){\n+                name = ((QName)property).getName();\n+            }\n+            else {\n+                name = (String)property;\n+            }\n+            pointer.setPropertyName(name);\n+            if (pointer instanceof NullPropertyPointer && dynamic){\n+                ((NullPropertyPointer)pointer).setDynamic(true);\n+            }\n+            if (index != -1){\n+                if (index >= 0 && index < pointer.getLength()){\n+                    pointer.setIndex(index);\n+                    return pointer.getValuePointer();\n+                }\n+                else {\n+                    return new NullElementPointer(pointer, index).getValuePointer();\n+                }\n+            }\n+            else {\n+                return pointer.getValuePointer();\n+            }\n+        }\n+        else {\n+            QName name;\n+            if (property instanceof QName){\n+                name = (QName)property;\n+            }\n+            else {\n+                name = new QName(null, (String)property);\n+            }\n+            NodeIterator it = parent.childIterator(new NodeNameTest(name), false, null);\n+            if (it != null && it.setPosition(index == -1 ? 1 : index + 1)){\n+                return it.getNodePointer();\n+            }\n+            else {\n+                PropertyPointer pointer = new NullPropertyPointer(parent);\n+                pointer.setPropertyName(name.toString());\n+                pointer.setIndex(index);\n+                return pointer.getValuePointer();\n+            }\n+        }\n+    }\n+\n+    private int indexFromPredicate(Expression predicate){\n+        Object value = eval(predicate, true);\n+        if (value instanceof EvalContext){\n+            value = ((EvalContext)value).getContextNodePointer();\n+        }\n+        if (value instanceof NodePointer){\n+            value = ((NodePointer)value).getCanonicalValue();\n+        }\n+        if (value == null){\n+            throw new RuntimeException(\"Predicate is null: \" + value);\n+        }\n+\n+        if (value instanceof Number){\n+            return (int)(doubleValue(value) + 0.5) - 1;\n+        }\n+        else if (booleanValue(value)){\n+            return 0;\n+        }\n+\n+        return -1;\n+    }\n+\n+    private String keyFromPredicate(Expression predicate){\n+        Expression expr = (Expression)predicate.\n+                getEvaluationHint(CoreOperation.DYNAMIC_PROPERTY_ACCESS_HINT);\n+        return stringValue(eval(expr));\n     }\n \n     /**\n         }\n \n         Expression predicates[] = path.getPredicates();\n-        if (firstMatch){\n-            if (path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE)){\n-                EvalContext ctx = new InitialContext(context);\n-                NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n-                if (ptr != null &&\n-                        (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n-                         predicates == null || predicates.length == 0)){\n-                    NodePointer pointer = processBasicPredicates(ptr, predicates);\n-                    if (pointer != null){\n-                        Object result = tryBasicPath(pointer, path.getSteps());\n-                        if (result != FAILURE){\n-                            return result;\n-                        }\n-                    }\n-                }\n+\n+        if (firstMatch &&\n+                path.getEvaluationHint(ExpressionPath.BASIC_PREDICATES_HINT).equals(Boolean.TRUE) &&\n+                !(context instanceof UnionContext)){\n+            EvalContext ctx = context;\n+            NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n+            if (ptr != null &&\n+                    (ptr.getIndex() == NodePointer.WHOLE_COLLECTION ||\n+                     predicates == null || predicates.length == 0)){\n+                NodePointer pointer = interpretBasicPredicates(ptr, predicates);\n+                return interpretBasicPath(pointer, path.getSteps());\n             }\n         }\n \n      */\n     private Object evalSteps(EvalContext context, Path path, boolean firstMatch){\n         Step steps[] = path.getSteps();\n+\n         if (firstMatch && steps.length != 0){\n             boolean basic = path.getEvaluationHint(Path.BASIC_PATH_HINT).equals(Boolean.TRUE);\n             if (basic){\n-                EvalContext ctx = new InitialContext(context);\n-                NodePointer ptr = (NodePointer)ctx.getContextNodePointer();\n-                Object result = tryBasicPath(ptr, steps);\n-                if (result != FAILURE){\n-                    return result;\n-                }\n+                NodePointer ptr = (NodePointer)context.getContextNodePointer();\n+                return interpretBasicPath(ptr, steps);\n             }\n         }\n \n         int count = 0;\n         Object value = eval(arg1, false);\n         if (value instanceof NodePointer){\n-            value = ((NodePointer)value).getPrimitiveValue();\n+            value = ((NodePointer)value).getCanonicalValue();\n         }\n         if (value instanceof EvalContext){\n             EvalContext ctx = (EvalContext)value;\n--- a/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n+++ b/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.8 2002/04/12 02:28:06 dmitri Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/04/12 02:28:06 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/JXPathContextReferenceImpl.java,v 1.9 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri;\n \n \n+import java.lang.ref.SoftReference;\n import java.util.*;\n \n+import org.apache.commons.jxpath.Function;\n+import org.apache.commons.jxpath.Functions;\n+import org.apache.commons.jxpath.JXPathContext;\n+import org.apache.commons.jxpath.PackageFunctions;\n+import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.Variables;\n-import org.apache.commons.jxpath.JXPathContext;\n-import org.apache.commons.jxpath.Pointer;\n-import org.apache.commons.jxpath.Functions;\n-import org.apache.commons.jxpath.Function;\n-import org.apache.commons.jxpath.PackageFunctions;\n-import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.Compiler;\n-import org.apache.commons.jxpath.ri.pointers.*;\n-import org.apache.commons.jxpath.ri.EvalContext;\n-import org.apache.commons.jxpath.ri.axes.*;\n-import org.apache.commons.jxpath.functions.Types;\n-import java.lang.ref.SoftReference;\n+import org.apache.commons.jxpath.ri.axes.RootContext;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n+import org.apache.commons.jxpath.ri.compiler.TreeCompiler;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+import org.apache.commons.jxpath.ri.model.VariablePointer;\n+import org.apache.commons.jxpath.ri.model.beans.BeanPointerFactory;\n+import org.apache.commons.jxpath.ri.model.beans.CollectionPointerFactory;\n+import org.apache.commons.jxpath.ri.model.beans.DynamicPointerFactory;\n+import org.apache.commons.jxpath.ri.model.container.ContainerPointerFactory;\n+import org.apache.commons.jxpath.ri.model.dom.DOMPointerFactory;\n+import org.apache.commons.jxpath.util.TypeUtils;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.8 $ $Date: 2002/04/12 02:28:06 $\n+ * @version $Revision: 1.9 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class JXPathContextReferenceImpl extends JXPathContext\n {\n     private static Vector nodeFactories = new Vector();\n     private static NodePointerFactory nodeFactoryArray[] = null;\n     static {\n+        nodeFactories.add(new CollectionPointerFactory());\n         nodeFactories.add(new BeanPointerFactory());\n         nodeFactories.add(new DynamicPointerFactory());\n         nodeFactories.add(new DOMPointerFactory());\n         nodeFactories.add(new ContainerPointerFactory());\n         createNodeFactoryArray();\n     }\n+    private NodePointer rootPointer;\n \n     // The frequency of the cache cleanup\n     private static final int CLEANUP_THRESHOLD = 500;\n     }\n \n     private static void cleanupCache(){\n-        System.gc();\n+//        System.gc();\n         Iterator it = compiled.entrySet().iterator();\n         while (it.hasNext()){\n             Map.Entry me = (Map.Entry)it.next();\n             EvalContext ctx = (EvalContext)result;\n             result = ctx.getContextNodePointer();\n         }\n-\n-//        if (result instanceof DOMNodePointer){\n-//            result = ((DOMNodePointer)result).stringValue();\n-//        }\n         if (result instanceof NodePointer){\n-            result = ((NodePointer)result).getPrimitiveValue();\n+            result = ((NodePointer)result).getCanonicalValue();\n         }\n         return result;\n     }\n     public Object getValue(String xpath, Class requiredType){\n         Object value = getValue(xpath);\n         if (value != null && requiredType != null){\n-            if (!Types.canConvert(value, requiredType)){\n+            if (!TypeUtils.canConvert(value, requiredType)){\n                 throw new RuntimeException(\"Invalid expression type. '\" + xpath +\n                     \"' returns \" + value.getClass().getName() +\n                     \". It cannot be converted to \" + requiredType.getName());\n             }\n-            value = Types.convert(value, requiredType);\n+            value = TypeUtils.convert(value, requiredType);\n         }\n         return value;\n     }\n             return (Pointer)result;\n         }\n         else {\n-            return NodePointer.createNodePointer(null, result, getLocale());\n+            return NodePointer.newNodePointer(null, result, getLocale());\n         }\n     }\n \n             setValue(xpath, value, true);\n         }\n         catch (Throwable ex){\n+            ex.printStackTrace();\n             throw new RuntimeException(\"Exception trying to create xpath \" +\n                     xpath + \". \" + ex.getMessage());\n         }\n             pointer = ctx.getContextNodePointer();\n         }\n         else {\n+            // This should never happen\n             throw new RuntimeException(\"Cannot set value for xpath: \" + xpath);\n         }\n-//        Pointer p = pointer;\n-//        while (p != null){\n-//            System.err.println(\"PTR: \" + p.getClass() + \" \" + p.asPath());\n-//            if (p instanceof NodePointer){\n-//                p = ((NodePointer)p).getParent();\n-//            }\n-//        }\n         if (create){\n             ((NodePointer)pointer).createPath(this, value);\n         }\n             list.add((Pointer)result);\n         }\n         else {\n-            list.add(NodePointer.createNodePointer(null, result, getLocale()));\n+            list.add(NodePointer.newNodePointer(null, result, getLocale()));\n         }\n         return list;\n     }\n \n     private Object eval(String xpath, boolean firstMatchLookup) {\n         Expression expr = compile(xpath);\n-        NodePointer pointer = NodePointer.createNodePointer(new QName(null, \"root\"), getContextBean(), getLocale());\n-        EvalContext ctx = new RootContext(this, pointer);\n-        return ctx.eval(expr, firstMatchLookup);\n+        return getRootContext().eval(expr, firstMatchLookup);\n+    }\n+\n+    private void printPointer(NodePointer pointer){\n+        Pointer p = pointer;\n+        while (p != null){\n+            System.err.println((p == pointer ? \"POINTER: \" : \" PARENT: \") + p.getClass() + \" \" + p.asPath());\n+            if (p instanceof NodePointer){\n+                p = ((NodePointer)p).getParent();\n+            }\n+        }\n+    }\n+\n+    private synchronized NodePointer getRootPointer(){\n+        if (rootPointer == null){\n+            rootPointer = NodePointer.newNodePointer(new QName(null, \"root\"),\n+                getContextBean(), getLocale());\n+        }\n+        return rootPointer;\n+    }\n+\n+    private EvalContext getRootContext(){\n+        return new RootContext(this, getRootPointer());\n     }\n \n     private List resolveNodeSet(List list){\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/QName.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/QName.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:32 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ */\n+public class QName {\n+    private String prefix;\n+    private String name;\n+\n+    public QName(String prefix, String name){\n+        this.prefix = prefix;\n+        this.name = name;\n+    }\n+\n+    public String getPrefix(){\n+        return prefix;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public String toString(){\n+        if (prefix != null){\n+            return prefix + ':' + name;\n+        }\n+        return name;\n+    }\n+\n+    public int hashCode(){\n+        return name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (!(object instanceof QName)){\n+            return false;\n+        }\n+        if (this == object){\n+            return true;\n+        }\n+        QName that = (QName)object;\n+        if (!this.name.equals(that.name)){\n+            return false;\n+        }\n+\n+        if ((this.prefix == null && that.prefix != null) ||\n+            (this.prefix != null && !this.prefix.equals(that.prefix))){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AncestorContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n \n import java.util.*;\n \n  * EvalContext that walks the \"ancestor::\" and \"ancestor-or-self::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class AncestorContext extends EvalContext {\n     private NodeTest nodeTest;\n             }\n         }\n \n-        currentNodePointer = currentNodePointer.getParent();\n+        while(true){\n+            currentNodePointer = currentNodePointer.getParent();\n \n-        return currentNodePointer != null && currentNodePointer.testNode(nodeTest);\n+            if (currentNodePointer == null){\n+                return false;\n+            }\n+\n+            if (currentNodePointer.testNode(nodeTest)){\n+                return true;\n+            }\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n \n import java.util.*;\n \n  * EvalContext that walks the \"attribute::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class AttributeContext extends EvalContext {\n     private NodeTest nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ChildContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n \n import java.lang.reflect.*;\n  * \"preceding-sibling::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class ChildContext extends EvalContext {\n     private NodeTest nodeTest;\n             return;\n         }\n         if (startFromParentLocation){\n-            iterator = parent.siblingIterator(nodeTest, reverse);\n+            NodePointer pointer = parent.getParent();\n+            while (pointer != null && !pointer.isNode()){\n+                pointer = pointer.getParent();\n+            }\n+\n+            iterator = pointer.childIterator(nodeTest, reverse, parent);\n         }\n         else {\n-            iterator = parent.childIterator(nodeTest, reverse);\n+            iterator = parent.childIterator(nodeTest, reverse, null);\n         }\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/DescendantContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import java.util.*;\n \n  * axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class DescendantContext extends EvalContext {\n     private NodeTest nodeTest;\n             currentNodePointer = parentContext.getCurrentNodePointer();\n             if (currentNodePointer != null){\n                 if (!currentNodePointer.isLeaf()){\n-                    stack.push(currentNodePointer.childIterator(null, false));\n+                    stack.push(currentNodePointer.childIterator(null, false, null));\n                 }\n                 if (includeSelf){\n                     if (currentNodePointer.testNode(nodeTest)){\n             if (it.setPosition(it.getPosition() + 1)){\n                 currentNodePointer = it.getNodePointer();\n                 if (!currentNodePointer.isLeaf()){\n-                    stack.push(currentNodePointer.childIterator(null, false));\n+                    stack.push(currentNodePointer.childIterator(null, false, null));\n                 }\n                 if (currentNodePointer.testNode(nodeTest)){\n                     position++;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/InitialContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import java.util.*;\n \n  * on to the parent context.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class InitialContext extends EvalContext {\n     private boolean startedSet = false;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/NamespaceContext.java,v 1.3 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.jxpath.ri.axes;\n \n+import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n \n import java.util.*;\n \n  * EvalContext that walks the \"namespace::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class NamespaceContext extends EvalContext {\n     private NodeTest nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/ParentContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n \n import java.util.*;\n  * EvalContext that walks the \"parent::\" axis.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class ParentContext extends EvalContext {\n     private NodeTest nodeTest;\n         setStarted = true;\n         NodePointer thisLocation = parentContext.getCurrentNodePointer();\n         currentNodePointer = thisLocation.getParent();\n+        while (currentNodePointer != null && !currentNodePointer.isNode()){\n+            currentNodePointer = currentNodePointer.getParent();\n+        }\n         return currentNodePointer != null && currentNodePointer.testNode(nodeTest);\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PrecedingOrFollowingContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.*;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import java.lang.reflect.*;\n import java.util.*;\n  * EvalContext that walks the \"preceding::\" and \"following::\" axes.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class PrecedingOrFollowingContext extends EvalContext {\n     private NodeTest nodeTest;\n         if (!setStarted){\n             setStarted = true;\n             currentRootLocation = parentContext.getCurrentNodePointer();\n-            // TBD: check type\n-            stack.push(currentRootLocation.siblingIterator(null, reverse));\n+            NodePointer parent = getMaterialPointer(currentRootLocation.getParent());\n+            if (parent != null){\n+                // TBD: check type\n+                stack.push(parent.childIterator(null, reverse, currentRootLocation));\n+            }\n         }\n \n         while (true){\n             if (stack.isEmpty()){\n-                currentRootLocation = currentRootLocation.getParent();\n+                currentRootLocation = getMaterialPointer(currentRootLocation.getParent());\n+\n                 if (currentRootLocation == null || currentRootLocation.isRoot()){\n                     break;\n                 }\n-                // TBD: check type\n-                stack.push(currentRootLocation.siblingIterator(null, reverse));\n+\n+                NodePointer parent = getMaterialPointer(currentRootLocation.getParent());\n+                if (parent != null){\n+                    stack.push(parent.childIterator(null, reverse, currentRootLocation));\n+                }\n             }\n \n             while (!stack.isEmpty()){\n                     if (it.setPosition(it.getPosition() + 1)){\n                         currentNodePointer = it.getNodePointer();\n                         if (!currentNodePointer.isLeaf()){\n-                            stack.push(currentNodePointer.childIterator(null, reverse));\n+                            stack.push(currentNodePointer.childIterator(null, reverse, null));\n                         }\n                         if (currentNodePointer.testNode(nodeTest)){\n                             super.setPosition(getCurrentPosition() + 1);\n                     if (it.setPosition(it.getPosition() + 1)){\n                         currentNodePointer = it.getNodePointer();\n                         if (!currentNodePointer.isLeaf()){\n-                            stack.push(currentNodePointer.childIterator(null, reverse));\n+                            stack.push(currentNodePointer.childIterator(null, reverse, null));\n                         }\n                         else if (currentNodePointer.testNode(nodeTest)){\n                             super.setPosition(getCurrentPosition() + 1);\n         }\n         return false;\n     }\n+\n+    /**\n+     * If the pointer is auxiliary, return the parent; otherwise - the pointer itself\n+     */\n+    private NodePointer getMaterialPointer(NodePointer pointer){\n+        while (pointer != null && !pointer.isNode()){\n+            pointer = pointer.getParent();\n+        }\n+        return pointer;\n+    }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/PredicateContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.ri.compiler.*;\n import org.apache.commons.jxpath.ri.Compiler;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n \n /**\n  * EvalContext that checks predicates.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class PredicateContext extends EvalContext {\n     private Expression expression;\n             if (setupDynamicPropertyPointer()){\n                 Object pred = parentContext.eval(dynamicPropertyNameExpression);\n                 if (pred instanceof NodePointer){\n-                    pred = ((NodePointer)pred).getValue();\n+                    pred = ((NodePointer)pred).getCanonicalValue();\n                 }\n-                dynamicPropertyPointer.setPropertyName(String.valueOf(pred));\n+                dynamicPropertyPointer.setPropertyName(stringValue(pred));\n                 done = true;\n                 return true;\n             }\n         if (!(parent instanceof PropertyOwnerPointer)){\n             return false;\n         }\n-        dynamicPropertyPointer = ((PropertyOwnerPointer)parentContext.getCurrentNodePointer()).getPropertyPointer();\n+        dynamicPropertyPointer = ((PropertyOwnerPointer)parent).getPropertyPointer();\n         return true;\n     }\n \n     }\n \n     public boolean setPosition(int position){\n-        return false;\n+        if (this.position > position){\n+            reset();\n+        }\n+\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n }\n--- a/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.4 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/RootContext.java,v 1.5 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.JXPathContext;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import org.apache.commons.jxpath.ri.JXPathContextReferenceImpl;\n import org.apache.commons.jxpath.Function;\n  * EvalContext that is used to hold the root node for the path traversal.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.4 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.5 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class RootContext extends EvalContext {\n     private boolean startedSet = false;\n     }\n \n     public EvalContext getConstantContext(Object constant){\n-        NodePointer pointer = NodePointer.createNodePointer(new QName(null, \"\"), constant, null);\n+        NodePointer pointer = NodePointer.newNodePointer(new QName(null, \"\"), constant, null);\n         return new InitialContext(new RootContext(parent, pointer));\n     }\n \n--- a/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/SelfContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n import org.apache.commons.jxpath.Pointer;\n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n \n import java.util.*;\n  * EvalContext that returns the current node from the parent context if the test succeeds.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class SelfContext extends EvalContext {\n     private NodeTest nodeTest;\n--- a/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n+++ b/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.3 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,v 1.4 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.ri.Compiler;\n import org.apache.commons.jxpath.ri.compiler.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n import org.apache.commons.jxpath.ri.EvalContext;\n import java.util.*;\n \n  * of a union operation like (a | b)\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.3 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.4 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class UnionContext extends EvalContext {\n     private boolean startedSet = false;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,v 1.2 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * like \"position()\" or \"number()\".\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class CoreFunction extends Operation {\n \n             case Compiler.FUNCTION_STRING:\n             case Compiler.FUNCTION_LANG:\n             case Compiler.FUNCTION_NUMBER:\n-                return args.length == 0;\n+                return args == null || args.length == 0;\n \n             case Compiler.FUNCTION_COUNT:\n             case Compiler.FUNCTION_ID:\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperation.java,v 1.3 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.Compiler;\n \n /**\n  * \"-\", \"*\" etc.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class CoreOperation extends Operation {\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.2 2002/04/10 03:40:20 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/04/10 03:40:20 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/ExtensionFunction.java,v 1.3 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.*;\n \n+import org.apache.commons.jxpath.ri.*;\n+\n /**\n  * Represents an element of the parse tree representing an extension function call.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2002/04/10 03:40:20 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class ExtensionFunction extends Operation {\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/NodeNameTest.java,v 1.3 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.*;\n \n+import org.apache.commons.jxpath.ri.*;\n+\n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class NodeNameTest extends NodeTest {\n     private QName qname;\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.2 2001/09/21 23:22:44 dmitri Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/09/21 23:22:44 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/TreeCompiler.java,v 1.3 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath.ri.compiler;\n \n import java.util.*;\n+\n+import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.Compiler;\n \n /**\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.2 $ $Date: 2001/09/21 23:22:44 $\n+ * @version $Revision: 1.3 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class TreeCompiler implements Compiler {\n \n--- a/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.1 2001/08/23 00:46:59 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/08/23 00:46:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/compiler/VariableReference.java,v 1.2 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/21 21:52:32 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import java.util.*;\n \n+import org.apache.commons.jxpath.ri.*;\n+\n /**\n  * An element of the compile tree holding a variable reference.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/08/23 00:46:59 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:32 $\n  */\n public class VariableReference extends Expression {\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodeIterator.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:32 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model;\n+\n+/**\n+ * Definition for an iterator for all kinds of Nodes.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ */\n+public interface NodeIterator {\n+\n+    int getPosition();\n+\n+    /**\n+     * Sets the new current position and returns true if there a node\n+     * at that position.\n+     */\n+    boolean setPosition(int position);\n+\n+    NodePointer getNodePointer();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:32 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Common superclass for Pointers of all kinds.  A NodePointer maps to\n+ * a deterministic XPath that represents the location of a node in an object graph.\n+ * This XPath uses only simple axes: child, namespace and attribute and only simple,\n+ * context-independent predicates.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ */\n+public abstract class NodePointer implements Pointer, Cloneable {\n+\n+    public static int WHOLE_COLLECTION = Integer.MIN_VALUE;\n+    protected int index = WHOLE_COLLECTION;\n+    public static String UNKNOWN_NAMESPACE = \"<<unknown namespace>>\";\n+\n+    /**\n+     * Allocates an entirely new NodePointer by iterating through all installed\n+     * NodePointerFactories until it finds one that can create a pointer.\n+     */\n+    public static NodePointer newNodePointer(QName name, Object bean, Locale locale){\n+        if (bean == null){\n+            return new NullPointer(name, locale);\n+        }\n+        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++){\n+            NodePointer pointer = factories[i].createNodePointer(name, bean, locale);\n+            if (pointer != null){\n+                return pointer;\n+            }\n+        }\n+        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n+    }\n+\n+    /**\n+     * Allocates an new child NodePointer by iterating through all installed\n+     * NodePointerFactories until it finds one that can create a pointer.\n+     */\n+    public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean){\n+        NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories();\n+        for (int i = 0; i < factories.length; i++){\n+            NodePointer pointer = factories[i].createNodePointer(parent, name, bean);\n+            if (pointer != null){\n+                return pointer;\n+            }\n+        }\n+        throw new RuntimeException(\"Could not allocate a NodePointer for object of \" + bean.getClass());\n+    }\n+\n+    protected NodePointer parent;\n+    protected Locale locale;\n+\n+    protected NodePointer(NodePointer parent){\n+        this.parent = parent;\n+    }\n+\n+    protected NodePointer(NodePointer parent, Locale locale){\n+        this.parent = parent;\n+        this.locale = locale;\n+    }\n+\n+    public NodePointer getParent(){\n+        return parent;\n+    }\n+\n+    /**\n+     * Returns true if this Pointer has no parent.\n+     */\n+    public boolean isRoot(){\n+        return parent == null;\n+    }\n+\n+    /**\n+     * If true, this node does not have children\n+     */\n+    public boolean isLeaf(){\n+        Object value = getValue();\n+        return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic();\n+    }\n+\n+    /**\n+     * If false, this node is axiliary and can only be used as an intermediate\n+     * in the chain of pointers.\n+     */\n+    public boolean isNode(){\n+        return true;\n+    }\n+\n+    /**\n+     * If the pointer represents a collection, the index identifies\n+     * an element of that collection.  The default value of <code>index</code>\n+     * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n+     * is not indexed at all.\n+     * Note: the index on NodePointer starts with 0, not 1.\n+     */\n+    public int getIndex(){\n+        return index;\n+    }\n+\n+    public void setIndex(int index){\n+        this.index = index;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the value of the pointer is an array or\n+     * a Collection.\n+     */\n+    public boolean isCollection(){\n+        Object value = getBaseValue();\n+        return value != null && ValueUtils.isCollection(value);\n+    }\n+\n+    /**\n+     * If the pointer represents a collection (or collection element),\n+     * returns the length of the collection. Otherwise returns 1 (even if the value is null).\n+     */\n+    public int getLength(){\n+        Object value = getBaseValue();\n+        if (value == null){\n+            return 1;\n+        }\n+        return ValueUtils.getLength(value);\n+    }\n+\n+    /**\n+     * By default, returns <code>getValue()</code>, can be overridden to\n+     * return a \"canonical\" value, like for instance a DOM element should\n+     * return its string value.\n+     */\n+    public Object getCanonicalValue(){\n+        return getValue();\n+    }\n+\n+    /**\n+     * If this pointer manages a transparent container, like a variable,\n+     * this method returns the pointer to the contents.\n+     * Only an auxiliary (non-node) pointer can (and should) return a\n+     * value pointer other than itself.\n+     */\n+    public NodePointer getValuePointer(){\n+        return this;\n+    }\n+\n+    /**\n+     * An actual pointer points to an existing part of an object graph, even\n+     * if it is null. A non-actual pointer represents a part that does not exist\n+     * at all.\n+     * For instance consider the pointer \"/address/street\".\n+     * If both <em>address</em> and <em>street</em> are not null, the pointer is actual.\n+     * If <em>address</em> is not null, but <em>street</em> is null, the pointer is still actual.\n+     * If <em>address</em> is null, the pointer is not actual.\n+     * (In JavaBeans) if <em>address</em> is not a property of the root bean, a Pointer\n+     * for this path cannot be obtained at all - actual or otherwise.\n+     */\n+    public boolean isActual(){\n+        if (index == WHOLE_COLLECTION){\n+            return true;\n+        }\n+        else {\n+            return index >= 0 && index < getLength();\n+        }\n+    }\n+\n+    /**\n+     * Returns the name of this node. Can be null.\n+     */\n+    public abstract QName getName();\n+\n+    /**\n+     * Returns the value represented by the pointer before indexing.\n+     * So, if the node represents an element of a collection, this\n+     * method returns the collection itself.\n+     */\n+    public abstract Object getBaseValue();\n+\n+    public abstract void setValue(Object value);\n+\n+    /**\n+     * Checks if this Pointer matches the supplied NodeTest.\n+     */\n+    public boolean testNode(NodeTest test){\n+        if (test == null){\n+            return true;\n+        }\n+        else if (test instanceof NodeNameTest){\n+            if (!isNode()){\n+                return false;\n+            }\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            QName nodeName = getName();\n+            String testPrefix = testName.getPrefix();\n+            String nodePrefix = nodeName.getPrefix();\n+            if (!equalStrings(testPrefix, nodePrefix)){\n+                String testNS = getNamespaceURI(testPrefix);\n+                String nodeNS = getNamespaceURI(nodePrefix);\n+                if (!equalStrings(testNS, nodeNS)){\n+                    return false;\n+                }\n+            }\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\")){\n+                return true;\n+            }\n+            return testLocalName.equals(nodeName.getName());\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+                return isNode();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     *  Called directly by JXPathContext. Must create path and\n+     *  set value.\n+     */\n+    public void createPath(JXPathContext context, Object value){\n+        setValue(value);\n+    }\n+\n+    /**\n+     * Called by a child pointer when it needs to create a parent object.\n+     * Must create an object described by this pointer and return\n+     * a new pointer that properly describes the new object.\n+     */\n+    public NodePointer createPath(JXPathContext context){\n+        return this;\n+    }\n+\n+    /**\n+     * Called by a child pointer if that child needs to assign the value\n+     * supplied in the createPath(context, value) call to a non-existent\n+     * node. This method must may have to expand the collection in order to\n+     * assign the element.\n+     */\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n+                \", operation is not allowed for this type of node\");\n+    }\n+\n+    /**\n+     * Called by a child pointer when it needs to create a parent object\n+     * for a non-existent collection element.  It may have to expand the collection,\n+     * then create an element object and return a new pointer describing the\n+     * newly created element.\n+     */\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        throw new RuntimeException(\"Cannot create an object for path \" + asPath() +\n+                \", operation is not allowed for this type of node\");\n+    }\n+\n+    /**\n+     * If the Pointer has a parent, returns the parent's locale;\n+     * otherwise returns the locale specified when this Pointer\n+     * was created.\n+     */\n+    public Locale getLocale(){\n+        if (locale == null){\n+            if (parent != null){\n+                locale = parent.getLocale();\n+            }\n+        }\n+        return locale;\n+    }\n+\n+    /**\n+     * Returns true if the selected locale name starts\n+     * with the specified prefix <i>lang</i>, case-insensitive.\n+     */\n+    public boolean isLanguage(String lang){\n+        Locale loc = getLocale();\n+        String name = loc.toString().replace('_', '-');\n+        return name.toUpperCase().startsWith(lang.toUpperCase());\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all children or all children\n+     * that match the given NodeTest, starting with the specified one.\n+     */\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all attributes of the current node\n+     * matching the supplied node name (could have a wildcard).\n+     * May return null if the object does not support the attributes.\n+     */\n+    public NodeIterator attributeIterator(QName qname){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodeIterator that iterates over all namespaces of the value\n+     * currently pointed at.\n+     * May return null if the object does not support the namespaces.\n+     */\n+    public NodeIterator namespaceIterator(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a NodePointer for the specified namespace. Will return null\n+     * if namespaces are not supported. Will return UNKNOWN_NAMESPACE if there is no such namespace.\n+     */\n+    public NodePointer namespacePointer(String namespace){\n+        return null;\n+    }\n+\n+    /**\n+     * Decodes a namespace prefix to the corresponding URI.\n+     */\n+    public String getNamespaceURI(String prefix){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the namespace URI associated with this Pointer.\n+     */\n+    public String getNamespaceURI(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns true if the supplied prefix represents the\n+     * default namespace in the context of the current node.\n+     */\n+    protected boolean isDefaultNamespace(String prefix){\n+        if (prefix == null){\n+            return true;\n+        }\n+\n+        String namespace = getNamespaceURI(prefix);\n+        if (namespace == null){\n+            return false;       // undefined namespace\n+        }\n+\n+        return namespace.equals(getDefaultNamespaceURI());\n+    }\n+\n+    protected String getDefaultNamespaceURI(){\n+        return null;\n+    }\n+\n+    /**\n+     * Returns a name that consists of the namespaceURI and the local name\n+     * of the node.  For non-XML pointers, returns the Pointer's qualified name.\n+     */\n+    public QName getExpandedName(){\n+        return getName();\n+    }\n+\n+    /**\n+     * Returns an XPath that maps to this Pointer.\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (getParent() != null){\n+            buffer.append(getParent().asPath());\n+            // TBD: the following needs to be redesigned.  What this condition says is\n+            // \"if the parent of this node has already appended this node's name,\n+            // don't do it again\".  However, I would hate to add an ugly API like\n+            // \"isResponsibleForAppendingChildName()\".\n+            if (getParent().isNode() || (parent instanceof NullElementPointer)){\n+                QName name = getName();\n+                if (name != null){\n+                    buffer.append('/');\n+                    buffer.append(name);\n+                }\n+            }\n+        }\n+        else {\n+            QName name = getName();\n+            buffer.append(name);\n+        }\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    public Object clone(){\n+        try {\n+            return super.clone();\n+        }\n+        catch (CloneNotSupportedException ex){\n+            // Of course it is supported\n+            ex.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    public String toString(){\n+        return asPath();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/NodePointerFactory.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:32 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model;\n+\n+import org.apache.commons.jxpath.ri.QName;\n+\n+import java.util.*;\n+\n+/**\n+ * Creates NodePointers for objects of a certain type.\n+ * NodePointerFactories are ordered according to the values returned\n+ * by the \"getOrder\" method and always queried in that order.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ */\n+public interface NodePointerFactory {\n+\n+    /**\n+     * The factory name determines its position between other factories.\n+     */\n+    public int getOrder();\n+\n+    /**\n+     * Create a NodePointer for the supplied object.  The node will represent\n+     * the \"root\" object a path.\n+     *\n+     * Return null if this factory does not recognize objects of the supplied type.\n+     */\n+    public NodePointer createNodePointer(QName name, Object object, Locale locale);\n+\n+    /**\n+     * Create a NodePointer for the supplied child object.\n+     * <p>\n+     * Return null if this factory does not recognize objects of the supplied type.\n+     */\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object object);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/VariablePointer.java,v 1.1 2002/04/21 21:52:32 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:32 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Pointer to a context variable.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:32 $\n+ */\n+public class VariablePointer extends NodePointer {\n+    private Variables variables;\n+    private QName name;\n+    private NodePointer valuePointer;\n+    private boolean actual;\n+\n+    public VariablePointer(Variables variables, QName name){\n+        super(null);\n+        this.variables = variables;\n+        this.name = name;\n+        actual = true;\n+    }\n+\n+    public VariablePointer(QName name){\n+        super(null);\n+        this.name = name;\n+        actual = false;\n+    }\n+\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    public Object getBaseValue(){\n+        if (!actual){\n+            throw new RuntimeException(\"Undefined variable: \" + name);\n+        }\n+        return variables.getVariable(name.getName());\n+    }\n+\n+    public Object getValue(){\n+        Object value = getBaseValue();\n+        if (index != WHOLE_COLLECTION){\n+            return ValueUtils.getValue(value, index);\n+        }\n+        return value;\n+    }\n+\n+    public void setValue(Object value){\n+        if (!actual){\n+            throw new RuntimeException(\"Cannot set undefined variable: \" + name);\n+        }\n+        valuePointer = null;\n+        if (index != WHOLE_COLLECTION){\n+            Object collection = getBaseValue();\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+        else {\n+            variables.declareVariable(name.getName(), value);\n+        }\n+    }\n+\n+    public boolean isActual(){\n+        return actual;\n+    }\n+\n+    public NodePointer getValuePointer(){\n+        if (valuePointer == null){\n+            Object value = null;\n+            if (actual){\n+                value = getValue();\n+            }\n+            valuePointer = NodePointer.newChildNodePointer(this, null, value);\n+        }\n+        return valuePointer;\n+    }\n+\n+    public int getLength(){\n+        if (actual){\n+            return super.getLength();\n+        }\n+        return 0;\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        if (actual){\n+            setValue(value);\n+            return;\n+        }\n+        createPath(context).setValue(value);\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (!actual){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory.declareVariable(context, name.toString())){\n+                throw new RuntimeException(\"Factory cannot define variable '\" + name + \"' for path: \" + asPath());\n+            }\n+            findVariables(context);\n+            // Assert: actual == true\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        Object collection = createCollection(context, index);\n+        if (!isActual() || (index != 0 && index != WHOLE_COLLECTION)){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            // Ignore the name passed as a parameter, pass the name of the variable instead\n+            if (!factory.createObject(context, this, collection, getName().toString(), index)){\n+                throw new RuntimeException(\"Factory could not create object path: \" + asPath());\n+            }\n+            setIndex(index);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     */\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        Object collection = createCollection(context, index);\n+        ValueUtils.setValue(collection, index, value);\n+    }\n+\n+    private Object createCollection(JXPathContext context, int index){\n+        createPath(context);\n+\n+        Object collection = getBaseValue();\n+        if (collection == null){\n+            throw new RuntimeException(\"Factory did not assign a collection to variable '\" + name + \"' for path: \" + asPath());\n+        }\n+\n+        if (index == WHOLE_COLLECTION){\n+            index = 0;\n+        }\n+        else if (index < 0){\n+            throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()){\n+            collection = ValueUtils.expandCollection(collection, index + 1);\n+            variables.declareVariable(name.toString(), collection);\n+        }\n+\n+        return collection;\n+    }\n+\n+    protected void findVariables(JXPathContext context){\n+        valuePointer = null;\n+        JXPathContext varCtx = context;\n+        while (varCtx != null){\n+            variables = varCtx.getVariables();\n+            if (variables.isDeclaredVariable(name.toString())){\n+                actual = true;\n+                break;\n+            }\n+            varCtx = varCtx.getParentContext();\n+            variables = null;\n+        }\n+    }\n+\n+    public int hashCode(){\n+        return (actual ? System.identityHashCode(variables): 0) + name.hashCode() + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof VariablePointer)){\n+            return false;\n+        }\n+\n+        VariablePointer other = (VariablePointer)object;\n+        return variables == other.variables &&\n+                name.equals(other.name) &&\n+                index == other.index;\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append('$');\n+        buffer.append(name);\n+        if (!actual){\n+            if (index != WHOLE_COLLECTION){\n+                buffer.append('[').append(index + 1).append(']');\n+            }\n+        }\n+        else if (index != WHOLE_COLLECTION && (getValue() == null || isCollection())){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        return getValuePointer().childIterator(test, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return getValuePointer().attributeIterator(name);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return getValuePointer().namespaceIterator();\n+    }\n+\n+    public NodePointer namespacePointer(String name){\n+        return getValuePointer().namespacePointer(name);\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return getValuePointer().testNode(nodeTest);\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new RuntimeException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanAttributeIterator.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * An iterator of attributes of a JavaBean. Currently supports only one\n+ * attribute - \"lang\".\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class BeanAttributeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private QName name;\n+    private int position = 0;\n+\n+    public BeanAttributeIterator(NodePointer parent, QName name){\n+        this.parent = parent;\n+        this.name = name;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        return new LangAttributePointer(parent);\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position == 1 && name.getPrefix() != null && name.getPrefix().equals(\"xml\") &&\n+            (name.getName().equals(\"lang\") || name.getName().equals(\"*\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * A Pointer that points to a JavaBean or a collection. It is the first element of\n+ * a path, following elements will by of type PropertyPointer.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class BeanPointer extends PropertyOwnerPointer {\n+    private QName name;\n+    private Object bean;\n+    private JXPathBeanInfo beanInfo;\n+    private PropertyDescriptor propertyDescriptors[];\n+    private String[] names;\n+\n+    public BeanPointer(QName name, Object bean, JXPathBeanInfo beanInfo, Locale locale){\n+        super(null, locale);\n+        this.name = name;\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    /**\n+     * @param name is the name given to the first node\n+     */\n+    public BeanPointer(NodePointer parent, QName name, Object bean, JXPathBeanInfo beanInfo){\n+        super(parent);\n+        this.name = name;\n+        this.bean = bean;\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    public PropertyPointer getPropertyPointer(){\n+        return new BeanPropertyPointer(this, beanInfo);\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the bean itself\n+     */\n+    public Object getBaseValue(){\n+        return bean;\n+    }\n+\n+    /**\n+     * Throws an exception if you try to change the root element.\n+     */\n+    public void setValue(Object value){\n+        if (parent instanceof PropertyPointer){\n+            parent.setValue(value);\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+        }\n+    }\n+\n+    /**\n+     * If the bean is a collection, returns the length of that collection,\n+     * otherwise returns 1.\n+     */\n+    public int getLength(){\n+        return ValueUtils.getLength(getBaseValue());\n+    }\n+\n+    public int hashCode(){\n+        return name == null ? 0 : name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof BeanPointer)){\n+            return false;\n+        }\n+\n+        BeanPointer other = (BeanPointer)object;\n+        if ((name == null && other.name != null) ||\n+                (name != null && !name.equals(other.name))){\n+            return false;\n+        }\n+\n+        if (bean instanceof Number || bean instanceof String || bean instanceof Boolean){\n+            return bean.equals(other.bean);\n+        }\n+        return bean == other.bean;\n+    }\n+\n+    /**\n+     * Empty string\n+     */\n+    public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n+        else if (bean == null){\n+            return \"null()\";\n+        }\n+        else if (bean instanceof Number){\n+            String string = bean.toString();\n+            if (string.endsWith(\".0\")){\n+                string = string.substring(0, string.length() - 2);\n+            }\n+            return string;\n+        }\n+        else if (bean instanceof Boolean){\n+            return ((Boolean)bean).booleanValue() ? \"true()\" : \"false()\";\n+        }\n+        else if (bean instanceof String){\n+            return \"'\" + bean + \"'\";\n+        }\n+        return \"\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPointerFactory.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for JavaBeans.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class BeanPointerFactory implements NodePointerFactory {\n+\n+    public static final int BEAN_POINTER_FACTORY_ORDER = 900;\n+\n+    public int getOrder(){\n+        return BEAN_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        return new BeanPointer(name, bean, bi, locale);\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        parent = (NodePointer)parent.clone();\n+        if (bean == null){\n+            return new NullPointer(parent, name);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        return new BeanPointer(parent, name, bean, bi);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/BeanPropertyPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Pointer pointing to a property of a JavaBean.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class BeanPropertyPointer extends PropertyPointer {\n+    private String propertyName;\n+    private JXPathBeanInfo beanInfo;\n+    private PropertyDescriptor propertyDescriptors[];\n+    private PropertyDescriptor propertyDescriptor;\n+    private String[] names;\n+    private static final Object UNINITIALIZED = new Object();\n+    private Object baseValue = UNINITIALIZED;\n+    private Object value = UNINITIALIZED;\n+\n+    public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo){\n+        super(parent);\n+        this.beanInfo = beanInfo;\n+    }\n+\n+    /**\n+     * This type of node is auxiliary.\n+     */\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    /**\n+     * Number of the bean's properties.\n+     */\n+    public int getPropertyCount(){\n+        return getPropertyDescriptors().length;\n+    }\n+\n+    /**\n+     * Names of all properties, sorted alphabetically\n+     */\n+    public String[] getPropertyNames(){\n+        if (names == null){\n+            PropertyDescriptor pds[] = getPropertyDescriptors();\n+            names = new String[pds.length];\n+            for (int i = 0; i < names.length; i++){\n+                names[i] = pds[i].getName();\n+            }\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Select a property by name\n+     */\n+    public void setPropertyName(String propertyName){\n+        setPropertyIndex(UNSPECIFIED_PROPERTY);\n+        this.propertyName = propertyName;\n+    }\n+\n+    /**\n+     * Selects a property by its offset in the alphabetically sorted list.\n+     */\n+    public void setPropertyIndex(int index){\n+        if (propertyIndex != index){\n+            super.setPropertyIndex(index);\n+            propertyName = null;\n+            propertyDescriptor = null;\n+            baseValue = UNINITIALIZED;\n+            value = UNINITIALIZED;\n+        }\n+    }\n+\n+    /**\n+     * If the property contains a collection, then the length of that\n+     * collection, otherwise - 1.\n+     */\n+    public int getLength(){\n+        return ValueUtils.getLength(getBaseValue());\n+    }\n+\n+    /**\n+     * The value of the currently selected property.\n+     */\n+    public Object getBaseValue(){\n+        if (baseValue == UNINITIALIZED){\n+            PropertyDescriptor pd = getPropertyDescriptor();\n+            if (pd == null){\n+                return null;\n+            }\n+            baseValue = ValueUtils.getValue(getBean(), pd);\n+        }\n+        return baseValue;\n+    }\n+\n+    public void setIndex(int index){\n+        if (this.index != index){\n+            super.setIndex(index);\n+            value = UNINITIALIZED;\n+        }\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, the value of the property, otherwise\n+     * the value of the index'th element of the collection represented by the\n+     * property. If the property is not a collection, index should be zero\n+     * and the value will be the property itself.\n+     */\n+    public Object getValue(){\n+        if (value == UNINITIALIZED){\n+            PropertyDescriptor pd = getPropertyDescriptor();\n+            if (pd == null){\n+                value = null;\n+            }\n+            else {\n+                if (index == WHOLE_COLLECTION){\n+                    value = ValueUtils.getValue(getBean(), pd);\n+                }\n+                else {\n+                    value = ValueUtils.getValue(getBean(), pd, index);\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    protected boolean isActualProperty(){\n+        return getPropertyDescriptor() != null;\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n+     * change the value of the index'th element of the collection\n+     * represented by the property.\n+     */\n+    public void setValue(Object value){\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            throw new RuntimeException(\"Cannot set property: \" + asPath() + \" - no such property\");\n+        }\n+\n+        if (index == WHOLE_COLLECTION){\n+            ValueUtils.setValue(getBean(), pd, value);\n+        }\n+        else {\n+            ValueUtils.setValue(getBean(), pd, index, value);\n+        }\n+        this.value = value;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (getValue() == null){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n+                throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+            }\n+            baseValue = UNINITIALIZED;\n+            value = UNINITIALIZED;\n+        }\n+        return this;\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        return createPath(context).getValuePointer().createChild(context, name, index);\n+//        NodePointer pointer = setIndexExpandingCollection(context, name, index);\n+//        return pointer.createPath(context);\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        createPath(context).getValuePointer().createChild(context, name, index, value);\n+//        NodePointer pointer = setIndexExpandingCollection(context, name, index);\n+//        pointer.createPath(context, value);\n+    }\n+\n+    private BeanPropertyPointer setIndexExpandingCollection(JXPathContext context, QName name, int index){\n+        // Ignore the name passed to us, use our own information\n+        PropertyDescriptor pd = getPropertyDescriptor();\n+        if (pd == null){\n+            throw new RuntimeException(\"Cannot create path: \" + asPath() +\n+                    \" - property '\" + getPropertyName() + \"' does not exist\");\n+        }\n+\n+        if (index < 0){\n+            throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), index)){\n+                throw new RuntimeException(\"Factory could not create path \" + asPath());\n+            }\n+        }\n+        BeanPropertyPointer clone = (BeanPropertyPointer)this.clone();\n+        clone.baseValue = UNINITIALIZED;\n+        clone.value = UNINITIALIZED;\n+        clone.setIndex(index);\n+        return clone;\n+    }\n+\n+    /**\n+     * Name of the currently selected property.\n+     */\n+    public String getPropertyName(){\n+        if (propertyName == null){\n+            PropertyDescriptor pd = getPropertyDescriptor();\n+            if (pd != null){\n+                propertyName = pd.getName();\n+            }\n+        }\n+        return propertyName != null ? propertyName : \"*\";\n+    }\n+\n+    /**\n+     * Finds the property descriptor corresponding to the current property index.\n+     */\n+    private PropertyDescriptor getPropertyDescriptor(){\n+        if (propertyDescriptor == null){\n+            int inx = getPropertyIndex();\n+            if (inx == UNSPECIFIED_PROPERTY){\n+                propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName);\n+            }\n+            else {\n+                PropertyDescriptor propertyDescriptors[] = getPropertyDescriptors();\n+                if (inx >=0 && inx < propertyDescriptors.length){\n+                    propertyDescriptor = propertyDescriptors[inx];\n+                }\n+                else {\n+                    propertyDescriptor = null;\n+                }\n+            }\n+        }\n+        return propertyDescriptor;\n+    }\n+\n+    protected PropertyDescriptor[] getPropertyDescriptors(){\n+        if (propertyDescriptors == null){\n+            propertyDescriptors = beanInfo.getPropertyDescriptors();\n+        }\n+        return propertyDescriptors;\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new RuntimeException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Transparent pointer to a collection (array or Collection).\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class CollectionPointer extends NodePointer {\n+    private Object collection;\n+    private NodePointer valuePointer;\n+\n+    public CollectionPointer(Object collection, Locale locale){\n+        super(null, locale);\n+        this.collection = collection;\n+    }\n+\n+    public CollectionPointer(NodePointer parent, Object collection){\n+        super(parent);\n+        this.collection = collection;\n+    }\n+\n+    public QName getName(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return collection;\n+    }\n+\n+    public Object getValue(){\n+        if (index != WHOLE_COLLECTION){\n+            return ValueUtils.getValue(collection, index);\n+        }\n+        return collection;\n+    }\n+\n+    public void setValue(Object value){\n+        if (index == WHOLE_COLLECTION){\n+            parent.setValue(value);\n+        }\n+        else {\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+    }\n+\n+    public NodePointer getValuePointer(){\n+        if (valuePointer == null){\n+            Object value = getValue();\n+            valuePointer = NodePointer.newChildNodePointer(this, getName(), value);\n+        }\n+        return valuePointer;\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        if (parent instanceof PropertyPointer){\n+            parent.createChild(context, name, index, value);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (ValueUtils.getLength(collection) <= index){\n+                ValueUtils.expandCollection(getValue(), index + 1);\n+            }\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (parent instanceof PropertyPointer){\n+            return parent.createPath(context);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (ValueUtils.getLength(collection) <= index){\n+                ValueUtils.expandCollection(getValue(), index + 1);\n+            }\n+            return this;\n+        }\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        if (parent instanceof PropertyPointer){\n+            return parent.createChild(context, name, index);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (ValueUtils.getLength(collection) <= index){\n+                ValueUtils.expandCollection(getValue(), index + 1);\n+            }\n+            return this;\n+        }\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(collection) + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof CollectionPointer)){\n+            return false;\n+        }\n+\n+        CollectionPointer other = (CollectionPointer)object;\n+        return collection == other.collection &&\n+                index == other.index;\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        if (index == WHOLE_COLLECTION){\n+            return null;\n+        }\n+        return getValuePointer().childIterator(test, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return getValuePointer().attributeIterator(name);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return getValuePointer().namespaceIterator();\n+    }\n+\n+    public NodePointer namespacePointer(String namespace){\n+        return getValuePointer().namespacePointer(namespace);\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return getValuePointer().testNode(nodeTest);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/CollectionPointerFactory.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.Container;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for stand-alone collections.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class CollectionPointerFactory implements NodePointerFactory {\n+\n+    public static final int COLLECTION_POINTER_FACTORY_ORDER = 10;\n+\n+    public int getOrder(){\n+        return COLLECTION_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        if (ValueUtils.isCollection(bean)){\n+            return new CollectionPointer(bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (ValueUtils.isCollection(bean)){\n+            return new CollectionPointer(parent, bean);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * A Pointer that points to an object with Dynamic Properties. It is used\n+ * for the first element of a path; following elements will by of type PropertyPointer.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DynamicPointer extends PropertyOwnerPointer {\n+    private QName name;\n+    private Object bean;\n+    private DynamicPropertyHandler handler;\n+    private String[] names;\n+\n+    public DynamicPointer(QName name, Object bean, DynamicPropertyHandler handler, Locale locale){\n+        super(null, locale);\n+        this.name = name;\n+        this.bean = bean;\n+        this.handler = handler;\n+    }\n+\n+    public DynamicPointer(NodePointer parent, QName name, Object bean, DynamicPropertyHandler handler){\n+        super(parent);\n+        this.name = name;\n+        this.bean = bean;\n+        this.handler = handler;\n+    }\n+\n+    public PropertyPointer getPropertyPointer(){\n+        return new DynamicPropertyPointer(this, handler);\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the DP object iself.\n+     */\n+    public Object getBaseValue(){\n+        return bean;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot replace the root object\");\n+    }\n+\n+    /**\n+     * If the bean is a collection, returns the length of that collection,\n+     * otherwise returns 1.\n+     */\n+    public int getLength(){\n+        return ValueUtils.getLength(getBaseValue());\n+    }\n+\n+    /**\n+     * Empty string\n+     */\n+    public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n+        return \"\";\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(bean) + name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DynamicPointer)){\n+            return false;\n+        }\n+\n+        DynamicPointer other = (DynamicPointer)object;\n+        return bean == other.bean && name.equals(other.name);\n+    }\n+\n+    public String toString(){\n+        return bean.getClass().getName() + \"@\" + System.identityHashCode(bean) +\n+            \"(\" + name + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPointerFactory.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for Dynamic classes like Map.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DynamicPointerFactory implements NodePointerFactory {\n+\n+    public static final int DYNAMIC_POINTER_FACTORY_ORDER = 800;\n+\n+    public int getOrder(){\n+        return DYNAMIC_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(name, bean, handler, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+//        if (bean == null){\n+//            return new NullPropertyPointer(parent);\n+//        }\n+//\n+//        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+//        if (bi.isDynamic()){\n+//            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+//            return new DynamicPropertyPointer(parent, handler);\n+//        }\n+//        parent = (NodePointer)parent.clone();\n+        if (bean == null){\n+            return new NullPointer(parent, name);\n+        }\n+\n+        JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass());\n+        if (bi.isDynamic()){\n+            DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass());\n+            return new DynamicPointer(parent, name, bean, handler);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/DynamicPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/Attic/DynamicPropertyPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Pointer pointing to a property of an object with dynamic properties.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DynamicPropertyPointer extends PropertyPointer {\n+    private DynamicPropertyHandler handler;\n+    private String name;\n+    private String[] names;\n+    private String requiredPropertyName;\n+\n+    public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler){\n+        super(parent);\n+        this.handler = handler;\n+    }\n+\n+    /**\n+     * This type of node is auxiliary.\n+     */\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    /**\n+     * Number of the DP object's properties.\n+     */\n+    public int getPropertyCount(){\n+        return getPropertyNames().length;\n+    }\n+\n+    /**\n+     * Names of all properties, sorted alphabetically\n+     */\n+    public String[] getPropertyNames(){\n+        if (names == null){\n+            String allNames[] = handler.getPropertyNames(getBean());\n+            names = new String[allNames.length];\n+            for (int i = 0; i < names.length; i++){\n+                names[i] = allNames[i];\n+            }\n+            Arrays.sort(names);\n+            if (requiredPropertyName != null){\n+                int inx = Arrays.binarySearch(names, requiredPropertyName);\n+                if (inx < 0){\n+                    allNames = names;\n+                    names = new String[allNames.length + 1];\n+                    names[0] = requiredPropertyName;\n+                    System.arraycopy(allNames, 0, names, 1, allNames.length);\n+                    Arrays.sort(names);\n+                }\n+            }\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Returns the name of the currently selected property or \"*\"\n+     * if none has been selected.\n+     */\n+    public String getPropertyName(){\n+        if (name == null){\n+            String names[] = getPropertyNames();\n+            if (propertyIndex >=0 && propertyIndex < names.length){\n+                name = names[propertyIndex];\n+            }\n+            else {\n+                name = \"*\";\n+            }\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Select a property by name.  If the supplied name is\n+     * not one of the object's existing properties, it implicitly\n+     * adds this name to the object's property name list. It does not\n+     * set the property value though. In order to set the property\n+     * value, call setValue().\n+     */\n+    public void setPropertyName(String propertyName){\n+        setPropertyIndex(UNSPECIFIED_PROPERTY);\n+        this.name = propertyName;\n+        requiredPropertyName = propertyName;\n+        if (names != null && Arrays.binarySearch(names, propertyName) < 0){\n+            names = null;\n+        }\n+    }\n+\n+    /**\n+     * Index of the currently selected property in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public int getPropertyIndex(){\n+        if (propertyIndex == UNSPECIFIED_PROPERTY){\n+            String names[] = getPropertyNames();\n+            for (int i = 0; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    setPropertyIndex(i);\n+                    break;\n+                }\n+            }\n+        }\n+        return super.getPropertyIndex();\n+    }\n+\n+    /**\n+     * Index a property by its index in the list of all\n+     * properties sorted alphabetically.\n+     */\n+    public void setPropertyIndex(int index){\n+        if (propertyIndex != index){\n+            super.setPropertyIndex(index);\n+            name = null;\n+        }\n+    }\n+\n+    /**\n+     * If the property contains a collection, then the length of that\n+     * collection, otherwise - 1.\n+     */\n+    public int getLength(){\n+        return ValueUtils.getLength(getValue());\n+    }\n+\n+    /**\n+     * Returns the value of the property, not an element of the collection\n+     * represented by the property, if any.\n+     */\n+    public Object getBaseValue(){\n+        return handler.getProperty(getBean(), getPropertyName());\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, the value of the property, otherwise\n+     * the value of the index'th element of the collection represented by the\n+     * property. If the property is not a collection, index should be zero\n+     * and the value will be the property itself.\n+     */\n+    public Object getValue(){\n+        Object value;\n+        if (index == WHOLE_COLLECTION){\n+            value = handler.getProperty(getBean(), getPropertyName());\n+        }\n+        else {\n+            value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * A dynamic property is always considered actual - all keys are apparently\n+     * existing with possibly the value of null.\n+     */\n+    protected boolean isActualProperty(){\n+        return true;\n+    }\n+\n+    /**\n+     * If index == WHOLE_COLLECTION, change the value of the property, otherwise\n+     * change the value of the index'th element of the collection\n+     * represented by the property.\n+     */\n+    public void setValue(Object value){\n+        if (index == WHOLE_COLLECTION){\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            ValueUtils.setValue(handler.getProperty(getBean(), getPropertyName()), index, value);\n+        }\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        createChild(context, getName(), index, value);\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        // Ignore the name passed to us, use our own data\n+        if (index == WHOLE_COLLECTION){\n+            handler.setProperty(getBean(), getPropertyName(), value);\n+        }\n+        else {\n+            Object collection = getBaseValue();\n+            if (collection == null){\n+                AbstractFactory factory = getAbstractFactory(context);\n+                if (!factory.createObject(context, this, getBean(), getPropertyName(), 0)){\n+                    throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+                }\n+                collection = getBaseValue();\n+            }\n+\n+            if (index < 0){\n+                throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+            }\n+\n+            if (index >= getLength()){\n+                collection = ValueUtils.expandCollection(collection, index + 1);\n+                handler.setProperty(getBean(), getPropertyName(), collection);\n+            }\n+\n+            ValueUtils.setValue(collection, index, value);\n+        }\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        // Ignore the name passed to us, use our own data\n+        Object collection = getBaseValue();\n+        if (collection == null){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), 0)){\n+                throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+            }\n+            collection = getBaseValue();\n+        }\n+\n+        if (index < 0){\n+            throw new RuntimeException(\"Index is less than 1: \" + asPath());\n+        }\n+\n+        if (index >= getLength()){\n+            collection = ValueUtils.expandCollection(collection, index + 1);\n+            handler.setProperty(getBean(), getPropertyName(), collection);\n+        }\n+\n+        DynamicPropertyPointer pointer = (DynamicPropertyPointer)this.clone();\n+        pointer.setIndex(index);\n+        return pointer;\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (getValue() == null){\n+            AbstractFactory factory = getAbstractFactory(context);\n+            int inx = (index == WHOLE_COLLECTION ? 0 : index);\n+            if (!factory.createObject(context, this, getBean(), getPropertyName(), inx)){\n+                throw new RuntimeException(\"Factory could not create an object for path: \" + asPath());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(getParent().asPath());\n+        buffer.append(\"[@name='\");\n+        buffer.append(escape(getPropertyName()));\n+        buffer.append(\"']\");\n+        if (index != WHOLE_COLLECTION && isCollection()){\n+            buffer.append('[').append(index + 1).append(']');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new RuntimeException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/LangAttributePointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.util.*;\n+\n+/**\n+ * A Pointer that points to the \"lang\" attribute of a JavaBean. The value\n+ * of the attribute is based on the locale supplied to it in the constructor.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class LangAttributePointer extends NodePointer {\n+    public LangAttributePointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public QName getName(){\n+        return new QName(null, \"lang\");\n+    }\n+\n+    public QName getExpandedName(){\n+        return getName();\n+    }\n+\n+    public String getNamespaceURI(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return parent.getLocale().toString().replace('_', '-');\n+    }\n+\n+    public Object getValue(){\n+        return getBaseValue();\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot change locale using the 'lang' attribute\");\n+    }\n+\n+    /**\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append(\"@xml:lang\");\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        return 0;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof LangAttributePointer)){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public boolean testNode(NodeTest test){\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullElementPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * Used when there is a need to construct a Pointer for\n+ * a collection element that does not exist.  For example,\n+ * if the path is \"foo[3]\", but the collection \"foo\" only has\n+ * one element or is empty or is null, the NullElementPointer\n+ * can be used to capture this situatuin without putting\n+ * a regular NodePointer into an invalid state.  Just create\n+ * a NullElementPointer with index 2 (= 3 - 1) and a \"foo\" pointer\n+ * as the parent.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class NullElementPointer extends PropertyOwnerPointer {\n+\n+    public NullElementPointer(NodePointer parent, int index){\n+        super(parent);\n+        this.index = index;\n+    }\n+\n+    public QName getName(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public Object getValue(){\n+        return null;\n+    }\n+\n+    public PropertyPointer getPropertyPointer(){\n+        return new NullPropertyPointer(this);\n+    }\n+\n+    public NodePointer getValuePointer(){\n+        return new NullPointer(this, getName());\n+    }\n+\n+    public void setValue(Object value){\n+        if (parent instanceof PropertyPointer){\n+            parent.setValue(value);\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property\");\n+        }\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        if (parent instanceof PropertyPointer){\n+            parent.getParent().createChild(context, parent.getName(), index, value);\n+        }\n+        else {\n+            parent.createChild(context, null, index, value);\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (parent instanceof PropertyPointer){\n+            return parent.getParent().createChild(context, parent.getName(), index);\n+        }\n+        else {\n+            return parent.createChild(context, null, index);\n+        }\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        if (index != 0 && index != WHOLE_COLLECTION){\n+            throw new RuntimeException(\"Internal error. \" +\n+                \"Indexed passed to NullElementPointer.createChild() is not 0: \" + index);\n+        }\n+        if (parent instanceof PropertyPointer){\n+            parent.getParent().createChild(context, parent.getName(), getIndex(), value);\n+        }\n+        else {\n+            parent.createChild(context, name, getIndex(), value);\n+        }\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        if (index != 0 && index != WHOLE_COLLECTION){\n+            throw new RuntimeException(\"Internal error. \" +\n+                \"Indexed passed to NullElementPointer.createChild() is not 0: \" + index);\n+        }\n+        if (parent instanceof PropertyPointer){\n+            return parent.getParent().createChild(context, parent.getName(), getIndex());\n+        }\n+        else {\n+            return parent.createChild(context, name, getIndex());\n+        }\n+    }\n+\n+    public int hashCode(){\n+        return getParent().hashCode() + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NullElementPointer)){\n+            return false;\n+        }\n+\n+        NullElementPointer other = (NullElementPointer)object;\n+        return getParent() == other.getParent() &&\n+            index == other.index;\n+    }\n+\n+    public String asPath(){\n+        return parent.asPath() + \"[\" + (index + 1) + \"]\";\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class NullPointer extends PropertyOwnerPointer {\n+    private QName name;\n+\n+    public NullPointer(QName name, Locale locale){\n+        super(null, locale);\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Used for the root node\n+     */\n+    public NullPointer(NodePointer parent, QName name){\n+        super(parent);\n+        this.name = name;\n+    }\n+\n+    public QName getName(){\n+        return name;\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public void setValue(Object value){\n+        if (parent instanceof PropertyPointer){\n+            parent.setValue(value);\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\"Cannot setValue of an object that is not some other object's property/child\");\n+        }\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n+    public PropertyPointer getPropertyPointer(){\n+        return new NullPropertyPointer(this);\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        if (parent != null){\n+            if (parent instanceof PropertyPointer){\n+                parent.createPath(context, value);\n+            }\n+            else {\n+                parent.createChild(context, getName(), 0, value);\n+            }\n+        }\n+        else {\n+            throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+        }\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        if (parent != null){\n+            if (parent instanceof PropertyPointer){\n+                return parent.createPath(context).getValuePointer();\n+            }\n+            else {\n+                return parent.createChild(context, getName(), 0).getValuePointer();\n+            }\n+        }\n+        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        if (parent != null){\n+            NodePointer pointer = createPath(context);\n+            if (pointer != null){\n+                pointer.getValuePointer().createChild(context, name, index, value);\n+                return;\n+            }\n+        }\n+        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        if (parent != null){\n+            NodePointer pointer = createPath(context);\n+            if (pointer != null){\n+                return pointer.createChild(context, name, index);\n+            }\n+        }\n+        throw new UnsupportedOperationException(\"Cannot create the root object: \" + asPath());\n+    }\n+\n+    public int hashCode(){\n+        return name == null ? 0 : name.hashCode();\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NullPointer)){\n+            return false;\n+        }\n+\n+        NullPointer other = (NullPointer)object;\n+        return (name == null && other.name == null) ||\n+               (name != null && name.equals(other.name));\n+    }\n+\n+    public String asPath(){\n+        if (parent != null){\n+            return super.asPath();\n+        }\n+        return \"null()\";\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class NullPropertyPointer extends PropertyPointer {\n+\n+    private String propertyName = \"*\";\n+    private boolean dynamic = false;\n+\n+    /**\n+     */\n+    public NullPropertyPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public QName getName(){\n+        return new QName(null, propertyName);\n+    }\n+\n+    public void setPropertyIndex(int index){\n+    }\n+\n+    public int getLength(){\n+        return 0;\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public Object getValue(){\n+        return null;\n+    }\n+\n+    public NodePointer getValuePointer(){\n+        return new NullPointer(this,  new QName(null, getPropertyName()));\n+    }\n+\n+    protected boolean isActualProperty(){\n+        return false;\n+    }\n+\n+    public boolean isActual(){\n+        return false;\n+    }\n+\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    public void setValue(Object value){\n+        throw new RuntimeException(\"Cannot set property \" + asPath() +\n+            \", the target object is null\");\n+    }\n+\n+    public NodePointer createPath(JXPathContext context){\n+        return parent.createChild(context, getName(), getIndex());\n+    }\n+\n+    public void createPath(JXPathContext context, Object value){\n+        parent.createChild(context, getName(), getIndex(), value);\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        createPath(context).createChild(context, name, index, value);\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        return createPath(context).createChild(context, name, index);\n+    }\n+\n+    public String getPropertyName(){\n+        return propertyName;\n+    }\n+\n+    public void setPropertyName(String propertyName){\n+        this.propertyName = propertyName;\n+    }\n+\n+    public void setDynamic(boolean flag){\n+        dynamic = flag;\n+    }\n+\n+    public boolean isCollection(){\n+        return getIndex() != WHOLE_COLLECTION;\n+    }\n+\n+    public int getPropertyCount(){\n+        return 0;\n+    }\n+\n+    public String[] getPropertyNames(){\n+        return new String[0];\n+    }\n+\n+    public String asPath(){\n+        if (!dynamic){\n+            return super.asPath();\n+        }\n+        else {\n+            StringBuffer buffer = new StringBuffer();\n+            buffer.append(getParent().asPath());\n+            buffer.append(\"[@name='\");\n+            buffer.append(escape(getPropertyName()));\n+            buffer.append(\"']\");\n+            if (index != WHOLE_COLLECTION){\n+                buffer.append('[').append(index + 1).append(']');\n+            }\n+            return buffer.toString();\n+        }\n+    }\n+\n+    private String escape(String string){\n+        int index = string.indexOf('\\'');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&apos;\" + string.substring(index + 1);\n+            index = string.indexOf('\\'');\n+        }\n+        index = string.indexOf('\\\"');\n+        while (index != -1){\n+            string = string.substring(0, index) + \"&quot;\" + string.substring(index + 1);\n+            index = string.indexOf('\\\"');\n+        }\n+        return string;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyIterator.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+/**\n+ * Iterates property values of an object pointed at with a PropertyOwnerPointer.\n+ * Examples of such objects are JavaBeans and objects with Dynamic Properties.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class PropertyIterator implements NodeIterator {\n+    boolean empty = false;\n+    private boolean reverse;\n+    private String name;\n+    private int startIndex = 0;\n+    private boolean targetReady = false;\n+    private int position = 0;\n+    private PropertyPointer propertyNodePointer;\n+    private int startPropertyIndex;\n+\n+    private boolean ready = false;\n+    private boolean includeStart = false;\n+\n+    public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith){\n+        propertyNodePointer = pointer.getPropertyPointer();\n+        this.name = name;\n+        this.reverse = reverse;\n+        this.includeStart = true;\n+        if (reverse){\n+            this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY;\n+            this.startIndex = -1;\n+        }\n+        if (startWith != null){\n+            while (startWith != null && startWith.getParent() != pointer){\n+                startWith = startWith.getParent();\n+            }\n+            if (startWith == null){\n+                throw new RuntimeException(\n+                    \"PropertyIerator startWith parameter is not a child of the supplied parent\");\n+            }\n+            this.startPropertyIndex = ((PropertyPointer)startWith).getPropertyIndex();\n+            this.startIndex = startWith.getIndex();\n+            this.includeStart = false;\n+            if (reverse && startIndex == -1){\n+                this.includeStart = true;\n+            }\n+        }\n+    }\n+\n+    public void reset(){\n+        position = 0;\n+        targetReady = false;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (name != null){\n+                if (!targetReady){\n+                    prepare();\n+                }\n+                // If there is no such property - return null\n+                if (empty){\n+                    return null;\n+                }\n+            }\n+            else {\n+                if (!setPosition(1)){\n+                    return null;\n+                }\n+                reset();\n+            }\n+        }\n+        return propertyNodePointer.getValuePointer();\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        if (name != null){\n+            return setPositionIndividualProperty(position);\n+        }\n+        else {\n+            return setPositionAllProperties(position);\n+        }\n+    }\n+\n+    private boolean setPositionIndividualProperty(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        if (!targetReady){\n+            prepare();\n+        }\n+\n+        if (empty){\n+            return false;\n+        }\n+\n+        int length = propertyNodePointer.getLength();   // TBD: cache length\n+        int index;\n+        if (!reverse){\n+            index = position + startIndex;\n+            if (!includeStart){\n+                index++;\n+            }\n+            if (index > length){\n+                return false;\n+            }\n+        }\n+        else {\n+            int end = startIndex;\n+            if (end == -1){\n+                end = length - 1;\n+            }\n+            index = end - position + 2;\n+            if (!includeStart){\n+                index--;\n+            }\n+            if (index < 1){\n+                return false;\n+            }\n+        }\n+        propertyNodePointer.setIndex(index - 1);\n+        return true;\n+    }\n+\n+    private boolean setPositionAllProperties(int position){\n+        this.position = position;\n+        if (position < 1){\n+            return false;\n+        }\n+\n+        int offset;\n+        int count = propertyNodePointer.getPropertyCount();\n+        if (!reverse){\n+            int index = 1;\n+            for (int i = startPropertyIndex; i < count; i++){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    length -= startIndex;\n+                    if (!includeStart){\n+                        length--;\n+                    }\n+                    offset = startIndex + position - index;\n+                    if (!includeStart){\n+                        offset++;\n+                    }\n+                }\n+                else {\n+                    offset = position - index;\n+                }\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        else {\n+            int index = 1;\n+            int start = startPropertyIndex;\n+            if (start == PropertyPointer.UNSPECIFIED_PROPERTY){\n+                start = count - 1;\n+            }\n+            for (int i = start; i >= 0; i--){\n+                propertyNodePointer.setPropertyIndex(i);\n+                int length = propertyNodePointer.getLength();\n+                if (i == startPropertyIndex){\n+                    int end = startIndex;\n+                    if (end == -1){\n+                        end = length - 1;\n+                    }\n+                    length = end + 1;\n+                    offset = end - position + 1;\n+                    if (!includeStart){\n+                        offset--;\n+                        length--;\n+                    }\n+                }\n+                else {\n+                    offset = length - (position - index) - 1;\n+                }\n+\n+                if (index <= position && position < index + length){\n+                    propertyNodePointer.setIndex(offset);\n+                    return true;\n+                }\n+                index += length;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void prepare(){\n+        targetReady = true;\n+        empty = true;\n+        // TBD: simplify\n+        if (propertyNodePointer instanceof DynamicPropertyPointer){\n+            propertyNodePointer.setPropertyName(name);\n+        }\n+\n+        String names[] = propertyNodePointer.getPropertyNames();\n+        if (!reverse){\n+//            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n+                startPropertyIndex = 0;\n+            }\n+            if (startIndex == NodePointer.WHOLE_COLLECTION){\n+                startIndex = 0;\n+            }\n+            for (int i = startPropertyIndex; i < names.length; i++){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = 0;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+        else {\n+//            int startPropertyIndex = propertyNodePointer.getPropertyIndex();\n+            if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY){\n+                startPropertyIndex = names.length - 1;\n+            }\n+            if (startIndex == NodePointer.WHOLE_COLLECTION){\n+                startIndex = -1;\n+            }\n+            for (int i = startPropertyIndex; i >= 0; i--){\n+                if (names[i].equals(name)){\n+                    propertyNodePointer.setPropertyIndex(i);\n+                    if (i != startPropertyIndex){\n+                        startIndex = -1;\n+                        includeStart = true;\n+                    }\n+                    empty = false;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyOwnerPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * A pointer describing a node that has properties, each of which could be\n+ * a collection.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public abstract class PropertyOwnerPointer extends NodePointer {\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        if (test == null){\n+            return new PropertyIterator(this, null, reverse, startWith);\n+        }\n+        else if (test instanceof NodeNameTest){\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            String property;\n+            if (!isDefaultNamespace(testName.getPrefix())){\n+                return null;\n+            }\n+            else if (testName.getName().equals(\"*\")){\n+                property = null;\n+            }\n+            else {\n+                property = testName.getName();\n+            }\n+            return new PropertyIterator(this, property, reverse, startWith);\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            if (((NodeTypeTest)test).getNodeType() == Compiler.NODE_TYPE_NODE){\n+                return new PropertyIterator(this, null, reverse, startWith);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return new BeanAttributeIterator(this, name);\n+    }\n+\n+    protected PropertyOwnerPointer(NodePointer parent, Locale locale){\n+        super(parent, locale);\n+    }\n+\n+    protected PropertyOwnerPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public boolean isCollection(){\n+        Object value = getBaseValue();\n+        return value != null && ValueUtils.isCollection(value);\n+    }\n+\n+    public void setIndex(int index){\n+        if (this.index != index){\n+            super.setIndex(index);\n+            value = UNINITIALIZED;\n+        }\n+    }\n+\n+    private static final Object UNINITIALIZED = new Object();\n+\n+    private Object value = UNINITIALIZED;\n+    public Object getValue(){\n+        if (value == UNINITIALIZED){\n+            if (index == WHOLE_COLLECTION){\n+                value = getBaseValue();\n+            }\n+            else {\n+                value = ValueUtils.getValue(getBaseValue(), index);\n+            }\n+        }\n+        return value;\n+    }\n+\n+    public abstract QName getName();\n+    public abstract void setValue(Object value);\n+\n+    public abstract PropertyPointer getPropertyPointer();\n+\n+    /**\n+     * If has an index, returns a pointer to the collection element,\n+     * otherwise returns the pointer itself.\n+     */\n+    public NodePointer getValuePointer() {\n+        return NodePointer.newChildNodePointer(this, getName(), getValue());\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        PropertyPointer prop = getPropertyPointer();\n+        prop.setPropertyName(name.getName());\n+        prop.setIndex(index);\n+        prop.createPath(context, value);\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        PropertyPointer prop = getPropertyPointer();\n+        prop.setPropertyName(name.getName());\n+        prop.setIndex(index);\n+        return prop.createPath(context);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.beans;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.*;\n+\n+import java.util.*;\n+\n+/**\n+ * A pointer allocated by a PropertyOwnerPointer to represent the value of\n+ * a property of the parent object.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public abstract class PropertyPointer extends NodePointer {\n+    public static int UNSPECIFIED_PROPERTY = Integer.MIN_VALUE;\n+\n+    protected int propertyIndex = UNSPECIFIED_PROPERTY;\n+    protected Object bean;\n+\n+    /**\n+     * Takes a javabean, a descriptor of a property of that object and\n+     * an offset within that property (starting with 0).\n+     */\n+    public PropertyPointer(NodePointer parent){\n+        super(parent);\n+    }\n+\n+    public boolean isCollection(){\n+        Object value = getBaseValue();\n+        return value != null && ValueUtils.isCollection(value);\n+    }\n+\n+    public int getPropertyIndex(){\n+        return propertyIndex;\n+    }\n+\n+    public void setPropertyIndex(int index){\n+        propertyIndex = index;\n+        index = WHOLE_COLLECTION;\n+    }\n+\n+    public Object getBean(){\n+        if (bean == null){\n+            bean = getParent().getValue();\n+        }\n+        return bean;\n+    }\n+\n+    public QName getName(){\n+        return new QName(null, getPropertyName());\n+    }\n+\n+    public abstract String getPropertyName();\n+\n+    public abstract void setPropertyName(String propertyName);\n+\n+    public abstract int getPropertyCount();\n+\n+    public abstract String[] getPropertyNames();\n+\n+    protected abstract boolean isActualProperty();\n+\n+    public boolean isActual(){\n+        if (!isActualProperty()){\n+            return false;\n+        }\n+\n+        return super.isActual();\n+    }\n+\n+    private static final Object UNINITIALIZED = new Object();\n+\n+    private Object value = UNINITIALIZED;\n+    public Object getValue(){\n+        if (value == UNINITIALIZED){\n+            if (index == WHOLE_COLLECTION){\n+                value = getBaseValue();\n+            }\n+            else {\n+                value = ValueUtils.getValue(getBaseValue(), index);\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns a NodePointer that can be used to access the currently\n+     * selected property value.\n+     */\n+    public NodePointer getValuePointer(){\n+        return NodePointer.newChildNodePointer(this, getName(), getValue());\n+    }\n+\n+    public int hashCode(){\n+        return getParent().hashCode() + propertyIndex + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof PropertyPointer)){\n+            return false;\n+        }\n+\n+        PropertyPointer other = (PropertyPointer)object;\n+        return getParent() == other.getParent() &&\n+                propertyIndex == other.propertyIndex &&\n+                index == other.index;\n+    }\n+\n+    public String toString(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (getBean() == null){\n+            buffer.append(\"null\");\n+        }\n+        else {\n+            buffer.append(getBean().getClass().getName());\n+        }\n+        buffer.append('@');\n+        buffer.append(System.identityHashCode(getBean()));\n+        buffer.append('.');\n+        buffer.append(getPropertyName());\n+        if (index != WHOLE_COLLECTION){\n+            buffer.append('[').append(index).append(']');\n+        }\n+        buffer.append(\" = \").append(getValue());\n+        return buffer.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.container;\n+\n+import java.util.Locale;\n+\n+import org.apache.commons.jxpath.Container;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.compiler.NodeTest;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.util.ValueUtils;\n+\n+/**\n+ * Transparent pointer to a Container. The getValue() method\n+ * returns the contents of the container, rather than the container\n+ * itself.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class ContainerPointer extends NodePointer {\n+    private Container container;\n+    private NodePointer valuePointer;\n+\n+    public ContainerPointer(Container container, Locale locale){\n+        super(null, locale);\n+        this.container = container;\n+    }\n+\n+    public ContainerPointer(NodePointer parent, Container container){\n+        super(parent);\n+        this.container = container;\n+    }\n+\n+    /**\n+     * This type of node is auxiliary.\n+     */\n+    public boolean isNode(){\n+        return false;\n+    }\n+\n+    public QName getName(){\n+        return null;\n+    }\n+\n+    public Object getBaseValue(){\n+        return container.getValue();\n+    }\n+\n+    public Object getValue(){\n+        Object value = getBaseValue();\n+        if (index != WHOLE_COLLECTION){\n+            return ValueUtils.getValue(value, index);\n+        }\n+        return value;\n+    }\n+\n+    public void setValue(Object value){\n+        container.setValue(value);\n+    }\n+\n+    public NodePointer getValuePointer(){\n+        if (valuePointer == null){\n+            Object value = getValue();\n+            valuePointer = NodePointer.newChildNodePointer(this, getName(), value).getValuePointer();\n+        }\n+        return valuePointer;\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(container) + index;\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof ContainerPointer)){\n+            return false;\n+        }\n+\n+        ContainerPointer other = (ContainerPointer)object;\n+        return container == other.container &&\n+                index == other.index;\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        return getValuePointer().childIterator(test, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return getValuePointer().attributeIterator(name);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return getValuePointer().namespaceIterator();\n+    }\n+\n+    public NodePointer namespacePointer(String namespace){\n+        return getValuePointer().namespacePointer(namespace);\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return getValuePointer().testNode(nodeTest);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/container/ContainerPointerFactory.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.container;\n+\n+import org.apache.commons.jxpath.Container;\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+\n+import java.util.*;\n+\n+/**\n+ * Implements NodePointerFactory for Container objects.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class ContainerPointerFactory implements NodePointerFactory {\n+\n+    public static final int CONTAINER_POINTER_FACTORY_ORDER = 200;\n+\n+    public int getOrder(){\n+        return CONTAINER_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        if (bean instanceof Container){\n+            return new ContainerPointer((Container)bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean instanceof Container){\n+            return new ContainerPointer(parent, (Container)bean);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of attributes of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMAttributeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private QName name;\n+    private List attributes;\n+    private int position = 0;\n+\n+    public DOMAttributeIterator(NodePointer parent, QName name){\n+        this.parent = parent;\n+        this.name = name;\n+        attributes = new ArrayList();\n+        Node node = (Node)parent.getValue();\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            String lname = name.getName();\n+            if (!lname.equals(\"*\")){\n+                Attr attr = getAttribute((Element)node, name);\n+                if (attr != null){\n+                    attributes.add(attr);\n+                }\n+            }\n+            else {\n+                NamedNodeMap map = node.getAttributes();\n+                int count = map.getLength();\n+                for (int i = 0; i < count; i++){\n+                    Attr attr = (Attr)map.item(i);\n+                    if (testAttr(attr, name)){\n+                        attributes.add(attr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean testAttr(Attr attr, QName testName){\n+        String nodePrefix = DOMNodePointer.getPrefix(attr);\n+        String nodeLocalName = DOMNodePointer.getLocalName(attr);\n+\n+        if (nodePrefix != null && nodePrefix.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")){\n+            return false;\n+        }\n+\n+        String testLocalName = name.getName();\n+        if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)){\n+            String testPrefix = testName.getPrefix();\n+\n+            if (equalStrings(testPrefix, nodePrefix)){\n+                return true;\n+            }\n+\n+            String testNS = null;\n+            if (testPrefix != null){\n+                testNS = parent.getNamespaceURI(testPrefix);\n+            }\n+\n+            String nodeNS = null;\n+            if (nodePrefix != null){\n+                nodeNS = parent.getNamespaceURI(nodePrefix);\n+            }\n+            return equalStrings(testNS, nodeNS);\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && !s1.equals(s2)){\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private Attr getAttribute(Element element, QName name){\n+        String testPrefix = name.getPrefix();\n+        String testNS = null;\n+\n+        if (testPrefix != null){\n+            testNS = parent.getNamespaceURI(testPrefix);\n+        }\n+\n+        Node attr;\n+        if (testNS != null){\n+            return element.getAttributeNodeNS(testNS, name.getName());\n+        }\n+        else {\n+            return element.getAttributeNode(name.getName());\n+        }\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        return new DOMAttributePointer(parent, (Attr)attributes.get(index));\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position >= 1 && position <= attributes.size();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributePointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+import org.apache.commons.jxpath.util.TypeUtils;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMAttributePointer extends NodePointer {\n+    private Attr attr;\n+\n+    public DOMAttributePointer(NodePointer parent, Attr attr){\n+        super(parent);\n+        this.attr = attr;\n+    }\n+\n+    public QName getName(){\n+        return new QName(DOMNodePointer.getPrefix(attr), DOMNodePointer.getLocalName(attr));\n+    }\n+\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(),  DOMNodePointer.getLocalName(attr));\n+    }\n+\n+    public String getNamespaceURI(){\n+        String prefix = DOMNodePointer.getPrefix(attr);\n+        if (prefix == null){\n+            return null;\n+        }\n+        return parent.getNamespaceURI(prefix);\n+    }\n+\n+    public Object getBaseValue(){\n+        return attr;\n+    }\n+\n+    public Object getValue(){\n+        String value = attr.getValue();\n+        if (value == null){\n+            return null;\n+        }\n+        if (value.equals(\"\") && !attr.getSpecified()){\n+            return null;\n+        }\n+        return value;\n+    }\n+\n+    public boolean isActual(){\n+        return true;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return nodeTest == null ||\n+                ((nodeTest instanceof NodeTypeTest) &&\n+                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    }\n+\n+    /**\n+     * Sets the value of this attribute.\n+     */\n+    public void setValue(Object value){\n+        attr.setValue((String)TypeUtils.convert(value, String.class));\n+    }\n+\n+    /**\n+     */\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append('@');\n+        buffer.append(getName());\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(attr);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DOMAttributePointer)){\n+            return false;\n+        }\n+\n+        DOMAttributePointer other = (DOMAttributePointer)object;\n+        return attr == other.attr;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNamespaceIterator.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of namespaces of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMNamespaceIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private List attributes;\n+    private int position = 0;\n+\n+    public DOMNamespaceIterator(NodePointer parent){\n+        this.parent = parent;\n+        attributes = new ArrayList();\n+        collectNamespaces(attributes, (Node)parent.getValue());\n+    }\n+\n+    private void collectNamespaces(List attributes, Node node){\n+        Node parent = node.getParentNode();\n+        if (parent != null){\n+            collectNamespaces(attributes, parent);\n+        }\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            NamedNodeMap map = node.getAttributes();\n+            int count = map.getLength();\n+            for (int i = 0; i < count; i++){\n+                Attr attr = (Attr)map.item(i);\n+                String prefix = DOMNodePointer.getPrefix(attr);\n+                String name = DOMNodePointer.getLocalName(attr);\n+                if ((prefix != null && prefix.equals(\"xmlns\")) ||\n+                        (prefix == null && name.equals(\"xmlns\"))){\n+                    attributes.add(attr);\n+                }\n+            }\n+        }\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (position == 0){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+        int index = position - 1;\n+        if (index < 0){\n+            index = 0;\n+        }\n+        String prefix = \"\";\n+        Attr attr = (Attr)attributes.get(index);\n+        String name = attr.getPrefix();\n+        if (name != null && name.equals(\"xmlns\")){\n+            prefix = DOMNodePointer.getLocalName(attr);\n+        }\n+        return new NamespacePointer(parent, prefix, attr.getValue());\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        this.position = position;\n+        return position >= 1 && position <= attributes.size();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodeIterator.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+\n+/**\n+ * An iterator of children of a DOM Node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMNodeIterator implements NodeIterator {\n+    private NodePointer parent;\n+    private NodeTest nodeTest;\n+    private String namespaceURI;\n+    private Node node;\n+    private Node child = null;\n+    private boolean reverse;\n+    private int position = 0;\n+\n+    public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith){\n+        this.parent = parent;\n+        this.node = (Node)parent.getValue();\n+        if (startWith != null){\n+            this.child = (Node)startWith.getValue();\n+        }\n+        this.nodeTest = nodeTest;\n+        this.reverse = reverse;\n+    }\n+\n+    public NodePointer getNodePointer(){\n+        if (child == null){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+\n+        return new DOMNodePointer(parent, child);\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        while (this.position > position){\n+            if (!previous()){\n+                return false;\n+            }\n+        }\n+//        System.err.println(getNodePointer().asPath() + \" SET POSITION: \" + position);\n+        return true;\n+    }\n+\n+    private boolean previous(){\n+        position--;\n+        if (!reverse){\n+            child = child.getPreviousSibling();\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        else {\n+            child = child.getNextSibling();\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean next(){\n+        position++;\n+        if (!reverse){\n+            if (position == 1){\n+                if (child == null){\n+                    child = node.getFirstChild();\n+                }\n+                else {\n+                    child = child.getNextSibling();\n+                }\n+            }\n+            else {\n+                child = child.getNextSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        else {\n+            if (position == 1){\n+                if (child == null){\n+                    child = node.getLastChild();\n+                }\n+                else {\n+                    child = child.getPreviousSibling();\n+                }\n+            }\n+            else {\n+                child = child.getPreviousSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean testChild(){\n+        return DOMNodePointer.testNode(parent, child, nodeTest);\n+    }\n+/*\n+    public NodePointer getNodePointer(){\n+        if (child == null){\n+            if (!setPosition(1)){\n+                return null;\n+            }\n+            position = 0;\n+        }\n+\n+        if (children){\n+            return new DOMNodePointer(parent, child);\n+        }\n+        else {\n+            return new DOMNodePointer(parent.getParent(), child);\n+        }\n+    }\n+\n+    public int getPosition(){\n+        return position;\n+    }\n+\n+    public boolean setPosition(int position){\n+        while (this.position < position){\n+            if (!next()){\n+                return false;\n+            }\n+        }\n+        while (this.position > position){\n+            if (!previous()){\n+                return false;\n+            }\n+        }\n+//        System.err.println(getNodePointer().asPath() + \" SET POSITION: \" + position);\n+        return true;\n+    }\n+\n+    private boolean previous(){\n+        position--;\n+        if (!reverse){\n+            child = child.getPreviousSibling();\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        else {\n+            child = child.getNextSibling();\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean next(){\n+        position++;\n+        if (!reverse){\n+            if (position == 1){\n+                if (children){\n+                    child = node.getFirstChild();\n+                }\n+                else {\n+                    child = node.getNextSibling();\n+                }\n+            }\n+            else {\n+                child = child.getNextSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getNextSibling();\n+            }\n+        }\n+        else {\n+            if (position == 1){\n+                if (children){\n+                    child = node.getLastChild();\n+                }\n+                else {\n+                    child = node.getPreviousSibling();\n+                }\n+            }\n+            else {\n+                child = child.getPreviousSibling();\n+            }\n+            while (child != null && !testChild()){\n+                child = child.getPreviousSibling();\n+            }\n+        }\n+        return child != null;\n+    }\n+\n+    private boolean testChild(){\n+        return DOMNodePointer.testNode(parent, child, nodeTest);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodeIterator;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+import org.w3c.dom.*;\n+import org.apache.commons.jxpath.util.TypeUtils;\n+\n+/**\n+ * A Pointer that points to a DOM node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMNodePointer extends NodePointer {\n+    private Node node;\n+    private Map namespaces;\n+    private String defaultNamespace;\n+\n+    public static final String XML_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\";\n+    public static final String XMLNS_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\";\n+\n+    public DOMNodePointer(Node node, Locale locale){\n+        super(null, locale);\n+        this.node = node;\n+    }\n+\n+    public DOMNodePointer(NodePointer parent, Node node){\n+        super(parent);\n+        this.node = node;\n+    }\n+\n+    public boolean testNode(NodeTest test){\n+        return testNode(this, node, test);\n+    }\n+\n+    public static boolean testNode(NodePointer pointer, Node node, NodeTest test){\n+        if (test == null){\n+            return true;\n+        }\n+        else if (test instanceof NodeNameTest){\n+            if (node.getNodeType() != Node.ELEMENT_NODE){\n+                return false;\n+            }\n+\n+            QName testName = ((NodeNameTest)test).getNodeName();\n+            String testLocalName = testName.getName();\n+            if (testLocalName.equals(\"*\") || testLocalName.equals(DOMNodePointer.getLocalName(node))){\n+                String testPrefix = testName.getPrefix();\n+                String nodePrefix = DOMNodePointer.getPrefix(node);\n+                if (equalStrings(testPrefix, nodePrefix)){\n+                    return true;\n+                }\n+\n+                String testNS = pointer.getNamespaceURI(testPrefix);\n+                String nodeNS = pointer.getNamespaceURI(nodePrefix);\n+                return equalStrings(testNS, nodeNS);\n+            }\n+        }\n+        else if (test instanceof NodeTypeTest){\n+            int nodeType = node.getNodeType();\n+            switch (((NodeTypeTest)test).getNodeType()){\n+                case Compiler.NODE_TYPE_NODE:\n+                    return nodeType == Node.ELEMENT_NODE;\n+                case Compiler.NODE_TYPE_TEXT:\n+                    return nodeType == Node.CDATA_SECTION_NODE ||\n+                            nodeType == Node.TEXT_NODE;\n+                case Compiler.NODE_TYPE_COMMENT:\n+                    return nodeType == Node.COMMENT_NODE;\n+                case Compiler.NODE_TYPE_PI:\n+                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n+            }\n+            return false;\n+        }\n+        else if (test instanceof ProcessingInstructionTest){\n+            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE){\n+                String testPI = ((ProcessingInstructionTest)test).getTarget();\n+                String nodePI = ((ProcessingInstruction)node).getTarget();\n+                return testPI.equals(nodePI);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean equalStrings(String s1, String s2){\n+        if (s1 == null && s2 != null){\n+            return false;\n+        }\n+        if (s1 != null && s2 == null){\n+            return false;\n+        }\n+\n+        if (s1 != null && !s1.trim().equals(s2.trim())){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    public QName getName(){\n+        int type = node.getNodeType();\n+        if (type == Node.ELEMENT_NODE){\n+            return new QName(DOMNodePointer.getPrefix(node), DOMNodePointer.getLocalName(node));\n+        }\n+        else if (type == Node.PROCESSING_INSTRUCTION_NODE){\n+            return new QName(null, ((ProcessingInstruction)node).getTarget());\n+        }\n+        return null;\n+    }\n+\n+    public String getNamespaceURI(){\n+        if (node.getNodeType() == Node.ELEMENT_NODE){\n+            return getNamespaceURI(getName().getPrefix());\n+        }\n+        return null;\n+    }\n+\n+    public QName getExpandedName(){\n+        return new QName(getNamespaceURI(), getName().getName());\n+    }\n+\n+    public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith){\n+        return new DOMNodeIterator(this, test, reverse, startWith);\n+    }\n+\n+    public NodeIterator attributeIterator(QName name){\n+        return new DOMAttributeIterator(this, name);\n+    }\n+\n+    public NodePointer namespacePointer(String prefix){\n+        return new NamespacePointer(this, prefix);\n+    }\n+\n+    public NodeIterator namespaceIterator(){\n+        return new DOMNamespaceIterator(this);\n+    }\n+\n+    public String getNamespaceURI(String prefix){\n+        if (prefix == null || prefix.equals(\"\")){\n+            return getDefaultNamespaceURI();\n+        }\n+\n+        if (prefix.equals(\"xml\")){\n+            return XML_NAMESPACE_URI;\n+        }\n+\n+        if (prefix.equals(\"xmlns\")){\n+            return XMLNS_NAMESPACE_URI;\n+        }\n+\n+        String namespace = null;\n+        if (namespaces == null){\n+            namespaces = new HashMap();\n+        }\n+        else {\n+            namespace = (String)namespaces.get(prefix);\n+        }\n+\n+        if (namespace == null){\n+            String qname = \"xmlns:\" + prefix;\n+            Node aNode = node;\n+            while (aNode != null){\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n+                    Attr attr = ((Element)aNode).getAttributeNode(qname);\n+                    if (attr != null){\n+                        namespace = attr.getValue();\n+                        break;\n+                    }\n+                }\n+                aNode = aNode.getParentNode();\n+            }\n+            if (namespace == null || namespace.equals(\"\")){\n+                namespace = NodePointer.UNKNOWN_NAMESPACE;\n+            }\n+        }\n+\n+        namespaces.put(prefix, namespace);\n+        // TBD: We are supposed to resolve relative URIs to absolute ones.\n+        return namespace;\n+    }\n+\n+    public String getDefaultNamespaceURI(){\n+        if (defaultNamespace == null){\n+            Node aNode = node;\n+            while (aNode != null){\n+                if (aNode.getNodeType() == Node.ELEMENT_NODE){\n+                    Attr attr = ((Element)aNode).getAttributeNode(\"xmlns\");\n+                    if (attr != null){\n+                        defaultNamespace = attr.getValue();\n+                        break;\n+                    }\n+                }\n+                aNode = aNode.getParentNode();\n+            }\n+        }\n+        if (defaultNamespace == null){\n+            defaultNamespace = \"\";\n+        }\n+        // TBD: We are supposed to resolve relative URIs to absolute ones.\n+        return defaultNamespace.equals(\"\") ? null : defaultNamespace;\n+    }\n+\n+    public Object getBaseValue(){\n+        return node;\n+    }\n+\n+    public Object getValue(){\n+        return node;\n+    }\n+\n+    public boolean isActual(){\n+        return true;\n+    }\n+\n+    public boolean isCollection(){\n+        return false;\n+    }\n+\n+    public int getLength(){\n+        return 1;\n+    }\n+\n+    public boolean isLeaf(){\n+        return !node.hasChildNodes();\n+    }\n+\n+    /**\n+     * Returns true if the xml:lang attribute for the current node\n+     * or its parent has the specified prefix <i>lang</i>.\n+     * If no node has this prefix, calls <code>super.isLanguage(lang)</code>.\n+     */\n+    public boolean isLanguage(String lang){\n+        String current = getLanguage();\n+        if (current == null){\n+            return super.isLanguage(lang);\n+        }\n+        return current.toUpperCase().startsWith(lang.toUpperCase());\n+    }\n+\n+    protected String getLanguage(){\n+        Node n = node;\n+        while (n != null){\n+            if (n.getNodeType() == Node.ELEMENT_NODE){\n+                Element e = (Element)n;\n+                String attr = e.getAttribute(\"xml:lang\");\n+                if (attr != null && !attr.equals(\"\")){\n+                    return attr;\n+                }\n+            }\n+            n = n.getParentNode();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets text contents of the node to the specified value\n+     */\n+    public void setValue(Object value){\n+        String string = null;\n+        if (value != null){\n+            string = (String)TypeUtils.convert(value, String.class);\n+            if (string.equals(\"\")){\n+                string = null;\n+            }\n+        }\n+\n+        if (node.getNodeType() == Node.TEXT_NODE){\n+            if (string != null){\n+                node.setNodeValue(string);\n+            }\n+            else {\n+                node.getParentNode().removeChild(node);\n+            }\n+        }\n+        else {\n+            NodeList children = node.getChildNodes();\n+            int count = children.getLength();\n+            for (int i = 0; i < count; i++){\n+                Node child = children.item(i);\n+                if (child.getNodeType() == Node.TEXT_NODE ||\n+                        child.getNodeType() == Node.CDATA_SECTION_NODE){\n+                    node.removeChild(child);\n+                }\n+            }\n+            if (string != null){\n+                Node text = node.getOwnerDocument().createTextNode(string);\n+                node.appendChild(text);\n+            }\n+        }\n+    }\n+\n+    public NodePointer createChild(JXPathContext context, QName name, int index){\n+        if (index == WHOLE_COLLECTION){\n+            index = 0;\n+        }\n+        if (!getAbstractFactory(context).createObject(context, this, node, name.toString(), index)){\n+            throw new RuntimeException(\"Factory could not create a child node for path: \" +\n+                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n+        }\n+        NodeIterator it = childIterator(new NodeNameTest(name), false, null);\n+        if (it == null || !it.setPosition(index + 1)){\n+            throw new RuntimeException(\"Factory could not create a child node for path: \" +\n+                    asPath() + \"/\" + name + \"[\" + (index+1) + \"]\");\n+        }\n+        return it.getNodePointer();\n+    }\n+\n+    public void createChild(JXPathContext context, QName name, int index, Object value){\n+        createChild(context, name, index).setValue(value);\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+        }\n+        switch(node.getNodeType()){\n+            case Node.ELEMENT_NODE:\n+                // If the parent pointer is not a DOMNodePointer, it is\n+                // the parent's responsibility to produce the node test part\n+                // of the path\n+                if (parent instanceof DOMNodePointer){\n+                    buffer.append('/');\n+                    buffer.append(getName());\n+                    buffer.append('[').append(getRelativePositionByName()).append(']');\n+                }\n+                break;\n+            case Node.TEXT_NODE:\n+            case Node.CDATA_SECTION_NODE:\n+                buffer.append(\"/text()\");\n+                buffer.append('[').append(getRelativePositionOfTextNode()).append(']');\n+                break;\n+            case Node.PROCESSING_INSTRUCTION_NODE:\n+                String target = ((ProcessingInstruction)node).getTarget();\n+                buffer.append(\"/processing-instruction(\\'\").append(target).append(\"')\");\n+                buffer.append('[').append(getRelativePositionOfPI(target)).append(']');\n+                break;\n+            case Node.DOCUMENT_NODE:\n+                // That'll be empty\n+        }\n+        return buffer.toString();\n+    }\n+\n+    private int getRelativePositionByName(){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.ELEMENT_NODE){\n+                String nm = n.getNodeName();\n+                if (nm.equals(node.getNodeName())){\n+                    count ++;\n+                }\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    private int getRelativePositionOfTextNode(){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.TEXT_NODE || n.getNodeType() == Node.CDATA_SECTION_NODE){\n+                count ++;\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    private int getRelativePositionOfPI(String target){\n+        int count = 1;\n+        Node n = node.getPreviousSibling();\n+        while (n != null){\n+            if (n.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE &&\n+                    ((ProcessingInstruction)n).getTarget().equals(target)){\n+                count ++;\n+            }\n+            n = n.getPreviousSibling();\n+        }\n+        return count;\n+    }\n+\n+    public int hashCode(){\n+        return System.identityHashCode(node);\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof DOMNodePointer)){\n+            return false;\n+        }\n+\n+        DOMNodePointer other = (DOMNodePointer)object;\n+        return node == other.node;\n+    }\n+\n+    public static String getPrefix(Node node){\n+        String prefix = node.getPrefix();\n+        if (prefix != null){\n+            return prefix;\n+        }\n+\n+        String name = node.getNodeName();\n+        int index = name.lastIndexOf(':');\n+        if (index == -1){\n+            return null;\n+        }\n+\n+        return name.substring(0, index);\n+    }\n+\n+    public static String getLocalName(Node node){\n+        String localName = node.getLocalName();\n+        if (localName != null){\n+            return localName;\n+        }\n+\n+        String name = node.getNodeName();\n+        int index = name.lastIndexOf(':');\n+        if (index == -1){\n+            return name;\n+        }\n+\n+        return name.substring(index + 1);\n+    }\n+\n+    public Object getCanonicalValue(){\n+        return stringValue(node);\n+    }\n+\n+    private String stringValue(Node node){\n+        int nodeType = node.getNodeType();\n+        if (nodeType == Node.COMMENT_NODE){\n+            String text = ((Comment)node).getData();\n+            return text == null ? \"\" : text.trim();\n+        }\n+        else if (nodeType == Node.TEXT_NODE ||\n+                nodeType == Node.CDATA_SECTION_NODE){\n+            String text = node.getNodeValue();\n+            return text == null ? \"\" : text.trim();\n+        }\n+        else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE){\n+            String text = ((ProcessingInstruction)node).getData();\n+            return text == null ? \"\" : text.trim();\n+        }\n+        else {\n+            NodeList list = node.getChildNodes();\n+            StringBuffer buf = new StringBuffer(16);\n+            for(int i = 0; i < list.getLength();i++) {\n+                Node child = list.item(i);\n+                if (child.getNodeType() == Node.TEXT_NODE){\n+                    buf.append(child.getNodeValue());\n+                }\n+                else {\n+                    buf.append(stringValue(child));\n+                }\n+            }\n+            return buf.toString().trim();\n+        }\n+    }\n+\n+    private AbstractFactory getAbstractFactory(JXPathContext context){\n+        AbstractFactory factory = context.getFactory();\n+        if (factory == null){\n+            throw new RuntimeException(\"Factory is not set on the JXPathContext - cannot create path: \" + asPath());\n+        }\n+        return factory;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/DOMPointerFactory.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.ri.QName;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+import org.apache.commons.jxpath.ri.model.NodePointerFactory;\n+\n+import java.util.*;\n+import org.w3c.dom.Node;\n+\n+/**\n+ * Implements NodePointerFactory for DOM elements.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class DOMPointerFactory implements NodePointerFactory {\n+\n+    public static final int DOM_POINTER_FACTORY_ORDER = 100;\n+\n+    public int getOrder(){\n+        return DOM_POINTER_FACTORY_ORDER;\n+    }\n+\n+    public NodePointer createNodePointer(QName name, Object bean, Locale locale){\n+        if (bean instanceof Node){\n+            return new DOMNodePointer((Node)bean, locale);\n+        }\n+        return null;\n+    }\n+\n+    public NodePointer createNodePointer(NodePointer parent, QName name, Object bean){\n+        if (bean instanceof Node){\n+            return new DOMNodePointer(parent, (Node)bean);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/ri/model/dom/NamespacePointer.java,v 1.1 2002/04/21 21:52:33 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:33 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.ri.model.dom;\n+\n+import org.apache.commons.jxpath.ri.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.model.NodePointer;\n+\n+import java.util.*;\n+\n+/**\n+ * Represents a namespace node.\n+ *\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:33 $\n+ */\n+public class NamespacePointer extends NodePointer {\n+    private String prefix;\n+    private String namespaceURI;\n+\n+    public NamespacePointer(NodePointer parent, String prefix){\n+        super(parent);\n+        this.prefix = prefix;\n+    }\n+\n+    public NamespacePointer(NodePointer parent, String prefix, String namespaceURI){\n+        super(parent);\n+        this.prefix = prefix;\n+        this.namespaceURI = namespaceURI;\n+    }\n+\n+    public QName getName(){\n+        return new QName(getNamespaceURI(), prefix);\n+    }\n+\n+    public Object getBaseValue(){\n+        return null;\n+    }\n+\n+    public Object getValue(){\n+        return getNamespaceURI();\n+    }\n+\n+    public String getNamespaceURI(){\n+        if (namespaceURI == null){\n+            namespaceURI = parent.getNamespaceURI(prefix);\n+        }\n+        return namespaceURI;\n+    }\n+\n+    public boolean isLeaf(){\n+        return true;\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     */\n+    public void setValue(Object value){\n+        throw new UnsupportedOperationException(\"Cannot modify DOM trees\");\n+    }\n+\n+    public boolean testNode(NodeTest nodeTest){\n+        return nodeTest == null ||\n+                ((nodeTest instanceof NodeTypeTest) &&\n+                    ((NodeTypeTest)nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE);\n+    }\n+\n+    public String asPath(){\n+        StringBuffer buffer = new StringBuffer();\n+        if (parent != null){\n+            buffer.append(parent.asPath());\n+            buffer.append('/');\n+        }\n+        buffer.append(\"namespace::\");\n+        buffer.append(prefix);\n+        return buffer.toString();\n+    }\n+\n+    public int hashCode(){\n+        String nsURI = getNamespaceURI();\n+        if (nsURI == null){\n+            return 0;\n+        }\n+        else {\n+            return nsURI.hashCode();\n+        }\n+    }\n+\n+    public boolean equals(Object object){\n+        if (object == this){\n+            return true;\n+        }\n+\n+        if (!(object instanceof NamespacePointer)){\n+            return false;\n+        }\n+\n+        NamespacePointer other = (NamespacePointer)object;\n+        String nsURI = getNamespaceURI();\n+        String otherNSURI = other.getNamespaceURI();\n+        return (nsURI == null && otherNSURI == null) ||\n+               (nsURI != null && nsURI.endsWith(otherNSURI));\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/TypeUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/TypeUtils.java,v 1.1 2002/04/21 21:52:34 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:34 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+import org.apache.commons.jxpath.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:34 $\n+ */\n+public class TypeUtils {\n+\n+    private static final int NO_MATCH = 0;\n+    private static final int APPROXIMATE_MATCH = 1;\n+    private static final int EXACT_MATCH = 2;\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    public static Constructor lookupConstructor(Class targetClass, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Constructor constructor = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                constructor = targetClass.getConstructor(types);\n+                if (constructor != null){\n+                    return constructor;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Constructor[] constructors = targetClass.getConstructors();\n+        for (int i = 0; i < constructors.length; i++){\n+            int match = TypeUtils.matchParameterTypes(constructors[i].getParameterTypes(), parameters);\n+            if (match != TypeUtils.NO_MATCH){\n+                if (match > currentMatch){\n+                    constructor = constructors[i];\n+                    currentMatch = match;\n+                    ambiguous = false;\n+                }\n+                else if (match == currentMatch){\n+                    ambiguous = true;\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous constructor \" + Arrays.asList(parameters));\n+        }\n+        return constructor;\n+    }\n+\n+    public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters){\n+        boolean tryExact = true;\n+        int count = parameters.length;\n+        Class types[] = new Class[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i];\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = TypeUtils.matchParameterTypes(methods[i].getParameterTypes(), parameters);\n+                if (match != TypeUtils.NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+    }\n+\n+    public static Method lookupMethod(Class targetClass, String name, Object[] parameters){\n+        if (parameters.length < 1 || parameters[0] == null){\n+            return null;\n+        }\n+\n+        if (TypeUtils.matchType(targetClass, parameters[0]) == TypeUtils.NO_MATCH){\n+            return null;\n+        }\n+\n+        targetClass = convert(parameters[0], targetClass).getClass();\n+\n+        boolean tryExact = true;\n+        int count = parameters.length - 1;\n+        Class types[] = new Class[count];\n+        Object arguments[] = new Object[count];\n+        for (int i = 0; i < count; i++){\n+            Object param = parameters[i+1];\n+            arguments[i] = param;\n+            if (param != null){\n+                types[i] = param.getClass();\n+            }\n+            else {\n+                types[i] = null;\n+                tryExact = false;\n+            }\n+        }\n+\n+        Method method = null;\n+\n+        if (tryExact){\n+            // First - without type conversion\n+            try {\n+                method = targetClass.getMethod(name, types);\n+                if (method != null && !Modifier.isStatic(method.getModifiers())){\n+                    return method;\n+                }\n+            }\n+            catch (NoSuchMethodException ex){\n+            }\n+        }\n+\n+        int currentMatch = 0;\n+        boolean ambiguous = false;\n+\n+        // Then - with type conversion\n+        Method[] methods = targetClass.getMethods();\n+        for (int i = 0; i < methods.length; i++){\n+            if (!Modifier.isStatic(methods[i].getModifiers()) &&\n+                    methods[i].getName().equals(name)){\n+                int match = TypeUtils.matchParameterTypes(methods[i].getParameterTypes(), arguments);\n+                if (match != TypeUtils.NO_MATCH){\n+                    if (match > currentMatch){\n+                        method = methods[i];\n+                        currentMatch = match;\n+                        ambiguous = false;\n+                    }\n+                    else if (match == currentMatch){\n+                        ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (ambiguous){\n+            throw new RuntimeException(\"Ambigous method call: \" + name);\n+        }\n+        return method;\n+    }\n+\n+    public static int matchParameterTypes(Class types[], Object parameters[]){\n+        int pi = 0;\n+        if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])){\n+            pi++;\n+        }\n+        if (types.length != parameters.length + pi){\n+            return NO_MATCH;\n+        }\n+        int totalMatch = EXACT_MATCH;\n+        for (int i = 0; i < parameters.length; i++){\n+            int match = matchType(types[i + pi], parameters[i]);\n+            if (match == NO_MATCH){\n+                return NO_MATCH;\n+            }\n+            if (match < totalMatch){\n+                totalMatch = match;\n+            }\n+        }\n+        return totalMatch;\n+    }\n+\n+    public static int matchType(Class expected, Object object){\n+        if (object == null){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        Class actual = object.getClass();\n+\n+        if (expected.equals(actual)){\n+            return EXACT_MATCH;\n+        }\n+        if (expected.isAssignableFrom(actual)){\n+            return EXACT_MATCH;\n+        }\n+\n+        if (canConvert(object, expected)){\n+            return APPROXIMATE_MATCH;\n+        }\n+\n+        return NO_MATCH;\n+    }\n+\n+    public static boolean canConvert(Object object, Class toType){\n+        if (object == null){\n+            return true;\n+        }\n+\n+        if (toType == Object.class){\n+            return true;\n+        }\n+\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType)){\n+            return true;\n+        }\n+\n+        if (toType.isAssignableFrom(fromType)){\n+            return true;\n+        }\n+\n+        if (toType == String.class){\n+            return true;\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Number){\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType.isPrimitive()){\n+                return true;\n+            }\n+        }\n+        else if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                return true;\n+            }\n+            Pointer pointer = ((ExpressionContext)object).getContextNodePointer();\n+            if (pointer != null){\n+                Object value = pointer.getValue();\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (fromType.isArray()){\n+            if (Array.getLength(object) == 1){\n+                Object value = Array.get(object, 0);\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (object instanceof List){\n+            if (((List)object).size() == 1){\n+                Object value = ((List)object).get(0);\n+                return canConvert(value, toType);\n+            }\n+        }\n+        else if (object instanceof Collection){\n+            if (!((Collection)object).isEmpty()){\n+                Iterator it = ((Collection)object).iterator();\n+                Object value = it.next();\n+                return canConvert(value, toType);\n+            }\n+        }\n+\n+        // TBD: date conversion to/from string\n+        return false;\n+    }\n+\n+    public static Object convert(Object object, Class toType){\n+        if (object == null){\n+            return null;\n+        }\n+\n+        if (toType == Object.class){\n+            return object;\n+        }\n+\n+        if (object instanceof ExpressionContext){\n+            if (Collection.class.isAssignableFrom(toType)){\n+                List list = ((ExpressionContext)object).getContextNodeList();\n+                Collection result = new ArrayList();\n+                if (toType == List.class || toType == ArrayList.class){\n+                    result = new ArrayList();\n+                }\n+                else if (toType == Vector.class){\n+                    result = new Vector();\n+                }\n+                else if (toType == Set.class || toType == HashSet.class){\n+                    result = new HashSet();\n+                }\n+                int count = list.size();\n+                for (int i = 0; i < count; i++){\n+                    Pointer ptr = (Pointer)list.get(i);\n+                    result.add(ptr.getValue());\n+                }\n+                return result;\n+            }\n+            else {\n+                Object value = ((ExpressionContext)object).getContextNodePointer().getValue();\n+                return convert(value, toType);\n+            }\n+        }\n+\n+        Class fromType = object.getClass();\n+        if (fromType.equals(toType) || toType.isAssignableFrom(fromType)){\n+            return object;\n+        }\n+\n+        if (toType == String.class){\n+            return object.toString();\n+        }\n+\n+        if (object instanceof Boolean){\n+            if (toType == boolean.class){\n+                return object;\n+            }\n+            boolean value = ((Boolean)object).booleanValue();\n+            return allocateNumber(toType, value ? 1 : 0);\n+        }\n+        else if (object instanceof Number){\n+            double value = ((Number)object).doubleValue();\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return value == 0.0 ? Boolean.FALSE : Boolean.TRUE;\n+            }\n+            if (toType.isPrimitive() ||\n+                    Number.class.isAssignableFrom(toType)){\n+                return allocateNumber(toType, value);\n+            }\n+        }\n+        else if (object instanceof Character){\n+            if (toType == char.class){\n+                return object;\n+            }\n+        }\n+        else if (object instanceof String){\n+            if (toType == boolean.class || toType == Boolean.class){\n+                return new Boolean((String)object);\n+            }\n+            if (toType == char.class || toType == Character.class){\n+                return new Character(((String)object).charAt(0));\n+            }\n+            if (toType == byte.class || toType == Byte.class){\n+                return new Byte((String)object);\n+            }\n+            if (toType == short.class || toType == Short.class){\n+                return new Short((String)object);\n+            }\n+            if (toType == int.class || toType == Integer.class){\n+                return new Integer((String)object);\n+            }\n+            if (toType == long.class || toType == Long.class){\n+                return new Long((String)object);\n+            }\n+            if (toType == float.class || toType == Float.class){\n+                return new Float((String)object);\n+            }\n+            if (toType == double.class || toType == Double.class){\n+                return new Double((String)object);\n+            }\n+        }\n+        else if (fromType.isArray()){\n+            Object value = Array.get(object, 0);\n+            return convert(value, toType);\n+        }\n+        else if (object instanceof List){\n+            Object value = ((List)object).get(0);\n+            return convert(value, toType);\n+        }\n+        else if (object instanceof Collection){\n+            Iterator it = ((Collection)object).iterator();\n+            Object value = it.next();\n+            return convert(value, toType);\n+        }\n+        return object;\n+    }\n+\n+    private static Number allocateNumber(Class type, double value){\n+        if (type == Byte.class || type == byte.class){\n+            return new Byte((byte)value);\n+        }\n+        if (type == Short.class || type == short.class){\n+            return new Short((short)value);\n+        }\n+        if (type == Integer.class || type == int.class){\n+            return new Integer((int)value);\n+        }\n+        if (type == Long.class || type == long.class){\n+            return new Long((long)value);\n+        }\n+        if (type == Float.class || type == float.class){\n+            return new Float((float)value);\n+        }\n+        if (type == Double.class || type == double.class){\n+            return new Double(value);\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/jxpath/util/ValueUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/java/org/apache/commons/jxpath/util/ValueUtils.java,v 1.1 2002/04/21 21:52:34 dmitri Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/04/21 21:52:34 $\n+ *\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation and was\n+ * originally based on software copyright (c) 2001, Plotnix, Inc,\n+ * <http://www.plotnix.com/>.\n+ * For more information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.jxpath.util;\n+\n+import org.apache.commons.jxpath.*;\n+import org.apache.commons.jxpath.ri.Compiler;\n+import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.functions.*;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.beans.*;\n+\n+/**\n+ * @author Dmitri Plotnikov\n+ * @version $Revision: 1.1 $ $Date: 2002/04/21 21:52:34 $\n+ */\n+public class ValueUtils {\n+    private static Map dynamicPropertyHandlerMap = new HashMap();\n+\n+    public static boolean isCollection(PropertyDescriptor propertyDescriptor){\n+        return false;\n+    }\n+\n+    public static boolean isCollection(PropertyDescriptor propertyDescriptor, Object value){\n+        return isCollection(value);\n+    }\n+\n+    public static boolean isCollection(Object value){\n+        if (value == null){\n+            return false;\n+        }\n+        else if (value.getClass().isArray()){\n+            return true;\n+        }\n+        else if (value instanceof Collection){\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static int getLength(Object bean, PropertyDescriptor propertyDescriptor){\n+        Object obj = getValue(bean, propertyDescriptor);\n+        return getLength(obj);\n+    }\n+\n+    public static int getLength(Object collection){\n+        if (collection == null){\n+            return 0;\n+        }\n+        else if (collection.getClass().isArray()){\n+            return Array.getLength(collection);\n+        }\n+        else if (collection instanceof Collection){\n+            return ((Collection)collection).size();\n+        }\n+        else {\n+            return 1;\n+        }\n+    }\n+\n+    public static Object expandCollection(Object collection, int size){\n+        if (collection == null){\n+            return null;\n+        }\n+        else if (collection.getClass().isArray()){\n+            Object bigger = Array.newInstance(collection.getClass().getComponentType(), size);\n+            System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection));\n+            return bigger;\n+        }\n+        else if (collection instanceof Collection){\n+            while (((Collection)collection).size() < size){\n+                ((Collection)collection).add(null);\n+            }\n+            return collection;\n+        }\n+        else {\n+            throw new RuntimeException(\"Cannot turn \" + collection.getClass().getName() +\n+                    \" into a collection of size \" + size);\n+        }\n+    }\n+\n+    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index){\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+            Object value;\n+            try {\n+                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                Method method = ipd.getIndexedReadMethod();\n+                if (method != null){\n+                    return method.invoke(bean, new Object[]{new Integer(index)});\n+                }\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                    \", \" + ex.getMessage());\n+            }\n+        }\n+        // We will fall through if there is no indexed read\n+\n+        return getValue(getValue(bean, propertyDescriptor), index);\n+    }\n+\n+    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value){\n+        if (propertyDescriptor instanceof IndexedPropertyDescriptor){\n+            try {\n+                IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor)propertyDescriptor;\n+                Method method = ipd.getIndexedWriteMethod();\n+                if (method != null){\n+                    method.invoke(bean,\n+                        new Object[]{new Integer(index),\n+                                     convert(value, ipd.getIndexedPropertyType())});\n+                    return;\n+                }\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                    \", \" + ex.getMessage());\n+            }\n+        }\n+        // We will fall through if there is no indexed read\n+        setValue(getValue(bean, propertyDescriptor), index, value);\n+    }\n+\n+    public static Object getValue(Object collection, int index){\n+        Object value = collection;\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                if (index < 0 || index >= Array.getLength(collection)){\n+                    return null;\n+                }\n+                value = Array.get(collection, index);\n+            }\n+            else if (collection instanceof List){\n+                if (index < 0 || index >= ((List)collection).size()){\n+                    return null;\n+                }\n+                value = ((List)collection).get(index);\n+            }\n+            else if (collection instanceof Collection){\n+                int i = 0;\n+                Iterator it = ((Collection)collection).iterator();\n+                for (; i < index; i++){\n+                    it.next();\n+                }\n+                if (it.hasNext()){\n+                    value = it.next();\n+                }\n+                else {\n+                    value = null;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    public static void setValue(Object collection, int index, Object value){\n+        if (collection != null){\n+            if (collection.getClass().isArray()){\n+                Array.set(collection, index, convert(value, collection.getClass().getComponentType()));\n+            }\n+            else if (collection instanceof List){\n+                ((List)collection).set(index, value);\n+            }\n+            else if (collection instanceof Collection){\n+                throw new UnsupportedOperationException(\"Cannot set value of an element of a \" +\n+                        collection.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor){\n+        Object value;\n+        try {\n+            Method method = getAccessibleMethod(propertyDescriptor.getReadMethod());\n+            if (method == null){\n+                throw new RuntimeException(\"No read method\");\n+            }\n+            value = method.invoke(bean, new Object[0]);\n+        }\n+        catch (Exception ex){\n+            ex.printStackTrace();\n+            throw new RuntimeException(\"Cannot access property: \" + propertyDescriptor.getName() +\n+                \", \" + ex.getMessage());\n+        }\n+        return value;\n+    }\n+\n+    public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value){\n+        try {\n+            Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod());\n+            if (method == null){\n+                throw new RuntimeException(\"No write method\");\n+            }\n+            value = convert(value, propertyDescriptor.getPropertyType());\n+            value = method.invoke(bean, new Object[]{value});\n+        }\n+        catch (Exception ex){\n+            throw new RuntimeException(\"Cannot modify property: \" + propertyDescriptor.getName() +\n+                \", \" + ex);\n+        }\n+    }\n+\n+    private static Object convert(Object value, Class type){\n+        if (!TypeUtils.canConvert(value, type)){\n+            throw new RuntimeException(\"Cannot convert value of class \" +\n+                    (value == null ? \"null\" : value.getClass().getName()) +\n+                    \" to type \" + type);\n+        }\n+        return TypeUtils.convert(value, type);\n+    }\n+\n+    /**\n+     * Returns a shared instance of the dynamic property handler class\n+     * returned by <code>getDynamicPropertyHandlerClass()</code>.\n+     */\n+    public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) {\n+        DynamicPropertyHandler handler = (DynamicPropertyHandler)dynamicPropertyHandlerMap.get(clazz);\n+        if (handler == null){\n+            try {\n+                handler = (DynamicPropertyHandler)clazz.newInstance();\n+            }\n+            catch (Exception ex){\n+                throw new RuntimeException(\"Cannot allocate dynamic property handler \" +\n+                    \" of class \" + clazz + \".\\n\" + ex);\n+            }\n+            dynamicPropertyHandlerMap.put(clazz, handler);\n+        }\n+        return handler;\n+    }\n+\n+    // -------------------------------------------------------- Private Methods\n+    //\n+    //  The rest of the code in this file was copied FROM\n+    //  org.apache.commons.beanutils.PropertyUtil. We don't want to introduce a dependency\n+    //  on BeanUtils yet - DP.\n+    //\n+\n+    /**\n+     * Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified Method.  If no such method\n+     * can be found, return <code>null</code>.\n+     *\n+     * @param method The method that we wish to call\n+     */\n+    private static Method getAccessibleMethod(Method method) {\n+\n+        // Make sure we have a method to check\n+        if (method == null) {\n+            return (null);\n+        }\n+\n+        // If the requested method is not public we cannot call it\n+        if (!Modifier.isPublic(method.getModifiers())) {\n+            return (null);\n+        }\n+\n+        // If the declaring class is public, we are done\n+        Class clazz = method.getDeclaringClass();\n+        if (Modifier.isPublic(clazz.getModifiers())) {\n+            return (method);\n+        }\n+\n+        // Check the implemented interfaces and subinterfaces\n+        String methodName = method.getName();\n+        Class[] parameterTypes = method.getParameterTypes();\n+        method =\n+            getAccessibleMethodFromInterfaceNest(clazz,\n+                                                 method.getName(),\n+                                                 method.getParameterTypes());\n+        return (method);\n+    }\n+\n+\n+    /**\n+     * Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such Method\n+     * can be found, return <code>null</code>.\n+     *\n+     * @param clazz Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest\n+        (Class clazz, String methodName, Class parameterTypes[]) {\n+\n+        Method method = null;\n+\n+        // Check the implemented interfaces of the parent class\n+        Class interfaces[] = clazz.getInterfaces();\n+        for (int i = 0; i < interfaces.length; i++) {\n+\n+            // Is this interface public?\n+            if (!Modifier.isPublic(interfaces[i].getModifiers()))\n+                continue;\n+\n+            // Does the method exist on this interface?\n+            try {\n+                method = interfaces[i].getDeclaredMethod(methodName,\n+                                                         parameterTypes);\n+            } catch (NoSuchMethodException e) {\n+                ;\n+            }\n+            if (method != null)\n+                break;\n+\n+            // Recursively check our parent interfaces\n+            method =\n+                getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                                                     methodName,\n+                                                     parameterTypes);\n+            if (method != null)\n+                break;\n+\n+        }\n+\n+        // Return whatever we have found\n+        return (method);\n+    }\n+}\n--- a/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n+++ b/src/test/org/apache/commons/jxpath/JXPathTestCase.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.11 2002/04/11 02:57:41 dmitri Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/04/11 02:57:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/JXPathTestCase.java,v 1.12 2002/04/21 21:52:34 dmitri Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2002/04/21 21:52:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.jxpath.ri.*;\n import org.apache.commons.jxpath.ri.parser.*;\n-import org.apache.commons.jxpath.ri.pointers.*;\n+import org.apache.commons.jxpath.ri.model.*;\n+import org.apache.commons.jxpath.ri.model.beans.*;\n import org.apache.commons.jxpath.ri.axes.*;\n import org.apache.commons.jxpath.ri.compiler.*;\n+import org.apache.commons.jxpath.ri.compiler.Expression;\n import java.beans.*;\n \n+import org.apache.xpath.XPath;\n+import org.apache.xpath.XPathContext;\n+import org.apache.xml.utils.PrefixResolver;\n+import org.apache.xml.utils.PrefixResolverDefault;\n \n /**\n  * <p>\n  * <p>\n  *   Note that the tests are dependant upon the static aspects\n  *   (such as array sizes...) of the TestBean.java class, so ensure\n- *   than all changes to TestBean are reflected here.\n+ *   that all changes to TestBean are reflected here.\n  * </p>\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.11 $ $Date: 2002/04/11 02:57:41 $\n+ * @version $Revision: 1.12 $ $Date: 2002/04/21 21:52:34 $\n  */\n \n public class JXPathTestCase extends TestCase\n      * Test property iterators, the core of the graph traversal engine\n      */\n     public void testIndividualIterators(){\n-        if (enabled){\n+        if (true){\n //        testIndividual(0, 0, true, false, 3);\n             testIndividual(+1, 0, true, false, 0);\n             testIndividual(-1, 0, true, false, 4);\n     }\n \n     private void testIndividual(int relativePropertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n-        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.createNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.newNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n         NodeIterator it;\n \n         if (useStartLocation){\n             PropertyPointer holder = root.getPropertyPointer();\n             holder.setPropertyIndex(relativeProperty(holder, relativePropertyIndex));\n             holder.setIndex(offset);\n-            it = holder.siblingIterator(new NodeNameTest(new QName(null, \"integers\")), reverse);\n+            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse, holder);\n         }\n         else {\n-            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse);\n+            it = root.childIterator(new NodeNameTest(new QName(null, \"integers\")), reverse, null);\n         }\n \n         int size = 0;\n     }\n \n     public void testMultipleIterators(){\n-        if (enabled){\n+        if (true){\n             testMultiple(0, 0, true, false, 20);\n \n             testMultiple(3, 0, true, false, 16);\n     }\n \n     private void testMultiple(int propertyIndex, int offset, boolean useStartLocation, boolean reverse, int expected){\n-        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.createNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n+        PropertyOwnerPointer root = (PropertyOwnerPointer)NodePointer.newNodePointer(new QName(null, \"root\"), bean, Locale.getDefault());\n         NodeIterator it;\n \n         if (useStartLocation){\n             PropertyPointer holder = root.getPropertyPointer();\n             holder.setPropertyIndex(propertyIndex);\n             holder.setIndex(offset);\n-            it = holder.siblingIterator(null, reverse);\n+            it = root.childIterator(null, reverse, holder);\n         }\n         else {\n-            it = root.childIterator(null, reverse);\n+            it = root.childIterator(null, reverse, null);\n         }\n \n         int size = 0;\n      * Test JXPath.getValue() with various arguments\n      */\n     public void testGetValue(){\n-        if (enabled){\n-            JXPathContext context = JXPathContext.newContext(bean);\n-            testGetValue(context, \"2+2\",                     new Double(4.0));\n-            testGetValue(context, \"boolean\",                 Boolean.FALSE);\n-            testGetValue(context, \"substring(boolean, 1,2)\", \"fa\"); // 'fa'lse\n-            testGetValue(context, \"int*2\",                   new Double(2.0));\n-            testGetValue(context, \"integers[1]\",             new Integer(1));\n-            testGetValue(context, \"nestedBean\",              bean.getNestedBean());\n-            testGetValue(context, \"nestedBean/boolean\",      Boolean.FALSE);\n-            testGetValue(context, \"object/name\",             \"Name 5\");\n-            testGetValue(context, \"objects[1]\",              new Integer(1));\n-            testGetValue(context, \"map/Key1\",                \"Value 1\");\n-            testGetValue(context, \"beans[name = 'Name 1']\",  bean.getBeans()[0]);\n-            testGetValue(context, \".[1]/int\",                new Integer(1));\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(bean);\n+        testGetValue(context, \"2+2\",                     new Double(4.0));\n+        testGetValue(context, \"boolean\",                 Boolean.FALSE);\n+        testGetValue(context, \"substring(boolean, 1,2)\", \"fa\"); // 'fa'lse\n+        testGetValue(context, \"int*2\",                   new Double(2.0));\n+        testGetValue(context, \"integers[1]\",             new Integer(1));\n+        testGetValue(context, \"nestedBean\",              bean.getNestedBean());\n+        testGetValue(context, \"nestedBean/boolean\",      Boolean.FALSE);\n+        testGetValue(context, \"object/name\",             \"Name 5\");\n+        testGetValue(context, \"objects[1]\",              new Integer(1));\n+        testGetValue(context, \"map/Key1\",                \"Value 1\");\n+        testGetValue(context, \"beans[name = 'Name 1']\",  bean.getBeans()[0]);\n+        testGetValue(context, \".[1]/int\",                new Integer(1));\n //        testGetValue(context, \"id('foo')\",               new Integer(1));\n //        testGetValue(context, \"key('foo', 'bar')\",               new Integer(1));\n-            testGetValue(context, \"integers[1]\",            new Double(1), Double.class);\n-            testGetValue(context, \"2 + 3\",                  \"5.0\", String.class);\n-            testGetValue(context, \"2 + 3\",                  Boolean.TRUE, boolean.class);\n-            boolean exception = false;\n-            try {\n-                testGetValue(context, \"'foo'\",                  null, Date.class);\n-            }\n-            catch(Exception ex){\n-                exception = true;\n-            }\n-            assertTrue(\"Type conversion exception\", exception);\n-        }\n+        testGetValue(context, \"integers[1]\",            new Double(1), Double.class);\n+        testGetValue(context, \"2 + 3\",                  \"5.0\", String.class);\n+        testGetValue(context, \"2 + 3\",                  Boolean.TRUE, boolean.class);\n+        boolean exception = false;\n+        try {\n+            testGetValue(context, \"'foo'\",                  null, Date.class);\n+        }\n+        catch(Exception ex){\n+            exception = true;\n+        }\n+        assertTrue(\"Type conversion exception\", exception);\n     }\n \n     /**\n      * Test JXPath.createPath() with various arguments\n      */\n     public void testCreatePath(){\n-        if (enabled){\n-            TestBean tBean = new TestBean();\n-            tBean.setNestedBean(null);\n-            tBean.setBeans(null);\n-            tBean.setMap(null);\n-            JXPathContext context = JXPathContext.newContext(tBean);\n-            context.setFactory(new TestFactory());\n-\n-            // Calls factory.declareVariable(\"string\")\n-            testCreatePath(context, \"$string\", \"Value\");\n-\n-            // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n-            testCreatePath(context, \"$stringArray[2]\", \"Value2\");\n-            assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n-\n-            context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n-\n-            // Does not involve factory at all - just expands the collection\n-            testCreatePath(context, \"$array[2]\", \"Value2\");\n-            assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n-\n-            // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n-            testCreatePath(context, \"$test/boolean\", Boolean.TRUE);\n-\n-            // Calls factory.declareVariable(\"testArray\").\n-            // The factory should create a collection of TestBeans.\n-            // Then calls factory.createObject(..., collection, \"testArray\", 1).\n-            // That one should produce an instance of TestBean and put it in the collection\n-            // at index 1.\n-            testCreatePath(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n-\n-            // Calls factory.createObject(..., TestBean, \"nestedBean\")\n-            testCreatePath(context, \"nestedBean/int\", new Integer(1));\n-\n-            // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n-            // factory.createObject(..., testBean, \"beans\", 2)\n-            testCreatePath(context, \"beans[2]/int\", new Integer(2));\n-\n-            // Another, but the collection already exists\n-            testCreatePath(context, \"beans[3]/int\", new Integer(3));\n-\n-            // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n-            // sets the value\n-            testCreatePath(context, \"nestedBean/strings[2]\", \"Test\");\n-\n-            // Calls factory.createObject(..., testBean, \"map\"), then\n-            // sets the value\n-            testCreatePath(context, \"map[@name = 'TestKey1']\", \"Test\");\n-\n-            // Calls factory.createObject(..., testBean, \"map\"), then\n-            // then factory.createObject(..., map, \"TestKey2\"), then\n-            // sets the value\n-            testCreatePath(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n-\n-            // Calls factory.expandCollection(..., map, \"TestKey3\", 2), then\n-            testCreatePath(context, \"map/TestKey3[2]\", \"Test\");\n-\n-            // Should be the same as the one before\n-            testCreatePath(context, \"map[@name='TestKey3'][3]\", \"Test\");\n-\n-            // Comprehensive tests: map & bean\n-            tBean.setMap(null);\n-            testCreatePath(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(5));\n-            tBean.setMap(null);\n-            testCreatePath(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(6));\n-        }\n+//        if (!enabled){\n+//            return;\n+//        }\n+        TestBean tBean = createTestBeanWithDOM();\n+        tBean.setNestedBean(null);\n+        tBean.setBeans(null);\n+        tBean.setMap(null);\n+        JXPathContext context = JXPathContext.newContext(tBean);\n+        context.setFactory(new TestFactory());\n+\n+        // Calls factory.declareVariable(\"string\")\n+        testCreatePath(context, \"$string\", \"Value\");\n+\n+        // Calls factory.declareVariable(\"stringArray\"). The factory needs to create a collection\n+        testCreatePath(context, \"$stringArray[2]\", \"Value2\");\n+        assertEquals(\"Created <\" + \"$stringArray[1]\" + \">\", \"Value1\", context.getValue(\"$stringArray[1]\"));\n+\n+        context.getVariables().declareVariable(\"array\", new String[]{\"Value1\"});\n+\n+        // Does not involve factory at all - just expands the collection\n+        testCreatePath(context, \"$array[2]\", \"Value2\");\n+\n+        // Make sure it is still the same array\n+        assertEquals(\"Created <\" + \"$array[1]\" + \">\", \"Value1\", context.getValue(\"$array[1]\"));\n+\n+        // Calls factory.declareVariable(\"test\"). The factory should create a TestBean\n+        testCreatePath(context, \"$test/boolean\", Boolean.TRUE);\n+\n+        // Calls factory.declareVariable(\"testArray\").\n+        // The factory should create a collection of TestBeans.\n+        // Then calls factory.createObject(..., collection, \"testArray\", 1).\n+        // That one should produce an instance of TestBean and put it in the collection\n+        // at index 1.\n+        testCreatePath(context, \"$testArray[2]/boolean\", Boolean.TRUE);\n+\n+        // Calls factory.createObject(..., TestBean, \"nestedBean\")\n+        testCreatePath(context, \"nestedBean/int\", new Integer(1));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // factory.createObject(..., testBean, \"beans\", 2)\n+        testCreatePath(context, \"beans[2]/int\", new Integer(2));\n+\n+        // Another, but the collection already exists\n+        testCreatePath(context, \"beans[3]/int\", new Integer(3));\n+\n+        // Calls factory.expandCollection(..., testBean, \"beans\", 2), then\n+        // sets the value\n+        testCreatePath(context, \"nestedBean/strings[2]\", \"Test\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // sets the value\n+        testCreatePath(context, \"map[@name = 'TestKey1']\", \"Test\");\n+\n+        // Calls factory.createObject(..., testBean, \"map\"), then\n+        // then factory.createObject(..., map, \"TestKey2\"), then\n+        // sets the value\n+        testCreatePath(context, \"map[@name = 'TestKey2']/int\", new Integer(4));\n+\n+        // Calls factory.expandCollection(..., map, \"TestKey3\", 2)\n+        testCreatePath(context, \"map/TestKey3[2]\", \"Test\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"map[@name='TestKey3'][3]\", \"Test\");\n+\n+        // Create an element of a dynamic map element, which is a collection\n+        testCreatePath(context, \"map/TestKey4[1]/int\", new Integer(5));\n+\n+        tBean.getMap().remove(\"TestKey4\");\n+\n+        // Should be the same as the one before\n+        testCreatePath(context, \"map[@name = 'TestKey4'][1]/int\", new Integer(5));\n+\n+        // Create a DOM element\n+        testCreatePath(context, \"vendor/location[3]\", \"\");\n+\n+        // Create a DOM element with contents\n+        testCreatePath(context, \"vendor/location[3]/address/street\", \"Lemon Circle\");\n+\n+        // Comprehensive tests: map & bean\n+        tBean.setMap(null);\n+        testCreatePath(context, \"map[@name = 'TestKey5']/nestedBean/int\", new Integer(6));\n+        tBean.setMap(null);\n+        testCreatePath(context, \"map[@name = 'TestKey5']/beans[2]/int\", new Integer(7));\n     }\n \n     private void testCreatePath(JXPathContext context, String path, Object value){\n     }\n \n     public void testNull(){\n-        if (enabled){\n-            JXPathContext context = JXPathContext.newContext(new TestNull());\n-            testGetValue(context, \"nothing\", null);\n-            testGetValue(context, \"child/nothing\", null);\n-            testGetValue(context, \"array[2]\", null);\n-            context.setLenient(true);\n-            testGetValue(context, \"nothing/something\", null);\n-            testGetValue(context, \"array[2]/something\", null);\n-        }\n+        if (!enabled){\n+            return;\n+        }\n+        JXPathContext context = JXPathContext.newContext(new TestNull());\n+        testGetValue(context, \"nothing\", null);\n+        testGetValue(context, \"child/nothing\", null);\n+        testGetValue(context, \"array[2]\", null);\n+        context.setLenient(true);\n+        testGetValue(context, \"nothing/something\", null);\n+        testGetValue(context, \"array[2]/something\", null);\n     }\n \n     /**\n         }\n \n         public Pointer getContextNodePointer(){\n-            return NodePointer.createNodePointer(null, object, Locale.getDefault());\n+            return NodePointer.newNodePointer(null, object, Locale.getDefault());\n         }\n \n         public List getContextNodeList(){\n     }\n \n     static final XP[] xpath_tests = new XP[]{\n+\n         // Numbers\n         test(\"1\", new Double(1.0)),\n         testEval(\"1\", list(new Double(1.0))),\n         // Traversal\n         // ancestor::\n         test(\"int/ancestor::root = /\", Boolean.TRUE),\n-//        testEval(\"beans/name/ancestor-or-self::node()\", new Double(5)),\n         test(\"count(beans/name/ancestor-or-self::node())\", new Double(5)),\n         test(\"beans/name/ancestor-or-self::node()[3] = /\", Boolean.TRUE),\n \n         test(\"nestedBean/name\", \"Name 0\"),\n         testPath(\"nestedBean/name\", \"/nestedBean/name\"),\n         testEvalPath(\"nestedBean/name\", list(\"/nestedBean/name\")),\n+\n         testEval(\"integers\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n         testPath(\"integers\", \"/integers\"),\n         testEvalPath(\"integers\", list(\"/integers[1]\", \"/integers[2]\", \"/integers[3]\", \"/integers[4]\")),\n         testEval(\"beans[1]/strings\", list(\"String 1\", \"String 2\", \"String 3\")),\n         testEval(\"beans/strings[2]\", list(\"String 2\", \"String 2\")),\n         test(\"beans/strings[2]\", \"String 2\"),\n+\n+        test(\"beans/strings[name(.)='strings'][2]\", \"String 2\"),\n         test(\"(beans/strings[2])[1]\", \"String 2\"),\n         test(\"count(*)\", new Double(21)),\n         test(\"count(child::node())\", new Double(21)),\n         test(\"count((integers | beans[1]/strings)[name(.) = 'strings'])\", new Double(3)),\n \n         // Note that the following is different from \"integer[2]\" - it is a filter expression\n-        test(\"(integers)[2]\", new Integer(2)),\n+        test(\"(integers)[2]\", new Integer(2)),        // TBD\n \n         // Core functions\n         test(\"integers[last()]\", new Integer(4)),\n         test(\"integers[position() = last() - 1]\", new Integer(3)),\n         testEval(\"integers[position() < 3]\", list(new Integer(1), new Integer(2))),\n         test(\"count(beans/strings)\", new Double(6)),\n-//        test(\"integers[string() = '2.0']\", new Integer(2)),  // Incorrect -- TBD\n+        test(\"integers[string() = '2.0']\", new Integer(2)),\n \n         test(\"name(integers)\", \"integers\"),\n         testEval(\"*[name(.) = 'integers']\", list(new Integer(1), new Integer(2), new Integer(3), new Integer(4))),\n         test(\"/beans[contains(test:path(), '[2]')]/name\", \"Name 2\"),\n \n         // null\n+        testPath(\"$null\", \"$null\"),\n+        testPath(\"$null[3]\", \"$null[3]\"),\n         testPath(\"$testnull/nothing\", \"$testnull/nothing\"),\n+        testPath(\"$testnull/nothing[2]\", \"$testnull/nothing[2]\"),\n+        testPath(\"beans[8]/int\", \"/beans[8]/int\"),\n         testEval(\"$testnull/nothing[1]\", Collections.EMPTY_LIST),\n     };\n \n         testPath(\"$test/object/vendor/location[1]//street\", \"$test/object/vendor[1]/location[1]/address[1]/street[1]\"),\n         test(\"$object//street\", \"Orchard Road\"),\n         testPath(\"$object//street\", \"$object/vendor[1]/location[1]/address[1]/street[1]\"),\n-\n-        testPath(\"$null\", \"$null\"),\n-//        testPath(\"$null[3]\", \"$null[3]\"),\n     };\n-}\n-\n+}\n--- a/src/test/org/apache/commons/jxpath/TestBeanWithDOM.java\n+++ b/src/test/org/apache/commons/jxpath/TestBeanWithDOM.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestBeanWithDOM.java,v 1.1 2001/09/03 01:22:31 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/03 01:22:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestBeanWithDOM.java,v 1.2 2002/04/21 21:52:34 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/21 21:52:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  * General purpose test bean for JUnit tests for the \"jxpath\" component.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2001/09/03 01:22:31 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:34 $\n  */\n public class TestBeanWithDOM extends TestBean {\n     private Node node;\n \n     public Node getVendor(){\n         return node;\n+    }\n+\n+    public Node[] getVendors(){\n+        return new Node[]{node};\n     }\n \n     public void setVendor(Node node){\n--- a/src/test/org/apache/commons/jxpath/TestFactory.java\n+++ b/src/test/org/apache/commons/jxpath/TestFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.1 2002/04/10 03:40:21 dmitri Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/04/10 03:40:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//jxpath/src/test/org/apache/commons/jxpath/Attic/TestFactory.java,v 1.2 2002/04/21 21:52:34 dmitri Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/04/21 21:52:34 $\n  *\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n package org.apache.commons.jxpath;\n \n import java.util.*;\n+import org.w3c.dom.*;\n \n /**\n  * Test AbstractFactory.\n  *\n  * @author Dmitri Plotnikov\n- * @version $Revision: 1.1 $ $Date: 2002/04/10 03:40:21 $\n+ * @version $Revision: 1.2 $ $Date: 2002/04/21 21:52:34 $\n  */\n public class TestFactory extends AbstractFactory {\n \n             ((TestBean[])parent)[index] = new TestBean();\n             return true;\n         }\n+        else if (name.equals(\"strings\")){\n+            NestedTestBean bean = (NestedTestBean)parent;\n+            bean.setStrings(new String[index + 1]);\n+            bean.getStrings()[index] = \"\";\n+            return true;\n+        }\n         else if (name.equals(\"nestedBean\")){\n             ((TestBean)parent).setNestedBean(new NestedTestBean(\"newName\"));\n             return true;\n         }\n         else if (name.equals(\"beans\")){\n+            TestBean bean = (TestBean)parent;\n+            if (bean.getBeans() == null || index >= bean.getBeans().length){\n+                bean.setBeans(new NestedTestBean[index + 1]);\n+            }\n             ((TestBean)parent).getBeans()[index] = new NestedTestBean(\"newName\");\n             return true;\n         }\n             ((Map)parent).put(name, new Vector());\n             return true;\n         }\n+        else if (name.equals(\"TestKey4\")){\n+            ((Map)parent).put(name, new Object[]{new TestBean()});\n+            return true;\n+        }\n         else if (name.equals(\"TestKey5\")){\n             TestBean tb = new TestBean();\n             tb.setNestedBean(null);\n             ((Map)parent).put(name, tb);\n             return true;\n         }\n+        else if (name.equals(\"location\") || name.equals(\"address\") || name.equals(\"street\")){\n+            addElement((Node)parent, index, name);\n+            return true;\n+        }\n         return false;\n+    }\n+\n+    private void addElement(Node parent, int index, String tag){\n+        boolean repeat = true;\n+        while(repeat){\n+            Node child = parent.getFirstChild();\n+            int count = 0;\n+            while (child != null){\n+                if (child.getNodeName().equals(tag)){\n+                    if (count == index){\n+                        repeat = false;\n+                        break;\n+                    }\n+                    count++;\n+                }\n+                child = child.getNextSibling();\n+            }\n+            if (child != null){\n+                child = child.getNextSibling();\n+            }\n+            Node newElement = parent.getOwnerDocument().createElement(tag);\n+            if (child != null){\n+                parent.insertBefore(newElement, child);\n+            }\n+            else {\n+                parent.appendChild(newElement);\n+            }\n+        }\n     }\n \n     /**\n         context.getVariables().declareVariable(name, null);\n         return true;\n     }\n-\n-    public boolean expandCollection(JXPathContext context, Pointer pointer, Object parent, String name, int size){\n-        if (name.equals(\"beans\")){\n-            TestBean bean = (TestBean)parent;\n-            bean.setBeans(new NestedTestBean[size]);\n-            return true;\n-        }\n-        else if (name.equals(\"strings\")){\n-            NestedTestBean bean = (NestedTestBean)parent;\n-            bean.setStrings(new String[size]);\n-            return true;\n-        }\n-        return false;\n-    }\n }", "timestamp": 1019425954, "metainfo": ""}