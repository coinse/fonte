{"sha": "e99193605b688e923d20054c13db897cff751607", "log": "Reuse Tokens, instead of creating all the time  Saves an awful lot of GC. These are just data transfer objects, so not worth creating every time.", "commit": "\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n     private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n-    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+    private List<String> pendingTableCharacters = new ArrayList<String>(); // chars in table to be shifted out\n+    private Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag\n \n     private boolean framesetOk = true; // if ok to go into frameset\n     private boolean fosterInserts = false; // if next inserts should be fostered\n             Element el = insertEmpty(startTag);\n             stack.add(el);\n             tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n-            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n+            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n     }\n \n     void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<Token.Character>();\n-    }\n-\n-    List<Token.Character> getPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<String>();\n+    }\n+\n+    List<String> getPendingTableCharacters() {\n         return pendingTableCharacters;\n     }\n \n-    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n         this.pendingTableCharacters = pendingTableCharacters;\n     }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 tb.setHeadElement(head);\n                 tb.transition(InHead);\n             } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             } else if (t.isEndTag()) {\n                 tb.error(this);\n                 return false;\n             } else {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             }\n             return true;\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            tb.process(new Token.EndTag(\"head\"));\n+            tb.processEndTag(\"head\");\n             return tb.process(t);\n         }\n     },\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            tb.process(new Token.EndTag(\"noscript\"));\n+            tb.processEndTag(\"noscript\");\n             return tb.process(t);\n         }\n     },\n         }\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n-            tb.process(new Token.StartTag(\"body\"));\n+            tb.processStartTag(\"body\");\n             tb.framesetOk(true);\n             return tb.process(t);\n         }\n                         }\n                     } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.Headings)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                             tb.error(this);\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         // todo: ignore LF if next token\n                             return false;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertForm(startTag, true);\n                     } else if (name.equals(\"li\")) {\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (el.nodeName().equals(\"li\")) {\n-                                tb.process(new Token.EndTag(\"li\"));\n+                                tb.processEndTag(\"li\");\n                                 break;\n                             }\n                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.DdDt)) {\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n-                                tb.process(new Token.EndTag(el.nodeName()));\n+                                tb.processEndTag(el.nodeName());\n                                 break;\n                             }\n                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (name.equals(\"plaintext\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                         if (tb.inButtonScope(\"button\")) {\n                             // close and reprocess\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"button\"));\n+                            tb.processEndTag(\"button\");\n                             tb.process(startTag);\n                         } else {\n                             tb.reconstructFormattingElements();\n                     } else if (name.equals(\"a\")) {\n                         if (tb.getActiveFormattingElement(\"a\") != null) {\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"a\"));\n+                            tb.processEndTag(\"a\");\n \n                             // still on stack?\n                             Element remainingA = tb.getFromStack(\"a\");\n                         tb.reconstructFormattingElements();\n                         if (tb.inScope(\"nobr\")) {\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"nobr\"));\n+                            tb.processEndTag(\"nobr\");\n                             tb.reconstructFormattingElements();\n                         }\n                         Element el = tb.insert(startTag);\n                         tb.framesetOk(false);\n                     } else if (name.equals(\"table\")) {\n                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.framesetOk(false);\n                         tb.insertEmpty(startTag);\n                     } else if (name.equals(\"hr\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertEmpty(startTag);\n                         tb.framesetOk(false);\n                             return false;\n \n                         tb.tokeniser.acknowledgeSelfClosingFlag();\n-                        tb.process(new Token.StartTag(\"form\"));\n+                        tb.processStartTag(\"form\");\n                         if (startTag.attributes.hasKey(\"action\")) {\n                             Element form = tb.getFormElement();\n                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n                         }\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.StartTag(\"label\"));\n+                        tb.processStartTag(\"hr\");\n+                        tb.processStartTag(\"label\");\n                         // hope you like english.\n                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                 startTag.attributes.get(\"prompt\") :\n                                 \"This is a searchable index. Enter search keywords: \";\n \n-                        tb.process(new Token.Character(prompt));\n+                        tb.process(new Token.Character().data(prompt));\n \n                         // input\n                         Attributes inputAttribs = new Attributes();\n                                 inputAttribs.put(attr);\n                         }\n                         inputAttribs.put(\"name\", \"isindex\");\n-                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n-                        tb.process(new Token.EndTag(\"label\"));\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.EndTag(\"form\"));\n+                        tb.processStartTag(\"input\", inputAttribs);\n+                        tb.processEndTag(\"label\");\n+                        tb.processStartTag(\"hr\");\n+                        tb.processEndTag(\"form\");\n                     } else if (name.equals(\"textarea\")) {\n                         tb.insert(startTag);\n                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                         tb.transition(Text);\n                     } else if (name.equals(\"xmp\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.reconstructFormattingElements();\n                         tb.framesetOk(false);\n                             tb.transition(InSelect);\n                     } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                             tb.transition(AfterBody);\n                         }\n                     } else if (name.equals(\"html\")) {\n-                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n+                        boolean notIgnored = tb.processEndTag(\"body\");\n                         if (notIgnored)\n                             return tb.process(endTag);\n                     } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                     } else if (name.equals(\"p\")) {\n                         if (!tb.inButtonScope(name)) {\n                             tb.error(this);\n-                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n+                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                             return tb.process(endTag);\n                         } else {\n                             tb.generateImpliedEndTags(name);\n                         }\n                     } else if (name.equals(\"br\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"br\"));\n+                        tb.processStartTag(\"br\");\n                         return false;\n                     } else {\n                         return anyOtherEndTag(t, tb);\n                     tb.insert(startTag);\n                     tb.transition(InColumnGroup);\n                 } else if (name.equals(\"col\")) {\n-                    tb.process(new Token.StartTag(\"colgroup\"));\n+                    tb.processStartTag(\"colgroup\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                     tb.clearStackToTableContext();\n                     tb.insert(startTag);\n                     tb.transition(InTableBody);\n                 } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n-                    tb.process(new Token.StartTag(\"tbody\"));\n+                    tb.processStartTag(\"tbody\");\n                     return tb.process(t);\n                 } else if (name.equals(\"table\")) {\n                     tb.error(this);\n-                    boolean processed = tb.process(new Token.EndTag(\"table\"));\n+                    boolean processed = tb.processEndTag(\"table\");\n                     if (processed) // only ignored if in fragment\n                         return tb.process(t);\n                 } else if (StringUtil.in(name, \"style\", \"script\")) {\n                         tb.error(this);\n                         return false;\n                     } else {\n-                        tb.getPendingTableCharacters().add(c);\n+                        tb.getPendingTableCharacters().add(c.getData());\n                     }\n                     break;\n                 default:\n+                    // todo - don't really like the way these table character data lists are built\n                     if (tb.getPendingTableCharacters().size() > 0) {\n-                        for (Token.Character character : tb.getPendingTableCharacters()) {\n+                        for (String character : tb.getPendingTableCharacters()) {\n                             if (!isWhitespace(character)) {\n                                 // InTable anything else section:\n                                 tb.error(this);\n                                 if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                     tb.setFosterInserts(true);\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                     tb.setFosterInserts(false);\n                                 } else {\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                 }\n                             } else\n-                                tb.insert(character);\n+                                tb.insert(new Token.Character().data(character));\n                         }\n                         tb.newPendingTableCharacters();\n                     }\n                             t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n                     ) {\n                 tb.error(this);\n-                boolean processed = tb.process(new Token.EndTag(\"caption\"));\n+                boolean processed = tb.processEndTag(\"caption\");\n                 if (processed)\n                     return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"colgroup\"));\n+            boolean processed = tb.processEndTag(\"colgroup\");\n             if (processed) // only ignored in frag case\n                 return tb.process(t);\n             return true;\n                         tb.transition(InRow);\n                     } else if (StringUtil.in(name, \"th\", \"td\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"tr\"));\n+                        tb.processStartTag(\"tr\");\n                         return tb.process(startTag);\n                     } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                         return exitTableBody(t, tb);\n                 return false;\n             }\n             tb.clearStackToTableBodyContext();\n-            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead\n+            tb.processEndTag(tb.currentElement().nodeName()); // tbody, tfoot, thead\n             return tb.process(t);\n         }\n \n                         tb.error(this);\n                         return false;\n                     }\n-                    tb.process(new Token.EndTag(\"tr\"));\n+                    tb.processEndTag(\"tr\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                     tb.error(this);\n         }\n \n         private boolean handleMissingTr(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"tr\"));\n+            boolean processed = tb.processEndTag(\"tr\");\n             if (processed)\n                 return tb.process(t);\n             else\n \n         private void closeCell(HtmlTreeBuilder tb) {\n             if (tb.inTableScope(\"td\"))\n-                tb.process(new Token.EndTag(\"td\"));\n+                tb.processEndTag(\"td\");\n             else\n-                tb.process(new Token.EndTag(\"th\")); // only here if th or td in scope\n+                tb.processEndTag(\"th\"); // only here if th or td in scope\n         }\n     },\n     InSelect {\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n-                        tb.process(new Token.EndTag(\"option\"));\n+                        tb.processEndTag(\"option\");\n                         tb.insert(start);\n                     } else if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"optgroup\"));\n+                            tb.processEndTag(\"optgroup\");\n                         tb.insert(start);\n                     } else if (name.equals(\"select\")) {\n                         tb.error(this);\n-                        return tb.process(new Token.EndTag(\"select\"));\n+                        return tb.processEndTag(\"select\");\n                     } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                         tb.error(this);\n                         if (!tb.inSelectScope(\"select\"))\n                             return false; // frag\n-                        tb.process(new Token.EndTag(\"select\"));\n+                        tb.processEndTag(\"select\");\n                         return tb.process(start);\n                     } else if (name.equals(\"script\")) {\n                         return tb.process(t, InHead);\n                     name = end.name();\n                     if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                             tb.pop();\n                         else\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n-                tb.process(new Token.EndTag(\"select\"));\n+                tb.processEndTag(\"select\");\n                 return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n                 if (tb.inTableScope(t.asEndTag().name())) {\n-                    tb.process(new Token.EndTag(\"select\"));\n+                    tb.processEndTag(\"select\");\n                     return (tb.process(t));\n                 } else\n                     return false;\n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n             String data = t.asCharacter().getData();\n-            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n-            for (int i = 0; i < data.length(); i++) {\n-                char c = data.charAt(i);\n-                if (!StringUtil.isWhitespace(c))\n-                    return false;\n-            }\n-            return true;\n+            return isWhitespace(data);\n         }\n         return false;\n+    }\n+\n+    private static boolean isWhitespace(String data) {\n+        // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n+        for (int i = 0; i < data.length(); i++) {\n+            char c = data.charAt(i);\n+            if (!StringUtil.isWhitespace(c))\n+                return false;\n+        }\n+        return true;\n     }\n \n     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         return this.getClass().getSimpleName();\n     }\n \n+    /**\n+     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n+     * piece of data, which immediately get GCed.\n+     */\n+    abstract Token reset();\n+\n+    static void reset(StringBuilder sb) {\n+        if (sb != null) {\n+            sb.delete(0, sb.length());\n+        }\n+    }\n+\n     static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n         final StringBuilder publicIdentifier = new StringBuilder();\n             type = TokenType.Doctype;\n         }\n \n+        @Override\n+        Token reset() {\n+            reset(name);\n+            reset(publicIdentifier);\n+            reset(systemIdentifier);\n+            forceQuirks = false;\n+            return this;\n+        }\n+\n         String getName() {\n             return name.toString();\n         }\n     static abstract class Tag extends Token {\n         protected String tagName;\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n-        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n-\n+        private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n         Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n+\n+        @Override\n+        Tag reset() {\n+            tagName = null;\n+            pendingAttributeName = null;\n+            reset(pendingAttributeValue);\n+            hasPendingAttributeValue = false;\n+            selfClosing = false;\n+            attributes = null;\n+            return this;\n+        }\n \n         final void newAttribute() {\n             if (attributes == null)\n \n             if (pendingAttributeName != null) {\n                 Attribute attribute;\n-                if (pendingAttributeValue == null)\n+                if (!hasPendingAttributeValue)\n                     attribute = new Attribute(pendingAttributeName, \"\");\n                 else\n                     attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n                 attributes.put(attribute);\n             }\n             pendingAttributeName = null;\n-            if (pendingAttributeValue != null)\n-                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n+            reset(pendingAttributeValue);\n         }\n \n         final void finaliseTag() {\n         }\n \n         private void ensureAttributeValue() {\n-            if (pendingAttributeValue == null)\n-                pendingAttributeValue = new StringBuilder();\n+            hasPendingAttributeValue = true;\n         }\n     }\n \n             type = TokenType.StartTag;\n         }\n \n-        StartTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n-        StartTag(String name, Attributes attributes) {\n-            this();\n+        @Override\n+        Tag reset() {\n+            super.reset();\n+            attributes = new Attributes();\n+            // todo - would prefer these to be null, but need to check Element assertions\n+            return this;\n+        }\n+\n+        StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n+            return this;\n         }\n \n         @Override\n             type = TokenType.EndTag;\n         }\n \n-        EndTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n         @Override\n         public String toString() {\n             return \"</\" + name() + \">\";\n         final StringBuilder data = new StringBuilder();\n         boolean bogus = false;\n \n+        @Override\n+        Token reset() {\n+            reset(data);\n+            bogus = false;\n+            return this;\n+        }\n+\n         Comment() {\n             type = TokenType.Comment;\n         }\n     }\n \n     final static class Character extends Token {\n-        private final String data;\n-\n-        Character(String data) {\n+        private String data;\n+\n+        Character() {\n+            super();\n             type = TokenType.Character;\n+        }\n+\n+        @Override\n+        Token reset() {\n+            data = null;\n+            return this;\n+        }\n+\n+        Character data(String data) {\n             this.data = data;\n+            return this;\n         }\n \n         String getData() {\n     final static class EOF extends Token {\n         EOF() {\n             type = Token.TokenType.EOF;\n+        }\n+\n+        @Override\n+        Token reset() {\n+            return this;\n         }\n     }\n \n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n \n import java.util.Arrays;\n     private boolean isEmitPending = false;\n     private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n     private StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n-    StringBuilder dataBuffer; // buffers data looking for </script>\n+    StringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n \n     Token.Tag tagPending; // tag we are building up\n-    Token.Doctype doctypePending; // doctype building up\n-    Token.Comment commentPending; // comment building up\n-    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n+    Token.StartTag startPending = new Token.StartTag();\n+    Token.EndTag endPending = new Token.EndTag();\n+    Token.Character charPending = new Token.Character();\n+    Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n+    Token.Comment commentPending = new Token.Comment(); // comment building up\n+    private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n             String str = charsBuilder.toString();\n             charsBuilder.delete(0, charsBuilder.length());\n             charsString = null;\n-            return new Token.Character(str);\n+            return charPending.data(str);\n         } else if (charsString != null) {\n-            Token token = new Token.Character(charsString);\n+            Token token = charPending.data(charsString);\n             charsString = null;\n             return token;\n         } else {\n \n         if (token.type == Token.TokenType.StartTag) {\n             Token.StartTag startTag = (Token.StartTag) token;\n-            lastStartTag = startTag;\n+            lastStartTag = startTag.tagName;\n             if (startTag.selfClosing)\n                 selfClosingFlagAcknowledged = false;\n         } else if (token.type == Token.TokenType.EndTag) {\n     }\n \n     Token.Tag createTagPending(boolean start) {\n-        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n+        tagPending = start ? startPending.reset() : endPending.reset();\n         return tagPending;\n     }\n \n     }\n \n     void createCommentPending() {\n-        commentPending = new Token.Comment();\n+        commentPending.reset();\n     }\n \n     void emitCommentPending() {\n     }\n \n     void createDoctypePending() {\n-        doctypePending = new Token.Doctype();\n+        doctypePending.reset();\n     }\n \n     void emitDoctypePending() {\n     }\n \n     void createTempBuffer() {\n-        dataBuffer = new StringBuilder();\n+        Token.reset(dataBuffer);\n     }\n \n     boolean isAppropriateEndTagToken() {\n-        if (lastStartTag == null)\n-            return false;\n-        return tagPending.tagName.equals(lastStartTag.tagName);\n+        return lastStartTag != null && tagPending.tagName.equals(lastStartTag);\n     }\n \n     String appropriateEndTagName() {\n         if (lastStartTag == null)\n             return null;\n-        return lastStartTag.tagName;\n+        return lastStartTag;\n     }\n \n     void error(TokeniserState state) {\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n             } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                 // consuming to EOF; break out here\n-                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n+                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                 t.emitTagPending();\n                 r.unconsume(); // undo \"<\"\n                 t.transition(Data);\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n+\n+    private Token.StartTag start = new Token.StartTag(); // start tag to process\n+    private Token.EndTag end  = new Token.EndTag();\n \n     protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n         Validate.notNull(input, \"String input must not be null\");\n         while (true) {\n             Token token = tokeniser.read();\n             process(token);\n+            token.reset();\n \n             if (token.type == Token.TokenType.EOF)\n                 break;\n \n     protected abstract boolean process(Token token);\n \n+    protected boolean processStartTag(String name) {\n+        return process(start.reset().name(name));\n+    }\n+\n+    public boolean processStartTag(String name, Attributes attrs) {\n+        start.reset();\n+        start.nameAttr(name, attrs);\n+        return process(start);\n+    }\n+\n+    protected boolean processEndTag(String name) {\n+        return process(end.reset().name(name));\n+    }\n+\n+\n     protected Element currentElement() {\n         int size = stack.size();\n         return size > 0 ? stack.get(size-1) : null;", "timestamp": 1414470565, "metainfo": ""}