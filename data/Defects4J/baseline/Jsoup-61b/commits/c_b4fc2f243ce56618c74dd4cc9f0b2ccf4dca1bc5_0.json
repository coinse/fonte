{"sha": "b4fc2f243ce56618c74dd4cc9f0b2ccf4dca1bc5", "log": "1. add support for \"unsecure connections\"", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     }\n \n     /**\n+     * Setter to disable\\enable SSL certificates checks during https connection\n+     * @param value\n+     */\n+    Connection setSecure (boolean value);\n+\n+    /**\n      * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      * Represents a HTTP request.\n      */\n     public interface Request extends Base<Request> {\n+\n+\n         /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * get current state of security enabling\\disabling feature\n+         *\n+         * @return\n+         */\n+        boolean isSecure();\n+\n+        /**\n+         * Disable SSL certificates checks.\n+         * @param value\n+         */\n+        void setSecure(boolean value);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n+import javax.net.ssl.*;\n import java.io.*;\n import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n import java.util.*;\n import java.util.zip.GZIPInputStream;\n \n \tprivate HttpConnection() {\n         req = new Request();\n         res = new Response();\n+    }\n+\n+    public Connection setSecure(boolean value) {\n+        req.setSecure(value);\n+        return this;\n     }\n \n     public Connection url(URL url) {\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n-\n-      \tprivate Request() {\n+        private boolean secure = true;\n+\n+        private Request() {\n             timeoutMilliseconds = 3000;\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n         public Parser parser() {\n             return parser;\n         }\n+\n+        public boolean isSecure() {\n+            return secure;\n+        }\n+\n+        public void setSecure(boolean value) {\n+            secure = value;\n+        }\n     }\n \n     public static class Response extends Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private static SSLSocketFactory sslSocketFactory;\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n             HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n             conn.setReadTimeout(req.timeout());\n+            if (!req.isSecure()) {\n+                initUnSecureSSL();\n+                ( (HttpsURLConnection) conn ).setSSLSocketFactory(sslSocketFactory);\n+            }\n             if (req.method() == Method.POST)\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(header.getKey(), header.getValue());\n             }\n             return conn;\n+        }\n+\n+        private static void initUnSecureSSL() throws IOException {\n+            if ( sslSocketFactory == null) {\n+                // Create a trust manager that does not validate certificate chains\n+                final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n+\n+                    public void checkClientTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public void checkServerTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                } };\n+\n+                // Install the all-trusting trust manager\n+                final SSLContext sslContext;\n+                try {\n+                    sslContext = SSLContext.getInstance(\"SSL\");\n+                    sslContext.init( null, trustAllCerts, new java.security.SecureRandom() );\n+                    // Create an ssl socket factory with our all-trusting manager\n+                    sslSocketFactory = sslContext.getSocketFactory();\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                } catch (KeyManagementException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                }\n+            }\n+\n         }\n \n         // set up url, method, header, cookies", "timestamp": 1373014276, "metainfo": ""}