{"sha": "c850608f18d6cf71d96713abed84def85f5bb8fe", "log": "Resolved PR #470 conflicts  Cleaned up a little, added changes", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/SerializationException.java\n+package org.jsoup;\n+\n+/**\n+ * A SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an\n+ * {@link java.io.IOException} that may be thrown due to an inaccessible output stream.\n+ */\n+public final class SerializationException extends RuntimeException {\n+\t/**\n+\t * Creates and initializes a new serialization exception with no error message and cause.\n+\t */\n+\tpublic SerializationException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the given error message and no cause.\n+\t * \n+\t * @param message\n+\t *            the error message of the new serialization exception (may be <code>null</code>).\n+\t */\n+\tpublic SerializationException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the specified cause and an error message of\n+     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n+     * <code>cause</code>).\n+\t * \n+\t * @param cause\n+\t *            the cause of the new serialization exception (may be <code>null</code>).\n+\t */\n+\tpublic SerializationException(Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the given error message and cause.\n+\t * \n+\t * @param message\n+\t *            the error message of the new serialization exception.\n+\t * @param cause\n+\t *            the cause of the new serialization exception.\n+\t */\n+\tpublic SerializationException(String message, Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+}\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.Map;\n \n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum, (new Document(\"\")).outputSettings());\n+        \n+        try {\n+        \thtml(accum, (new Document(\"\")).outputSettings());\n+        } catch(IOException exception) {\n+        \tthrow new SerializationException(exception);\n+        }\n         return accum.toString();\n     }\n     \n-    protected void html(StringBuilder accum, Document.OutputSettings out) {\n+    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         accum.append(key);\n         if (!shouldCollapseAttribute(out)) {\n             accum.append(\"=\\\"\");\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n import java.util.*;\n \n /**\n     /**\n      Get the HTML representation of these attributes.\n      @return HTML\n+     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        try {\n+            html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        } catch (IOException e) { // ought never happen\n+            throw new SerializationException(e);\n+        }\n         return accum.toString();\n     }\n     \n-    void html(StringBuilder accum, Document.OutputSettings out) {\n+    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         if (attributes == null)\n             return;\n         \n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n /**\n  A comment node.\n         return attributes.get(COMMENT_KEY);\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.prettyPrint())\n             indent(accum, depth, out);\n         accum\n                 .append(\"-->\");\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n /**\n  A data node, for contents of style, script tags etc, where contents should not show in text().\n         return this;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum.append(getWholeData()); // data is not escaped in return from data nodes, so \" in script, style is plain\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document.OutputSettings.*;\n     }\n \n     @Override\n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n             // looks like a html5 doctype, go lowercase for aesthetics\n             accum.append(\"<!doctype\");\n     }\n \n     @Override\n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n     }\n \n     private boolean has(final String attribute) {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.*;\n-\n-import java.util.*;\n+import org.jsoup.select.Collector;\n+import org.jsoup.select.Elements;\n+import org.jsoup.select.Evaluator;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+import org.jsoup.select.Selector;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n \n         return this;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n-            indent(accum, depth, out);\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n+            if (accum instanceof StringBuilder) {\n+                if (((StringBuilder) accum).length() > 0)\n+                    indent(accum, depth, out);\n+            } else {\n+                indent(accum, depth, out);\n+            }\n+        }\n         accum\n                 .append(\"<\")\n                 .append(tagName());\n             accum.append(\">\");\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n             if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                     tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T extends Appendable> T html(T appendable) {\n+        for (Node node : childNodes)\n+            node.outerHtml(appendable);\n+\n+        return appendable;\n+    }\n     \n     /**\n      * Set this element's inner HTML. Clears the existing HTML first.\n         return this;\n     }\n \n-    public String toString() {\n+\tpublic String toString() {\n         return outerHtml();\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.parser.Parser;\n \n     \n     static String escape(String string, Document.OutputSettings out) {\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n-        escape(accum, string, out, false, false, false);\n+        try {\n+            escape(accum, string, out, false, false, false);\n+        } catch (IOException e) {\n+            throw new SerializationException(e); // doesn't happen\n+        }\n         return accum.toString();\n     }\n \n     // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n-    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n-                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n+    static void escape(Appendable accum, String string, Document.OutputSettings out,\n+                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n \n         boolean lastWasWhite = false;\n         boolean reachedNonWhite = false;\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.net.MalformedURLException;\n-import java.net.URL;\n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.LinkedList;\n         return accum.toString();\n     }\n \n-    protected void outerHtml(StringBuilder accum) {\n+    protected void outerHtml(Appendable accum) {\n         new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n     }\n \n     /**\n      Get the outer HTML of this node.\n      @param accum accumulator to place HTML into\n-     */\n-    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n-\n-    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n-\n-    @Override\n-    public String toString() {\n+     @throws IOException if appending to the given accumulator fails.\n+     */\n+    abstract void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n+\n+    abstract void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n+\n+    /**\n+     * Write this node and its children to the given {@link Appendable}.\n+     *\n+     * @param appendable the {@link Appendable} to write to.\n+     * @return the supplied {@link Appendable}, for chaining.\n+     */\n+    public <T extends Appendable> T html(T appendable) {\n+        outerHtml(appendable);\n+        return appendable;\n+    }\n+    \n+\tpublic String toString() {\n         return outerHtml();\n     }\n \n-    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n     }\n \n     }\n \n     private static class OuterHtmlVisitor implements NodeVisitor {\n-        private StringBuilder accum;\n+        private Appendable accum;\n         private Document.OutputSettings out;\n \n-        OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n+        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n             this.accum = accum;\n             this.out = out;\n         }\n \n         public void head(Node node, int depth) {\n-            node.outerHtmlHead(accum, depth, out);\n+            try {\n+\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n+\t\t\t} catch (IOException exception) {\n+\t\t\t\tthrow new SerializationException(exception);\n+\t\t\t}\n         }\n \n         public void tail(Node node, int depth) {\n-            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n-                node.outerHtmlTail(accum, depth, out);\n+            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n+\t\t\t\ttry {\n+\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n+\t\t\t\t} catch (IOException exception) {\n+\t\t\t\t\tthrow new SerializationException(exception);\n+\t\t\t\t}\n+            }\n         }\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n         this.text = text;\n     }\n \n-    public String nodeName() {\n+\tpublic String nodeName() {\n         return \"#text\";\n     }\n     \n         return tailNode;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n             indent(accum, depth, out);\n \n         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n /**\n  An XML Declaration.\n             return attributes.get(DECL_KEY);\n         }\n     }\n-    \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum\n                 .append(\"<\")\n                 .append(isProcessingInstruction ? \"!\" : \"?\")\n                 .append(\">\");\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n package org.jsoup.nodes;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.TextUtil;\n+import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Document.OutputSettings;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+import org.junit.Ignore;\n+import org.junit.Test;\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.StringWriter;\n import java.nio.charset.Charset;\n-import org.jsoup.Jsoup;\n-import org.jsoup.TextUtil;\n-import org.jsoup.integration.ParseTest;\n-import org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.*;\n-import org.junit.Ignore;\n-import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests for Document.\n         Document doc = Jsoup.parse(\"x\");\n         assertEquals(Syntax.html, doc.outputSettings().syntax());\n     }\n+    \n+    @Test public void testHtmlAppendable() {\n+    \tString htmlContent = \"<html><head><title>Hello</title></head><body><p>One</p><p>Two</p></body></html>\";\n+    \tDocument document = Jsoup.parse(htmlContent);\n+    \tOutputSettings outputSettings = new OutputSettings();\n+    \t\n+    \toutputSettings.prettyPrint(false);\n+    \tdocument.outputSettings(outputSettings);\n+    \tassertEquals(htmlContent, document.html(new StringWriter()).toString());\n+    }\n \n     // Ignored since this test can take awhile to run.\n     @Ignore\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import static org.jsoup.nodes.Document.OutputSettings;\n import static org.jsoup.nodes.Entities.EscapeMode.*;\n import static org.junit.Assert.*;\n-\n \n public class EntitiesTest {\n     @Test public void escape() {\n         assertEquals(text, Entities.unescape(escapedUtfMin));\n     }\n \n-    @Test public void escapeSupplementaryCharacter(){\n+    @Test public void escapeSupplementaryCharacter() {\n         String text = new String(Character.toChars(135361));\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         assertEquals(\"&#x210c1;\", escapedAscii);\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n package org.jsoup;\n \n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.HtmlTreeBuilder;\n import org.jsoup.parser.Parser;\n \n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Proxy;\n import java.net.URL;\n+import java.util.Collection;\n import java.util.Map;\n-import java.util.Collection;\n-import java.io.IOException;\n \n /**\n  * A Connection provides a convenient interface to fetch content from the web, and parse them into Documents.\n  * <p>\n  * To get a new Connection, use {@link org.jsoup.Jsoup#connect(String)}. Connections contain {@link Connection.Request}\n  * and {@link Connection.Response} objects. The request objects are reusable as prototype requests.\n+ * </p>\n  * <p>\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n- * or by methods in the Connection.Request object directly. All request configuration must be made before the request\n- * is executed.\n+ * or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n+ * executed.\n+ * </p>\n  */\n public interface Connection {\n \n     /**\n      * GET and POST http methods.\n      */\n-    public enum Method {\n-        GET, POST\n+    enum Method {\n+        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);\n+\n+        private final boolean hasBody;\n+\n+        Method(boolean hasBody) {\n+            this.hasBody = hasBody;\n+        }\n+\n+        /**\n+         * Check if this HTTP method has/needs a request body\n+         * @return if body needed\n+         */\n+        public final boolean hasBody() {\n+            return hasBody;\n+        }\n     }\n \n     /**\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      */\n-    public Connection url(URL url);\n+    Connection url(URL url);\n \n     /**\n      * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      */\n-    public Connection url(String url);\n+    Connection url(String url);\n+\n+    /**\n+     * Set the proxy to use for this request. Set to <code>null</code> to disable.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(Proxy proxy);\n+\n+    /**\n+     * Set the HTTP proxy to use for this request.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(String host, int port);\n \n     /**\n      * Set the request user-agent header.\n      * @param userAgent user-agent to use\n      * @return this Connection, for chaining\n      */\n-    public Connection userAgent(String userAgent);\n+    Connection userAgent(String userAgent);\n \n     /**\n      * Set the request timeouts (connect and read). If a timeout occurs, an IOException will be thrown. The default\n      * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n      * @return this Connection, for chaining\n      */\n-    public Connection timeout(int millis);\n+    Connection timeout(int millis);\n \n     /**\n      * Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\n      * @param bytes number of bytes to read from the input before truncating\n      * @return this Connection, for chaining\n      */\n-    public Connection maxBodySize(int bytes);\n+    Connection maxBodySize(int bytes);\n \n     /**\n      * Set the request referrer (aka \"referer\") header.\n      * @param referrer referrer to use\n      * @return this Connection, for chaining\n      */\n-    public Connection referrer(String referrer);\n+    Connection referrer(String referrer);\n \n     /**\n      * Configures the connection to (not) follow server redirects. By default this is <b>true</b>.\n      * @param followRedirects true if server redirects should be followed.\n      * @return this Connection, for chaining\n      */\n-    public Connection followRedirects(boolean followRedirects);\n+    Connection followRedirects(boolean followRedirects);\n \n     /**\n      * Set the request method to use, GET or POST. Default is GET.\n      * @param method HTTP request method\n      * @return this Connection, for chaining\n      */\n-    public Connection method(Method method);\n+    Connection method(Method method);\n \n     /**\n      * Configures the connection to not throw exceptions when a HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By\n      * @param ignoreHttpErrors - false (default) if HTTP errors should be ignored.\n      * @return this Connection, for chaining\n      */\n-    public Connection ignoreHttpErrors(boolean ignoreHttpErrors);\n+    Connection ignoreHttpErrors(boolean ignoreHttpErrors);\n \n     /**\n      * Ignore the document's Content-Type when parsing the response. By default this is <b>false</b>, an unrecognised\n      * Document.\n      * @return this Connection, for chaining\n      */\n-    public Connection ignoreContentType(boolean ignoreContentType);\n-\n-    /**\n-     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the request\n-     * body for POSTs. A request may have multiple values of the same name.\n+    Connection ignoreContentType(boolean ignoreContentType);\n+\n+    /**\n+     * Disable/enable TSL certificates validation for HTTPS requests.\n+     * <p>\n+     * By default this is <b>true</b>; all\n+     * connections over HTTPS perform normal validation of certificates, and will abort requests if the provided\n+     * certificate does not validate.\n+     * </p>\n+     * <p>\n+     * Some servers use expired, self-generated certificates; or your JDK may not\n+     * support SNI hosts. In which case, you may want to enable this setting.\n+     * </p>\n+     * <p>\n+     * <b>Be careful</b> and understand why you need to disable these validations.\n+     * </p>\n+     * @param value if should validate TSL (SSL) certificates. <b>true</b> by default.\n+     * @return this Connection, for chaining\n+     */\n+    Connection validateTLSCertificates(boolean value);\n+\n+    /**\n+     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n+     * request body for POSTs. A request may have multiple values of the same name.\n      * @param key data key\n      * @param value data value\n      * @return this Connection, for chaining\n      */\n-    public Connection data(String key, String value);\n+    Connection data(String key, String value);\n+\n+    /**\n+     * Add an input stream as a request data paramater. For GETs, has no effect, but for POSTS this will upload the\n+     * input stream.\n+     * @param key data key (form item name)\n+     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n+     * component.\n+     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n+     * You must close the InputStream in a {@code finally} block.\n+     * @return this Connections, for chaining\n+     */\n+    Connection data(String key, String filename, InputStream inputStream);\n \n     /**\n      * Adds all of the supplied data to the request data parameters\n      * @param data collection of data parameters\n      * @return this Connection, for chaining\n      */\n-    public Connection data(Collection<KeyVal> data);\n+    Connection data(Collection<KeyVal> data);\n \n     /**\n      * Adds all of the supplied data to the request data parameters\n      * @param data map of data parameters\n      * @return this Connection, for chaining\n      */\n-    public Connection data(Map<String, String> data);\n-\n-    /**\n-     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.:\n-     * <code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n-     * <code>?name=jsoup&language=Java&language=English</code>\n+    Connection data(Map<String, String> data);\n+\n+    /**\n+     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n+     * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n+     * <code>{@literal ?name=jsoup&language=Java&language=English}</code>\n      * @param keyvals a set of key value pairs.\n      * @return this Connection, for chaining\n      */\n-    public Connection data(String... keyvals);\n+    Connection data(String... keyvals);\n \n     /**\n      * Set a request header.\n      * @return this Connection, for chaining\n      * @see org.jsoup.Connection.Request#headers()\n      */\n-    public Connection header(String name, String value);\n+    Connection header(String name, String value);\n \n     /**\n      * Set a cookie to be sent in the request.\n      * @param value value of cookie\n      * @return this Connection, for chaining\n      */\n-    public Connection cookie(String name, String value);\n+    Connection cookie(String name, String value);\n \n     /**\n      * Adds each of the supplied cookies to the request.\n-     * @param cookies map of cookie name -> value pairs\n-     * @return this Connection, for chaining\n-     */\n-    public Connection cookies(Map<String, String> cookies);\n-\n-    /**\n-     * Provide an alternate parser to use when parsing the response to a Document.\n+     * @param cookies map of cookie name {@literal ->} value pairs\n+     * @return this Connection, for chaining\n+     */\n+    Connection cookies(Map<String, String> cookies);\n+\n+    /**\n+     * Provide an alternate parser to use when parsing the response to a Document. If not set, defaults to the HTML\n+     * parser, unless the response content-type is XML, in which case the XML parser is used.\n      * @param parser alternate parser\n      * @return this Connection, for chaining\n      */\n-    public Connection parser(Parser parser);\n+    Connection parser(Parser parser);\n+\n+    /**\n+     * Sets the default post data character set for x-www-form-urlencoded post data\n+     * @param charset character set to encode post data\n+     * @return this Connection, for chaining\n+     */\n+    Connection postDataCharset(String charset);\n \n     /**\n      * Execute the request as a GET, and parse the result.\n      * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n-    public Document get() throws IOException;\n+    Document get() throws IOException;\n \n     /**\n      * Execute the request as a POST, and parse the result.\n      * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n-    public Document post() throws IOException;\n+    Document post() throws IOException;\n \n     /**\n      * Execute the request.\n      * @throws java.net.SocketTimeoutException if the connection times out\n      * @throws IOException on error\n      */\n-    public Response execute() throws IOException;\n+    Response execute() throws IOException;\n \n     /**\n      * Get the request object associated with this connection\n      * @return request\n      */\n-    public Request request();\n+    Request request();\n \n     /**\n      * Set the connection's request\n      * @param request new request object\n      * @return this Connection, for chaining\n      */\n-    public Connection request(Request request);\n+    Connection request(Request request);\n \n     /**\n      * Get the response, once the request has been executed\n      * @return response\n      */\n-    public Response response();\n+    Response response();\n \n     /**\n      * Set the connection's response\n      * @param response new response\n      * @return this Connection, for chaining\n      */\n-    public Connection response(Response response);\n-\n+    Connection response(Response response);\n \n     /**\n      * Common methods for Requests and Responses\n          * Get the URL\n          * @return URL\n          */\n-        public URL url();\n+        URL url();\n \n         /**\n          * Set the URL\n          * @param url new URL\n          * @return this, for chaining\n          */\n-        public T url(URL url);\n+        T url(URL url);\n \n         /**\n          * Get the request method\n          * @return method\n          */\n-        public Method method();\n+        Method method();\n \n         /**\n          * Set the request method\n          * @param method new method\n          * @return this, for chaining\n          */\n-        public T method(Method method);\n+        T method(Method method);\n \n         /**\n          * Get the value of a header. This is a simplified header model, where a header may only have one value.\n          * <p>\n          * Header names are case insensitive.\n+         * </p>\n          * @param name name of header (case insensitive)\n          * @return value of header, or null if not set.\n          * @see #hasHeader(String)\n          * @see #cookie(String)\n          */\n-        public String header(String name);\n-\n-        /**\n-         * Set a header. This method will overwrite any existing header with the same case insensitive name. \n+        String header(String name);\n+\n+        /**\n+         * Set a header. This method will overwrite any existing header with the same case insensitive name.\n          * @param name Name of header\n          * @param value Value of header\n          * @return this, for chaining\n          */\n-        public T header(String name, String value);\n+        T header(String name, String value);\n \n         /**\n          * Check if a header is present\n          * @param name name of header (case insensitive)\n          * @return if the header is present in this request/response\n          */\n-        public boolean hasHeader(String name);\n+        boolean hasHeader(String name);\n+\n+        /**\n+         * Check if a header is present, with the given value\n+         * @param name header name (case insensitive)\n+         * @param value value (case insensitive)\n+         * @return if the header and value pair are set in this req/res\n+         */\n+        boolean hasHeaderWithValue(String name, String value);\n \n         /**\n          * Remove a header by name\n          * @param name name of header to remove (case insensitive)\n          * @return this, for chaining\n          */\n-        public T removeHeader(String name);\n+        T removeHeader(String name);\n \n         /**\n          * Retrieve all of the request/response headers as a map\n          * @return headers\n          */\n-        public Map<String, String> headers();\n+        Map<String, String> headers();\n \n         /**\n          * Get a cookie value by name from this request/response.\n          * <p>\n          * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n          * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n+         * </p>\n          * @param name name of cookie to retrieve.\n          * @return value of cookie, or null if not set\n          */\n-        public String cookie(String name);\n+        String cookie(String name);\n \n         /**\n          * Set a cookie in this request/response.\n          * @param value value of cookie\n          * @return this, for chaining\n          */\n-        public T cookie(String name, String value);\n+        T cookie(String name, String value);\n \n         /**\n          * Check if a cookie is present\n          * @param name name of cookie\n          * @return if the cookie is present in this request/response\n          */\n-        public boolean hasCookie(String name);\n+        boolean hasCookie(String name);\n \n         /**\n          * Remove a cookie by name\n          * @param name name of cookie to remove\n          * @return this, for chaining\n          */\n-        public T removeCookie(String name);\n+        T removeCookie(String name);\n \n         /**\n          * Retrieve all of the request/response cookies as a map\n          * @return cookies\n          */\n-        public Map<String, String> cookies();\n-\n+        Map<String, String> cookies();\n     }\n \n     /**\n      * Represents a HTTP request.\n      */\n-    public interface Request extends Base<Request> {\n+    interface Request extends Base<Request> {\n+        /**\n+         * Get the proxy used for this request.\n+         * @return the proxy; <code>null</code> if not enabled.\n+         */\n+        Proxy proxy();\n+\n+        /**\n+         * Update the proxy for this request.\n+         * @param proxy the proxy ot use; <code>null</code> to disable.\n+         * @return this Request, for chaining\n+         */\n+        Request proxy(Proxy proxy);\n+\n+        /**\n+         * Set the HTTP proxy to use for this request.\n+         * @param proxy proxy to use\n+         * @return this Connection, for chaining\n+         */\n+        Request proxy(String host, int port);\n+\n         /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          */\n-        public int timeout();\n+        int timeout();\n \n         /**\n          * Update the request timeout.\n          * @param millis timeout, in milliseconds\n          * @return this Request, for chaining\n          */\n-        public Request timeout(int millis);\n+        Request timeout(int millis);\n \n         /**\n          * Get the maximum body size, in bytes.\n          * @return the maximum body size, in bytes.\n          */\n-        public int maxBodySize();\n+        int maxBodySize();\n \n         /**\n          * Update the maximum body size, in bytes.\n          * @param bytes maximum body size, in bytes.\n          * @return this Request, for chaining\n          */\n-        public Request maxBodySize(int bytes);\n+        Request maxBodySize(int bytes);\n \n         /**\n          * Get the current followRedirects configuration.\n          * @return true if followRedirects is enabled.\n          */\n-        public boolean followRedirects();\n+        boolean followRedirects();\n \n         /**\n          * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n-         *\n          * @param followRedirects true if server redirects should be followed.\n          * @return this Request, for chaining\n          */\n-        public Request followRedirects(boolean followRedirects);\n+        Request followRedirects(boolean followRedirects);\n \n         /**\n          * Get the current ignoreHttpErrors configuration.\n-         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be thrown.\n-         */\n-        public boolean ignoreHttpErrors();\n-\n-    \t/**\n-    \t * Configures the request to ignore HTTP errors in the response.\n-    \t * @param ignoreHttpErrors set to true to ignore HTTP errors.\n-         * @return this Request, for chaining\n-    \t */\n-        public Request ignoreHttpErrors(boolean ignoreHttpErrors);\n+         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be\n+         * thrown.\n+         */\n+        boolean ignoreHttpErrors();\n+\n+        /**\n+         * Configures the request to ignore HTTP errors in the response.\n+         * @param ignoreHttpErrors set to true to ignore HTTP errors.\n+         * @return this Request, for chaining\n+         */\n+        Request ignoreHttpErrors(boolean ignoreHttpErrors);\n \n         /**\n          * Get the current ignoreContentType configuration.\n-         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to be thrown.\n-         */\n-        public boolean ignoreContentType();\n-\n-        /**\n-    \t * Configures the request to ignore the Content-Type of the response.\n-    \t * @param ignoreContentType set to true to ignore the content type.\n-         * @return this Request, for chaining\n-    \t */\n-        public Request ignoreContentType(boolean ignoreContentType);\n+         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to\n+         * be thrown.\n+         */\n+        boolean ignoreContentType();\n+\n+        /**\n+         * Configures the request to ignore the Content-Type of the response.\n+         * @param ignoreContentType set to true to ignore the content type.\n+         * @return this Request, for chaining\n+         */\n+        Request ignoreContentType(boolean ignoreContentType);\n+\n+        /**\n+         * Get the current state of TLS (SSL) certificate validation.\n+         * @return true if TLS cert validation enabled\n+         */\n+        boolean validateTLSCertificates();\n+\n+        /**\n+         * Set TLS certificate validation.\n+         * @param value set false to ignore TLS (SSL) certificates\n+         */\n+        void validateTLSCertificates(boolean value);\n \n         /**\n          * Add a data parameter to the request\n          * @param keyval data to add.\n          * @return this Request, for chaining\n          */\n-        public Request data(KeyVal keyval);\n+        Request data(KeyVal keyval);\n \n         /**\n          * Get all of the request's data parameters\n          * @return collection of keyvals\n          */\n-        public Collection<KeyVal> data();\n+        Collection<KeyVal> data();\n \n         /**\n          * Specify the parser to use when parsing the document.\n          * @param parser parser to use.\n          * @return this Request, for chaining\n          */\n-        public Request parser(Parser parser);\n+        Request parser(Parser parser);\n \n         /**\n          * Get the current parser to use when parsing the document.\n          * @return current Parser\n          */\n-        public Parser parser();\n+        Parser parser();\n+\n+        /**\n+         * Sets the post data character set for x-www-form-urlencoded post data\n+         * @param charset character set to encode post data\n+         * @return this Request, for chaining\n+         */\n+        Request postDataCharset(String charset);\n+\n+        /**\n+         * Gets the post data character set for x-www-form-urlencoded post data\n+         * @return character set to encode post data\n+         */\n+        String postDataCharset();\n+\n     }\n \n     /**\n      * Represents a HTTP response.\n      */\n-    public interface Response extends Base<Response> {\n-    \t\n-    \t/**\n+    interface Response extends Base<Response> {\n+\n+        /**\n          * Get the status code of the response.\n          * @return status code\n          */\n-        public int statusCode();\n+        int statusCode();\n \n         /**\n          * Get the status message of the response.\n          * @return status message\n          */\n-        public String statusMessage();\n+        String statusMessage();\n \n         /**\n          * Get the character set name of the response.\n          * @return character set name\n          */\n-        public String charset();\n+        String charset();\n \n         /**\n          * Get the response content type (e.g. \"text/html\");\n          * @return the response content type\n          */\n-        public String contentType();\n+        String contentType();\n \n         /**\n          * Parse the body of the response as a Document.\n          * @return a parsed Document\n          * @throws IOException on error\n          */\n-        public Document parse() throws IOException;\n+        Document parse() throws IOException;\n \n         /**\n          * Get the body of the response as a plain string.\n          * @return body\n          */\n-        public String body();\n+        String body();\n \n         /**\n          * Get the body of the response as an array of bytes.\n          * @return body bytes\n          */\n-        public byte[] bodyAsBytes();\n+        byte[] bodyAsBytes();\n     }\n \n     /**\n      * A Key Value tuple.\n      */\n-    public interface KeyVal {\n+    interface KeyVal {\n \n         /**\n          * Update the key of a keyval\n          * @param key new key\n          * @return this KeyVal, for chaining\n          */\n-        public KeyVal key(String key);\n+        KeyVal key(String key);\n \n         /**\n          * Get the key of a keyval\n          * @return the key\n          */\n-        public String key();\n+        String key();\n \n         /**\n          * Update the value of a keyval\n          * @param value the new value\n          * @return this KeyVal, for chaining\n          */\n-        public KeyVal value(String value);\n+        KeyVal value(String value);\n \n         /**\n          * Get the value of a keyval\n          * @return the value\n          */\n-        public String value();\n+        String value();\n+\n+        /**\n+         * Add or update an input stream to this keyVal\n+         * @param inputStream new input stream\n+         * @return this KeyVal, for chaining\n+         */\n+        KeyVal inputStream(InputStream inputStream);\n+\n+        /**\n+         * Get the input stream associated with this keyval, if any\n+         * @return input stream if set, or null\n+         */\n+        InputStream inputStream();\n+\n+        /**\n+         * Does this keyval have an input stream?\n+         * @return true if this keyval does indeed have an input stream\n+         */\n+        boolean hasInputStream();\n     }\n }\n-\n--- a/src/main/java/org/jsoup/SerializationException.java\n+++ b/src/main/java/org/jsoup/SerializationException.java\n package org.jsoup;\n \n /**\n- * SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an {@link java.io.IOException} that may be thrown due to an inaccessible\n- * output stream.\n- *\n- * @author Michael Schmid\n+ * A SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an\n+ * {@link java.io.IOException} that may be thrown due to an inaccessible output stream.\n  */\n public final class SerializationException extends RuntimeException {\n-\n-\tprivate static final long serialVersionUID = -6182985863817230363L;\n-\n \t/**\n \t * Creates and initializes a new serialization exception with no error message and cause.\n \t */\n \t}\n \n \t/**\n-\t * Creates and initializes a new serialization exception with the specified cause and an error message of <code>(cause==null ? null : cause.toString())</code> (which typically\n-\t * contains the class and error message of <code>cause</code>).\n+\t * Creates and initializes a new serialization exception with the specified cause and an error message of\n+     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n+     * <code>cause</code>).\n \t * \n \t * @param cause\n \t *            the cause of the new serialization exception (may be <code>null</code>).\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n+import org.jsoup.select.Elements;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n  * HTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted\n  * plain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a\n  * scrape.\n- * <p/>\n+ * <p>\n  * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n- *\n+ * </p>\n+ * <p>\n+ * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:</p>\n+ * <p><code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code></p>\n+ * where <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class HtmlToPlainText {\n+    private static final String userAgent = \"Mozilla/5.0 (jsoup)\";\n+    private static final int timeout = 5 * 1000;\n+\n     public static void main(String... args) throws IOException {\n-        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n-        String url = args[0];\n+        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n+        final String url = args[0];\n+        final String selector = args.length == 2 ? args[1] : null;\n \n         // fetch the specified URL and parse to a HTML DOM\n-        Document doc = Jsoup.connect(url).get();\n+        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n \n         HtmlToPlainText formatter = new HtmlToPlainText();\n-        String plainText = formatter.getPlainText(doc);\n-        System.out.println(plainText);\n+\n+        if (selector != null) {\n+            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n+            for (Element element : elements) {\n+                String plainText = formatter.getPlainText(element); // format that element to plain text\n+                System.out.println(plainText);\n+            }\n+        } else { // format the whole doc\n+            String plainText = formatter.getPlainText(doc);\n+            System.out.println(plainText);\n+        }\n     }\n \n     /**\n                 append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n             else if (name.equals(\"li\"))\n                 append(\"\\n * \");\n+            else if (name.equals(\"dt\"))\n+                append(\"  \");\n+            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n+                append(\"\\n\");\n         }\n \n         // hit when all of the node's children (if any) have been visited\n         public void tail(Node node, int depth) {\n             String name = node.nodeName();\n-            if (name.equals(\"br\"))\n+            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                 append(\"\\n\");\n-            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n-                append(\"\\n\\n\");\n             else if (name.equals(\"a\"))\n                 append(String.format(\" <%s>\", node.absUrl(\"href\")));\n         }\n             }\n         }\n \n+        @Override\n         public String toString() {\n             return accum.toString();\n         }\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Locale;\n+import java.util.Random;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import java.util.Locale;\n \n /**\n  * Internal static utilities for handling data.\n  *\n  */\n-public class DataUtil {\n+public final class DataUtil {\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n+    private static final int UNICODE_BOM = 0xFEFF;\n+    private static final char[] mimeBoundaryChars =\n+            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n+    static final int boundaryLength = 32;\n \n     private DataUtil() {}\n \n         return parseByteData(byteData, charsetName, baseUri, parser);\n     }\n \n+    /**\n+     * Writes the input stream to the output stream. Doesn't close them.\n+     * @param in input stream to read from\n+     * @param out output stream to write to\n+     * @throws IOException on IO error\n+     */\n+    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n+        final byte[] buffer = new byte[bufferSize];\n+        int len;\n+        while ((len = in.read(buffer)) != -1) {\n+            out.write(buffer, 0, len);\n+        }\n+    }\n+\n     // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n     // switching the chartset midstream when a meta http-equiv tag defines the charset.\n     // todo - this is getting gnarly. needs a rewrite.\n     static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n         String docData;\n         Document doc = null;\n+\n+        // look for BOM - overrides any other header or input\n+        byteData.mark();\n+        byte[] bom = new byte[4];\n+        byteData.get(bom);\n+        byteData.rewind();\n+        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n+            charsetName = \"UTF-32\"; // and I hope it's on your system\n+        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n+            charsetName = \"UTF-16\"; // in all Javas\n+        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n+            charsetName = \"UTF-8\"; // in all Javas\n+            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed\n+        }\n+\n         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             if (meta != null) { // if not found, will keep utf-8 as best attempt\n-                String foundCharset;\n+                String foundCharset = null;\n                 if (meta.hasAttr(\"http-equiv\")) {\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                        try {\n-                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                                foundCharset = meta.attr(\"charset\");\n-                            }\n-                        } catch (IllegalCharsetNameException e) {\n-                            foundCharset = null;\n+                }\n+                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n+                    try {\n+                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                            foundCharset = meta.attr(\"charset\");\n                         }\n+                    } catch (IllegalCharsetNameException e) {\n+                        foundCharset = null;\n                     }\n-                } else {\n-                    foundCharset = meta.attr(\"charset\");\n                 }\n \n                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n         } else { // specified by content type header (or by user on file load)\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n-        }\n-        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n-        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n-            byteData.rewind();\n-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            docData = docData.substring(1);\n-            charsetName = defaultCharset;\n-            doc = null;\n         }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);\n             }\n             outStream.write(buffer, 0, read);\n         }\n-        ByteBuffer byteData = ByteBuffer.wrap(outStream.toByteArray());\n-        return byteData;\n+        return ByteBuffer.wrap(outStream.toByteArray());\n     }\n \n     static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n             if (randomAccessFile != null)\n                 randomAccessFile.close();\n         }\n+    }\n+\n+    static ByteBuffer emptyByteBuffer() {\n+        return ByteBuffer.allocate(0);\n     }\n \n     /**\n         }\n         return null;\n     }\n-    \n-    \n+\n+    /**\n+     * Creates a random string, suitable for use as a mime boundary\n+     */\n+    static String mimeBoundary() {\n+        final StringBuilder mime = new StringBuilder(boundaryLength);\n+        final Random rand = new Random();\n+        for (int i = 0; i < boundaryLength; i++) {\n+            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n+        }\n+        return mime.toString();\n+    }\n }\n--- a/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n+++ b/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n \n /**\n  * Provides a descending iterator and other 1.6 methods to allow support on the 1.5 JRE.\n+ * @param <E> Type of elements\n  */\n public class DescendableLinkedList<E> extends LinkedList<E> {\n \n      * Add a new element to the start of the list.\n      * @param e element to add\n      */\n+    @Override\n     public void push(E e) {\n         addFirst(e);\n     }\n      * Look at the last element, if there is one.\n      * @return the last element, or null\n      */\n+    @Override\n     public E peekLast() {\n         return size() == 0 ? null : getLast();\n     }\n      * Remove and return the last element, if there is one\n      * @return the last element, or null\n      */\n+    @Override\n     public E pollLast() {\n         return size() == 0 ? null : removeLast();\n     }\n      * Get an iterator that starts and the end of the list and works towards the start.\n      * @return an iterator that starts and the end of the list and works towards the start.\n      */\n+    @Override\n     public Iterator<E> descendingIterator() {\n         return new DescendingIterator<E>(size());\n     }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n package org.jsoup.helper;\n \n-import org.jsoup.Connection;\n-import org.jsoup.HttpStatusException;\n-import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.*;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n+import javax.net.ssl.*;\n import java.io.*;\n-import java.net.HttpURLConnection;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n+import java.net.*;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n import java.util.*;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n  * @see org.jsoup.Jsoup#connect(String)\n  */\n public class HttpConnection implements Connection {\n+    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n+    private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n     private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n \n     public static Connection connect(String url) {\n \t\t\treturn null;\n     \treturn url.replaceAll(\" \", \"%20\");\n \t}\n+\n+    private static String encodeMimeName(String val) {\n+        if (val == null)\n+            return null;\n+        return val.replaceAll(\"\\\"\", \"%22\");\n+    }\n \n     private Connection.Request req;\n     private Connection.Response res;\n         return this;\n     }\n \n+    public Connection proxy(Proxy proxy) {\n+        req.proxy(proxy);\n+        return this;\n+    }\n+\n+    public Connection proxy(String host, int port) {\n+        req.proxy(host, port);\n+        return this;\n+    }\n+\n     public Connection userAgent(String userAgent) {\n         Validate.notNull(userAgent, \"User agent must not be null\");\n         req.header(\"User-Agent\", userAgent);\n         return this;\n     }\n \n+    public Connection validateTLSCertificates(boolean value) {\n+        req.validateTLSCertificates(value);\n+        return this;\n+    }\n+\n     public Connection data(String key, String value) {\n         req.data(KeyVal.create(key, value));\n+        return this;\n+    }\n+\n+    public Connection data(String key, String filename, InputStream inputStream) {\n+        req.data(KeyVal.create(key, filename, inputStream));\n         return this;\n     }\n \n         return this;\n     }\n \n+    public Connection postDataCharset(String charset) {\n+        req.postDataCharset(charset);\n+        return this;\n+    }\n+\n     @SuppressWarnings({\"unchecked\"})\n     private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> {\n         URL url;\n         public boolean hasHeader(String name) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n             return getHeaderCaseInsensitive(name) != null;\n+        }\n+\n+        /**\n+         * Test if the request has a header with this value (case insensitive).\n+         */\n+        public boolean hasHeaderWithValue(String name, String value) {\n+            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n         }\n \n         public T removeHeader(String name) {\n         }\n     }\n \n-    public static class Request extends Base<Connection.Request> implements Connection.Request {\n+    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n+        private Proxy proxy; // nullable\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n-\n-      \tprivate Request() {\n+        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n+        private boolean validateTSLCertificates = true;\n+        private String postDataCharset = DataUtil.defaultCharset;\n+\n+        private Request() {\n             timeoutMilliseconds = 3000;\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n             data = new ArrayList<Connection.KeyVal>();\n-            method = Connection.Method.GET;\n+            method = Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n             parser = Parser.htmlParser();\n+        }\n+\n+        public Proxy proxy() {\n+            return proxy;\n+        }\n+\n+        public Request proxy(Proxy proxy) {\n+            this.proxy = proxy;\n+            return this;\n+        }\n+\n+        public Request proxy(String host, int port) {\n+            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n+            return this;\n         }\n \n         public int timeout() {\n             return ignoreHttpErrors;\n         }\n \n+        public boolean validateTLSCertificates() {\n+            return validateTSLCertificates;\n+        }\n+\n+        public void validateTLSCertificates(boolean value) {\n+            validateTSLCertificates = value;\n+        }\n+\n         public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n             this.ignoreHttpErrors = ignoreHttpErrors;\n             return this;\n \n         public Request parser(Parser parser) {\n             this.parser = parser;\n+            parserDefined = true;\n             return this;\n         }\n \n         public Parser parser() {\n             return parser;\n         }\n-    }\n-\n-    public static class Response extends Base<Connection.Response> implements Connection.Response {\n+\n+        public Connection.Request postDataCharset(String charset) {\n+            Validate.notNull(charset, \"Charset must not be null\");\n+            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n+            this.postDataCharset = charset;\n+            return this;\n+        }\n+\n+        public String postDataCharset() {\n+            return postDataCharset;\n+        }\n+    }\n+\n+    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private static SSLSocketFactory sslSocketFactory;\n+        private static final String LOCATION = \"Location\";\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n         private Connection.Request req;\n \n         /*\n-         * For example {@code application/atom+xml;charset=utf-8}.\n-         * Stepping through it: start with {@code \"application/\"}, follow with word\n-         * characters up to a {@code \"+xml\"}, and then maybe more ({@code .*}).\n+         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)\n          */\n-        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"application/\\\\w+\\\\+xml.*\");\n+        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\");\n \n         Response() {\n             super();\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n \n             // set up the request for execution\n-            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n+            String mimeBoundary = null;\n+            if (!req.method().hasBody() && req.data().size() > 0) {\n                 serialiseRequestUrl(req); // appends query string\n+            } else if (req.method().hasBody()) {\n+                mimeBoundary = setOutputContentType(req);\n+            }\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                 conn.connect();\n-                if (req.method() == Connection.Method.POST)\n-                    writePost(req.data(), conn.getOutputStream());\n+                if (conn.getDoOutput())\n+                    writePost(req, conn.getOutputStream(), mimeBoundary);\n \n                 int status = conn.getResponseCode();\n-                boolean needsRedirect = false;\n-                if (status != HttpURLConnection.HTTP_OK) {\n-                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER || status == HTTP_TEMP_REDIR)\n-                        needsRedirect = true;\n-                    else if (!req.ignoreHttpErrors())\n-                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n-                }\n                 res = new Response(previousResponse);\n                 res.setupFromConnection(conn, previousResponse);\n-                if (needsRedirect && req.followRedirects()) {\n-                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n-                    req.data().clear();\n-\n-                    String location = res.header(\"Location\");\n+                res.req = req;\n+\n+                // redirect if there's a location header (from 3xx, or 201 etc)\n+                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n+                    if (status != HTTP_TEMP_REDIR) {\n+                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n+                        req.data().clear();\n+                    }\n+\n+                    String location = res.header(LOCATION);\n                     if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                         location = location.substring(6);\n-                    req.url(new URL(req.url(), encodeUrl(location)));\n+                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n \n                     for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                         req.cookie(cookie.getKey(), cookie.getValue());\n                     }\n                     return execute(req, res);\n                 }\n-                res.req = req;\n+                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n+                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n \n                 // check that we can handle the returned content type; if not, abort before fetching it\n                 String contentType = res.contentType();\n                 if (contentType != null\n                         && !req.ignoreContentType()\n                         && !contentType.startsWith(\"text/\")\n-                        && !contentType.startsWith(\"application/xml\")\n                         && !xmlContentTypeRxp.matcher(contentType).matches()\n                         )\n                     throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                             contentType, req.url().toString());\n \n-                InputStream bodyStream = null;\n-                InputStream dataStream = null;\n-                try {\n-                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n-                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                            new BufferedInputStream(dataStream);\n-\n-                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n-                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n-                } finally {\n-                    if (bodyStream != null) bodyStream.close();\n-                    if (dataStream != null) dataStream.close();\n+                // switch to the XML parser if content type is xml and not parser not explicitly set\n+                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n+                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n+                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n+                        req.parser(Parser.xmlParser());\n+                    }\n+                }\n+\n+                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n+                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n+                    InputStream bodyStream = null;\n+                    try {\n+                        bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                        if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                            bodyStream = new GZIPInputStream(bodyStream);\n+\n+                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                    } finally {\n+                        if (bodyStream != null) bodyStream.close();\n+                    }\n+                } else {\n+                    res.byteData = DataUtil.emptyByteBuffer();\n                 }\n             } finally {\n                 // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n \n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n-            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+            final HttpURLConnection conn = (HttpURLConnection) (\n+                req.proxy() == null ?\n+                req.url().openConnection() :\n+                req.url().openConnection(req.proxy())\n+            );\n+\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n             conn.setReadTimeout(req.timeout());\n-            if (req.method() == Method.POST)\n+\n+            if (conn instanceof HttpsURLConnection) {\n+                if (!req.validateTLSCertificates()) {\n+                    initUnSecureTSL();\n+                    ((HttpsURLConnection)conn).setSSLSocketFactory(sslSocketFactory);\n+                    ((HttpsURLConnection)conn).setHostnameVerifier(getInsecureVerifier());\n+                }\n+            }\n+\n+            if (req.method().hasBody())\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n             return conn;\n         }\n \n+        /**\n+         * Instantiate Hostname Verifier that does nothing.\n+         * This is used for connections with disabled SSL certificates validation.\n+         *\n+         *\n+         * @return Hostname Verifier that does nothing and accepts all hostnames\n+         */\n+        private static HostnameVerifier getInsecureVerifier() {\n+            return new HostnameVerifier() {\n+                public boolean verify(String urlHostName, SSLSession session) {\n+                    return true;\n+                }\n+            };\n+        }\n+\n+        /**\n+         * Initialise Trust manager that does not validate certificate chains and\n+         * add it to current SSLContext.\n+         * <p/>\n+         * please not that this method will only perform action if sslSocketFactory is not yet\n+         * instantiated.\n+         *\n+         * @throws IOException\n+         */\n+        private static synchronized void initUnSecureTSL() throws IOException {\n+            if (sslSocketFactory == null) {\n+                // Create a trust manager that does not validate certificate chains\n+                final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n+\n+                    public void checkClientTrusted(final X509Certificate[] chain, final String authType) {\n+                    }\n+\n+                    public void checkServerTrusted(final X509Certificate[] chain, final String authType) {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                }};\n+\n+                // Install the all-trusting trust manager\n+                final SSLContext sslContext;\n+                try {\n+                    sslContext = SSLContext.getInstance(\"SSL\");\n+                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n+                    // Create an ssl socket factory with our all-trusting manager\n+                    sslSocketFactory = sslContext.getSocketFactory();\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                } catch (KeyManagementException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                }\n+            }\n+\n+        }\n+\n         // set up url, method, header, cookies\n         private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n-            method = Connection.Method.valueOf(conn.getRequestMethod());\n+            method = Method.valueOf(conn.getRequestMethod());\n             url = conn.getURL();\n             statusCode = conn.getResponseCode();\n             statusMessage = conn.getResponseMessage();\n             contentType = conn.getContentType();\n \n-            Map<String, List<String>> resHeaders = conn.getHeaderFields();\n+            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n             processResponseHeaders(resHeaders);\n \n             // if from a redirect, map previous response cookies into this response\n                         cookie(prevCookie.getKey(), prevCookie.getValue());\n                 }\n             }\n+        }\n+\n+        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n+            // the default sun impl of conn.getHeaderFields() returns header values out of order\n+            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n+            int i = 0;\n+            while (true) {\n+                final String key = conn.getHeaderFieldKey(i);\n+                final String val = conn.getHeaderField(i);\n+                if (key == null && val == null)\n+                    break;\n+                i++;\n+                if (key == null || val == null)\n+                    continue; // skip http1.1 line\n+\n+                if (headers.containsKey(key))\n+                    headers.get(key).add(val);\n+                else {\n+                    final ArrayList<String> vals = new ArrayList<String>();\n+                    vals.add(val);\n+                    headers.put(key, vals);\n+                }\n+            }\n+            return headers;\n         }\n \n         void processResponseHeaders(Map<String, List<String>> resHeaders) {\n                         TokenQueue cd = new TokenQueue(value);\n                         String cookieName = cd.chompTo(\"=\").trim();\n                         String cookieVal = cd.consumeTo(\";\").trim();\n-                        if (cookieVal == null)\n-                            cookieVal = \"\";\n-                        // ignores path, date, domain, secure et al. req'd?\n+                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                         // name not blank, value not null\n-                        if (cookieName != null && cookieName.length() > 0)\n+                        if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n-                } else { // only take the first instance of each header\n-                    if (!values.isEmpty())\n+                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+                    if (values.size() == 1)\n                         header(name, values.get(0));\n-                }\n-            }\n-        }\n-\n-        private static void writePost(Collection<Connection.KeyVal> data, OutputStream outputStream) throws IOException {\n-            OutputStreamWriter w = new OutputStreamWriter(outputStream, DataUtil.defaultCharset);\n-            boolean first = true;\n-            for (Connection.KeyVal keyVal : data) {\n-                if (!first)\n-                    w.append('&');\n-                else\n-                    first = false;\n-\n-                w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n-                w.write('=');\n-                w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+                    else if (values.size() > 1) {\n+                        StringBuilder accum = new StringBuilder();\n+                        for (int i = 0; i < values.size(); i++) {\n+                            final String val = values.get(i);\n+                            if (i != 0)\n+                                accum.append(\", \");\n+                            accum.append(val);\n+                        }\n+                        header(name, accum.toString());\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static String setOutputContentType(final Connection.Request req) {\n+            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n+            boolean needsMulti = false;\n+            for (Connection.KeyVal keyVal : req.data()) {\n+                if (keyVal.hasInputStream()) {\n+                    needsMulti = true;\n+                    break;\n+                }\n+            }\n+            String bound = null;\n+            if (needsMulti) {\n+                bound = DataUtil.mimeBoundary();\n+                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n+            } else {\n+                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n+            }\n+            return bound;\n+        }\n+\n+        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n+            final Collection<Connection.KeyVal> data = req.data();\n+            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n+\n+            if (bound != null) {\n+                // boundary will be set if we're in multipart mode\n+                for (Connection.KeyVal keyVal : data) {\n+                    w.write(\"--\");\n+                    w.write(bound);\n+                    w.write(\"\\r\\n\");\n+                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n+                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n+                    w.write(\"\\\"\");\n+                    if (keyVal.hasInputStream()) {\n+                        w.write(\"; filename=\\\"\");\n+                        w.write(encodeMimeName(keyVal.value()));\n+                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n+                        w.flush(); // flush\n+                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n+                        outputStream.flush();\n+                    } else {\n+                        w.write(\"\\r\\n\\r\\n\");\n+                        w.write(keyVal.value());\n+                    }\n+                    w.write(\"\\r\\n\");\n+                }\n+                w.write(\"--\");\n+                w.write(bound);\n+                w.write(\"--\");\n+            } else {\n+                // regular form data (application/x-www-form-urlencoded)\n+                boolean first = true;\n+                for (Connection.KeyVal keyVal : data) {\n+                    if (!first)\n+                        w.append('&');\n+                    else\n+                        first = false;\n+\n+                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n+                    w.write('=');\n+                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n+                }\n             }\n             w.close();\n         }\n     public static class KeyVal implements Connection.KeyVal {\n         private String key;\n         private String value;\n+        private InputStream stream;\n \n         public static KeyVal create(String key, String value) {\n-            Validate.notEmpty(key, \"Data key must not be empty\");\n-            Validate.notNull(value, \"Data value must not be null\");\n-            return new KeyVal(key, value);\n-        }\n-\n-        private KeyVal(String key, String value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n+            return new KeyVal().key(key).value(value);\n+        }\n+\n+        public static KeyVal create(String key, String filename, InputStream stream) {\n+            return new KeyVal().key(key).value(filename).inputStream(stream);\n+        }\n+\n+        private KeyVal() {}\n \n         public KeyVal key(String key) {\n             Validate.notEmpty(key, \"Data key must not be empty\");\n             return value;\n         }\n \n+        public KeyVal inputStream(InputStream inputStream) {\n+            Validate.notNull(value, \"Data input stream must not be null\");\n+            this.stream = inputStream;\n+            return this;\n+        }\n+\n+        public InputStream inputStream() {\n+            return stream;\n+        }\n+\n+        public boolean hasInputStream() {\n+            return stream != null;\n+        }\n+\n         @Override\n         public String toString() {\n             return key + \"=\" + value;\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n package org.jsoup.helper;\n \n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n \n         }\n         return false;\n     }\n+\n+    public static boolean inSorted(String needle, String[] haystack) {\n+        return Arrays.binarySearch(haystack, needle) >= 0;\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param base the existing absolulte base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return the resolved absolute URL\n+     * @throws MalformedURLException if an error occurred generating the URL\n+     */\n+    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n+        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n+        if (relUrl.startsWith(\"?\"))\n+            relUrl = base.getPath() + relUrl;\n+        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n+        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n+            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n+        }\n+        return new URL(base, relUrl);\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param baseUrl the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return an absolute URL if one was able to be generated, or the empty string if not\n+     */\n+    public static String resolve(final String baseUrl, final String relUrl) {\n+        URL base;\n+        try {\n+            try {\n+                base = new URL(baseUrl);\n+            } catch (MalformedURLException e) {\n+                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n+                URL abs = new URL(relUrl);\n+                return abs.toExternalForm();\n+            }\n+            return resolve(base, relUrl).toExternalForm();\n+        } catch (MalformedURLException e) {\n+            return \"\";\n+        }\n+\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n+package org.jsoup.helper;\n+\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+import org.w3c.dom.Comment;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Text;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.StringWriter;\n+import java.util.HashMap;\n+\n+/**\n+ * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n+ * for integration with toolsets that use the W3C DOM.\n+ * <p>\n+ * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.\n+ * </p>\n+ */\n+public class W3CDom {\n+    protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+\n+    /**\n+     * Convert a jsoup Document to a W3C Document.\n+     * @param in jsoup doc\n+     * @return w3c doc\n+     */\n+    public Document fromJsoup(org.jsoup.nodes.Document in) {\n+        Validate.notNull(in);\n+        DocumentBuilder builder;\n+        try {\n+        \t//set the factory to be namespace-aware\n+        \tfactory.setNamespaceAware(true);\n+            builder = factory.newDocumentBuilder();\n+            Document out = builder.newDocument();\n+            convert(in, out);\n+            return out;\n+        } catch (ParserConfigurationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Converts a jsoup document into the provided W3C Document. If required, you can set options on the output document\n+     * before converting.\n+     * @param in jsoup doc\n+     * @param out w3c doc\n+     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Document)\n+     */\n+    public void convert(org.jsoup.nodes.Document in, Document out) {\n+        if (!StringUtil.isBlank(in.location()))\n+            out.setDocumentURI(in.location());\n+\n+        org.jsoup.nodes.Element rootEl = in.child(0); // skip the #root node\n+        NodeTraversor traversor = new NodeTraversor(new W3CBuilder(out));\n+        traversor.traverse(rootEl);\n+    }\n+\n+    /**\n+     * Implements the conversion by walking the input.\n+     */\n+    protected static class W3CBuilder implements NodeVisitor {\n+        private static final String xmlnsKey = \"xmlns\";\n+        private static final String xmlnsPrefix = \"xmlns:\";\n+\n+        private final Document doc;\n+        private final HashMap<String, String> namespaces = new HashMap<String, String>(); // prefix => urn\n+        private Element dest;\n+\n+        public W3CBuilder(Document doc) {\n+            this.doc = doc;\n+        }\n+\n+        public void head(org.jsoup.nodes.Node source, int depth) {\n+            if (source instanceof org.jsoup.nodes.Element) {\n+                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n+\n+                String prefix = updateNamespaces(sourceEl);\n+                String namespace = namespaces.get(prefix);\n+\n+                Element el = doc.createElementNS(namespace, sourceEl.tagName());\n+                copyAttributes(sourceEl, el);\n+                if (dest == null) { // sets up the root\n+                    doc.appendChild(el);\n+                } else {\n+                    dest.appendChild(el);\n+                }\n+                dest = el; // descend\n+            } else if (source instanceof org.jsoup.nodes.TextNode) {\n+                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n+                Text text = doc.createTextNode(sourceText.getWholeText());\n+                dest.appendChild(text);\n+            } else if (source instanceof org.jsoup.nodes.Comment) {\n+                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n+                Comment comment = doc.createComment(sourceComment.getData());\n+                dest.appendChild(comment);\n+            } else if (source instanceof org.jsoup.nodes.DataNode) {\n+                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n+                Text node = doc.createTextNode(sourceData.getWholeData());\n+                dest.appendChild(node);\n+            } else {\n+                // unhandled\n+            }\n+        }\n+\n+        public void tail(org.jsoup.nodes.Node source, int depth) {\n+            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n+                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n+            }\n+        }\n+\n+        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n+            for (Attribute attribute : source.attributes()) {\n+                el.setAttribute(attribute.getKey(), attribute.getValue());\n+            }\n+        }\n+\n+        /**\n+         * Finds any namespaces defined in this element. Returns any tag prefix.\n+         */\n+        private String updateNamespaces(org.jsoup.nodes.Element el) {\n+            // scan the element for namespace declarations\n+            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n+            Attributes attributes = el.attributes();\n+            for (Attribute attr : attributes) {\n+                String key = attr.getKey();\n+                String prefix;\n+                if (key.equals(xmlnsKey)) {\n+                    prefix = \"\";\n+                } else if (key.startsWith(xmlnsPrefix)) {\n+                    prefix = key.substring(xmlnsPrefix.length());\n+                } else {\n+                    continue;\n+                }\n+                namespaces.put(prefix, attr.getValue());\n+            }\n+\n+            // get the element prefix if any\n+            int pos = el.tagName().indexOf(\":\");\n+            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n+        }\n+\n+    }\n+\n+    /**\n+     * Serialize a W3C document to a String.\n+     * @param doc Document\n+     * @return Document as string\n+     */\n+    public String asString(Document doc) {\n+        try {\n+            DOMSource domSource = new DOMSource(doc);\n+            StringWriter writer = new StringWriter();\n+            StreamResult result = new StreamResult(writer);\n+            TransformerFactory tf = TransformerFactory.newInstance();\n+            Transformer transformer = tf.newTransformer();\n+            transformer.transform(domSource, result);\n+            return writer.toString();\n+        } catch (TransformerException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n         try {\n         \thtml(accum, (new Document(\"\")).outputSettings());\n         } catch(IOException exception) {\n-        \tthrow new SerializationException(String.format(\"Serialization of the attribute \\\"%s\\\" failed!\", getKey()) , exception);\n+        \tthrow new SerializationException(exception);\n         }\n         return accum.toString();\n     }\n      Get the string representation of this attribute, implemented as {@link #html()}.\n      @return string\n      */\n+    @Override\n     public String toString() {\n         return html();\n     }\n \n     /**\n      * Collapsible if it's a boolean attribute and value is empty or same as name\n+     * \n+     * @param out Outputsettings\n+     * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n         return (\"\".equals(value) || value.equalsIgnoreCase(key))\n                 && out.syntax() == Document.OutputSettings.Syntax.html\n-                && Arrays.binarySearch(booleanAttributes, key) >= 0;\n+                && isBooleanAttribute();\n+    }\n+\n+    protected boolean isBooleanAttribute() {\n+        return Arrays.binarySearch(booleanAttributes, key) >= 0;\n     }\n \n     @Override\n         Attribute attribute = (Attribute) o;\n \n         if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n-        if (value != null ? !value.equals(attribute.value) : attribute.value != null) return false;\n-\n-        return true;\n+        return !(value != null ? !value.equals(attribute.value) : attribute.value != null);\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n \n /**\n  * The attributes of an Element.\n- * <p/>\n+ * <p>\n  * Attributes are treated as a map: there can be only one value associated with an attribute key.\n- * <p/>\n+ * </p>\n+ * <p>\n  * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n  * lower-case.\n+ * </p>\n  * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n+    \n+    /**\n+    Set a new boolean attribute, remove attribute if value is false.\n+    @param key attribute key\n+    @param value attribute value\n+    */\n+    public void put(String key, boolean value) {\n+        if (value)\n+            put(new BooleanAttribute(key));\n+        else\n+            remove(key);\n+    }\n \n     /**\n      Set a new attribute, or replace an existing one by key.\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        try {\n+            html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        } catch (IOException e) { // ought never happen\n+            throw new SerializationException(e);\n+        }\n         return accum.toString();\n     }\n     \n-    void html(Appendable accum, Document.OutputSettings out) {\n+    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         if (attributes == null)\n             return;\n         \n-        try {\n-        \tfor (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n-                Attribute attribute = entry.getValue();\n-                accum.append(\" \");\n-                attribute.html(accum, out);\n-            }\n-        } catch(IOException exception) {\n-        \tthrow new SerializationException(\"Attribute serialization failed!\", exception);\n-        }\n-    }\n-    \n+        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n+            Attribute attribute = entry.getValue();\n+            accum.append(\" \");\n+            attribute.html(accum, out);\n+        }\n+    }\n+    \n+    @Override\n     public String toString() {\n         return html();\n     }\n-    \n+\n+    /**\n+     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n+     * @param o attributes to compare with\n+     * @return if both sets of attributes have the same content\n+     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         \n         Attributes that = (Attributes) o;\n         \n-        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;\n-        \n-        return true;\n-    }\n-    \n+        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n+    }\n+\n+    /**\n+     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n+     * @return calculated hashcode\n+     */\n     @Override\n     public int hashCode() {\n         return attributes != null ? attributes.hashCode() : 0;\n                 attributes = new LinkedHashMap<String, Attribute>(2);\n         }\n \n+        @Override\n         public Set<Entry<String, String>> entrySet() {\n             return new EntrySet();\n         }\n         }\n \n         private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n+\n+            @Override\n             public Iterator<Map.Entry<String, String>> iterator() {\n                 return new DatasetIterator();\n             }\n \n+           @Override\n             public int size() {\n                 int count = 0;\n                 Iterator iter = new DatasetIterator();\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/BooleanAttribute.java\n+package org.jsoup.nodes;\n+\n+/**\n+ * A boolean attribute that is written out without any value.\n+ */\n+public class BooleanAttribute extends Attribute {\n+    /**\n+     * Create a new boolean attribute from unencoded (raw) key.\n+     * @param key attribute key\n+     */\n+    public BooleanAttribute(String key) {\n+        super(key, \"\");\n+    }\n+\n+    @Override\n+    protected boolean isBooleanAttribute() {\n+        return true;\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n     private OutputSettings outputSettings = new OutputSettings();\n     private QuirksMode quirksMode = QuirksMode.noQuirks;\n     private String location;\n+    private boolean updateMetaCharset = false;\n \n     /**\n      Create a new, empty Document.\n \n         normaliseStructure(\"head\", htmlEl);\n         normaliseStructure(\"body\", htmlEl);\n+        \n+        ensureMetaCharsetElement();\n         \n         return this;\n     }\n     }\n     \n     /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public <T extends Appendable> T html(T appendable) {\n-    \t // Exclude outer wrapper tag.\n-    \tfor (Node node : childNodes)\n-            node.outerHtml(appendable);\n-    \t\n-    \treturn appendable;\n+     * Sets the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset(java.nio.charset.Charset)\n+     * OutputSettings.charset(Charset)} but in addition it updates the\n+     * charset / encoding element within the document.\n+     * \n+     * <p>This enables\n+     * {@link #updateMetaCharsetElement(boolean) meta charset update}.</p>\n+     * \n+     * <p>If there's no element with charset / encoding information yet it will\n+     * be created. Obsolete charset / encoding definitions are removed!</p>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     * \n+     * @param charset Charset\n+     * \n+     * @see #updateMetaCharsetElement(boolean) \n+     * @see OutputSettings#charset(java.nio.charset.Charset) \n+     */\n+    public void charset(Charset charset) {\n+        updateMetaCharsetElement(true);\n+        outputSettings.charset(charset);\n+        ensureMetaCharsetElement();\n+    }\n+    \n+    /**\n+     * Returns the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset()}.\n+     * \n+     * @return Current Charset\n+     * \n+     * @see OutputSettings#charset() \n+     */\n+    public Charset charset() {\n+        return outputSettings.charset();\n+    }\n+    \n+    /**\n+     * Sets whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements\n+     * modified.</p>\n+     * \n+     * @param update If <tt>true</tt> the element updated on charset\n+     * changes, <tt>false</tt> if not\n+     * \n+     * @see #charset(java.nio.charset.Charset) \n+     */\n+    public void updateMetaCharsetElement(boolean update) {\n+        this.updateMetaCharset = update;\n+    }\n+    \n+    /**\n+     * Returns whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * @return Returns <tt>true</tt> if the element is updated on charset\n+     * changes, <tt>false</tt> if not\n+     */\n+    public boolean updateMetaCharsetElement() {\n+        return updateMetaCharset;\n     }\n \n     @Override\n         clone.outputSettings = this.outputSettings.clone();\n         return clone;\n     }\n+    \n+    /**\n+     * Ensures a meta charset (html) or xml declaration (xml) with the current\n+     * encoding used. This only applies with\n+     * {@link #updateMetaCharsetElement(boolean) updateMetaCharset} set to\n+     * <tt>true</tt>, otherwise this method does nothing.\n+     * \n+     * <ul>\n+     * <li>An exsiting element gets updated with the current charset</li>\n+     * <li>If there's no element yet it will be inserted</li>\n+     * <li>Obsolete elements are removed</li>\n+     * </ul>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     */\n+    private void ensureMetaCharsetElement() {\n+        if (updateMetaCharset) {\n+            OutputSettings.Syntax syntax = outputSettings().syntax();\n+\n+            if (syntax == OutputSettings.Syntax.html) {\n+                Element metaCharset = select(\"meta[charset]\").first();\n+\n+                if (metaCharset != null) {\n+                    metaCharset.attr(\"charset\", charset().displayName());\n+                } else {\n+                    Element head = head();\n+\n+                    if (head != null) {\n+                        head.appendElement(\"meta\").attr(\"charset\", charset().displayName());\n+                    }\n+                }\n+\n+                // Remove obsolete elements\n+                select(\"meta[name=charset]\").remove();\n+            } else if (syntax == OutputSettings.Syntax.xml) {\n+                Node node = childNodes().get(0);\n+\n+                if (node instanceof XmlDeclaration) {\n+                    XmlDeclaration decl = (XmlDeclaration) node;\n+\n+                    if (decl.attr(XmlDeclaration.DECL_KEY).equals(\"xml\")) {\n+                        decl.attr(\"encoding\", charset().displayName());\n+\n+                        final String version = decl.attr(\"version\");\n+\n+                        if (version != null) {\n+                            decl.attr(\"version\", \"1.0\");\n+                        }\n+                    } else {\n+                        decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                        decl.attr(\"version\", \"1.0\");\n+                        decl.attr(\"encoding\", charset().displayName());\n+\n+                        prependChild(decl);\n+                    }\n+                } else {\n+                    XmlDeclaration decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                    decl.attr(\"version\", \"1.0\");\n+                    decl.attr(\"encoding\", charset().displayName());\n+\n+                    prependChild(decl);\n+                }\n+            } else {\n+                // Unsupported syntax - nothing to do yet\n+            }\n+        }\n+    }\n+    \n \n     /**\n      * A Document's output settings control the form of the text() and html() methods.\n         private Syntax syntax = Syntax.html;\n \n         public OutputSettings() {}\n-\n+        \n         /**\n          * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML\n          * entities and escapes other characters as numbered entities for maximum compatibility; or <code>extended</code>,\n          * @return the document's output settings, for chaining\n          */\n         public OutputSettings charset(Charset charset) {\n-            // todo: this should probably update the doc's meta charset\n             this.charset = charset;\n             charsetEncoder = charset.newEncoder();\n             return this;\n \n         /**\n          * Set the indent amount for pretty printing\n-         * @param indentAmount number of spaces to use for indenting each level. Must be >= 0.\n+         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n          * @return this, for chaining\n          */\n         public OutputSettings indentAmount(int indentAmount) {\n     }\n \n     public enum QuirksMode {\n-        noQuirks, quirks, limitedQuirks;\n+        noQuirks, quirks, limitedQuirks\n     }\n \n     public QuirksMode quirksMode() {\n         this.quirksMode = quirksMode;\n         return this;\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return super.equals(o);\n-    }\n }\n-\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n-import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Document.OutputSettings.*;\n \n /**\n  * A {@code <!DOCTYPE>} node.\n  */\n public class DocumentType extends Node {\n+    private static final String NAME = \"name\";\n+    private static final String PUBLIC_ID = \"publicId\";\n+    private static final String SYSTEM_ID = \"systemId\";\n     // todo: quirk mode from publicId and systemId\n \n     /**\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        attr(\"name\", name);\n-        attr(\"publicId\", publicId);\n-        attr(\"systemId\", systemId);\n+        attr(NAME, name);\n+        attr(PUBLIC_ID, publicId);\n+        attr(SYSTEM_ID, systemId);\n     }\n \n     @Override\n \n     @Override\n     void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n-        accum.append(\"<!DOCTYPE\");\n-        if (!StringUtil.isBlank(attr(\"name\")))\n-            accum.append(\" \").append(attr(\"name\"));\n-        if (!StringUtil.isBlank(attr(\"publicId\")))\n-            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n-        if (!StringUtil.isBlank(attr(\"systemId\")))\n-            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n+        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n+            // looks like a html5 doctype, go lowercase for aesthetics\n+            accum.append(\"<!doctype\");\n+        } else {\n+            accum.append(\"<!DOCTYPE\");\n+        }\n+        if (has(NAME))\n+            accum.append(\" \").append(attr(NAME));\n+        if (has(PUBLIC_ID))\n+            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n+        if (has(SYSTEM_ID))\n+            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n         accum.append('>');\n     }\n \n     @Override\n     void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n     }\n+\n+    private boolean has(final String attribute) {\n+        return !StringUtil.isBlank(attr(attribute));\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.*;\n+import org.jsoup.select.Collector;\n+import org.jsoup.select.Elements;\n+import org.jsoup.select.Evaluator;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+import org.jsoup.select.Selector;\n \n import java.io.IOException;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n \n  */\n public class Element extends Node {\n     private Tag tag;\n-    private Set<String> classNames;\n-    \n+\n+    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n+\n     /**\n      * Create a new, standalone Element. (Standalone in that is has no parent.)\n      * \n      * @return The id attribute, if present, or an empty string if not.\n      */\n     public String id() {\n-        String id = attr(\"id\");\n-        return id == null ? \"\" : id;\n+        return attributes.get(\"id\");\n     }\n \n     /**\n      */\n     public Element attr(String attributeKey, String attributeValue) {\n         super.attr(attributeKey, attributeValue);\n+        return this;\n+    }\n+    \n+    /**\n+     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n+     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n+     * with the same key if it exists.\n+     * \n+     * @param attributeKey the attribute key\n+     * @param attributeValue the attribute value\n+     * \n+     * @return this element\n+     */\n+    public Element attr(String attributeKey, boolean attributeValue) {\n+        attributes.put(attributeKey, attributeValue);\n         return this;\n     }\n \n \n     /**\n      * Get a child element of this element, by its 0-based index number.\n-     * <p/>\n+     * <p>\n      * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n      * a filtered list of children that are elements, and the index is based on that filtered list.\n+     * </p>\n      * \n      * @param index the index number of the element to retrieve\n      * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n \n     /**\n      * Get this element's child elements.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n+     * </p>\n      * @return child elements. If this element has no children, returns an\n      * empty list.\n      * @see #childNodes()\n \n     /**\n      * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n      * @return child text nodes. If this element has no text nodes, returns an\n      * empty list.\n-     * <p/>\n+     * </p>\n      * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n      * <ul>\n      *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n \n     /**\n      * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n+     * </p>\n      * @return child data nodes. If this element has no data nodes, returns an\n      * empty list.\n      * @see #data()\n     /**\n      * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n      * may include this element, or any of its children.\n-     * <p/>\n+     * <p>\n      * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n      * multiple filters can be combined, e.g.:\n+     * </p>\n      * <ul>\n      * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n      * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n      * </ul>\n-     * <p/>\n+     * <p>\n      * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n-     *\n+     * </p>\n+     * \n      * @param cssQuery a {@link Selector} CSS-like query\n      * @return elements that match the query (empty if none match)\n      * @see org.jsoup.select.Selector\n+     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n      */\n     public Elements select(String cssQuery) {\n         return Selector.select(cssQuery, this);\n      */\n     public Element appendChild(Node child) {\n         Validate.notNull(child);\n-        \n-        addChildren(child);\n+\n+        // was - Node#addChildren(child). short-circuits an array create and a loop.\n+        reparentChild(child);\n+        ensureChildNodes();\n+        childNodes.add(child);\n+        child.setSiblingIndex(childNodes.size() - 1);\n         return this;\n     }\n \n      * @return this element\n      */\n     public Element appendText(String text) {\n+        Validate.notNull(text);\n         TextNode node = new TextNode(text, baseUri());\n         appendChild(node);\n         return this;\n      * @return this element\n      */\n     public Element prependText(String text) {\n+        Validate.notNull(text);\n         TextNode node = new TextNode(text, baseUri());\n         prependChild(node);\n         return this;\n \n     /**\n      * Get a CSS selector that will uniquely select this element.\n-     * <p/>If the element has an ID, returns #id;\n-     * otherwise returns the parent (if any) CSS selector, followed by '>',\n+     * <p>\n+     * If the element has an ID, returns #id;\n+     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n      * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n+     * </p>\n      *\n      * @return the CSS Path that can be used to retrieve the element in a selector.\n      */\n     /**\n      * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n      * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n-     * <p/>\n+     * <p>\n      * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n+     * </p>\n      * @return the next element, or null if there is no next element\n      * @see #previousElementSibling()\n      */\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+            if (element == search)\n                 return i;\n         }\n         return null;\n \n     /**\n      * Gets the literal value of this element's \"class\" attribute, which may include multiple class names, space\n-     * separated. (E.g. on <code>&lt;div class=\"header gray\"></code> returns, \"<code>header gray</code>\")\n+     * separated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n      */\n     public String className() {\n-        return attr(\"class\");\n-    }\n-\n-    /**\n-     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\"}>},\n+        return attr(\"class\").trim();\n+    }\n+\n+    /**\n+     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\">},\n      * returns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\n      * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n      * @return set of classnames, empty if no class attribute\n      */\n     public Set<String> classNames() {\n-        if (classNames == null) {\n-            String[] names = className().split(\"\\\\s+\");\n-            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n-        }\n+    \tString[] names = classSplit.split(className());\n+    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n+    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n+\n         return classNames;\n     }\n \n      * @param className name of class to check for\n      * @return true if it does, false if not\n      */\n+    /*\n+    Used by common .class selector, so perf tweaked to reduce object creation vs hitting classnames().\n+\n+    Wiki: 71, 13 (5.4x)\n+    CNN: 227, 91 (2.5x)\n+    Alterslash: 59, 4 (14.8x)\n+    Jsoup: 14, 1 (14x)\n+    */\n     public boolean hasClass(String className) {\n-        Set<String> classNames = classNames();\n-        for (String name : classNames) {\n+        String classAttr = attributes.get(\"class\");\n+        if (classAttr.equals(\"\") || classAttr.length() < className.length())\n+            return false;\n+\n+        final String[] classes = classSplit.split(classAttr);\n+        for (String name : classes) {\n             if (className.equalsIgnoreCase(name))\n                 return true;\n         }\n+\n         return false;\n     }\n \n             attr(\"value\", value);\n         return this;\n     }\n-    \n+\n     void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n-    \tif (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n-    \t\tif(accum instanceof StringBuilder) {\n-    \t\t\tif(((StringBuilder)accum).length() > 0)\n-    \t\t\t\tindent(accum, depth, out);\n-    \t\t} else {\n-    \t\t\tindent(accum, depth, out);\n-    \t\t}\n-    \t}\n-    \taccum\n-        \t\t.append(\"<\")\n-        \t\t.append(tagName());\n+        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n+            if (accum instanceof StringBuilder) {\n+                if (((StringBuilder) accum).length() > 0)\n+                    indent(accum, depth, out);\n+            } else {\n+                indent(accum, depth, out);\n+            }\n+        }\n+        accum\n+                .append(\"<\")\n+                .append(tagName());\n         attributes.html(accum, out);\n \n         // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T extends Appendable> T html(T appendable) {\n+        for (Node node : childNodes)\n+            node.outerHtml(appendable);\n+\n+        return appendable;\n+    }\n     \n     /**\n      * Set this element's inner HTML. Clears the existing HTML first.\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        return this == o;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        // todo: fixup, not very useful\n-        int result = super.hashCode();\n-        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n-        return result;\n-    }\n-\n-    @Override\n     public Element clone() {\n-        Element clone = (Element) super.clone();\n-        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n-        return clone;\n+        return (Element) super.clone();\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.parser.Parser;\n \n import java.io.InputStream;\n import java.nio.charset.CharsetEncoder;\n import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  * HTML entities, and escape routines.\n     /**\n      * Get the Character value of the named entity\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n-     * @return the Character value of the named entity (e.g. '<' or '&')\n+     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n      */\n     public static Character getCharacterByName(String name) {\n         return full.get(name);\n     }\n     \n-    static String escape(String string, Document.OutputSettings out) throws IOException {\n+    static String escape(String string, Document.OutputSettings out) {\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n-        escape(accum, string, out, false, false, false);\n+        try {\n+            escape(accum, string, out, false, false, false);\n+        } catch (IOException e) {\n+            throw new SerializationException(e); // doesn't happen\n+        }\n         return accum.toString();\n     }\n \n \n         boolean lastWasWhite = false;\n         boolean reachedNonWhite = false;\n-        EscapeMode escapeMode = out.escapeMode();\n-        CharsetEncoder encoder = out.encoder();\n-        Map<Character, String> map = escapeMode.getMap();\n+        final EscapeMode escapeMode = out.escapeMode();\n+        final CharsetEncoder encoder = out.encoder();\n+        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n+        final Map<Character, String> map = escapeMode.getMap();\n         final int length = string.length();\n \n         int codePoint;\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                            accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n-                        if (!inAttribute)\n+                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n+                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                             accum.append(c);\n                         break;\n                     default:\n-                        if (encoder.canEncode(c))\n+                        if (canEncode(coreCharset, c, encoder))\n                             accum.append(c);\n                         else if (map.containsKey(c))\n                             accum.append('&').append(map.get(c)).append(';');\n                 }\n             } else {\n                 final String c = new String(Character.toChars(codePoint));\n-                if (encoder.canEncode(c))\n+                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                     accum.append(c);\n                 else\n                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n \n     /**\n      * Unescape the input string.\n-     * @param string\n+     * @param string to un-HTML-escape\n      * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n-     * @return\n+     * @return unescaped string\n      */\n     static String unescape(String string, boolean strict) {\n         return Parser.unescapeEntities(string, strict);\n+    }\n+\n+    /*\n+     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n+     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n+     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n+     * issues on Android if required.\n+     *\n+     * Benchmarks:     *\n+     * OLD toHtml() impl v New (fastpath) in millis\n+     * Wiki: 1895, 16\n+     * CNN: 6378, 55\n+     * Alterslash: 3013, 28\n+     * Jsoup: 167, 2\n+     */\n+\n+    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n+        // todo add more charset tests if impacted by Android's bad perf in canEncode\n+        switch (charset) {\n+            case ascii:\n+                return c < 0x80;\n+            case utf:\n+                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\n+            default:\n+                return fallback.canEncode(c);\n+        }\n+    }\n+\n+    private enum CoreCharset {\n+        ascii, utf, fallback;\n+\n+        private static CoreCharset byName(String name) {\n+            if (name.equals(\"US-ASCII\"))\n+                return ascii;\n+            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n+                return utf;\n+            return fallback;\n+        }\n     }\n \n \n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n         Connection.Method method = attr(\"method\").toUpperCase().equals(\"POST\") ?\n                 Connection.Method.POST : Connection.Method.GET;\n \n-        Connection con = Jsoup.connect(action)\n+        return Jsoup.connect(action)\n                 .data(formData())\n                 .method(method);\n-\n-        return con;\n     }\n \n     /**\n         // iterate the form control elements and accumulate their values\n         for (Element el: elements) {\n             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n+            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n             String name = el.attr(\"name\");\n             if (name.length() == 0) continue;\n+            String type = el.attr(\"type\");\n \n             if (\"select\".equals(el.tagName())) {\n                 Elements options = el.select(\"option[selected]\");\n+                boolean set = false;\n                 for (Element option: options) {\n                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n+                    set = true;\n+                }\n+                if (!set) {\n+                    Element option = el.select(\"option\").first();\n+                    if (option != null)\n+                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n+                }\n+            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n+                // only add checkbox or radio if they have the checked attribute\n+                if (el.hasAttr(\"checked\")) {\n+                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n+                    data.add(HttpConnection.KeyVal.create(name, val));\n                 }\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n         }\n         return data;\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return super.equals(o);\n-    }\n }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import org.jsoup.select.NodeVisitor;\n \n import java.io.IOException;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.LinkedList;\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public abstract class Node implements Cloneable {\n+    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n     Node parentNode;\n     List<Node> childNodes;\n     Attributes attributes;\n         Validate.notNull(baseUri);\n         Validate.notNull(attributes);\n         \n-        childNodes = new ArrayList<Node>(4);\n+        childNodes = EMPTY_NODES;\n         this.baseUri = baseUri.trim();\n         this.attributes = attributes;\n     }\n      * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n      */\n     protected Node() {\n-        childNodes = Collections.emptyList();\n+        childNodes = EMPTY_NODES;\n         attributes = null;\n     }\n \n \n     /**\n      * Get an attribute's value by its key.\n-     * <p/>\n+     * <p>\n      * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n      * which is a shortcut to the {@link #absUrl} method.\n-     * E.g.: <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * </p>\n+     * E.g.:\n+     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * \n      * @param attributeKey The attribute key.\n      * @return The attribute, or empty string if not present (to avoid nulls).\n      * @see #attributes()\n     }\n \n     /**\n-     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n-     * <code>&lt;img src></code>).\n-     * <p/>\n+     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href&gt;</code> or\n+     * <code>&lt;img src&gt;</code>).\n+     * <p>\n      * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n-     * <p/>\n+     * </p>\n+     * <p>\n      * If the attribute value is already absolute (i.e. it starts with a protocol, like\n      * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n      * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n      * absolute using that.\n-     * <p/>\n+     * </p>\n+     * <p>\n      * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n      * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n-     *\n+     * </p>\n+     * \n      * @param attributeKey The attribute key\n      * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n      * could not be made successfully into a URL.\n     public String absUrl(String attributeKey) {\n         Validate.notEmpty(attributeKey);\n \n-        String relUrl = attr(attributeKey);\n         if (!hasAttr(attributeKey)) {\n             return \"\"; // nothing to make absolute with\n         } else {\n-            URL base;\n-            try {\n-                try {\n-                    base = new URL(baseUri);\n-                } catch (MalformedURLException e) {\n-                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n-                    URL abs = new URL(relUrl);\n-                    return abs.toExternalForm();\n-                }\n-                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n-                if (relUrl.startsWith(\"?\"))\n-                    relUrl = base.getPath() + relUrl;\n-                URL abs = new URL(base, relUrl);\n-                return abs.toExternalForm();\n-            } catch (MalformedURLException e) {\n-                return \"\";\n-            }\n+            return StringUtil.resolve(baseUri, attr(attributeKey));\n         }\n     }\n \n      * @see #after(String)\n      */\n     public Node before(String html) {\n-        addSiblingHtml(siblingIndex(), html);\n+        addSiblingHtml(siblingIndex, html);\n         return this;\n     }\n \n         Validate.notNull(node);\n         Validate.notNull(parentNode);\n \n-        parentNode.addChildren(siblingIndex(), node);\n+        parentNode.addChildren(siblingIndex, node);\n         return this;\n     }\n \n      * @see #before(String)\n      */\n     public Node after(String html) {\n-        addSiblingHtml(siblingIndex()+1, html);\n+        addSiblingHtml(siblingIndex + 1, html);\n         return this;\n     }\n \n         Validate.notNull(node);\n         Validate.notNull(parentNode);\n \n-        parentNode.addChildren(siblingIndex()+1, node);\n+        parentNode.addChildren(siblingIndex + 1, node);\n         return this;\n     }\n \n     /**\n      * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n      * the node but keeping its children.\n-     * <p/>\n-     * For example, with the input html:<br/>\n-     * {@code <div>One <span>Two <b>Three</b></span></div>}<br/>\n-     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:<br/>\n-     * {@code <div>One Two <b>Three</b></div>}<br/>\n+     * <p>\n+     * For example, with the input html:\n+     * </p>\n+     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n+     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n+     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n      * and the {@code \"Two \"} {@link TextNode} being returned.\n+     * \n      * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n      * @see #remove()\n      * @see #wrap(String)\n     public Node unwrap() {\n         Validate.notNull(parentNode);\n \n-        int index = siblingIndex;\n         Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n-        parentNode.addChildren(index, this.childNodesAsArray());\n+        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n         this.remove();\n \n         return firstChild;\n         if (in.parentNode != null)\n             in.parentNode.removeChild(in);\n         \n-        Integer index = out.siblingIndex();\n+        final int index = out.siblingIndex;\n         childNodes.set(index, in);\n         in.parentNode = this;\n         in.setSiblingIndex(index);\n \n     protected void removeChild(Node out) {\n         Validate.isTrue(out.parentNode == this);\n-        int index = out.siblingIndex();\n+        final int index = out.siblingIndex;\n         childNodes.remove(index);\n-        reindexChildren();\n+        reindexChildren(index);\n         out.parentNode = null;\n     }\n \n         //most used. short circuit addChildren(int), which hits reindex children and array copy\n         for (Node child: children) {\n             reparentChild(child);\n+            ensureChildNodes();\n             childNodes.add(child);\n             child.setSiblingIndex(childNodes.size()-1);\n         }\n \n     protected void addChildren(int index, Node... children) {\n         Validate.noNullElements(children);\n+        ensureChildNodes();\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n-        }\n-        reindexChildren();\n-    }\n-\n-    private void reparentChild(Node child) {\n+            reindexChildren(index);\n+        }\n+    }\n+\n+    protected void ensureChildNodes() {\n+        if (childNodes == EMPTY_NODES) {\n+            childNodes = new ArrayList<Node>(4);\n+        }\n+    }\n+\n+    protected void reparentChild(Node child) {\n         if (child.parentNode != null)\n             child.parentNode.removeChild(child);\n         child.setParentNode(this);\n     }\n     \n-    private void reindexChildren() {\n-        for (int i = 0; i < childNodes.size(); i++) {\n+    private void reindexChildren(int start) {\n+        for (int i = start; i < childNodes.size(); i++) {\n             childNodes.get(i).setSiblingIndex(i);\n         }\n     }\n         if (parentNode == null)\n             return null; // root\n         \n-        List<Node> siblings = parentNode.childNodes;\n-        Integer index = siblingIndex();\n-        Validate.notNull(index);\n-        if (siblings.size() > index+1)\n-            return siblings.get(index+1);\n+        final List<Node> siblings = parentNode.childNodes;\n+        final int index = siblingIndex+1;\n+        if (siblings.size() > index)\n+            return siblings.get(index);\n         else\n             return null;\n     }\n         if (parentNode == null)\n             return null; // root\n \n-        List<Node> siblings = parentNode.childNodes;\n-        Integer index = siblingIndex();\n-        Validate.notNull(index);\n-        if (index > 0)\n-            return siblings.get(index-1);\n+        if (siblingIndex > 0)\n+            return parentNode.childNodes.get(siblingIndex-1);\n         else\n             return null;\n     }\n     abstract void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n \n     /**\n-     * Recursively serializes this node to the given {@link Appendable} and returns the resulting <code>Appendable</code> instance.\n-     *   \n-     * @param appendable the {@link Appendable} that should hold the content of this node and all its child nodes.\n-     * @return the given {@link Appendable}, now containing this node and all child nodes.\n+     * Write this node and its children to the given {@link Appendable}.\n+     *\n+     * @param appendable the {@link Appendable} to write to.\n+     * @return the supplied {@link Appendable}, for chaining.\n      */\n     public <T extends Appendable> T html(T appendable) {\n-    \touterHtml(appendable);\n-    \treturn appendable;\n+        outerHtml(appendable);\n+        return appendable;\n     }\n     \n \tpublic String toString() {\n         accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n     }\n \n+    /**\n+     * Check if this node is the same instance of another (object identity test).\n+     * @param o other object to compare to\n+     * @return true if the content of this node is the same as the other\n+     * @see Node#hasSameValue(Object) to compare nodes by their value\n+     */\n     @Override\n     public boolean equals(Object o) {\n+        // implemented just so that javadoc is clear this is an identity test\n+        return this == o;\n+    }\n+\n+    /**\n+     * Check if this node is has the same content as another node. A node is considered the same if its name, attributes and content match the\n+     * other node; particularly its position in the tree does not influence its similarity.\n+     * @param o other object to compare to\n+     * @return true if the content of this node is the same as the other\n+     */\n+\n+    public boolean hasSameValue(Object o) {\n         if (this == o) return true;\n-        // todo: have nodes hold a child index, compare against that and parent (not children)\n-        return false;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = parentNode != null ? parentNode.hashCode() : 0;\n-        // not children, or will block stack as they go back up to parent)\n-        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n-        return result;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Node node = (Node) o;\n+        return this.outerHtml().equals(((Node) o).outerHtml());\n     }\n \n     /**\n             try {\n \t\t\t\tnode.outerHtmlHead(accum, depth, out);\n \t\t\t} catch (IOException exception) {\n-\t\t\t\tthrow new SerializationException(\"Node head serialization failed!\", exception);\n+\t\t\t\tthrow new SerializationException(exception);\n \t\t\t}\n         }\n \n \t\t\t\ttry {\n \t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n \t\t\t\t} catch (IOException exception) {\n-\t\t\t\t\tthrow new SerializationException(\"Node tail serialization failed!\", exception);\n+\t\t\t\t\tthrow new SerializationException(exception);\n \t\t\t\t}\n             }\n         }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             indent(accum, depth, out);\n \n         boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n-                && !Element.preserveWhitespace((Element) parent());\n+                && !Element.preserveWhitespace(parent());\n         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n     }\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n-\tpublic String toString() {\n+    @Override\n+    public String toString() {\n         return outerHtml();\n     }\n \n     /**\n      * Create a new TextNode from HTML encoded (aka escaped) data.\n      * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n+     * @param baseUri Base uri\n      * @return TextNode containing unencoded data (e.g. &lt;)\n      */\n     public static TextNode createFromEncoded(String encodedText, String baseUri) {\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class XmlDeclaration extends Node {\n-    private static final String DECL_KEY = \"declaration\";\n+    static final String DECL_KEY = \"declaration\";\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n     /**\n      @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        return attributes.get(DECL_KEY);\n+        final String decl = attributes.get(DECL_KEY);\n+        \n+        if(decl.equals(\"xml\") && attributes.size() > 1 ) {\n+            StringBuilder sb = new StringBuilder(decl);\n+            final String version = attributes.get(\"version\");\n+            \n+            if( version != null ) {\n+                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n+            }\n+            \n+            final String encoding = attributes.get(\"encoding\");\n+            \n+            if( encoding != null ) {\n+                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n+            }\n+            \n+            return sb.toString();\n+        }\n+        else {\n+            return attributes.get(DECL_KEY);\n+        }\n     }\n \n \tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n-\tpublic String toString() {\n+    @Override\n+    public String toString() {\n         return outerHtml();\n     }\n }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n \n import org.jsoup.helper.Validate;\n \n+import java.util.Arrays;\n import java.util.Locale;\n \n /**\n  CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n  */\n-class CharacterReader {\n+final class CharacterReader {\n     static final char EOF = (char) -1;\n+    private static final int maxCacheLen = 12;\n \n     private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n+    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n         for (int offset = pos; offset < length; offset++) {\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]);\n+                while(++offset < length && startChar != input[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n             if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n     String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     }\n \n     String consumeToAny(final char... chars) {\n-        int start = pos;\n-\n-        OUTER: while (pos < length) {\n-            for (int i = 0; i < chars.length; i++) {\n-                if (input[pos] == chars[i])\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        OUTER: while (pos < remaining) {\n+            for (char c : chars) {\n+                if (val[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input, start, pos-start) : \"\";\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeToAnySorted(final char... chars) {\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeData() {\n+        // &, <, null\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeTagName() {\n+        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input, pos, length-pos);\n+        String data = cacheString(pos, length-pos);\n         pos = length;\n         return data;\n     }\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeHexSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     boolean matches(char c) {\n         return false;\n     }\n \n+    boolean matchesAnySorted(char[] seq) {\n+        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+    }\n+\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n         char c = input[pos];\n-        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n     }\n \n     boolean matchesDigit() {\n     public String toString() {\n         return new String(input, pos, length - pos);\n     }\n+\n+    /**\n+     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n+     * <p />\n+     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n+     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n+     * some more duplicates.\n+     */\n+    private String cacheString(final int start, final int count) {\n+        final char[] val = input;\n+        final String[] cache = stringCache;\n+\n+        // limit (no cache):\n+        if (count > maxCacheLen)\n+            return new String(val, start, count);\n+\n+        // calculate hash:\n+        int hash = 0;\n+        int offset = start;\n+        for (int i = 0; i < count; i++) {\n+            hash = 31 * hash + val[offset++];\n+        }\n+\n+        // get from cache\n+        final int index = hash & cache.length - 1;\n+        String cached = cache[index];\n+\n+        if (cached == null) { // miss, add\n+            cached = new String(val, start, count);\n+            cache[index] = cached;\n+        } else { // hashcode hit, check equality\n+            if (rangeEquals(start, count, cached)) { // hit\n+                return cached;\n+            } else { // hashcode conflict\n+                cached = new String(val, start, count);\n+                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n+            }\n+        }\n+        return cached;\n+    }\n+\n+    /**\n+     * Check if the value of the provided range equals the string.\n+     */\n+    boolean rangeEquals(final int start, int count, final String cached) {\n+        if (count == cached.length()) {\n+            char one[] = input;\n+            int i = start;\n+            int j = 0;\n+            while (count-- != 0) {\n+                if (one[i++] != cached.charAt(j++))\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n  * HTML Tree Builder; creates a DOM from Tokens.\n  */\n-class HtmlTreeBuilder extends TreeBuilder {\n+public class HtmlTreeBuilder extends TreeBuilder {\n     // tag searches\n     private static final String[] TagsScriptStyle = new String[]{\"script\", \"style\"};\n     public static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n     private Element headElement; // the current head element\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n-    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+    private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n+    private List<String> pendingTableCharacters = new ArrayList<String>(); // chars in table to be shifted out\n+    private Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag\n \n     private boolean framesetOk = true; // if ok to go into frameset\n     private boolean fosterInserts = false; // if next inserts should be fostered\n \n             root = new Element(Tag.valueOf(\"html\"), baseUri);\n             doc.appendChild(root);\n-            stack.push(root);\n+            stack.add(root);\n             resetInsertionMode();\n \n             // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n         }\n \n         runParser();\n-        if (context != null)\n+        if (context != null && root != null)\n             return root.childNodes();\n         else\n             return doc.childNodes();\n             Element el = insertEmpty(startTag);\n             stack.add(el);\n             tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n-            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n+            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n         return el;\n     }\n \n-    Element insert(String startTagName) {\n+    Element insertStartTag(String startTagName) {\n         Element el = new Element(Tag.valueOf(startTagName), baseUri);\n         insert(el);\n         return el;\n     }\n \n     Element pop() {\n-        // todo - dev, remove validation check\n-        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n-            Validate.isFalse(true, \"pop td not in cell\");\n-        if (stack.peekLast().nodeName().equals(\"html\"))\n-            Validate.isFalse(true, \"popping html!\");\n-        return stack.pollLast();\n+        int size = stack.size();\n+        return stack.remove(size-1);\n     }\n \n     void push(Element element) {\n         stack.add(element);\n     }\n \n-    DescendableLinkedList<Element> getStack() {\n+    ArrayList<Element> getStack() {\n         return stack;\n     }\n \n         return isElementInQueue(stack, el);\n     }\n \n-    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n-        Iterator<Element> it = queue.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n+        for (int pos = queue.size() -1; pos >= 0; pos--) {\n+            Element next = queue.get(pos);\n             if (next == element) {\n                 return true;\n             }\n     }\n \n     Element getFromStack(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 return next;\n             }\n     }\n \n     boolean removeFromStack(Element el) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                it.remove();\n+                stack.remove(pos);\n                 return true;\n             }\n         }\n     }\n \n     void popStackToClose(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next.nodeName().equals(elName))\n+                break;\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (StringUtil.in(next.nodeName(), elNames))\n+                break;\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n-                it.remove();\n                 break;\n             } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToClose(String... elNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), elNames)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToBefore(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                break;\n-            } else {\n-                it.remove();\n+                stack.remove(pos);\n             }\n         }\n     }\n     }\n \n     private void clearStackToContext(String... nodeNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                 break;\n             else\n-                it.remove();\n+                stack.remove(pos);\n         }\n     }\n \n     Element aboveOnStack(Element el) {\n         assert onStack(el);\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                return it.next();\n+                return stack.get(pos-1);\n             }\n         }\n         return null;\n         replaceInQueue(stack, out, in);\n     }\n \n-    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n         int i = queue.lastIndexOf(out);\n         Validate.isTrue(i != -1);\n-        queue.remove(i);\n-        queue.add(i, in);\n+        queue.set(i, in);\n     }\n \n     void resetInsertionMode() {\n         boolean last = false;\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element node = it.next();\n-            if (!it.hasNext()) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element node = stack.get(pos);\n+            if (pos == 0) {\n                 last = true;\n                 node = contextElement;\n             }\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n     }\n \n     // todo: tidy up in specific scope methods\n+    private String[] specificScopeTarget = {null};\n+\n     private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n-        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n+        specificScopeTarget[0] = targetName;\n+        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n     }\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (StringUtil.in(elName, targetNames))\n                 return true;\n     }\n \n     boolean inScope(String targetName, String[] extras) {\n-        return inSpecificScope(targetName, TagsSearchInScope , extras);\n+        return inSpecificScope(targetName, TagsSearchInScope, extras);\n         // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n         // todo: in svg namespace: forignOjbect, desc, title\n     }\n     }\n \n     boolean inSelectScope(String targetName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (elName.equals(targetName))\n                 return true;\n     }\n \n     void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<Token.Character>();\n-    }\n-\n-    List<Token.Character> getPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<String>();\n+    }\n+\n+    List<String> getPendingTableCharacters() {\n         return pendingTableCharacters;\n     }\n \n-    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n         this.pendingTableCharacters = pendingTableCharacters;\n     }\n \n         return StringUtil.in(name, TagSearchSpecial);\n     }\n \n+    Element lastFormattingElement() {\n+        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n+    }\n+\n+    Element removeLastFormattingElement() {\n+        int size = formattingElements.size();\n+        if (size > 0)\n+            return formattingElements.remove(size-1);\n+        else\n+            return null;\n+    }\n+\n     // active formatting elements\n     void pushActiveFormattingElements(Element in) {\n         int numSeen = 0;\n-        Iterator<Element> iter = formattingElements.descendingIterator();\n-        while (iter.hasNext()) {\n-            Element el =  iter.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element el = formattingElements.get(pos);\n             if (el == null) // marker\n                 break;\n \n                 numSeen++;\n \n             if (numSeen == 3) {\n-                iter.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     void reconstructFormattingElements() {\n+        Element last = lastFormattingElement();\n+        if (last == null || onStack(last))\n+            return;\n+\n+        Element entry = last;\n         int size = formattingElements.size();\n-        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n-            return;\n-\n-        Element entry = formattingElements.getLast();\n         int pos = size - 1;\n         boolean skip = false;\n         while (true) {\n \n             // 8. create new element from element, 9 insert into current node, onto stack\n             skip = false; // can only skip increment from 4.\n-            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n+            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n             // newEl.namespace(entry.namespace()); // todo: namespaces\n             newEl.attributes().addAll(entry.attributes());\n \n             // 10. replace entry with new entry\n-            formattingElements.add(pos, newEl);\n-            formattingElements.remove(pos + 1);\n+            formattingElements.set(pos, newEl);\n \n             // 11\n             if (pos == size-1) // if not last entry in list, jump to 7\n \n     void clearFormattingElementsToLastMarker() {\n         while (!formattingElements.isEmpty()) {\n-            Element el = formattingElements.peekLast();\n-            formattingElements.removeLast();\n+            Element el = removeLastFormattingElement();\n             if (el == null)\n                 break;\n         }\n     }\n \n     void removeFromActiveFormattingElements(Element el) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == el) {\n-                it.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     Element getActiveFormattingElement(String nodeName) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == null) // scope marker\n                 break;\n             else if (next.nodeName().equals(nodeName))\n     }\n \n     void insertInFosterParent(Node in) {\n-        Element fosterParent = null;\n+        Element fosterParent;\n         Element lastTable = getFromStack(\"table\");\n         boolean isLastTableParent = false;\n         if (lastTable != null) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n \n /**\n  * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n         }\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n-            tb.insert(\"html\");\n+            tb.insertStartTag(\"html\");\n             tb.transition(BeforeHead);\n             return tb.process(t);\n         }\n                 tb.setHeadElement(head);\n                 tb.transition(InHead);\n             } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             } else if (t.isEndTag()) {\n                 tb.error(this);\n                 return false;\n             } else {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             }\n             return true;\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            tb.process(new Token.EndTag(\"head\"));\n+            tb.processEndTag(\"head\");\n             return tb.process(t);\n         }\n     },\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            tb.process(new Token.EndTag(\"noscript\"));\n-            return tb.process(t);\n+            tb.insert(new Token.Character().data(t.toString()));\n+            return true;\n         }\n     },\n     AfterHead {\n         }\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n-            tb.process(new Token.StartTag(\"body\"));\n+            tb.processStartTag(\"body\");\n             tb.framesetOk(true);\n             return tb.process(t);\n         }\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n                     String name = startTag.name();\n-                    if (name.equals(\"html\")) {\n+                    if (name.equals(\"a\")) {\n+                        if (tb.getActiveFormattingElement(\"a\") != null) {\n+                            tb.error(this);\n+                            tb.processEndTag(\"a\");\n+\n+                            // still on stack?\n+                            Element remainingA = tb.getFromStack(\"a\");\n+                            if (remainingA != null) {\n+                                tb.removeFromActiveFormattingElements(remainingA);\n+                                tb.removeFromStack(remainingA);\n+                            }\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        Element a = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(a);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.processEndTag(\"p\");\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"span\")) {\n+                        // same as final else, but short circuits lots of checks\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"li\")) {\n+                        tb.framesetOk(false);\n+                        ArrayList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (el.nodeName().equals(\"li\")) {\n+                                tb.processEndTag(\"li\");\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.processEndTag(\"p\");\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"html\")) {\n                         tb.error(this);\n                         // merge attributes onto real html\n-                        Element html = tb.getStack().getFirst();\n+                        Element html = tb.getStack().get(0);\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         }\n                     } else if (name.equals(\"frameset\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                                 second.remove();\n                             // pop up to html element\n                             while (stack.size() > 1)\n-                                stack.removeLast();\n+                                stack.remove(stack.size()-1);\n                             tb.insert(startTag);\n                             tb.transition(InFrameset);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n+                        }\n+                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n+                            tb.error(this);\n+                            tb.pop();\n                         }\n                         tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.Headings)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n-                        }\n-                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n-                            tb.error(this);\n-                            tb.pop();\n-                        }\n-                        tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n-                        if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         // todo: ignore LF if next token\n                             return false;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertForm(startTag, true);\n-                    } else if (name.equals(\"li\")) {\n+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n-                            if (el.nodeName().equals(\"li\")) {\n-                                tb.process(new Token.EndTag(\"li\"));\n+                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n+                                tb.processEndTag(el.nodeName());\n                                 break;\n                             }\n-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n-                        }\n-                        tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.DdDt)) {\n-                        tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n-                        for (int i = stack.size() - 1; i > 0; i--) {\n-                            Element el = stack.get(i);\n-                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n-                                tb.process(new Token.EndTag(el.nodeName()));\n-                                break;\n-                            }\n-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n-                                break;\n-                        }\n-                        if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (name.equals(\"plaintext\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                         if (tb.inButtonScope(\"button\")) {\n                             // close and reprocess\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"button\"));\n+                            tb.processEndTag(\"button\");\n                             tb.process(startTag);\n                         } else {\n                             tb.reconstructFormattingElements();\n                             tb.insert(startTag);\n                             tb.framesetOk(false);\n                         }\n-                    } else if (name.equals(\"a\")) {\n-                        if (tb.getActiveFormattingElement(\"a\") != null) {\n-                            tb.error(this);\n-                            tb.process(new Token.EndTag(\"a\"));\n-\n-                            // still on stack?\n-                            Element remainingA = tb.getFromStack(\"a\");\n-                            if (remainingA != null) {\n-                                tb.removeFromActiveFormattingElements(remainingA);\n-                                tb.removeFromStack(remainingA);\n-                            }\n-                        }\n-                        tb.reconstructFormattingElements();\n-                        Element a = tb.insert(startTag);\n-                        tb.pushActiveFormattingElements(a);\n-                    } else if (StringUtil.in(name, Constants.Formatters)) {\n+                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                         tb.reconstructFormattingElements();\n                         Element el = tb.insert(startTag);\n                         tb.pushActiveFormattingElements(el);\n                         tb.reconstructFormattingElements();\n                         if (tb.inScope(\"nobr\")) {\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"nobr\"));\n+                            tb.processEndTag(\"nobr\");\n                             tb.reconstructFormattingElements();\n                         }\n                         Element el = tb.insert(startTag);\n                         tb.pushActiveFormattingElements(el);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n                         tb.insertMarkerToFormattingElements();\n                         tb.framesetOk(false);\n                     } else if (name.equals(\"table\")) {\n                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.framesetOk(false);\n                         tb.transition(InTable);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n-                        tb.reconstructFormattingElements();\n-                        tb.insertEmpty(startTag);\n-                        tb.framesetOk(false);\n                     } else if (name.equals(\"input\")) {\n                         tb.reconstructFormattingElements();\n                         Element el = tb.insertEmpty(startTag);\n                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                             tb.framesetOk(false);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                         tb.insertEmpty(startTag);\n                     } else if (name.equals(\"hr\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertEmpty(startTag);\n                         tb.framesetOk(false);\n                             return false;\n \n                         tb.tokeniser.acknowledgeSelfClosingFlag();\n-                        tb.process(new Token.StartTag(\"form\"));\n+                        tb.processStartTag(\"form\");\n                         if (startTag.attributes.hasKey(\"action\")) {\n                             Element form = tb.getFormElement();\n                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n                         }\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.StartTag(\"label\"));\n+                        tb.processStartTag(\"hr\");\n+                        tb.processStartTag(\"label\");\n                         // hope you like english.\n                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                 startTag.attributes.get(\"prompt\") :\n                                 \"This is a searchable index. Enter search keywords: \";\n \n-                        tb.process(new Token.Character(prompt));\n+                        tb.process(new Token.Character().data(prompt));\n \n                         // input\n                         Attributes inputAttribs = new Attributes();\n                         for (Attribute attr : startTag.attributes) {\n-                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n+                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                 inputAttribs.put(attr);\n                         }\n                         inputAttribs.put(\"name\", \"isindex\");\n-                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n-                        tb.process(new Token.EndTag(\"label\"));\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.EndTag(\"form\"));\n+                        tb.processStartTag(\"input\", inputAttribs);\n+                        tb.processEndTag(\"label\");\n+                        tb.processStartTag(\"hr\");\n+                        tb.processEndTag(\"form\");\n                     } else if (name.equals(\"textarea\")) {\n                         tb.insert(startTag);\n                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                         tb.transition(Text);\n                     } else if (name.equals(\"xmp\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.reconstructFormattingElements();\n                         tb.framesetOk(false);\n                             tb.transition(InSelectInTable);\n                         else\n                             tb.transition(InSelect);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                         if (tb.inScope(\"ruby\")) {\n                             tb.generateImpliedEndTags();\n                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                         tb.insert(startTag);\n                         tb.tokeniser.acknowledgeSelfClosingFlag();\n-                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                         tb.error(this);\n                         return false;\n                     } else {\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n                     name = endTag.name();\n-                    if (name.equals(\"body\")) {\n-                        if (!tb.inScope(\"body\")) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n-                            tb.transition(AfterBody);\n-                        }\n-                    } else if (name.equals(\"html\")) {\n-                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n-                        if (notIgnored)\n-                            return tb.process(endTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n-                        if (!tb.inScope(name)) {\n-                            // nothing to close\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (name.equals(\"form\")) {\n-                        Element currentForm = tb.getFormElement();\n-                        tb.setFormElement(null);\n-                        if (currentForm == null || !tb.inScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            // remove currentForm from stack. will shift anything under up.\n-                            tb.removeFromStack(currentForm);\n-                        }\n-                    } else if (name.equals(\"p\")) {\n-                        if (!tb.inButtonScope(name)) {\n-                            tb.error(this);\n-                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n-                            return tb.process(endTag);\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (name.equals(\"li\")) {\n-                        if (!tb.inListItemScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (StringUtil.in(name, Constants.DdDt)) {\n-                        if (!tb.inScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (StringUtil.in(name, Constants.Headings)) {\n-                        if (!tb.inScope(Constants.Headings)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(Constants.Headings);\n-                        }\n-                    } else if (name.equals(\"sarcasm\")) {\n-                        // *sigh*\n-                        return anyOtherEndTag(t, tb);\n-                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n+                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n-                        OUTER:\n                         for (int i = 0; i < 8; i++) {\n                             Element formatEl = tb.getActiveFormattingElement(name);\n                             if (formatEl == null)\n                             Element furthestBlock = null;\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n-                            LinkedList<Element> stack = tb.getStack();\n+                            ArrayList<Element> stack = tb.getStack();\n                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                             // run-aways\n                             final int stackSize = stack.size();\n                             // does that mean: int pos of format el in list?\n                             Element node = furthestBlock;\n                             Element lastNode = furthestBlock;\n-                            INNER:\n                             for (int j = 0; j < 3; j++) {\n                                 if (tb.onStack(node))\n                                     node = tb.aboveOnStack(node);\n                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                     tb.removeFromStack(node);\n-                                    continue INNER;\n+                                    continue;\n                                 } else if (node == formatEl)\n-                                    break INNER;\n+                                    break;\n \n                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                 tb.replaceActiveFormattingElement(node, replacement);\n                                 lastNode = node;\n                             }\n \n-                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n+                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                 if (lastNode.parent() != null)\n                                     lastNode.remove();\n                                 tb.insertInFosterParent(lastNode);\n                             tb.removeFromStack(formatEl);\n                             tb.insertOnStackAfter(furthestBlock, adopter);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n+                        if (!tb.inScope(name)) {\n+                            // nothing to close\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"span\")) {\n+                        // same as final fall through, but saves short circuit\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (name.equals(\"li\")) {\n+                        if (!tb.inListItemScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"body\")) {\n+                        if (!tb.inScope(\"body\")) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n+                            tb.transition(AfterBody);\n+                        }\n+                    } else if (name.equals(\"html\")) {\n+                        boolean notIgnored = tb.processEndTag(\"body\");\n+                        if (notIgnored)\n+                            return tb.process(endTag);\n+                    } else if (name.equals(\"form\")) {\n+                        Element currentForm = tb.getFormElement();\n+                        tb.setFormElement(null);\n+                        if (currentForm == null || !tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            // remove currentForm from stack. will shift anything under up.\n+                            tb.removeFromStack(currentForm);\n+                        }\n+                    } else if (name.equals(\"p\")) {\n+                        if (!tb.inButtonScope(name)) {\n+                            tb.error(this);\n+                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n+                            return tb.process(endTag);\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n+                        if (!tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n+                        if (!tb.inScope(Constants.Headings)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(Constants.Headings);\n+                        }\n+                    } else if (name.equals(\"sarcasm\")) {\n+                        // *sigh*\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                         if (!tb.inScope(\"name\")) {\n                             if (!tb.inScope(name)) {\n                                 tb.error(this);\n                         }\n                     } else if (name.equals(\"br\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"br\"));\n+                        tb.processStartTag(\"br\");\n                         return false;\n                     } else {\n                         return anyOtherEndTag(t, tb);\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n             String name = t.asEndTag().name();\n-            DescendableLinkedList<Element> stack = tb.getStack();\n-            Iterator<Element> it = stack.descendingIterator();\n-            while (it.hasNext()) {\n-                Element node = it.next();\n+            ArrayList<Element> stack = tb.getStack();\n+            for (int pos = stack.size() -1; pos >= 0; pos--) {\n+                Element node = stack.get(pos);\n                 if (node.nodeName().equals(name)) {\n                     tb.generateImpliedEndTags(name);\n                     if (!name.equals(tb.currentElement().nodeName()))\n                     tb.insert(startTag);\n                     tb.transition(InColumnGroup);\n                 } else if (name.equals(\"col\")) {\n-                    tb.process(new Token.StartTag(\"colgroup\"));\n+                    tb.processStartTag(\"colgroup\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                     tb.clearStackToTableContext();\n                     tb.insert(startTag);\n                     tb.transition(InTableBody);\n                 } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n-                    tb.process(new Token.StartTag(\"tbody\"));\n+                    tb.processStartTag(\"tbody\");\n                     return tb.process(t);\n                 } else if (name.equals(\"table\")) {\n                     tb.error(this);\n-                    boolean processed = tb.process(new Token.EndTag(\"table\"));\n+                    boolean processed = tb.processEndTag(\"table\");\n                     if (processed) // only ignored if in fragment\n                         return tb.process(t);\n                 } else if (StringUtil.in(name, \"style\", \"script\")) {\n \n         boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            boolean processed = true;\n+            boolean processed;\n             if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                 tb.setFosterInserts(true);\n                 processed = tb.process(t, InBody);\n                         tb.error(this);\n                         return false;\n                     } else {\n-                        tb.getPendingTableCharacters().add(c);\n+                        tb.getPendingTableCharacters().add(c.getData());\n                     }\n                     break;\n                 default:\n+                    // todo - don't really like the way these table character data lists are built\n                     if (tb.getPendingTableCharacters().size() > 0) {\n-                        for (Token.Character character : tb.getPendingTableCharacters()) {\n+                        for (String character : tb.getPendingTableCharacters()) {\n                             if (!isWhitespace(character)) {\n                                 // InTable anything else section:\n                                 tb.error(this);\n                                 if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                     tb.setFosterInserts(true);\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                     tb.setFosterInserts(false);\n                                 } else {\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                 }\n                             } else\n-                                tb.insert(character);\n+                                tb.insert(new Token.Character().data(character));\n                         }\n                         tb.newPendingTableCharacters();\n                     }\n                             t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n                     ) {\n                 tb.error(this);\n-                boolean processed = tb.process(new Token.EndTag(\"caption\"));\n+                boolean processed = tb.processEndTag(\"caption\");\n                 if (processed)\n                     return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"colgroup\"));\n+            boolean processed = tb.processEndTag(\"colgroup\");\n             if (processed) // only ignored in frag case\n                 return tb.process(t);\n             return true;\n                         tb.transition(InRow);\n                     } else if (StringUtil.in(name, \"th\", \"td\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"tr\"));\n+                        tb.processStartTag(\"tr\");\n                         return tb.process(startTag);\n                     } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                         return exitTableBody(t, tb);\n                 return false;\n             }\n             tb.clearStackToTableBodyContext();\n-            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead\n+            tb.processEndTag(tb.currentElement().nodeName()); // tbody, tfoot, thead\n             return tb.process(t);\n         }\n \n                         tb.error(this);\n                         return false;\n                     }\n-                    tb.process(new Token.EndTag(\"tr\"));\n+                    tb.processEndTag(\"tr\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                     tb.error(this);\n         }\n \n         private boolean handleMissingTr(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"tr\"));\n+            boolean processed = tb.processEndTag(\"tr\");\n             if (processed)\n                 return tb.process(t);\n             else\n \n         private void closeCell(HtmlTreeBuilder tb) {\n             if (tb.inTableScope(\"td\"))\n-                tb.process(new Token.EndTag(\"td\"));\n+                tb.processEndTag(\"td\");\n             else\n-                tb.process(new Token.EndTag(\"th\")); // only here if th or td in scope\n+                tb.processEndTag(\"th\"); // only here if th or td in scope\n         }\n     },\n     InSelect {\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n-                        tb.process(new Token.EndTag(\"option\"));\n+                        tb.processEndTag(\"option\");\n                         tb.insert(start);\n                     } else if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"optgroup\"));\n+                            tb.processEndTag(\"optgroup\");\n                         tb.insert(start);\n                     } else if (name.equals(\"select\")) {\n                         tb.error(this);\n-                        return tb.process(new Token.EndTag(\"select\"));\n+                        return tb.processEndTag(\"select\");\n                     } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                         tb.error(this);\n                         if (!tb.inSelectScope(\"select\"))\n                             return false; // frag\n-                        tb.process(new Token.EndTag(\"select\"));\n+                        tb.processEndTag(\"select\");\n                         return tb.process(start);\n                     } else if (name.equals(\"script\")) {\n                         return tb.process(t, InHead);\n                     name = end.name();\n                     if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                             tb.pop();\n                         else\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n-                tb.process(new Token.EndTag(\"select\"));\n+                tb.processEndTag(\"select\");\n                 return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n                 if (tb.inTableScope(t.asEndTag().name())) {\n-                    tb.process(new Token.EndTag(\"select\"));\n+                    tb.processEndTag(\"select\");\n                     return (tb.process(t));\n                 } else\n                     return false;\n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n             String data = t.asCharacter().getData();\n-            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n-            for (int i = 0; i < data.length(); i++) {\n-                char c = data.charAt(i);\n-                if (!StringUtil.isWhitespace(c))\n-                    return false;\n-            }\n-            return true;\n+            return isWhitespace(data);\n         }\n         return false;\n+    }\n+\n+    private static boolean isWhitespace(String data) {\n+        // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n+        for (int i = 0; i < data.length(); i++) {\n+            char c = data.charAt(i);\n+            if (!StringUtil.isWhitespace(c))\n+                return false;\n+        }\n+        return true;\n     }\n \n     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     \n     public Document parseInput(String html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        Document doc = treeBuilder.parse(html, baseUri, errors);\n-        return doc;\n+        return treeBuilder.parse(html, baseUri, errors);\n     }\n \n     // gets & sets\n         Element body = doc.body();\n         List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n         Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n+        for (int i = nodes.length - 1; i > 0; i--) {\n+            nodes[i].remove();\n+        }\n         for (Node node : nodes) {\n             body.appendChild(node);\n         }\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n     /**\n      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n-     * <p/>\n+     * <p>\n      * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n-     *\n+     * </p>\n+     * \n      * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n      * @return The tag, either defined or new generic.\n      */\n \n         Tag tag = (Tag) o;\n \n+        if (!tagName.equals(tag.tagName)) return false;\n         if (canContainBlock != tag.canContainBlock) return false;\n         if (canContainInline != tag.canContainInline) return false;\n         if (empty != tag.empty) return false;\n         if (preserveWhitespace != tag.preserveWhitespace) return false;\n         if (selfClosing != tag.selfClosing) return false;\n         if (formList != tag.formList) return false;\n-        if (formSubmit != tag.formSubmit) return false;\n-        if (!tagName.equals(tag.tagName)) return false;\n-\n-        return true;\n+        return formSubmit == tag.formSubmit;\n     }\n \n     @Override\n         return result;\n     }\n \n+    @Override\n     public String toString() {\n         return tagName;\n     }\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n             \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n-            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n+            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n+            \"svg\", \"math\"\n     };\n     private static final String[] inlineTags = {\n             \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n             \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n             \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n             \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n-            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\"\n+            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n+            \"data\", \"bdi\"\n     };\n     private static final String[] emptyTags = {\n             \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.BooleanAttribute;\n \n /**\n  * Parse tokens for the Tokeniser.\n         return this.getClass().getSimpleName();\n     }\n \n-    static class Doctype extends Token {\n+    /**\n+     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n+     * piece of data, which immediately get GCed.\n+     */\n+    abstract Token reset();\n+\n+    static void reset(StringBuilder sb) {\n+        if (sb != null) {\n+            sb.delete(0, sb.length());\n+        }\n+    }\n+\n+    static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n         final StringBuilder publicIdentifier = new StringBuilder();\n         final StringBuilder systemIdentifier = new StringBuilder();\n             type = TokenType.Doctype;\n         }\n \n+        @Override\n+        Token reset() {\n+            reset(name);\n+            reset(publicIdentifier);\n+            reset(systemIdentifier);\n+            forceQuirks = false;\n+            return this;\n+        }\n+\n         String getName() {\n             return name.toString();\n         }\n     static abstract class Tag extends Token {\n         protected String tagName;\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n-        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n-\n+        private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n+        private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n+        private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n         Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n \n-        void newAttribute() {\n+        @Override\n+        Tag reset() {\n+            tagName = null;\n+            pendingAttributeName = null;\n+            reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n+            hasEmptyAttributeValue = false;\n+            hasPendingAttributeValue = false;\n+            selfClosing = false;\n+            attributes = null;\n+            return this;\n+        }\n+\n+        final void newAttribute() {\n             if (attributes == null)\n                 attributes = new Attributes();\n \n             if (pendingAttributeName != null) {\n                 Attribute attribute;\n-                if (pendingAttributeValue == null)\n+                if (hasPendingAttributeValue)\n+                    attribute = new Attribute(pendingAttributeName,\n+                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                else if (hasEmptyAttributeValue)\n                     attribute = new Attribute(pendingAttributeName, \"\");\n                 else\n-                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n+                    attribute = new BooleanAttribute(pendingAttributeName);\n                 attributes.put(attribute);\n             }\n             pendingAttributeName = null;\n-            if (pendingAttributeValue != null)\n-                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n-        }\n-\n-        void finaliseTag() {\n+            hasEmptyAttributeValue = false;\n+            hasPendingAttributeValue = false;\n+            reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n+        }\n+\n+        final void finaliseTag() {\n             // finalises for emit\n             if (pendingAttributeName != null) {\n                 // todo: check if attribute name exists; if so, drop and error\n             }\n         }\n \n-        String name() {\n+        final String name() {\n             Validate.isFalse(tagName == null || tagName.length() == 0);\n             return tagName;\n         }\n \n-        Tag name(String name) {\n+        final Tag name(String name) {\n             tagName = name;\n             return this;\n         }\n \n-        boolean isSelfClosing() {\n+        final boolean isSelfClosing() {\n             return selfClosing;\n         }\n \n         @SuppressWarnings({\"TypeMayBeWeakened\"})\n-        Attributes getAttributes() {\n+        final Attributes getAttributes() {\n             return attributes;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n-        void appendTagName(String append) {\n+        final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n         }\n \n-        void appendTagName(char append) {\n+        final void appendTagName(char append) {\n             appendTagName(String.valueOf(append));\n         }\n \n-        void appendAttributeName(String append) {\n+        final void appendAttributeName(String append) {\n             pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n         }\n \n-        void appendAttributeName(char append) {\n+        final void appendAttributeName(char append) {\n             appendAttributeName(String.valueOf(append));\n         }\n \n-        void appendAttributeValue(String append) {\n+        final void appendAttributeValue(String append) {\n+            ensureAttributeValue();\n+            if (pendingAttributeValue.length() == 0) {\n+                pendingAttributeValueS = append;\n+            } else {\n+                pendingAttributeValue.append(append);\n+            }\n+        }\n+\n+        final void appendAttributeValue(char append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        void appendAttributeValue(char append) {\n+        final void appendAttributeValue(char[] append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n-\n-        void appendAttributeValue(char[] append) {\n-            ensureAttributeValue();\n-            pendingAttributeValue.append(append);\n-        }\n-\n-        private final void ensureAttributeValue() {\n-            if (pendingAttributeValue == null)\n-                pendingAttributeValue = new StringBuilder();\n-        }\n-    }\n-\n-    static class StartTag extends Tag {\n+        \n+        final void setEmptyAttributeValue() {\n+            hasEmptyAttributeValue = true;\n+        }\n+\n+        private void ensureAttributeValue() {\n+            hasPendingAttributeValue = true;\n+            // if on second hit, we'll need to move to the builder\n+            if (pendingAttributeValueS != null) {\n+                pendingAttributeValue.append(pendingAttributeValueS);\n+                pendingAttributeValueS = null;\n+            }\n+        }\n+    }\n+\n+    final static class StartTag extends Tag {\n         StartTag() {\n             super();\n             attributes = new Attributes();\n             type = TokenType.StartTag;\n         }\n \n-        StartTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n-        StartTag(String name, Attributes attributes) {\n-            this();\n+        @Override\n+        Tag reset() {\n+            super.reset();\n+            attributes = new Attributes();\n+            // todo - would prefer these to be null, but need to check Element assertions\n+            return this;\n+        }\n+\n+        StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n+            return this;\n         }\n \n         @Override\n         }\n     }\n \n-    static class EndTag extends Tag{\n+    final static class EndTag extends Tag{\n         EndTag() {\n             super();\n             type = TokenType.EndTag;\n         }\n \n-        EndTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n         @Override\n         public String toString() {\n             return \"</\" + name() + \">\";\n         }\n     }\n \n-    static class Comment extends Token {\n+    final static class Comment extends Token {\n         final StringBuilder data = new StringBuilder();\n         boolean bogus = false;\n \n+        @Override\n+        Token reset() {\n+            reset(data);\n+            bogus = false;\n+            return this;\n+        }\n+\n         Comment() {\n             type = TokenType.Comment;\n         }\n         }\n     }\n \n-    static class Character extends Token {\n-        private final String data;\n-\n-        Character(String data) {\n+    final static class Character extends Token {\n+        private String data;\n+\n+        Character() {\n+            super();\n             type = TokenType.Character;\n+        }\n+\n+        @Override\n+        Token reset() {\n+            data = null;\n+            return this;\n+        }\n+\n+        Character data(String data) {\n             this.data = data;\n+            return this;\n         }\n \n         String getData() {\n         }\n     }\n \n-    static class EOF extends Token {\n+    final static class EOF extends Token {\n         EOF() {\n             type = Token.TokenType.EOF;\n         }\n-    }\n-\n-    boolean isDoctype() {\n+\n+        @Override\n+        Token reset() {\n+            return this;\n+        }\n+    }\n+\n+    final boolean isDoctype() {\n         return type == TokenType.Doctype;\n     }\n \n-    Doctype asDoctype() {\n+    final Doctype asDoctype() {\n         return (Doctype) this;\n     }\n \n-    boolean isStartTag() {\n+    final boolean isStartTag() {\n         return type == TokenType.StartTag;\n     }\n \n-    StartTag asStartTag() {\n+    final StartTag asStartTag() {\n         return (StartTag) this;\n     }\n \n-    boolean isEndTag() {\n+    final boolean isEndTag() {\n         return type == TokenType.EndTag;\n     }\n \n-    EndTag asEndTag() {\n+    final EndTag asEndTag() {\n         return (EndTag) this;\n     }\n \n-    boolean isComment() {\n+    final boolean isComment() {\n         return type == TokenType.Comment;\n     }\n \n-    Comment asComment() {\n+    final Comment asComment() {\n         return (Comment) this;\n     }\n \n-    boolean isCharacter() {\n+    final boolean isCharacter() {\n         return type == TokenType.Character;\n     }\n \n-    Character asCharacter() {\n+    final Character asCharacter() {\n         return (Character) this;\n     }\n \n-    boolean isEOF() {\n+    final boolean isEOF() {\n         return type == TokenType.EOF;\n     }\n \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n                 pos++;\n         }\n \n-        String data = queue.substring(start, pos); \n-        return data; \n+        return queue.substring(start, pos);\n     }\n \n     /**\n             pos++;\n         }\n \n-        String data = queue.substring(start, pos); \n-        return data; \n+        return queue.substring(start, pos);\n     }\n \n     /**\n \n     /**\n      * Pulls the next run of whitespace characters of the queue.\n+     * @return Whether consuming whitespace or not\n      */\n     public boolean consumeWhitespace() {\n         boolean seen = false;\n         return remainder;\n     }\n     \n+    @Override\n     public String toString() {\n         return queue.substring(pos);\n     }\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Arrays;\n \n /**\n  * Readers the input stream into tokens.\n  */\n-class Tokeniser {\n+final class Tokeniser {\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n+    private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n+\n+    static {\n+        Arrays.sort(notCharRefCharsSorted);\n+    }\n \n     private CharacterReader reader; // html input\n     private ParseErrorList errors; // errors found while tokenising\n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private boolean isEmitPending = false;\n-    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n-    StringBuilder dataBuffer; // buffers data looking for </script>\n+    private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n+    private StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n+    StringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n \n     Token.Tag tagPending; // tag we are building up\n-    Token.Doctype doctypePending; // doctype building up\n-    Token.Comment commentPending; // comment building up\n-    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n+    Token.StartTag startPending = new Token.StartTag();\n+    Token.EndTag endPending = new Token.EndTag();\n+    Token.Character charPending = new Token.Character();\n+    Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n+    Token.Comment commentPending = new Token.Comment(); // comment building up\n+    private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n             state.read(this, reader);\n \n         // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n-        if (charBuffer.length() > 0) {\n-            String str = charBuffer.toString();\n-            charBuffer.delete(0, charBuffer.length());\n-            return new Token.Character(str);\n+        if (charsBuilder.length() > 0) {\n+            String str = charsBuilder.toString();\n+            charsBuilder.delete(0, charsBuilder.length());\n+            charsString = null;\n+            return charPending.data(str);\n+        } else if (charsString != null) {\n+            Token token = charPending.data(charsString);\n+            charsString = null;\n+            return token;\n         } else {\n             isEmitPending = false;\n             return emitPending;\n \n         if (token.type == Token.TokenType.StartTag) {\n             Token.StartTag startTag = (Token.StartTag) token;\n-            lastStartTag = startTag;\n+            lastStartTag = startTag.tagName;\n             if (startTag.selfClosing)\n                 selfClosingFlagAcknowledged = false;\n         } else if (token.type == Token.TokenType.EndTag) {\n         }\n     }\n \n-    void emit(String str) {\n+    void emit(final String str) {\n         // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n         // does not set isEmitPending; read checks that\n-        charBuffer.append(str);\n+        if (charsString == null) {\n+            charsString = str;\n+        }\n+        else {\n+            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n+                charsBuilder.append(charsString);\n+            }\n+            charsBuilder.append(str);\n+        }\n     }\n \n     void emit(char[] chars) {\n-        charBuffer.append(chars);\n+        emit(String.valueOf(chars));\n     }\n \n     void emit(char c) {\n-        charBuffer.append(c);\n+        emit(String.valueOf(c));\n     }\n \n     TokeniserState getState() {\n         selfClosingFlagAcknowledged = true;\n     }\n \n+    final private char[] charRefHolder = new char[1]; // holder to not have to keep creating arrays\n     char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             return null;\n-        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n-            return null;\n-\n+        if (reader.matchesAnySorted(notCharRefCharsSorted))\n+            return null;\n+\n+        final char[] charRef = charRefHolder;\n         reader.mark();\n         if (reader.matchConsume(\"#\")) { // numbered\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return new char[]{replacementChar};\n+                charRef[0] = replacementChar;\n+                return charRef;\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n+                if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+                    charRef[0] = (char) charval;\n+                    return charRef;\n+                } else\n                 return Character.toChars(charval);\n             }\n         } else { // named\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return new char[]{Entities.getCharacterByName(nameRef)};\n+            charRef[0] = Entities.getCharacterByName(nameRef);\n+            return charRef;\n         }\n     }\n \n     Token.Tag createTagPending(boolean start) {\n-        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n+        tagPending = start ? startPending.reset() : endPending.reset();\n         return tagPending;\n     }\n \n     }\n \n     void createCommentPending() {\n-        commentPending = new Token.Comment();\n+        commentPending.reset();\n     }\n \n     void emitCommentPending() {\n     }\n \n     void createDoctypePending() {\n-        doctypePending = new Token.Doctype();\n+        doctypePending.reset();\n     }\n \n     void emitDoctypePending() {\n     }\n \n     void createTempBuffer() {\n-        dataBuffer = new StringBuilder();\n+        Token.reset(dataBuffer);\n     }\n \n     boolean isAppropriateEndTagToken() {\n-        if (lastStartTag == null)\n-            return false;\n-        return tagPending.tagName.equals(lastStartTag.tagName);\n+        return lastStartTag != null && tagPending.tagName.equals(lastStartTag);\n     }\n \n     String appropriateEndTagName() {\n         if (lastStartTag == null)\n             return null;\n-        return lastStartTag.tagName;\n+        return lastStartTag;\n     }\n \n     void error(TokeniserState state) {\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n package org.jsoup.parser;\n+\n+import java.util.Arrays;\n \n /**\n  * States and transition activations for the Tokeniser.\n                     t.emit(new Token.EOF());\n                     break;\n                 default:\n-                    String data = r.consumeToAny('&', '<', nullChar);\n+                    String data = r.consumeData();\n                     t.emit(data);\n                     break;\n             }\n         // from < or </ in data, will have start or end tag pending\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n-            String tagName = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n+            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+            String tagName = r.consumeTagName().toLowerCase();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n             } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                 // consuming to EOF; break out here\n-                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n+                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                 t.emitTagPending();\n                 r.unconsume(); // undo \"<\"\n                 t.transition(Data);\n     AttributeName {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n-            String name = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<');\n+            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n             t.tagPending.appendAttributeName(name.toLowerCase());\n \n             char c = r.consume();\n                     break;\n                 case eof:\n                     t.eofError(this);\n+                    t.emitTagPending();\n                     t.transition(Data);\n                     break;\n                 case '>':\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\"', '&', nullChar);\n+            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n+            else\n+                t.tagPending.setEmptyAttributeValue();\n \n             char c = r.consume();\n             switch (c) {\n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\'', '&', nullChar);\n+            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n+            else\n+                t.tagPending.setEmptyAttributeValue();\n \n             char c = r.consume();\n             switch (c) {\n     },\n     AttributeValue_unquoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n+            String value = r.consumeToAnySorted(attributeValueUnquoted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n \n     abstract void read(Tokeniser t, CharacterReader r);\n \n-    private static final char nullChar = '\\u0000';\n+    static final char nullChar = '\\u0000';\n+    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n+    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n+    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+    private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'};\n+\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n+\n+    static {\n+        Arrays.sort(attributeSingleValueCharsSorted);\n+        Arrays.sort(attributeDoubleValueCharsSorted);\n+        Arrays.sort(attributeNameCharsSorted);\n+        Arrays.sort(attributeValueUnquoted);\n+    }\n \n     /**\n      * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n      * different else exit transitions.\n      */\n-    private static final void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n+    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.tagPending.appendTagName(name.toLowerCase());\n         }\n     }\n \n-    private static final void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n+    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.dataBuffer.append(name.toLowerCase());\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n     CharacterReader reader;\n     Tokeniser tokeniser;\n     protected Document doc; // current doc we are building into\n-    protected DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected ArrayList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n+\n+    private Token.StartTag start = new Token.StartTag(); // start tag to process\n+    private Token.EndTag end  = new Token.EndTag();\n \n     protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n         Validate.notNull(input, \"String input must not be null\");\n         reader = new CharacterReader(input);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new DescendableLinkedList<Element>();\n+        stack = new ArrayList<Element>(32);\n         this.baseUri = baseUri;\n     }\n \n         while (true) {\n             Token token = tokeniser.read();\n             process(token);\n+            token.reset();\n \n             if (token.type == Token.TokenType.EOF)\n                 break;\n \n     protected abstract boolean process(Token token);\n \n+    protected boolean processStartTag(String name) {\n+        if (currentToken == start) { // don't recycle an in-use token\n+            return process(new Token.StartTag().name(name));\n+        }\n+        return process(start.reset().name(name));\n+    }\n+\n+    public boolean processStartTag(String name, Attributes attrs) {\n+        if (currentToken == start) { // don't recycle an in-use token\n+            return process(new Token.StartTag().nameAttr(name, attrs));\n+        }\n+        start.reset();\n+        start.nameAttr(name, attrs);\n+        return process(start);\n+    }\n+\n+    protected boolean processEndTag(String name) {\n+        if (currentToken == end) { // don't recycle an in-use token\n+            return process(new Token.EndTag().name(name));\n+        }\n+        return process(end.reset().name(name));\n+    }\n+\n+\n     protected Element currentElement() {\n-        return stack.getLast();\n+        int size = stack.size();\n+        return size > 0 ? stack.get(size-1) : null;\n     }\n }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n import java.util.List;\n \n /**\n         String elName = endTag.name();\n         Element firstFound = null;\n \n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 firstFound = next;\n                 break;\n         if (firstFound == null)\n             return; // not found, skip\n \n-        it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == firstFound) {\n-                it.remove();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next == firstFound)\n                 break;\n-            } else {\n-                it.remove();\n-            }\n         }\n     }\n \n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.util.List;\n \n /**\n  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n  that you are expecting; no junk, and no cross-site scripting attacks!\n- <p/>\n+ <p>\n  The HTML cleaner parses the input as HTML and then runs it through a white-list, so the output HTML can only contain\n  HTML that is allowed by the whitelist.\n- <p/>\n+ </p>\n+ <p>\n  It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the\n  canned white-lists only allow body contained tags.\n- <p/>\n+ </p>\n+ <p>\n  Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.\n+ </p>\n  */\n public class Cleaner {\n     private Whitelist whitelist;\n     /**\n      Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n      in the input HTML are allowed by the whitelist.\n-     <p/>\n+     <p>\n      This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n      using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n      to ensure enforced attributes are set correctly, and that the output is tidied.\n+     </p>\n      @param dirtyDocument document to test\n      @return true if no tags or attributes need to be removed; false if they do\n      */\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n \n /**\n  Whitelists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.\n- <p/>\n+ <p>\n  Start with one of the defaults:\n+ </p>\n  <ul>\n  <li>{@link #none}\n  <li>{@link #simpleText}\n  <li>{@link #basicWithImages}\n  <li>{@link #relaxed}\n  </ul>\n- <p/>\n+ <p>\n  If you need to allow more through (please be careful!), tweak a base whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #addTags}\n  <li>{@link #addAttributes}\n  <li>{@link #addEnforcedAttribute}\n  <li>{@link #addProtocols}\n  </ul>\n- <p/>\n+ <p>\n  You can remove any setting from an existing whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #removeTags}\n  <li>{@link #removeAttributes}\n  <li>{@link #removeEnforcedAttribute}\n  <li>{@link #removeProtocols}\n  </ul>\n- <p/>\n+ \n+ <p>\n  The cleaner and these whitelists assume that you want to clean a <code>body</code> fragment of HTML (to add user\n  supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the\n  document HTML around the cleaned body HTML, or create a whitelist that allows <code>html</code> and <code>head</code>\n  elements as appropriate.\n- <p/>\n+ </p>\n+ <p>\n  If you are going to extend a whitelist, please be very careful. Make sure you understand what attributes may lead to\n  XSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See \n  http://ha.ckers.org/xss.html for some XSS attack examples.\n+ </p>\n \n  @author Jonathan Hedley\n  */\n     }\n \n     /**\n+     <p>\n      This whitelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\n      ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n-     <p/>\n+     </p>\n+     <p>\n      Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n      <code>rel=nofollow</code> attribute.\n-     <p/>\n+     </p>\n+     <p>\n      Does not allow images.\n+     </p>\n \n      @return whitelist\n      */\n      This whitelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\n      code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\n      sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n-     <p/>\n+     <p>\n      Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n+     </p>\n \n      @return whitelist\n      */\n \n     /**\n      Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n      on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>addAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n      @param keys List of valid attributes for the tag\n \n     /**\n      Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n      attributes on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>removeAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for.\n      @param keys List of invalid attributes for the tag\n     /**\n      Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n      already has the attribute set, it will be overridden.\n-     <p/>\n+     <p>\n      E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n-     <code>&lt;a href=\"...\" rel=\"nofollow\"></code>\n+     <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n+     </p>\n \n      @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n      @param key   The attribute key\n      * Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute\n      * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\n      * e.g. {@code http://}.\n-     * <p />\n+     * <p>\n      * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when\n      * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\n      * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\n      * will be removed.\n+     * </p>\n      *\n      * @param preserve {@code true} to allow relative links, {@code false} (default) to deny\n      * @return this Whitelist, for chaining.\n     /**\n      Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\n      URLs with the defined protocol.\n-     <p/>\n+     <p>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n-     <p/>\n+     </p>\n+     <p>\n      To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n \n     /**\n      Remove allowed URL protocols for an element's URL attribute.\n-     <p/>\n+     <p>\n      E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.List;\n \n /**\n  * Base combining (and, or) evaluator.\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n \n /**\n  A list of {@link Element}s, with methods that act on every element in the list.\n- <p/>\n+ <p>\n  To get an {@code Elements} object, use the {@link Element#select(String)} method.\n+ </p>\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Elements implements List<Element>, Cloneable {\n-    private List<Element> contents;\n-\n+public class Elements extends ArrayList<Element> {\n     public Elements() {\n-        contents = new ArrayList<Element>();\n     }\n \n     public Elements(int initialCapacity) {\n-        contents = new ArrayList<Element>(initialCapacity);\n+        super(initialCapacity);\n     }\n \n     public Elements(Collection<Element> elements) {\n-        contents = new ArrayList<Element>(elements);\n+        super(elements);\n     }\n     \n     public Elements(List<Element> elements) {\n-        contents = elements;\n+        super(elements);\n     }\n     \n     public Elements(Element... elements) {\n-        this(Arrays.asList(elements));\n+    \tsuper(Arrays.asList(elements));\n     }\n \n     /**\n      */\n     @Override\n \tpublic Elements clone() {\n-        Elements clone;\n-        try {\n-            clone = (Elements) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new RuntimeException(e);\n-        }\n-    \tList<Element> elements = new ArrayList<Element>();\n-        clone.contents = elements;\n-    \t\n-    \tfor(Element e : contents)\n-    \t\telements.add(e.clone());\n-\t\t\n+        Elements clone = new Elements(size());\n+\n+        for(Element e : this)\n+    \t\tclone.add(e.clone());\n     \t\n     \treturn clone;\n \t}\n      @see #hasAttr(String)\n      */\n     public String attr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return element.attr(attributeKey);\n         }\n      @return true if any of the elements have the attribute; false if none do.\n      */\n     public boolean hasAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return true;\n         }\n      * @return this\n      */\n     public Elements attr(String attributeKey, String attributeValue) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.attr(attributeKey, attributeValue);\n         }\n         return this;\n      * @return this (for chaining)\n      */\n     public Elements removeAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeAttr(attributeKey);\n         }\n         return this;\n      @return this\n      */\n     public Elements addClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.addClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements removeClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements toggleClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.toggleClass(className);\n         }\n         return this;\n      @return true if any do, false if none do\n      */\n     public boolean hasClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasClass(className))\n                 return true;\n         }\n      * @return this (for chaining)\n      */\n     public Elements val(String value) {\n-        for (Element element : contents)\n+        for (Element element : this)\n             element.val(value);\n         return this;\n     }\n      */\n     public String text() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\" \");\n             sb.append(element.text());\n     }\n \n     public boolean hasText() {\n-        for (Element element: contents) {\n+        for (Element element: this) {\n             if (element.hasText())\n                 return true;\n         }\n      */\n     public String html() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.html());\n      */\n     public String outerHtml() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.outerHtml());\n      * @see #text()\n      * @see #html()\n      */\n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n      * @see Element#tagName(String)\n      */\n     public Elements tagName(String tagName) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.tagName(tagName);\n         }\n         return this;\n      * @see Element#html(String)\n      */\n     public Elements html(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.html(html);\n         }\n         return this;\n      * @see Element#prepend(String)\n      */\n     public Elements prepend(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.prepend(html);\n         }\n         return this;\n      * @see Element#append(String)\n      */\n     public Elements append(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.append(html);\n         }\n         return this;\n      * @see Element#before(String)\n      */\n     public Elements before(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.before(html);\n         }\n         return this;\n      * @see Element#after(String)\n      */\n     public Elements after(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.after(html);\n         }\n         return this;\n      */\n     public Elements wrap(String html) {\n         Validate.notEmpty(html);\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.wrap(html);\n         }\n         return this;\n     /**\n      * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of\n      * dropping the elements but keeping their children.\n-     * <p/>\n+     * <p>\n      * This is useful for e.g removing unwanted formatting elements but keeping their contents.\n-     * <p/>\n-     * E.g. with HTML: {@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}<br/>\n-     * {@code doc.select(\"font\").unwrap();}<br/>\n-     * HTML = {@code <div>One <a href=\"/\">Two</a></div>}\n+     * </p>\n+     * \n+     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n+     * <p>{@code doc.select(\"font\").unwrap();}</p>\n+     * <p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n      *\n      * @return this (for chaining)\n      * @see Node#unwrap\n      */\n     public Elements unwrap() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.unwrap();\n         }\n         return this;\n      * @see #remove()\n      */\n     public Elements empty() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.empty();\n         }\n         return this;\n      * @see #empty()\n      */\n     public Elements remove() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.remove();\n         }\n         return this;\n      * @return Elements containing only the specified element, or, if that element did not exist, an empty list.\n      */\n     public Elements eq(int index) {\n-        return contents.size() > index ? new Elements(get(index)) : new Elements();\n+        return size() > index ? new Elements(get(index)) : new Elements();\n     }\n     \n     /**\n      */\n     public Elements parents() {\n         HashSet<Element> combo = new LinkedHashSet<Element>();\n-        for (Element e: contents) {\n+        for (Element e: this) {\n             combo.addAll(e.parents());\n         }\n         return new Elements(combo);\n      @return The first matched element, or <code>null</code> if contents is empty.\n      */\n     public Element first() {\n-        return contents.isEmpty() ? null : contents.get(0);\n+        return isEmpty() ? null : get(0);\n     }\n \n     /**\n      @return The last matched element, or <code>null</code> if contents is empty.\n      */\n     public Element last() {\n-        return contents.isEmpty() ? null : contents.get(contents.size() - 1);\n+        return isEmpty() ? null : get(size() - 1);\n     }\n \n     /**\n     public Elements traverse(NodeVisitor nodeVisitor) {\n         Validate.notNull(nodeVisitor);\n         NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n-        for (Element el: contents) {\n+        for (Element el: this) {\n             traversor.traverse(el);\n         }\n         return this;\n      */\n     public List<FormElement> forms() {\n         ArrayList<FormElement> forms = new ArrayList<FormElement>();\n-        for (Element el: contents)\n+        for (Element el: this)\n             if (el instanceof FormElement)\n                 forms.add((FormElement) el);\n         return forms;\n     }\n \n-    // implements List<Element> delegates:\n-    public int size() {return contents.size();}\n-\n-    public boolean isEmpty() {return contents.isEmpty();}\n-\n-    public boolean contains(Object o) {return contents.contains(o);}\n-\n-    public Iterator<Element> iterator() {return contents.iterator();}\n-\n-    public Object[] toArray() {return contents.toArray();}\n-\n-    public <T> T[] toArray(T[] a) {return contents.toArray(a);}\n-\n-    public boolean add(Element element) {return contents.add(element);}\n-\n-    public boolean remove(Object o) {return contents.remove(o);}\n-\n-    public boolean containsAll(Collection<?> c) {return contents.containsAll(c);}\n-\n-    public boolean addAll(Collection<? extends Element> c) {return contents.addAll(c);}\n-\n-    public boolean addAll(int index, Collection<? extends Element> c) {return contents.addAll(index, c);}\n-\n-    public boolean removeAll(Collection<?> c) {return contents.removeAll(c);}\n-\n-    public boolean retainAll(Collection<?> c) {return contents.retainAll(c);}\n-\n-    public void clear() {contents.clear();}\n-\n-    public boolean equals(Object o) {return contents.equals(o);}\n-\n-    public int hashCode() {return contents.hashCode();}\n-\n-    public Element get(int index) {return contents.get(index);}\n-\n-    public Element set(int index, Element element) {return contents.set(index, element);}\n-\n-    public void add(int index, Element element) {contents.add(index, element);}\n-\n-    public Element remove(int index) {return contents.remove(index);}\n-\n-    public int indexOf(Object o) {return contents.indexOf(o);}\n-\n-    public int lastIndexOf(Object o) {return contents.lastIndexOf(o);}\n-\n-    public ListIterator<Element> listIterator() {return contents.listIterator();}\n-\n-    public ListIterator<Element> listIterator(int index) {return contents.listIterator(index);}\n-\n-    public List<Element> subList(int fromIndex, int toIndex) {return contents.subList(fromIndex, toIndex);}\n }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n      *\n      * @param root    Root of the matching subtree\n      * @param element tested element\n+     * @return Returns <tt>true</tt> if the requirements are met or\n+     * <tt>false</tt> otherwise\n      */\n     public abstract boolean matches(Element root, Element element);\n \n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));\n+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n         }\n \n         @Override\n             Validate.notEmpty(value);\n \n             this.key = key.trim().toLowerCase();\n-            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n+            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")\n+                    || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n                 value = value.substring(1, value.length()-1);\n             }\n             this.value = value.trim().toLowerCase();\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e < idx)\n+     * Evaluator for matching by sibling index number (e {@literal <} idx)\n      */\n     public static final class IndexLessThan extends IndexEvaluator {\n         public IndexLessThan(int index) {\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e > idx)\n+     * Evaluator for matching by sibling index number (e {@literal >} idx)\n      */\n     public static final class IndexGreaterThan extends IndexEvaluator {\n         public IndexGreaterThan(int index) {\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n \n /**\n  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.\n- * <p/>\n+ * <p>\n  * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.\n+ * </p>\n  */\n public class NodeTraversor {\n     private NodeVisitor visitor;\n--- a/src/main/java/org/jsoup/select/NodeVisitor.java\n+++ b/src/main/java/org/jsoup/select/NodeVisitor.java\n \n /**\n  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.\n- * <p/>\n+ * <p>\n  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first\n  * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to\n  * create a start tag for a node, and tail to create the end tag.\n+ * </p>\n  */\n public interface NodeVisitor {\n     /**\n      * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n      * of that will have depth 1.\n      */\n-    public void head(Node node, int depth);\n+    void head(Node node, int depth);\n \n     /**\n      * Callback for when a node is last visited, after all of its descendants have been visited.\n      * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node\n      * of that will have depth 1.\n      */\n-    public void tail(Node node, int depth);\n+    void tail(Node node, int depth);\n }\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Element;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.LinkedHashSet;\n+import java.util.IdentityHashMap;\n \n /**\n  * CSS-like element selector, that finds elements matching a query.\n- * <p/>\n+ * \n  * <h2>Selector syntax</h2>\n+ * <p>\n  * A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against\n  * elements, attributes, and attribute values).\n- * <p/>\n+ * </p>\n+ * <p>\n  * The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n  * is equivalent).\n- * <p/>\n- * <table>\n+ * </p>\n+ * <table summary=\"\">\n  * <tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n- * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n+ * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  * <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>span[hello=\"Cleveland\"][goodbye=\"Columbus\"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>\n- * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n+ * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></td></tr>\n  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  * <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n- * <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n+ * <tr><td><code>E {@literal >} F</code></td><td>an F direct child of E</td><td><code>ol {@literal >} li</code></td></tr>\n  * <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  * <tr><td><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n- * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 2 cells of each row</td></tr>\n+ * <tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 3 cells of each row</td></tr>\n  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<p><code>div:not(:has(div))</code> finds divs that do not contain divs.</p></td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n  * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n  * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n- * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div > p:first-child</code></td></tr>\n- * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol > li:last-child</code></td></tr>\n+ * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div {@literal >} p:first-child</code></td></tr>\n+ * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>\n  * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n- * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr > td:last-of-type</code></td></tr>\n+ * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>\n  * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>\n  * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>\n  * </table>\n- *\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  * @see Element#select(String)\n  */\n         this.root = root;\n     }\n \n+    private Selector(Evaluator evaluator, Element root) {\n+        Validate.notNull(evaluator);\n+        Validate.notNull(root);\n+\n+        this.evaluator = evaluator;\n+        this.root = root;\n+    }\n+\n     /**\n      * Find elements matching selector.\n      *\n      * @param query CSS selector\n      * @param root  root element to descend into\n-     * @return matching elements, empty if not\n+     * @return matching elements, empty if none\n+     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n      */\n     public static Elements select(String query, Element root) {\n         return new Selector(query, root).select();\n     /**\n      * Find elements matching selector.\n      *\n+     * @param evaluator CSS selector\n+     * @param root root element to descend into\n+     * @return matching elements, empty if none\n+     */\n+    public static Elements select(Evaluator evaluator, Element root) {\n+        return new Selector(evaluator, root).select();\n+    }\n+\n+    /**\n+     * Find elements matching selector.\n+     *\n      * @param query CSS selector\n      * @param roots root elements to descend into\n-     * @return matching elements, empty if not\n+     * @return matching elements, empty if none\n      */\n     public static Elements select(String query, Iterable<Element> roots) {\n         Validate.notEmpty(query);\n         Validate.notNull(roots);\n-        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n+        Evaluator evaluator = QueryParser.parse(query);\n+        ArrayList<Element> elements = new ArrayList<Element>();\n+        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<Element, Boolean>();\n+        // dedupe elements by identity, not equality\n \n         for (Element root : roots) {\n-            elements.addAll(select(query, root));\n+            final Elements found = select(evaluator, root);\n+            for (Element el : found) {\n+                if (!seenElements.containsKey(el)) {\n+                    elements.add(el);\n+                    seenElements.put(el, Boolean.TRUE);\n+                }\n+            }\n         }\n         return new Elements(elements);\n     }\n--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":has(%s)\", evaluator);\n         }\n             return !evaluator.matches(root, node);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":not%s\", evaluator);\n         }\n                 return false;\n \n             Element parent = element.parent();\n-            while (parent != root) {\n+            while (true) {\n                 if (evaluator.matches(root, parent))\n                     return true;\n+                if (parent == root)\n+                    break;\n                 parent = parent.parent();\n             }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":parent%s\", evaluator);\n         }\n             return parent != null && evaluator.matches(root, parent);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":ImmediateParent%s\", evaluator);\n         }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev*%s\", evaluator);\n         }\n             return prev != null && evaluator.matches(root, prev);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev%s\", evaluator);\n         }\n--- a/src/test/java/org/jsoup/TextUtil.java\n+++ b/src/test/java/org/jsoup/TextUtil.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TextUtil {\n+    public static final String LE = String.format(\"%n\");\n+\n     public static String stripNewlines(String text) {\n         text = text.replaceAll(\"\\\\n\\\\s*\", \"\");\n         return text;\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n package org.jsoup.helper;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.junit.Test;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.jsoup.integration.ParseTest.getFile;\n+import static org.junit.Assert.*;\n \n public class DataUtilTest {\n     @Test\n         assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=$HJKDF\u00a7$/(\"));\n     }\n \n+    @Test\n+    public void generatesMimeBoundaries() {\n+        String m1 = DataUtil.mimeBoundary();\n+        String m2 = DataUtil.mimeBoundary();\n+\n+        assertEquals(DataUtil.boundaryLength, m1.length());\n+        assertEquals(DataUtil.boundaryLength, m2.length());\n+        assertNotSame(m1, m2);\n+    }\n+    \n+    @Test\n+    public void wrongMetaCharsetFallback() {\n+        try {\n+            final byte[] input = \"<html><head><meta charset=iso-8></head><body></body></html>\".getBytes(\"UTF-8\");\n+            final ByteBuffer inBuffer = ByteBuffer.wrap(input);\n+            \n+            Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n+            \n+            final String expected = \"<html>\\n\" +\n+                                    \" <head>\\n\" +\n+                                    \"  <meta charset=\\\"iso-8\\\">\\n\" +\n+                                    \" </head>\\n\" +\n+                                    \" <body></body>\\n\" +\n+                                    \"</html>\";\n+            \n+            assertEquals(expected, doc.toString());\n+        } catch( UnsupportedEncodingException ex ) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void supportsBOMinFiles() throws IOException {\n+        // test files from http://www.i18nl10n.com/korean/utftest/\n+        File in = getFile(\"/bomtests/bom_utf16be.html\");\n+        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-16BE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf16le.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-16LE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf32be.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-32BE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf32le.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-32LE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n package org.jsoup.helper;\n \n import static org.junit.Assert.*;\n+\n+import org.jsoup.integration.ParseTest;\n import org.junit.Test;\n import org.jsoup.Connection;\n \n         res.header(\"accept-encoding\", \"deflate\");\n         assertEquals(\"deflate\", res.header(\"Accept-Encoding\"));\n         assertEquals(\"deflate\", res.header(\"accept-Encoding\"));\n+    }\n+\n+    @Test public void sameHeadersCombineWithComma() {\n+        Map<String, List<String>> headers = new HashMap<String, List<String>>();\n+        List<String> values = new ArrayList<String>();\n+        values.add(\"no-cache\");\n+        values.add(\"no-store\");\n+        headers.put(\"Cache-Control\", values);\n+        HttpConnection.Response res = new HttpConnection.Response();\n+        res.processResponseHeaders(headers);\n+        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));\n     }\n \n     @Test public void ignoresEmptySetCookies() {\n         con.cookie(\"Name\", \"Val\");\n         assertEquals(\"Val\", con.request().cookie(\"Name\"));\n     }\n-}\n+\n+    @Test public void inputStream() {\n+        Connection.KeyVal kv = HttpConnection.KeyVal.create(\"file\", \"thumb.jpg\", ParseTest.inputStreamFrom(\"Check\"));\n+        assertEquals(\"file\", kv.key());\n+        assertEquals(\"thumb.jpg\", kv.value());\n+        assertTrue(kv.hasInputStream());\n+\n+        kv = HttpConnection.KeyVal.create(\"one\", \"two\");\n+        assertEquals(\"one\", kv.key());\n+        assertEquals(\"two\", kv.value());\n+        assertFalse(kv.hasInputStream());\n+    }\n+}\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n \n import java.util.Arrays;\n \n+import static org.jsoup.helper.StringUtil.*;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n public class StringUtilTest {\n \n     @Test public void join() {\n-        assertEquals(\"\", StringUtil.join(Arrays.<String>asList(\"\"), \" \"));\n-        assertEquals(\"one\", StringUtil.join(Arrays.<String>asList(\"one\"), \" \"));\n-        assertEquals(\"one two three\", StringUtil.join(Arrays.<String>asList(\"one\", \"two\", \"three\"), \" \"));\n+        assertEquals(\"\", StringUtil.join(Arrays.asList(\"\"), \" \"));\n+        assertEquals(\"one\", StringUtil.join(Arrays.asList(\"one\"), \" \"));\n+        assertEquals(\"one two three\", StringUtil.join(Arrays.asList(\"one\", \"two\", \"three\"), \" \"));\n     }\n \n     @Test public void padding() {\n     }\n \n     @Test public void normaliseWhiteSpace() {\n-        assertEquals(\" \", StringUtil.normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n-        assertEquals(\" hello there \", StringUtil.normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n-        assertEquals(\"hello\", StringUtil.normaliseWhitespace(\"hello\"));\n-        assertEquals(\"hello there\", StringUtil.normaliseWhitespace(\"hello\\nthere\"));\n+        assertEquals(\" \", normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n+        assertEquals(\" hello there \", normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n+        assertEquals(\"hello\", normaliseWhitespace(\"hello\"));\n+        assertEquals(\"hello there\", normaliseWhitespace(\"hello\\nthere\"));\n     }\n \n     @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {\n         String test71540chars = \"\\ud869\\udeb2\\u304b\\u309a  1\";\n         String test71540charsExpectedSingleWhitespace = \"\\ud869\\udeb2\\u304b\\u309a 1\";\n \n-        assertEquals(test71540charsExpectedSingleWhitespace, StringUtil.normaliseWhitespace(test71540chars));\n+        assertEquals(test71540charsExpectedSingleWhitespace, normaliseWhitespace(test71540chars));\n         String extractedText = Jsoup.parse(test71540chars).text();\n         assertEquals(test71540charsExpectedSingleWhitespace, extractedText);\n     }\n+\n+    @Test public void resolvesRelativeUrls() {\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com?one\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three#four\", resolve(\"http://example.com\", \"./one/two?three#four\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"http://example.com/\", \"https://example.com/one\"));\n+        assertEquals(\"http://example.com/one/two.html\", resolve(\"http://example.com/two/\", \"../one/two.html\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"https://example.com/\", \"//example2.com/one\"));\n+        assertEquals(\"https://example.com:8080/one\", resolve(\"https://example.com:8080\", \"./one\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"http://example.com/\", \"https://example2.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"wrong\", \"https://example.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"https://example.com/one\", \"\"));\n+        assertEquals(\"\", resolve(\"wrong\", \"also wrong\"));\n+        assertEquals(\"ftp://example.com/one\", resolve(\"ftp://example.com/two/\", \"../one\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"./two.c\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"two.c\"));\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n+package org.jsoup.helper;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.integration.ParseTest;\n+import org.junit.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import static org.jsoup.TextUtil.LE;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class W3CDomTest {\n+    @Test\n+    public void simpleConversion() {\n+        String html = \"<html><head><title>W3c</title></head><body><p class='one' id=12>Text</p><!-- comment --><invalid>What<script>alert('!')\";\n+        org.jsoup.nodes.Document doc = Jsoup.parse(html);\n+\n+        W3CDom w3c = new W3CDom();\n+        Document wDoc = w3c.fromJsoup(doc);\n+        String out = w3c.asString(wDoc);\n+        assertEquals(\n+                \"<html>\" + LE +\n+                        \"<head>\" + LE +\n+                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\" + LE +\n+                        \"<title>W3c</title>\" + LE +\n+                        \"</head>\" + LE +\n+                        \"<body>\" + LE +\n+                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\" + LE +\n+                        \"<!-- comment -->\" + LE +\n+                        \"<invalid>What<script>alert('!')</script>\" + LE +\n+                        \"</invalid>\" + LE +\n+                        \"</body>\" + LE +\n+                        \"</html>\" + LE\n+                , out);\n+    }\n+\n+    @Test\n+    public void convertsGoogle() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n+        org.jsoup.nodes.Document doc = Jsoup.parse(in, \"UTF8\");\n+\n+        W3CDom w3c = new W3CDom();\n+        Document wDoc = w3c.fromJsoup(doc);\n+        Node htmlEl = wDoc.getChildNodes().item(0);\n+        assertEquals(null, htmlEl.getNamespaceURI());\n+        assertEquals(\"html\", htmlEl.getLocalName());\n+        assertEquals(\"html\", htmlEl.getNodeName());\n+\n+        String out = w3c.asString(wDoc);\n+        assertTrue(out.contains(\"ipod\"));\n+    }\n+\n+    @Test\n+    public void namespacePreservation() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/namespaces.xhtml\");\n+        org.jsoup.nodes.Document jsoupDoc;\n+        jsoupDoc = Jsoup.parse(in, \"UTF-8\");\n+\n+        Document doc;\n+        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();\n+        doc = jDom.fromJsoup(jsoupDoc);\n+\n+        Node htmlEl = doc.getChildNodes().item(0);\n+        assertEquals(\"http://www.w3.org/1999/xhtml\", htmlEl.getNamespaceURI());\n+        assertEquals(\"html\", htmlEl.getLocalName());\n+        assertEquals(\"html\", htmlEl.getNodeName());\n+\n+        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);\n+        assertEquals(\"http://www.idpf.org/2007/ops\", epubTitle.getNamespaceURI());\n+        assertEquals(\"title\", epubTitle.getLocalName());\n+        assertEquals(\"epub:title\", epubTitle.getNodeName());\n+\n+        Node xSection = epubTitle.getNextSibling().getNextSibling();\n+        assertEquals(\"urn:test\", xSection.getNamespaceURI());\n+        assertEquals(\"section\", xSection.getLocalName());\n+        assertEquals(\"x:section\", xSection.getNodeName());\n+    }\n+}\n+\n--- a/src/test/java/org/jsoup/integration/ParseTest.java\n+++ b/src/test/java/org/jsoup/integration/ParseTest.java\n         assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n     }\n \n-    public File getFile(String resourceName) {\n+    public static File getFile(String resourceName) {\n         try {\n             File file = new File(ParseTest.class.getResource(resourceName).toURI());\n             return file;\n         }\n     }\n \n-    private InputStream inputStreamFrom(String s) {\n+    public static InputStream inputStreamFrom(String s) {\n         try {\n             return new ByteArrayInputStream(s.getBytes(\"UTF-8\"));\n         } catch (UnsupportedEncodingException e) {\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.HttpStatusException;\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.W3CDom;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.FormElement;\n+import org.jsoup.parser.HtmlTreeBuilder;\n+import org.jsoup.parser.Parser;\n+import org.jsoup.parser.XmlTreeBuilder;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n+import java.net.*;\n import java.util.Map;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.*;\n \n /**\n  Tests the URL connection. Not enabled by default, so tests don't require network connection.\n  @author Jonathan Hedley, jonathan@hedley.net */\n @Ignore // ignored by default so tests don't require network access. comment out to enable.\n public class UrlConnectTest {\n+    private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n+    private static final String WEBSITE_WITH_SNI = \"https://jsoup.org/\";\n     private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n \n     @Test\n     public void fetchURl() throws IOException {\n-        String url = \"http://www.google.com\"; // no trailing / to force redir\n+        String url = \"http://jsoup.org\"; // no trailing / to force redir\n         Document doc = Jsoup.parse(new URL(url), 10*1000);\n-        assertTrue(doc.title().contains(\"Google\"));\n+        assertTrue(doc.title().contains(\"jsoup\"));\n     }\n \n     @Test\n     \n     @Test\n     public void exceptOnUnknownContentType() {\n-        String url = \"http://jsoup.org/rez/osi_logo.png\"; // not text/* but image/png, should throw\n+        String url = \"http://direct.jsoup.org/rez/osi_logo.png\"; // not text/* but image/png, should throw\n         boolean threw = false;\n         try {\n             Document doc = Jsoup.parse(new URL(url), 3000);\n         } catch (UnsupportedMimeTypeException e) {\n             threw = true;\n-            assertEquals(\"org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://jsoup.org/rez/osi_logo.png\", e.toString());\n+            assertEquals(\"org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://direct.jsoup.org/rez/osi_logo.png\", e.toString());\n             assertEquals(url, e.getUrl());\n             assertEquals(\"image/png\", e.getMimeType());\n         } catch (IOException e) {\n         assertEquals(\"http://example.com\", ihVal(\"HTTP_REFERER\", doc));\n     }\n \n+    @Test\n+    public void doesPut() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL)\n+                .data(\"uname\", \"Jsoup\", \"uname\", \"Jonathan\", \"\u767e\", \"\u5ea6\u4e00\u4e0b\")\n+                .cookie(\"auth\", \"token\")\n+                .method(Connection.Method.PUT)\n+                .execute();\n+\n+        Document doc = res.parse();\n+        assertEquals(\"PUT\", ihVal(\"REQUEST_METHOD\", doc));\n+        //assertEquals(\"gzip\", ihVal(\"HTTP_ACCEPT_ENCODING\", doc)); // current proxy removes gzip on post\n+        assertEquals(\"auth=token\", ihVal(\"HTTP_COOKIE\", doc));\n+    }\n+\n+\n     private static String ihVal(String key, Document doc) {\n         return doc.select(\"th:contains(\"+key+\") + td\").first().text();\n     }\n \n     @Test\n     public void followsRelativeRedirect() throws IOException {\n-        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel.pl\"); // to ./ - /tools/\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel.pl\"); // to /tidy/\n         Document doc = con.post();\n         assertTrue(doc.title().contains(\"HTML Tidy Online\"));\n+    }\n+\n+    @Test\n+    public void followsRelativeDotRedirect() throws IOException {\n+        // redirects to \"./ok.html\", should resolve to http://direct.infohound.net/tools/ok.html\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel-dot.pl\"); // to ./ok.html\n+        Document doc = con.post();\n+        assertTrue(doc.title().contains(\"OK\"));\n+        assertEquals(doc.location(), \"http://direct.infohound.net/tools/ok.html\");\n+    }\n+\n+    @Test\n+    public void followsRelativeDotRedirect2() throws IOException {\n+        //redirects to \"esportspenedes.cat/./ep/index.php\", should resolve to \"esportspenedes.cat/ep/index.php\"\n+        Connection con = Jsoup.connect(\"http://esportspenedes.cat\")  // note lack of trailing / - server should redir to / first, then to ./ep/...; but doesn't'\n+                .timeout(10000);\n+        Document doc = con.post();\n+        assertEquals(doc.location(), \"http://esportspenedes.cat/ep/index.php\");\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void ignores500tExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/500.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(500, res.statusCode());\n+        assertEquals(\"Application Error\", res.statusMessage());\n+        assertEquals(\"Woops\", doc.select(\"h1\").first().text());\n+    }\n+\n+    @Test\n+    public void ignores500NoWithContentExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/500-no-content.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(500, res.statusCode());\n+        assertEquals(\"Application Error\", res.statusMessage());\n+    }\n+\n+    @Test\n+    public void ignores200NoWithContentExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/200-no-content.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(200, res.statusCode());\n+        assertEquals(\"All Good\", res.statusMessage());\n+    }\n+\n+    @Test\n     public void doesntRedirectIfSoConfigured() throws IOException {\n         Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302.pl\").followRedirects(false);\n         Connection.Response res = con.execute();\n         Connection.Response res = con.execute();\n         assertEquals(\"asdfg123\", res.cookie(\"token\")); // confirms that cookies set on 1st hit are presented in final result\n         Document doc = res.parse();\n-        assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n+        assertEquals(\"token=asdfg123; uid=jhy\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n     }\n \n     @Test\n \n         // send those cookies into the echo URL by map:\n         Document doc = Jsoup.connect(echoURL).cookies(cookies).get();\n-        assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc));\n+        assertEquals(\"token=asdfg123; uid=jhy\", ihVal(\"HTTP_COOKIE\", doc));\n     }\n \n     @Test\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n     }\n \n+    /**\n+     * Verify that security disabling feature works properly.\n+     * <p/>\n+     * 1. try to hit url with invalid certificate and evaluate that exception is thrown\n+     *\n+     * @throws Exception\n+     */\n+    @Test(expected = IOException.class)\n+    public void testUnsafeFail() throws Exception {\n+        String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n+        Jsoup.connect(url).execute();\n+    }\n+\n+\n+    /**\n+     * Verify that requests to websites with SNI fail on jdk 1.6\n+     * <p/>\n+     * read for more details:\n+     * http://en.wikipedia.org/wiki/Server_Name_Indication\n+     *\n+     * Test is ignored independent from others as it requires JDK 1.6\n+     * @throws Exception\n+     */\n+    @Test(expected = IOException.class)\n+    public void testSNIFail() throws Exception {\n+        String url = WEBSITE_WITH_SNI;\n+        Jsoup.connect(url).execute();\n+    }\n+\n+    /**\n+     * Verify that requests to websites with SNI pass\n+     * <p/>\n+     * <b>NB!</b> this test is FAILING right now on jdk 1.6\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSNIPass() throws Exception {\n+        String url = WEBSITE_WITH_SNI;\n+        Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n+        assertThat(defaultRes.statusCode(), is(200));\n+    }\n+\n+    /**\n+     * Verify that security disabling feature works properly.\n+     * <p/>\n+     * 1. disable security checks and call the same url to verify that content is consumed correctly\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnsafePass() throws Exception {\n+        String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n+        Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n+        assertThat(defaultRes.statusCode(), is(200));\n+    }\n+\n     @Test\n     public void shouldWorkForCharsetInExtraAttribute() throws IOException {\n         Connection.Response res = Jsoup.connect(\"https://www.creditmutuel.com/groupe/fr/\").execute();\n         assertEquals(\"http://example.com/foo.jpg\", doc.select(\"img\").first().absUrl(\"src\"));\n     }\n \n+    /**\n+     * Test fetching a form, and submitting it with a file attached.\n+     */\n+    @Test\n+    public void postHtmlFile() throws IOException {\n+        Document index = Jsoup.connect(\"http://direct.infohound.net/tidy/\").get();\n+        FormElement form = index.select(\"[name=tidy]\").forms().get(0);\n+        Connection post = form.submit();\n+\n+        File uploadFile = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n+        FileInputStream stream = new FileInputStream(uploadFile);\n+\n+        // todo: need to add a better way to get an existing data field\n+        for (Connection.KeyVal keyVal : post.request().data()) {\n+            if (keyVal.key().equals(\"_file\")) {\n+                keyVal.value(\"check.html\");\n+                keyVal.inputStream(stream);\n+            }\n+        }\n+\n+        Connection.Response res;\n+        try {\n+            res = post.execute();\n+        } finally {\n+            stream.close();\n+        }\n+\n+        Document out = res.parse();\n+        assertTrue(out.text().contains(\"HTML Tidy Complete\"));\n+    }\n+\n+    /**\n+     * Tests upload of binary content to a remote service.\n+     */\n+    @Test\n+    public void postJpeg() throws IOException {\n+        File thumb = ParseTest.getFile(\"/htmltests/thumb.jpg\");\n+        Document result = Jsoup\n+                .connect(\"http://regex.info/exif.cgi\")\n+                .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n+                .post();\n+\n+        assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n+    }\n+\n+    @Test\n+    public void handles201Created() throws IOException {\n+        Document doc = Jsoup.connect(\"http://direct.infohound.net/tools/201.pl\").get(); // 201, location=jsoup\n+        assertEquals(\"http://jsoup.org\", doc.location());\n+    }\n+\n+    @Test\n+    public void fetchToW3c() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Document doc = Jsoup.connect(url).get();\n+\n+        W3CDom dom = new W3CDom();\n+        org.w3c.dom.Document wDoc = dom.fromJsoup(doc);\n+        assertEquals(url, wDoc.getDocumentURI());\n+        String html = dom.asString(wDoc);\n+        assertTrue(html.contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void fetchHandlesXml() throws IOException {\n+        // should auto-detect xml and use XML parser, unless explicitly requested the html parser\n+        String xmlUrl = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(xmlUrl);\n+        Document doc = con.get();\n+        Connection.Request req = con.request();\n+        assertTrue(req.parser().getTreeBuilder() instanceof XmlTreeBuilder);\n+        assertEquals(\"<xml> <link> one </link> <table> Two </table> </xml>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test\n+    public void fetchHandlesXmlAsHtmlWhenParserSet() throws IOException {\n+        // should auto-detect xml and use XML parser, unless explicitly requested the html parser\n+        String xmlUrl = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(xmlUrl).parser(Parser.htmlParser());\n+        Document doc = con.get();\n+        Connection.Request req = con.request();\n+        assertTrue(req.parser().getTreeBuilder() instanceof HtmlTreeBuilder);\n+        assertEquals(\"<html> <head></head> <body> <xml> <link>one <table> Two </table> </xml> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test\n+    public void combinesSameHeadersWithComma() throws IOException {\n+        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+        String url = \"http://direct.infohound.net/tools/q.pl\";\n+        Connection con = Jsoup.connect(url);\n+        con.get();\n+\n+        assertEquals(\"text/html\", con.response().header(\"Content-Type\"));\n+        assertEquals(\"no-cache, no-store\", con.response().header(\"Cache-Control\"));\n+    }\n+\n+    @Test\n+    public void sendHeadRequest() throws IOException {\n+        String url = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(url).method(Connection.Method.HEAD);\n+        final Connection.Response response = con.execute();\n+        assertEquals(\"text/xml\", response.header(\"Content-Type\"));\n+        assertEquals(\"\", response.body()); // head ought to have no body\n+        Document doc = response.parse();\n+        assertEquals(\"\", doc.text());\n+    }\n+\n+\n+    /*\n+     Proxy tests. Assumes local proxy running on 8888, without system propery set (so that specifying it is required).\n+     */\n+\n+    @Test\n+    public void fetchViaHttpProxy() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8888));\n+        Document doc = Jsoup.connect(url).proxy(proxy).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void fetchViaHttpProxySetByArgument() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Document doc = Jsoup.connect(url).proxy(\"localhost\", 8888).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void invalidProxyFails() throws IOException {\n+        boolean caught = false;\n+        String url = \"http://jsoup.org\";\n+        try {\n+            Document doc = Jsoup.connect(url).proxy(\"localhost\", 8889).get();\n+        } catch (IOException e) {\n+            caught = e instanceof ConnectException;\n+        }\n+        assertTrue(caught);\n+    }\n+\n+    @Test\n+    public void proxyGetAndSet() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8889)); // invalid\n+        final Connection con = Jsoup.connect(url).proxy(proxy);\n+\n+        assert con.request().proxy() == proxy;\n+        con.request().proxy(null); // disable\n+        Document doc = con.get();\n+        assertTrue(doc.title().contains(\"jsoup\")); // would fail if actually went via proxy\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n package org.jsoup.nodes;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.StringWriter;\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.integration.ParseTest;\n import org.jsoup.nodes.Document.OutputSettings;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+import org.junit.Ignore;\n import org.junit.Test;\n-import org.junit.Ignore;\n-\n-import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.StringWriter;\n+import java.nio.charset.Charset;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests for Document.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class DocumentTest {\n+    private static final String charsetUtf8 = \"UTF-8\";\n+    private static final String charsetIso8859 = \"ISO-8859-1\";\n+    \n+    \n     @Test public void setTextPreservesDocumentStructure() {\n         Document doc = Jsoup.parse(\"<p>Hello</p>\");\n         doc.text(\"Replaced\");\n         Document doc = Jsoup.parse(\"<p title=\u03c0>\u03c0 & < > </p>\");\n         // default is utf-8\n         assertEquals(\"<p title=\\\"\u03c0\\\">\u03c0 &amp; &lt; &gt; </p>\", doc.body().html());\n-        assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName());\n+        assertEquals(\"UTF-8\", doc.outputSettings().charset().name());\n \n         doc.outputSettings().charset(\"ascii\");\n         assertEquals(Entities.EscapeMode.base, doc.outputSettings().escapeMode());\n \n     @Test public void testNormalisesStructure() {\n         Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>\");\n-        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testClone() {\n         Document clone = doc.clone();\n \n         assertEquals(doc.html(), clone.html());\n-        assertEquals(\"<!DOCTYPE html><html><head><title>Doctype test</title></head><body></body></html>\",\n+        assertEquals(\"<!doctype html><html><head><title>Doctype test</title></head><body></body></html>\",\n                 TextUtil.stripNewlines(clone.html()));\n     }\n     \n         Document doc = Jsoup.parse(h);\n \n         doc.outputSettings().syntax(Syntax.html);\n-        assertEquals(\"<!DOCTYPE html>\\n\" +\n+        assertEquals(\"<!doctype html>\\n\" +\n                 \"<html>\\n\" +\n                 \" <head></head>\\n\" +\n                 \" <body>\\n\" +\n         Document doc = Jsoup.parse(builder.toString());\n         doc.clone();\n     }\n+\n+    @Test public void DocumentsWithSameContentAreEqual() throws Exception {\n+        Document docA = Jsoup.parse(\"<div/>One\");\n+        Document docB = Jsoup.parse(\"<div/>One\");\n+        Document docC = Jsoup.parse(\"<div/>Two\");\n+\n+        assertFalse(docA.equals(docB));\n+        assertTrue(docA.equals(docA));\n+        assertEquals(docA.hashCode(), docA.hashCode());\n+        assertFalse(docA.hashCode() == docC.hashCode());\n+    }\n+\n+    @Test public void DocumentsWithSameContentAreVerifialbe() throws Exception {\n+        Document docA = Jsoup.parse(\"<div/>One\");\n+        Document docB = Jsoup.parse(\"<div/>One\");\n+        Document docC = Jsoup.parse(\"<div/>Two\");\n+\n+        assertTrue(docA.hasSameValue(docB));\n+        assertFalse(docA.hasSameValue(docC));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateUtf8() {\n+        final Document doc = createHtmlDocument(\"changeThis\");\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetUTF8, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(charsetUtf8, doc.charset().name());\n+        assertEquals(charsetUtf8, selectedElement.attr(\"charset\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateIso8859() {\n+        final Document doc = createHtmlDocument(\"changeThis\");\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetIso8859));\n+        \n+        final String htmlCharsetISO = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetISO, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(charsetIso8859, doc.charset().name());\n+        assertEquals(charsetIso8859, selectedElement.attr(\"charset\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateNoCharset() {\n+        final Document docNoCharset = Document.createShell(\"\");\n+        docNoCharset.updateMetaCharsetElement(true);\n+        docNoCharset.charset(Charset.forName(charsetUtf8));\n+        \n+        assertEquals(charsetUtf8, docNoCharset.select(\"meta[charset]\").first().attr(\"charset\"));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetUTF8, docNoCharset.toString()); \n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateDisabled() {\n+        final Document docDisabled = Document.createShell(\"\");\n+        \n+        final String htmlNoCharset = \"<html>\\n\" +\n+                                        \" <head></head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlNoCharset, docDisabled.toString());\n+        assertNull(docDisabled.select(\"meta[charset]\").first());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateDisabledNoChanges() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        \n+        final String htmlCharset = \"<html>\\n\" +\n+                                    \" <head>\\n\" +\n+                                    \"  <meta charset=\\\"dontTouch\\\">\\n\" +\n+                                    \"  <meta name=\\\"charset\\\" content=\\\"dontTouch\\\">\\n\" +\n+                                    \" </head>\\n\" +\n+                                    \" <body></body>\\n\" +\n+                                    \"</html>\";\n+        assertEquals(htmlCharset, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"charset\"));\n+        \n+        selectedElement = doc.select(\"meta[name=charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"content\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateEnabledAfterCharsetChange() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(charsetUtf8, selectedElement.attr(\"charset\"));\n+        assertTrue(doc.select(\"meta[name=charset]\").isEmpty());\n+    }\n+            \n+    @Test\n+    public void testMetaCharsetUpdateCleanup() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        \n+        assertEquals(htmlCharsetUTF8, doc.toString());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlUtf8() {\n+        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetUTF8, doc.toString());\n+\n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetUtf8, doc.charset().name());\n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlIso8859() {\n+        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetIso8859));\n+        \n+        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetISO, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetIso8859, doc.charset().name());\n+        assertEquals(charsetIso8859, selectedNode.attr(\"encoding\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlNoCharset() {\n+        final Document doc = createXmlDocument(\"1.0\", \"none\", false);\n+        doc.updateMetaCharsetElement(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetUTF8, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlDisabled() {\n+        final Document doc = createXmlDocument(\"none\", \"none\", false);\n+        \n+        final String xmlNoCharset = \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        assertEquals(xmlNoCharset, doc.toString());\n+    }\n+\n+    @Test\n+    public void testMetaCharsetUpdateXmlDisabledNoChanges() {\n+        final Document doc = createXmlDocument(\"dontTouch\", \"dontTouch\", true);\n+        \n+        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\">\\n\" +\n+                                    \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        assertEquals(xmlCharset, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(\"dontTouch\", selectedNode.attr(\"encoding\"));\n+        assertEquals(\"dontTouch\", selectedNode.attr(\"version\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdatedDisabledPerDefault() {\n+        final Document doc = createHtmlDocument(\"none\");\n+        assertFalse(doc.updateMetaCharsetElement());\n+    }\n+    \n+    private Document createHtmlDocument(String charset) {\n+        final Document doc = Document.createShell(\"\");\n+        doc.head().appendElement(\"meta\").attr(\"charset\", charset);\n+        doc.head().appendElement(\"meta\").attr(\"name\", \"charset\").attr(\"content\", charset);\n+        \n+        return doc;\n+    }\n+    \n+    private Document createXmlDocument(String version, String charset, boolean addDecl) {\n+        final Document doc = new Document(\"\");\n+        doc.appendElement(\"root\").text(\"node\");\n+        doc.outputSettings().syntax(Syntax.xml);\n+        \n+        if( addDecl == true ) {\n+            XmlDeclaration decl = new XmlDeclaration(\"xml\", \"\", false);\n+            decl.attr(\"version\", version);\n+            decl.attr(\"encoding\", charset);\n+            doc.prependChild(decl);\n+        }\n+        \n+        return doc;\n+    }\n+\n+    @Test\n+    public void testShiftJisRoundtrip() throws Exception {\n+        String input =\n+                \"<html>\"\n+                        +   \"<head>\"\n+                        +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n+                        +   \"</head>\"\n+                        +   \"<body>\"\n+                        +     \"before&nbsp;after\"\n+                        +   \"</body>\"\n+                        + \"</html>\";\n+        InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n+\n+        Document doc = Jsoup.parse(is, null, \"http://example.com\");\n+        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n+\n+        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n+\n+        assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));\n+        assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\",\n+                output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n \n     @Test public void outerHtmlGeneration() {\n         DocumentType html5 = new DocumentType(\"html\", \"\", \"\", \"\");\n-        assertEquals(\"<!DOCTYPE html>\", html5.outerHtml());\n+        assertEquals(\"<!doctype html>\", html5.outerHtml());\n \n         DocumentType publicDocType = new DocumentType(\"html\", \"-//IETF//DTD HTML//\", \"\", \"\");\n         assertEquals(\"<!DOCTYPE html PUBLIC \\\"-//IETF//DTD HTML//\\\">\", publicDocType.outerHtml());\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n-import org.jsoup.helper.StringUtil;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n+import java.util.*;\n+\n import static org.junit.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Map;\n \n /**\n  * Tests for Element (DOM stuff mostly).\n         assertEquals(\"element\", p.lastElementSibling().text());\n     }\n \n+    @Test public void testGetSiblingsWithDuplicateContent() {\n+        Document doc = Jsoup.parse(\"<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>\");\n+        Element p = doc.getElementById(\"1\");\n+        assertEquals(\"there\", p.text());\n+        assertEquals(\"Hello\", p.previousElementSibling().text());\n+        assertEquals(\"this\", p.nextElementSibling().text());\n+        assertEquals(\"this\", p.nextElementSibling().nextElementSibling().text());\n+        assertEquals(\"is\", p.nextElementSibling().nextElementSibling().nextElementSibling().text());\n+        assertEquals(\"Hello\", p.firstElementSibling().text());\n+        assertEquals(\"element\", p.lastElementSibling().text());\n+    }\n+\n     @Test public void testGetParents() {\n         Document doc = Jsoup.parse(\"<div><p>Hello <span>there</span></div>\");\n         Element span = doc.select(\"span\").first();\n         assertTrue(2 == ps.get(2).elementSiblingIndex());\n     }\n \n+    @Test public void testElementSiblingIndexSameContent() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p>...<p>One</p>...<p>One</p>\");\n+        Elements ps = doc.select(\"p\");\n+        assertTrue(0 == ps.get(0).elementSiblingIndex());\n+        assertTrue(1 == ps.get(1).elementSiblingIndex());\n+        assertTrue(2 == ps.get(2).elementSiblingIndex());\n+    }\n+\n     @Test public void testGetElementsWithClass() {\n         Document doc = Jsoup.parse(\"<div class='mellow yellow'><span class=mellow>Hello <b class='yellow'>Yellow!</b></span><p>Empty</p></div>\");\n \n     }\n     \n     @Test public void testClassDomMethods() {\n-        Document doc = Jsoup.parse(\"<div><span class='mellow yellow'>Hello <b>Yellow</b></span></div>\");\n+        Document doc = Jsoup.parse(\"<div><span class=' mellow yellow '>Hello <b>Yellow</b></span></div>\");\n         List<Element> els = doc.getElementsByAttribute(\"class\");\n         Element span = els.get(0);\n         assertEquals(\"mellow yellow\", span.className());\n         assertTrue(classes.contains(\"yellow\"));\n \n         assertEquals(\"\", doc.className());\n+        classes = doc.classNames();\n+        assertEquals(0, classes.size());\n         assertFalse(doc.hasClass(\"mellow\"));\n     }\n \n             assertEquals(i, ps.get(i).siblingIndex);\n         }\n     }\n+    \n+    @Test public void testAddBooleanAttribute() {\n+        Element div = new Element(Tag.valueOf(\"div\"), \"\");\n+        \n+        div.attr(\"true\", true);\n+        \n+        div.attr(\"false\", \"value\");\n+        div.attr(\"false\", false);\n+        \n+        assertTrue(div.hasAttr(\"true\"));\n+        assertEquals(\"\", div.attr(\"true\"));\n+        \n+        List<Attribute> attributes = div.attributes().asList();\n+        assertEquals(\"There should be one attribute\", 1, attributes.size());\n+\t\tassertTrue(\"Attribute should be boolean\", attributes.get(0) instanceof BooleanAttribute);\n+        \n+        assertFalse(div.hasAttr(\"false\"));\n+ \n+        assertEquals(\"<div true></div>\", div.outerHtml());\n+    }    \n \n     @Test public void testAppendRowToTable() {\n         Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n         assertEquals(\"there & now > Hello\", div.text());\n         assertEquals(\"there &amp; now &gt; <p>Hello</p>\", TextUtil.stripNewlines(div.html()));\n     }\n+\n+    @Test(expected = IllegalArgumentException.class) public void testThrowsOnAddNullText() {\n+        Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n+        Element div = doc.getElementById(\"1\");\n+        div.appendText(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)  public void testThrowsOnPrependNullText() {\n+        Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n+        Element div = doc.getElementById(\"1\");\n+        div.prependText(null);\n+    }\n     \n     @Test public void testAddNewHtml() {\n         Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n         assertEquals(\"<div><div class=\\\"head\\\"><p>Hello</p></div><p>There</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n \n         Element ret = p.wrap(\"<div><div class=foo></div><p>What?</p></div>\");\n-        assertEquals(\"<div><div class=\\\"head\\\"><div><div class=\\\"foo\\\"><p>Hello</p></div><p>What?</p></div></div><p>There</p></div>\", \n+        assertEquals(\"<div><div class=\\\"head\\\"><div><div class=\\\"foo\\\"><p>Hello</p></div><p>What?</p></div></div><p>There</p></div>\",\n                 TextUtil.stripNewlines(doc.body().html()));\n \n         assertEquals(ret, p);\n         assertTrue(divC == doc.select(divC.cssSelector()).first());\n     }\n \n+\n+    @Test\n+    public void testClassNames() {\n+        Document doc = Jsoup.parse(\"<div class=\\\"c1 c2\\\">C</div>\");\n+        Element div = doc.select(\"div\").get(0);\n+\n+        assertEquals(\"c1 c2\", div.className());\n+\n+        final Set<String> set1 = div.classNames();\n+        final Object[] arr1 = set1.toArray();\n+        assertTrue(arr1.length==2);\n+        assertEquals(\"c1\", arr1[0]);\n+        assertEquals(\"c2\", arr1[1]);\n+\n+        // Changes to the set should not be reflected in the Elements getters\n+       \tset1.add(\"c3\");\n+        assertTrue(2==div.classNames().size());\n+        assertEquals(\"c1 c2\", div.className());\n+\n+        // Update the class names to a fresh set\n+        final Set<String> newSet = new LinkedHashSet<String>(3);\n+        newSet.addAll(set1);\n+        newSet.add(\"c3\");\n+        \n+        div.classNames(newSet);\n+\n+        \n+        assertEquals(\"c1 c2 c3\", div.className());\n+\n+        final Set<String> set2 = div.classNames();\n+        final Object[] arr2 = set2.toArray();\n+        assertTrue(arr2.length==3);\n+        assertEquals(\"c1\", arr2[0]);\n+        assertEquals(\"c2\", arr2[1]);\n+        assertEquals(\"c3\", arr2[2]);\n+    }\n+\n+    @Test\n+    public void testHashAndEqualsAndValue() {\n+        // .equals and hashcode are identity. value is content.\n+\n+        String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n+                \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n+\n+        Document doc = Jsoup.parse(doc1);\n+        Elements els = doc.select(\"p\");\n+\n+        /*\n+        for (Element el : els) {\n+            System.out.println(el.hashCode() + \" - \" + el.outerHtml());\n+        }\n+\n+        0 1534787905 - <p class=\"one\">One</p>\n+        1 1534787905 - <p class=\"one\">One</p>\n+        2 1539683239 - <p class=\"one\">Two</p>\n+        3 1535455211 - <p class=\"two\">One</p>\n+        4 1534787905 - <p class=\"one\">One</p>\n+        5 1534787905 - <p class=\"one\">One</p>\n+        6 1539683239 - <p class=\"one\">Two</p>\n+        7 1535455211 - <p class=\"two\">One</p>\n+        */\n+        assertEquals(8, els.size());\n+        Element e0 = els.get(0);\n+        Element e1 = els.get(1);\n+        Element e2 = els.get(2);\n+        Element e3 = els.get(3);\n+        Element e4 = els.get(4);\n+        Element e5 = els.get(5);\n+        Element e6 = els.get(6);\n+        Element e7 = els.get(7);\n+\n+        assertEquals(e0, e0);\n+        assertTrue(e0.hasSameValue(e1));\n+        assertTrue(e0.hasSameValue(e4));\n+        assertTrue(e0.hasSameValue(e5));\n+        assertFalse(e0.equals(e2));\n+        assertFalse(e0.hasSameValue(e2));\n+        assertFalse(e0.hasSameValue(e3));\n+        assertFalse(e0.hasSameValue(e6));\n+        assertFalse(e0.hasSameValue(e7));\n+\n+        assertEquals(e0.hashCode(), e0.hashCode());\n+        assertFalse(e0.hashCode() == (e2.hashCode()));\n+        assertFalse(e0.hashCode() == (e3).hashCode());\n+        assertFalse(e0.hashCode() == (e6).hashCode());\n+        assertFalse(e0.hashCode() == (e7).hashCode());\n+    }\n+\n+    @Test public void testRelativeUrls() {\n+        String html = \"<body><a href='./one.html'>One</a> <a href='two.html'>two</a> <a href='../three.html'>Three</a> <a href='//example2.com/four/'>Four</a> <a href='https://example2.com/five/'>Five</a>\";\n+        Document doc = Jsoup.parse(html, \"http://example.com/bar/\");\n+        Elements els = doc.select(\"a\");\n+\n+        assertEquals(\"http://example.com/bar/one.html\", els.get(0).absUrl(\"href\"));\n+        assertEquals(\"http://example.com/bar/two.html\", els.get(1).absUrl(\"href\"));\n+        assertEquals(\"http://example.com/three.html\", els.get(2).absUrl(\"href\"));\n+        assertEquals(\"http://example2.com/four/\", els.get(3).absUrl(\"href\"));\n+        assertEquals(\"https://example2.com/five/\", els.get(4).absUrl(\"href\"));\n+    }\n+\n+    @Test\n+    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n+        Document doc = new Document(\"\");\n+        Element body = doc.appendElement(\"body\");\n+        body.appendElement(\"div1\");\n+        body.appendElement(\"div2\");\n+        final Element div3 = body.appendElement(\"div3\");\n+        div3.text(\"Check\");\n+        final Element div4 = body.appendElement(\"div4\");\n+\n+        ArrayList<Element> toMove = new ArrayList<Element>();\n+        toMove.add(div3);\n+        toMove.add(div4);\n+\n+        body.insertChildren(0, toMove);\n+\n+        String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n+        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n+    }\n+\n+    @Test\n+    public void testHashcodeIsStableWithContentChanges() {\n+        Element root = new Element(Tag.valueOf(\"root\"), \"\");\n+\n+        HashSet<Element> set = new HashSet<Element>();\n+        // Add root node:\n+        set.add(root);\n+\n+        root.appendChild(new Element(Tag.valueOf(\"a\"), \"\"));\n+        assertTrue(set.contains(root));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import static org.jsoup.nodes.Entities.EscapeMode.*;\n import static org.junit.Assert.*;\n \n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-\n public class EntitiesTest {\n-    @Test public void escape() throws IOException {\n+    @Test public void escape() {\n         String text = \"Hello &<> \u00c5 \u00e5 \u03c0 \u65b0 there \u00be \u00a9 \u00bb\";\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n         String escapedAsciiXhtml = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(xhtml));\n-        String escapedUtfFull = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(base));\n+        String escapedUtfFull = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(extended));\n         String escapedUtfMin = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(xhtml));\n \n         assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; &#x3c0; &#x65b0; there &frac34; &copy; &raquo;\", escapedAscii);\n         assertEquals(text, Entities.unescape(escapedUtfMin));\n     }\n \n-    @Test public void escapeSupplementaryCharacter() throws IOException{\n+    @Test public void escapeSupplementaryCharacter() {\n         String text = new String(Character.toChars(135361));\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         assertEquals(\"&#x210c1;\", escapedAscii);\n     }\n \n     \n-    @Test public void caseSensitive() throws IOException {\n+    @Test public void caseSensitive() {\n         String unescaped = \"\u00dc \u00fc & &\";\n         assertEquals(\"&Uuml; &uuml; &amp; &amp;\",\n                 Entities.escape(unescaped, new OutputSettings().charset(\"ascii\").escapeMode(extended)));\n         String string = \"http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\";\n         assertEquals(string, Entities.unescape(string));\n     }\n+\n+    @Test public void escapesGtInXmlAttributesButNotInHtml() {\n+        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML\n+\n+\n+        String docHtml = \"<a title='<p>One</p>'>One</a>\";\n+        Document doc = Jsoup.parse(docHtml);\n+        Element element = doc.select(\"a\").first();\n+\n+        doc.outputSettings().escapeMode(base);\n+        assertEquals(\"<a title=\\\"<p>One</p>\\\">One</a>\", element.outerHtml());\n+\n+        doc.outputSettings().escapeMode(xhtml);\n+        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/FormElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/FormElementTest.java\n import org.jsoup.Jsoup;\n import org.junit.Test;\n \n-import java.io.IOException;\n-import java.util.Collection;\n import java.util.List;\n \n import static org.junit.Assert.*;\n \n     @Test public void createsFormData() {\n         String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n-                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea></form>\";\n+                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n+                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n+                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n+                \"<input name='ten' value='text' disabled>\" +\n+                \"</form>\";\n         Document doc = Jsoup.parse(html);\n         FormElement form = (FormElement) doc.select(\"form\").first();\n         List<Connection.KeyVal> data = form.formData();\n \n-        assertEquals(4, data.size());\n+        assertEquals(6, data.size());\n         assertEquals(\"one=two\", data.get(0).toString());\n         assertEquals(\"three=four\", data.get(1).toString());\n         assertEquals(\"three=five\", data.get(2).toString());\n         assertEquals(\"six=seven\", data.get(3).toString());\n+        assertEquals(\"seven=on\", data.get(4).toString()); // set\n+        assertEquals(\"eight=on\", data.get(5).toString()); // default\n+        // nine should not appear, not checked checkbox\n+        // ten should not appear, disabled\n     }\n \n     @Test public void createsSubmitableConnection() {\n         List<Connection.KeyVal> data = form.formData();\n         assertEquals(\"foo=bar\", data.get(0).toString());\n     }\n+\n+    @Test public void usesOnForCheckboxValueIfNoValueSet() {\n+        Document doc = Jsoup.parse(\"<form><input type=checkbox checked name=foo></form>\");\n+        FormElement form = (FormElement) doc.select(\"form\").first();\n+        List<Connection.KeyVal> data = form.formData();\n+        assertEquals(\"on\", data.get(0).value());\n+        assertEquals(\"foo\", data.get(0).key());\n+    }\n+\n+    @Test public void adoptedFormsRetainInputs() {\n+        // test for https://github.com/jhy/jsoup/issues/249\n+        String html = \"<html>\\n\" +\n+                \"<body>  \\n\" +\n+                \"  <table>\\n\" +\n+                \"      <form action=\\\"/hello.php\\\" method=\\\"post\\\">\\n\" +\n+                \"      <tr><td>User:</td><td> <input type=\\\"text\\\" name=\\\"user\\\" /></td></tr>\\n\" +\n+                \"      <tr><td>Password:</td><td> <input type=\\\"password\\\" name=\\\"pass\\\" /></td></tr>\\n\" +\n+                \"      <tr><td><input type=\\\"submit\\\" name=\\\"login\\\" value=\\\"login\\\" /></td></tr>\\n\" +\n+                \"   </form>\\n\" +\n+                \"  </table>\\n\" +\n+                \"</body>\\n\" +\n+                \"</html>\";\n+        Document doc = Jsoup.parse(html);\n+        FormElement form = (FormElement) doc.select(\"form\").first();\n+        List<Connection.KeyVal> data = form.formData();\n+        assertEquals(3, data.size());\n+        assertEquals(\"user\", data.get(0).key());\n+        assertEquals(\"pass\", data.get(1).key());\n+        assertEquals(\"login\", data.get(2).key());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Elements;\n import org.jsoup.select.NodeVisitor;\n import org.junit.Test;\n \n \n         Element a2 = doc.select(\"a\").get(1);\n         assertEquals(\"http://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n+    }\n+\n+    @Test public void absHandlesDotFromIndex() {\n+        Document doc = Jsoup.parse(\"<a href='./one/two.html'>One</a>\", \"http://example.com\");\n+        Element a1 = doc.select(\"a\").first();\n+        assertEquals(\"http://example.com/one/two.html\", a1.absUrl(\"href\"));\n     }\n     \n     @Test public void testRemove() {\n         assertEquals(\"<div id=\\\"1\\\">Text 1 <p>One</p> Text 2 <p>Two</p><p>Three</p></div><div id=\\\"2\\\">Text 1 updated\"\n             +\"<p>One</p> Text 2 <p>Two</p><p>Three</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n+\n+    @Test public void supportsClone() {\n+        Document doc = org.jsoup.Jsoup.parse(\"<div class=foo>Text</div>\");\n+        Element el = doc.select(\"div\").first();\n+        assertTrue(el.hasClass(\"foo\"));\n+\n+        Element elClone = doc.clone().select(\"div\").first();\n+        assertTrue(elClone.hasClass(\"foo\"));\n+        assertTrue(elClone.text().equals(\"Text\"));\n+\n+        el.removeClass(\"foo\");\n+        el.text(\"None\");\n+        assertFalse(el.hasClass(\"foo\"));\n+        assertTrue(elClone.hasClass(\"foo\"));\n+        assertTrue(el.text().equals(\"None\"));\n+        assertTrue(elClone.text().equals(\"Text\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n package org.jsoup.parser;\n \n+import java.util.List;\n+\n import org.jsoup.Jsoup;\n+import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.BooleanAttribute;\n import org.jsoup.nodes.Element;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n         Elements els = Jsoup.parse(html).select(\"a\");\n         assertEquals(\"&wr_id=123&mid-size=true&ok=&wr\", els.first().attr(\"href\"));\n     }\n+    \n+    @Test public void parsesBooleanAttributes() {\n+        String html = \"<a normal=\\\"123\\\" boolean empty=\\\"\\\"></a>\";\n+        Element el = Jsoup.parse(html).select(\"a\").first();\n+        \n+        assertEquals(\"123\", el.attr(\"normal\"));\n+        assertEquals(\"\", el.attr(\"boolean\"));\n+        assertEquals(\"\", el.attr(\"empty\"));\n+        \n+        List<Attribute> attributes = el.attributes().asList();\n+        assertEquals(\"There should be 3 attribute present\", 3, attributes.size());\n+        \n+        // Assuming the list order always follows the parsed html\n+\t\tassertFalse(\"'normal' attribute should not be boolean\", attributes.get(0) instanceof BooleanAttribute);        \n+\t\tassertTrue(\"'boolean' attribute should be boolean\", attributes.get(1) instanceof BooleanAttribute);        \n+\t\tassertFalse(\"'empty' attribute should not be boolean\", attributes.get(2) instanceof BooleanAttribute);        \n+        \n+        assertEquals(html, el.outerHtml());\n+    }\n+    \n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matchesAny(scan));\n     }\n \n+    @Test public void cachesStrings() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\\tA string that is longer than 16 chars\");\n+        String one = r.consumeTo('\\t');\n+        r.consume();\n+        String two = r.consumeTo('\\t');\n+        r.consume();\n+        String three = r.consumeTo('\\t');\n+        r.consume();\n+        String four = r.consumeTo('\\t');\n+        r.consume();\n+        String five = r.consumeTo('\\t');\n+\n+        assertEquals(\"Check\", one);\n+        assertEquals(\"Check\", two);\n+        assertEquals(\"Check\", three);\n+        assertEquals(\"CHOKE\", four);\n+        assertTrue(one == two);\n+        assertTrue(two == three);\n+        assertTrue(three != four);\n+        assertTrue(four != five);\n+        assertEquals(five, \"A string that is longer than 16 chars\");\n+    }\n+\n+    @Test\n+    public void rangeEquals() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\");\n+        assertTrue(r.rangeEquals(0, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(0, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(0, 5, \"Chec\"));\n+\n+        assertTrue(r.rangeEquals(6, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(6, 5, \"Chuck\"));\n+\n+        assertTrue(r.rangeEquals(12, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(12, 5, \"Cheeky\"));\n+\n+        assertTrue(r.rangeEquals(18, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n+    }\n+\n+\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.integration.ParseTest;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.io.IOException;\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n \n /**\n         String html = \"<p =a>One<a <p>Something</p>Else\";\n         // this gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n         Document doc = Jsoup.parse(html);\n-        assertEquals(\"<p =a=\\\"\\\">One<a <p=\\\"\\\">Something</a></p>\\n\" +\n-                \"<a <p=\\\"\\\">Else</a>\", doc.body().html());\n+        assertEquals(\"<p =a>One<a <p>Something</a></p>\\n\" +\n+                \"<a <p>Else</a>\", doc.body().html());\n \n         doc = Jsoup.parse(\"<p .....>\");\n-        assertEquals(\"<p .....=\\\"\\\"></p>\", doc.body().html());\n+        assertEquals(\"<p .....></p>\", doc.body().html());\n     }\n \n     @Test public void parsesComments() {\n     @Test public void normalisesDocument() {\n         String h = \"<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven \";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(\"<!DOCTYPE html><html><head></head><body>OneTwoThree<link>FourFive Six Seven </body></html>\",\n+        assertEquals(\"<!doctype html><html><head></head><body>OneTwoThree<link>FourFive Six Seven </body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testNoImagesInNoScriptInHead() {\n         // jsoup used to allow, but against spec if parsing with noscript\n         Document doc = Jsoup.parse(\"<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>\");\n-        assertEquals(\"<html><head><noscript></noscript></head><body><img src=\\\"foo\\\"><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><noscript>&lt;img src=\\\"foo\\\"&gt;</noscript></head><body><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testAFlowContents() {\n                 \"<p></b></b></b></b></b></b>X\";\n         Document doc = Jsoup.parse(h);\n         doc.outputSettings().indentAmount(0);\n-        String want = \"<!DOCTYPE html>\\n\" +\n+        String want = \"<!doctype html>\\n\" +\n                 \"<html>\\n\" +\n                 \"<head></head>\\n\" +\n                 \"<body>\\n\" +\n         // would previously throw invalid name exception on empty doctype\n         Document doc = Jsoup.parse(\"<!DOCTYPE>\");\n         assertEquals(\n-                \"<!DOCTYPE> <html> <head></head> <body></body> </html>\",\n+                \"<!doctype> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n \n         doc = Jsoup.parse(\"<!DOCTYPE><html><p>Foo</p></html>\");\n         assertEquals(\n-                \"<!DOCTYPE> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n+                \"<!doctype> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n \n         doc = Jsoup.parse(\"<!DOCTYPE \\u0000>\");\n         assertEquals(\n-                \"<!DOCTYPE \ufffd> <html> <head></head> <body></body> </html>\",\n+                \"<!doctype \ufffd> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n     }\n+    \n+    @Test public void handlesManyChildren() {\n+        // Arrange\n+        StringBuilder longBody = new StringBuilder(500000);\n+        for (int i = 0; i < 25000; i++) {\n+            longBody.append(i).append(\"<br>\");\n+        }\n+        \n+        // Act\n+        long start = System.currentTimeMillis();\n+        Document doc = Parser.parseBodyFragment(longBody.toString(), \"\");\n+        \n+        // Assert\n+        assertEquals(50000, doc.body().childNodeSize());\n+        assertTrue(System.currentTimeMillis() - start < 1000);\n+    }\n+\n+    @Test\n+    public void testInvalidTableContents() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/table-invalid-elements.html\");\n+        Document doc = Jsoup.parse(in, \"UTF-8\");\n+        doc.outputSettings().prettyPrint(true);\n+        String rendered = doc.toString();\n+        int endOfEmail = rendered.indexOf(\"Comment\");\n+        int guarantee = rendered.indexOf(\"Why am I here?\");\n+        assertTrue(\"Comment not found\", endOfEmail > -1);\n+        assertTrue(\"Search text not found\", guarantee > -1);\n+        assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail);\n+    }\n+\n+    @Test public void testNormalisesIsIndex() {\n+        Document doc = Jsoup.parse(\"<body><isindex action='/submit'></body>\");\n+        String html = doc.outerHtml();\n+        assertEquals(\"<form action=\\\"/submit\\\"> <hr> <label>This is a searchable index. Enter search keywords: <input name=\\\"isindex\\\"></label> <hr> </form>\",\n+                StringUtil.normaliseWhitespace(doc.body().html()));\n+    }\n+\n+    @Test public void testReinsertionModeForThCelss() {\n+        String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\n+        Document doc = Jsoup.parse(body);\n+        assertEquals(1, doc.body().children().size());\n+    }\n+\n+    @Test public void testUsingSingleQuotesInQueries() {\n+        String body = \"<body> <div class='main'>hello</div></body>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements main = doc.select(\"div[class='main']\");\n+        assertEquals(\"hello\", main.text());\n+    }\n+\n+    @Test public void testSupportsNonAsciiTags() {\n+        String body = \"<\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>Yes</\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5><\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433>Correct</<\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements els = doc.select(\"\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5\");\n+        assertEquals(\"Yes\", els.text());\n+        els = doc.select(\"\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433\");\n+        assertEquals(\"Correct\", els.text());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n-import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n import java.util.List;\n \n import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.*;\n \n /**\n  * Tests XmlTreeBuilder.\n \n         // parse with both xml and html parser, ensure different\n         Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();\n-        Document htmlDoc = Jsoup.connect(xmlUrl).get();\n+        Document htmlDoc = Jsoup.connect(xmlUrl).parser(Parser.htmlParser()).get();\n+        Document autoXmlDoc = Jsoup.connect(xmlUrl).get(); // check connection auto detects xml, uses xml parser\n \n         assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                 TextUtil.stripNewlines(xmlDoc.html()));\n-        assertNotSame(htmlDoc, xmlDoc);\n+        assertFalse(htmlDoc.equals(xmlDoc));\n+        assertEquals(xmlDoc, autoXmlDoc);\n         assertEquals(1, htmlDoc.select(\"head\").size()); // html parser normalises\n         assertEquals(0, xmlDoc.select(\"head\").size()); // xml parser does not\n+        assertEquals(0, autoXmlDoc.select(\"head\").size()); // xml parser does not\n     }\n \n     @Test\n         Document doc = Jsoup.parse(\"x\", \"\", Parser.xmlParser());\n         assertEquals(Syntax.xml, doc.outputSettings().syntax());\n     }\n+\n+    @Test\n+    public void testDoesHandleEOFInTag() {\n+        String html = \"<img src=asdf onerror=\\\"alert(1)\\\" x=\";\n+        Document xmlDoc = Jsoup.parse(html, \"\", Parser.xmlParser());\n+        assertEquals(\"<img src=\\\"asdf\\\" onerror=\\\"alert(1)\\\" x=\\\"\\\" />\", xmlDoc.html());\n+    }\n }\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n         assertEquals(\"<a>One</a> Two Three <i>Four</i> Fix <i>Six</i>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n+    @Test public void unwrapKeepsSpace() {\n+        String h = \"<p>One <span>two</span> <span>three</span> four</p>\";\n+        Document doc = Jsoup.parse(h);\n+        doc.select(\"span\").unwrap();\n+        assertEquals(\"<p>One two three four</p>\", doc.body().html());\n+    }\n+\n     @Test public void empty() {\n         Document doc = Jsoup.parse(\"<div><p>Hello <b>there</b></p> <p>now!</p></div>\");\n         doc.outputSettings().prettyPrint(false);\n         assertEquals(\"1\", forms.get(0).id());\n         assertEquals(\"2\", forms.get(1).id());\n     }\n+\n+    @Test public void classWithHyphen() {\n+        Document doc = Jsoup.parse(\"<p class='tab-nav'>Check</p>\");\n+        Elements els = doc.getElementsByClass(\"tab-nav\");\n+        assertEquals(1, els.size());\n+        assertEquals(\"Check\", els.text());\n+    }\n }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n     @Test public void descendant() {\n         String h = \"<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>\";\n         Document doc = Jsoup.parse(h);\n-        Elements els = doc.select(\".head p\");\n+        Element root = doc.getElementsByClass(\"head\").first();\n+        \n+        Elements els = root.select(\".head p\");\n         assertEquals(2, els.size());\n         assertEquals(\"Hello\", els.get(0).text());\n         assertEquals(\"There\", els.get(1).text());\n \n-        Elements p = doc.select(\"p.first\");\n+        Elements p = root.select(\"p.first\");\n         assertEquals(1, p.size());\n         assertEquals(\"Hello\", p.get(0).text());\n \n-        Elements empty = doc.select(\"p .first\"); // self, not descend, should not match\n+        Elements empty = root.select(\"p .first\"); // self, not descend, should not match\n         assertEquals(0, empty.size());\n+        \n+        Elements aboveRoot = root.select(\"body div.head\");\n+        assertEquals(0, aboveRoot.size());\n     }\n \n     @Test public void and() {\n \n     @Test public void deeperDescendant() {\n         String h = \"<div class=head><p><span class=first>Hello</div><div class=head><p class=first><span>Another</span><p>Again</div>\";\n-        Elements els = Jsoup.parse(h).select(\"div p .first\");\n+        Document doc = Jsoup.parse(h);\n+        Element root = doc.getElementsByClass(\"head\").first();\n+\n+        Elements els = root.select(\"div p .first\");\n         assertEquals(1, els.size());\n         assertEquals(\"Hello\", els.first().text());\n         assertEquals(\"span\", els.first().tagName());\n+\n+        Elements aboveRoot = root.select(\"body p .first\");\n+        assertEquals(0, aboveRoot.size());\n     }\n \n     @Test public void parentChildElement() {\n         assertEquals(\"div\", doc.select(\"div[k\" + s + \"]\").first().tagName());\n         assertEquals(\"div\", doc.select(\"div:containsOwn(\" + s + \")\").first().tagName());\n     }\n+    \n+    @Test\n+    public void selectClassWithSpace() {\n+        final String html = \"<div class=\\\"value\\\">class without space</div>\\n\"\n+                          + \"<div class=\\\"value \\\">class with space</div>\";\n+        \n+        Document doc = Jsoup.parse(html);\n+        \n+        Elements found = doc.select(\"div[class=value ]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value \\\"]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value\\\\ \\\"]\");\n+        assertEquals(0, found.size());\n+    }\n+\n+    @Test public void selectSameElements() {\n+        final String html = \"<div>one</div><div>one</div>\";\n+\n+        Document doc = Jsoup.parse(html);\n+        Elements els = doc.select(\"div\");\n+        assertEquals(2, els.size());\n+\n+        Elements subSelect = els.select(\":contains(one)\");\n+        assertEquals(2, subSelect.size());\n+    }\n }", "timestamp": 1460656182, "metainfo": ""}