{"sha": "10cfa0465c9d48f6a3ce3f5996259e77b43fa858", "log": "Use a Visitor instead of recursion for HTML and selectors.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n         return attributes.get(COMMENT_KEY);\n     }\n \n-    void outerHtml(StringBuilder accum) {\n-        indent(accum);\n+    void outerHtmlHead(StringBuilder accum, int depth) {\n+        indent(accum, depth);\n         accum.append(String.format(\"<!--%s-->\", getData()));\n     }\n+\n+    void outerHtmlTail(StringBuilder accum, int depth) {}\n \n     public String toString() {\n         return outerHtml();\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n         return attributes.get(DATA_KEY);\n     }\n \n-    void outerHtml(StringBuilder accum) {\n+    void outerHtmlHead(StringBuilder accum, int depth) {\n         accum.append(getWholeData()); // data is not escaped in return from data nodes, so \" in script, style is plain\n     }\n+\n+    void outerHtmlTail(StringBuilder accum, int depth) {}\n \n     public String toString() {\n         return outerHtml();\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n         return this;\n     }\n \n-    void outerHtml(StringBuilder accum) {\n+    void outerHtmlHead(StringBuilder accum, int depth) {\n         if (isBlock() || (parent() != null && parent().tag().canContainBlock() && siblingIndex() == 0))\n-            indent(accum);\n+            indent(accum, depth);\n         accum\n                 .append(\"<\")\n                 .append(tagName())\n                 .append(attributes.html());\n \n-        if (childNodes.isEmpty() && tag.isEmpty()) {\n+        if (childNodes.isEmpty() && tag.isEmpty())\n             accum.append(\" />\");\n-        } else {\n+        else\n             accum.append(\">\");\n-            html(accum);\n-            if (tag.canContainBlock()) indent(accum);\n+    }\n+\n+    void outerHtmlTail(StringBuilder accum, int depth) {\n+        if (!tag.isEmpty()) {\n+            if (tag.canContainBlock()) indent(accum, depth);\n             accum.append(\"</\").append(tagName()).append(\">\");\n         }\n     }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n import org.apache.commons.lang.Validate;\n import org.apache.commons.lang.StringUtils;\n+import org.jsoup.select.NodeVisitor;\n+import org.jsoup.select.NodeTraversor;\n \n import java.net.MalformedURLException;\n import java.net.URL;\n      @return next sibling, or null if this is the last sibling\n      */\n     public Node nextSibling() {\n+        if (parentNode == null)\n+            return null; // root\n+        \n         List<Node> siblings = parentNode.childNodes;\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n         return accum.toString();\n     }\n \n+    protected void outerHtml(StringBuilder accum) {\n+        new NodeTraversor(new OuterHtmlVisitor(accum)).traverse(this);\n+    }\n+\n     /**\n      Get the outer HTML of this node.\n      @param accum accumulator to place HTML into\n      */\n-    abstract void outerHtml(StringBuilder accum);\n+    abstract void outerHtmlHead(StringBuilder accum, int depth);\n+\n+    abstract void outerHtmlTail(StringBuilder accum, int depth);\n \n     public String toString() {\n         return outerHtml();\n     }\n \n-    protected void indent(StringBuilder accum) {\n-        accum.append(\"\\n\").append(StringUtils.leftPad(\"\", nodeDepth() -1 * 2));\n+    protected void indent(StringBuilder accum, int depth) {\n+        accum.append(\"\\n\").append(StringUtils.leftPad(\"\", depth));\n     }\n \n     @Override\n         result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n         return result;\n     }\n+\n+    private static class OuterHtmlVisitor implements NodeVisitor {\n+        private StringBuilder accum;\n+\n+        OuterHtmlVisitor(StringBuilder accum) {\n+            this.accum = accum;\n+        }\n+\n+        public void head(Node node, int depth) {\n+            node.outerHtmlHead(accum, depth);\n+        }\n+\n+        public void tail(Node node, int depth) {\n+            node.outerHtmlTail(accum, depth);\n+        }\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n         return StringUtils.isBlank(normaliseWhitespace(getWholeText()));\n     }\n \n-    void outerHtml(StringBuilder accum) {\n+    void outerHtmlHead(StringBuilder accum, int depth) {\n         String html = StringEscapeUtils.escapeHtml(getWholeText());\n         if (parent() instanceof Element && !((Element) parent()).preserveWhitespace()) {\n             html = normaliseWhitespace(html);\n         }\n \n         if (siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().canContainBlock() && !isBlank())\n-            indent(accum);\n+            indent(accum, depth);\n         accum.append(html);\n     }\n+\n+    void outerHtmlTail(StringBuilder accum, int depth) {}\n \n     public String toString() {\n         return outerHtml();\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n         return attributes.get(DECL_KEY);\n     }\n \n-    void outerHtml(StringBuilder accum) {\n+    void outerHtmlHead(StringBuilder accum, int depth) {\n         accum.append(String.format(\"<%s%s>\", isProcessingInstruction ? \"!\" : \"?\", getWholeDeclaration()));\n     }\n+\n+    void outerHtmlTail(StringBuilder accum, int depth) {}\n \n     public String toString() {\n         return outerHtml();\n--- a/src/main/java/org/jsoup/select/Collector.java\n+++ b/src/main/java/org/jsoup/select/Collector.java\n \n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n+import org.jsoup.nodes.Node;\n \n import java.util.List;\n \n      */\n     public static Elements collect (Evaluator eval, Element root) {\n         Elements elements = new Elements();\n-        accumulateMatches(eval, elements, root);\n+        new NodeTraversor(new Accumulator(elements, eval)).traverse(root);\n         return elements;\n     }\n \n-    private static void accumulateMatches(Evaluator eval, List<Element> elements, Element element) {\n-        if (eval.matches(element))\n-            elements.add(element);\n-        for (Element child: element.children())\n-            accumulateMatches(eval, elements, child);\n+    private static class Accumulator implements NodeVisitor {\n+        private Elements elements;\n+        private Evaluator eval;\n+\n+        Accumulator(Elements elements, Evaluator eval) {\n+            this.elements = elements;\n+            this.eval = eval;\n+        }\n+\n+        public void head(Node node, int depth) {\n+            if (node instanceof Element) {\n+                Element el = (Element) node;\n+                if (eval.matches(el))\n+                    elements.add(el);\n+            }\n+        }\n+\n+        public void tail(Node node, int depth) {\n+            // void\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n+package org.jsoup.select;\n+\n+import org.jsoup.nodes.Node;\n+\n+/**\n+ * Breadth first node traversor.\n+ */\n+public class NodeTraversor {\n+    private NodeVisitor visitor;\n+\n+    public NodeTraversor(NodeVisitor visitor) {\n+        this.visitor = visitor;\n+    }\n+\n+    public void traverse(Node root) {\n+        Node node = root;\n+        int depth = 0;\n+        \n+        while (node != null) {\n+            visitor.head(node, depth);\n+            if (node.childNodes().size() > 0) {\n+                node = node.childNode(0);\n+                depth++;\n+            } else {\n+                while (node.nextSibling() == null && depth > 0) {\n+                    visitor.tail(node, depth);\n+                    node = node.parent();\n+                    depth--;\n+                }\n+                visitor.tail(node, depth);\n+                if (node == root)\n+                    break;\n+                node = node.nextSibling();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/NodeVisitor.java\n+package org.jsoup.select;\n+\n+import org.jsoup.nodes.Node;\n+\n+/**\n+ * Node visitor interface\n+ */\n+public interface NodeVisitor {\n+    public void head(Node node, int depth);\n+    public void tail(Node node, int depth);\n+}\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n     @Test public void testFormatHtml() {\n         Document doc = Jsoup.parse(\"<div><p>Hello</p></div>\");\n-        assertEquals(\"<html>\\n<head>\\n</head>\\n<body>\\n <div>\\n  <p>Hello</p>\\n </div>\\n</body>\\n</html>\", doc.html());\n+        assertEquals(\"<html>\\n <head>\\n </head>\\n <body>\\n  <div>\\n   <p>Hello</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n     }\n \n     @Test public void testSetText() {", "timestamp": 1309605114, "metainfo": ""}