{"sha": "79c672355bb31aa69c23d2dd1ed8cc3f89dd2844", "log": "New: E + F adjacent sibling selector, E ~ F preceding sibling.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n         List<Element> siblings = parent().children();\n         return siblings.size() > 1 ? siblings.get(0) : null;\n     }\n+    \n+    /**\n+     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n+     * sibling, returns 0.\n+     * @return position in element sibling list\n+     */\n+    public Integer elementSiblingIndex() {\n+       return indexInList(this, parent().children()); \n+    }\n \n     /**\n      * Gets the last element sibling of this element\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n         }\n         return accum.toString();\n     }\n+    \n+    public String toString() {\n+        return queue.toString();\n+    }\n }\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n- <tr><td><code>E > F</code></td><td>an F child of E</td><td><code> ol > li</code></td></tr>\n+ <tr><td><code>E > F</code></td><td>an F child of E</td><td><code>ol > li</code></td></tr>\n+ <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n+ <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  <tr><td><code>E, F, G</code></td><td>any matching element E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  </table>\n \n  @see Element#select(String)\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Selector {\n+    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n     private final Element root;\n     private final LinkedHashSet<Element> elements; // LHS for unique and ordered elements\n     private final String query;\n                     String subQuery = tq.chompTo(\",\");\n                     elements.addAll(select(subQuery, root));\n                 }\n-            } else if (tq.matchChomp(\">\")) { // parent > child\n-                String subQuery = tq.chompTo(\">\"); // support multi > childs\n-                Elements candidates = select(subQuery, elements);\n-                Elements children = filterForChildren(elements, candidates);\n-                elements.clear(); elements.addAll(children);\n-            } else if (seenWhite) { // ancestor descendant\n-                Elements candidates = select(tq.remainder(), elements);\n-                return filterForDescendants(elements, candidates);\n+            } else if (tq.matchesAny(combinators)) {\n+                combinator(tq.consume().toString());\n+            } else if (seenWhite) {\n+                combinator(\" \");\n             } else { // E.class, E#id, E[attr] etc. AND\n                 Elements candidates = findElements(); // take next el, #. etc off queue\n                 intersectElements(filterForSelf(elements, candidates));\n             }\n         }\n         return new Elements(elements);\n+    }\n+    \n+    private void combinator(String combinator) {\n+        tq.consumeWhitespace();\n+        String subQuery = tq.consumeToAny(combinators); // support multi > childs\n+        \n+        Elements output;\n+        if (combinator.equals(\">\"))\n+            output = filterForChildren(elements, select(subQuery, elements));\n+        else if (combinator.equals(\" \"))\n+            output = filterForDescendants(elements, select(subQuery, elements));\n+        else if (combinator.equals(\"+\"))\n+            output = filterForAdjacentSiblings(elements, select(subQuery, root));\n+        else if (combinator.equals(\"~\"))\n+            output = filterForGeneralSiblings(elements, select(subQuery, root));\n+        else\n+            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n+        \n+        elements.clear(); elements.addAll(output);\n     }\n     \n     private Elements findElements() {\n         Elements children = new Elements();\n         CHILD: for (Element c : candidates) {\n             for (Element p : parents) {\n-                if (c.parent().equals(p)) {\n+                if (c.parent() != null && c.parent().equals(p)) {\n                     children.add(c);\n                     continue CHILD;\n                 }\n         return children;\n     }\n     \n+    // adjacent siblings\n+    private static Elements filterForAdjacentSiblings(Collection<Element> elements, Collection<Element> candidates) {\n+        Elements siblings = new Elements();\n+        SIBLING: for (Element c: candidates) {\n+            for (Element e: elements) {\n+                if (!e.parent().equals(c.parent()))\n+                    continue;\n+                Element previousSib = c.previousElementSibling();\n+                if (previousSib != null && previousSib.equals(e)) {\n+                    siblings.add(c);\n+                    continue SIBLING;\n+                }\n+            }\n+        }\n+        return siblings;\n+    }\n+    \n+    // preceeding siblings\n+    private static Elements filterForGeneralSiblings(Collection<Element> elements, Collection<Element> candidates) {\n+        Elements output = new Elements();\n+        SIBLING: for (Element c: candidates) {\n+            for (Element e: elements) {\n+                if (!e.parent().equals(c.parent()))\n+                    continue;\n+                int ePos = e.elementSiblingIndex();\n+                int cPos = c.elementSiblingIndex();\n+                if (cPos > ePos) {\n+                    output.add(c);\n+                    continue SIBLING;\n+                }\n+            }\n+        }\n+        return output;\n+    }\n+    \n     // union of both sets, for e.class type selectors\n     private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n         Elements children = new Elements();\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n+import org.jsoup.select.Elements;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n         assertEquals(\"this\", p.nextElementSibling().text());\n         assertEquals(\"Hello\", p.firstElementSibling().text());\n         assertEquals(\"element\", p.lastElementSibling().text());\n+    }\n+    \n+    @Test public void testElementSiblingIndex() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p>...<p>Two</p>...<p>Three</p>\");\n+        Elements ps = doc.select(\"p\");\n+        assertTrue(0 == ps.get(0).elementSiblingIndex());\n+        assertTrue(1 == ps.get(1).elementSiblingIndex());\n+        assertTrue(2 == ps.get(2).elementSiblingIndex());\n     }\n \n     @Test public void testGetElementsWithClass() {\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(1, doc.select(\"DIV[TITLE=BAR]\").size());\n         assertEquals(0, doc.select(\"DIV[TITLE=BARBARELLA\").size());\n     }\n+    \n+    @Test public void adjacentSiblings() {\n+        String h = \"<ol><li>One<li>Two<li>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = doc.select(\"li + li\");\n+        assertEquals(2, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+        assertEquals(\"Three\", sibs.get(1).text());\n+    }\n+    \n+    @Test public void adjacentSiblingsWithId() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = doc.select(\"li#1 + li#2\");\n+        assertEquals(1, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+    }\n+    \n+    @Test public void notAdjacent() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = doc.select(\"li#1 + li#3\");\n+        assertEquals(0, sibs.size());\n+    }\n+    \n+    @Test public void mixCombinator() {\n+        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = doc.select(\"body > div.foo li + li\");\n+        \n+        assertEquals(2, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+        assertEquals(\"Three\", sibs.get(1).text());\n+    }\n+    \n+    @Test public void mixCombinatorGroup() {\n+        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = doc.select(\".foo > ol, ol > li + li\");\n+        \n+        assertEquals(3, els.size());\n+        assertEquals(\"ol\", els.get(0).tagName());\n+        assertEquals(\"Two\", els.get(1).text());\n+        assertEquals(\"Three\", els.get(2).text());\n+    }\n+    \n+    @Test public void generalSiblings() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = doc.select(\"#1 ~ #3\");\n+        assertEquals(1, els.size());\n+        assertEquals(\"Three\", els.first().text());\n+    }\n }", "timestamp": 1309605109, "metainfo": ""}